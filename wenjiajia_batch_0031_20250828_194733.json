{
  "metadata": {
    "batch_number": 31,
    "batch_size": 100,
    "problems_in_batch": 100,
    "total_processed": 3200,
    "created_at": "2025-08-28T19:47:33.483317",
    "format": "wenjiajia_v1.0_incremental"
  },
  "problems": [
    {
      "problem_id": "176/C",
      "title": "C. Playing with Superglue",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains six integers n, m, x1, y1, x2, y2 — the board sizes and the coordinates of the first and second chips, correspondingly (1 ≤ n, m ≤ 100; 2 ≤ n × m; 1 ≤ x1, x2 ≤ n; 1 ≤ y1, y2 ≤ m). The numbers in the line are separated by single spaces.It is guaranteed that the chips are located in different squares.",
      "output_spec": "OutputIf the first player wins, print \"First\" without the quotes. Otherwise, print \"Second\" without the quotes.",
      "sample_tests": "ExamplesInputCopy1 6 1 2 1 6OutputCopyFirstInputCopy6 5 4 3 2 1OutputCopyFirstInputCopy10 10 1 1 10 10OutputCopySecond",
      "description": "C. Playing with Superglue\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains six integers n, m, x1, y1, x2, y2 — the board sizes and the coordinates of the first and second chips, correspondingly (1 ≤ n, m ≤ 100; 2 ≤ n × m; 1 ≤ x1, x2 ≤ n; 1 ≤ y1, y2 ≤ m). The numbers in the line are separated by single spaces.It is guaranteed that the chips are located in different squares.\n\nOutputIf the first player wins, print \"First\" without the quotes. Otherwise, print \"Second\" without the quotes.\n\nInputCopy1 6 1 2 1 6OutputCopyFirstInputCopy6 5 4 3 2 1OutputCopyFirstInputCopy10 10 1 1 10 10OutputCopySecond\n\nInputCopy1 6 1 2 1 6\n\nOutputCopyFirst\n\nInputCopy6 5 4 3 2 1\n\nOutputCopyFirst\n\nInputCopy10 10 1 1 10 10\n\nOutputCopySecond",
      "solutions": [
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces",
          "content": "Hello everyone!Today is the second round of the Open Moscow Programming Championship By CROC will be. Start is planned at 19:00.Competition will happen by usual rules of Codeforces, with hacks and score falling in process of time. All contestants who passed score no less than contectant of the 300-th place in the Round 1, can participate in the Round 2. Every other contestants can patricipate the Round 2 out of competition. Specially for contestants of the second division we prepared more easy unofficial problemset. The official problemset and the unnoficial one have some common tasks.Round will be rated for all participants.Some number of problems are waiting you. They are roughly ordered by the increasing complexity. Score distribution is standard for both divisions (500-1000-1500-2000-2500). Don't forget that during contest your solutions will be tested on a small set of pretests. Testing on full testset will be after end of the round. Pretests can don't cover all cases of input data, so you should test your solutions very carefully.It is strictly forbidden to publish statements/solutions of the problems before round will be end. Also you shouldn't to talk about problems, discuss some things about possible solutions of them. Let's be honest! You can discuss problems after the end of round.Top 50 contestant will be allowed to the Final Round. Also all contestant with score not less than score of the 50-th contestant will be passed.The round was prepared by Ripatti, havaliza, Gerald, RAD, MikeMirzayanov, Delinur.Good luck for all!UPD. We remind that the final of the Open Championship of Moscow and Moscow Region Programming (CROC) take place on April 27 in the office of the CROC. Note that CROC does not pay for the road and residence of the finalists. All participants must arrive at the final in the office of the CROC (Moscow) in the morning on April 27.After the competition all participants will be provided to fill the form on the ability to participate in the finals of the competition. The first 50 participants on the results of the competition, which will confirm their participation in the finals, will be invited to final competition. You can confirm participation in the finals during the day after the end of Round 2.It is recommended to fill the form, regardless of your results in Round 2, as large number of participants can reject the participation in the final.",
          "author": "Ripatti",
          "url": "https://codeforces.com/blog/entry/4370",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2409
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces",
          "content": "A div2. Required row is row that have only one star inside. Requred column is comumn that also have only one star inside. So, you can iterate over all rows/columns, calculate number of stars inside them and find the answer.Authors are MikeMirzayanov, Gerald .B div2. Naive solution O(n3) (where you check all triplets) doesn't fin into time limits.You can see that for every two points from triplet (for example, for A and C) you can find place of the third point. So you can find number of requred triplets just inerate over all pairs of points and check middle point between points in every pair.How to fast check position? You can add 1000 for all coordinates (you can see that this operation doesn't change the answer) and mark them in the 2-dimensional boolean array 2001х2001. So you can check every position for point in O(1) time.Obtained solution works in O(n2).Authors are MikeMirzayanov, GeraldA div1. C div2. In this problem some greedy solution expected.Let fix 2 planets: in planet i we will buy items, in planet j we will sell the ones. Profit of item of type k will be b_jk-a_ik. Every item has size 1, so you should greedy take items in order of decreasing of profits of items while you have place in the hold.Scheme of full solution: you should iterate over all pairs of planet, for every pair greedy take items and find total profit. At the end you should find maximal total profit over all pairs and output it.Author is RipattiB div1. D div2. You can see that split oparetion is just cyclically shift of string. You can go from any cyclically shift to any other one except the current one.Let's call some cyclically shift good iff it equal to the final string. All others cyclically shifts we will call bad. You can check all shifts in O(|w|2) time. Let's you have A good shifts and B bad ones.Let's define dpA[n] as number of ways to get some good shift using n splits and за dpB[n] as number of ways to get some bad shift using n splits.dpA[0]=1, dpB[0]=0 or dpA[0]=0, dpB[0]=1 according to the first shift is good or not. All other values of dp you can get using following reccurences:dpA[n] = dpA[n-1] * (A-1) + dpB[n-1] * AdpB[n] = dpA[n-1] * B + dpB[n-1] * (B-1)Answer will be dpA[k]. So you have O(|w|2 + k) solution.Also this problem can be solved in time.Author is havalizaC div1. E div2. The second player have easy strategy to hold some chip in position (X, Y) in one of four half-planes — x ≤ X + 2, x ≥ X - 2, y ≤ Y + 2 и y ≥ Y - 2. He can chose one of these half-planes by himself.So, in case max(|x1 - x2|, |y1 - y2|) > 4 the second player wins — he just holds chips in half-planes that have no common cells.Cases for max(|x1 - x2|, |y1 - y2|) ≤ 4 expected to solve using some bruteforce. You can see that moving chips in way of distancing from each other is not profitable for the first player. Therefore you can bruteforce the game in square no more than 5 × 5. If your bruteforce so slow and doesn't fit into 2 sec, you can use precalculation. Also you can write some dp using masks.Also you can check cases max(|x1 - x2|, |y1 - y2|) ≤ 4 by hand. But there you can easy make some mistakes.Author is RipattiD div1. Let's define dp[pre][len] as the minimal prefix of hyperstring that have with prefix of t of length len largest common sequence of length len.Then you have see reccurences:dp[pre][len] = min(dp[pre - 1][len],  leftmost position of letter s[pre] in t that right than dp[pre - 1][len - 1]).For finding value of the second part inside min-function of formula above in O(1), you should calculate some additional dp's: dp1 — for every basic string, positions inside of them and letter you should calculate leftmost position of current letter that right than current position;dp2 — for every element of array of basic strings (it is hyperstring) and letter you should calculate leftmost basic string that have current letter and this string is rinht than current basic string.So you have solution.Author is havaliza.E div1. At the first let's try to solve another problem: we have k chosed vertices in the tree and we want to find sum of subtree that \"spanned\" dy them in time (with any preprocessing time).Let's sort all k vertices in order of dfs traversal — v1, v2, ... , vk. Consider pathes v1-v2, v2-v3, ... , v(k-1)-vk and vk-v1. You can see that they cover only our requred subtree and every edge is covered exactly two times. So you can just find sum of lengths of these pathes (you can do it in required time using LCA algo) and divide obtained value by 2.For solving initial problem you should support set of active vertices in ordered state (for example, you can use std::set) and sum of all pathes between all neighbour vertices. Now you can process insert/remove queries in , and recalculate sum of pathes by finding no more than 3 new pathes also in .So you have solution.Author is Ripatti.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4372",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4850
        }
      ],
      "code_examples": [
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 1",
          "code": "x...\n....\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 2",
          "code": "x...\n....\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 3",
          "code": "x...\n.!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 4",
          "code": "x...\n.!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 5",
          "code": "x...\n.!..\n....\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 6",
          "code": "x...\n.!..\n....\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 7",
          "code": "x...\n.!..\n.!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 8",
          "code": "x...\n.!..\n.!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 9",
          "code": "....\nx!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 10",
          "code": "....\nx!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 11",
          "code": "....\nx!..\n!...\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 12",
          "code": "....\nx!..\n!...\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 13",
          "code": "....\nx!..\n!...\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 14",
          "code": "....\nx!..\n!...\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 15",
          "code": "....\nx!..\n!!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 16",
          "code": "....\nx!..\n!!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces - Code 1",
          "code": "dpA[n] = dpA[n-1]*(A-1) + dpB[n-1]*A\ndpB[n] = dpA[n-1]*B + dpB[n-1](B-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4372",
          "author": "jiangly"
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces - Code 2",
          "code": "dpA[n] = dpA[n-1]*(A-1) + dpB[n-1]*A\ndpB[n] = dpA[n-1]*B + dpB[n-1](B-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4372",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int x1 = inf.readInt(1, n, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(1, m, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(1, n, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(1, m, \"y2\");\n    inf.readEoln();\n\n    ensuref(n * m >= 2, \"n * m must be at least 2\");\n    ensuref(!(x1 == x2 && y1 == y2), \"Chips must be on different squares\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int x1 = inf.readInt(1, n, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(1, m, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(1, n, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(1, m, \"y2\");\n    inf.readEoln();\n\n    ensuref(n * m >= 2, \"n * m must be at least 2\");\n    ensuref(!(x1 == x2 && y1 == y2), \"Chips must be on different squares\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int x1 = inf.readInt(1, n, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(1, m, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(1, n, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(1, m, \"y2\");\n    inf.readEoln();\n\n    ensuref(n * m >= 2, \"n * m must be at least 2\");\n    ensuref(!(x1 == x2 && y1 == y2), \"Chips must be on different squares\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters with default values\n    int n = opt<int>(\"n\", 10);\n    int m = opt<int>(\"m\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and m are within bounds\n    n = max(1, min(100, n));\n    m = max(1, min(100, m));\n\n    // Ensure n * m ≥ 2\n    if (n * m < 2) {\n        if (n == 1) {\n            m = 2;\n        } else {\n            n = 2;\n        }\n    }\n\n    int x1, y1, x2, y2;\n\n    if (type == \"random\") {\n        // Generate random positions\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n        do {\n            x2 = rnd.next(1, n);\n            y2 = rnd.next(1, m);\n        } while (x1 == x2 && y1 == y2);\n    } else if (type == \"close\") {\n        // Generate positions that are close\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n\n        // Generate a neighboring position\n        int dx[] = {-2, -1, 0, 1, 2};\n        int dy[] = {-2, -1, 0, 1, 2};\n        while (true) {\n            int nx = x1 + dx[rnd.next(0, 4)];\n            int ny = y1 + dy[rnd.next(0, 4)];\n            if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && (nx != x1 || ny != y1)) {\n                x2 = nx;\n                y2 = ny;\n                break;\n            }\n        }\n    } else if (type == \"far\") {\n        // Generate positions that are far apart\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n\n        // Set x2 and y2 far from x1 and y1\n        x2 = (x1 + n / 2) % n + 1;\n        y2 = (y1 + m / 2) % m + 1;\n        if (x1 == x2 && y1 == y2) {\n            x2 = x1 == n ? 1 : n;\n        }\n    } else if (type == \"boundary\") {\n        // Place chips on boundary positions\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(0, 1) == 0 ? 1 : m;\n        x2 = rnd.next(1, n);\n        y2 = y1 == 1 ? m : 1;\n        if (x1 == x2 && y1 == y2) {\n            x2 = x2 % n + 1;\n        }\n    } else if (type == \"max_diff\") {\n        // Generate positions where abs(x1 - x2) or abs(y1 - y2) is at the boundary\n        int dx_list[] = {4, 5};\n        int dy_list[] = {4, 5};\n\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n\n        int dx = dx_list[rnd.next(0, 1)] * (rnd.next(0, 1) == 0 ? 1 : -1);\n        int dy = dy_list[rnd.next(0, 1)] * (rnd.next(0, 1) == 0 ? 1 : -1);\n\n        x2 = x1 + dx;\n        y2 = y1 + dy;\n\n        // Wrap around if out of bounds\n        x2 = (x2 - 1 + n) % n + 1;\n        y2 = (y2 - 1 + m) % m + 1;\n\n        if (x1 == x2 && y1 == y2) {\n            y2 = y2 % m + 1;\n        }\n    } else if (type == \"min\") {\n        // Use minimal n and m (n x m ≥ 2)\n        n = 1;\n        m = 2;\n        x1 = 1;\n        y1 = 1;\n        x2 = 1;\n        y2 = 2;\n    } else if (type == \"max\") {\n        // Use maximal n and m (n = m = 100)\n        n = m = 100;\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n        do {\n            x2 = rnd.next(1, n);\n            y2 = rnd.next(1, m);\n        } while (x1 == x2 && y1 == y2);\n    } else {\n        // Default to random positions\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n        do {\n            x2 = rnd.next(1, n);\n            y2 = rnd.next(1, m);\n        } while (x1 == x2 && y1 == y2);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d %d %d\\n\", n, m, x1, y1, x2, y2);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters with default values\n    int n = opt<int>(\"n\", 10);\n    int m = opt<int>(\"m\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and m are within bounds\n    n = max(1, min(100, n));\n    m = max(1, min(100, m));\n\n    // Ensure n * m ≥ 2\n    if (n * m < 2) {\n        if (n == 1) {\n            m = 2;\n        } else {\n            n = 2;\n        }\n    }\n\n    int x1, y1, x2, y2;\n\n    if (type == \"random\") {\n        // Generate random positions\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n        do {\n            x2 = rnd.next(1, n);\n            y2 = rnd.next(1, m);\n        } while (x1 == x2 && y1 == y2);\n    } else if (type == \"close\") {\n        // Generate positions that are close\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n\n        // Generate a neighboring position\n        int dx[] = {-2, -1, 0, 1, 2};\n        int dy[] = {-2, -1, 0, 1, 2};\n        while (true) {\n            int nx = x1 + dx[rnd.next(0, 4)];\n            int ny = y1 + dy[rnd.next(0, 4)];\n            if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && (nx != x1 || ny != y1)) {\n                x2 = nx;\n                y2 = ny;\n                break;\n            }\n        }\n    } else if (type == \"far\") {\n        // Generate positions that are far apart\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n\n        // Set x2 and y2 far from x1 and y1\n        x2 = (x1 + n / 2) % n + 1;\n        y2 = (y1 + m / 2) % m + 1;\n        if (x1 == x2 && y1 == y2) {\n            x2 = x1 == n ? 1 : n;\n        }\n    } else if (type == \"boundary\") {\n        // Place chips on boundary positions\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(0, 1) == 0 ? 1 : m;\n        x2 = rnd.next(1, n);\n        y2 = y1 == 1 ? m : 1;\n        if (x1 == x2 && y1 == y2) {\n            x2 = x2 % n + 1;\n        }\n    } else if (type == \"max_diff\") {\n        // Generate positions where abs(x1 - x2) or abs(y1 - y2) is at the boundary\n        int dx_list[] = {4, 5};\n        int dy_list[] = {4, 5};\n\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n\n        int dx = dx_list[rnd.next(0, 1)] * (rnd.next(0, 1) == 0 ? 1 : -1);\n        int dy = dy_list[rnd.next(0, 1)] * (rnd.next(0, 1) == 0 ? 1 : -1);\n\n        x2 = x1 + dx;\n        y2 = y1 + dy;\n\n        // Wrap around if out of bounds\n        x2 = (x2 - 1 + n) % n + 1;\n        y2 = (y2 - 1 + m) % m + 1;\n\n        if (x1 == x2 && y1 == y2) {\n            y2 = y2 % m + 1;\n        }\n    } else if (type == \"min\") {\n        // Use minimal n and m (n x m ≥ 2)\n        n = 1;\n        m = 2;\n        x1 = 1;\n        y1 = 1;\n        x2 = 1;\n        y2 = 2;\n    } else if (type == \"max\") {\n        // Use maximal n and m (n = m = 100)\n        n = m = 100;\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n        do {\n            x2 = rnd.next(1, n);\n            y2 = rnd.next(1, m);\n        } while (x1 == x2 && y1 == y2);\n    } else {\n        // Default to random positions\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n        do {\n            x2 = rnd.next(1, n);\n            y2 = rnd.next(1, m);\n        } while (x1 == x2 && y1 == y2);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d %d %d\\n\", n, m, x1, y1, x2, y2);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 2 -type min\n./gen -n 2 -m 1 -type min\n./gen -n 100 -m 100 -type max\n\n./gen -n 10 -m 10 -type random\n./gen -n 50 -m 50 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type random\n\n./gen -n 10 -m 10 -type close\n./gen -n 50 -m 50 -type close\n./gen -n 100 -m 100 -type close\n\n./gen -n 10 -m 10 -type far\n./gen -n 50 -m 50 -type far\n./gen -n 100 -m 100 -type far\n\n./gen -n 10 -m 10 -type boundary\n./gen -n 50 -m 50 -type boundary\n./gen -n 100 -m 100 -type boundary\n\n./gen -n 10 -m 10 -type max_diff\n./gen -n 50 -m 50 -type max_diff\n./gen -n 100 -m 100 -type max_diff\n\n./gen -n 1 -m 100 -type random\n./gen -n 100 -m 1 -type random\n\n./gen -n 2 -m 50 -type far\n./gen -n 50 -m 2 -type far\n\n./gen -n 1 -m 99 -type boundary\n./gen -n 99 -m 1 -type boundary\n\n./gen -n 99 -m 99 -type close\n./gen -n 99 -m 99 -type far\n./gen -n 99 -m 99 -type max_diff\n\n./gen -n 1 -m 2 -type max_diff\n./gen -n 2 -m 1 -type max_diff\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:15.812878",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "176/D",
      "title": "D. Hyper String",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains the single integer n (1 ≤ n ≤ 2000) — the number of base strings. The next n lines contains values of base strings. Each base string is made of lowercase Latin letters. A base string cannot be empty string and the sum of lengths of all n base strings doesn't exceed 106. The next line contains the single integer m (1 ≤ m ≤ 2000) — the number of base strings in the given Hyper String t. The next line contains m space-separated integer numbers i1, i2, ..., im (1 ≤ ij ≤ n) — the indices of base strings in the Hyper String t.The last line contains a non-empty string s. String s is made of lowercase Latin letters and its length is no more than 2000 characters.",
      "output_spec": "OutputPrint the length of longest common sub-sequence of Hyper String t and string s. If there is no common sub-sequence print 0.",
      "sample_tests": "ExamplesInputCopy2cbadgh21 2aedfhrOutputCopy3InputCopy2ba51 2 1 2 1aaaOutputCopy2",
      "description": "D. Hyper String\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains the single integer n (1 ≤ n ≤ 2000) — the number of base strings. The next n lines contains values of base strings. Each base string is made of lowercase Latin letters. A base string cannot be empty string and the sum of lengths of all n base strings doesn't exceed 106. The next line contains the single integer m (1 ≤ m ≤ 2000) — the number of base strings in the given Hyper String t. The next line contains m space-separated integer numbers i1, i2, ..., im (1 ≤ ij ≤ n) — the indices of base strings in the Hyper String t.The last line contains a non-empty string s. String s is made of lowercase Latin letters and its length is no more than 2000 characters.\n\nOutputPrint the length of longest common sub-sequence of Hyper String t and string s. If there is no common sub-sequence print 0.\n\nInputCopy2cbadgh21 2aedfhrOutputCopy3InputCopy2ba51 2 1 2 1aaaOutputCopy2\n\nInputCopy2cbadgh21 2aedfhr\n\nOutputCopy3\n\nInputCopy2ba51 2 1 2 1aaa\n\nOutputCopy2\n\nNoteThe length of string s is the number of characters in it. If the length of string s is marked as |s|, then string s can be represented as s = s1s2... s|s|.A non-empty string y = s[p1p2... p|y|] = sp1sp2... sp|y| (1 ≤ p1 < p2 < ... < p|y| ≤ |s|) is a subsequence of string s. For example, \"coders\" is a subsequence of \"codeforces\".",
      "solutions": [
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces",
          "content": "Hello everyone!Today is the second round of the Open Moscow Programming Championship By CROC will be. Start is planned at 19:00.Competition will happen by usual rules of Codeforces, with hacks and score falling in process of time. All contestants who passed score no less than contectant of the 300-th place in the Round 1, can participate in the Round 2. Every other contestants can patricipate the Round 2 out of competition. Specially for contestants of the second division we prepared more easy unofficial problemset. The official problemset and the unnoficial one have some common tasks.Round will be rated for all participants.Some number of problems are waiting you. They are roughly ordered by the increasing complexity. Score distribution is standard for both divisions (500-1000-1500-2000-2500). Don't forget that during contest your solutions will be tested on a small set of pretests. Testing on full testset will be after end of the round. Pretests can don't cover all cases of input data, so you should test your solutions very carefully.It is strictly forbidden to publish statements/solutions of the problems before round will be end. Also you shouldn't to talk about problems, discuss some things about possible solutions of them. Let's be honest! You can discuss problems after the end of round.Top 50 contestant will be allowed to the Final Round. Also all contestant with score not less than score of the 50-th contestant will be passed.The round was prepared by Ripatti, havaliza, Gerald, RAD, MikeMirzayanov, Delinur.Good luck for all!UPD. We remind that the final of the Open Championship of Moscow and Moscow Region Programming (CROC) take place on April 27 in the office of the CROC. Note that CROC does not pay for the road and residence of the finalists. All participants must arrive at the final in the office of the CROC (Moscow) in the morning on April 27.After the competition all participants will be provided to fill the form on the ability to participate in the finals of the competition. The first 50 participants on the results of the competition, which will confirm their participation in the finals, will be invited to final competition. You can confirm participation in the finals during the day after the end of Round 2.It is recommended to fill the form, regardless of your results in Round 2, as large number of participants can reject the participation in the final.",
          "author": "Ripatti",
          "url": "https://codeforces.com/blog/entry/4370",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2409
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces",
          "content": "A div2. Required row is row that have only one star inside. Requred column is comumn that also have only one star inside. So, you can iterate over all rows/columns, calculate number of stars inside them and find the answer.Authors are MikeMirzayanov, Gerald .B div2. Naive solution O(n3) (where you check all triplets) doesn't fin into time limits.You can see that for every two points from triplet (for example, for A and C) you can find place of the third point. So you can find number of requred triplets just inerate over all pairs of points and check middle point between points in every pair.How to fast check position? You can add 1000 for all coordinates (you can see that this operation doesn't change the answer) and mark them in the 2-dimensional boolean array 2001х2001. So you can check every position for point in O(1) time.Obtained solution works in O(n2).Authors are MikeMirzayanov, GeraldA div1. C div2. In this problem some greedy solution expected.Let fix 2 planets: in planet i we will buy items, in planet j we will sell the ones. Profit of item of type k will be b_jk-a_ik. Every item has size 1, so you should greedy take items in order of decreasing of profits of items while you have place in the hold.Scheme of full solution: you should iterate over all pairs of planet, for every pair greedy take items and find total profit. At the end you should find maximal total profit over all pairs and output it.Author is RipattiB div1. D div2. You can see that split oparetion is just cyclically shift of string. You can go from any cyclically shift to any other one except the current one.Let's call some cyclically shift good iff it equal to the final string. All others cyclically shifts we will call bad. You can check all shifts in O(|w|2) time. Let's you have A good shifts and B bad ones.Let's define dpA[n] as number of ways to get some good shift using n splits and за dpB[n] as number of ways to get some bad shift using n splits.dpA[0]=1, dpB[0]=0 or dpA[0]=0, dpB[0]=1 according to the first shift is good or not. All other values of dp you can get using following reccurences:dpA[n] = dpA[n-1] * (A-1) + dpB[n-1] * AdpB[n] = dpA[n-1] * B + dpB[n-1] * (B-1)Answer will be dpA[k]. So you have O(|w|2 + k) solution.Also this problem can be solved in time.Author is havalizaC div1. E div2. The second player have easy strategy to hold some chip in position (X, Y) in one of four half-planes — x ≤ X + 2, x ≥ X - 2, y ≤ Y + 2 и y ≥ Y - 2. He can chose one of these half-planes by himself.So, in case max(|x1 - x2|, |y1 - y2|) > 4 the second player wins — he just holds chips in half-planes that have no common cells.Cases for max(|x1 - x2|, |y1 - y2|) ≤ 4 expected to solve using some bruteforce. You can see that moving chips in way of distancing from each other is not profitable for the first player. Therefore you can bruteforce the game in square no more than 5 × 5. If your bruteforce so slow and doesn't fit into 2 sec, you can use precalculation. Also you can write some dp using masks.Also you can check cases max(|x1 - x2|, |y1 - y2|) ≤ 4 by hand. But there you can easy make some mistakes.Author is RipattiD div1. Let's define dp[pre][len] as the minimal prefix of hyperstring that have with prefix of t of length len largest common sequence of length len.Then you have see reccurences:dp[pre][len] = min(dp[pre - 1][len],  leftmost position of letter s[pre] in t that right than dp[pre - 1][len - 1]).For finding value of the second part inside min-function of formula above in O(1), you should calculate some additional dp's: dp1 — for every basic string, positions inside of them and letter you should calculate leftmost position of current letter that right than current position;dp2 — for every element of array of basic strings (it is hyperstring) and letter you should calculate leftmost basic string that have current letter and this string is rinht than current basic string.So you have solution.Author is havaliza.E div1. At the first let's try to solve another problem: we have k chosed vertices in the tree and we want to find sum of subtree that \"spanned\" dy them in time (with any preprocessing time).Let's sort all k vertices in order of dfs traversal — v1, v2, ... , vk. Consider pathes v1-v2, v2-v3, ... , v(k-1)-vk and vk-v1. You can see that they cover only our requred subtree and every edge is covered exactly two times. So you can just find sum of lengths of these pathes (you can do it in required time using LCA algo) and divide obtained value by 2.For solving initial problem you should support set of active vertices in ordered state (for example, you can use std::set) and sum of all pathes between all neighbour vertices. Now you can process insert/remove queries in , and recalculate sum of pathes by finding no more than 3 new pathes also in .So you have solution.Author is Ripatti.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4372",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4850
        }
      ],
      "code_examples": [
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 1",
          "code": "x...\n....\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 2",
          "code": "x...\n....\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 3",
          "code": "x...\n.!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 4",
          "code": "x...\n.!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 5",
          "code": "x...\n.!..\n....\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 6",
          "code": "x...\n.!..\n....\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 7",
          "code": "x...\n.!..\n.!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 8",
          "code": "x...\n.!..\n.!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 9",
          "code": "....\nx!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 10",
          "code": "....\nx!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 11",
          "code": "....\nx!..\n!...\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 12",
          "code": "....\nx!..\n!...\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 13",
          "code": "....\nx!..\n!...\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 14",
          "code": "....\nx!..\n!...\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 15",
          "code": "....\nx!..\n!!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 16",
          "code": "....\nx!..\n!!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces - Code 1",
          "code": "dpA[n] = dpA[n-1]*(A-1) + dpB[n-1]*A\ndpB[n] = dpA[n-1]*B + dpB[n-1](B-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4372",
          "author": "Qingyu"
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces - Code 2",
          "code": "dpA[n] = dpA[n-1]*(A-1) + dpB[n-1]*A\ndpB[n] = dpA[n-1]*B + dpB[n-1](B-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4372",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n    \n    long long total_base_length = 0;\n    for(int i = 0; i < n; i++) {\n        string base_str = inf.readLine(\"[a-z]+\", \"base_string\");\n        total_base_length += (long long)base_str.size();\n    }\n    ensuref(total_base_length <= 1000000LL, \n            \"Sum of lengths of base strings should not exceed 1e6, but is %lld\", total_base_length);\n    \n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n    \n    vector<int> indices = inf.readInts(m, 1, n, \"indices\");\n    inf.readEoln();\n    \n    string s = inf.readLine(\"[a-z]+\", \"s\");\n    int s_length = (int)s.size();\n    ensuref(s_length >= 1, \"s should be non-empty\");\n    ensuref(s_length <= 2000, \"Length of s should not exceed 2000, but is %d\", s_length);\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n    \n    long long total_base_length = 0;\n    for(int i = 0; i < n; i++) {\n        string base_str = inf.readLine(\"[a-z]+\", \"base_string\");\n        total_base_length += (long long)base_str.size();\n    }\n    ensuref(total_base_length <= 1000000LL, \n            \"Sum of lengths of base strings should not exceed 1e6, but is %lld\", total_base_length);\n    \n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n    \n    vector<int> indices = inf.readInts(m, 1, n, \"indices\");\n    inf.readEoln();\n    \n    string s = inf.readLine(\"[a-z]+\", \"s\");\n    int s_length = (int)s.size();\n    ensuref(s_length >= 1, \"s should be non-empty\");\n    ensuref(s_length <= 2000, \"Length of s should not exceed 2000, but is %d\", s_length);\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n    \n    long long total_base_length = 0;\n    for(int i = 0; i < n; i++) {\n        string base_str = inf.readLine(\"[a-z]+\", \"base_string\");\n        total_base_length += (long long)base_str.size();\n    }\n    ensuref(total_base_length <= 1000000LL, \n            \"Sum of lengths of base strings should not exceed 1e6, but is %lld\", total_base_length);\n    \n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n    \n    vector<int> indices = inf.readInts(m, 1, n, \"indices\");\n    inf.readEoln();\n    \n    string s = inf.readLine(\"[a-z]+\", \"s\");\n    int s_length = (int)s.size();\n    ensuref(s_length >= 1, \"s should be non-empty\");\n    ensuref(s_length <= 2000, \"Length of s should not exceed 2000, but is %d\", s_length);\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Maximum total length of base strings\nconst int MAX_TOTAL_BASE_LENGTH = 1e6;\nconst int MAX_S_LENGTH = 2000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Number of base strings\n    int m = opt<int>(\"m\"); // Number of indices in hyper string t\n    int s_len_param = opt<int>(\"s_len\", MAX_S_LENGTH); // Length of string s\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n    string alphabet = opt<string>(\"alphabet\", \"abcdefghijklmnopqrstuvwxyz\"); // Allowed letters\n\n    // The letters to use\n    vector<char> letters(alphabet.begin(), alphabet.end());\n\n    vector<string> base_strings(n);\n    int total_base_length = 0;\n\n    // Function to adjust base strings to ensure total length ≤ MAX_TOTAL_BASE_LENGTH\n    auto adjust_base_strings_length = [&](int desired_total_length) {\n        // Adjust lengths so that total length equals desired_total_length\n        int current_total_length = 0;\n        for (int i = 0; i < n; ++i) {\n            current_total_length += base_strings[i].size();\n        }\n        if (current_total_length == desired_total_length) {\n            return;\n        }\n        // Scale lengths\n        double scale = (double)desired_total_length / current_total_length;\n        int adjusted_total_length = 0;\n        for (int i = 0; i < n; ++i) {\n            int len = base_strings[i].size();\n            int new_len = max(1, (int)(len * scale));\n            base_strings[i] = base_strings[i].substr(0, new_len);\n            adjusted_total_length += new_len;\n        }\n        // Adjust lengths to match desired_total_length\n        int diff = desired_total_length - adjusted_total_length;\n        for (int i = 0; i < n && diff != 0; ++i) {\n            int len = base_strings[i].size();\n            if (diff > 0) {\n                base_strings[i] += letters[rnd.next(letters.size())];\n                diff--;\n            } else if (len > 1) {\n                base_strings[i] = base_strings[i].substr(0, len - 1);\n                diff++;\n            }\n        }\n    };\n\n    if (type == \"max_base_length\") {\n        // Generate base strings of maximum possible total length\n        int total_length = MAX_TOTAL_BASE_LENGTH;\n        int base_length = total_length / n;\n        int remaining = total_length % n;\n        for (int i = 0; i < n; ++i) {\n            int len = base_length + (i < remaining ? 1 : 0);\n            string s = \"\";\n            for (int j = 0; j < len; ++j) {\n                s += letters[rnd.next(letters.size())];\n            }\n            base_strings[i] = s;\n        }\n    } else if (type == \"single_char_base_strings\") {\n        // Generate base strings of length 1\n        for (int i = 0; i < n; ++i) {\n            char c = letters[rnd.next(letters.size())];\n            base_strings[i] = string(1, c);\n        }\n    } else if (type == \"identical_base_strings\") {\n        // All base strings are the same\n        string s = \"\";\n        int len = min(1000, MAX_TOTAL_BASE_LENGTH / n); // Limit length to avoid exceeding MAX_TOTAL_BASE_LENGTH\n        for (int i = 0; i < len; ++i) {\n            s += letters[rnd.next(letters.size())];\n        }\n        for (int i = 0; i < n; ++i) {\n            base_strings[i] = s;\n        }\n        adjust_base_strings_length(MAX_TOTAL_BASE_LENGTH);\n    } else if (type == \"random\") {\n        // Random lengths, make sure total length ≤ MAX_TOTAL_BASE_LENGTH\n        int total_length = 0;\n        int min_total_length = n; // Each base string at least length 1\n        for (int i = 0; i < n; ++i) {\n            int remaining_bases = n - i;\n            int remaining_length = MAX_TOTAL_BASE_LENGTH - total_length - (remaining_bases - 1); // Ensure at least length 1 for remaining\n            int max_len = min(remaining_length, 1000);\n            int len = rnd.next(1, max_len);\n            total_length += len;\n            string s = \"\";\n            for (int j = 0; j < len; ++j) {\n                s += letters[rnd.next(letters.size())];\n            }\n            base_strings[i] = s;\n        }\n    } else {\n        // Other types\n        int avg_length = max(1, MAX_TOTAL_BASE_LENGTH / n);\n        for (int i = 0; i < n; ++i) {\n            int len = avg_length;\n            if (type == \"repeated_letters\") {\n                char c = letters[rnd.next(letters.size())];\n                base_strings[i] = string(len, c);\n            } else if (type == \"alternating_characters\") {\n                char c1 = letters[rnd.next(letters.size())];\n                char c2 = letters[rnd.next(letters.size())];\n                while (c2 == c1) c2 = letters[rnd.next(letters.size())];\n                string s = \"\";\n                for (int j = 0; j < len; ++j) {\n                    s += (j % 2 == 0 ? c1 : c2);\n                }\n                base_strings[i] = s;\n            } else if (type == \"palindrome_base_strings\") {\n                string half = \"\";\n                for(int j=0;j<(len+1)/2;++j){\n                    half += letters[rnd.next(letters.size())];\n                }\n                string rev = half;\n                reverse(rev.begin(), rev.end());\n                string s = half + rev.substr(len%2);\n                base_strings[i] = s;\n            } else {\n                // Default to random letters\n                string s = \"\";\n                for (int j = 0; j < len; ++j) {\n                    s += letters[rnd.next(letters.size())];\n                }\n                base_strings[i] = s;\n            }\n        }\n        // Now adjust total length\n        adjust_base_strings_length(MAX_TOTAL_BASE_LENGTH);\n    }\n\n    // Generate the indices for t\n    vector<int> indices(m);\n    if (type == \"maximum_m\") {\n        for (int i = 0; i < m; ++i) {\n            indices[i] = rnd.next(1, n);\n        }\n    } else if (type == \"s_equals_t\" || type == \"s_is_subsequence_of_t\") {\n        // We need to ensure t length ≤ MAX_S_LENGTH\n        // Adjust m accordingly\n        m = min(m, MAX_S_LENGTH); // Because base strings are at least of length 1\n        indices.resize(m);\n        int t_length = 0;\n        for (int i = 0; i < m; ++i) {\n            indices[i] = rnd.next(1, n);\n            t_length += base_strings[indices[i]-1].size();\n            if (t_length >= MAX_S_LENGTH) {\n                m = i + 1;\n                indices.resize(m);\n                break;\n            }\n        }\n    } else {\n        for (int i = 0; i < m; ++i) {\n            indices[i] = rnd.next(1, n);\n        }\n    }\n\n    // Generate s according to type\n\n    string s;\n    if (type == \"s_equals_t\") {\n        // s is the same as t\n        s = \"\";\n        for (int i = 0; i < m; ++i) {\n            s += base_strings[indices[i]-1];\n        }\n    } else if (type == \"s_is_subsequence_of_t\") {\n        // s is a subsequence of t\n        string t_concat = \"\";\n        for (int i = 0; i < m; ++i) {\n            t_concat += base_strings[indices[i]-1];\n        }\n        int t_len = t_concat.size();\n        int s_len = min(t_len, s_len_param);\n        vector<int> positions(t_len);\n        for (int i = 0; i < t_len; ++i) {\n            positions[i] = i;\n        }\n        shuffle(positions.begin(), positions.end());\n        positions.resize(s_len);\n        sort(positions.begin(), positions.end());\n        s = \"\";\n        for (int i = 0; i < s_len; ++i) {\n            s += t_concat[positions[i]];\n        }\n    } else if (type == \"disjoint_s_t\") {\n        // s and t share no common letters\n        string t_alphabet = \"abcdefghijklm\";\n        string s_alphabet = \"nopqrstuvwxyz\";\n        letters = vector<char>(t_alphabet.begin(), t_alphabet.end());\n\n        // Regenerate base_strings using t_alphabet letters\n        for (int i = 0; i < n; ++i) {\n            int len = base_strings[i].size(); // Keep same length\n            string s = \"\";\n            for (int j = 0; j < len; ++j) {\n                s += letters[rnd.next(letters.size())];\n            }\n            base_strings[i] = s;\n        }\n\n        letters = vector<char>(s_alphabet.begin(), s_alphabet.end());\n        // Generate s\n        int len = s_len_param;\n        s = \"\";\n        for (int i = 0; i < len; ++i) {\n            s += letters[rnd.next(letters.size())];\n        }\n    } else {\n        // Random s\n        int len = s_len_param;\n        s = \"\";\n        for (int i = 0; i < len; ++i) {\n            s += letters[rnd.next(letters.size())];\n        }\n    }\n\n    // Now ensure s length ≤ MAX_S_LENGTH\n    if (s.size() > MAX_S_LENGTH) {\n        s = s.substr(0, MAX_S_LENGTH);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output n base strings\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", base_strings[i].c_str());\n    }\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output indices\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", indices[i], i == m - 1 ? '\\n' : ' ');\n    }\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Maximum total length of base strings\nconst int MAX_TOTAL_BASE_LENGTH = 1e6;\nconst int MAX_S_LENGTH = 2000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Number of base strings\n    int m = opt<int>(\"m\"); // Number of indices in hyper string t\n    int s_len_param = opt<int>(\"s_len\", MAX_S_LENGTH); // Length of string s\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n    string alphabet = opt<string>(\"alphabet\", \"abcdefghijklmnopqrstuvwxyz\"); // Allowed letters\n\n    // The letters to use\n    vector<char> letters(alphabet.begin(), alphabet.end());\n\n    vector<string> base_strings(n);\n    int total_base_length = 0;\n\n    // Function to adjust base strings to ensure total length ≤ MAX_TOTAL_BASE_LENGTH\n    auto adjust_base_strings_length = [&](int desired_total_length) {\n        // Adjust lengths so that total length equals desired_total_length\n        int current_total_length = 0;\n        for (int i = 0; i < n; ++i) {\n            current_total_length += base_strings[i].size();\n        }\n        if (current_total_length == desired_total_length) {\n            return;\n        }\n        // Scale lengths\n        double scale = (double)desired_total_length / current_total_length;\n        int adjusted_total_length = 0;\n        for (int i = 0; i < n; ++i) {\n            int len = base_strings[i].size();\n            int new_len = max(1, (int)(len * scale));\n            base_strings[i] = base_strings[i].substr(0, new_len);\n            adjusted_total_length += new_len;\n        }\n        // Adjust lengths to match desired_total_length\n        int diff = desired_total_length - adjusted_total_length;\n        for (int i = 0; i < n && diff != 0; ++i) {\n            int len = base_strings[i].size();\n            if (diff > 0) {\n                base_strings[i] += letters[rnd.next(letters.size())];\n                diff--;\n            } else if (len > 1) {\n                base_strings[i] = base_strings[i].substr(0, len - 1);\n                diff++;\n            }\n        }\n    };\n\n    if (type == \"max_base_length\") {\n        // Generate base strings of maximum possible total length\n        int total_length = MAX_TOTAL_BASE_LENGTH;\n        int base_length = total_length / n;\n        int remaining = total_length % n;\n        for (int i = 0; i < n; ++i) {\n            int len = base_length + (i < remaining ? 1 : 0);\n            string s = \"\";\n            for (int j = 0; j < len; ++j) {\n                s += letters[rnd.next(letters.size())];\n            }\n            base_strings[i] = s;\n        }\n    } else if (type == \"single_char_base_strings\") {\n        // Generate base strings of length 1\n        for (int i = 0; i < n; ++i) {\n            char c = letters[rnd.next(letters.size())];\n            base_strings[i] = string(1, c);\n        }\n    } else if (type == \"identical_base_strings\") {\n        // All base strings are the same\n        string s = \"\";\n        int len = min(1000, MAX_TOTAL_BASE_LENGTH / n); // Limit length to avoid exceeding MAX_TOTAL_BASE_LENGTH\n        for (int i = 0; i < len; ++i) {\n            s += letters[rnd.next(letters.size())];\n        }\n        for (int i = 0; i < n; ++i) {\n            base_strings[i] = s;\n        }\n        adjust_base_strings_length(MAX_TOTAL_BASE_LENGTH);\n    } else if (type == \"random\") {\n        // Random lengths, make sure total length ≤ MAX_TOTAL_BASE_LENGTH\n        int total_length = 0;\n        int min_total_length = n; // Each base string at least length 1\n        for (int i = 0; i < n; ++i) {\n            int remaining_bases = n - i;\n            int remaining_length = MAX_TOTAL_BASE_LENGTH - total_length - (remaining_bases - 1); // Ensure at least length 1 for remaining\n            int max_len = min(remaining_length, 1000);\n            int len = rnd.next(1, max_len);\n            total_length += len;\n            string s = \"\";\n            for (int j = 0; j < len; ++j) {\n                s += letters[rnd.next(letters.size())];\n            }\n            base_strings[i] = s;\n        }\n    } else {\n        // Other types\n        int avg_length = max(1, MAX_TOTAL_BASE_LENGTH / n);\n        for (int i = 0; i < n; ++i) {\n            int len = avg_length;\n            if (type == \"repeated_letters\") {\n                char c = letters[rnd.next(letters.size())];\n                base_strings[i] = string(len, c);\n            } else if (type == \"alternating_characters\") {\n                char c1 = letters[rnd.next(letters.size())];\n                char c2 = letters[rnd.next(letters.size())];\n                while (c2 == c1) c2 = letters[rnd.next(letters.size())];\n                string s = \"\";\n                for (int j = 0; j < len; ++j) {\n                    s += (j % 2 == 0 ? c1 : c2);\n                }\n                base_strings[i] = s;\n            } else if (type == \"palindrome_base_strings\") {\n                string half = \"\";\n                for(int j=0;j<(len+1)/2;++j){\n                    half += letters[rnd.next(letters.size())];\n                }\n                string rev = half;\n                reverse(rev.begin(), rev.end());\n                string s = half + rev.substr(len%2);\n                base_strings[i] = s;\n            } else {\n                // Default to random letters\n                string s = \"\";\n                for (int j = 0; j < len; ++j) {\n                    s += letters[rnd.next(letters.size())];\n                }\n                base_strings[i] = s;\n            }\n        }\n        // Now adjust total length\n        adjust_base_strings_length(MAX_TOTAL_BASE_LENGTH);\n    }\n\n    // Generate the indices for t\n    vector<int> indices(m);\n    if (type == \"maximum_m\") {\n        for (int i = 0; i < m; ++i) {\n            indices[i] = rnd.next(1, n);\n        }\n    } else if (type == \"s_equals_t\" || type == \"s_is_subsequence_of_t\") {\n        // We need to ensure t length ≤ MAX_S_LENGTH\n        // Adjust m accordingly\n        m = min(m, MAX_S_LENGTH); // Because base strings are at least of length 1\n        indices.resize(m);\n        int t_length = 0;\n        for (int i = 0; i < m; ++i) {\n            indices[i] = rnd.next(1, n);\n            t_length += base_strings[indices[i]-1].size();\n            if (t_length >= MAX_S_LENGTH) {\n                m = i + 1;\n                indices.resize(m);\n                break;\n            }\n        }\n    } else {\n        for (int i = 0; i < m; ++i) {\n            indices[i] = rnd.next(1, n);\n        }\n    }\n\n    // Generate s according to type\n\n    string s;\n    if (type == \"s_equals_t\") {\n        // s is the same as t\n        s = \"\";\n        for (int i = 0; i < m; ++i) {\n            s += base_strings[indices[i]-1];\n        }\n    } else if (type == \"s_is_subsequence_of_t\") {\n        // s is a subsequence of t\n        string t_concat = \"\";\n        for (int i = 0; i < m; ++i) {\n            t_concat += base_strings[indices[i]-1];\n        }\n        int t_len = t_concat.size();\n        int s_len = min(t_len, s_len_param);\n        vector<int> positions(t_len);\n        for (int i = 0; i < t_len; ++i) {\n            positions[i] = i;\n        }\n        shuffle(positions.begin(), positions.end());\n        positions.resize(s_len);\n        sort(positions.begin(), positions.end());\n        s = \"\";\n        for (int i = 0; i < s_len; ++i) {\n            s += t_concat[positions[i]];\n        }\n    } else if (type == \"disjoint_s_t\") {\n        // s and t share no common letters\n        string t_alphabet = \"abcdefghijklm\";\n        string s_alphabet = \"nopqrstuvwxyz\";\n        letters = vector<char>(t_alphabet.begin(), t_alphabet.end());\n\n        // Regenerate base_strings using t_alphabet letters\n        for (int i = 0; i < n; ++i) {\n            int len = base_strings[i].size(); // Keep same length\n            string s = \"\";\n            for (int j = 0; j < len; ++j) {\n                s += letters[rnd.next(letters.size())];\n            }\n            base_strings[i] = s;\n        }\n\n        letters = vector<char>(s_alphabet.begin(), s_alphabet.end());\n        // Generate s\n        int len = s_len_param;\n        s = \"\";\n        for (int i = 0; i < len; ++i) {\n            s += letters[rnd.next(letters.size())];\n        }\n    } else {\n        // Random s\n        int len = s_len_param;\n        s = \"\";\n        for (int i = 0; i < len; ++i) {\n            s += letters[rnd.next(letters.size())];\n        }\n    }\n\n    // Now ensure s length ≤ MAX_S_LENGTH\n    if (s.size() > MAX_S_LENGTH) {\n        s = s.substr(0, MAX_S_LENGTH);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output n base strings\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", base_strings[i].c_str());\n    }\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output indices\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", indices[i], i == m - 1 ? '\\n' : ' ');\n    }\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random test cases\n./gen -n 1 -m 1 -s_len 1 -type random\n./gen -n 5 -m 5 -s_len 5 -type random\n./gen -n 10 -m 10 -s_len 10 -type random\n./gen -n 50 -m 50 -s_len 50 -type random\n./gen -n 100 -m 100 -s_len 100 -type random\n\n# Maximum size test cases\n./gen -n 2000 -m 2000 -s_len 2000 -type max_base_length\n./gen -n 2000 -m 2000 -s_len 2000 -type random\n./gen -n 2000 -m 2000 -s_len 2000 -type identical_base_strings\n./gen -n 2000 -m 2000 -s_len 2000 -type single_char_base_strings\n\n# s equals t\n./gen -n 10 -m 10 -type s_equals_t\n./gen -n 100 -m 100 -type s_equals_t\n./gen -n 2000 -m 2000 -type s_equals_t\n\n# s is a subsequence of t\n./gen -n 10 -m 10 -s_len 5 -type s_is_subsequence_of_t\n./gen -n 100 -m 100 -s_len 50 -type s_is_subsequence_of_t\n./gen -n 2000 -m 2000 -s_len 1000 -type s_is_subsequence_of_t\n\n# s and t have no common letters\n./gen -n 100 -m 100 -s_len 100 -type disjoint_s_t\n\n# Edge cases\n./gen -n 1 -m 2000 -s_len 2000 -type single_char_base_strings\n./gen -n 2000 -m 1 -s_len 2000 -type random\n\n# Base strings with repeated letters\n./gen -n 2000 -m 2000 -s_len 2000 -type repeated_letters\n\n# Base strings with alternating characters\n./gen -n 2000 -m 2000 -s_len 2000 -type alternating_characters\n\n# Base strings that are palindromes\n./gen -n 2000 -m 2000 -s_len 2000 -type palindrome_base_strings\n\n# Random types\n./gen -n 1000 -m 1000 -s_len 1000 -type random\n./gen -n 1500 -m 1500 -s_len 1500 -type random\n\n# Different alphabets\n./gen -n 1000 -m 1000 -s_len 1000 -type random -alphabet abcdef\n\n# Random small cases for preliminary tests\n./gen -n 2 -m 2 -s_len 2 -type random\n./gen -n 5 -m 3 -s_len 3 -type random\n\n# Maximal total base length\n./gen -n 1000 -m 1000 -s_len 1000 -type max_base_length\n\n# Tests where base strings are long and m is small\n./gen -n 1000 -m 10 -s_len 2000 -type max_base_length\n\n# Tests where base strings are short and m is large\n./gen -n 1000 -m 2000 -s_len 2000 -type single_char_base_strings\n\n# Random large tests\n./gen -n 2000 -m 2000 -s_len 2000 -type random\n\n# Edge case: m=1\n./gen -n 2000 -m 1 -s_len 2000 -type random\n\n# Edge case: n=1\n./gen -n 1 -m 2000 -s_len 2000 -type random\n\n# Edge case: s of length 1\n./gen -n 2000 -m 2000 -s_len 1 -type random\n\n# Edge case: s of length maximum\n./gen -n 2000 -m 2000 -s_len 2000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:17.710483",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "176/E",
      "title": "E. Археология",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 second",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке дано целое число n (1 ≤ n ≤ 105) — количество деревень. В последующих n - 1 строках описаны дороги. i-я из этих строк содержит три целых числа ai, bi и ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 109, 1 ≤ i < n) — номера деревень, которые соединяет i-я дорога и ее длина. Числа в строках записаны через пробел.В следующей строке дано целое число q (1 ≤ q ≤ 105) — количество запросов. Далее идут q запросов по одному в строке, упорядоченные по времени. Каждый запрос имеет один из трех типов: «+ x» — деревня с номером x возрождается (1 ≤ x ≤ n).  «- x» — деревня с номером x уничтожается (1 ≤ x ≤ n).  «?» — в этот момент времени археологи хотят знать суммарную длину используемых дорог.Гарантируется, что запросы не противоречат друг другу, то есть не будет запросов на уничтожение несуществующих деревень или возрождение уже существующих. Гарантируется, что имеется хотя бы один запрос типа «?». Также гарантируется, что по заданным дорогам из любой деревни можно добраться в любую другую.Считается, что в начальный момент времени ни одной деревни не существует.",
      "output_spec": "Выходные данныеНа каждый запрос типа «?» выведите суммарную длину используемых дорог в отдельной строке. Ответы за запросы должны быть выведены в том порядке, в котором запросы перечислены во входных данных.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать61 2 11 3 54 1 74 5 36 4 210+ 3+ 1?+ 6?+ 5?- 6- 3?Выходные данныеСкопировать5141710",
      "description": "E. Археология\n\nограничение по времени на тест1 second\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке дано целое число n (1 ≤ n ≤ 105) — количество деревень. В последующих n - 1 строках описаны дороги. i-я из этих строк содержит три целых числа ai, bi и ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 109, 1 ≤ i < n) — номера деревень, которые соединяет i-я дорога и ее длина. Числа в строках записаны через пробел.В следующей строке дано целое число q (1 ≤ q ≤ 105) — количество запросов. Далее идут q запросов по одному в строке, упорядоченные по времени. Каждый запрос имеет один из трех типов: «+ x» — деревня с номером x возрождается (1 ≤ x ≤ n).  «- x» — деревня с номером x уничтожается (1 ≤ x ≤ n).  «?» — в этот момент времени археологи хотят знать суммарную длину используемых дорог.Гарантируется, что запросы не противоречат друг другу, то есть не будет запросов на уничтожение несуществующих деревень или возрождение уже существующих. Гарантируется, что имеется хотя бы один запрос типа «?». Также гарантируется, что по заданным дорогам из любой деревни можно добраться в любую другую.Считается, что в начальный момент времени ни одной деревни не существует.\n\nВходные данные\n\nВыходные данныеНа каждый запрос типа «?» выведите суммарную длину используемых дорог в отдельной строке. Ответы за запросы должны быть выведены в том порядке, в котором запросы перечислены во входных данных.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать61 2 11 3 54 1 74 5 36 4 210+ 3+ 1?+ 6?+ 5?- 6- 3?Выходные данныеСкопировать5141710\n\nВходные данныеСкопировать61 2 11 3 54 1 74 5 36 4 210+ 3+ 1?+ 6?+ 5?- 6- 3?\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5141710\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces",
          "content": "Всем привет!Сегодня будет проходить второй раунд Открытого чемпионата Москвы и МО по программированию (КРОК). Начало запланировано на 19:00.Соревнование будет проходить по обычным правилам Codeforces, со взломами и падением баллов со временем. В Раунд 2 допускаются все участники, набравшие в Раунде 1 баллов не меньше участника на 300-ом месте. Все остальные участники могут участвовать в раунде вне конкурса. Специально для участников второго дивизиона подготовлена облегченная версия набора задач. Наборы задач официальной и неофициальной версий раундов частично пересекаются.Контест будет рейтинговым для всех участников.Вас ждет несколько задач, упорядоченных примерно по возрастанию сложности. Разбалловка задач как для первого, так и второго дивизиона стандартная (500-1000-1500-2000-2500). Не забывайте, что во время контеста решения будут тестироваться на небольшом наборе претестов. Тестирование на полном наборе тестов будет произведено после окончания раунда. Набор претестов не всегда покрывает все возможные случаи входных данных, поэтому внимательно тестируйте свои решения.До окончания раунда категорически запрещается публиковать условия/решения задач. Запрещено общаться по теме задач, обсуждать какие либо мысли о возможном их решении. Давайте будем честными! Обсуждать задачи можно после окончания раунда.В финальный раунд проходит 50 участников, показавших наилучший результат. Все участники, набравшие столько же баллов, сколько и участник на 50-ом месте, также проходят в финал.Раунд готовили: Ripatti, havaliza, Gerald, RAD, MikeMirzayanov, Delinur.Всем удачи!UPD. Напоминаем, что 27 апреля в офисе компании КРОК состоится финал Открытого чемпионата Москвы и МО по программированию (КРОК). Обратите внимание, что компания КРОК не оплачивает дорогу и проживание участников финала. Все участники финала должны прибыть в офис компании КРОК (г. Москва) утром 27 апреля. После соревнования всем участникам будет предоставлена возможность заполнить форму на согласие участвовать в финале соревнования. В финал будут приглашены первые 50 участников по результатам соревнования, которые подтвердят свое участие в финале. Подтвердить свое участие в финале можно в течение суток после окончания соревнования.Рекомендуется заполнить форму независимо от ваших результатов в Раунде 2, поскольку отказаться может достаточно большое количество участников.",
          "author": "Ripatti",
          "url": "https://codeforces.com/blog/entry/4370",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2364
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 — разбор задач - Codeforces",
          "content": "A div2. Искомая строка — та, на которой звездочка встретилась ровно один раз, искомый столбец — тот, где звездочка встретилась только однажды. Перебрав все строки/столбцы и проверив количество звездочек в них, получаем ответ.Авторы: MikeMirzayanov, Gerald .B div2. Наивное решение за O(n3) (перебор всех троек с последующей проверкой) не укладывается по времени.Заметим, что по двум точкам из тройки (скажем, это точки A и C) можно однозначно установить предполагаемое положение точки B. То есть достаточно перебора всех пар точек с последующий проверкой середины отрезка, их соединяющего.Прибавим ко всем координатам точек 1000 (понятно, что ответ от этого не изменится) и отметим эти точки в двумерном массиве флагов размера 2001х2001. Теперь мы можем проверить есть ли в данной позиции точка или нет за O(1).Объединим две последние идеи и получим верное решение за O(n2).Авторы: MikeMirzayanov, GeraldA div1. C div2. В данной задаче предполагалось жадное решение.Зафиксируем две планеты: на планете i мы будем покупать товары, на планете j — продавать. Тогда прибыль с товара типа k будет равна b_jk-a_ik. Поскольку каждый товар занимает единицу места, нам выгоднее всего закупать для перепродажи товары в порядке уменьшения прибыли.Отсюда сразу вытекает решение: перебираем все пары планет, для каждой пары сортируем товары в порядке уменьшения прибыли, после чего жадно закупаем самые прибыльные товары пока хватает места в трюме. Из всех пар планет выбираем ту, где суммарной получилось как можно больше.Автор: RipattiB div1. D div2. Заметим, что операция split — это ничто иное, как циклических сдвигов строки. Мы можем переходить от любого циклического сдвига к любому другому кроме текущего.Назовем циклический сдвиг хорошим, если он равен конечной строке. Все остальные сдвиги назовем плохими. Пусть у нас A хороших сдвигов и B плохих (проверить все сдвига на \"хорошесть\" можно в лоб за O(|w|2).Обозначим за dpA[n] — количество способов получить хороший сдвиг за n split-ов, за dpB[n] — количество способов получить плохих сдвигов за n split-ов.В начале либо dpA[0]=1, dpB[0]=0, либо dpA[0]=0, dpB[0]=1 в зависимости от того, хороший сдвиг начальной строка (= совпадает ли с конечной) или нет. Далее переходы легко выводятся:dpA[n] = dpA[n-1] * (A-1) + dpB[n-1] * AdpB[n] = dpA[n-1] * B + dpB[n-1] * (B-1)Посчитаем все для n<=k, ответом будет dpA[k]. Итого решение за O(|w|2 + k).Также, в этой задаче есть решение за .Автор: havalizaC div1. E div2. У второго игрока есть довольно очевидная стратегия, позволяющая задержать фишку с начальными координатами (X, Y) в одной из 4х полуплоскостей — x ≤ X + 2, x ≥ X - 2, y ≤ Y + 2 и y ≥ Y - 2. Причем какая это будет плоскость — решать второму игроку.Таким образом, если max(|x1 - x2|, |y1 - y2|) > 4, выигрывает второй игрок — он просто задерживает фишки в двух не пересекающихся полуплоскостях.Оставшиеся случаи max(|x1 - x2|, |y1 - y2|) ≤ 4 предполагалось добивать перебором (возможно, с отсечениями). Понятно, что первому игроку ходить так, чтобы фишки \"расходились\" не выгодно, поэтому пространство перебора ограничивается квадратом 5 × 5. Если перебор не укладывается в 2 сек, можно сделать precalculation. Еще можно было написать дп на масках.Кроме того, здесь можно было вывести формулу вручную. Однако тут много сложных для разбора случаев и легко ошибиться.Автор: RipattiD div1. Заведем динамику dp[pre][len], в которой будем хранить наименьшую длину префикса гиперстроки, которая имеет с префиксом длины pre строки s наибольшую общую подпоследовательность длины len.Тогда несложно получить формулы перехода:dp[pre][len] = min(dp[pre - 1][len],  наименьшая позиция буквы s[pre] в t правее dp[pre - 1][len - 1]).Чтобы получать значения второго значения внутри минимума в вышеупомянутой формуле за O(1), нужно завести еще несколько динамик: dp1 — для каждой базовой строки, позиции в ней и буквы посчитать самую левую позицию данной буквы правее данной позиции;dp2 — для каждого элемента массива базовых строк (в гиперстроке) и буквы посчитать самую левую базовую строку, содержащую данную букву, правее данной базовой строки.Итого решение за .Автор: havaliza.E div1. Сначала попробуем решить такую задачу: в деревы вебрано k вершин, нужно найти сумму ребер \"натянутого\" на них поддерева за .Упорядочим все k вершин в порядке обхода dfs — v1, v2, ... , vk. Рассмотрим пути v1-v2, v2-v3, ... , v(k-1)-vk и vk-v1. Нетрудно заметить, что они покрывают нужное нам поддерево, причем каждое ребро покрыто ровно два раза. Теперь, чтобы найти сумму ребер надо просто посчитать сумму всех путей (при помощи LCA это можно сделать как раз за ), а потом просто поделить на 2.Чтобы решить первоначальную задачу, нужно поддерживать множество активных вершин в упорядоченном состоянии (например, использую std::set) и сумму всех путей между последовательными вершинами. Теперь запросы на добавление и удаление вершин можно обработать за , после чего обновить текущую сумму пересчитав 3 пути — тоже за .Итого имеем решение за .Автор: Ripatti.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4372",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4988
        }
      ],
      "code_examples": [
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 1",
          "code": "int[] a = new int[26 * 1000000];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 2",
          "code": "int[] a = new int[26 * 1000000];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 3",
          "code": "int[][] a = new int[26][1000000];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 4",
          "code": "int[][] a = new int[26][1000000];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 5",
          "code": "x...\n....\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 6",
          "code": "x...\n....\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 7",
          "code": "x...\n.!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 8",
          "code": "x...\n.!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 9",
          "code": "x...\n.!..\n....\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 10",
          "code": "x...\n.!..\n....\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 11",
          "code": "x...\n.!..\n.!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 12",
          "code": "x...\n.!..\n.!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 13",
          "code": "....\nx!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 14",
          "code": "....\nx!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 15",
          "code": "....\nx!..\n!...\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 16",
          "code": "....\nx!..\n!...\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 17",
          "code": "....\nx!..\n!...\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 18",
          "code": "....\nx!..\n!...\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 19",
          "code": "....\nx!..\n!!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 - Codeforces - Code 20",
          "code": "....\nx!..\n!!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 — разбор задач - Codeforces - Code 1",
          "code": "dpA[n] = dpA[n-1]*(A-1) + dpB[n-1]*A\ndpB[n] = dpA[n-1]*B + dpB[n-1](B-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4372",
          "author": "jiangly"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 — разбор задач - Codeforces - Code 2",
          "code": "dpA[n] = dpA[n-1]*(A-1) + dpB[n-1]*A\ndpB[n] = dpA[n-1]*B + dpB[n-1](B-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4372",
          "author": "jiangly"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 — разбор задач - Codeforces - Code 3",
          "code": "int x = 0, y = 0;\nfor (int i = 0; i < n; i++)\n  for (int j = 0; j < m; j++)\n    if (s[i][j] == '*') {\n      x ^= i;\n      y ^= j;\n    }\ncout << x+1 << \" \" << y+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4372",
          "author": "jiangly"
        },
        {
          "title": "Чемпионат КРОК 2012 — Раунд 2 — разбор задач - Codeforces - Code 4",
          "code": "int x = 0, y = 0;\nfor (int i = 0; i < n; i++)\n  for (int j = 0; j < m; j++)\n    if (s[i][j] == '*') {\n      x ^= i;\n      y ^= j;\n    }\ncout << x+1 << \" \" << y+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4372",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // DSU for checking connectedness and acyclicity\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++)\n        parent[i] = i;\n\n    int components = n;\n\n    function<int(int)> find = [&](int u) {\n        return u == parent[u] ? u : parent[u] = find(parent[u]);\n    };\n\n    auto unite = [&](int u, int v) {\n        u = find(u);\n        v = find(v);\n        if (u == v)\n            return false;  // cycle detected\n        parent[u] = v;\n        components--;\n        return true;\n    };\n\n    for (int i = 0; i < n - 1; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"Edge cannot connect a village to itself: edge between %d and %d\", ai, bi);\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readEoln();\n\n        bool ok = unite(ai, bi);\n        ensuref(ok, \"The graph must be acyclic\");\n    }\n\n    ensuref(components == 1, \"The graph must be connected\");\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<bool> exists(n + 1, false);\n    int num_question_queries = 0;\n\n    for (int i = 0; i < q; i++) {\n        string line = inf.readLine();\n        if (line == \"?\") {\n            num_question_queries++;\n        } else {\n            if (line.size() < 3 || (line[0] != '+' && line[0] != '-') || line[1] != ' ')\n                quitf(_fail, \"Invalid query format: %s\", line.c_str());\n            char op = line[0];\n            string x_str = line.substr(2);\n            if (x_str.empty())\n                quitf(_fail, \"Missing x after %c in query: %s\", op, line.c_str());\n            if (!all_of(x_str.begin(), x_str.end(), ::isdigit))\n                quitf(_fail, \"Invalid integer x in query: %s\", x_str.c_str());\n            int x = stoi(x_str);\n            ensuref(1 <= x && x <= n, \"Village number x=%d out of bounds (1..%d)\", x, n);\n            if (op == '+') {\n                // Restore x\n                ensuref(!exists[x], \"Cannot restore village %d, village already exists\", x);\n                exists[x] = true;\n            } else if (op == '-') {\n                // Destroy x\n                ensuref(exists[x], \"Cannot destroy village %d, village does not exist\", x);\n                exists[x] = false;\n            } else {\n                quitf(_fail, \"Invalid operator in query: %c\", op);\n            }\n        }\n    }\n\n    ensuref(num_question_queries >= 1, \"There must be at least one query of type '?'\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // DSU for checking connectedness and acyclicity\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++)\n        parent[i] = i;\n\n    int components = n;\n\n    function<int(int)> find = [&](int u) {\n        return u == parent[u] ? u : parent[u] = find(parent[u]);\n    };\n\n    auto unite = [&](int u, int v) {\n        u = find(u);\n        v = find(v);\n        if (u == v)\n            return false;  // cycle detected\n        parent[u] = v;\n        components--;\n        return true;\n    };\n\n    for (int i = 0; i < n - 1; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"Edge cannot connect a village to itself: edge between %d and %d\", ai, bi);\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readEoln();\n\n        bool ok = unite(ai, bi);\n        ensuref(ok, \"The graph must be acyclic\");\n    }\n\n    ensuref(components == 1, \"The graph must be connected\");\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<bool> exists(n + 1, false);\n    int num_question_queries = 0;\n\n    for (int i = 0; i < q; i++) {\n        string line = inf.readLine();\n        if (line == \"?\") {\n            num_question_queries++;\n        } else {\n            if (line.size() < 3 || (line[0] != '+' && line[0] != '-') || line[1] != ' ')\n                quitf(_fail, \"Invalid query format: %s\", line.c_str());\n            char op = line[0];\n            string x_str = line.substr(2);\n            if (x_str.empty())\n                quitf(_fail, \"Missing x after %c in query: %s\", op, line.c_str());\n            if (!all_of(x_str.begin(), x_str.end(), ::isdigit))\n                quitf(_fail, \"Invalid integer x in query: %s\", x_str.c_str());\n            int x = stoi(x_str);\n            ensuref(1 <= x && x <= n, \"Village number x=%d out of bounds (1..%d)\", x, n);\n            if (op == '+') {\n                // Restore x\n                ensuref(!exists[x], \"Cannot restore village %d, village already exists\", x);\n                exists[x] = true;\n            } else if (op == '-') {\n                // Destroy x\n                ensuref(exists[x], \"Cannot destroy village %d, village does not exist\", x);\n                exists[x] = false;\n            } else {\n                quitf(_fail, \"Invalid operator in query: %c\", op);\n            }\n        }\n    }\n\n    ensuref(num_question_queries >= 1, \"There must be at least one query of type '?'\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // DSU for checking connectedness and acyclicity\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++)\n        parent[i] = i;\n\n    int components = n;\n\n    function<int(int)> find = [&](int u) {\n        return u == parent[u] ? u : parent[u] = find(parent[u]);\n    };\n\n    auto unite = [&](int u, int v) {\n        u = find(u);\n        v = find(v);\n        if (u == v)\n            return false;  // cycle detected\n        parent[u] = v;\n        components--;\n        return true;\n    };\n\n    for (int i = 0; i < n - 1; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        ensuref(ai != bi, \"Edge cannot connect a village to itself: edge between %d and %d\", ai, bi);\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readEoln();\n\n        bool ok = unite(ai, bi);\n        ensuref(ok, \"The graph must be acyclic\");\n    }\n\n    ensuref(components == 1, \"The graph must be connected\");\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<bool> exists(n + 1, false);\n    int num_question_queries = 0;\n\n    for (int i = 0; i < q; i++) {\n        string line = inf.readLine();\n        if (line == \"?\") {\n            num_question_queries++;\n        } else {\n            if (line.size() < 3 || (line[0] != '+' && line[0] != '-') || line[1] != ' ')\n                quitf(_fail, \"Invalid query format: %s\", line.c_str());\n            char op = line[0];\n            string x_str = line.substr(2);\n            if (x_str.empty())\n                quitf(_fail, \"Missing x after %c in query: %s\", op, line.c_str());\n            if (!all_of(x_str.begin(), x_str.end(), ::isdigit))\n                quitf(_fail, \"Invalid integer x in query: %s\", x_str.c_str());\n            int x = stoi(x_str);\n            ensuref(1 <= x && x <= n, \"Village number x=%d out of bounds (1..%d)\", x, n);\n            if (op == '+') {\n                // Restore x\n                ensuref(!exists[x], \"Cannot restore village %d, village already exists\", x);\n                exists[x] = true;\n            } else if (op == '-') {\n                // Destroy x\n                ensuref(exists[x], \"Cannot destroy village %d, village does not exist\", x);\n                exists[x] = false;\n            } else {\n                quitf(_fail, \"Invalid operator in query: %c\", op);\n            }\n        }\n    }\n\n    ensuref(num_question_queries >= 1, \"There must be at least one query of type '?'\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string edge_length_type = opt<string>(\"edge_length_type\", \"random\");\n    string query_pattern = opt<string>(\"query_pattern\", \"random\");\n\n    // Generate tree\n    vector<int> a, b, c; // Edges\n\n    if (tree_type == \"chain\") {\n        for (int i = 1; i < n; ++i) {\n            a.push_back(i);\n            b.push_back(i+1);\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 1; i < n; ++i) {\n            a.push_back(1);\n            b.push_back(i+1);\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int p = rnd.next(1, i-1);\n            a.push_back(p);\n            b.push_back(i);\n        }\n    }\n\n    // Generate edge lengths\n    int m = n - 1;\n    c.resize(m);\n\n    if (edge_length_type == \"constant\") {\n        int val = opt<int>(\"edge_value\", 1);\n        for (int i = 0; i < m; ++i) {\n            c[i] = val;\n        }\n    } else if (edge_length_type == \"increasing\") {\n        for (int i = 0; i < m; ++i) {\n            c[i] = i + 1;\n        }\n    } else if (edge_length_type == \"decreasing\") {\n        for (int i = 0; i < m; ++i) {\n            c[i] = m - i;\n        }\n    } else {\n        // Random edge lengths\n        for (int i = 0; i < m; ++i) {\n            c[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Output the tree\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %d\\n\", a[i], b[i], c[i]);\n    }\n\n    // Generate queries based on query_pattern\n    vector<string> queries;\n\n    if (query_pattern == \"add_then_query\") {\n        vector<int> villages(n);\n        for (int i = 0; i < n; ++i) {\n            villages[i] = i + 1;\n        }\n        shuffle(villages.begin(), villages.end());\n\n        int num_add = min(n, q - 1);\n        for (int i = 0; i < num_add; ++i) {\n            queries.push_back(\"+ \" + to_string(villages[i]));\n        }\n\n        // Ensure at least one \"?\" query\n        queries.push_back(\"?\");\n\n        int num_query = q - num_add - 1;\n        for (int i = 0; i < num_query; ++i) {\n            queries.push_back(\"?\");\n        }\n\n    } else if (query_pattern == \"random\") {\n        // Random queries\n        vector<int> available_villages;\n        for (int i = 1; i <= n; ++i) {\n            available_villages.push_back(i);\n        }\n        shuffle(available_villages.begin(), available_villages.end());\n\n        set<int> existing_villages;\n\n        bool has_question = false;\n        int idx_avail = 0;\n\n        for (int i = 0; i < q; ++i) {\n            vector<string> possible_queries;\n            if (!existing_villages.empty()) {\n                possible_queries.push_back(\"-\");\n            }\n            if (idx_avail < n) {\n                possible_queries.push_back(\"+\");\n            }\n            // Always allow \"?\" query\n            possible_queries.push_back(\"?\");\n\n            string selected_query = rnd.any(possible_queries);\n\n            if (selected_query == \"+\") {\n                int v = available_villages[idx_avail++];\n                existing_villages.insert(v);\n                queries.push_back(\"+ \" + to_string(v));\n            } else if (selected_query == \"-\") {\n                int pos = rnd.next(0, (int)existing_villages.size() - 1);\n                auto it = existing_villages.begin();\n                advance(it, pos);\n                int v = *it;\n                existing_villages.erase(it);\n                queries.push_back(\"- \" + to_string(v));\n            } else if (selected_query == \"?\") {\n                queries.push_back(\"?\");\n                has_question = true;\n            }\n        }\n\n        // Ensure at least one \"?\" query\n        if (!has_question) {\n            queries.back() = \"?\";\n        }\n\n    } else if (query_pattern == \"alternate\") {\n        vector<int> villages(n);\n        for (int i = 0; i < n; ++i) {\n            villages[i] = i + 1;\n        }\n        shuffle(villages.begin(), villages.end());\n\n        set<int> existing_villages;\n        int idx = 0;\n        bool has_question = false;\n\n        for (int i = 0; i < q; ++i) {\n            if (i % 3 == 0 && idx < n) {\n                int v = villages[idx++];\n                existing_villages.insert(v);\n                queries.push_back(\"+ \" + to_string(v));\n            } else if (i % 3 == 1 && !existing_villages.empty()) {\n                int v = *existing_villages.begin();\n                existing_villages.erase(existing_villages.begin());\n                queries.push_back(\"- \" + to_string(v));\n            } else {\n                queries.push_back(\"?\");\n                has_question = true;\n            }\n        }\n\n        // Ensure at least one \"?\" query\n        if (!has_question) {\n            queries.back() = \"?\";\n        }\n\n    } else {\n        // Default to random (same as the \"random\" pattern)\n        // (Implementation omitted for brevity)\n    }\n\n    // Output the number of queries\n    printf(\"%d\\n\", q);\n    // Output the queries\n    for (size_t i = 0; i < queries.size(); ++i) {\n        printf(\"%s\\n\", queries[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string edge_length_type = opt<string>(\"edge_length_type\", \"random\");\n    string query_pattern = opt<string>(\"query_pattern\", \"random\");\n\n    // Generate tree\n    vector<int> a, b, c; // Edges\n\n    if (tree_type == \"chain\") {\n        for (int i = 1; i < n; ++i) {\n            a.push_back(i);\n            b.push_back(i+1);\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 1; i < n; ++i) {\n            a.push_back(1);\n            b.push_back(i+1);\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int p = rnd.next(1, i-1);\n            a.push_back(p);\n            b.push_back(i);\n        }\n    }\n\n    // Generate edge lengths\n    int m = n - 1;\n    c.resize(m);\n\n    if (edge_length_type == \"constant\") {\n        int val = opt<int>(\"edge_value\", 1);\n        for (int i = 0; i < m; ++i) {\n            c[i] = val;\n        }\n    } else if (edge_length_type == \"increasing\") {\n        for (int i = 0; i < m; ++i) {\n            c[i] = i + 1;\n        }\n    } else if (edge_length_type == \"decreasing\") {\n        for (int i = 0; i < m; ++i) {\n            c[i] = m - i;\n        }\n    } else {\n        // Random edge lengths\n        for (int i = 0; i < m; ++i) {\n            c[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Output the tree\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %d\\n\", a[i], b[i], c[i]);\n    }\n\n    // Generate queries based on query_pattern\n    vector<string> queries;\n\n    if (query_pattern == \"add_then_query\") {\n        vector<int> villages(n);\n        for (int i = 0; i < n; ++i) {\n            villages[i] = i + 1;\n        }\n        shuffle(villages.begin(), villages.end());\n\n        int num_add = min(n, q - 1);\n        for (int i = 0; i < num_add; ++i) {\n            queries.push_back(\"+ \" + to_string(villages[i]));\n        }\n\n        // Ensure at least one \"?\" query\n        queries.push_back(\"?\");\n\n        int num_query = q - num_add - 1;\n        for (int i = 0; i < num_query; ++i) {\n            queries.push_back(\"?\");\n        }\n\n    } else if (query_pattern == \"random\") {\n        // Random queries\n        vector<int> available_villages;\n        for (int i = 1; i <= n; ++i) {\n            available_villages.push_back(i);\n        }\n        shuffle(available_villages.begin(), available_villages.end());\n\n        set<int> existing_villages;\n\n        bool has_question = false;\n        int idx_avail = 0;\n\n        for (int i = 0; i < q; ++i) {\n            vector<string> possible_queries;\n            if (!existing_villages.empty()) {\n                possible_queries.push_back(\"-\");\n            }\n            if (idx_avail < n) {\n                possible_queries.push_back(\"+\");\n            }\n            // Always allow \"?\" query\n            possible_queries.push_back(\"?\");\n\n            string selected_query = rnd.any(possible_queries);\n\n            if (selected_query == \"+\") {\n                int v = available_villages[idx_avail++];\n                existing_villages.insert(v);\n                queries.push_back(\"+ \" + to_string(v));\n            } else if (selected_query == \"-\") {\n                int pos = rnd.next(0, (int)existing_villages.size() - 1);\n                auto it = existing_villages.begin();\n                advance(it, pos);\n                int v = *it;\n                existing_villages.erase(it);\n                queries.push_back(\"- \" + to_string(v));\n            } else if (selected_query == \"?\") {\n                queries.push_back(\"?\");\n                has_question = true;\n            }\n        }\n\n        // Ensure at least one \"?\" query\n        if (!has_question) {\n            queries.back() = \"?\";\n        }\n\n    } else if (query_pattern == \"alternate\") {\n        vector<int> villages(n);\n        for (int i = 0; i < n; ++i) {\n            villages[i] = i + 1;\n        }\n        shuffle(villages.begin(), villages.end());\n\n        set<int> existing_villages;\n        int idx = 0;\n        bool has_question = false;\n\n        for (int i = 0; i < q; ++i) {\n            if (i % 3 == 0 && idx < n) {\n                int v = villages[idx++];\n                existing_villages.insert(v);\n                queries.push_back(\"+ \" + to_string(v));\n            } else if (i % 3 == 1 && !existing_villages.empty()) {\n                int v = *existing_villages.begin();\n                existing_villages.erase(existing_villages.begin());\n                queries.push_back(\"- \" + to_string(v));\n            } else {\n                queries.push_back(\"?\");\n                has_question = true;\n            }\n        }\n\n        // Ensure at least one \"?\" query\n        if (!has_question) {\n            queries.back() = \"?\";\n        }\n\n    } else {\n        // Default to random (same as the \"random\" pattern)\n        // (Implementation omitted for brevity)\n    }\n\n    // Output the number of queries\n    printf(\"%d\\n\", q);\n    // Output the queries\n    for (size_t i = 0; i < queries.size(); ++i) {\n        printf(\"%s\\n\", queries[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -q 10 -tree_type chain -edge_length_type constant -query_pattern add_then_query\n./gen -n 10 -q 10 -tree_type chain -edge_length_type increasing -query_pattern random\n./gen -n 10 -q 10 -tree_type chain -edge_length_type decreasing -query_pattern alternate\n./gen -n 10 -q 10 -tree_type chain -edge_length_type random -query_pattern random\n\n./gen -n 100 -q 200 -tree_type star -edge_length_type constant -edge_value 1 -query_pattern add_then_query\n./gen -n 100 -q 100 -tree_type star -edge_length_type increasing -query_pattern random\n./gen -n 100 -q 150 -tree_type star -edge_length_type decreasing -query_pattern alternate\n\n./gen -n 1000 -q 2000 -tree_type random -edge_length_type random -query_pattern random\n./gen -n 1000 -q 1000 -tree_type random -edge_length_type constant -edge_value 1000 -query_pattern add_then_query\n\n./gen -n 100000 -q 200000 -tree_type random -edge_length_type random -query_pattern random\n./gen -n 100000 -q 100001 -tree_type chain -edge_length_type increasing -query_pattern add_then_query\n\n./gen -n 100000 -q 100000 -tree_type star -edge_length_type decreasing -query_pattern alternate\n./gen -n 100000 -q 100000 -tree_type random -edge_length_type constant -edge_value 1000000000 -query_pattern random\n\n# Edge cases\n./gen -n 1 -q 1 -tree_type chain -edge_length_type constant -query_pattern add_then_query\n\n./gen -n 2 -q 2 -tree_type chain -edge_length_type decreasing -query_pattern random\n\n# Additional cases to test potential errors\n./gen -n 50000 -q 100000 -tree_type random -edge_length_type random -query_pattern random\n\n./gen -n 99999 -q 100000 -tree_type random -edge_length_type random -query_pattern random\n\n./gen -n 100000 -q 100000 -tree_type chain -edge_length_type increasing -query_pattern random\n\n./gen -n 100000 -q 100000 -tree_type star -edge_length_type increasing -query_pattern random\n\n./gen -n 100000 -q 100000 -tree_type random -edge_length_type increasing -query_pattern alternate\n\n./gen -n 50000 -q 50000 -tree_type random -edge_length_type decreasing -query_pattern add_then_query\n\n./gen -n 100000 -q 100000 -tree_type random -edge_length_type decreasing -query_pattern random\n\n./gen -n 100000 -q 100000 -tree_type random -edge_length_type constant -edge_value 1 -query_pattern random\n\n./gen -n 50000 -q 50000 -tree_type random -edge_length_type constant -edge_value 1000000000 -query_pattern add_then_query\n\n# Potential time limit test case\n./gen -n 100000 -q 100000 -tree_type random -edge_length_type random -query_pattern random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:19.591388",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "18/A",
      "title": "A. Triangle",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first input line contains 6 space-separated integers x1, y1, x2, y2, x3, y3 — coordinates of the triangle's vertices. All the coordinates are integer and don't exceed 100 in absolute value. It's guaranteed that the triangle is nondegenerate, i.e. its total area is not zero.",
      "output_spec": "OutputIf the given triangle is right-angled, output RIGHT, if it is almost right-angled, output ALMOST, and if it is neither of these, output NEITHER.",
      "sample_tests": "ExamplesInputCopy0 0 2 0 0 1OutputCopyRIGHTInputCopy2 3 4 5 6 6OutputCopyNEITHERInputCopy-1 0 2 0 0 1OutputCopyALMOST",
      "description": "A. Triangle\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains 6 space-separated integers x1, y1, x2, y2, x3, y3 — coordinates of the triangle's vertices. All the coordinates are integer and don't exceed 100 in absolute value. It's guaranteed that the triangle is nondegenerate, i.e. its total area is not zero.\n\nOutputIf the given triangle is right-angled, output RIGHT, if it is almost right-angled, output ALMOST, and if it is neither of these, output NEITHER.\n\nInputCopy0 0 2 0 0 1OutputCopyRIGHTInputCopy2 3 4 5 6 6OutputCopyNEITHERInputCopy-1 0 2 0 0 1OutputCopyALMOST\n\nInputCopy0 0 2 0 0 1\n\nOutputCopyRIGHT\n\nInputCopy2 3 4 5 6 6\n\nOutputCopyNEITHER\n\nInputCopy-1 0 2 0 0 1\n\nOutputCopyALMOST",
      "solutions": [
        {
          "title": "Codeforces Beta Round #18 (Div. 2) - Codeforces",
          "content": "Welcome to Codeforces Beta Round #18 Authors of today's contest are Mike Mirzayanov, Edvard Davtyan and me. Thanks to Dmitry Matov for his help in statements preparation and Julia Satushina for translation of problems in English. Good luck everyone!ProblemsFinal standingsContest winner: I_am_Feeling_Lucky",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/462",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 18\\s*A"
          },
          "content_length": 306
        },
        {
          "title": "Codeforces Beta Round #18(Div. 2) Tutorial - Codeforces",
          "content": "Contest discussionProblem А. TrianglePythagorean theorem, brute forceIn this problem you should implement a function, which takes three points and checks whether they form a right-angled triangle. There are a lot of ways to do so, but the simplest one is using a Pythagorean theorem. You should use squared distances instead of taking roots to overcome problems related to precision errors.To examine a triangle on almost-rightness, you can try to move each point in each of four possible directions and check the new triangle using our function. It's good and easy to use two arrays: dx={-1,0,1,0} and dy={0,1,0,-1} for moving. Then we can get the new coordinates of shifted point simply using the following code:for (int i = 0; i < 4; i ++){int x = dx[i] + px;int y = dy[i] + py;}Problem B. PlatformsSimulationIllustrative picture:In this problem you were to determine a coordinate where the grasshoper would fall down. To do so, let's keep the position of grasshoper at a certain moment of time.To avoid TLE one should \"move\" the grasshoper along a platform in O(1) time (not in the cycle). The grasshoper will do j = (righti-x)/d jumps along platform \"i\", where x is the grasshoper's coordinate (he's standing at the platform), and righti is a right coordinate of the platform. So we can move the grasshoper on j*d to the right at once. Problem C. StripeBrute forceOne should keep two sums S1 ans S2, where S1 is the sum of all numbers on the left part of the stripe, and S2 is the sum of the right one. At the beginning S1 = 0 and S2 equals to the sum of all numbers of the stripe. Then we move the border of the parts within a cycle from left to right recalculating the values of S1 and S2 each iteration and increasing the answer when it's necessary.Problem D. Seller BobGreedy, long arithmeticsIn this problem we need big integers because the number 22000 doesn't fit in int64.We are given an assertion that for every memory stick there will be at most one potential customer. Since 2x > 2x-1 + 2x-2 + ... 20, the earnings of selling the most expensive stick will be greater than the earnings of selling all other sticks. So we first try to sell the most expensive stick, then the second one and so on. So one should try to sell sticks in descending order of their costs. Probelm E. Flag 2Dynamic programmingIn this problem one should use dynamic programming. Consider the function DP(level, A, B) (where A and B are the numbers of colors, from 0 to 25), which returns the minimal number of repaintings required to repaint the first level rows. The last row will be like ABABAB...Consider recalculating of this function. First, calculate the number of repaintings required for row level to be like ABABAB... (let D will be this number). Obviously, the row can be painted so if the color of the first element of the previous row is not \"A\" and the second one - not \"B\" (it's a condition of adjacent cells not to have the same color) or it should be the first row. So DP(level, A, B) = min(DP(level-1, i, j)) + D , i = 0..25, j = 0..25, i != j, i != B, j != A.Estimate the run time of our program: O(N*26*26*(M+26*26)), this value is smaller than 4*108Great thanks to Ilya Akolzin for his help in  translation",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/463",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3215
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #18(Div. 2) Tutorial - Codeforces - Code 1",
          "code": "5win 10win 5sell 5win 1sell 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/463",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x1 = inf.readInt(-100, 100, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-100, 100, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(-100, 100, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-100, 100, \"y2\");\n    inf.readSpace();\n    int x3 = inf.readInt(-100, 100, \"x3\");\n    inf.readSpace();\n    int y3 = inf.readInt(-100, 100, \"y3\");\n    inf.readEoln();\n\n    // Check that the triangle is non-degenerate (area is not zero)\n    long long area2 = abs(1LL * x1 * (y2 - y3) + 1LL * x2 * (y3 - y1) + 1LL * x3 * (y1 - y2));\n    ensuref(area2 > 0, \"The triangle is degenerate (area zero)\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x1 = inf.readInt(-100, 100, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-100, 100, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(-100, 100, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-100, 100, \"y2\");\n    inf.readSpace();\n    int x3 = inf.readInt(-100, 100, \"x3\");\n    inf.readSpace();\n    int y3 = inf.readInt(-100, 100, \"y3\");\n    inf.readEoln();\n\n    // Check that the triangle is non-degenerate (area is not zero)\n    long long area2 = abs(1LL * x1 * (y2 - y3) + 1LL * x2 * (y3 - y1) + 1LL * x3 * (y1 - y2));\n    ensuref(area2 > 0, \"The triangle is degenerate (area zero)\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x1 = inf.readInt(-100, 100, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-100, 100, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(-100, 100, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-100, 100, \"y2\");\n    inf.readSpace();\n    int x3 = inf.readInt(-100, 100, \"x3\");\n    inf.readSpace();\n    int y3 = inf.readInt(-100, 100, \"y3\");\n    inf.readEoln();\n\n    // Check that the triangle is non-degenerate (area is not zero)\n    long long area2 = abs(1LL * x1 * (y2 - y3) + 1LL * x2 * (y3 - y1) + 1LL * x3 * (y1 - y2));\n    ensuref(area2 > 0, \"The triangle is degenerate (area zero)\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");  // \"RIGHT\", \"ALMOST\", \"NEITHER\"\n    int min_coord = opt<int>(\"min_coord\", -100);\n    int max_coord = opt<int>(\"max_coord\", 100);\n\n    if (type == \"RIGHT\") {\n        // Generate a right-angled triangle\n        while (true) {\n            int x0 = rnd.next(min_coord, max_coord);\n            int y0 = rnd.next(min_coord, max_coord);\n\n            int dx1, dy1;\n            do {\n                dx1 = rnd.next(-10, 10);\n                dy1 = rnd.next(-10, 10);\n            } while (dx1 == 0 && dy1 == 0);\n\n            int x1 = x0 + dx1;\n            int y1 = y0 + dy1;\n\n            int dx2 = -dy1;\n            int dy2 = dx1;\n            int x2 = x0 + dx2;\n            int y2 = y0 + dy2;\n\n            // Ensure all coordinates are within bounds\n            if (x1 < min_coord || x1 > max_coord || y1 < min_coord || y1 > max_coord ||\n                x2 < min_coord || x2 > max_coord || y2 < min_coord || y2 > max_coord) {\n                continue;\n            }\n\n            // Output the coordinates\n            printf(\"%d %d %d %d %d %d\\n\", x0, y0, x1, y1, x2, y2);\n            break;\n        }\n    } else if (type == \"ALMOST\") {\n        // Generate an almost right-angled triangle\n        while (true) {\n            int x0 = rnd.next(min_coord, max_coord);\n            int y0 = rnd.next(min_coord, max_coord);\n\n            int dx1, dy1;\n            do {\n                dx1 = rnd.next(-10, 10);\n                dy1 = rnd.next(-10, 10);\n            } while (dx1 == 0 && dy1 == 0);\n\n            int x1 = x0 + dx1;\n            int y1 = y0 + dy1;\n\n            int dx2 = -dy1;\n            int dy2 = dx1;\n            int x2 = x0 + dx2;\n            int y2 = y0 + dy2;\n\n            if (x1 < min_coord || x1 > max_coord || y1 < min_coord || y1 > max_coord ||\n                x2 < min_coord || x2 > max_coord || y2 < min_coord || y2 > max_coord) {\n                continue;\n            }\n\n            // Now, perturb one point by moving it by distance 1\n            int idx = rnd.next(3); // 0, 1, or 2\n            int nx, ny;\n\n            vector<pair<int, int>> moves = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n            shuffle(moves.begin(), moves.end());\n\n            bool moved = false;\n            for (auto move : moves) {\n                if (idx == 0) {\n                    nx = x0 + move.first;\n                    ny = y0 + move.second;\n                } else if (idx == 1) {\n                    nx = x1 + move.first;\n                    ny = y1 + move.second;\n                } else {\n                    nx = x2 + move.first;\n                    ny = y2 + move.second;\n                }\n                // Check if within bounds\n                if (nx >= min_coord && nx <= max_coord && ny >= min_coord && ny <= max_coord) {\n                    // Now set the point\n                    if (idx == 0) {\n                        x0 = nx;\n                        y0 = ny;\n                    } else if (idx == 1) {\n                        x1 = nx;\n                        y1 = ny;\n                    } else {\n                        x2 = nx;\n                        y2 = ny;\n                    }\n                    moved = true;\n                    break;\n                }\n            }\n            if (!moved) {\n                continue;\n            }\n\n            // Output the coordinates\n            printf(\"%d %d %d %d %d %d\\n\", x0, y0, x1, y1, x2, y2);\n            break;\n        }\n    } else if (type == \"NEITHER\") {\n        // Generate a triangle that is neither right-angled nor almost right-angled\n        while (true) {\n            int x0 = rnd.next(min_coord, max_coord);\n            int y0 = rnd.next(min_coord, max_coord);\n            int x1 = rnd.next(min_coord, max_coord);\n            int y1 = rnd.next(min_coord, max_coord);\n            int x2 = rnd.next(min_coord, max_coord);\n            int y2 = rnd.next(min_coord, max_coord);\n\n            // Check if the triangle is non-degenerate\n            int area2 = abs((x1 - x0) * (y2 - y0) - (x2 - x0) * (y1 - y0));\n            if (area2 == 0) continue; // Degenerate triangle\n\n            // Output the coordinates\n            printf(\"%d %d %d %d %d %d\\n\", x0, y0, x1, y1, x2, y2);\n            break;\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");  // \"RIGHT\", \"ALMOST\", \"NEITHER\"\n    int min_coord = opt<int>(\"min_coord\", -100);\n    int max_coord = opt<int>(\"max_coord\", 100);\n\n    if (type == \"RIGHT\") {\n        // Generate a right-angled triangle\n        while (true) {\n            int x0 = rnd.next(min_coord, max_coord);\n            int y0 = rnd.next(min_coord, max_coord);\n\n            int dx1, dy1;\n            do {\n                dx1 = rnd.next(-10, 10);\n                dy1 = rnd.next(-10, 10);\n            } while (dx1 == 0 && dy1 == 0);\n\n            int x1 = x0 + dx1;\n            int y1 = y0 + dy1;\n\n            int dx2 = -dy1;\n            int dy2 = dx1;\n            int x2 = x0 + dx2;\n            int y2 = y0 + dy2;\n\n            // Ensure all coordinates are within bounds\n            if (x1 < min_coord || x1 > max_coord || y1 < min_coord || y1 > max_coord ||\n                x2 < min_coord || x2 > max_coord || y2 < min_coord || y2 > max_coord) {\n                continue;\n            }\n\n            // Output the coordinates\n            printf(\"%d %d %d %d %d %d\\n\", x0, y0, x1, y1, x2, y2);\n            break;\n        }\n    } else if (type == \"ALMOST\") {\n        // Generate an almost right-angled triangle\n        while (true) {\n            int x0 = rnd.next(min_coord, max_coord);\n            int y0 = rnd.next(min_coord, max_coord);\n\n            int dx1, dy1;\n            do {\n                dx1 = rnd.next(-10, 10);\n                dy1 = rnd.next(-10, 10);\n            } while (dx1 == 0 && dy1 == 0);\n\n            int x1 = x0 + dx1;\n            int y1 = y0 + dy1;\n\n            int dx2 = -dy1;\n            int dy2 = dx1;\n            int x2 = x0 + dx2;\n            int y2 = y0 + dy2;\n\n            if (x1 < min_coord || x1 > max_coord || y1 < min_coord || y1 > max_coord ||\n                x2 < min_coord || x2 > max_coord || y2 < min_coord || y2 > max_coord) {\n                continue;\n            }\n\n            // Now, perturb one point by moving it by distance 1\n            int idx = rnd.next(3); // 0, 1, or 2\n            int nx, ny;\n\n            vector<pair<int, int>> moves = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n            shuffle(moves.begin(), moves.end());\n\n            bool moved = false;\n            for (auto move : moves) {\n                if (idx == 0) {\n                    nx = x0 + move.first;\n                    ny = y0 + move.second;\n                } else if (idx == 1) {\n                    nx = x1 + move.first;\n                    ny = y1 + move.second;\n                } else {\n                    nx = x2 + move.first;\n                    ny = y2 + move.second;\n                }\n                // Check if within bounds\n                if (nx >= min_coord && nx <= max_coord && ny >= min_coord && ny <= max_coord) {\n                    // Now set the point\n                    if (idx == 0) {\n                        x0 = nx;\n                        y0 = ny;\n                    } else if (idx == 1) {\n                        x1 = nx;\n                        y1 = ny;\n                    } else {\n                        x2 = nx;\n                        y2 = ny;\n                    }\n                    moved = true;\n                    break;\n                }\n            }\n            if (!moved) {\n                continue;\n            }\n\n            // Output the coordinates\n            printf(\"%d %d %d %d %d %d\\n\", x0, y0, x1, y1, x2, y2);\n            break;\n        }\n    } else if (type == \"NEITHER\") {\n        // Generate a triangle that is neither right-angled nor almost right-angled\n        while (true) {\n            int x0 = rnd.next(min_coord, max_coord);\n            int y0 = rnd.next(min_coord, max_coord);\n            int x1 = rnd.next(min_coord, max_coord);\n            int y1 = rnd.next(min_coord, max_coord);\n            int x2 = rnd.next(min_coord, max_coord);\n            int y2 = rnd.next(min_coord, max_coord);\n\n            // Check if the triangle is non-degenerate\n            int area2 = abs((x1 - x0) * (y2 - y0) - (x2 - x0) * (y1 - y0));\n            if (area2 == 0) continue; // Degenerate triangle\n\n            // Output the coordinates\n            printf(\"%d %d %d %d %d %d\\n\", x0, y0, x1, y1, x2, y2);\n            break;\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Generate RIGHT-angled triangles\n./gen -type RIGHT\n./gen -type RIGHT\n./gen -type RIGHT\n./gen -type RIGHT\n./gen -type RIGHT\n\n# Generate ALMOST right-angled triangles\n./gen -type ALMOST\n./gen -type ALMOST\n./gen -type ALMOST\n./gen -type ALMOST\n./gen -type ALMOST\n\n# Generate NEITHER right-angled nor almost right-angled triangles\n./gen -type NEITHER\n./gen -type NEITHER\n./gen -type NEITHER\n./gen -type NEITHER\n./gen -type NEITHER\n\n# Generate RIGHT-angled triangles with larger coordinate ranges\n./gen -type RIGHT -min_coord -100 -max_coord 100\n./gen -type RIGHT -min_coord -50 -max_coord 50\n./gen -type RIGHT -min_coord -10 -max_coord 10\n./gen -type RIGHT -min_coord -1 -max_coord 1\n\n# Generate ALMOST right-angled triangles near coordinate boundaries\n./gen -type ALMOST -min_coord -100 -max_coord -90\n./gen -type ALMOST -min_coord 90 -max_coord 100\n./gen -type ALMOST -min_coord -10 -max_coord 10\n./gen -type ALMOST -min_coord -1 -max_coord 1\n\n# Generate NEITHER triangles with small coordinate ranges\n./gen -type NEITHER -min_coord -10 -max_coord 10\n./gen -type NEITHER -min_coord -5 -max_coord 5\n./gen -type NEITHER -min_coord -1 -max_coord 1\n\n# Generate RIGHT-angled triangles near coordinate boundaries\n./gen -type RIGHT -min_coord -100 -max_coord -90\n./gen -type RIGHT -min_coord 90 -max_coord 100\n\n# Generate NEITHER triangles near coordinate boundaries\n./gen -type NEITHER -min_coord -100 -max_coord -90\n./gen -type NEITHER -min_coord 90 -max_coord 100\n\n# Generate more random test cases\n./gen -type RIGHT\n./gen -type ALMOST\n./gen -type NEITHER\n./gen -type RIGHT\n./gen -type ALMOST\n./gen -type NEITHER\n\n# Total commands: 30\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:21.891318",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "18/B",
      "title": "B. Platforms",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first input line contains 4 integer numbers n, d, m, l (1 ≤ n, d, m, l ≤ 106, l < m) — respectively: amount of platforms, length of the grasshopper Bob's jump, and numbers m and l needed to find coordinates of the k-th platform: [(k - 1)m, (k - 1)m + l].",
      "output_spec": "OutputOutput the coordinates of the point, where the grosshopper will fall down. Don't forget that if Bob finds himself on the platform edge, he doesn't fall down.",
      "sample_tests": "ExamplesInputCopy2 2 5 3OutputCopy4InputCopy5 4 11 8OutputCopy20",
      "description": "B. Platforms\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains 4 integer numbers n, d, m, l (1 ≤ n, d, m, l ≤ 106, l < m) — respectively: amount of platforms, length of the grasshopper Bob's jump, and numbers m and l needed to find coordinates of the k-th platform: [(k - 1)m, (k - 1)m + l].\n\nOutputOutput the coordinates of the point, where the grosshopper will fall down. Don't forget that if Bob finds himself on the platform edge, he doesn't fall down.\n\nInputCopy2 2 5 3OutputCopy4InputCopy5 4 11 8OutputCopy20\n\nInputCopy2 2 5 3\n\nOutputCopy4\n\nInputCopy5 4 11 8\n\nOutputCopy20",
      "solutions": [
        {
          "title": "Codeforces Beta Round #18 (Div. 2) - Codeforces",
          "content": "Welcome to Codeforces Beta Round #18 Authors of today's contest are Mike Mirzayanov, Edvard Davtyan and me. Thanks to Dmitry Matov for his help in statements preparation and Julia Satushina for translation of problems in English. Good luck everyone!ProblemsFinal standingsContest winner: I_am_Feeling_Lucky",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/462",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 18"
          },
          "content_length": 306
        },
        {
          "title": "Codeforces Beta Round #18(Div. 2) Tutorial - Codeforces",
          "content": "Contest discussionProblem А. TrianglePythagorean theorem, brute forceIn this problem you should implement a function, which takes three points and checks whether they form a right-angled triangle. There are a lot of ways to do so, but the simplest one is using a Pythagorean theorem. You should use squared distances instead of taking roots to overcome problems related to precision errors.To examine a triangle on almost-rightness, you can try to move each point in each of four possible directions and check the new triangle using our function. It's good and easy to use two arrays: dx={-1,0,1,0} and dy={0,1,0,-1} for moving. Then we can get the new coordinates of shifted point simply using the following code:for (int i = 0; i < 4; i ++){int x = dx[i] + px;int y = dy[i] + py;}Problem B. PlatformsSimulationIllustrative picture:In this problem you were to determine a coordinate where the grasshoper would fall down. To do so, let's keep the position of grasshoper at a certain moment of time.To avoid TLE one should \"move\" the grasshoper along a platform in O(1) time (not in the cycle). The grasshoper will do j = (righti-x)/d jumps along platform \"i\", where x is the grasshoper's coordinate (he's standing at the platform), and righti is a right coordinate of the platform. So we can move the grasshoper on j*d to the right at once. Problem C. StripeBrute forceOne should keep two sums S1 ans S2, where S1 is the sum of all numbers on the left part of the stripe, and S2 is the sum of the right one. At the beginning S1 = 0 and S2 equals to the sum of all numbers of the stripe. Then we move the border of the parts within a cycle from left to right recalculating the values of S1 and S2 each iteration and increasing the answer when it's necessary.Problem D. Seller BobGreedy, long arithmeticsIn this problem we need big integers because the number 22000 doesn't fit in int64.We are given an assertion that for every memory stick there will be at most one potential customer. Since 2x > 2x-1 + 2x-2 + ... 20, the earnings of selling the most expensive stick will be greater than the earnings of selling all other sticks. So we first try to sell the most expensive stick, then the second one and so on. So one should try to sell sticks in descending order of their costs. Probelm E. Flag 2Dynamic programmingIn this problem one should use dynamic programming. Consider the function DP(level, A, B) (where A and B are the numbers of colors, from 0 to 25), which returns the minimal number of repaintings required to repaint the first level rows. The last row will be like ABABAB...Consider recalculating of this function. First, calculate the number of repaintings required for row level to be like ABABAB... (let D will be this number). Obviously, the row can be painted so if the color of the first element of the previous row is not \"A\" and the second one - not \"B\" (it's a condition of adjacent cells not to have the same color) or it should be the first row. So DP(level, A, B) = min(DP(level-1, i, j)) + D , i = 0..25, j = 0..25, i != j, i != B, j != A.Estimate the run time of our program: O(N*26*26*(M+26*26)), this value is smaller than 4*108Great thanks to Ilya Akolzin for his help in  translation",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/463",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3215
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #18(Div. 2) Tutorial - Codeforces - Code 1",
          "code": "5win 10win 5sell 5win 1sell 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/463",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000, \"d\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readSpace();\n    int l = inf.readInt(1, 1000000, \"l\");\n    inf.readEoln();\n    ensuref(l < m, \"l(%d) should be less than m(%d)\", l, m);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000, \"d\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readSpace();\n    int l = inf.readInt(1, 1000000, \"l\");\n    inf.readEoln();\n    ensuref(l < m, \"l(%d) should be less than m(%d)\", l, m);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000, \"d\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readSpace();\n    int l = inf.readInt(1, 1000000, \"l\");\n    inf.readEoln();\n    ensuref(l < m, \"l(%d) should be less than m(%d)\", l, m);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 1000000; // 1e6\nconst int MINN = 1;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int n, m, l, d;\n\n    if (type == \"min_values\") {\n        n = 1;\n        m = 2;\n        l = 1; // l < m\n        d = 1;\n    } else if (type == \"max_values\") {\n        n = 1000000;\n        m = 1000000;\n        l = m - 1; // l < m\n        d = 1000000;\n    } else if (type == \"l_equal_m_minus_1\") {\n        n = rnd.next(MINN, MAXN);\n        m = rnd.next(2, 1000000);\n        l = m - 1;\n        d = rnd.next(1, 1000000);\n    } else if (type == \"l_equal_1\") {\n        n = rnd.next(MINN, MAXN);\n        m = rnd.next(2, 1000000);\n        l = 1;\n        d = rnd.next(1, 1000000);\n    } else if (type == \"m_mod_d_0\") {\n        n = rnd.next(MINN, MAXN);\n        d = rnd.next(1, 1000000);\n        m = d * rnd.next(1, 1000000 / d); // m is multiple of d\n        if (m > 1000000) m = 1000000;\n        l = rnd.next(1, m - 1);\n    } else if (type == \"m_mod_d_not_0\") {\n        n = rnd.next(MINN, MAXN);\n        d = rnd.next(1, 1000000);\n        m = rnd.next(1, 1000000);\n        while (m % d == 0) {\n            m = rnd.next(1, 1000000);\n        }\n        if (m <= 1) m = 2; // ensure m >= 2\n        l = rnd.next(1, m - 1);\n    } else if (type == \"d_greater_m\") {\n        n = rnd.next(MINN, MAXN);\n        m = rnd.next(1, 999999); // m ≤ 1e6 - 1\n        d = rnd.next(m + 1, 1000000);\n        l = rnd.next(1, m - 1);\n    } else if (type == \"d_equals_m\") {\n        n = rnd.next(MINN, MAXN);\n        m = rnd.next(1, 1000000);\n        d = m;\n        l = rnd.next(1, m - 1);\n    } else if (type == \"random_small\") {\n        n = rnd.next(1, 1000); // small n\n        m = rnd.next(2, 1000);\n        l = rnd.next(1, m - 1);\n        d = rnd.next(1, 1000);\n    } else if (type == \"random_large\") {\n        n = rnd.next(100000, 1000000);\n        m = rnd.next(2, 1000000);\n        l = rnd.next(1, m - 1);\n        d = rnd.next(1, 1000000);\n    } else {\n        // default random\n        n = rnd.next(MINN, MAXN);\n        m = rnd.next(2, 1000000);\n        l = rnd.next(1, m - 1);\n        d = rnd.next(1, 1000000);\n    }\n\n    // Output n, d, m, l\n    printf(\"%d %d %d %d\\n\", n, d, m, l);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 1000000; // 1e6\nconst int MINN = 1;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int n, m, l, d;\n\n    if (type == \"min_values\") {\n        n = 1;\n        m = 2;\n        l = 1; // l < m\n        d = 1;\n    } else if (type == \"max_values\") {\n        n = 1000000;\n        m = 1000000;\n        l = m - 1; // l < m\n        d = 1000000;\n    } else if (type == \"l_equal_m_minus_1\") {\n        n = rnd.next(MINN, MAXN);\n        m = rnd.next(2, 1000000);\n        l = m - 1;\n        d = rnd.next(1, 1000000);\n    } else if (type == \"l_equal_1\") {\n        n = rnd.next(MINN, MAXN);\n        m = rnd.next(2, 1000000);\n        l = 1;\n        d = rnd.next(1, 1000000);\n    } else if (type == \"m_mod_d_0\") {\n        n = rnd.next(MINN, MAXN);\n        d = rnd.next(1, 1000000);\n        m = d * rnd.next(1, 1000000 / d); // m is multiple of d\n        if (m > 1000000) m = 1000000;\n        l = rnd.next(1, m - 1);\n    } else if (type == \"m_mod_d_not_0\") {\n        n = rnd.next(MINN, MAXN);\n        d = rnd.next(1, 1000000);\n        m = rnd.next(1, 1000000);\n        while (m % d == 0) {\n            m = rnd.next(1, 1000000);\n        }\n        if (m <= 1) m = 2; // ensure m >= 2\n        l = rnd.next(1, m - 1);\n    } else if (type == \"d_greater_m\") {\n        n = rnd.next(MINN, MAXN);\n        m = rnd.next(1, 999999); // m ≤ 1e6 - 1\n        d = rnd.next(m + 1, 1000000);\n        l = rnd.next(1, m - 1);\n    } else if (type == \"d_equals_m\") {\n        n = rnd.next(MINN, MAXN);\n        m = rnd.next(1, 1000000);\n        d = m;\n        l = rnd.next(1, m - 1);\n    } else if (type == \"random_small\") {\n        n = rnd.next(1, 1000); // small n\n        m = rnd.next(2, 1000);\n        l = rnd.next(1, m - 1);\n        d = rnd.next(1, 1000);\n    } else if (type == \"random_large\") {\n        n = rnd.next(100000, 1000000);\n        m = rnd.next(2, 1000000);\n        l = rnd.next(1, m - 1);\n        d = rnd.next(1, 1000000);\n    } else {\n        // default random\n        n = rnd.next(MINN, MAXN);\n        m = rnd.next(2, 1000000);\n        l = rnd.next(1, m - 1);\n        d = rnd.next(1, 1000000);\n    }\n\n    // Output n, d, m, l\n    printf(\"%d %d %d %d\\n\", n, d, m, l);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_values\n./gen -type max_values\n./gen -type l_equal_m_minus_1\n./gen -type l_equal_1\n./gen -type m_mod_d_0\n./gen -type m_mod_d_not_0\n./gen -type d_greater_m\n./gen -type d_equals_m\n./gen -type random_small\n./gen -type random_large\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random_small\n./gen -type random_small\n./gen -type random_large\n./gen -type random_large\n./gen -type m_mod_d_0\n./gen -type m_mod_d_not_0\n./gen -type d_greater_m\n./gen -type d_equals_m\n./gen -type l_equal_m_minus_1\n./gen -type l_equal_1\n./gen -type random\n./gen -type random\n./gen -type random_small\n./gen -type random_large\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:24.270396",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "18/C",
      "title": "C. Полоска",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест64 megabytes",
      "input_spec": "Входные данныеВ первой строке входных данных содержится целое число n (1 ≤ n ≤ 105) — количество клеток в полоске. Во второй строке содержится n чисел, разделенных пробелами — числа, записанные в клетках полоски. Эти числа целые и не превосходят по модулю 10000.",
      "output_spec": "Выходные данныеВыведите число способов разрезать полоску на две непустые части так, чтобы сумма чисел в одной части была равна сумме чисел в другой части. Не забудьте, что разрезать полоску разрешается только по границам клеток.",
      "sample_tests": "ПримерыВходные данныеСкопировать91 5 -6 7 9 -16 0 -2 2Выходные данныеСкопировать3Входные данныеСкопировать31 1 1Выходные данныеСкопировать0Входные данныеСкопировать20 0Выходные данныеСкопировать1",
      "description": "ограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест64 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных содержится целое число n (1 ≤ n ≤ 105) — количество клеток в полоске. Во второй строке содержится n чисел, разделенных пробелами — числа, записанные в клетках полоски. Эти числа целые и не превосходят по модулю 10000.\n\nВходные данные\n\nВыходные данныеВыведите число способов разрезать полоску на две непустые части так, чтобы сумма чисел в одной части была равна сумме чисел в другой части. Не забудьте, что разрезать полоску разрешается только по границам клеток.\n\nВыходные данные\n\nВходные данныеСкопировать91 5 -6 7 9 -16 0 -2 2Выходные данныеСкопировать3Входные данныеСкопировать31 1 1Выходные данныеСкопировать0Входные данныеСкопировать20 0Выходные данныеСкопировать1\n\nВходные данныеСкопировать91 5 -6 7 9 -16 0 -2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать31 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать20 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #18 (Див. 2) - Codeforces",
          "content": "Добро пожаловать на Codeforces Beta Round #18 Авторы задач сегодняшнего контеста: Михаил Мирзаянов, Эдвард Давтян и я. Спасибо Дмитрию Матову за помощь в подготовке условий и Юлии Сатушиной за перевод задач на английский язык. Всем удачи!ЗадачиРезультатыПобедитель: I_am_Feeling_Lucky",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/462",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 18"
          },
          "content_length": 284
        },
        {
          "title": "Разбор задач Codeforces Beta Round #18 - Codeforces",
          "content": "Обсуждение контестаЗадача А. ТреугольникиТематика: Теорема Пифагора, переборВ данной задаче нужно было написать функцию, проверяющую, что три точки образуют прямоугольный треугольник. Сделать это можно было множеством способов, один из самых простых - теорема Пифагора Чтобы избежать проблем с погрешностью, можно было не извлекать корень, а использовать квадрат расстояния.Чтобы проверить треугольник на почти прямоугольность, нужно было поочередно подвигать каждую точку во все 4 направления и проверить получившийся треугольник в нашей функции. Для быстрого перебора смещения, можно использовать два массива dx={-1,0,1,0} и dy={0,1,0,-1}. Тогда следующий код давал бы нам координаты смещенной точки:for (int i = 0; i < 4; i ++){int x = dx[i] + px;int y = dy[i] + py;}Задача B. ПлатформыТематика: СимуляцияРисунок к задаче:В данной задачи нужно было определить координату падения кузнечика. Для этого просто будем хранить положение кузнечика в данный момент. Для того, чтобы программа не работала слишком долго, нужно \"продвигать кузнечика\" по платформе за О(1) (не в цикле). Кузнечик сделает j = (righti-x)/d прыжков по i-ой, платформе, где x - координата кузнечика (он уже стоит на платформе) а righti - правая координата платформы. Поэтому кузнечка сразу можно передвинуть на j*d право.Задача C. ПолоскаТематика: ПереборДля решения данной задачи нужно было хранить две суммы S1 - сумма чисел слева от разреза (изначально равна 0) и S2 - сумма чисел справа от разреза (изначально равна сумме всех чисел на полоске). В цикле двигаем место разреза слева направо, изменяя значения сумм, и, при необходимости, увеличиваем ответЗадача D. Продавец ВасяТематика: Жадный алгоритм, длинная арифметикаВ задаче D потребуется длинная арифметика (сложение), так как число 22000 не вместится в int64.Нам дано условие того, что продавец для каждого размера флешки встретится не более одного раза. Так как 2x > 2x-1 + 2x-2 + ... 20, то прибыль от флешки с самым большим объемом будет больше чем если бы мы продали все остальные флешки. Поэтому в первую очередь нужно попытаться продать самую большую флешку, потом флешку поменьше и т.д. Таким образом, нужно пытаться продать флешки по убыванию их стоимостиЗадача E. Флаг 2Тематика: Динамическое программированиеВ задаче про флаг необходимо воспользоваться методом динамического программирования. Мы будем считать функцию DP(level, A, B) (где A и B - номера цветов, от 0 до 25), которая возвращает минимальное число перекрасок, нужное чтобы перекрасить первые level полосок, причем последняя полоска будет иметь вид ABABAB...Для пересчета данной функции сначала посчитаем, сколько перекрасок нужно, чтобы привести полоску с номером level к виду ABABAB... (пусть это будет число D). Заметим, что полоску можно покрасить таким образом, если первый цвет предыдущей полоски не был \"A\", а второй цвет не был \"B\" (условие того, что смежные клетки не должны быть одного цвета) или же это должна быть первая полоска. Поэтому DP(level, A, B) = min(DP(level-1, i, j)) + D , i = 0..25, j = 0..25, i != j, i != B, j != A.Оценим время работы программы: O(N*26*26*(M+26*26)), эта константа не превышает 4*108Спасибо за внимание! Решения не претендуют на оптимальность",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/463",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3190
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #18 (Див. 2) - Codeforces - Code 1",
          "code": "10\nsell 179\nwin 1278\nsell 1278\nwin 179\nwin 788\nsell 788\nwin 1819\nwin 1278\nsell 1454\nsell 1819",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/462",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Beta Round #18 - Codeforces - Code 1",
          "code": "5win 10win 5sell 5win 1sell 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/463",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, -10000, 10000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, -10000, 10000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, -10000, 10000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const int MAX_VAL = 10000;\n\n    vector<int> a(n);\n\n    if (type == \"zeros\") {\n        // All zeros\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"positive\") {\n        // All positive max value\n        for(int i = 0; i < n; ++i)\n            a[i] = MAX_VAL;\n    } else if (type == \"negative\") {\n        // All negative min value\n        for(int i = 0; i < n; ++i)\n            a[i] = -MAX_VAL;\n    } else if (type == \"alternating\") {\n        // Alternating positive and negative\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? MAX_VAL : -MAX_VAL;\n    } else if (type == \"sum_zero\") {\n        // Generate numbers that sum to zero\n        long long sum = 0;\n        for(int i = 0; i < n-1; ++i) {\n            a[i] = rnd.next(-MAX_VAL, MAX_VAL);\n            sum += a[i];\n        }\n        a[n-1] = -sum;\n        if (a[n-1] < -MAX_VAL || a[n-1] > MAX_VAL) {\n            // Adjusting to fit within the range\n            a[0] += a[n-1];\n            a[n-1] = -sum - a[0];\n            if (a[0] < -MAX_VAL || a[0] > MAX_VAL || a[n-1] < -MAX_VAL || a[n-1] > MAX_VAL) {\n                // If adjustment goes out of bounds, assign zeros\n                for(int i = 0; i < n; ++i)\n                    a[i] = 0;\n            }\n        }\n    } else if (type == \"sum_nonzero\") {\n        // Generate numbers that sum to a non-zero value\n        long long sum = 0;\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-MAX_VAL, MAX_VAL);\n            sum += a[i];\n        }\n        if (sum == 0) {\n            // Adjust first element to make sum non-zero\n            if (a[0] != MAX_VAL)\n                a[0]++;\n            else\n                a[0]--;\n        }\n    } else if (type == \"no_solution\") {\n        // Generate array with no valid cuts\n        if (n % 2 == 1) {\n            for(int i = 0; i < n; ++i)\n                a[i] = MAX_VAL;\n        } else {\n            for(int i = 0; i < n; ++i)\n                a[i] = MAX_VAL;\n            a[0] = MAX_VAL - 1; // Adjust to make total sum odd\n        }\n    } else if (type == \"multiple_solutions\") {\n        // All zeros, maximum number of valid cuts\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else {\n        // Random integers within the constraints\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-MAX_VAL, MAX_VAL);\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    const int MAX_VAL = 10000;\n\n    vector<int> a(n);\n\n    if (type == \"zeros\") {\n        // All zeros\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"positive\") {\n        // All positive max value\n        for(int i = 0; i < n; ++i)\n            a[i] = MAX_VAL;\n    } else if (type == \"negative\") {\n        // All negative min value\n        for(int i = 0; i < n; ++i)\n            a[i] = -MAX_VAL;\n    } else if (type == \"alternating\") {\n        // Alternating positive and negative\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? MAX_VAL : -MAX_VAL;\n    } else if (type == \"sum_zero\") {\n        // Generate numbers that sum to zero\n        long long sum = 0;\n        for(int i = 0; i < n-1; ++i) {\n            a[i] = rnd.next(-MAX_VAL, MAX_VAL);\n            sum += a[i];\n        }\n        a[n-1] = -sum;\n        if (a[n-1] < -MAX_VAL || a[n-1] > MAX_VAL) {\n            // Adjusting to fit within the range\n            a[0] += a[n-1];\n            a[n-1] = -sum - a[0];\n            if (a[0] < -MAX_VAL || a[0] > MAX_VAL || a[n-1] < -MAX_VAL || a[n-1] > MAX_VAL) {\n                // If adjustment goes out of bounds, assign zeros\n                for(int i = 0; i < n; ++i)\n                    a[i] = 0;\n            }\n        }\n    } else if (type == \"sum_nonzero\") {\n        // Generate numbers that sum to a non-zero value\n        long long sum = 0;\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-MAX_VAL, MAX_VAL);\n            sum += a[i];\n        }\n        if (sum == 0) {\n            // Adjust first element to make sum non-zero\n            if (a[0] != MAX_VAL)\n                a[0]++;\n            else\n                a[0]--;\n        }\n    } else if (type == \"no_solution\") {\n        // Generate array with no valid cuts\n        if (n % 2 == 1) {\n            for(int i = 0; i < n; ++i)\n                a[i] = MAX_VAL;\n        } else {\n            for(int i = 0; i < n; ++i)\n                a[i] = MAX_VAL;\n            a[0] = MAX_VAL - 1; // Adjust to make total sum odd\n        }\n    } else if (type == \"multiple_solutions\") {\n        // All zeros, maximum number of valid cuts\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else {\n        // Random integers within the constraints\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-MAX_VAL, MAX_VAL);\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type zeros\n./gen -n 2 -type zeros\n./gen -n 10 -type zeros\n./gen -n 100 -type zeros\n./gen -n 1000 -type zeros\n./gen -n 10000 -type zeros\n./gen -n 100000 -type zeros\n\n./gen -n 1 -type positive\n./gen -n 2 -type positive\n./gen -n 10 -type positive\n./gen -n 100 -type positive\n./gen -n 1000 -type positive\n./gen -n 10000 -type positive\n./gen -n 100000 -type positive\n\n./gen -n 1 -type negative\n./gen -n 2 -type negative\n./gen -n 10 -type negative\n./gen -n 100 -type negative\n./gen -n 1000 -type negative\n./gen -n 10000 -type negative\n./gen -n 100000 -type negative\n\n./gen -n 1 -type alternating\n./gen -n 2 -type alternating\n./gen -n 10 -type alternating\n./gen -n 100 -type alternating\n./gen -n 1000 -type alternating\n./gen -n 10000 -type alternating\n./gen -n 100000 -type alternating\n\n./gen -n 2 -type sum_zero\n./gen -n 10 -type sum_zero\n./gen -n 100 -type sum_zero\n./gen -n 1000 -type sum_zero\n./gen -n 10000 -type sum_zero\n./gen -n 100000 -type sum_zero\n\n./gen -n 2 -type sum_nonzero\n./gen -n 10 -type sum_nonzero\n./gen -n 100 -type sum_nonzero\n./gen -n 1000 -type sum_nonzero\n./gen -n 10000 -type sum_nonzero\n./gen -n 100000 -type sum_nonzero\n\n./gen -n 2 -type no_solution\n./gen -n 5 -type no_solution\n./gen -n 10 -type no_solution\n./gen -n 100 -type no_solution\n./gen -n 1000 -type no_solution\n./gen -n 10000 -type no_solution\n./gen -n 100000 -type no_solution\n\n./gen -n 2 -type multiple_solutions\n./gen -n 5 -type multiple_solutions\n./gen -n 10 -type multiple_solutions\n./gen -n 100 -type multiple_solutions\n./gen -n 1000 -type multiple_solutions\n./gen -n 10000 -type multiple_solutions\n./gen -n 100000 -type multiple_solutions\n\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:26.467040",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "18/D",
      "title": "D. Seller Bob",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test128 megabytes",
      "input_spec": "InputThe first input line contains number n (1 ≤ n ≤ 5000) — amount of Bob's working days. The following n lines contain the description of the days. Line sell x stands for a day when a customer came to Bob to buy a 2x MB memory stick (0 ≤ x ≤ 2000). It's guaranteed that for each x there is not more than one line sell x. Line win x stands for a day when Bob won a 2x MB memory stick (0 ≤ x ≤ 2000).",
      "output_spec": "OutputOutput the maximum possible earnings for Bob in berllars, that he would have had if he had known all the events beforehand. Don't forget, please, that Bob can't keep more than one memory stick at a time.",
      "sample_tests": "ExamplesInputCopy7win 10win 5win 3sell 5sell 3win 10sell 10OutputCopy1056InputCopy3win 5sell 6sell 4OutputCopy0",
      "description": "D. Seller Bob\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test128 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains number n (1 ≤ n ≤ 5000) — amount of Bob's working days. The following n lines contain the description of the days. Line sell x stands for a day when a customer came to Bob to buy a 2x MB memory stick (0 ≤ x ≤ 2000). It's guaranteed that for each x there is not more than one line sell x. Line win x stands for a day when Bob won a 2x MB memory stick (0 ≤ x ≤ 2000).\n\nOutputOutput the maximum possible earnings for Bob in berllars, that he would have had if he had known all the events beforehand. Don't forget, please, that Bob can't keep more than one memory stick at a time.\n\nInputCopy7win 10win 5win 3sell 5sell 3win 10sell 10OutputCopy1056InputCopy3win 5sell 6sell 4OutputCopy0\n\nInputCopy7win 10win 5win 3sell 5sell 3win 10sell 10\n\nOutputCopy1056\n\nInputCopy3win 5sell 6sell 4\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Beta Round #18 (Div. 2) - Codeforces",
          "content": "Welcome to Codeforces Beta Round #18 Authors of today's contest are Mike Mirzayanov, Edvard Davtyan and me. Thanks to Dmitry Matov for his help in statements preparation and Julia Satushina for translation of problems in English. Good luck everyone!ProblemsFinal standingsContest winner: I_am_Feeling_Lucky",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/462",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 18"
          },
          "content_length": 306
        },
        {
          "title": "Codeforces Beta Round #18(Div. 2) Tutorial - Codeforces",
          "content": "Contest discussionProblem А. TrianglePythagorean theorem, brute forceIn this problem you should implement a function, which takes three points and checks whether they form a right-angled triangle. There are a lot of ways to do so, but the simplest one is using a Pythagorean theorem. You should use squared distances instead of taking roots to overcome problems related to precision errors.To examine a triangle on almost-rightness, you can try to move each point in each of four possible directions and check the new triangle using our function. It's good and easy to use two arrays: dx={-1,0,1,0} and dy={0,1,0,-1} for moving. Then we can get the new coordinates of shifted point simply using the following code:for (int i = 0; i < 4; i ++){int x = dx[i] + px;int y = dy[i] + py;}Problem B. PlatformsSimulationIllustrative picture:In this problem you were to determine a coordinate where the grasshoper would fall down. To do so, let's keep the position of grasshoper at a certain moment of time.To avoid TLE one should \"move\" the grasshoper along a platform in O(1) time (not in the cycle). The grasshoper will do j = (righti-x)/d jumps along platform \"i\", where x is the grasshoper's coordinate (he's standing at the platform), and righti is a right coordinate of the platform. So we can move the grasshoper on j*d to the right at once. Problem C. StripeBrute forceOne should keep two sums S1 ans S2, where S1 is the sum of all numbers on the left part of the stripe, and S2 is the sum of the right one. At the beginning S1 = 0 and S2 equals to the sum of all numbers of the stripe. Then we move the border of the parts within a cycle from left to right recalculating the values of S1 and S2 each iteration and increasing the answer when it's necessary.Problem D. Seller BobGreedy, long arithmeticsIn this problem we need big integers because the number 22000 doesn't fit in int64.We are given an assertion that for every memory stick there will be at most one potential customer. Since 2x > 2x-1 + 2x-2 + ... 20, the earnings of selling the most expensive stick will be greater than the earnings of selling all other sticks. So we first try to sell the most expensive stick, then the second one and so on. So one should try to sell sticks in descending order of their costs. Probelm E. Flag 2Dynamic programmingIn this problem one should use dynamic programming. Consider the function DP(level, A, B) (where A and B are the numbers of colors, from 0 to 25), which returns the minimal number of repaintings required to repaint the first level rows. The last row will be like ABABAB...Consider recalculating of this function. First, calculate the number of repaintings required for row level to be like ABABAB... (let D will be this number). Obviously, the row can be painted so if the color of the first element of the previous row is not \"A\" and the second one - not \"B\" (it's a condition of adjacent cells not to have the same color) or it should be the first row. So DP(level, A, B) = min(DP(level-1, i, j)) + D , i = 0..25, j = 0..25, i != j, i != B, j != A.Estimate the run time of our program: O(N*26*26*(M+26*26)), this value is smaller than 4*108Great thanks to Ilya Akolzin for his help in  translation",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/463",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3215
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #18(Div. 2) Tutorial - Codeforces - Code 1",
          "code": "5win 10win 5sell 5win 1sell 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/463",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n\n    set<int> sell_xs;\n\n    for (int i = 0; i < n; ++i) {\n\n        string s = inf.readLine(\"^(sell|win) [0-9]{1,4}$\");\n\n        size_t sp = s.find(' ');\n\n        ensuref(sp != string::npos, \"Line %d: expected space between command and number\", i+2);\n        string cmd = s.substr(0, sp);\n        string x_s = s.substr(sp+1);\n\n        int x = 0;\n        ensuref(!x_s.empty(), \"Line %d: missing integer value\", i+2);\n        for (char c : x_s) {\n            ensuref(c >= '0' && c <= '9', \"Line %d: invalid character '%c' in integer\", i+2, c);\n            x = x * 10 + (c - '0');\n        }\n\n        ensuref(x >= 0 && x <= 2000, \"Line %d: x value out of range [0,2000]: %d\", i+2, x);\n\n        if (cmd == \"sell\") {\n\n            ensuref(sell_xs.count(x) == 0, \"Line %d: x value %d appears in multiple 'sell x' commands\", i+2, x);\n            sell_xs.insert(x);\n\n        }\n        else if (cmd == \"win\") {\n            // Nothing extra to do\n\n        }\n        else {\n            ensuref(false, \"Line %d: Unknown command: %s\", i+2, cmd.c_str());\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n\n    set<int> sell_xs;\n\n    for (int i = 0; i < n; ++i) {\n\n        string s = inf.readLine(\"^(sell|win) [0-9]{1,4}$\");\n\n        size_t sp = s.find(' ');\n\n        ensuref(sp != string::npos, \"Line %d: expected space between command and number\", i+2);\n        string cmd = s.substr(0, sp);\n        string x_s = s.substr(sp+1);\n\n        int x = 0;\n        ensuref(!x_s.empty(), \"Line %d: missing integer value\", i+2);\n        for (char c : x_s) {\n            ensuref(c >= '0' && c <= '9', \"Line %d: invalid character '%c' in integer\", i+2, c);\n            x = x * 10 + (c - '0');\n        }\n\n        ensuref(x >= 0 && x <= 2000, \"Line %d: x value out of range [0,2000]: %d\", i+2, x);\n\n        if (cmd == \"sell\") {\n\n            ensuref(sell_xs.count(x) == 0, \"Line %d: x value %d appears in multiple 'sell x' commands\", i+2, x);\n            sell_xs.insert(x);\n\n        }\n        else if (cmd == \"win\") {\n            // Nothing extra to do\n\n        }\n        else {\n            ensuref(false, \"Line %d: Unknown command: %s\", i+2, cmd.c_str());\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n\n    set<int> sell_xs;\n\n    for (int i = 0; i < n; ++i) {\n\n        string s = inf.readLine(\"^(sell|win) [0-9]{1,4}$\");\n\n        size_t sp = s.find(' ');\n\n        ensuref(sp != string::npos, \"Line %d: expected space between command and number\", i+2);\n        string cmd = s.substr(0, sp);\n        string x_s = s.substr(sp+1);\n\n        int x = 0;\n        ensuref(!x_s.empty(), \"Line %d: missing integer value\", i+2);\n        for (char c : x_s) {\n            ensuref(c >= '0' && c <= '9', \"Line %d: invalid character '%c' in integer\", i+2, c);\n            x = x * 10 + (c - '0');\n        }\n\n        ensuref(x >= 0 && x <= 2000, \"Line %d: x value out of range [0,2000]: %d\", i+2, x);\n\n        if (cmd == \"sell\") {\n\n            ensuref(sell_xs.count(x) == 0, \"Line %d: x value %d appears in multiple 'sell x' commands\", i+2, x);\n            sell_xs.insert(x);\n\n        }\n        else if (cmd == \"win\") {\n            // Nothing extra to do\n\n        }\n        else {\n            ensuref(false, \"Line %d: Unknown command: %s\", i+2, cmd.c_str());\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\npattern pnum(\"0|-?[1-9][0-9]*\");\r\n\r\nbool isNumeric(const string &p) {\r\n    return pnum.matches(p);\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two signed huge integers\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    string ja = ans.readWord();\r\n    string pa = ouf.readWord();\r\n\r\n    if (!isNumeric(ja))\r\n        quitf(_fail, \"%s is not a valid integer\", compress(ja).c_str());\r\n\r\n    if (!ans.seekEof())\r\n        quitf(_fail, \"expected exactly one token in the answer file\");\r\n\r\n    if (!isNumeric(pa))\r\n        quitf(_pe, \"%s is not a valid integer\", compress(pa).c_str());\r\n\r\n    if (ja != pa)\r\n        quitf(_wa, \"expected '%s', found '%s'\", compress(ja).c_str(), compress(pa).c_str());\r\n\r\n    quitf(_ok, \"answer is '%s'\", compress(ja).c_str());\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> events(n);\n    if (type == \"random\") {\n        // Randomly decide 'sell x' events\n        int max_sell = min(n, 2001);\n        int sell_count = rnd.next(0, max_sell);\n\n        vector<int> sell_x;\n        for (int x = 0; x <= 2000; ++x) {\n            sell_x.push_back(x);\n        }\n        shuffle(sell_x.begin(), sell_x.end());\n\n        vector<int> positions(n);\n        for (int i = 0; i < n; ++i) positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n\n        // Set 'sell x' events\n        for (int i = 0; i < sell_count; ++i) {\n            int idx = positions[i];\n            int x = sell_x[i];\n            events[idx] = \"sell \" + to_string(x);\n        }\n\n        // Fill remaining positions with 'win x'\n        for (int i = sell_count; i < n; ++i) {\n            int idx = positions[i];\n            int x = rnd.next(0, 2000);\n            events[idx] = \"win \" + to_string(x);\n        }\n\n    } else if (type == \"max_earnings\") {\n        // We will generate events to maximize Bob's earnings\n\n        int k = n / 2; // Number of 'sell x' events\n        vector<int> x_values;\n        for (int x = 2000; x >= 0; --x) {\n            x_values.push_back(x);\n            if (x_values.size() >= k) break;\n        }\n        int idx = 0;\n        for (int i = 0; i < k; ++i) {\n            events[idx++] = \"win \" + to_string(x_values[i]);\n            events[idx++] = \"sell \" + to_string(x_values[i]);\n        }\n        // If n is odd, fill the remaining event(s) with 'win x' of small x\n        while (idx < n) {\n            events[idx++] = \"win 0\";\n        }\n    } else if (type == \"min_earnings\") {\n        // Bob cannot make any earnings\n        int k = min(n / 2, 2001);\n        vector<int> sell_x;\n        for (int x = 0; x <= 2000; ++x) {\n            sell_x.push_back(x);\n            if (sell_x.size() >= k) break;\n        }\n\n        int idx = 0;\n        // 'sell x' events\n        for (int i = 0; i < k; ++i) {\n            events[idx++] = \"sell \" + to_string(sell_x[i]);\n        }\n        // Corresponding 'win x' events after 'sell x' events\n        for (int i = 0; i < k; ++i) {\n            events[idx++] = \"win \" + to_string(sell_x[i]);\n        }\n        // If n is more than 2*k, fill remaining events with 'win x'\n        while (idx < n) {\n            events[idx++] = \"win \" + to_string(rnd.next(0, 2000));\n        }\n    } else if (type == \"all_win\") {\n        // All events are 'win x'\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 2000);\n            events[i] = \"win \" + to_string(x);\n        }\n    } else if (type == \"all_sell\") {\n        // All 'sell x', up to max possible (2001)\n        int max_sell = min(n, 2001);\n        vector<int> sell_x;\n        for (int x = 0; x <= 2000; ++x) {\n            sell_x.push_back(x);\n            if (sell_x.size() >= max_sell) break;\n        }\n        for (int i = 0; i < max_sell; ++i) {\n            events[i] = \"sell \" + to_string(sell_x[i]);\n        }\n        // Fill remaining events with 'win x'\n        for (int i = max_sell; i < n; ++i) {\n            events[i] = \"win \" + to_string(rnd.next(0, 2000));\n        }\n    } else if (type == \"alternating\") {\n        // Alternate 'win x' and 'sell x' events\n        int max_x = 2000;\n        int x = rnd.next(0, max_x);\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                events[i] = \"win \" + to_string(x);\n            } else {\n                events[i] = \"sell \" + to_string(x);\n                x = (x + rnd.next(1, max_x)) % (max_x + 1);\n            }\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    cout << n << endl;\n    for (const auto& event : events) {\n        cout << event << endl;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> events(n);\n    if (type == \"random\") {\n        // Randomly decide 'sell x' events\n        int max_sell = min(n, 2001);\n        int sell_count = rnd.next(0, max_sell);\n\n        vector<int> sell_x;\n        for (int x = 0; x <= 2000; ++x) {\n            sell_x.push_back(x);\n        }\n        shuffle(sell_x.begin(), sell_x.end());\n\n        vector<int> positions(n);\n        for (int i = 0; i < n; ++i) positions[i] = i;\n        shuffle(positions.begin(), positions.end());\n\n        // Set 'sell x' events\n        for (int i = 0; i < sell_count; ++i) {\n            int idx = positions[i];\n            int x = sell_x[i];\n            events[idx] = \"sell \" + to_string(x);\n        }\n\n        // Fill remaining positions with 'win x'\n        for (int i = sell_count; i < n; ++i) {\n            int idx = positions[i];\n            int x = rnd.next(0, 2000);\n            events[idx] = \"win \" + to_string(x);\n        }\n\n    } else if (type == \"max_earnings\") {\n        // We will generate events to maximize Bob's earnings\n\n        int k = n / 2; // Number of 'sell x' events\n        vector<int> x_values;\n        for (int x = 2000; x >= 0; --x) {\n            x_values.push_back(x);\n            if (x_values.size() >= k) break;\n        }\n        int idx = 0;\n        for (int i = 0; i < k; ++i) {\n            events[idx++] = \"win \" + to_string(x_values[i]);\n            events[idx++] = \"sell \" + to_string(x_values[i]);\n        }\n        // If n is odd, fill the remaining event(s) with 'win x' of small x\n        while (idx < n) {\n            events[idx++] = \"win 0\";\n        }\n    } else if (type == \"min_earnings\") {\n        // Bob cannot make any earnings\n        int k = min(n / 2, 2001);\n        vector<int> sell_x;\n        for (int x = 0; x <= 2000; ++x) {\n            sell_x.push_back(x);\n            if (sell_x.size() >= k) break;\n        }\n\n        int idx = 0;\n        // 'sell x' events\n        for (int i = 0; i < k; ++i) {\n            events[idx++] = \"sell \" + to_string(sell_x[i]);\n        }\n        // Corresponding 'win x' events after 'sell x' events\n        for (int i = 0; i < k; ++i) {\n            events[idx++] = \"win \" + to_string(sell_x[i]);\n        }\n        // If n is more than 2*k, fill remaining events with 'win x'\n        while (idx < n) {\n            events[idx++] = \"win \" + to_string(rnd.next(0, 2000));\n        }\n    } else if (type == \"all_win\") {\n        // All events are 'win x'\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(0, 2000);\n            events[i] = \"win \" + to_string(x);\n        }\n    } else if (type == \"all_sell\") {\n        // All 'sell x', up to max possible (2001)\n        int max_sell = min(n, 2001);\n        vector<int> sell_x;\n        for (int x = 0; x <= 2000; ++x) {\n            sell_x.push_back(x);\n            if (sell_x.size() >= max_sell) break;\n        }\n        for (int i = 0; i < max_sell; ++i) {\n            events[i] = \"sell \" + to_string(sell_x[i]);\n        }\n        // Fill remaining events with 'win x'\n        for (int i = max_sell; i < n; ++i) {\n            events[i] = \"win \" + to_string(rnd.next(0, 2000));\n        }\n    } else if (type == \"alternating\") {\n        // Alternate 'win x' and 'sell x' events\n        int max_x = 2000;\n        int x = rnd.next(0, max_x);\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                events[i] = \"win \" + to_string(x);\n            } else {\n                events[i] = \"sell \" + to_string(x);\n                x = (x + rnd.next(1, max_x)) % (max_x + 1);\n            }\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    cout << n << endl;\n    for (const auto& event : events) {\n        cout << event << endl;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 5000 -type random\n\n./gen -n 1 -type min_earnings\n./gen -n 2 -type min_earnings\n./gen -n 10 -type min_earnings\n./gen -n 100 -type min_earnings\n./gen -n 5000 -type min_earnings\n\n./gen -n 1 -type max_earnings\n./gen -n 2 -type max_earnings\n./gen -n 10 -type max_earnings\n./gen -n 100 -type max_earnings\n./gen -n 5000 -type max_earnings\n\n./gen -n 5000 -type all_sell\n./gen -n 5000 -type all_win\n./gen -n 5000 -type alternating\n\n./gen -n 4999 -type random\n./gen -n 4999 -type min_earnings\n./gen -n 4999 -type max_earnings\n\n./gen -n 5000 -type random\n./gen -n 5000 -type random\n./gen -n 5000 -type random\n./gen -n 5000 -type random\n\n./gen -n 1000 -type alternating\n\n./gen -n 2001 -type all_sell\n\n./gen -n 2000 -type min_earnings\n\n./gen -n 3 -type min_earnings\n\n./gen -n 3 -type max_earnings\n\n./gen -n 2 -type all_win\n\n./gen -n 5000 -type all_win\n\n./gen -n 5000 -type all_sell\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:28.690685",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "18/E",
      "title": "E. Флаг 2",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест128 megabytes",
      "input_spec": "Входные данныеВ первой строке входных данных записаны 2 целых числа n и m (1 ≤ n, m ≤ 500) — число строк и столбцов во флаге Берляндии соответственно. Далее следует описание флага: в следующих n строках содержится по m символов. Каждый символ — буква от a до z, обозначает цвет соответствующей клетки.",
      "output_spec": "Выходные данныеВ первую строку выходных данных выведите наименьшее число перекрашиваний, требуемое для приведения флага в соответствие новому стандарту ISO. Следующие n строк должны содержать один из возможных вариантов нового флага Берляндии. Не забудьте, что предложенный вами вариант нового флага должен быть получен из старого наименьшим числом перекрашиваний клеток. Если решений несколько выведите любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 4aaaabbbbccccВыходные данныеСкопировать6ababbabaacacВходные данныеСкопировать3 3abaabazzzВыходные данныеСкопировать4abababzbz",
      "description": "ограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест128 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных записаны 2 целых числа n и m (1 ≤ n, m ≤ 500) — число строк и столбцов во флаге Берляндии соответственно. Далее следует описание флага: в следующих n строках содержится по m символов. Каждый символ — буква от a до z, обозначает цвет соответствующей клетки.\n\nВходные данные\n\nВыходные данныеВ первую строку выходных данных выведите наименьшее число перекрашиваний, требуемое для приведения флага в соответствие новому стандарту ISO. Следующие n строк должны содержать один из возможных вариантов нового флага Берляндии. Не забудьте, что предложенный вами вариант нового флага должен быть получен из старого наименьшим числом перекрашиваний клеток. Если решений несколько выведите любое.\n\nВыходные данные\n\nВходные данныеСкопировать3 4aaaabbbbccccВыходные данныеСкопировать6ababbabaacacВходные данныеСкопировать3 3abaabazzzВыходные данныеСкопировать4abababzbz\n\nВходные данныеСкопировать3 4aaaabbbbcccc\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6ababbabaacac\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 3abaabazzz\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4abababzbz\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #18 (Див. 2) - Codeforces",
          "content": "Добро пожаловать на Codeforces Beta Round #18 Авторы задач сегодняшнего контеста: Михаил Мирзаянов, Эдвард Давтян и я. Спасибо Дмитрию Матову за помощь в подготовке условий и Юлии Сатушиной за перевод задач на английский язык. Всем удачи!ЗадачиРезультатыПобедитель: I_am_Feeling_Lucky",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/462",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 18"
          },
          "content_length": 284
        },
        {
          "title": "Разбор задач Codeforces Beta Round #18 - Codeforces",
          "content": "Обсуждение контестаЗадача А. ТреугольникиТематика: Теорема Пифагора, переборВ данной задаче нужно было написать функцию, проверяющую, что три точки образуют прямоугольный треугольник. Сделать это можно было множеством способов, один из самых простых - теорема Пифагора Чтобы избежать проблем с погрешностью, можно было не извлекать корень, а использовать квадрат расстояния.Чтобы проверить треугольник на почти прямоугольность, нужно было поочередно подвигать каждую точку во все 4 направления и проверить получившийся треугольник в нашей функции. Для быстрого перебора смещения, можно использовать два массива dx={-1,0,1,0} и dy={0,1,0,-1}. Тогда следующий код давал бы нам координаты смещенной точки:for (int i = 0; i < 4; i ++){int x = dx[i] + px;int y = dy[i] + py;}Задача B. ПлатформыТематика: СимуляцияРисунок к задаче:В данной задачи нужно было определить координату падения кузнечика. Для этого просто будем хранить положение кузнечика в данный момент. Для того, чтобы программа не работала слишком долго, нужно \"продвигать кузнечика\" по платформе за О(1) (не в цикле). Кузнечик сделает j = (righti-x)/d прыжков по i-ой, платформе, где x - координата кузнечика (он уже стоит на платформе) а righti - правая координата платформы. Поэтому кузнечка сразу можно передвинуть на j*d право.Задача C. ПолоскаТематика: ПереборДля решения данной задачи нужно было хранить две суммы S1 - сумма чисел слева от разреза (изначально равна 0) и S2 - сумма чисел справа от разреза (изначально равна сумме всех чисел на полоске). В цикле двигаем место разреза слева направо, изменяя значения сумм, и, при необходимости, увеличиваем ответЗадача D. Продавец ВасяТематика: Жадный алгоритм, длинная арифметикаВ задаче D потребуется длинная арифметика (сложение), так как число 22000 не вместится в int64.Нам дано условие того, что продавец для каждого размера флешки встретится не более одного раза. Так как 2x > 2x-1 + 2x-2 + ... 20, то прибыль от флешки с самым большим объемом будет больше чем если бы мы продали все остальные флешки. Поэтому в первую очередь нужно попытаться продать самую большую флешку, потом флешку поменьше и т.д. Таким образом, нужно пытаться продать флешки по убыванию их стоимостиЗадача E. Флаг 2Тематика: Динамическое программированиеВ задаче про флаг необходимо воспользоваться методом динамического программирования. Мы будем считать функцию DP(level, A, B) (где A и B - номера цветов, от 0 до 25), которая возвращает минимальное число перекрасок, нужное чтобы перекрасить первые level полосок, причем последняя полоска будет иметь вид ABABAB...Для пересчета данной функции сначала посчитаем, сколько перекрасок нужно, чтобы привести полоску с номером level к виду ABABAB... (пусть это будет число D). Заметим, что полоску можно покрасить таким образом, если первый цвет предыдущей полоски не был \"A\", а второй цвет не был \"B\" (условие того, что смежные клетки не должны быть одного цвета) или же это должна быть первая полоска. Поэтому DP(level, A, B) = min(DP(level-1, i, j)) + D , i = 0..25, j = 0..25, i != j, i != B, j != A.Оценим время работы программы: O(N*26*26*(M+26*26)), эта константа не превышает 4*108Спасибо за внимание! Решения не претендуют на оптимальность",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/463",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3190
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #18 (Див. 2) - Codeforces - Code 1",
          "code": "10\nsell 179\nwin 1278\nsell 1278\nwin 179\nwin 788\nsell 788\nwin 1819\nwin 1278\nsell 1454\nsell 1819",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/462",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Beta Round #18 - Codeforces - Code 1",
          "code": "5win 10win 5sell 5win 1sell 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/463",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readEoln();\n\n    string pattern = format(\"[a-z]{%d}\", m);\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern, format(\"line %d\", i+1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readEoln();\n\n    string pattern = format(\"[a-z]{%d}\", m);\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern, format(\"line %d\", i+1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readEoln();\n\n    string pattern = format(\"[a-z]{%d}\", m);\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(pattern, format(\"line %d\", i+1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\nint n, m;\nvector<string> old_flag;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read n and m from input file\n    n = inf.readInt(); \n    m = inf.readInt();\n\n    // Read original flag from the input file\n    old_flag.resize(n);\n    for (int i = 0; i < n; i++) {\n        old_flag[i] = inf.readToken();\n        if ((int)old_flag[i].size() != m) {\n            quitf(_fail, \"Invalid input flag at line %d\", i+1);\n        }\n    }\n\n    // Read minimal number of repaintings from the answer file\n    int mins = ans.readInt(0, n * m, \"minimum repaintings\");\n\n    // Read participant's number of repaintings from output file\n    int pans = ouf.readInt(0, n * m, \"participant's repaintings\");\n\n    // Read participant's new flag configuration\n    vector<string> new_flag(n);\n    for (int i = 0; i < n; i++) {\n        new_flag[i] = ouf.readToken();\n        if ((int)new_flag[i].size() != m) {\n            quitf(_wa, \"Row %d has incorrect length\", i+1);\n        }\n        for (int j = 0; j < m; j++) {\n            if (new_flag[i][j] < 'a' || new_flag[i][j] > 'z') {\n                quitf(_wa, \"Invalid character '%c' in row %d, column %d\", new_flag[i][j], i+1, j+1);\n            }\n        }\n    }\n\n    // Count the number of squares that are different from the original flag\n    int diffs = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (new_flag[i][j] != old_flag[i][j]) {\n                diffs++;\n            }\n        }\n    }\n\n    // Check if the reported number of repaintings matches the actual number\n    if (diffs != pans) {\n        quitf(_wa, \"Number of repaintings does not match claimed number: claimed %d, actual %d\", pans, diffs);\n    }\n\n    // Check that the new flag meets the constraints\n    for (int i = 0; i < n; i++) {\n        // Each row should use at most two different colours\n        set<char> colors_in_row(new_flag[i].begin(), new_flag[i].end());\n        if (colors_in_row.size() > 2) {\n            quitf(_wa, \"Row %d has more than 2 different colours\", i+1);\n        }\n        // No two adjacent squares can be painted the same colour\n        for (int j = 1; j < m; j++) {\n            if (new_flag[i][j] == new_flag[i][j-1]) {\n                quitf(_wa, \"Adjacent squares in row %d, columns %d and %d have the same colour '%c'\", i+1, j, j+1, new_flag[i][j]);\n            }\n        }\n    }\n\n    // Compare participant's repainting count with the minimal count\n    if (pans == mins) {\n        quitf(_ok, \"Correct solution with %d repaintings\", mins);\n    } else if (pans > mins) {\n        // Participant's solution is not optimal\n        quitf(_wa, \"Jury has better answer: minimal repaintings = %d, participant's repaintings = %d\", mins, pans);\n    } else {\n        // Participant found a better solution than the jury\n        quitf(_fail, \"Participant has better solution than jury: minimal repaintings = %d, participant's repaintings = %d\", mins, pans);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, 'a'));\n\n    if (type == \"random\") {\n        // Random letters in the grid\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = 'a' + rnd.next(26);\n    } else if (type == \"already_good\") {\n        // Generate a grid that already satisfies the conditions\n        for (int i = 0; i < n; ++i) {\n            char c1 = 'a' + rnd.next(26);\n            char c2 = 'a' + rnd.next(26);\n            if (c2 == c1) c2 = (c2 - 'a' + 1) % 26 + 'a';\n            for (int j = 0; j < m; ++j) {\n                if (j % 2 == 0)\n                    grid[i][j] = c1;\n                else\n                    grid[i][j] = c2;\n            }\n        }\n    } else if (type == \"single_color_rows\") {\n        // Each row is a single color\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = c;\n        }\n    } else if (type == \"worse_case\") {\n        // Generate grid that maximizes the number of changes needed\n        // Let's make adjacent squares in the same row have the same color\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = c;\n        }\n    } else if (type == \"checkerboard\") {\n        // Create a checkerboard pattern with two colors\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        if (c2 == c1) c2 = (c2 - 'a' + 1) % 26 + 'a';\n        for (int i = 0; i < n; ++i) {\n            char row_c1 = c1;\n            char row_c2 = c2;\n            if (i % 2 == 1)\n                swap(row_c1, row_c2);\n            for (int j = 0; j < m; ++j) {\n                if (j % 2 == 0)\n                    grid[i][j] = row_c1;\n                else\n                    grid[i][j] = row_c2;\n            }\n        }\n    } else if (type == \"one_row\") {\n        // n == 1\n        n = 1;\n        grid.resize(1);\n        grid[0].resize(m);\n        for (int i = 0; i < m; ++i) {\n            grid[0][i] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"one_column\") {\n        // m == 1\n        m = 1;\n        for (int i = 0; i < n; ++i) {\n            grid[i].resize(1);\n            grid[i][0] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"max_change_checkerboard\") {\n        // Create a grid where fixing to checkerboard results in maximum changes\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = c;\n        }\n    } else if (type == \"max_size\") {\n        // n and m = 500\n        n = 500;\n        m = 500;\n        grid.resize(n, string(m, 'a'));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = 'a' + rnd.next(26);\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = 'a' + rnd.next(26);\n    }\n\n    // Output n m\n    printf(\"%d %d\\n\", n, m);\n    // Output grid\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, 'a'));\n\n    if (type == \"random\") {\n        // Random letters in the grid\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = 'a' + rnd.next(26);\n    } else if (type == \"already_good\") {\n        // Generate a grid that already satisfies the conditions\n        for (int i = 0; i < n; ++i) {\n            char c1 = 'a' + rnd.next(26);\n            char c2 = 'a' + rnd.next(26);\n            if (c2 == c1) c2 = (c2 - 'a' + 1) % 26 + 'a';\n            for (int j = 0; j < m; ++j) {\n                if (j % 2 == 0)\n                    grid[i][j] = c1;\n                else\n                    grid[i][j] = c2;\n            }\n        }\n    } else if (type == \"single_color_rows\") {\n        // Each row is a single color\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = c;\n        }\n    } else if (type == \"worse_case\") {\n        // Generate grid that maximizes the number of changes needed\n        // Let's make adjacent squares in the same row have the same color\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = c;\n        }\n    } else if (type == \"checkerboard\") {\n        // Create a checkerboard pattern with two colors\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        if (c2 == c1) c2 = (c2 - 'a' + 1) % 26 + 'a';\n        for (int i = 0; i < n; ++i) {\n            char row_c1 = c1;\n            char row_c2 = c2;\n            if (i % 2 == 1)\n                swap(row_c1, row_c2);\n            for (int j = 0; j < m; ++j) {\n                if (j % 2 == 0)\n                    grid[i][j] = row_c1;\n                else\n                    grid[i][j] = row_c2;\n            }\n        }\n    } else if (type == \"one_row\") {\n        // n == 1\n        n = 1;\n        grid.resize(1);\n        grid[0].resize(m);\n        for (int i = 0; i < m; ++i) {\n            grid[0][i] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"one_column\") {\n        // m == 1\n        m = 1;\n        for (int i = 0; i < n; ++i) {\n            grid[i].resize(1);\n            grid[i][0] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"max_change_checkerboard\") {\n        // Create a grid where fixing to checkerboard results in maximum changes\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = c;\n        }\n    } else if (type == \"max_size\") {\n        // n and m = 500\n        n = 500;\n        m = 500;\n        grid.resize(n, string(m, 'a'));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = 'a' + rnd.next(26);\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = 'a' + rnd.next(26);\n    }\n\n    // Output n m\n    printf(\"%d %d\\n\", n, m);\n    // Output grid\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type one_row\n\n./gen -n 1 -m 500 -type random\n./gen -n 1 -m 500 -type one_row\n\n./gen -n 500 -m 1 -type random\n./gen -n 500 -m 1 -type one_column\n\n./gen -n 2 -m 2 -type random\n./gen -n 2 -m 2 -type checkerboard\n\n./gen -n 2 -m 2 -type worse_case\n\n./gen -n 10 -m 10 -type already_good\n./gen -n 10 -m 10 -type worse_case\n./gen -n 10 -m 10 -type random\n\n./gen -n 100 -m 100 -type checkerboard\n\n./gen -n 100 -m 100 -type single_color_rows\n\n./gen -n 500 -m 500 -type random\n\n./gen -n 500 -m 500 -type already_good\n\n./gen -n 500 -m 500 -type checkerboard\n\n./gen -n 500 -m 500 -type worse_case\n\n./gen -n 499 -m 499 -type random\n\n./gen -n 499 -m 499 -type single_color_rows\n\n./gen -n 499 -m 499 -type one_row\n\n./gen -n 499 -m 499 -type one_column\n\n./gen -n 500 -m 500 -type max_change_checkerboard\n\n./gen -n 3 -m 5 -type random\n\n./gen -n 5 -m 3 -type random\n\n./gen -n 500 -m 500 -type max_size\n\n./gen -n 1 -m 500 -type one_row\n\n./gen -n 500 -m 1 -type one_column\n\n./gen -n 2 -m 500 -type random\n./gen -n 500 -m 2 -type random\n\n./gen -n 400 -m 400 -type random\n\n./gen -n 500 -m 500 -type single_color_rows\n\n./gen -n 10 -m 10 -type random\n\n./gen -n 10 -m 10 -type max_change_checkerboard\n\n./gen -n 500 -m 500 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:30.447336",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "180/A",
      "title": "A. Дефрагментация",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержатся два целых числа n и m (1 ≤ n, m ≤ 200) — количество кластеров и количество файлов, соответственно. Следующие m строк содержат описания файлов. Первое число в строке — ni (ni ≥ 1), количество кластеров, которые занимает i-й файл. Далее следуют ni чисел ai, 1, ai, 2, ..., ai, ni (1 ≤ ai, j ≤ n). Гарантируется, что каждый номер кластера встречается не более одного раза и , т.е. существует хотя бы один неиспользуемый кластер. Числа в каждой строке разделены пробелами.",
      "output_spec": "Выходные данныеВ первой строке выведите одно целое число k (0 ≤ k ≤ 2n) — количество операций, требующихся для дефрагментации диска. Следующие k строк должны содержать описания операций в формате «i j» (скопировать содержимое кластера с номером i в кластер с номером j).",
      "sample_tests": "ПримерыВходные данныеСкопировать7 22 1 23 3 4 5Выходные данныеСкопировать0Входные данныеСкопировать7 22 1 33 2 4 5Выходные данныеСкопировать32 63 26 3",
      "description": "A. Дефрагментация\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержатся два целых числа n и m (1 ≤ n, m ≤ 200) — количество кластеров и количество файлов, соответственно. Следующие m строк содержат описания файлов. Первое число в строке — ni (ni ≥ 1), количество кластеров, которые занимает i-й файл. Далее следуют ni чисел ai, 1, ai, 2, ..., ai, ni (1 ≤ ai, j ≤ n). Гарантируется, что каждый номер кластера встречается не более одного раза и , т.е. существует хотя бы один неиспользуемый кластер. Числа в каждой строке разделены пробелами.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите одно целое число k (0 ≤ k ≤ 2n) — количество операций, требующихся для дефрагментации диска. Следующие k строк должны содержать описания операций в формате «i j» (скопировать содержимое кластера с номером i в кластер с номером j).\n\nВыходные данные\n\nВходные данныеСкопировать7 22 1 23 3 4 5Выходные данныеСкопировать0Входные данныеСкопировать7 22 1 33 2 4 5Выходные данныеСкопировать32 63 26 3\n\nВходные данныеСкопировать7 22 1 23 3 4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 22 1 33 2 4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать32 63 26 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПусть диск состоит из 8 кластеров и на нем расположены два файла. Первый файл занимает два кластера, второй — три кластера. Рассмотрим примеры корректного и некорректного расположения файлов после дефрагментации.Пример 2: каждый файл должен занимать непрерывную область памяти.Пример 3: порядок файлов между собой не важен, сначала может быть записан второй файл, потом — первый.Пример 4: нарушать порядок фрагментов файла между собой не разрешается.Пример 5: неиспользуемые кластеры должны располагаться в конце, а в данном примере неиспользуемые кластеры — 3, 7, 8.",
      "solutions": [
        {
          "title": "Codeforces Round #116 - Codeforces",
          "content": "Всем привет!Сегодня вас ждет раунд по старым-добрым ACM-ICPC правилам. Да, это будет рейтинговый контест для второго дивизиона, а участники из первого дивизиона смогут принять участие вне конкурса.Задачи для вас делали Nerevar, natalia, MikeMirzayanov и Edvard, а Delinur перевела задачи. Спасибо всем за помощь!Желаю удачи!UPD: Рейтинг будет обновлен позже.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4390",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 358
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #116 - Codeforces - Code 1",
          "code": "for(int i=1;i<100001;i++)\n  {\n    if(v[i].size()==0)continue;\n    int back=0;\n    int front=0;\n    int sum=0;\n    bool frontmoved=true;\n    bool backmoved=false;\n    while(front!=v[i].size())\n    {\n      if(frontmoved)\n\tsum+=v[i][front];\n      if(backmoved)\n\tsum-=v[i][back-1];\n      if(sum<=k)\n      {\n\tif(max<front-back+2)max=front-back+2;\n\tfront++;\n\tfrontmoved=true;\n\tbackmoved=false;\n      }\n      else\n      {back++;backmoved=true;frontmoved=false;}\n      if(front<back)\n      {front++;frontmoved=true;}\n    }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #116 - Codeforces - Code 2",
          "code": "for(int i=1;i<100001;i++)\n  {\n    if(v[i].size()==0)continue;\n    int back=0;\n    int front=0;\n    int sum=0;\n    bool frontmoved=true;\n    bool backmoved=false;\n    while(front!=v[i].size())\n    {\n      if(frontmoved)\n\tsum+=v[i][front];\n      if(backmoved)\n\tsum-=v[i][back-1];\n      if(sum<=k)\n      {\n\tif(max<front-back+2)max=front-back+2;\n\tfront++;\n\tfrontmoved=true;\n\tbackmoved=false;\n      }\n      else\n      {back++;backmoved=true;frontmoved=false;}\n      if(front<back)\n      {front++;frontmoved=true;}\n    }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4390",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200, \"m\");\n    inf.readEoln();\n\n    unordered_set<int> used_clusters;\n\n    for (int i = 0; i < m; ++i) {\n        // Read ni\n        int ni = inf.readInt(1, n, \"ni\");\n\n        // Read ai_j\n        for (int j = 0; j < ni; ++j) {\n            inf.readSpace();\n            int aij = inf.readInt(1, n, \"ai_j\");\n\n            if (used_clusters.count(aij))\n                ensuref(false, \"Cluster number %d is used more than once\", aij);\n\n            used_clusters.insert(aij);\n        }\n\n        inf.readEoln();\n    }\n\n    // Ensure that there is at least one unused cluster\n    if (int(used_clusters.size()) >= n)\n        ensuref(false, \"All clusters are used, there must be at least one unused cluster\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200, \"m\");\n    inf.readEoln();\n\n    unordered_set<int> used_clusters;\n\n    for (int i = 0; i < m; ++i) {\n        // Read ni\n        int ni = inf.readInt(1, n, \"ni\");\n\n        // Read ai_j\n        for (int j = 0; j < ni; ++j) {\n            inf.readSpace();\n            int aij = inf.readInt(1, n, \"ai_j\");\n\n            if (used_clusters.count(aij))\n                ensuref(false, \"Cluster number %d is used more than once\", aij);\n\n            used_clusters.insert(aij);\n        }\n\n        inf.readEoln();\n    }\n\n    // Ensure that there is at least one unused cluster\n    if (int(used_clusters.size()) >= n)\n        ensuref(false, \"All clusters are used, there must be at least one unused cluster\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200, \"m\");\n    inf.readEoln();\n\n    unordered_set<int> used_clusters;\n\n    for (int i = 0; i < m; ++i) {\n        // Read ni\n        int ni = inf.readInt(1, n, \"ni\");\n\n        // Read ai_j\n        for (int j = 0; j < ni; ++j) {\n            inf.readSpace();\n            int aij = inf.readInt(1, n, \"ai_j\");\n\n            if (used_clusters.count(aij))\n                ensuref(false, \"Cluster number %d is used more than once\", aij);\n\n            used_clusters.insert(aij);\n        }\n\n        inf.readEoln();\n    }\n\n    // Ensure that there is at least one unused cluster\n    if (int(used_clusters.size()) >= n)\n        ensuref(false, \"All clusters are used, there must be at least one unused cluster\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Each cluster can store content of form (fileID, indexInFile),\n// or (0,0) if it is truly free initially.\nstruct ClusterContent {\n    int fileID, indexInFile;\n};\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(); // number of clusters\n    int m = inf.readInt(); // number of files\n\n    // fileSize[i] = number of clusters for file i (1-based indexing).\n    vector<int> fileSize(m + 1);\n\n    // content[c] = current (fileID, indexInFile) at cluster c (1-based).\n    // By default, all clusters are free (0,0).\n    vector<ClusterContent> content(n + 1, {0, 0});\n\n    // Read the initial layout from the input:\n    for (int i = 1; i <= m; i++) {\n        int len = inf.readInt(1, n, \"fileSize\");\n        fileSize[i] = len;\n        for (int j = 1; j <= len; j++) {\n            int clusterPos = inf.readInt(1, n, \"clusterPos\");\n            content[clusterPos] = {i, j};\n        }\n    }\n\n    // The contestant output:\n    // 1) The number of copy operations K (0 <= K <= 2*n).\n    // 2) Then K lines: \"i j\" meaning \"copy from cluster i to cluster j\".\n    int K = ouf.readInt(0, 2 * n, \"K\");\n\n    for (int step = 1; step <= K; step++) {\n        int i = ouf.readInt(1, n, \"copy_from\");\n        int j = ouf.readInt(1, n, \"copy_to\");\n        if (i == j) {\n            quitf(_wa, \"Operation #%d: cannot copy from and to the same cluster\", step);\n        }\n        // Apply the copy:\n        content[j] = content[i];\n    }\n\n    // Check final arrangement:\n    // Files must occupy the first some clusters, contiguously and in correct fragment order,\n    // from fragment #1 through #fileSize[i]. The order of files is arbitrary,\n    // but each file must appear exactly once, and leftover clusters are \"unused\"\n    // regardless of their physical contents.\n    \n    vector<bool> usedFile(m + 1, false);\n    int filesPlaced = 0;\n    int c = 1; // pointer to current cluster\n\n    // Place all m files:\n    while (filesPlaced < m) {\n        // If no more clusters yet not all files are placed => invalid\n        if (c > n) {\n            quitf(_wa, \"Not enough clusters to place all files contiguously at the start\");\n        }\n        // The next cluster must belong to some file. If it is free, that means there's a gap earlier.\n        if (content[c].fileID == 0) {\n            quitf(_wa, \"Cluster %d is free while not all files are placed\", c);\n        }\n\n        // Let this cluster start file f with fragment idx=1\n        int f = content[c].fileID;\n        int idx = content[c].indexInFile;\n        if (idx != 1) {\n            quitf(_wa, \"File %d must start with fragment #1, but found fragment #%d at cluster %d\",\n                  f, idx, c);\n        }\n        if (usedFile[f]) {\n            quitf(_wa, \"File %d appears more than once in the final layout\", f);\n        }\n\n        // Check that this file occupies fileSize[f] consecutive clusters\n        // with indices 1..fileSize[f].\n        for (int offset = 0; offset < fileSize[f]; offset++) {\n            int pos = c + offset;\n            if (pos > n) {\n                quitf(_wa, \"Not enough clusters to place file %d entirely\", f);\n            }\n            if (content[pos].fileID != f || content[pos].indexInFile != offset + 1) {\n                quitf(_wa,\n                      \"File %d's cluster at position %d has (fileID=%d, index=%d), expected (fileID=%d, index=%d)\",\n                      f, pos,\n                      content[pos].fileID, content[pos].indexInFile,\n                      f, offset + 1);\n            }\n        }\n\n        // Mark file f as placed\n        usedFile[f] = true;\n        filesPlaced++;\n\n        // Advance 'c' beyond this file\n        c += fileSize[f];\n    }\n\n    // The leftover clusters (c..n) are beyond all files. The problem statement allows\n    // them to contain anything physically. We do not require them to be (0,0).\n    // So no further check is needed.\n\n    quitf(_ok, \"All files defragmented correctly\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Make sure n and m are within constraints\n    ensure(n >= 1 && n <= 200);\n    ensure(m >= 1 && m <= 200);\n    ensure(m <= n - 1); // We need at least one unused cluster\n\n    vector<int> clusters(n);\n    for (int i = 0; i < n; ++i) clusters[i] = i + 1;\n\n    int total_clusters_used;\n    vector<int> sizes(m); // Sizes of files\n    vector<vector<int>> files(m); // Clusters assigned to files\n\n    if (type == \"random\") {\n        // Shuffle cluster indices\n        shuffle(clusters.begin(), clusters.end());\n\n        // Decide total clusters used\n        total_clusters_used = rnd.next(m, n - 1); // At least m clusters, at most n - 1\n\n        // Initialize file sizes to 1\n        sizes.assign(m, 1);\n        int remaining = total_clusters_used - m;\n\n        // Distribute remaining clusters randomly\n        for (int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, m - 1);\n            sizes[idx]++;\n        }\n\n        // Assign clusters to files\n        int idx = 0;\n        for (int i = 0; i < m; ++i) {\n            int ni = sizes[i];\n            files[i].resize(ni);\n            for (int j = 0; j < ni; ++j) {\n                files[i][j] = clusters[idx++];\n            }\n            // The clusters within a file correspond to fragments in order\n        }\n\n    } else if (type == \"max_clusters\") {\n        // Use as many clusters as possible\n        total_clusters_used = n - 1;\n\n        // Distribute clusters among files\n        sizes.assign(m, 1);\n        int remaining = total_clusters_used - m;\n        for (int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, m - 1);\n            sizes[idx]++;\n        }\n\n        // Shuffle clusters\n        shuffle(clusters.begin(), clusters.end());\n\n        // Assign clusters to files\n        int idx = 0;\n        for (int i = 0; i < m; ++i) {\n            int ni = sizes[i];\n            files[i].resize(ni);\n            for (int j = 0; j < ni; ++j) {\n                files[i][j] = clusters[idx++];\n            }\n        }\n\n    } else if (type == \"min_clusters\") {\n        // Each file has exactly one cluster\n        total_clusters_used = m;\n        sizes.assign(m, 1);\n\n        // Shuffle clusters\n        shuffle(clusters.begin(), clusters.end());\n\n        // Assign clusters to files\n        int idx = 0;\n        for (int i = 0; i < m; ++i) {\n            files[i].push_back(clusters[idx++]);\n        }\n\n    } else if (type == \"single_file\") {\n        // Only one file occupies almost all clusters\n        m = 1;\n        total_clusters_used = n - 1;\n        sizes.assign(1, total_clusters_used);\n\n        // Shuffle clusters\n        shuffle(clusters.begin(), clusters.end());\n\n        // Assign clusters to the single file\n        files.resize(1);\n        files[0].resize(total_clusters_used);\n        for (int i = 0; i < total_clusters_used; ++i) {\n            files[0][i] = clusters[i];\n        }\n\n    } else if (type == \"many_small_files\") {\n        // Many files each occupying a small number of clusters\n        m = min(n - 1, m);\n        total_clusters_used = n - 1;\n        sizes.assign(m, 1);\n        int remaining = total_clusters_used - m;\n        for (int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, m - 1);\n            if (sizes[idx] < 5) // Limit size of each file\n                sizes[idx]++;\n        }\n\n        // Shuffle clusters\n        shuffle(clusters.begin(), clusters.end());\n\n        // Assign clusters to files\n        int idx = 0;\n        files.resize(m);\n        for (int i = 0; i < m; ++i) {\n            int ni = sizes[i];\n            files[i].resize(ni);\n            for (int j = 0; j < ni; ++j) {\n                files[i][j] = clusters[idx++];\n            }\n        }\n\n    } else if (type == \"reverse_order\") {\n        // Clusters assigned to files are in reverse order\n        total_clusters_used = rnd.next(m, n - 1);\n        sizes.assign(m, 1);\n        int remaining = total_clusters_used - m;\n        for (int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, m - 1);\n            sizes[idx]++;\n        }\n\n        // Reverse the clusters\n        reverse(clusters.begin(), clusters.end());\n\n        // Assign clusters to files\n        int idx = 0;\n        files.resize(m);\n        for (int i = 0; i < m; ++i) {\n            int ni = sizes[i];\n            files[i].resize(ni);\n            for (int j = 0; j < ni; ++j) {\n                files[i][j] = clusters[idx++];\n            }\n        }\n\n    } else if (type == \"non_contiguous\") {\n        // Clusters assigned to each file are scattered\n        total_clusters_used = rnd.next(m, n - 1);\n        sizes.assign(m, 1);\n        int remaining = total_clusters_used - m;\n        for (int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, m - 1);\n            sizes[idx]++;\n        }\n\n        // Shuffle clusters\n        shuffle(clusters.begin(), clusters.end());\n\n        // Assign non-consecutive clusters to files\n        int idx = 0;\n        files.resize(m);\n        for (int j = 0; j < (int)sizes[0]; ++j) {\n            for (int i = 0; i < m; ++i) {\n                if (j < sizes[i]) {\n                    files[i].push_back(clusters[idx++]);\n                }\n            }\n        }\n\n    } else if (type == \"consecutive_files\") {\n        // Files are already in perfect order\n        total_clusters_used = rnd.next(m, n - 1);\n        sizes.assign(m, 1);\n        int remaining = total_clusters_used - m;\n        for (int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, m - 1);\n            sizes[idx]++;\n        }\n\n        // Assign clusters in order\n        int idx = 0;\n        files.resize(m);\n        for (int i = 0; i < m; ++i) {\n            int ni = sizes[i];\n            files[i].resize(ni);\n            for (int j = 0; j < ni; ++j) {\n                files[i][j] = clusters[idx++];\n            }\n        }\n\n    } else if (type == \"worst_case\") {\n        // Construct a worst-case scenario for contestants\n        total_clusters_used = n - 1;\n        sizes.assign(m, total_clusters_used / m);\n        int remainder = total_clusters_used % m;\n        for (int i = 0; i < remainder; ++i) {\n            sizes[i]++;\n        }\n\n        // Interleave clusters among files\n        vector<int> idx(m, 0);\n        int total = 0;\n        files.resize(m);\n        for (int i = 0; total < total_clusters_used; ++i) {\n            for (int j = 0; j < m && total < total_clusters_used; ++j) {\n                if (idx[j] < sizes[j]) {\n                    files[j].push_back(clusters[total++]);\n                    idx[j]++;\n                }\n            }\n        }\n\n    } else {\n        // Default to random type\n        // (Same as 'random' case)\n        // Shuffle cluster indices\n        shuffle(clusters.begin(), clusters.end());\n\n        // Decide total clusters used\n        total_clusters_used = rnd.next(m, n - 1);\n\n        // Initialize file sizes to 1\n        sizes.assign(m, 1);\n        int remaining = total_clusters_used - m;\n\n        // Distribute remaining clusters randomly\n        for (int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, m - 1);\n            sizes[idx]++;\n        }\n\n        // Assign clusters to files\n        int idx = 0;\n        for (int i = 0; i < m; ++i) {\n            int ni = sizes[i];\n            files[i].resize(ni);\n            for (int j = 0; j < ni; ++j) {\n                files[i][j] = clusters[idx++];\n            }\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        int ni = files[i].size();\n        printf(\"%d\", ni);\n        for (int j = 0; j < ni; ++j) {\n            printf(\" %d\", files[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Make sure n and m are within constraints\n    ensure(n >= 1 && n <= 200);\n    ensure(m >= 1 && m <= 200);\n    ensure(m <= n - 1); // We need at least one unused cluster\n\n    vector<int> clusters(n);\n    for (int i = 0; i < n; ++i) clusters[i] = i + 1;\n\n    int total_clusters_used;\n    vector<int> sizes(m); // Sizes of files\n    vector<vector<int>> files(m); // Clusters assigned to files\n\n    if (type == \"random\") {\n        // Shuffle cluster indices\n        shuffle(clusters.begin(), clusters.end());\n\n        // Decide total clusters used\n        total_clusters_used = rnd.next(m, n - 1); // At least m clusters, at most n - 1\n\n        // Initialize file sizes to 1\n        sizes.assign(m, 1);\n        int remaining = total_clusters_used - m;\n\n        // Distribute remaining clusters randomly\n        for (int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, m - 1);\n            sizes[idx]++;\n        }\n\n        // Assign clusters to files\n        int idx = 0;\n        for (int i = 0; i < m; ++i) {\n            int ni = sizes[i];\n            files[i].resize(ni);\n            for (int j = 0; j < ni; ++j) {\n                files[i][j] = clusters[idx++];\n            }\n            // The clusters within a file correspond to fragments in order\n        }\n\n    } else if (type == \"max_clusters\") {\n        // Use as many clusters as possible\n        total_clusters_used = n - 1;\n\n        // Distribute clusters among files\n        sizes.assign(m, 1);\n        int remaining = total_clusters_used - m;\n        for (int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, m - 1);\n            sizes[idx]++;\n        }\n\n        // Shuffle clusters\n        shuffle(clusters.begin(), clusters.end());\n\n        // Assign clusters to files\n        int idx = 0;\n        for (int i = 0; i < m; ++i) {\n            int ni = sizes[i];\n            files[i].resize(ni);\n            for (int j = 0; j < ni; ++j) {\n                files[i][j] = clusters[idx++];\n            }\n        }\n\n    } else if (type == \"min_clusters\") {\n        // Each file has exactly one cluster\n        total_clusters_used = m;\n        sizes.assign(m, 1);\n\n        // Shuffle clusters\n        shuffle(clusters.begin(), clusters.end());\n\n        // Assign clusters to files\n        int idx = 0;\n        for (int i = 0; i < m; ++i) {\n            files[i].push_back(clusters[idx++]);\n        }\n\n    } else if (type == \"single_file\") {\n        // Only one file occupies almost all clusters\n        m = 1;\n        total_clusters_used = n - 1;\n        sizes.assign(1, total_clusters_used);\n\n        // Shuffle clusters\n        shuffle(clusters.begin(), clusters.end());\n\n        // Assign clusters to the single file\n        files.resize(1);\n        files[0].resize(total_clusters_used);\n        for (int i = 0; i < total_clusters_used; ++i) {\n            files[0][i] = clusters[i];\n        }\n\n    } else if (type == \"many_small_files\") {\n        // Many files each occupying a small number of clusters\n        m = min(n - 1, m);\n        total_clusters_used = n - 1;\n        sizes.assign(m, 1);\n        int remaining = total_clusters_used - m;\n        for (int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, m - 1);\n            if (sizes[idx] < 5) // Limit size of each file\n                sizes[idx]++;\n        }\n\n        // Shuffle clusters\n        shuffle(clusters.begin(), clusters.end());\n\n        // Assign clusters to files\n        int idx = 0;\n        files.resize(m);\n        for (int i = 0; i < m; ++i) {\n            int ni = sizes[i];\n            files[i].resize(ni);\n            for (int j = 0; j < ni; ++j) {\n                files[i][j] = clusters[idx++];\n            }\n        }\n\n    } else if (type == \"reverse_order\") {\n        // Clusters assigned to files are in reverse order\n        total_clusters_used = rnd.next(m, n - 1);\n        sizes.assign(m, 1);\n        int remaining = total_clusters_used - m;\n        for (int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, m - 1);\n            sizes[idx]++;\n        }\n\n        // Reverse the clusters\n        reverse(clusters.begin(), clusters.end());\n\n        // Assign clusters to files\n        int idx = 0;\n        files.resize(m);\n        for (int i = 0; i < m; ++i) {\n            int ni = sizes[i];\n            files[i].resize(ni);\n            for (int j = 0; j < ni; ++j) {\n                files[i][j] = clusters[idx++];\n            }\n        }\n\n    } else if (type == \"non_contiguous\") {\n        // Clusters assigned to each file are scattered\n        total_clusters_used = rnd.next(m, n - 1);\n        sizes.assign(m, 1);\n        int remaining = total_clusters_used - m;\n        for (int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, m - 1);\n            sizes[idx]++;\n        }\n\n        // Shuffle clusters\n        shuffle(clusters.begin(), clusters.end());\n\n        // Assign non-consecutive clusters to files\n        int idx = 0;\n        files.resize(m);\n        for (int j = 0; j < (int)sizes[0]; ++j) {\n            for (int i = 0; i < m; ++i) {\n                if (j < sizes[i]) {\n                    files[i].push_back(clusters[idx++]);\n                }\n            }\n        }\n\n    } else if (type == \"consecutive_files\") {\n        // Files are already in perfect order\n        total_clusters_used = rnd.next(m, n - 1);\n        sizes.assign(m, 1);\n        int remaining = total_clusters_used - m;\n        for (int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, m - 1);\n            sizes[idx]++;\n        }\n\n        // Assign clusters in order\n        int idx = 0;\n        files.resize(m);\n        for (int i = 0; i < m; ++i) {\n            int ni = sizes[i];\n            files[i].resize(ni);\n            for (int j = 0; j < ni; ++j) {\n                files[i][j] = clusters[idx++];\n            }\n        }\n\n    } else if (type == \"worst_case\") {\n        // Construct a worst-case scenario for contestants\n        total_clusters_used = n - 1;\n        sizes.assign(m, total_clusters_used / m);\n        int remainder = total_clusters_used % m;\n        for (int i = 0; i < remainder; ++i) {\n            sizes[i]++;\n        }\n\n        // Interleave clusters among files\n        vector<int> idx(m, 0);\n        int total = 0;\n        files.resize(m);\n        for (int i = 0; total < total_clusters_used; ++i) {\n            for (int j = 0; j < m && total < total_clusters_used; ++j) {\n                if (idx[j] < sizes[j]) {\n                    files[j].push_back(clusters[total++]);\n                    idx[j]++;\n                }\n            }\n        }\n\n    } else {\n        // Default to random type\n        // (Same as 'random' case)\n        // Shuffle cluster indices\n        shuffle(clusters.begin(), clusters.end());\n\n        // Decide total clusters used\n        total_clusters_used = rnd.next(m, n - 1);\n\n        // Initialize file sizes to 1\n        sizes.assign(m, 1);\n        int remaining = total_clusters_used - m;\n\n        // Distribute remaining clusters randomly\n        for (int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, m - 1);\n            sizes[idx]++;\n        }\n\n        // Assign clusters to files\n        int idx = 0;\n        for (int i = 0; i < m; ++i) {\n            int ni = sizes[i];\n            files[i].resize(ni);\n            for (int j = 0; j < ni; ++j) {\n                files[i][j] = clusters[idx++];\n            }\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < m; ++i) {\n        int ni = files[i].size();\n        printf(\"%d\", ni);\n        for (int j = 0; j < ni; ++j) {\n            printf(\" %d\", files[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with varying sizes\n./gen -n 10 -m 2 -type random\n./gen -n 50 -m 20 -type random\n./gen -n 100 -m 50 -type random\n./gen -n 200 -m 100 -type random\n\n# Test cases with maximum clusters used\n./gen -n 10 -m 2 -type max_clusters\n./gen -n 50 -m 20 -type max_clusters\n./gen -n 100 -m 50 -type max_clusters\n./gen -n 200 -m 100 -type max_clusters\n\n# Test cases with minimum clusters used (each file occupies one cluster)\n./gen -n 10 -m 2 -type min_clusters\n./gen -n 50 -m 20 -type min_clusters\n./gen -n 100 -m 50 -type min_clusters\n./gen -n 200 -m 100 -type min_clusters\n\n# Test cases with a single file occupying almost all clusters\n./gen -n 10 -m 1 -type single_file\n./gen -n 50 -m 1 -type single_file\n./gen -n 100 -m 1 -type single_file\n./gen -n 200 -m 1 -type single_file\n\n# Test cases with many small files\n./gen -n 10 -m 9 -type many_small_files\n./gen -n 50 -m 49 -type many_small_files\n./gen -n 100 -m 99 -type many_small_files\n./gen -n 200 -m 199 -type many_small_files\n\n# Test cases with clusters assigned in reverse order\n./gen -n 10 -m 2 -type reverse_order\n./gen -n 50 -m 20 -type reverse_order\n./gen -n 100 -m 50 -type reverse_order\n./gen -n 200 -m 100 -type reverse_order\n\n# Test cases with non-contiguous clusters for each file\n./gen -n 10 -m 2 -type non_contiguous\n./gen -n 50 -m 20 -type non_contiguous\n./gen -n 100 -m 50 -type non_contiguous\n./gen -n 200 -m 100 -type non_contiguous\n\n# Test cases where files are already in perfect order\n./gen -n 10 -m 2 -type consecutive_files\n./gen -n 50 -m 20 -type consecutive_files\n./gen -n 100 -m 50 -type consecutive_files\n./gen -n 200 -m 100 -type consecutive_files\n\n# Worst-case test cases designed to challenge contestants\n./gen -n 10 -m 2 -type worst_case\n./gen -n 50 -m 20 -type worst_case\n./gen -n 100 -m 50 -type worst_case\n./gen -n 200 -m 100 -type worst_case\n\n# Edge cases with minimal n and m\n./gen -n 2 -m 1 -type random\n./gen -n 2 -m 1 -type min_clusters\n./gen -n 2 -m 1 -type max_clusters\n\n# Test cases with maximal m\n./gen -n 200 -m 199 -type random\n./gen -n 200 -m 199 -type max_clusters\n./gen -n 200 -m 199 -type min_clusters\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:32.462111",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "180/B",
      "title": "B. Divisibility Rules",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains two integers b and d (2 ≤ b, d ≤ 100) — the notation system base and the divisor. Both numbers are given in the decimal notation.",
      "output_spec": "OutputOn the first output line print the type of the rule in the b-based notation system, where the divisor is d: \"2-type\", \"3-type\", \"11-type\", \"6-type\" or \"7-type\". If there are several such types, print the one that goes earlier in the given sequence. If a number belongs to the 2-type, print on the second line the least number of the last b-based digits that we will need to use to check the divisibility.",
      "sample_tests": "ExamplesInputCopy10 10OutputCopy2-type1InputCopy2 3OutputCopy11-type",
      "description": "B. Divisibility Rules\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains two integers b and d (2 ≤ b, d ≤ 100) — the notation system base and the divisor. Both numbers are given in the decimal notation.\n\nOutputOn the first output line print the type of the rule in the b-based notation system, where the divisor is d: \"2-type\", \"3-type\", \"11-type\", \"6-type\" or \"7-type\". If there are several such types, print the one that goes earlier in the given sequence. If a number belongs to the 2-type, print on the second line the least number of the last b-based digits that we will need to use to check the divisibility.\n\nInputCopy10 10OutputCopy2-type1InputCopy2 3OutputCopy11-type\n\nInputCopy10 10\n\nOutputCopy2-type1\n\nInputCopy2 3\n\nOutputCopy11-type\n\nNoteThe divisibility rule for number 3 in binary notation looks as follows: \"A number is divisible by 3 if and only if the sum of its digits that occupy the even places differs from the sum of digits that occupy the odd places, in a number that is divisible by 3\". That's an 11-type rule. For example, 2110 = 101012. For it the sum of digits on odd positions equals 1 + 1 + 1 = 3, an on even positions — 0 + 0 = 0. The rule works and the number is divisible by 3. In some notations a number can fit into the 3-type rule and the 11-type rule. In this case the correct answer is \"3-type\".",
      "solutions": [
        {
          "title": "Codeforces Round #116 - Codeforces",
          "content": "Hello!Today it will be good old ACM-ICPC round. Yes, it will be the rated event for the second division, and the participants of the first division will be able to participate out of competition.Problems have been prepared by Nerevar, natalia, MikeMirzayanov and Edvard, and Delinur translated all the problems. Thanks!Good luck!UPD: Ratings will be updated later. Sorry for delay.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4390",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 381
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #116 - Codeforces - Code 1",
          "code": "for(int i=1;i<100001;i++)\n  {\n    if(v[i].size()==0)continue;\n    int back=0;\n    int front=0;\n    int sum=0;\n    bool frontmoved=true;\n    bool backmoved=false;\n    while(front!=v[i].size())\n    {\n      if(frontmoved)\n\tsum+=v[i][front];\n      if(backmoved)\n\tsum-=v[i][back-1];\n      if(sum<=k)\n      {\n\tif(max<front-back+2)max=front-back+2;\n\tfront++;\n\tfrontmoved=true;\n\tbackmoved=false;\n      }\n      else\n      {back++;backmoved=true;frontmoved=false;}\n      if(front<back)\n      {front++;frontmoved=true;}\n    }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #116 - Codeforces - Code 2",
          "code": "for(int i=1;i<100001;i++)\n  {\n    if(v[i].size()==0)continue;\n    int back=0;\n    int front=0;\n    int sum=0;\n    bool frontmoved=true;\n    bool backmoved=false;\n    while(front!=v[i].size())\n    {\n      if(frontmoved)\n\tsum+=v[i][front];\n      if(backmoved)\n\tsum-=v[i][back-1];\n      if(sum<=k)\n      {\n\tif(max<front-back+2)max=front-back+2;\n\tfront++;\n\tfrontmoved=true;\n\tbackmoved=false;\n      }\n      else\n      {back++;backmoved=true;frontmoved=false;}\n      if(front<back)\n      {front++;frontmoved=true;}\n    }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4390",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int b = inf.readInt(2, 100, \"b\");\n    inf.readSpace();\n    int d = inf.readInt(2, 100, \"d\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int b = inf.readInt(2, 100, \"b\");\n    inf.readSpace();\n    int d = inf.readInt(2, 100, \"d\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int b = inf.readInt(2, 100, \"b\");\n    inf.readSpace();\n    int d = inf.readInt(2, 100, \"d\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to compute gcd\nint gcd(int a, int b) {\n    while (b) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n\n// Function to factorize a number into its prime factors\nvector<int> factorize(int n) {\n    vector<int> factors;\n    for(int i = 2; i * i <= n; ++i) {\n        while(n % i == 0) {\n            if(find(factors.begin(), factors.end(), i) == factors.end())\n                factors.push_back(i);\n            n /= i;\n        }\n    }\n    if(n > 1) factors.push_back(n);\n    return factors;\n}\n\n// Function to find minimal k such that b^k mod d == 0\nint find_min_k(int b, int d) {\n    int mod = b % d;\n    int k = 1;\n    while (mod != 0 && k <= d) {\n        mod = (mod * b) % d;\n        k++;\n    }\n    if (mod == 0) return k;\n    else return -1;\n}\n\n// Function to determine the type for given b and d\nstring determine_type(int b, int d, int &min_k) {\n    // Check for 2-type\n    min_k = find_min_k(b, d);\n    if(min_k != -1) return \"2-type\";\n    \n    // Check for 3-type\n    if((b - 1) % d == 0) return \"3-type\";\n    \n    // Check for 11-type\n    if((b + 1) % d == 0) return \"11-type\";\n    \n    // Check for 6-type\n    vector<int> factors = factorize(d);\n    set<string> types_used;\n    for(int p : factors) {\n        int k_p = find_min_k(b, p);\n        if(k_p != -1) types_used.insert(\"2-type\");\n        else if((b - 1) % p == 0) types_used.insert(\"3-type\");\n        else if((b + 1) % p == 0) types_used.insert(\"11-type\");\n        else return \"7-type\"; // If any prime factor doesn't fit any type, it's 7-type\n    }\n    if(types_used.size() >= 2) return \"6-type\";\n    else if(!types_used.empty()) return *types_used.begin(); // If all factors are of same type\n    else return \"7-type\"; // No types found\n}\n\n// Function to generate a test case of a specific type\nvoid generate_test_case(string desired_type, int b_provided, int d_provided) {\n    int b = b_provided;\n    int d = d_provided;\n    int min_k;\n    const int MAX_B = 100;\n    const int MAX_D = 100;\n    if(desired_type == \"random\") {\n        b = rnd.next(2, MAX_B);\n        d = rnd.next(2, MAX_D);\n        cout << b << \" \" << d << endl;\n        return;\n    }\n    int attempts = 0;\n    while(true) {\n        attempts++;\n        if(attempts > 100000) { // To prevent infinite loops\n            // If unable to find after many attempts, output random test case\n            b = rnd.next(2, MAX_B);\n            d = rnd.next(2, MAX_D);\n            break;\n        }\n        if(b_provided == -1)\n            b = rnd.next(2, MAX_B);\n        if(d_provided == -1)\n            d = rnd.next(2, MAX_D);\n        string type = determine_type(b, d, min_k);\n        if(type == desired_type) {\n            break;\n        }\n    }\n    cout << b << \" \" << d << endl;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int b_param = opt<int>(\"b\", -1); // Base\n    int d_param = opt<int>(\"d\", -1); // Divisor\n    string type = opt<string>(\"type\", \"random\"); // Desired type\n\n    generate_test_case(type, b_param, d_param);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to compute gcd\nint gcd(int a, int b) {\n    while (b) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n\n// Function to factorize a number into its prime factors\nvector<int> factorize(int n) {\n    vector<int> factors;\n    for(int i = 2; i * i <= n; ++i) {\n        while(n % i == 0) {\n            if(find(factors.begin(), factors.end(), i) == factors.end())\n                factors.push_back(i);\n            n /= i;\n        }\n    }\n    if(n > 1) factors.push_back(n);\n    return factors;\n}\n\n// Function to find minimal k such that b^k mod d == 0\nint find_min_k(int b, int d) {\n    int mod = b % d;\n    int k = 1;\n    while (mod != 0 && k <= d) {\n        mod = (mod * b) % d;\n        k++;\n    }\n    if (mod == 0) return k;\n    else return -1;\n}\n\n// Function to determine the type for given b and d\nstring determine_type(int b, int d, int &min_k) {\n    // Check for 2-type\n    min_k = find_min_k(b, d);\n    if(min_k != -1) return \"2-type\";\n    \n    // Check for 3-type\n    if((b - 1) % d == 0) return \"3-type\";\n    \n    // Check for 11-type\n    if((b + 1) % d == 0) return \"11-type\";\n    \n    // Check for 6-type\n    vector<int> factors = factorize(d);\n    set<string> types_used;\n    for(int p : factors) {\n        int k_p = find_min_k(b, p);\n        if(k_p != -1) types_used.insert(\"2-type\");\n        else if((b - 1) % p == 0) types_used.insert(\"3-type\");\n        else if((b + 1) % p == 0) types_used.insert(\"11-type\");\n        else return \"7-type\"; // If any prime factor doesn't fit any type, it's 7-type\n    }\n    if(types_used.size() >= 2) return \"6-type\";\n    else if(!types_used.empty()) return *types_used.begin(); // If all factors are of same type\n    else return \"7-type\"; // No types found\n}\n\n// Function to generate a test case of a specific type\nvoid generate_test_case(string desired_type, int b_provided, int d_provided) {\n    int b = b_provided;\n    int d = d_provided;\n    int min_k;\n    const int MAX_B = 100;\n    const int MAX_D = 100;\n    if(desired_type == \"random\") {\n        b = rnd.next(2, MAX_B);\n        d = rnd.next(2, MAX_D);\n        cout << b << \" \" << d << endl;\n        return;\n    }\n    int attempts = 0;\n    while(true) {\n        attempts++;\n        if(attempts > 100000) { // To prevent infinite loops\n            // If unable to find after many attempts, output random test case\n            b = rnd.next(2, MAX_B);\n            d = rnd.next(2, MAX_D);\n            break;\n        }\n        if(b_provided == -1)\n            b = rnd.next(2, MAX_B);\n        if(d_provided == -1)\n            d = rnd.next(2, MAX_D);\n        string type = determine_type(b, d, min_k);\n        if(type == desired_type) {\n            break;\n        }\n    }\n    cout << b << \" \" << d << endl;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int b_param = opt<int>(\"b\", -1); // Base\n    int d_param = opt<int>(\"d\", -1); // Divisor\n    string type = opt<string>(\"type\", \"random\"); // Desired type\n\n    generate_test_case(type, b_param, d_param);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases\n./gen\n./gen\n./gen\n./gen\n./gen\n\n# Edge cases\n./gen -b 2 -d 2\n./gen -b 2 -d 100\n./gen -b 100 -d 2\n./gen -b 100 -d 100\n./gen -b 2 -d 3\n./gen -b 3 -d 2\n\n# Specific types\n./gen -type 2-type\n./gen -type 2-type\n./gen -type 3-type\n./gen -type 3-type\n./gen -type 11-type\n./gen -type 11-type\n./gen -type 6-type\n./gen -type 6-type\n./gen -type 7-type\n./gen -type 7-type\n\n# Test cases with provided base and random divisor of a specific type\n./gen -b 10 -type 2-type\n./gen -b 10 -type 3-type\n./gen -b 10 -type 11-type\n./gen -b 10 -type 6-type\n./gen -b 10 -type 7-type\n\n# Test cases with provided divisor and random base of a specific type\n./gen -d 6 -type 6-type\n./gen -d 7 -type 7-type\n./gen -d 11 -type 11-type\n./gen -d 9 -type 3-type\n./gen -d 8 -type 2-type\n\n# Maximal values\n./gen -b 100 -d 100\n./gen -b 100 -type 2-type\n./gen -b 100 -type 3-type\n./gen -b 100 -type 11-type\n./gen -b 100 -type 6-type\n./gen -b 100 -type 7-type\n\n# Minimal values\n./gen -b 2 -d 2\n./gen -b 2 -type 2-type\n./gen -b 2 -type 3-type\n./gen -b 2 -type 11-type\n./gen -b 2 -type 6-type\n./gen -b 2 -type 7-type\n\n# Provided base and divisor that are the same\n./gen -b 2 -d 2\n./gen -b 3 -d 3\n./gen -b 10 -d 10\n./gen -b 100 -d 100\n\n# Test cases to potentially catch mistakes in contestants' solutions\n./gen -b 10 -d 15 # 15 is 3*5, should be 6-type\n./gen -b 5 -d 8   # Check for 7-type\n./gen -b 16 -d 15 # Check different bases and divisors\n./gen -b 12 -d 11 # Should be 11-type\n./gen -b 99 -d 33 # 33 is 3*11, may be 6-type\n\n# Additional random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:34.284289",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "180/C",
      "title": "C. Письмо",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке входных данных содержится непустая строка из строчных и прописных латинских букв. Длина строки не превосходит 105.",
      "output_spec": "Выходные данныеВыведите единственное число — наименьшее число действий, необходимое, чтобы письмо стало красивым.",
      "sample_tests": "ПримерыВходные данныеСкопироватьPRuvetSTAaYAВыходные данныеСкопировать5Входные данныеСкопироватьOYPROSTIYAOPECHATALSYAPRIVETSTASYAВыходные данныеСкопировать0Входные данныеСкопироватьhelloworldВыходные данныеСкопировать0",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке входных данных содержится непустая строка из строчных и прописных латинских букв. Длина строки не превосходит 105.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — наименьшее число действий, необходимое, чтобы письмо стало красивым.\n\nВыходные данные\n\nВходные данныеСкопироватьPRuvetSTAaYAВыходные данныеСкопировать5Входные данныеСкопироватьOYPROSTIYAOPECHATALSYAPRIVETSTASYAВыходные данныеСкопировать0Входные данныеСкопироватьhelloworldВыходные данныеСкопировать0\n\nВходные данныеСкопироватьPRuvetSTAaYA\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьOYPROSTIYAOPECHATALSYAPRIVETSTASYA\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьhelloworld\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #116 - Codeforces",
          "content": "Всем привет!Сегодня вас ждет раунд по старым-добрым ACM-ICPC правилам. Да, это будет рейтинговый контест для второго дивизиона, а участники из первого дивизиона смогут принять участие вне конкурса.Задачи для вас делали Nerevar, natalia, MikeMirzayanov и Edvard, а Delinur перевела задачи. Спасибо всем за помощь!Желаю удачи!UPD: Рейтинг будет обновлен позже.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4390",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 358
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #116 - Codeforces - Code 1",
          "code": "for(int i=1;i<100001;i++)\n  {\n    if(v[i].size()==0)continue;\n    int back=0;\n    int front=0;\n    int sum=0;\n    bool frontmoved=true;\n    bool backmoved=false;\n    while(front!=v[i].size())\n    {\n      if(frontmoved)\n\tsum+=v[i][front];\n      if(backmoved)\n\tsum-=v[i][back-1];\n      if(sum<=k)\n      {\n\tif(max<front-back+2)max=front-back+2;\n\tfront++;\n\tfrontmoved=true;\n\tbackmoved=false;\n      }\n      else\n      {back++;backmoved=true;frontmoved=false;}\n      if(front<back)\n      {front++;frontmoved=true;}\n    }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #116 - Codeforces - Code 2",
          "code": "for(int i=1;i<100001;i++)\n  {\n    if(v[i].size()==0)continue;\n    int back=0;\n    int front=0;\n    int sum=0;\n    bool frontmoved=true;\n    bool backmoved=false;\n    while(front!=v[i].size())\n    {\n      if(frontmoved)\n\tsum+=v[i][front];\n      if(backmoved)\n\tsum-=v[i][back-1];\n      if(sum<=k)\n      {\n\tif(max<front-back+2)max=front-back+2;\n\tfront++;\n\tfrontmoved=true;\n\tbackmoved=false;\n      }\n      else\n      {back++;backmoved=true;frontmoved=false;}\n      if(front<back)\n      {front++;frontmoved=true;}\n    }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4390",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[A-Za-z]+\", \"message\");\n\n    ensuref(s.length() <= 100000, \"The length of message must not exceed 1e5, but it is %d\", (int)s.length());\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[A-Za-z]+\", \"message\");\n\n    ensuref(s.length() <= 100000, \"The length of message must not exceed 1e5, but it is %d\", (int)s.length());\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[A-Za-z]+\", \"message\");\n\n    ensuref(s.length() <= 100000, \"The length of message must not exceed 1e5, but it is %d\", (int)s.length());\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, 'a');\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            if (rnd.next(2))\n                c = toupper(c);\n            else\n                c = tolower(c);\n            s[i] = c;\n        }\n    } else if (type == \"all_upper\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'A' + rnd.next(26);\n        }\n    } else if (type == \"all_lower\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"uppercase_prefix\") {\n        int k = opt<int>(\"k\", n/2); // Default k = n/2\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            if (i < k)\n                s[i] = toupper(c);\n            else\n                s[i] = tolower(c);\n        }\n    } else if (type == \"lowercase_prefix\") {\n        int k = opt<int>(\"k\", n/2); // Default k = n/2\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            if (i < k)\n                s[i] = tolower(c);\n            else\n                s[i] = toupper(c);\n        }\n    } else if (type == \"alternating_upper_start\") {\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            if (i % 2 == 0)\n                s[i] = toupper(c);\n            else\n                s[i] = tolower(c);\n        }\n    } else if (type == \"alternating_lower_start\") {\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            if (i % 2 == 0)\n                s[i] = tolower(c);\n            else\n                s[i] = toupper(c);\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            if (rnd.next(2))\n                c = toupper(c);\n            else\n                c = tolower(c);\n            s[i] = c;\n        }\n    }\n\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, 'a');\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            if (rnd.next(2))\n                c = toupper(c);\n            else\n                c = tolower(c);\n            s[i] = c;\n        }\n    } else if (type == \"all_upper\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'A' + rnd.next(26);\n        }\n    } else if (type == \"all_lower\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"uppercase_prefix\") {\n        int k = opt<int>(\"k\", n/2); // Default k = n/2\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            if (i < k)\n                s[i] = toupper(c);\n            else\n                s[i] = tolower(c);\n        }\n    } else if (type == \"lowercase_prefix\") {\n        int k = opt<int>(\"k\", n/2); // Default k = n/2\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            if (i < k)\n                s[i] = tolower(c);\n            else\n                s[i] = toupper(c);\n        }\n    } else if (type == \"alternating_upper_start\") {\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            if (i % 2 == 0)\n                s[i] = toupper(c);\n            else\n                s[i] = tolower(c);\n        }\n    } else if (type == \"alternating_lower_start\") {\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            if (i % 2 == 0)\n                s[i] = tolower(c);\n            else\n                s[i] = toupper(c);\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            if (rnd.next(2))\n                c = toupper(c);\n            else\n                c = tolower(c);\n            s[i] = c;\n        }\n    }\n\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1000 -type all_upper\n./gen -n 1000 -type all_lower\n./gen -n 1000 -type uppercase_prefix -k 500\n./gen -n 1000 -type lowercase_prefix -k 500\n./gen -n 1000 -type random\n./gen -n 1000 -type alternating_upper_start\n./gen -n 1000 -type alternating_lower_start\n\n./gen -n 10000 -type all_upper\n./gen -n 10000 -type all_lower\n./gen -n 10000 -type uppercase_prefix -k 5000\n./gen -n 10000 -type lowercase_prefix -k 5000\n./gen -n 10000 -type random\n./gen -n 10000 -type alternating_upper_start\n./gen -n 10000 -type alternating_lower_start\n\n./gen -n 100000 -type all_upper\n./gen -n 100000 -type all_lower\n./gen -n 100000 -type uppercase_prefix -k 50000\n./gen -n 100000 -type lowercase_prefix -k 50000\n./gen -n 100000 -type random\n./gen -n 100000 -type alternating_upper_start\n./gen -n 100000 -type alternating_lower_start\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:36.435620",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "180/D",
      "title": "D. Имя",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записана непустая строка s (1 ≤ |s| ≤ 5000), где |s| — ее длина. Вторая строка содержит непустую строку t (1 ≤ |t| ≤ 5000), где |t| — ее длина. Обе строки состоят из строчных букв латинского алфавита.",
      "output_spec": "Выходные данныеВыведите искомое имя или -1, если такового не существует.",
      "sample_tests": "ПримерыВходные данныеСкопироватьaadaacВыходные данныеСкопироватьaadВходные данныеСкопироватьabadbobВыходные данныеСкопироватьdaabВходные данныеСкопироватьabcdefgВыходные данныеСкопировать-1Входные данныеСкопироватьczaaababcdefВыходные данныеСкопироватьabczaa",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записана непустая строка s (1 ≤ |s| ≤ 5000), где |s| — ее длина. Вторая строка содержит непустую строку t (1 ≤ |t| ≤ 5000), где |t| — ее длина. Обе строки состоят из строчных букв латинского алфавита.\n\nВходные данные\n\nВыходные данныеВыведите искомое имя или -1, если такового не существует.\n\nВыходные данные\n\nВходные данныеСкопироватьaadaacВыходные данныеСкопироватьaadВходные данныеСкопироватьabadbobВыходные данныеСкопироватьdaabВходные данныеСкопироватьabcdefgВыходные данныеСкопировать-1Входные данныеСкопироватьczaaababcdefВыходные данныеСкопироватьabczaa\n\nВходные данныеСкопироватьaadaac\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьaad\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьabadbob\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьdaab\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьabcdefg\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьczaaababcdef\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьabczaa\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере данная строка s является искомой, следовательно, порядок букв в ней менять не надо.",
      "solutions": [
        {
          "title": "Codeforces Round #116 - Codeforces",
          "content": "Всем привет!Сегодня вас ждет раунд по старым-добрым ACM-ICPC правилам. Да, это будет рейтинговый контест для второго дивизиона, а участники из первого дивизиона смогут принять участие вне конкурса.Задачи для вас делали Nerevar, natalia, MikeMirzayanov и Edvard, а Delinur перевела задачи. Спасибо всем за помощь!Желаю удачи!UPD: Рейтинг будет обновлен позже.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4390",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 358
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #116 - Codeforces - Code 1",
          "code": "for(int i=1;i<100001;i++)\n  {\n    if(v[i].size()==0)continue;\n    int back=0;\n    int front=0;\n    int sum=0;\n    bool frontmoved=true;\n    bool backmoved=false;\n    while(front!=v[i].size())\n    {\n      if(frontmoved)\n\tsum+=v[i][front];\n      if(backmoved)\n\tsum-=v[i][back-1];\n      if(sum<=k)\n      {\n\tif(max<front-back+2)max=front-back+2;\n\tfront++;\n\tfrontmoved=true;\n\tbackmoved=false;\n      }\n      else\n      {back++;backmoved=true;frontmoved=false;}\n      if(front<back)\n      {front++;frontmoved=true;}\n    }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4390",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #116 - Codeforces - Code 2",
          "code": "for(int i=1;i<100001;i++)\n  {\n    if(v[i].size()==0)continue;\n    int back=0;\n    int front=0;\n    int sum=0;\n    bool frontmoved=true;\n    bool backmoved=false;\n    while(front!=v[i].size())\n    {\n      if(frontmoved)\n\tsum+=v[i][front];\n      if(backmoved)\n\tsum-=v[i][back-1];\n      if(sum<=k)\n      {\n\tif(max<front-back+2)max=front-back+2;\n\tfront++;\n\tfrontmoved=true;\n\tbackmoved=false;\n      }\n      else\n      {back++;backmoved=true;frontmoved=false;}\n      if(front<back)\n      {front++;frontmoved=true;}\n    }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4390",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,5000}\", \"s\");\n    string t = inf.readLine(\"[a-z]{1,5000}\", \"t\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,5000}\", \"s\");\n    string t = inf.readLine(\"[a-z]{1,5000}\", \"t\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,5000}\", \"s\");\n    string t = inf.readLine(\"[a-z]{1,5000}\", \"t\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n); // Default m = n if not specified\n    string type = opt<string>(\"type\");\n\n    string s, t;\n\n    if (type == \"random\") {\n        // Generate random s and t of lengths n and m\n        s = \"\";\n        t = \"\";\n        for (int i = 0; i < n; ++i)\n            s += (char)('a' + rnd.next(26));\n        for (int i = 0; i < m; ++i)\n            t += (char)('a' + rnd.next(26));\n    } else if (type == \"same\") {\n        // Generate s of length n, t = s\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += (char)('a' + rnd.next(26));\n        t = s;\n    } else if (type == \"onechar_diff\") {\n        // Generate s and t that differ by one character\n        // Ensure n == m\n        m = n;\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += (char)('a' + rnd.next(26));\n        t = s;\n        // Change one character in t\n        if (n > 0) {\n            int pos = rnd.next(n);\n            char original = t[pos];\n            char new_char;\n            do {\n                new_char = 'a' + rnd.next(26);\n            } while (new_char == original);\n            t[pos] = new_char;\n        }\n    } else if (type == \"impossible\") {\n        // Generate s randomly, t as lex maximum permutation of s\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += (char)('a' + rnd.next(26));\n        vector<char> chars(s.begin(), s.end());\n        sort(chars.rbegin(), chars.rend());\n        t = string(chars.begin(), chars.end());\n        // Optionally, if m > n, we can append extra characters to t\n        if (m > n) {\n            while ((int)t.length() < m) {\n                t += (char)('a' + rnd.next(26));\n            }\n        }\n    } else if (type == \"minimal\") {\n        // Generate t randomly, s as the next permutation of t\n        m = n;\n        t = \"\";\n        for (int i = 0; i < n; ++i)\n            t += (char)('a' + rnd.next(26));\n\n        // Ensure t is not the lex maximum permutation\n        string t_sorted = t;\n        sort(t_sorted.begin(), t_sorted.end());\n        string t_max = t_sorted;\n        reverse(t_max.begin(), t_max.end());\n\n        if (t == t_max) {\n            // Modify t to ensure it is not the lex maximum permutation\n            bool changed = false;\n            for (int i = n - 1; i >= 1; --i) {\n                if (t[i] < t[i - 1]) {\n                    swap(t[i], t[i - 1]);\n                    changed = true;\n                    break;\n                }\n            }\n            if (!changed) {\n                t[0] = 'a';\n            }\n        }\n\n        s = t;\n        bool has_next = next_permutation(s.begin(), s.end());\n        if (!has_next) {\n            // Should not happen because we adjusted t\n            sort(s.begin(), s.end());\n        }\n    } else {\n        // Default to random\n        s = \"\";\n        t = \"\";\n        for (int i = 0; i < n; ++i)\n            s += (char)('a' + rnd.next(26));\n        for (int i = 0; i < m; ++i)\n            t += (char)('a' + rnd.next(26));\n    }\n\n    // Output s and t\n    printf(\"%s\\n\", s.c_str());\n    printf(\"%s\\n\", t.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n); // Default m = n if not specified\n    string type = opt<string>(\"type\");\n\n    string s, t;\n\n    if (type == \"random\") {\n        // Generate random s and t of lengths n and m\n        s = \"\";\n        t = \"\";\n        for (int i = 0; i < n; ++i)\n            s += (char)('a' + rnd.next(26));\n        for (int i = 0; i < m; ++i)\n            t += (char)('a' + rnd.next(26));\n    } else if (type == \"same\") {\n        // Generate s of length n, t = s\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += (char)('a' + rnd.next(26));\n        t = s;\n    } else if (type == \"onechar_diff\") {\n        // Generate s and t that differ by one character\n        // Ensure n == m\n        m = n;\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += (char)('a' + rnd.next(26));\n        t = s;\n        // Change one character in t\n        if (n > 0) {\n            int pos = rnd.next(n);\n            char original = t[pos];\n            char new_char;\n            do {\n                new_char = 'a' + rnd.next(26);\n            } while (new_char == original);\n            t[pos] = new_char;\n        }\n    } else if (type == \"impossible\") {\n        // Generate s randomly, t as lex maximum permutation of s\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += (char)('a' + rnd.next(26));\n        vector<char> chars(s.begin(), s.end());\n        sort(chars.rbegin(), chars.rend());\n        t = string(chars.begin(), chars.end());\n        // Optionally, if m > n, we can append extra characters to t\n        if (m > n) {\n            while ((int)t.length() < m) {\n                t += (char)('a' + rnd.next(26));\n            }\n        }\n    } else if (type == \"minimal\") {\n        // Generate t randomly, s as the next permutation of t\n        m = n;\n        t = \"\";\n        for (int i = 0; i < n; ++i)\n            t += (char)('a' + rnd.next(26));\n\n        // Ensure t is not the lex maximum permutation\n        string t_sorted = t;\n        sort(t_sorted.begin(), t_sorted.end());\n        string t_max = t_sorted;\n        reverse(t_max.begin(), t_max.end());\n\n        if (t == t_max) {\n            // Modify t to ensure it is not the lex maximum permutation\n            bool changed = false;\n            for (int i = n - 1; i >= 1; --i) {\n                if (t[i] < t[i - 1]) {\n                    swap(t[i], t[i - 1]);\n                    changed = true;\n                    break;\n                }\n            }\n            if (!changed) {\n                t[0] = 'a';\n            }\n        }\n\n        s = t;\n        bool has_next = next_permutation(s.begin(), s.end());\n        if (!has_next) {\n            // Should not happen because we adjusted t\n            sort(s.begin(), s.end());\n        }\n    } else {\n        // Default to random\n        s = \"\";\n        t = \"\";\n        for (int i = 0; i < n; ++i)\n            s += (char)('a' + rnd.next(26));\n        for (int i = 0; i < m; ++i)\n            t += (char)('a' + rnd.next(26));\n    }\n\n    // Output s and t\n    printf(\"%s\\n\", s.c_str());\n    printf(\"%s\\n\", t.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type same\n./gen -n 1 -m 1 -type onechar_diff\n./gen -n 1 -m 2 -type impossible\n\n./gen -n 5 -m 5 -type random\n./gen -n 5 -m 5 -type same\n./gen -n 5 -m 5 -type onechar_diff\n./gen -n 5 -m 5 -type impossible\n./gen -n 5 -m 5 -type minimal\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type same\n./gen -n 10 -m 10 -type onechar_diff\n./gen -n 10 -m 15 -type impossible\n./gen -n 10 -m 10 -type minimal\n\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type same\n./gen -n 100 -m 100 -type onechar_diff\n./gen -n 100 -m 101 -type impossible\n./gen -n 100 -m 100 -type minimal\n\n./gen -n 5000 -m 5000 -type random\n./gen -n 5000 -m 5000 -type same\n./gen -n 5000 -m 5000 -type onechar_diff\n./gen -n 5000 -m 5001 -type impossible\n./gen -n 5000 -m 5000 -type minimal\n\n./gen -n 1000 -m 2000 -type random\n./gen -n 2000 -m 1000 -type random\n./gen -n 4999 -m 5000 -type random\n\n./gen -n 2 -m 3 -type impossible\n./gen -n 3 -m 2 -type random\n\n./gen -n 3000 -m 3000 -type random\n./gen -n 3000 -m 3000 -type minimal\n\n./gen -n 4000 -m 4000 -type same\n./gen -n 4000 -m 4000 -type onechar_diff\n\n./gen -n 5000 -m 5000 -type random\n\n./gen -n 5000 -m 5000 -type impossible\n./gen -n 5000 -m 5000 -type minimal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:38.184636",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "180/E",
      "title": "E. Cubes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m and k (1 ≤ n ≤ 2·105, 1 ≤ m ≤ 105, 0 ≤ k < n). The second line contains n integers from 1 to m — the numbers of cube colors. The numbers of colors are separated by single spaces.",
      "output_spec": "OutputPrint the maximum possible number of points you can score.",
      "sample_tests": "ExamplesInputCopy10 3 21 2 1 1 3 2 1 1 2 2OutputCopy4InputCopy10 2 21 2 1 2 1 1 2 1 1 2OutputCopy5InputCopy3 1 21 1 1OutputCopy3",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m and k (1 ≤ n ≤ 2·105, 1 ≤ m ≤ 105, 0 ≤ k < n). The second line contains n integers from 1 to m — the numbers of cube colors. The numbers of colors are separated by single spaces.\n\nOutputPrint the maximum possible number of points you can score.\n\nInputCopy10 3 21 2 1 1 3 2 1 1 2 2OutputCopy4InputCopy10 2 21 2 1 2 1 1 2 1 1 2OutputCopy5InputCopy3 1 21 1 1OutputCopy3\n\nInputCopy10 3 21 2 1 1 3 2 1 1 2 2\n\nOutputCopy4\n\nInputCopy10 2 21 2 1 2 1 1 2 1 1 2\n\nOutputCopy5\n\nInputCopy3 1 21 1 1\n\nOutputCopy3\n\nNoteIn the first sample you should delete the fifth and the sixth cubes.In the second sample you should delete the fourth and the seventh cubes.In the third sample you shouldn't delete any cubes.",
      "solutions": [
        {
          "title": "Codeforces Round #116 - Codeforces",
          "content": "Hello!Today it will be good old ACM-ICPC round. Yes, it will be the rated event for the second division, and the participants of the first division will be able to participate out of competition.Problems have been prepared by Nerevar, natalia, MikeMirzayanov and Edvard, and Delinur translated all the problems. Thanks!Good luck!UPD: Ratings will be updated later. Sorry for delay.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4390",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 381
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #116 - Codeforces - Code 1",
          "code": "for(int i=1;i<100001;i++)\n  {\n    if(v[i].size()==0)continue;\n    int back=0;\n    int front=0;\n    int sum=0;\n    bool frontmoved=true;\n    bool backmoved=false;\n    while(front!=v[i].size())\n    {\n      if(frontmoved)\n\tsum+=v[i][front];\n      if(backmoved)\n\tsum-=v[i][back-1];\n      if(sum<=k)\n      {\n\tif(max<front-back+2)max=front-back+2;\n\tfront++;\n\tfrontmoved=true;\n\tbackmoved=false;\n      }\n      else\n      {back++;backmoved=true;frontmoved=false;}\n      if(front<back)\n      {front++;frontmoved=true;}\n    }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4390",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #116 - Codeforces - Code 2",
          "code": "for(int i=1;i<100001;i++)\n  {\n    if(v[i].size()==0)continue;\n    int back=0;\n    int front=0;\n    int sum=0;\n    bool frontmoved=true;\n    bool backmoved=false;\n    while(front!=v[i].size())\n    {\n      if(frontmoved)\n\tsum+=v[i][front];\n      if(backmoved)\n\tsum-=v[i][back-1];\n      if(sum<=k)\n      {\n\tif(max<front-back+2)max=front-back+2;\n\tfront++;\n\tfrontmoved=true;\n\tbackmoved=false;\n      }\n      else\n      {back++;backmoved=true;frontmoved=false;}\n      if(front<back)\n      {front++;frontmoved=true;}\n    }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4390",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n - 1, \"k\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 1, m, \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n - 1, \"k\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 1, m, \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n - 1, \"k\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 1, m, \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (k >= n) {\n        cerr << \"Error: k must be less than n.\\n\";\n        exit(1);\n    }\n\n    if (m < 1 || m > 100000) {\n        cerr << \"Error: m is out of bounds.\\n\";\n        exit(1);\n    }\n\n    if (n < 1 || n > 200000) {\n        cerr << \"Error: n is out of bounds.\\n\";\n        exit(1);\n    }\n\n    vector<int> colors(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            colors[i] = rnd.next(1, m);\n        }\n    } else if (type == \"all_same\") {\n        int c = rnd.next(1, m);\n        for (int i = 0; i < n; ++i) {\n            colors[i] = c;\n        }\n    } else if (type == \"all_different\") {\n        if (n > m) {\n            cerr << \"Error: n > m in all_different type.\\n\";\n            exit(1);\n        }\n        for (int i = 0; i < n; ++i) {\n            colors[i] = i + 1;\n        }\n        shuffle(colors.begin(), colors.end());\n    } else if (type == \"alternating\") {\n        if (m < 2) {\n            cerr << \"Error: m must be at least 2 for alternating type.\\n\";\n            exit(1);\n        }\n        int c1 = rnd.next(1, m);\n        int c2 = rnd.next(1, m);\n        while (c2 == c1) c2 = rnd.next(1, m);\n        for (int i = 0; i < n; ++i) {\n            colors[i] = (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (type == \"blocks\") {\n        int max_blocks = min(n, min(m, 10));\n        int num_blocks = rnd.next(1, max_blocks);\n        vector<int> block_sizes(num_blocks);\n        int remaining = n;\n        for (int i = 0; i < num_blocks; ++i) {\n            int size;\n            if (i == num_blocks -1) {\n                size = remaining;\n            } else {\n                size = rnd.next(1, remaining - (num_blocks - i - 1));\n            }\n            block_sizes[i] = size;\n            remaining -= size;\n        }\n        vector<int> block_colors(num_blocks);\n        for (int i = 0; i < num_blocks; ++i) {\n            int c = rnd.next(1, m);\n            while (find(block_colors.begin(), block_colors.begin()+i, c) != block_colors.begin()+i) {\n                c = rnd.next(1, m);\n            }\n            block_colors[i] = c;\n        }\n\n        int idx = 0;\n        for (int i = 0; i < num_blocks; ++i) {\n            int c = block_colors[i];\n            for (int j = 0; j < block_sizes[i]; ++j) {\n                colors[idx++] = c;\n            }\n        }\n        // Optionally shuffle the blocks\n        vector<int> block_indices(num_blocks);\n        for (int i = 0; i < num_blocks; ++i)\n            block_indices[i] = i;\n        shuffle(block_indices.begin(), block_indices.end());\n        vector<int> new_colors(n);\n        idx = 0;\n        for (int i = 0; i < num_blocks; ++i) {\n            int bi = block_indices[i];\n            int size = block_sizes[bi];\n            for (int j = 0; j < size; ++j) {\n                new_colors[idx++] = block_colors[bi];\n            }\n        }\n        colors = new_colors;\n    } else if (type == \"max_score\") {\n        if (m < 2) {\n            cerr << \"Error: m must be at least 2 for max_score type.\\n\";\n            exit(1);\n        }\n        int c = rnd.next(1, m);\n        int positions = k + 1;\n        int interval = max(1, n / positions);\n        int idx = 0;\n        for (int i = 0; i < positions && idx < n; ++i) {\n            colors[idx++] = c;\n            int num_between = interval - 1;\n            for (int j = 0; j < num_between && idx < n; ++j) {\n                int other_color = rnd.next(1, m);\n                while (other_color == c) other_color = rnd.next(1, m);\n                colors[idx++] = other_color;\n            }\n        }\n        while (idx < n) {\n            int cc = rnd.next(1, m);\n            colors[idx++] = cc;\n        }\n    } else if (type == \"min_score\") {\n        for (int i = 0; i < n; ++i) {\n            colors[i] = rnd.next(1, m);\n        }\n    } else {\n        cerr << \"Error: Unknown type.\\n\";\n        exit(1);\n    }\n\n    cout << n << \" \" << m << \" \" << k << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        cout << colors[i];\n        if (i + 1 < n) cout << \" \";\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (k >= n) {\n        cerr << \"Error: k must be less than n.\\n\";\n        exit(1);\n    }\n\n    if (m < 1 || m > 100000) {\n        cerr << \"Error: m is out of bounds.\\n\";\n        exit(1);\n    }\n\n    if (n < 1 || n > 200000) {\n        cerr << \"Error: n is out of bounds.\\n\";\n        exit(1);\n    }\n\n    vector<int> colors(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            colors[i] = rnd.next(1, m);\n        }\n    } else if (type == \"all_same\") {\n        int c = rnd.next(1, m);\n        for (int i = 0; i < n; ++i) {\n            colors[i] = c;\n        }\n    } else if (type == \"all_different\") {\n        if (n > m) {\n            cerr << \"Error: n > m in all_different type.\\n\";\n            exit(1);\n        }\n        for (int i = 0; i < n; ++i) {\n            colors[i] = i + 1;\n        }\n        shuffle(colors.begin(), colors.end());\n    } else if (type == \"alternating\") {\n        if (m < 2) {\n            cerr << \"Error: m must be at least 2 for alternating type.\\n\";\n            exit(1);\n        }\n        int c1 = rnd.next(1, m);\n        int c2 = rnd.next(1, m);\n        while (c2 == c1) c2 = rnd.next(1, m);\n        for (int i = 0; i < n; ++i) {\n            colors[i] = (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (type == \"blocks\") {\n        int max_blocks = min(n, min(m, 10));\n        int num_blocks = rnd.next(1, max_blocks);\n        vector<int> block_sizes(num_blocks);\n        int remaining = n;\n        for (int i = 0; i < num_blocks; ++i) {\n            int size;\n            if (i == num_blocks -1) {\n                size = remaining;\n            } else {\n                size = rnd.next(1, remaining - (num_blocks - i - 1));\n            }\n            block_sizes[i] = size;\n            remaining -= size;\n        }\n        vector<int> block_colors(num_blocks);\n        for (int i = 0; i < num_blocks; ++i) {\n            int c = rnd.next(1, m);\n            while (find(block_colors.begin(), block_colors.begin()+i, c) != block_colors.begin()+i) {\n                c = rnd.next(1, m);\n            }\n            block_colors[i] = c;\n        }\n\n        int idx = 0;\n        for (int i = 0; i < num_blocks; ++i) {\n            int c = block_colors[i];\n            for (int j = 0; j < block_sizes[i]; ++j) {\n                colors[idx++] = c;\n            }\n        }\n        // Optionally shuffle the blocks\n        vector<int> block_indices(num_blocks);\n        for (int i = 0; i < num_blocks; ++i)\n            block_indices[i] = i;\n        shuffle(block_indices.begin(), block_indices.end());\n        vector<int> new_colors(n);\n        idx = 0;\n        for (int i = 0; i < num_blocks; ++i) {\n            int bi = block_indices[i];\n            int size = block_sizes[bi];\n            for (int j = 0; j < size; ++j) {\n                new_colors[idx++] = block_colors[bi];\n            }\n        }\n        colors = new_colors;\n    } else if (type == \"max_score\") {\n        if (m < 2) {\n            cerr << \"Error: m must be at least 2 for max_score type.\\n\";\n            exit(1);\n        }\n        int c = rnd.next(1, m);\n        int positions = k + 1;\n        int interval = max(1, n / positions);\n        int idx = 0;\n        for (int i = 0; i < positions && idx < n; ++i) {\n            colors[idx++] = c;\n            int num_between = interval - 1;\n            for (int j = 0; j < num_between && idx < n; ++j) {\n                int other_color = rnd.next(1, m);\n                while (other_color == c) other_color = rnd.next(1, m);\n                colors[idx++] = other_color;\n            }\n        }\n        while (idx < n) {\n            int cc = rnd.next(1, m);\n            colors[idx++] = cc;\n        }\n    } else if (type == \"min_score\") {\n        for (int i = 0; i < n; ++i) {\n            colors[i] = rnd.next(1, m);\n        }\n    } else {\n        cerr << \"Error: Unknown type.\\n\";\n        exit(1);\n    }\n\n    cout << n << \" \" << m << \" \" << k << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        cout << colors[i];\n        if (i + 1 < n) cout << \" \";\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -k 0 -type all_same\n./gen -n 5 -m 3 -k 0 -type random\n./gen -n 5 -m 3 -k 4 -type random\n./gen -n 10 -m 1 -k 0 -type all_same\n./gen -n 10 -m 10 -k 5 -type all_different\n./gen -n 10 -m 2 -k 2 -type alternating\n./gen -n 200000 -m 100000 -k 0 -type random\n./gen -n 200000 -m 100000 -k 199999 -type random\n./gen -n 10 -m 100000 -k 0 -type all_different\n./gen -n 200000 -m 1 -k 100000 -type all_same\n./gen -n 200000 -m 2 -k 100000 -type alternating\n./gen -n 10 -m 3 -k 2 -type max_score\n./gen -n 200000 -m 100000 -k 100000 -type max_score\n./gen -n 10 -m 3 -k 2 -type min_score\n./gen -n 200000 -m 100000 -k 100000 -type min_score\n./gen -n 10 -m 5 -k 2 -type blocks\n./gen -n 200000 -m 10000 -k 50000 -type blocks\n./gen -n 200000 -m 100000 -k 0 -type random\n./gen -n 200000 -m 100000 -k 199999 -type random\n./gen -n 200000 -m 1 -k 199999 -type all_same\n./gen -n 200000 -m 2 -k 0 -type alternating\n./gen -n 100000 -m 100000 -k 0 -type all_different\n./gen -n 100000 -m 100000 -k 99999 -type all_different\n./gen -n 200000 -m 1000 -k 100000 -type max_score\n./gen -n 200000 -m 1 -k 0 -type random\n./gen -n 200000 -m 100000 -k 0 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:40.253184",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "180/F",
      "title": "F. Mathematical Analysis Rocks!",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105) — the number of students in the group. The second line contains sequence of different integers a1, a2, ..., an (1 ≤ ai ≤ n). The third line contains the sequence of different integers b1, b2, ..., bn (1 ≤ bi ≤ n).",
      "output_spec": "OutputPrint sequence n of different integers p[1], p[2], ..., p[n] (1 ≤ p[i] ≤ n). It is guaranteed that the solution exists and that it is unique.",
      "sample_tests": "ExamplesInputCopy42 1 4 33 4 2 1OutputCopy4 3 1 2 InputCopy55 2 3 1 41 3 2 4 5OutputCopy4 3 2 5 1 InputCopy21 22 1OutputCopy2 1",
      "description": "F. Mathematical Analysis Rocks!\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105) — the number of students in the group. The second line contains sequence of different integers a1, a2, ..., an (1 ≤ ai ≤ n). The third line contains the sequence of different integers b1, b2, ..., bn (1 ≤ bi ≤ n).\n\nOutputPrint sequence n of different integers p[1], p[2], ..., p[n] (1 ≤ p[i] ≤ n). It is guaranteed that the solution exists and that it is unique.\n\nInputCopy42 1 4 33 4 2 1OutputCopy4 3 1 2 InputCopy55 2 3 1 41 3 2 4 5OutputCopy4 3 2 5 1 InputCopy21 22 1OutputCopy2 1\n\nInputCopy42 1 4 33 4 2 1\n\nOutputCopy4 3 1 2\n\nInputCopy55 2 3 1 41 3 2 4 5\n\nOutputCopy4 3 2 5 1\n\nInputCopy21 22 1\n\nOutputCopy2 1",
      "solutions": [
        {
          "title": "Codeforces Round #116 - Codeforces",
          "content": "Hello!Today it will be good old ACM-ICPC round. Yes, it will be the rated event for the second division, and the participants of the first division will be able to participate out of competition.Problems have been prepared by Nerevar, natalia, MikeMirzayanov and Edvard, and Delinur translated all the problems. Thanks!Good luck!UPD: Ratings will be updated later. Sorry for delay.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4390",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 381
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #116 - Codeforces - Code 1",
          "code": "for(int i=1;i<100001;i++)\n  {\n    if(v[i].size()==0)continue;\n    int back=0;\n    int front=0;\n    int sum=0;\n    bool frontmoved=true;\n    bool backmoved=false;\n    while(front!=v[i].size())\n    {\n      if(frontmoved)\n\tsum+=v[i][front];\n      if(backmoved)\n\tsum-=v[i][back-1];\n      if(sum<=k)\n      {\n\tif(max<front-back+2)max=front-back+2;\n\tfront++;\n\tfrontmoved=true;\n\tbackmoved=false;\n      }\n      else\n      {back++;backmoved=true;frontmoved=false;}\n      if(front<back)\n      {front++;frontmoved=true;}\n    }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4390",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #116 - Codeforces - Code 2",
          "code": "for(int i=1;i<100001;i++)\n  {\n    if(v[i].size()==0)continue;\n    int back=0;\n    int front=0;\n    int sum=0;\n    bool frontmoved=true;\n    bool backmoved=false;\n    while(front!=v[i].size())\n    {\n      if(frontmoved)\n\tsum+=v[i][front];\n      if(backmoved)\n\tsum-=v[i][back-1];\n      if(sum<=k)\n      {\n\tif(max<front-back+2)max=front-back+2;\n\tfront++;\n\tfrontmoved=true;\n\tbackmoved=false;\n      }\n      else\n      {back++;backmoved=true;frontmoved=false;}\n      if(front<back)\n      {front++;frontmoved=true;}\n    }\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4390",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    vector<bool> vis(n+1, false);\n    for(int i = 0; i < n; ++i) {\n        int x = a[i];\n        ensuref(!vis[x], \"Number %d appears more than once in sequence a\", x);\n        vis[x] = true;\n    }\n\n    vector<int> b = inf.readInts(n, 1, n, \"b_i\");\n    inf.readEoln();\n\n    fill(vis.begin(), vis.end(), false);\n    for(int i = 0; i < n; ++i) {\n        int x = b[i];\n        ensuref(!vis[x], \"Number %d appears more than once in sequence b\", x);\n        vis[x] = true;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    vector<bool> vis(n+1, false);\n    for(int i = 0; i < n; ++i) {\n        int x = a[i];\n        ensuref(!vis[x], \"Number %d appears more than once in sequence a\", x);\n        vis[x] = true;\n    }\n\n    vector<int> b = inf.readInts(n, 1, n, \"b_i\");\n    inf.readEoln();\n\n    fill(vis.begin(), vis.end(), false);\n    for(int i = 0; i < n; ++i) {\n        int x = b[i];\n        ensuref(!vis[x], \"Number %d appears more than once in sequence b\", x);\n        vis[x] = true;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    vector<bool> vis(n+1, false);\n    for(int i = 0; i < n; ++i) {\n        int x = a[i];\n        ensuref(!vis[x], \"Number %d appears more than once in sequence a\", x);\n        vis[x] = true;\n    }\n\n    vector<int> b = inf.readInts(n, 1, n, \"b_i\");\n    inf.readEoln();\n\n    fill(vis.begin(), vis.end(), false);\n    for(int i = 0; i < n; ++i) {\n        int x = b[i];\n        ensuref(!vis[x], \"Number %d appears more than once in sequence b\", x);\n        vis[x] = true;\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n + 1); // 1-based indexing\n\n    if (type == \"identity\") {\n        // p[i] = i\n        for (int i = 1; i <= n; ++i)\n            p[i] = i;\n    } else if (type == \"reverse\") {\n        // p[i] = n - i + 1\n        for (int i = 1; i <= n; ++i)\n            p[i] = n - i + 1;\n    } else if (type == \"bigcycle\") {\n        // Create a single cycle: p[1] = 2, p[2] = 3, ..., p[n-1] = n, p[n] = 1\n        for (int i = 1; i < n; ++i)\n            p[i] = i + 1;\n        p[n] = 1;\n    } else if (type == \"smallcycles\") {\n        // Create cycles of a given size\n        int cyclesize = opt<int>(\"cyclesize\", 2);\n        int idx = 1;\n        while (idx + cyclesize - 1 <= n) {\n            for (int j = 0; j < cyclesize - 1; ++j) {\n                p[idx + j] = idx + j + 1;\n            }\n            p[idx + cyclesize - 1] = idx;\n            idx += cyclesize;\n        }\n        // For remaining elements (if n not divisible by cyclesize)\n        for (int i = idx; i <= n; ++i)\n            p[i] = i;\n    } else if (type == \"randomfixed\") {\n        // Random permutation with some fixed points\n        double fixprob = opt<double>(\"fixprob\", 0.1);\n        vector<int> indices;\n        for (int i = 1; i <= n; ++i) {\n            if (rnd.next() < fixprob) {\n                p[i] = i;\n            } else {\n                indices.push_back(i);\n            }\n        }\n        shuffle(indices.begin(), indices.end());\n        int idx = 0;\n        for (int i = 1; i <= n; ++i) {\n            if (p[i] == 0) {\n                p[i] = indices[idx++];\n            }\n        }\n    } else { // random\n        for (int i = 1; i <= n; ++i)\n            p[i] = i;\n        shuffle(p.begin() + 1, p.end());\n    }\n\n    // Compute p_inv\n    vector<int> p_inv(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        p_inv[p[i]] = i;\n    }\n\n    // Compute a and b\n    vector<int> a(n + 1), b(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        int ai = p_inv[p_inv[i]];\n        int bi = p_inv[p_inv[p_inv[i]]];\n        a[i] = ai;\n        b[i] = bi;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output a[1..n]\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", a[i], (i == n) ? '\\n' : ' ');\n    }\n\n    // Output b[1..n]\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", b[i], (i == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n + 1); // 1-based indexing\n\n    if (type == \"identity\") {\n        // p[i] = i\n        for (int i = 1; i <= n; ++i)\n            p[i] = i;\n    } else if (type == \"reverse\") {\n        // p[i] = n - i + 1\n        for (int i = 1; i <= n; ++i)\n            p[i] = n - i + 1;\n    } else if (type == \"bigcycle\") {\n        // Create a single cycle: p[1] = 2, p[2] = 3, ..., p[n-1] = n, p[n] = 1\n        for (int i = 1; i < n; ++i)\n            p[i] = i + 1;\n        p[n] = 1;\n    } else if (type == \"smallcycles\") {\n        // Create cycles of a given size\n        int cyclesize = opt<int>(\"cyclesize\", 2);\n        int idx = 1;\n        while (idx + cyclesize - 1 <= n) {\n            for (int j = 0; j < cyclesize - 1; ++j) {\n                p[idx + j] = idx + j + 1;\n            }\n            p[idx + cyclesize - 1] = idx;\n            idx += cyclesize;\n        }\n        // For remaining elements (if n not divisible by cyclesize)\n        for (int i = idx; i <= n; ++i)\n            p[i] = i;\n    } else if (type == \"randomfixed\") {\n        // Random permutation with some fixed points\n        double fixprob = opt<double>(\"fixprob\", 0.1);\n        vector<int> indices;\n        for (int i = 1; i <= n; ++i) {\n            if (rnd.next() < fixprob) {\n                p[i] = i;\n            } else {\n                indices.push_back(i);\n            }\n        }\n        shuffle(indices.begin(), indices.end());\n        int idx = 0;\n        for (int i = 1; i <= n; ++i) {\n            if (p[i] == 0) {\n                p[i] = indices[idx++];\n            }\n        }\n    } else { // random\n        for (int i = 1; i <= n; ++i)\n            p[i] = i;\n        shuffle(p.begin() + 1, p.end());\n    }\n\n    // Compute p_inv\n    vector<int> p_inv(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        p_inv[p[i]] = i;\n    }\n\n    // Compute a and b\n    vector<int> a(n + 1), b(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        int ai = p_inv[p_inv[i]];\n        int bi = p_inv[p_inv[p_inv[i]]];\n        a[i] = ai;\n        b[i] = bi;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output a[1..n]\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", a[i], (i == n) ? '\\n' : ' ');\n    }\n\n    // Output b[1..n]\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", b[i], (i == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n with identity permutation\n./gen -n 1 -type identity\n./gen -n 2 -type identity\n./gen -n 3 -type identity\n\n# Small n with reverse permutation\n./gen -n 2 -type reverse\n./gen -n 3 -type reverse\n./gen -n 5 -type reverse\n\n# Small n with bigcycle\n./gen -n 3 -type bigcycle\n./gen -n 4 -type bigcycle\n\n# Small n with random permutation\n./gen -n 5 -type random\n./gen -n 10 -type random\n\n# Small n with small cycles, various cycle sizes\n./gen -n 6 -type smallcycles -cyclesize 2\n./gen -n 6 -type smallcycles -cyclesize 3\n./gen -n 7 -type smallcycles -cyclesize 2\n\n# Medium n with random permutation\n./gen -n 100 -type random\n./gen -n 1000 -type random\n\n# Max n with random permutation\n./gen -n 100000 -type random\n\n# Max n with identity permutation\n./gen -n 100000 -type identity\n\n# Max n with reverse permutation\n./gen -n 100000 -type reverse\n\n# Max n with bigcycle\n./gen -n 100000 -type bigcycle\n\n# Max n with small cycles\n./gen -n 100000 -type smallcycles -cyclesize 2\n./gen -n 99999 -type smallcycles -cyclesize 3\n./gen -n 100000 -type smallcycles -cyclesize 5\n./gen -n 100000 -type smallcycles -cyclesize 1000\n./gen -n 100000 -type smallcycles -cyclesize 100000\n\n# Edge cases with prime n\n./gen -n 99991 -type random\n\n# Random permutations with n just under 1e5\n./gen -n 99999 -type random\n\n# Random permutations with some elements fixed at p[i]=i\n./gen -n 100000 -type randomfixed -fixprob 0.1\n./gen -n 100000 -type randomfixed -fixprob 0.5\n./gen -n 100000 -type randomfixed -fixprob 0.9\n\n# Small n with randomfixed\n./gen -n 10 -type randomfixed -fixprob 0.5\n./gen -n 20 -type randomfixed -fixprob 0.2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:42.230875",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "181/A",
      "title": "A. Series of Crimes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (2 ≤ n, m ≤ 100) — the number of rows and columns in the table, correspondingly.Each of the next n lines contains m characters — the description of the capital's map. Each character can either be a \".\" (dot), or an \"*\" (asterisk). A character equals \"*\" if the corresponding district has been robbed. Otherwise, it equals \".\".It is guaranteed that the map has exactly three characters \"*\" and we can always find the fourth district that meets the problem requirements.",
      "output_spec": "OutputPrint two integers — the number of the row and the number of the column of the city district that is the fourth one to be robbed. The rows are numbered starting from one from top to bottom and the columns are numbered starting from one from left to right.",
      "sample_tests": "ExamplesInputCopy3 2.*..**OutputCopy1 1InputCopy3 3*.**.....OutputCopy2 3",
      "description": "A. Series of Crimes\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (2 ≤ n, m ≤ 100) — the number of rows and columns in the table, correspondingly.Each of the next n lines contains m characters — the description of the capital's map. Each character can either be a \".\" (dot), or an \"*\" (asterisk). A character equals \"*\" if the corresponding district has been robbed. Otherwise, it equals \".\".It is guaranteed that the map has exactly three characters \"*\" and we can always find the fourth district that meets the problem requirements.\n\nOutputPrint two integers — the number of the row and the number of the column of the city district that is the fourth one to be robbed. The rows are numbered starting from one from top to bottom and the columns are numbered starting from one from left to right.\n\nInputCopy3 2.*..**OutputCopy1 1InputCopy3 3*.**.....OutputCopy2 3\n\nInputCopy3 2.*..**\n\nOutputCopy1 1\n\nInputCopy3 3*.**.....\n\nOutputCopy2 3",
      "solutions": [
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces",
          "content": "Hello everyone!Today is the second round of the Open Moscow Programming Championship By CROC will be. Start is planned at 19:00.Competition will happen by usual rules of Codeforces, with hacks and score falling in process of time. All contestants who passed score no less than contectant of the 300-th place in the Round 1, can participate in the Round 2. Every other contestants can patricipate the Round 2 out of competition. Specially for contestants of the second division we prepared more easy unofficial problemset. The official problemset and the unnoficial one have some common tasks.Round will be rated for all participants.Some number of problems are waiting you. They are roughly ordered by the increasing complexity. Score distribution is standard for both divisions (500-1000-1500-2000-2500). Don't forget that during contest your solutions will be tested on a small set of pretests. Testing on full testset will be after end of the round. Pretests can don't cover all cases of input data, so you should test your solutions very carefully.It is strictly forbidden to publish statements/solutions of the problems before round will be end. Also you shouldn't to talk about problems, discuss some things about possible solutions of them. Let's be honest! You can discuss problems after the end of round.Top 50 contestant will be allowed to the Final Round. Also all contestant with score not less than score of the 50-th contestant will be passed.The round was prepared by Ripatti, havaliza, Gerald, RAD, MikeMirzayanov, Delinur.Good luck for all!UPD. We remind that the final of the Open Championship of Moscow and Moscow Region Programming (CROC) take place on April 27 in the office of the CROC. Note that CROC does not pay for the road and residence of the finalists. All participants must arrive at the final in the office of the CROC (Moscow) in the morning on April 27.After the competition all participants will be provided to fill the form on the ability to participate in the finals of the competition. The first 50 participants on the results of the competition, which will confirm their participation in the finals, will be invited to final competition. You can confirm participation in the finals during the day after the end of Round 2.It is recommended to fill the form, regardless of your results in Round 2, as large number of participants can reject the participation in the final.",
          "author": "Ripatti",
          "url": "https://codeforces.com/blog/entry/4370",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2409
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces",
          "content": "A div2. Required row is row that have only one star inside. Requred column is comumn that also have only one star inside. So, you can iterate over all rows/columns, calculate number of stars inside them and find the answer.Authors are MikeMirzayanov, Gerald .B div2. Naive solution O(n3) (where you check all triplets) doesn't fin into time limits.You can see that for every two points from triplet (for example, for A and C) you can find place of the third point. So you can find number of requred triplets just inerate over all pairs of points and check middle point between points in every pair.How to fast check position? You can add 1000 for all coordinates (you can see that this operation doesn't change the answer) and mark them in the 2-dimensional boolean array 2001х2001. So you can check every position for point in O(1) time.Obtained solution works in O(n2).Authors are MikeMirzayanov, GeraldA div1. C div2. In this problem some greedy solution expected.Let fix 2 planets: in planet i we will buy items, in planet j we will sell the ones. Profit of item of type k will be b_jk-a_ik. Every item has size 1, so you should greedy take items in order of decreasing of profits of items while you have place in the hold.Scheme of full solution: you should iterate over all pairs of planet, for every pair greedy take items and find total profit. At the end you should find maximal total profit over all pairs and output it.Author is RipattiB div1. D div2. You can see that split oparetion is just cyclically shift of string. You can go from any cyclically shift to any other one except the current one.Let's call some cyclically shift good iff it equal to the final string. All others cyclically shifts we will call bad. You can check all shifts in O(|w|2) time. Let's you have A good shifts and B bad ones.Let's define dpA[n] as number of ways to get some good shift using n splits and за dpB[n] as number of ways to get some bad shift using n splits.dpA[0]=1, dpB[0]=0 or dpA[0]=0, dpB[0]=1 according to the first shift is good or not. All other values of dp you can get using following reccurences:dpA[n] = dpA[n-1] * (A-1) + dpB[n-1] * AdpB[n] = dpA[n-1] * B + dpB[n-1] * (B-1)Answer will be dpA[k]. So you have O(|w|2 + k) solution.Also this problem can be solved in time.Author is havalizaC div1. E div2. The second player have easy strategy to hold some chip in position (X, Y) in one of four half-planes — x ≤ X + 2, x ≥ X - 2, y ≤ Y + 2 и y ≥ Y - 2. He can chose one of these half-planes by himself.So, in case max(|x1 - x2|, |y1 - y2|) > 4 the second player wins — he just holds chips in half-planes that have no common cells.Cases for max(|x1 - x2|, |y1 - y2|) ≤ 4 expected to solve using some bruteforce. You can see that moving chips in way of distancing from each other is not profitable for the first player. Therefore you can bruteforce the game in square no more than 5 × 5. If your bruteforce so slow and doesn't fit into 2 sec, you can use precalculation. Also you can write some dp using masks.Also you can check cases max(|x1 - x2|, |y1 - y2|) ≤ 4 by hand. But there you can easy make some mistakes.Author is RipattiD div1. Let's define dp[pre][len] as the minimal prefix of hyperstring that have with prefix of t of length len largest common sequence of length len.Then you have see reccurences:dp[pre][len] = min(dp[pre - 1][len],  leftmost position of letter s[pre] in t that right than dp[pre - 1][len - 1]).For finding value of the second part inside min-function of formula above in O(1), you should calculate some additional dp's: dp1 — for every basic string, positions inside of them and letter you should calculate leftmost position of current letter that right than current position;dp2 — for every element of array of basic strings (it is hyperstring) and letter you should calculate leftmost basic string that have current letter and this string is rinht than current basic string.So you have solution.Author is havaliza.E div1. At the first let's try to solve another problem: we have k chosed vertices in the tree and we want to find sum of subtree that \"spanned\" dy them in time (with any preprocessing time).Let's sort all k vertices in order of dfs traversal — v1, v2, ... , vk. Consider pathes v1-v2, v2-v3, ... , v(k-1)-vk and vk-v1. You can see that they cover only our requred subtree and every edge is covered exactly two times. So you can just find sum of lengths of these pathes (you can do it in required time using LCA algo) and divide obtained value by 2.For solving initial problem you should support set of active vertices in ordered state (for example, you can use std::set) and sum of all pathes between all neighbour vertices. Now you can process insert/remove queries in , and recalculate sum of pathes by finding no more than 3 new pathes also in .So you have solution.Author is Ripatti.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4372",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4850
        }
      ],
      "code_examples": [
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 1",
          "code": "x...\n....\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 2",
          "code": "x...\n....\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 3",
          "code": "x...\n.!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 4",
          "code": "x...\n.!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 5",
          "code": "x...\n.!..\n....\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 6",
          "code": "x...\n.!..\n....\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 7",
          "code": "x...\n.!..\n.!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 8",
          "code": "x...\n.!..\n.!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 9",
          "code": "....\nx!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 10",
          "code": "....\nx!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 11",
          "code": "....\nx!..\n!...\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 12",
          "code": "....\nx!..\n!...\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 13",
          "code": "....\nx!..\n!...\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 14",
          "code": "....\nx!..\n!...\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 15",
          "code": "....\nx!..\n!!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 16",
          "code": "....\nx!..\n!!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces - Code 1",
          "code": "dpA[n] = dpA[n-1]*(A-1) + dpB[n-1]*A\ndpB[n] = dpA[n-1]*B + dpB[n-1](B-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4372",
          "author": "Qingyu"
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces - Code 2",
          "code": "dpA[n] = dpA[n-1]*(A-1) + dpB[n-1]*A\ndpB[n] = dpA[n-1]*B + dpB[n-1](B-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4372",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100, \"m\");\n    inf.readEoln();\n\n    int cntStars = 0;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.size()) == m, \"Line %d length is not equal to m=%d\", i + 1, m);\n        for (int j = 0; j < m; j++) {\n            char c = s[j];\n            ensuref(c == '.' || c == '*', \"Invalid character '%c' at row %d, column %d\", c, i + 1, j + 1);\n            if (c == '*') {\n                cntStars++;\n            }\n        }\n    }\n\n    ensuref(cntStars == 3, \"The number of '*' in the map must be exactly 3, but found %d\", cntStars);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100, \"m\");\n    inf.readEoln();\n\n    int cntStars = 0;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.size()) == m, \"Line %d length is not equal to m=%d\", i + 1, m);\n        for (int j = 0; j < m; j++) {\n            char c = s[j];\n            ensuref(c == '.' || c == '*', \"Invalid character '%c' at row %d, column %d\", c, i + 1, j + 1);\n            if (c == '*') {\n                cntStars++;\n            }\n        }\n    }\n\n    ensuref(cntStars == 3, \"The number of '*' in the map must be exactly 3, but found %d\", cntStars);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100, \"m\");\n    inf.readEoln();\n\n    int cntStars = 0;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.size()) == m, \"Line %d length is not equal to m=%d\", i + 1, m);\n        for (int j = 0; j < m; j++) {\n            char c = s[j];\n            ensuref(c == '.' || c == '*', \"Invalid character '%c' at row %d, column %d\", c, i + 1, j + 1);\n            if (c == '*') {\n                cntStars++;\n            }\n        }\n    }\n\n    ensuref(cntStars == 3, \"The number of '*' in the map must be exactly 3, but found %d\", cntStars);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    int r1, r2, c1, c2;\n    \n    if (type == \"random\") {\n        // Select two distinct rows and two distinct columns randomly\n        do {\n            r1 = rnd.next(1, n);\n            r2 = rnd.next(1, n);\n        } while (r1 == r2);\n        if (r2 < r1) swap(r1, r2);\n\n        do {\n            c1 = rnd.next(1, m);\n            c2 = rnd.next(1, m);\n        } while (c1 == c2);\n        if (c2 < c1) swap(c1, c2);\n\n    } else if (type == \"corners\") {\n        // Use the first and last rows and columns\n        r1 = 1; r2 = n;\n        c1 = 1; c2 = m;\n    } else if (type == \"edges\") {\n        // Use first and last rows and columns\n        r1 = 1; r2 = n;\n        c1 = 1; c2 = m;\n    } else if (type == \"middle\") {\n        // Use middle rows and columns\n        if (n < 3 || m < 3) {\n            r1 = 1; r2 = n;\n            c1 = 1; c2 = m;\n        } else {\n            r1 = n / 2;\n            r2 = r1 + 1;\n            c1 = m / 2;\n            c2 = c1 + 1;\n        }\n    } else if (type == \"adjacent_rows\") {\n        // r2 = r1 + 1\n        r1 = rnd.next(1, n - 1);\n        r2 = r1 + 1;\n        do {\n            c1 = rnd.next(1, m);\n            c2 = rnd.next(1, m);\n        } while (c1 == c2);\n        if (c2 < c1) swap(c1, c2);\n    } else if (type == \"adjacent_columns\") {\n        // c2 = c1 + 1\n        c1 = rnd.next(1, m - 1);\n        c2 = c1 + 1;\n        do {\n            r1 = rnd.next(1, n);\n            r2 = rnd.next(1, n);\n        } while (r1 == r2);\n        if (r2 < r1) swap(r1, r2);\n    } else if (type == \"far_rows\") {\n        // r1 and r2 at far ends\n        r1 = 1;\n        r2 = n;\n        do {\n            c1 = rnd.next(1, m);\n            c2 = rnd.next(1, m);\n        } while (c1 == c2);\n        if (c2 < c1) swap(c1, c2);\n    } else if (type == \"far_columns\") {\n        c1 = 1;\n        c2 = m;\n        do {\n            r1 = rnd.next(1, n);\n            r2 = rnd.next(1, n);\n        } while (r1 == r2);\n        if (r2 < r1) swap(r1, r2);\n    } else if (type == \"confusion\") {\n        // Special test case to catch confusion between rows and columns\n        // Set r1 = c1, r2 = c2\n        if (min(n, m) < 2) {\n            r1 = 1; c1 = 1;\n            r2 = 2; c2 = 2;\n        } else {\n            r1 = rnd.next(1, min(n, m) - 1);\n            c1 = r1;\n            r2 = r1 + 1;\n            c2 = c1 + 1;\n        }\n    } else {\n        // Default to random\n        do {\n            r1 = rnd.next(1, n);\n            r2 = rnd.next(1, n);\n        } while (r1 == r2);\n        if (r2 < r1) swap(r1, r2);\n\n        do {\n            c1 = rnd.next(1, m);\n            c2 = rnd.next(1, m);\n        } while (c1 == c2);\n        if (c2 < c1) swap(c1, c2);\n    }\n\n    // Now, r1 != r2 and c1 != c2, and we have four points:\n    // (r1,c1), (r1,c2), (r2,c1), (r2,c2)\n\n    // We need to select 3 of these to be '*' and one will be omitted.\n\n    vector<pair<int, int>> positions = {{r1, c1}, {r1, c2}, {r2, c1}, {r2, c2}};\n    // Shuffle the positions\n    shuffle(positions.begin(), positions.end());\n    // Mark three positions with '*'\n    for (int i = 0; i < 3; ++i) {\n        int r = positions[i].first - 1;\n        int c = positions[i].second - 1;\n        grid[r][c] = '*';\n    }\n    // Omit the fourth position; that is the missing one.\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    int r1, r2, c1, c2;\n    \n    if (type == \"random\") {\n        // Select two distinct rows and two distinct columns randomly\n        do {\n            r1 = rnd.next(1, n);\n            r2 = rnd.next(1, n);\n        } while (r1 == r2);\n        if (r2 < r1) swap(r1, r2);\n\n        do {\n            c1 = rnd.next(1, m);\n            c2 = rnd.next(1, m);\n        } while (c1 == c2);\n        if (c2 < c1) swap(c1, c2);\n\n    } else if (type == \"corners\") {\n        // Use the first and last rows and columns\n        r1 = 1; r2 = n;\n        c1 = 1; c2 = m;\n    } else if (type == \"edges\") {\n        // Use first and last rows and columns\n        r1 = 1; r2 = n;\n        c1 = 1; c2 = m;\n    } else if (type == \"middle\") {\n        // Use middle rows and columns\n        if (n < 3 || m < 3) {\n            r1 = 1; r2 = n;\n            c1 = 1; c2 = m;\n        } else {\n            r1 = n / 2;\n            r2 = r1 + 1;\n            c1 = m / 2;\n            c2 = c1 + 1;\n        }\n    } else if (type == \"adjacent_rows\") {\n        // r2 = r1 + 1\n        r1 = rnd.next(1, n - 1);\n        r2 = r1 + 1;\n        do {\n            c1 = rnd.next(1, m);\n            c2 = rnd.next(1, m);\n        } while (c1 == c2);\n        if (c2 < c1) swap(c1, c2);\n    } else if (type == \"adjacent_columns\") {\n        // c2 = c1 + 1\n        c1 = rnd.next(1, m - 1);\n        c2 = c1 + 1;\n        do {\n            r1 = rnd.next(1, n);\n            r2 = rnd.next(1, n);\n        } while (r1 == r2);\n        if (r2 < r1) swap(r1, r2);\n    } else if (type == \"far_rows\") {\n        // r1 and r2 at far ends\n        r1 = 1;\n        r2 = n;\n        do {\n            c1 = rnd.next(1, m);\n            c2 = rnd.next(1, m);\n        } while (c1 == c2);\n        if (c2 < c1) swap(c1, c2);\n    } else if (type == \"far_columns\") {\n        c1 = 1;\n        c2 = m;\n        do {\n            r1 = rnd.next(1, n);\n            r2 = rnd.next(1, n);\n        } while (r1 == r2);\n        if (r2 < r1) swap(r1, r2);\n    } else if (type == \"confusion\") {\n        // Special test case to catch confusion between rows and columns\n        // Set r1 = c1, r2 = c2\n        if (min(n, m) < 2) {\n            r1 = 1; c1 = 1;\n            r2 = 2; c2 = 2;\n        } else {\n            r1 = rnd.next(1, min(n, m) - 1);\n            c1 = r1;\n            r2 = r1 + 1;\n            c2 = c1 + 1;\n        }\n    } else {\n        // Default to random\n        do {\n            r1 = rnd.next(1, n);\n            r2 = rnd.next(1, n);\n        } while (r1 == r2);\n        if (r2 < r1) swap(r1, r2);\n\n        do {\n            c1 = rnd.next(1, m);\n            c2 = rnd.next(1, m);\n        } while (c1 == c2);\n        if (c2 < c1) swap(c1, c2);\n    }\n\n    // Now, r1 != r2 and c1 != c2, and we have four points:\n    // (r1,c1), (r1,c2), (r2,c1), (r2,c2)\n\n    // We need to select 3 of these to be '*' and one will be omitted.\n\n    vector<pair<int, int>> positions = {{r1, c1}, {r1, c2}, {r2, c1}, {r2, c2}};\n    // Shuffle the positions\n    shuffle(positions.begin(), positions.end());\n    // Mark three positions with '*'\n    for (int i = 0; i < 3; ++i) {\n        int r = positions[i].first - 1;\n        int c = positions[i].second - 1;\n        grid[r][c] = '*';\n    }\n    // Omit the fourth position; that is the missing one.\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases\n./gen -n 2 -m 2 -type random\n./gen -n 2 -m 100 -type random\n./gen -n 100 -m 2 -type random\n./gen -n 50 -m 50 -type random\n./gen -n 100 -m 100 -type random\n\n# Corners\n./gen -n 10 -m 10 -type corners\n./gen -n 100 -m 100 -type corners\n\n# Edges\n./gen -n 10 -m 20 -type edges\n./gen -n 20 -m 10 -type edges\n\n# Middle\n./gen -n 5 -m 5 -type middle\n./gen -n 11 -m 11 -type middle\n./gen -n 50 -m 50 -type middle\n\n# Adjacent Rows\n./gen -n 5 -m 5 -type adjacent_rows\n./gen -n 10 -m 20 -type adjacent_rows\n./gen -n 50 -m 50 -type adjacent_rows\n\n# Adjacent Columns\n./gen -n 5 -m 5 -type adjacent_columns\n./gen -n 20 -m 10 -type adjacent_columns\n./gen -n 50 -m 50 -type adjacent_columns\n\n# Far Rows\n./gen -n 100 -m 50 -type far_rows\n./gen -n 50 -m 100 -type far_rows\n\n# Far Columns\n./gen -n 50 -m 100 -type far_columns\n./gen -n 100 -m 50 -type far_columns\n\n# Edge cases (small sizes)\n./gen -n 2 -m 2 -type random\n./gen -n 2 -m 3 -type random\n./gen -n 3 -m 2 -type random\n\n# Edge case (minimum size with corners)\n./gen -n 2 -m 2 -type corners\n\n# Edge case (maximum size)\n./gen -n 100 -m 100 -type random\n\n# Confusion test cases\n./gen -n 10 -m 10 -type confusion\n./gen -n 20 -m 20 -type confusion\n./gen -n 100 -m 100 -type confusion\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:43.826385",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "181/B",
      "title": "B. Number of Triplets",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (3 ≤ n ≤ 3000) — the number of points. Next n lines contain the points. The i-th line contains coordinates of the i-th point: two space-separated integers xi, yi ( - 1000 ≤ xi, yi ≤ 1000).It is guaranteed that all given points are different.",
      "output_spec": "OutputPrint the single number — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy31 12 23 3OutputCopy1InputCopy30 0-1 00 1OutputCopy0",
      "description": "B. Number of Triplets\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (3 ≤ n ≤ 3000) — the number of points. Next n lines contain the points. The i-th line contains coordinates of the i-th point: two space-separated integers xi, yi ( - 1000 ≤ xi, yi ≤ 1000).It is guaranteed that all given points are different.\n\nOutputPrint the single number — the answer to the problem.\n\nInputCopy31 12 23 3OutputCopy1InputCopy30 0-1 00 1OutputCopy0\n\nInputCopy31 12 23 3\n\nOutputCopy1\n\nInputCopy30 0-1 00 1\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces",
          "content": "Hello everyone!Today is the second round of the Open Moscow Programming Championship By CROC will be. Start is planned at 19:00.Competition will happen by usual rules of Codeforces, with hacks and score falling in process of time. All contestants who passed score no less than contectant of the 300-th place in the Round 1, can participate in the Round 2. Every other contestants can patricipate the Round 2 out of competition. Specially for contestants of the second division we prepared more easy unofficial problemset. The official problemset and the unnoficial one have some common tasks.Round will be rated for all participants.Some number of problems are waiting you. They are roughly ordered by the increasing complexity. Score distribution is standard for both divisions (500-1000-1500-2000-2500). Don't forget that during contest your solutions will be tested on a small set of pretests. Testing on full testset will be after end of the round. Pretests can don't cover all cases of input data, so you should test your solutions very carefully.It is strictly forbidden to publish statements/solutions of the problems before round will be end. Also you shouldn't to talk about problems, discuss some things about possible solutions of them. Let's be honest! You can discuss problems after the end of round.Top 50 contestant will be allowed to the Final Round. Also all contestant with score not less than score of the 50-th contestant will be passed.The round was prepared by Ripatti, havaliza, Gerald, RAD, MikeMirzayanov, Delinur.Good luck for all!UPD. We remind that the final of the Open Championship of Moscow and Moscow Region Programming (CROC) take place on April 27 in the office of the CROC. Note that CROC does not pay for the road and residence of the finalists. All participants must arrive at the final in the office of the CROC (Moscow) in the morning on April 27.After the competition all participants will be provided to fill the form on the ability to participate in the finals of the competition. The first 50 participants on the results of the competition, which will confirm their participation in the finals, will be invited to final competition. You can confirm participation in the finals during the day after the end of Round 2.It is recommended to fill the form, regardless of your results in Round 2, as large number of participants can reject the participation in the final.",
          "author": "Ripatti",
          "url": "https://codeforces.com/blog/entry/4370",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2409
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces",
          "content": "A div2. Required row is row that have only one star inside. Requred column is comumn that also have only one star inside. So, you can iterate over all rows/columns, calculate number of stars inside them and find the answer.Authors are MikeMirzayanov, Gerald .B div2. Naive solution O(n3) (where you check all triplets) doesn't fin into time limits.You can see that for every two points from triplet (for example, for A and C) you can find place of the third point. So you can find number of requred triplets just inerate over all pairs of points and check middle point between points in every pair.How to fast check position? You can add 1000 for all coordinates (you can see that this operation doesn't change the answer) and mark them in the 2-dimensional boolean array 2001х2001. So you can check every position for point in O(1) time.Obtained solution works in O(n2).Authors are MikeMirzayanov, GeraldA div1. C div2. In this problem some greedy solution expected.Let fix 2 planets: in planet i we will buy items, in planet j we will sell the ones. Profit of item of type k will be b_jk-a_ik. Every item has size 1, so you should greedy take items in order of decreasing of profits of items while you have place in the hold.Scheme of full solution: you should iterate over all pairs of planet, for every pair greedy take items and find total profit. At the end you should find maximal total profit over all pairs and output it.Author is RipattiB div1. D div2. You can see that split oparetion is just cyclically shift of string. You can go from any cyclically shift to any other one except the current one.Let's call some cyclically shift good iff it equal to the final string. All others cyclically shifts we will call bad. You can check all shifts in O(|w|2) time. Let's you have A good shifts and B bad ones.Let's define dpA[n] as number of ways to get some good shift using n splits and за dpB[n] as number of ways to get some bad shift using n splits.dpA[0]=1, dpB[0]=0 or dpA[0]=0, dpB[0]=1 according to the first shift is good or not. All other values of dp you can get using following reccurences:dpA[n] = dpA[n-1] * (A-1) + dpB[n-1] * AdpB[n] = dpA[n-1] * B + dpB[n-1] * (B-1)Answer will be dpA[k]. So you have O(|w|2 + k) solution.Also this problem can be solved in time.Author is havalizaC div1. E div2. The second player have easy strategy to hold some chip in position (X, Y) in one of four half-planes — x ≤ X + 2, x ≥ X - 2, y ≤ Y + 2 и y ≥ Y - 2. He can chose one of these half-planes by himself.So, in case max(|x1 - x2|, |y1 - y2|) > 4 the second player wins — he just holds chips in half-planes that have no common cells.Cases for max(|x1 - x2|, |y1 - y2|) ≤ 4 expected to solve using some bruteforce. You can see that moving chips in way of distancing from each other is not profitable for the first player. Therefore you can bruteforce the game in square no more than 5 × 5. If your bruteforce so slow and doesn't fit into 2 sec, you can use precalculation. Also you can write some dp using masks.Also you can check cases max(|x1 - x2|, |y1 - y2|) ≤ 4 by hand. But there you can easy make some mistakes.Author is RipattiD div1. Let's define dp[pre][len] as the minimal prefix of hyperstring that have with prefix of t of length len largest common sequence of length len.Then you have see reccurences:dp[pre][len] = min(dp[pre - 1][len],  leftmost position of letter s[pre] in t that right than dp[pre - 1][len - 1]).For finding value of the second part inside min-function of formula above in O(1), you should calculate some additional dp's: dp1 — for every basic string, positions inside of them and letter you should calculate leftmost position of current letter that right than current position;dp2 — for every element of array of basic strings (it is hyperstring) and letter you should calculate leftmost basic string that have current letter and this string is rinht than current basic string.So you have solution.Author is havaliza.E div1. At the first let's try to solve another problem: we have k chosed vertices in the tree and we want to find sum of subtree that \"spanned\" dy them in time (with any preprocessing time).Let's sort all k vertices in order of dfs traversal — v1, v2, ... , vk. Consider pathes v1-v2, v2-v3, ... , v(k-1)-vk and vk-v1. You can see that they cover only our requred subtree and every edge is covered exactly two times. So you can just find sum of lengths of these pathes (you can do it in required time using LCA algo) and divide obtained value by 2.For solving initial problem you should support set of active vertices in ordered state (for example, you can use std::set) and sum of all pathes between all neighbour vertices. Now you can process insert/remove queries in , and recalculate sum of pathes by finding no more than 3 new pathes also in .So you have solution.Author is Ripatti.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4372",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4850
        }
      ],
      "code_examples": [
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 1",
          "code": "x...\n....\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 2",
          "code": "x...\n....\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 3",
          "code": "x...\n.!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 4",
          "code": "x...\n.!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 5",
          "code": "x...\n.!..\n....\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 6",
          "code": "x...\n.!..\n....\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 7",
          "code": "x...\n.!..\n.!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 8",
          "code": "x...\n.!..\n.!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 9",
          "code": "....\nx!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 10",
          "code": "....\nx!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 11",
          "code": "....\nx!..\n!...\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 12",
          "code": "....\nx!..\n!...\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 13",
          "code": "....\nx!..\n!...\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 14",
          "code": "....\nx!..\n!...\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 15",
          "code": "....\nx!..\n!!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 16",
          "code": "....\nx!..\n!!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces - Code 1",
          "code": "dpA[n] = dpA[n-1]*(A-1) + dpB[n-1]*A\ndpB[n] = dpA[n-1]*B + dpB[n-1](B-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4372",
          "author": "jiangly"
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces - Code 2",
          "code": "dpA[n] = dpA[n-1]*(A-1) + dpB[n-1]*A\ndpB[n] = dpA[n-1]*B + dpB[n-1](B-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4372",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 3000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-1000, 1000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000, 1000, \"yi\");\n        inf.readEoln();\n\n        pair<int, int> p = make_pair(xi, yi);\n        // Ensure that the point (xi, yi) is not already in points\n        ensuref(points.find(p) == points.end(), \"All points must be different, point (%d, %d) is repeated at line %d\", xi, yi, i + 2);\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 3000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-1000, 1000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000, 1000, \"yi\");\n        inf.readEoln();\n\n        pair<int, int> p = make_pair(xi, yi);\n        // Ensure that the point (xi, yi) is not already in points\n        ensuref(points.find(p) == points.end(), \"All points must be different, point (%d, %d) is repeated at line %d\", xi, yi, i + 2);\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 3000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-1000, 1000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-1000, 1000, \"yi\");\n        inf.readEoln();\n\n        pair<int, int> p = make_pair(xi, yi);\n        // Ensure that the point (xi, yi) is not already in points\n        ensuref(points.find(p) == points.end(), \"All points must be different, point (%d, %d) is repeated at line %d\", xi, yi, i + 2);\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is within the problem constraints\n    assert(3 <= n && n <= 3000);\n\n    vector< pair<int,int> > points;\n\n    if (type == \"random\") {\n        // Generate n unique random points within [-1000, 1000]\n        set< pair<int,int> > point_set;\n        while ((int) point_set.size() < n) {\n            int x = rnd.next(-1000, 1000);\n            int y = rnd.next(-1000, 1000);\n            point_set.insert(make_pair(x, y));\n        }\n        for (auto p : point_set) {\n            points.push_back(p);\n        }\n    } else if (type == \"line\") {\n        // Generate n points on a line y = 0\n        int x_start = -1000;\n        int x_end = 1000;\n        int x_range = x_end - x_start + 1;\n        int x_step = max(1, x_range / n);\n        for (int i = 0; i < n; ++i) {\n            int x = x_start + (i * x_step) % x_range;\n            if (x > x_end) x = x_end;\n            int y = 0;\n            points.push_back(make_pair(x, y));\n        }\n    } else if (type == \"grid\") {\n        // Generate points in a grid\n        int x_count = ceil(sqrt(n));\n        int y_count = (n + x_count - 1) / x_count;\n        double dx = (x_count <= 1) ? 0 : 2000.0 / (x_count - 1);\n        double dy = (y_count <= 1) ? 0 : 2000.0 / (y_count - 1);\n        int total_points = 0;\n        for (int xi = 0; xi < x_count && total_points < n; ++xi) {\n            int x = -1000 + round(xi * dx);\n            for (int yi = 0; yi < y_count && total_points < n; ++yi) {\n                int y = -1000 + round(yi * dy);\n                points.push_back(make_pair(x, y));\n                total_points++;\n            }\n        }\n    } else if (type == \"no_midpoints\") {\n        // Generate points such that there are no midpoints matching any point in the set\n        set< pair<int,int> > point_set;\n        while ((int) point_set.size() < n) {\n            int x = rnd.next(-1000, 1000);\n            int y = rnd.next(-1000, 1000);\n            if ((x + y) % 2 == 0) continue; // Skip points where x + y is even\n            point_set.insert(make_pair(x, y));\n        }\n        for (auto p : point_set) {\n            points.push_back(p);\n        }\n    } else {\n        // Default to random if type is unrecognized\n        set< pair<int,int> > point_set;\n        while ((int) point_set.size() < n) {\n            int x = rnd.next(-1000, 1000);\n            int y = rnd.next(-1000, 1000);\n            point_set.insert(make_pair(x, y));\n        }\n        for (auto p : point_set) {\n            points.push_back(p);\n        }\n    }\n\n    // Shuffle the points before outputting\n    shuffle(points.begin(), points.end());\n\n    // Output the number of points\n    printf(\"%d\\n\", n);\n    // Output each point\n    for (auto p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is within the problem constraints\n    assert(3 <= n && n <= 3000);\n\n    vector< pair<int,int> > points;\n\n    if (type == \"random\") {\n        // Generate n unique random points within [-1000, 1000]\n        set< pair<int,int> > point_set;\n        while ((int) point_set.size() < n) {\n            int x = rnd.next(-1000, 1000);\n            int y = rnd.next(-1000, 1000);\n            point_set.insert(make_pair(x, y));\n        }\n        for (auto p : point_set) {\n            points.push_back(p);\n        }\n    } else if (type == \"line\") {\n        // Generate n points on a line y = 0\n        int x_start = -1000;\n        int x_end = 1000;\n        int x_range = x_end - x_start + 1;\n        int x_step = max(1, x_range / n);\n        for (int i = 0; i < n; ++i) {\n            int x = x_start + (i * x_step) % x_range;\n            if (x > x_end) x = x_end;\n            int y = 0;\n            points.push_back(make_pair(x, y));\n        }\n    } else if (type == \"grid\") {\n        // Generate points in a grid\n        int x_count = ceil(sqrt(n));\n        int y_count = (n + x_count - 1) / x_count;\n        double dx = (x_count <= 1) ? 0 : 2000.0 / (x_count - 1);\n        double dy = (y_count <= 1) ? 0 : 2000.0 / (y_count - 1);\n        int total_points = 0;\n        for (int xi = 0; xi < x_count && total_points < n; ++xi) {\n            int x = -1000 + round(xi * dx);\n            for (int yi = 0; yi < y_count && total_points < n; ++yi) {\n                int y = -1000 + round(yi * dy);\n                points.push_back(make_pair(x, y));\n                total_points++;\n            }\n        }\n    } else if (type == \"no_midpoints\") {\n        // Generate points such that there are no midpoints matching any point in the set\n        set< pair<int,int> > point_set;\n        while ((int) point_set.size() < n) {\n            int x = rnd.next(-1000, 1000);\n            int y = rnd.next(-1000, 1000);\n            if ((x + y) % 2 == 0) continue; // Skip points where x + y is even\n            point_set.insert(make_pair(x, y));\n        }\n        for (auto p : point_set) {\n            points.push_back(p);\n        }\n    } else {\n        // Default to random if type is unrecognized\n        set< pair<int,int> > point_set;\n        while ((int) point_set.size() < n) {\n            int x = rnd.next(-1000, 1000);\n            int y = rnd.next(-1000, 1000);\n            point_set.insert(make_pair(x, y));\n        }\n        for (auto p : point_set) {\n            points.push_back(p);\n        }\n    }\n\n    // Shuffle the points before outputting\n    shuffle(points.begin(), points.end());\n\n    // Output the number of points\n    printf(\"%d\\n\", n);\n    // Output each point\n    for (auto p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type random\n./gen -n 3 -type line\n./gen -n 3 -type grid\n./gen -n 3 -type no_midpoints\n\n./gen -n 10 -type random\n./gen -n 10 -type line\n./gen -n 10 -type grid\n./gen -n 10 -type no_midpoints\n\n./gen -n 100 -type random\n./gen -n 100 -type line\n./gen -n 100 -type grid\n./gen -n 100 -type no_midpoints\n\n./gen -n 500 -type random\n./gen -n 500 -type line\n./gen -n 500 -type grid\n./gen -n 500 -type no_midpoints\n\n./gen -n 1000 -type random\n./gen -n 1000 -type line\n./gen -n 1000 -type grid\n./gen -n 1000 -type no_midpoints\n\n./gen -n 1500 -type random\n./gen -n 1500 -type line\n./gen -n 1500 -type grid\n./gen -n 1500 -type no_midpoints\n\n./gen -n 2000 -type random\n./gen -n 2000 -type line\n./gen -n 2000 -type grid\n./gen -n 2000 -type no_midpoints\n\n./gen -n 2500 -type random\n./gen -n 2500 -type line\n./gen -n 2500 -type grid\n./gen -n 2500 -type no_midpoints\n\n./gen -n 3000 -type random\n./gen -n 3000 -type line\n./gen -n 3000 -type grid\n./gen -n 3000 -type no_midpoints\n\n./gen -n 2999 -type random\n./gen -n 2999 -type line\n./gen -n 2999 -type grid\n./gen -n 2999 -type no_midpoints\n\n./gen -n 2998 -type random\n./gen -n 2998 -type line\n./gen -n 2998 -type grid\n./gen -n 2998 -type no_midpoints\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:45.654252",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "181/C",
      "title": "C. Trading Business",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers n, m and k (2 ≤ n ≤ 10, 1 ≤ m, k ≤ 100) — the number of planets, the number of question types and the capacity of Qwerty's ship hold, correspondingly.Then follow n blocks describing each planet.The first line of the i-th block has the planet's name as a string with length from 1 to 10 Latin letters. The first letter of the name is uppercase, the rest are lowercase. Then in the i-th block follow m lines, the j-th of them contains three integers aij, bij and cij (1 ≤ bij < aij ≤ 1000, 0 ≤ cij ≤ 100) — the numbers that describe money operations with the j-th item on the i-th planet. The numbers in the lines are separated by spaces.It is guaranteed that the names of all planets are different.",
      "output_spec": "OutputPrint a single number — the maximum profit Qwerty can get.",
      "sample_tests": "ExamplesInputCopy3 3 10Venus6 5 37 6 58 6 10Earth10 9 08 6 410 9 3Mars4 3 08 4 127 2 5OutputCopy16",
      "description": "C. Trading Business\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers n, m and k (2 ≤ n ≤ 10, 1 ≤ m, k ≤ 100) — the number of planets, the number of question types and the capacity of Qwerty's ship hold, correspondingly.Then follow n blocks describing each planet.The first line of the i-th block has the planet's name as a string with length from 1 to 10 Latin letters. The first letter of the name is uppercase, the rest are lowercase. Then in the i-th block follow m lines, the j-th of them contains three integers aij, bij and cij (1 ≤ bij < aij ≤ 1000, 0 ≤ cij ≤ 100) — the numbers that describe money operations with the j-th item on the i-th planet. The numbers in the lines are separated by spaces.It is guaranteed that the names of all planets are different.\n\nOutputPrint a single number — the maximum profit Qwerty can get.\n\nInputCopy3 3 10Venus6 5 37 6 58 6 10Earth10 9 08 6 410 9 3Mars4 3 08 4 127 2 5OutputCopy16\n\nInputCopy3 3 10Venus6 5 37 6 58 6 10Earth10 9 08 6 410 9 3Mars4 3 08 4 127 2 5\n\nOutputCopy16\n\nNoteIn the first test case you should fly to planet Venus, take a loan on 74 units of money and buy three items of the first type and 7 items of the third type (3·6 + 7·8 = 74). Then the ranger should fly to planet Earth and sell there all the items he has bought. He gets 3·9 + 7·9 = 90 units of money for the items, he should give 74 of them for the loan. The resulting profit equals 16 units of money. We cannot get more profit in this case.",
      "solutions": [
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces",
          "content": "Hello everyone!Today is the second round of the Open Moscow Programming Championship By CROC will be. Start is planned at 19:00.Competition will happen by usual rules of Codeforces, with hacks and score falling in process of time. All contestants who passed score no less than contectant of the 300-th place in the Round 1, can participate in the Round 2. Every other contestants can patricipate the Round 2 out of competition. Specially for contestants of the second division we prepared more easy unofficial problemset. The official problemset and the unnoficial one have some common tasks.Round will be rated for all participants.Some number of problems are waiting you. They are roughly ordered by the increasing complexity. Score distribution is standard for both divisions (500-1000-1500-2000-2500). Don't forget that during contest your solutions will be tested on a small set of pretests. Testing on full testset will be after end of the round. Pretests can don't cover all cases of input data, so you should test your solutions very carefully.It is strictly forbidden to publish statements/solutions of the problems before round will be end. Also you shouldn't to talk about problems, discuss some things about possible solutions of them. Let's be honest! You can discuss problems after the end of round.Top 50 contestant will be allowed to the Final Round. Also all contestant with score not less than score of the 50-th contestant will be passed.The round was prepared by Ripatti, havaliza, Gerald, RAD, MikeMirzayanov, Delinur.Good luck for all!UPD. We remind that the final of the Open Championship of Moscow and Moscow Region Programming (CROC) take place on April 27 in the office of the CROC. Note that CROC does not pay for the road and residence of the finalists. All participants must arrive at the final in the office of the CROC (Moscow) in the morning on April 27.After the competition all participants will be provided to fill the form on the ability to participate in the finals of the competition. The first 50 participants on the results of the competition, which will confirm their participation in the finals, will be invited to final competition. You can confirm participation in the finals during the day after the end of Round 2.It is recommended to fill the form, regardless of your results in Round 2, as large number of participants can reject the participation in the final.",
          "author": "Ripatti",
          "url": "https://codeforces.com/blog/entry/4370",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2409
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces",
          "content": "A div2. Required row is row that have only one star inside. Requred column is comumn that also have only one star inside. So, you can iterate over all rows/columns, calculate number of stars inside them and find the answer.Authors are MikeMirzayanov, Gerald .B div2. Naive solution O(n3) (where you check all triplets) doesn't fin into time limits.You can see that for every two points from triplet (for example, for A and C) you can find place of the third point. So you can find number of requred triplets just inerate over all pairs of points and check middle point between points in every pair.How to fast check position? You can add 1000 for all coordinates (you can see that this operation doesn't change the answer) and mark them in the 2-dimensional boolean array 2001х2001. So you can check every position for point in O(1) time.Obtained solution works in O(n2).Authors are MikeMirzayanov, GeraldA div1. C div2. In this problem some greedy solution expected.Let fix 2 planets: in planet i we will buy items, in planet j we will sell the ones. Profit of item of type k will be b_jk-a_ik. Every item has size 1, so you should greedy take items in order of decreasing of profits of items while you have place in the hold.Scheme of full solution: you should iterate over all pairs of planet, for every pair greedy take items and find total profit. At the end you should find maximal total profit over all pairs and output it.Author is RipattiB div1. D div2. You can see that split oparetion is just cyclically shift of string. You can go from any cyclically shift to any other one except the current one.Let's call some cyclically shift good iff it equal to the final string. All others cyclically shifts we will call bad. You can check all shifts in O(|w|2) time. Let's you have A good shifts and B bad ones.Let's define dpA[n] as number of ways to get some good shift using n splits and за dpB[n] as number of ways to get some bad shift using n splits.dpA[0]=1, dpB[0]=0 or dpA[0]=0, dpB[0]=1 according to the first shift is good or not. All other values of dp you can get using following reccurences:dpA[n] = dpA[n-1] * (A-1) + dpB[n-1] * AdpB[n] = dpA[n-1] * B + dpB[n-1] * (B-1)Answer will be dpA[k]. So you have O(|w|2 + k) solution.Also this problem can be solved in time.Author is havalizaC div1. E div2. The second player have easy strategy to hold some chip in position (X, Y) in one of four half-planes — x ≤ X + 2, x ≥ X - 2, y ≤ Y + 2 и y ≥ Y - 2. He can chose one of these half-planes by himself.So, in case max(|x1 - x2|, |y1 - y2|) > 4 the second player wins — he just holds chips in half-planes that have no common cells.Cases for max(|x1 - x2|, |y1 - y2|) ≤ 4 expected to solve using some bruteforce. You can see that moving chips in way of distancing from each other is not profitable for the first player. Therefore you can bruteforce the game in square no more than 5 × 5. If your bruteforce so slow and doesn't fit into 2 sec, you can use precalculation. Also you can write some dp using masks.Also you can check cases max(|x1 - x2|, |y1 - y2|) ≤ 4 by hand. But there you can easy make some mistakes.Author is RipattiD div1. Let's define dp[pre][len] as the minimal prefix of hyperstring that have with prefix of t of length len largest common sequence of length len.Then you have see reccurences:dp[pre][len] = min(dp[pre - 1][len],  leftmost position of letter s[pre] in t that right than dp[pre - 1][len - 1]).For finding value of the second part inside min-function of formula above in O(1), you should calculate some additional dp's: dp1 — for every basic string, positions inside of them and letter you should calculate leftmost position of current letter that right than current position;dp2 — for every element of array of basic strings (it is hyperstring) and letter you should calculate leftmost basic string that have current letter and this string is rinht than current basic string.So you have solution.Author is havaliza.E div1. At the first let's try to solve another problem: we have k chosed vertices in the tree and we want to find sum of subtree that \"spanned\" dy them in time (with any preprocessing time).Let's sort all k vertices in order of dfs traversal — v1, v2, ... , vk. Consider pathes v1-v2, v2-v3, ... , v(k-1)-vk and vk-v1. You can see that they cover only our requred subtree and every edge is covered exactly two times. So you can just find sum of lengths of these pathes (you can do it in required time using LCA algo) and divide obtained value by 2.For solving initial problem you should support set of active vertices in ordered state (for example, you can use std::set) and sum of all pathes between all neighbour vertices. Now you can process insert/remove queries in , and recalculate sum of pathes by finding no more than 3 new pathes also in .So you have solution.Author is Ripatti.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4372",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4850
        }
      ],
      "code_examples": [
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 1",
          "code": "x...\n....\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 2",
          "code": "x...\n....\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 3",
          "code": "x...\n.!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 4",
          "code": "x...\n.!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 5",
          "code": "x...\n.!..\n....\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 6",
          "code": "x...\n.!..\n....\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 7",
          "code": "x...\n.!..\n.!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 8",
          "code": "x...\n.!..\n.!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 9",
          "code": "....\nx!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 10",
          "code": "....\nx!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 11",
          "code": "....\nx!..\n!...\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 12",
          "code": "....\nx!..\n!...\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 13",
          "code": "....\nx!..\n!...\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 14",
          "code": "....\nx!..\n!...\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 15",
          "code": "....\nx!..\n!!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 16",
          "code": "....\nx!..\n!!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces - Code 1",
          "code": "dpA[n] = dpA[n-1]*(A-1) + dpB[n-1]*A\ndpB[n] = dpA[n-1]*B + dpB[n-1](B-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4372",
          "author": "jiangly"
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces - Code 2",
          "code": "dpA[n] = dpA[n-1]*(A-1) + dpB[n-1]*A\ndpB[n] = dpA[n-1]*B + dpB[n-1](B-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4372",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 10, \"n\"); // 2 ≤ n ≤ 10\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\"); // 1 ≤ m ≤ 100\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\"); // 1 ≤ k ≤ 100\n    inf.readEoln();\n\n    set<string> planetNames;\n\n    for (int i = 0; i < n; ++i) {\n        // Read planet name\n        string pname = inf.readToken(\"[A-Z][a-z]{0,9}\", \"planetName\");\n        ensuref(pname.size() >= 1 && pname.size() <= 10, \"Planet name length must be between 1 and 10\");\n\n        // Check that the name is unique\n        ensuref(planetNames.count(pname) == 0, \"Planet name '%s' is duplicate\", pname.c_str());\n        planetNames.insert(pname);\n\n        inf.readEoln();\n\n        // Read m lines of a_ij, b_ij, c_ij\n        for (int j = 0; j < m; ++j) {\n            int a_ij = inf.readInt(2, 1000, \"a_ij\"); // 2 ≤ a_ij ≤ 1000\n            inf.readSpace();\n            int b_ij = inf.readInt(1, a_ij - 1, \"b_ij\"); // 1 ≤ b_ij < a_ij\n            inf.readSpace();\n            int c_ij = inf.readInt(0, 100, \"c_ij\"); // 0 ≤ c_ij ≤ 100\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 10, \"n\"); // 2 ≤ n ≤ 10\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\"); // 1 ≤ m ≤ 100\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\"); // 1 ≤ k ≤ 100\n    inf.readEoln();\n\n    set<string> planetNames;\n\n    for (int i = 0; i < n; ++i) {\n        // Read planet name\n        string pname = inf.readToken(\"[A-Z][a-z]{0,9}\", \"planetName\");\n        ensuref(pname.size() >= 1 && pname.size() <= 10, \"Planet name length must be between 1 and 10\");\n\n        // Check that the name is unique\n        ensuref(planetNames.count(pname) == 0, \"Planet name '%s' is duplicate\", pname.c_str());\n        planetNames.insert(pname);\n\n        inf.readEoln();\n\n        // Read m lines of a_ij, b_ij, c_ij\n        for (int j = 0; j < m; ++j) {\n            int a_ij = inf.readInt(2, 1000, \"a_ij\"); // 2 ≤ a_ij ≤ 1000\n            inf.readSpace();\n            int b_ij = inf.readInt(1, a_ij - 1, \"b_ij\"); // 1 ≤ b_ij < a_ij\n            inf.readSpace();\n            int c_ij = inf.readInt(0, 100, \"c_ij\"); // 0 ≤ c_ij ≤ 100\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 10, \"n\"); // 2 ≤ n ≤ 10\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\"); // 1 ≤ m ≤ 100\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\"); // 1 ≤ k ≤ 100\n    inf.readEoln();\n\n    set<string> planetNames;\n\n    for (int i = 0; i < n; ++i) {\n        // Read planet name\n        string pname = inf.readToken(\"[A-Z][a-z]{0,9}\", \"planetName\");\n        ensuref(pname.size() >= 1 && pname.size() <= 10, \"Planet name length must be between 1 and 10\");\n\n        // Check that the name is unique\n        ensuref(planetNames.count(pname) == 0, \"Planet name '%s' is duplicate\", pname.c_str());\n        planetNames.insert(pname);\n\n        inf.readEoln();\n\n        // Read m lines of a_ij, b_ij, c_ij\n        for (int j = 0; j < m; ++j) {\n            int a_ij = inf.readInt(2, 1000, \"a_ij\"); // 2 ≤ a_ij ≤ 1000\n            inf.readSpace();\n            int b_ij = inf.readInt(1, a_ij - 1, \"b_ij\"); // 1 ≤ b_ij < a_ij\n            inf.readSpace();\n            int c_ij = inf.readInt(0, 100, \"c_ij\"); // 0 ≤ c_ij ≤ 100\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");  // number of planets\n    int m = opt<int>(\"m\");  // number of item types\n    int k = opt<int>(\"k\");  // ship capacity\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    vector<string> planetNames;\n    set<string> namesSet;\n\n    // Generate n distinct planet names\n    while ((int)planetNames.size() < n) {\n        int len = rnd.next(1, 10);  // Length from 1 to 10\n        string name;\n        name += (char)('A' + rnd.next(0, 25));  // First letter uppercase\n        for (int i = 1; i < len; ++i) {\n            name += (char)('a' + rnd.next(0, 25));\n        }\n        if (namesSet.count(name) == 0) {\n            namesSet.insert(name);\n            planetNames.push_back(name);\n        }\n    }\n\n    // Generate data for each planet\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", planetNames[i].c_str());\n\n        for (int j = 0; j < m; ++j) {\n            int aij, bij, cij;\n\n            if (type == \"random\") {\n                // Random data within constraints\n                bij = rnd.next(1, 999);\n                aij = rnd.next(bij + 1, 1000);\n                cij = rnd.next(0, 100);\n            } else if (type == \"zeroProfit\") {\n                // Profit per item is zero\n                bij = rnd.next(1, 999);\n                aij = bij + 1;\n                cij = rnd.next(0, 100);\n            } else if (type == \"noProfit\") {\n                // Profit per item is negative\n                bij = rnd.next(1, 900);\n                int delta = rnd.next(1, 100);\n                aij = bij + delta;\n                cij = rnd.next(0, 100);\n            } else if (type == \"maxProfit\") {\n                if (i == 0) {\n                    // Buying planet\n                    bij = 1;\n                    aij = bij + 1;\n                    cij = 100;  // Max available\n                } else if (i == 1) {\n                    // Selling planet\n                    bij = 1000;\n                    aij = bij + 1;\n                    cij = rnd.next(0, 100);\n                } else {\n                    // Other planets\n                    bij = rnd.next(1, 999);\n                    aij = bij + rnd.next(1, 100);\n                    cij = rnd.next(0, 100);\n                }\n            } else if (type == \"kLimit\") {\n                // Capacity k is limiting\n                bij = rnd.next(1, 999);\n                aij = bij + rnd.next(1, 100);\n                cij = 100;  // Max available\n            } else if (type == \"cLimit\") {\n                // Available items c_ij is limiting\n                bij = rnd.next(1, 999);\n                aij = bij + rnd.next(1, 100);\n                cij = rnd.next(0, 5);  // Small c_ij\n            } else if (type == \"edge0\") {\n                // All c_ij = 0\n                bij = rnd.next(1, 999);\n                aij = bij + rnd.next(1, 100);\n                cij = 0;\n            } else if (type == \"maxc\") {\n                // All c_ij = 100\n                bij = rnd.next(1, 999);\n                aij = bij + rnd.next(1, 100);\n                cij = 100;\n            } else {\n                // Default to random\n                bij = rnd.next(1, 999);\n                aij = rnd.next(bij + 1, 1000);\n                cij = rnd.next(0, 100);\n            }\n\n            printf(\"%d %d %d\\n\", aij, bij, cij);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");  // number of planets\n    int m = opt<int>(\"m\");  // number of item types\n    int k = opt<int>(\"k\");  // ship capacity\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    vector<string> planetNames;\n    set<string> namesSet;\n\n    // Generate n distinct planet names\n    while ((int)planetNames.size() < n) {\n        int len = rnd.next(1, 10);  // Length from 1 to 10\n        string name;\n        name += (char)('A' + rnd.next(0, 25));  // First letter uppercase\n        for (int i = 1; i < len; ++i) {\n            name += (char)('a' + rnd.next(0, 25));\n        }\n        if (namesSet.count(name) == 0) {\n            namesSet.insert(name);\n            planetNames.push_back(name);\n        }\n    }\n\n    // Generate data for each planet\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", planetNames[i].c_str());\n\n        for (int j = 0; j < m; ++j) {\n            int aij, bij, cij;\n\n            if (type == \"random\") {\n                // Random data within constraints\n                bij = rnd.next(1, 999);\n                aij = rnd.next(bij + 1, 1000);\n                cij = rnd.next(0, 100);\n            } else if (type == \"zeroProfit\") {\n                // Profit per item is zero\n                bij = rnd.next(1, 999);\n                aij = bij + 1;\n                cij = rnd.next(0, 100);\n            } else if (type == \"noProfit\") {\n                // Profit per item is negative\n                bij = rnd.next(1, 900);\n                int delta = rnd.next(1, 100);\n                aij = bij + delta;\n                cij = rnd.next(0, 100);\n            } else if (type == \"maxProfit\") {\n                if (i == 0) {\n                    // Buying planet\n                    bij = 1;\n                    aij = bij + 1;\n                    cij = 100;  // Max available\n                } else if (i == 1) {\n                    // Selling planet\n                    bij = 1000;\n                    aij = bij + 1;\n                    cij = rnd.next(0, 100);\n                } else {\n                    // Other planets\n                    bij = rnd.next(1, 999);\n                    aij = bij + rnd.next(1, 100);\n                    cij = rnd.next(0, 100);\n                }\n            } else if (type == \"kLimit\") {\n                // Capacity k is limiting\n                bij = rnd.next(1, 999);\n                aij = bij + rnd.next(1, 100);\n                cij = 100;  // Max available\n            } else if (type == \"cLimit\") {\n                // Available items c_ij is limiting\n                bij = rnd.next(1, 999);\n                aij = bij + rnd.next(1, 100);\n                cij = rnd.next(0, 5);  // Small c_ij\n            } else if (type == \"edge0\") {\n                // All c_ij = 0\n                bij = rnd.next(1, 999);\n                aij = bij + rnd.next(1, 100);\n                cij = 0;\n            } else if (type == \"maxc\") {\n                // All c_ij = 100\n                bij = rnd.next(1, 999);\n                aij = bij + rnd.next(1, 100);\n                cij = 100;\n            } else {\n                // Default to random\n                bij = rnd.next(1, 999);\n                aij = rnd.next(bij + 1, 1000);\n                cij = rnd.next(0, 100);\n            }\n\n            printf(\"%d %d %d\\n\", aij, bij, cij);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -k 1 -type random\n./gen -n 10 -m 100 -k 100 -type random\n./gen -n 3 -m 3 -k 10 -type random\n./gen -n 5 -m 50 -k 50 -type random\n./gen -n 10 -m 1 -k 100 -type random\n./gen -n 2 -m 100 -k 100 -type random\n./gen -n 10 -m 100 -k 1 -type random\n./gen -n 10 -m 100 -k 100 -type zeroProfit\n./gen -n 2 -m 1 -k 1 -type zeroProfit\n./gen -n 10 -m 100 -k 100 -type noProfit\n./gen -n 5 -m 50 -k 50 -type noProfit\n./gen -n 10 -m 100 -k 100 -type maxProfit\n./gen -n 2 -m 100 -k 100 -type maxProfit\n./gen -n 10 -m 100 -k 100 -type maxProfit\n./gen -n 10 -m 100 -k 5 -type kLimit\n./gen -n 10 -m 100 -k 1 -type kLimit\n./gen -n 10 -m 100 -k 10 -type kLimit\n./gen -n 10 -m 100 -k 100 -type cLimit\n./gen -n 10 -m 100 -k 100 -type cLimit\n./gen -n 10 -m 100 -k 100 -type edge0\n./gen -n 10 -m 100 -k 100 -type maxc\n./gen -n 2 -m 100 -k 100 -type maxc\n./gen -n 2 -m 1 -k 100 -type maxc\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:47.845868",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "181/D",
      "title": "D. Word Cut",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a non-empty word start, the second line contains a non-empty word end. The words consist of lowercase Latin letters. The number of letters in word start equals the number of letters in word end and is at least 2 and doesn't exceed 1000 letters.The third line contains integer k (0 ≤ k ≤ 105) — the required number of operations.",
      "output_spec": "OutputPrint a single number — the answer to the problem. As this number can be rather large, print it modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopyabab2OutputCopy1InputCopyabababababab1OutputCopy2InputCopyabba2OutputCopy0",
      "description": "D. Word Cut\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a non-empty word start, the second line contains a non-empty word end. The words consist of lowercase Latin letters. The number of letters in word start equals the number of letters in word end and is at least 2 and doesn't exceed 1000 letters.The third line contains integer k (0 ≤ k ≤ 105) — the required number of operations.\n\nOutputPrint a single number — the answer to the problem. As this number can be rather large, print it modulo 1000000007 (109 + 7).\n\nInputCopyabab2OutputCopy1InputCopyabababababab1OutputCopy2InputCopyabba2OutputCopy0\n\nInputCopyabab2\n\nOutputCopy1\n\nInputCopyabababababab1\n\nOutputCopy2\n\nInputCopyabba2\n\nOutputCopy0\n\nNoteThe sought way in the first sample is:ab  →  a|b  →  ba  →  b|a  →  abIn the second sample the two sought ways are: ababab  →  abab|ab  →  ababab  ababab  →  ab|abab  →  ababab",
      "solutions": [
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces",
          "content": "Hello everyone!Today is the second round of the Open Moscow Programming Championship By CROC will be. Start is planned at 19:00.Competition will happen by usual rules of Codeforces, with hacks and score falling in process of time. All contestants who passed score no less than contectant of the 300-th place in the Round 1, can participate in the Round 2. Every other contestants can patricipate the Round 2 out of competition. Specially for contestants of the second division we prepared more easy unofficial problemset. The official problemset and the unnoficial one have some common tasks.Round will be rated for all participants.Some number of problems are waiting you. They are roughly ordered by the increasing complexity. Score distribution is standard for both divisions (500-1000-1500-2000-2500). Don't forget that during contest your solutions will be tested on a small set of pretests. Testing on full testset will be after end of the round. Pretests can don't cover all cases of input data, so you should test your solutions very carefully.It is strictly forbidden to publish statements/solutions of the problems before round will be end. Also you shouldn't to talk about problems, discuss some things about possible solutions of them. Let's be honest! You can discuss problems after the end of round.Top 50 contestant will be allowed to the Final Round. Also all contestant with score not less than score of the 50-th contestant will be passed.The round was prepared by Ripatti, havaliza, Gerald, RAD, MikeMirzayanov, Delinur.Good luck for all!UPD. We remind that the final of the Open Championship of Moscow and Moscow Region Programming (CROC) take place on April 27 in the office of the CROC. Note that CROC does not pay for the road and residence of the finalists. All participants must arrive at the final in the office of the CROC (Moscow) in the morning on April 27.After the competition all participants will be provided to fill the form on the ability to participate in the finals of the competition. The first 50 participants on the results of the competition, which will confirm their participation in the finals, will be invited to final competition. You can confirm participation in the finals during the day after the end of Round 2.It is recommended to fill the form, regardless of your results in Round 2, as large number of participants can reject the participation in the final.",
          "author": "Ripatti",
          "url": "https://codeforces.com/blog/entry/4370",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2409
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces",
          "content": "A div2. Required row is row that have only one star inside. Requred column is comumn that also have only one star inside. So, you can iterate over all rows/columns, calculate number of stars inside them and find the answer.Authors are MikeMirzayanov, Gerald .B div2. Naive solution O(n3) (where you check all triplets) doesn't fin into time limits.You can see that for every two points from triplet (for example, for A and C) you can find place of the third point. So you can find number of requred triplets just inerate over all pairs of points and check middle point between points in every pair.How to fast check position? You can add 1000 for all coordinates (you can see that this operation doesn't change the answer) and mark them in the 2-dimensional boolean array 2001х2001. So you can check every position for point in O(1) time.Obtained solution works in O(n2).Authors are MikeMirzayanov, GeraldA div1. C div2. In this problem some greedy solution expected.Let fix 2 planets: in planet i we will buy items, in planet j we will sell the ones. Profit of item of type k will be b_jk-a_ik. Every item has size 1, so you should greedy take items in order of decreasing of profits of items while you have place in the hold.Scheme of full solution: you should iterate over all pairs of planet, for every pair greedy take items and find total profit. At the end you should find maximal total profit over all pairs and output it.Author is RipattiB div1. D div2. You can see that split oparetion is just cyclically shift of string. You can go from any cyclically shift to any other one except the current one.Let's call some cyclically shift good iff it equal to the final string. All others cyclically shifts we will call bad. You can check all shifts in O(|w|2) time. Let's you have A good shifts and B bad ones.Let's define dpA[n] as number of ways to get some good shift using n splits and за dpB[n] as number of ways to get some bad shift using n splits.dpA[0]=1, dpB[0]=0 or dpA[0]=0, dpB[0]=1 according to the first shift is good or not. All other values of dp you can get using following reccurences:dpA[n] = dpA[n-1] * (A-1) + dpB[n-1] * AdpB[n] = dpA[n-1] * B + dpB[n-1] * (B-1)Answer will be dpA[k]. So you have O(|w|2 + k) solution.Also this problem can be solved in time.Author is havalizaC div1. E div2. The second player have easy strategy to hold some chip in position (X, Y) in one of four half-planes — x ≤ X + 2, x ≥ X - 2, y ≤ Y + 2 и y ≥ Y - 2. He can chose one of these half-planes by himself.So, in case max(|x1 - x2|, |y1 - y2|) > 4 the second player wins — he just holds chips in half-planes that have no common cells.Cases for max(|x1 - x2|, |y1 - y2|) ≤ 4 expected to solve using some bruteforce. You can see that moving chips in way of distancing from each other is not profitable for the first player. Therefore you can bruteforce the game in square no more than 5 × 5. If your bruteforce so slow and doesn't fit into 2 sec, you can use precalculation. Also you can write some dp using masks.Also you can check cases max(|x1 - x2|, |y1 - y2|) ≤ 4 by hand. But there you can easy make some mistakes.Author is RipattiD div1. Let's define dp[pre][len] as the minimal prefix of hyperstring that have with prefix of t of length len largest common sequence of length len.Then you have see reccurences:dp[pre][len] = min(dp[pre - 1][len],  leftmost position of letter s[pre] in t that right than dp[pre - 1][len - 1]).For finding value of the second part inside min-function of formula above in O(1), you should calculate some additional dp's: dp1 — for every basic string, positions inside of them and letter you should calculate leftmost position of current letter that right than current position;dp2 — for every element of array of basic strings (it is hyperstring) and letter you should calculate leftmost basic string that have current letter and this string is rinht than current basic string.So you have solution.Author is havaliza.E div1. At the first let's try to solve another problem: we have k chosed vertices in the tree and we want to find sum of subtree that \"spanned\" dy them in time (with any preprocessing time).Let's sort all k vertices in order of dfs traversal — v1, v2, ... , vk. Consider pathes v1-v2, v2-v3, ... , v(k-1)-vk and vk-v1. You can see that they cover only our requred subtree and every edge is covered exactly two times. So you can just find sum of lengths of these pathes (you can do it in required time using LCA algo) and divide obtained value by 2.For solving initial problem you should support set of active vertices in ordered state (for example, you can use std::set) and sum of all pathes between all neighbour vertices. Now you can process insert/remove queries in , and recalculate sum of pathes by finding no more than 3 new pathes also in .So you have solution.Author is Ripatti.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4372",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4850
        }
      ],
      "code_examples": [
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 1",
          "code": "x...\n....\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 2",
          "code": "x...\n....\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 3",
          "code": "x...\n.!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 4",
          "code": "x...\n.!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 5",
          "code": "x...\n.!..\n....\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 6",
          "code": "x...\n.!..\n....\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 7",
          "code": "x...\n.!..\n.!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 8",
          "code": "x...\n.!..\n.!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 9",
          "code": "....\nx!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 10",
          "code": "....\nx!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 11",
          "code": "....\nx!..\n!...\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 12",
          "code": "....\nx!..\n!...\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 13",
          "code": "....\nx!..\n!...\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 14",
          "code": "....\nx!..\n!...\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 15",
          "code": "....\nx!..\n!!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 16",
          "code": "....\nx!..\n!!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces - Code 1",
          "code": "dpA[n] = dpA[n-1]*(A-1) + dpB[n-1]*A\ndpB[n] = dpA[n-1]*B + dpB[n-1](B-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4372",
          "author": "jiangly"
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces - Code 2",
          "code": "dpA[n] = dpA[n-1]*(A-1) + dpB[n-1]*A\ndpB[n] = dpA[n-1]*B + dpB[n-1](B-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4372",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string start = inf.readToken(\"[a-z]{2,1000}\", \"start\");\n    inf.readEoln();\n\n    string end = inf.readToken(\"[a-z]{2,1000}\", \"end\");\n    inf.readEoln();\n\n    ensuref(int(start.length()) == int(end.length()), \"Lengths of start (%d) and end (%d) must be equal\", int(start.length()), int(end.length()));\n\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string start = inf.readToken(\"[a-z]{2,1000}\", \"start\");\n    inf.readEoln();\n\n    string end = inf.readToken(\"[a-z]{2,1000}\", \"end\");\n    inf.readEoln();\n\n    ensuref(int(start.length()) == int(end.length()), \"Lengths of start (%d) and end (%d) must be equal\", int(start.length()), int(end.length()));\n\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string start = inf.readToken(\"[a-z]{2,1000}\", \"start\");\n    inf.readEoln();\n\n    string end = inf.readToken(\"[a-z]{2,1000}\", \"end\");\n    inf.readEoln();\n\n    ensuref(int(start.length()) == int(end.length()), \"Lengths of start (%d) and end (%d) must be equal\", int(start.length()), int(end.length()));\n\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nstring random_string(int n) {\n    string s(n, 'a');\n    for (int i = 0; i < n; ++i) {\n        s[i] = 'a' + rnd.next(26);\n    }\n    return s;\n}\n\nstring cyclic_shift(string s, int shift) {\n    int n = s.size();\n    string t = s.substr(shift, n - shift) + s.substr(0, shift);\n    return t;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    int k = opt<int>(\"k\", 0);\n    string type = opt<string>(\"type\", \"equal\");\n\n    n = max(2, min(1000, n));\n    k = max(0, min(100000, k));\n\n    string start, end;\n\n    if (type == \"equal\") {\n        start = random_string(n);\n        end = start;\n    } else if (type == \"cyclic\") {\n        start = random_string(n);\n        int shift = rnd.next(1, n - 1);\n        end = cyclic_shift(start, shift);\n    } else if (type == \"noncyclic\") {\n        start = random_string(n);\n        end = start;\n        int pos = n / 2;\n        char original_char = end[pos];\n        char new_char = 'a' + (original_char - 'a' + 1) % 26;\n        end[pos] = new_char;\n    } else if (type == \"same_char\") {\n        char c = 'a' + rnd.next(26);\n        start = string(n, c);\n        end = start;\n    } else if (type == \"max_n\") {\n        n = 1000;\n        start = random_string(n);\n        end = start;\n    } else if (type == \"min_n\") {\n        n = 2;\n        start = random_string(n);\n        end = start;\n    } else if (type == \"max_k\") {\n        k = 100000;\n        start = random_string(n);\n        end = start;\n    } else if (type == \"min_k\") {\n        k = 0;\n        start = random_string(n);\n        end = start;\n    } else if (type == \"random\") {\n        start = random_string(n);\n        end = random_string(n);\n    } else if (type == \"cyclic_max\") {\n        n = 1000;\n        k = 100000;\n        start = random_string(n);\n        int shift = rnd.next(1, n - 1);\n        end = cyclic_shift(start, shift);\n    } else if (type == \"same_char_cyclic\") {\n        n = rnd.next(2, 1000);\n        char c = 'a' + rnd.next(26);\n        start = string(n, c);\n        int shift = rnd.next(1, n - 1);\n        end = cyclic_shift(start, shift);\n    } else {\n        // Default to random\n        start = random_string(n);\n        end = start;\n    }\n\n    // Output\n    cout << start << endl;\n    cout << end << endl;\n    cout << k << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n\nstring random_string(int n) {\n    string s(n, 'a');\n    for (int i = 0; i < n; ++i) {\n        s[i] = 'a' + rnd.next(26);\n    }\n    return s;\n}\n\nstring cyclic_shift(string s, int shift) {\n    int n = s.size();\n    string t = s.substr(shift, n - shift) + s.substr(0, shift);\n    return t;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    int k = opt<int>(\"k\", 0);\n    string type = opt<string>(\"type\", \"equal\");\n\n    n = max(2, min(1000, n));\n    k = max(0, min(100000, k));\n\n    string start, end;\n\n    if (type == \"equal\") {\n        start = random_string(n);\n        end = start;\n    } else if (type == \"cyclic\") {\n        start = random_string(n);\n        int shift = rnd.next(1, n - 1);\n        end = cyclic_shift(start, shift);\n    } else if (type == \"noncyclic\") {\n        start = random_string(n);\n        end = start;\n        int pos = n / 2;\n        char original_char = end[pos];\n        char new_char = 'a' + (original_char - 'a' + 1) % 26;\n        end[pos] = new_char;\n    } else if (type == \"same_char\") {\n        char c = 'a' + rnd.next(26);\n        start = string(n, c);\n        end = start;\n    } else if (type == \"max_n\") {\n        n = 1000;\n        start = random_string(n);\n        end = start;\n    } else if (type == \"min_n\") {\n        n = 2;\n        start = random_string(n);\n        end = start;\n    } else if (type == \"max_k\") {\n        k = 100000;\n        start = random_string(n);\n        end = start;\n    } else if (type == \"min_k\") {\n        k = 0;\n        start = random_string(n);\n        end = start;\n    } else if (type == \"random\") {\n        start = random_string(n);\n        end = random_string(n);\n    } else if (type == \"cyclic_max\") {\n        n = 1000;\n        k = 100000;\n        start = random_string(n);\n        int shift = rnd.next(1, n - 1);\n        end = cyclic_shift(start, shift);\n    } else if (type == \"same_char_cyclic\") {\n        n = rnd.next(2, 1000);\n        char c = 'a' + rnd.next(26);\n        start = string(n, c);\n        int shift = rnd.next(1, n - 1);\n        end = cyclic_shift(start, shift);\n    } else {\n        // Default to random\n        start = random_string(n);\n        end = start;\n    }\n\n    // Output\n    cout << start << endl;\n    cout << end << endl;\n    cout << k << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -k 0 -type equal\n./gen -n 2 -k 1 -type equal\n./gen -n 2 -k 2 -type equal\n./gen -n 10 -k 5 -type cyclic\n./gen -n 10 -k 5 -type noncyclic\n./gen -n 10 -k 0 -type random\n./gen -n 10 -k 100000 -type random\n./gen -n 1000 -k 100000 -type max_n\n./gen -n 1000 -k 100000 -type max_k\n./gen -n 1000 -type cyclic_max\n./gen -n 500 -k 50000 -type cyclic\n./gen -n 500 -k 50000 -type noncyclic\n./gen -n 2 -k 100000 -type min_n\n./gen -n 1000 -k 0 -type min_k\n./gen -n 1000 -k 0 -type random\n./gen -n 1000 -k 0 -type same_char\n./gen -n 1000 -k 100000 -type same_char_cyclic\n./gen -n 2 -k 100000 -type same_char\n./gen -n 500 -k 50000 -type equal\n./gen -n 500 -k 50000 -type random\n./gen -n 1000 -k 50000 -type noncyclic\n./gen -n 2 -k 0 -type noncyclic\n./gen -n 10 -k 100000 -type max_k\n./gen -n 500 -k 0 -type min_k\n./gen -n 1000 -k 99999 -type cyclic\n./gen -n 999 -k 99999 -type same_char_cyclic\n./gen -n 100 -k 50 -type same_char\n./gen -n 100 -k 50 -type random\n./gen -n 2 -k 0 -type min_n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:49.838831",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "181/E",
      "title": "E. Playing with Superglue",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains six integers n, m, x1, y1, x2, y2 — the board sizes and the coordinates of the first and second chips, correspondingly (1 ≤ n, m ≤ 100; 2 ≤ n × m; 1 ≤ x1, x2 ≤ n; 1 ≤ y1, y2 ≤ m). The numbers in the line are separated by single spaces.It is guaranteed that the chips are located in different squares.",
      "output_spec": "OutputIf the first player wins, print \"First\" without the quotes. Otherwise, print \"Second\" without the quotes.",
      "sample_tests": "ExamplesInputCopy1 6 1 2 1 6OutputCopyFirstInputCopy6 5 4 3 2 1OutputCopyFirstInputCopy10 10 1 1 10 10OutputCopySecond",
      "description": "E. Playing with Superglue\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains six integers n, m, x1, y1, x2, y2 — the board sizes and the coordinates of the first and second chips, correspondingly (1 ≤ n, m ≤ 100; 2 ≤ n × m; 1 ≤ x1, x2 ≤ n; 1 ≤ y1, y2 ≤ m). The numbers in the line are separated by single spaces.It is guaranteed that the chips are located in different squares.\n\nOutputIf the first player wins, print \"First\" without the quotes. Otherwise, print \"Second\" without the quotes.\n\nInputCopy1 6 1 2 1 6OutputCopyFirstInputCopy6 5 4 3 2 1OutputCopyFirstInputCopy10 10 1 1 10 10OutputCopySecond\n\nInputCopy1 6 1 2 1 6\n\nOutputCopyFirst\n\nInputCopy6 5 4 3 2 1\n\nOutputCopyFirst\n\nInputCopy10 10 1 1 10 10\n\nOutputCopySecond",
      "solutions": [
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces",
          "content": "Hello everyone!Today is the second round of the Open Moscow Programming Championship By CROC will be. Start is planned at 19:00.Competition will happen by usual rules of Codeforces, with hacks and score falling in process of time. All contestants who passed score no less than contectant of the 300-th place in the Round 1, can participate in the Round 2. Every other contestants can patricipate the Round 2 out of competition. Specially for contestants of the second division we prepared more easy unofficial problemset. The official problemset and the unnoficial one have some common tasks.Round will be rated for all participants.Some number of problems are waiting you. They are roughly ordered by the increasing complexity. Score distribution is standard for both divisions (500-1000-1500-2000-2500). Don't forget that during contest your solutions will be tested on a small set of pretests. Testing on full testset will be after end of the round. Pretests can don't cover all cases of input data, so you should test your solutions very carefully.It is strictly forbidden to publish statements/solutions of the problems before round will be end. Also you shouldn't to talk about problems, discuss some things about possible solutions of them. Let's be honest! You can discuss problems after the end of round.Top 50 contestant will be allowed to the Final Round. Also all contestant with score not less than score of the 50-th contestant will be passed.The round was prepared by Ripatti, havaliza, Gerald, RAD, MikeMirzayanov, Delinur.Good luck for all!UPD. We remind that the final of the Open Championship of Moscow and Moscow Region Programming (CROC) take place on April 27 in the office of the CROC. Note that CROC does not pay for the road and residence of the finalists. All participants must arrive at the final in the office of the CROC (Moscow) in the morning on April 27.After the competition all participants will be provided to fill the form on the ability to participate in the finals of the competition. The first 50 participants on the results of the competition, which will confirm their participation in the finals, will be invited to final competition. You can confirm participation in the finals during the day after the end of Round 2.It is recommended to fill the form, regardless of your results in Round 2, as large number of participants can reject the participation in the final.",
          "author": "Ripatti",
          "url": "https://codeforces.com/blog/entry/4370",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2409
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces",
          "content": "A div2. Required row is row that have only one star inside. Requred column is comumn that also have only one star inside. So, you can iterate over all rows/columns, calculate number of stars inside them and find the answer.Authors are MikeMirzayanov, Gerald .B div2. Naive solution O(n3) (where you check all triplets) doesn't fin into time limits.You can see that for every two points from triplet (for example, for A and C) you can find place of the third point. So you can find number of requred triplets just inerate over all pairs of points and check middle point between points in every pair.How to fast check position? You can add 1000 for all coordinates (you can see that this operation doesn't change the answer) and mark them in the 2-dimensional boolean array 2001х2001. So you can check every position for point in O(1) time.Obtained solution works in O(n2).Authors are MikeMirzayanov, GeraldA div1. C div2. In this problem some greedy solution expected.Let fix 2 planets: in planet i we will buy items, in planet j we will sell the ones. Profit of item of type k will be b_jk-a_ik. Every item has size 1, so you should greedy take items in order of decreasing of profits of items while you have place in the hold.Scheme of full solution: you should iterate over all pairs of planet, for every pair greedy take items and find total profit. At the end you should find maximal total profit over all pairs and output it.Author is RipattiB div1. D div2. You can see that split oparetion is just cyclically shift of string. You can go from any cyclically shift to any other one except the current one.Let's call some cyclically shift good iff it equal to the final string. All others cyclically shifts we will call bad. You can check all shifts in O(|w|2) time. Let's you have A good shifts and B bad ones.Let's define dpA[n] as number of ways to get some good shift using n splits and за dpB[n] as number of ways to get some bad shift using n splits.dpA[0]=1, dpB[0]=0 or dpA[0]=0, dpB[0]=1 according to the first shift is good or not. All other values of dp you can get using following reccurences:dpA[n] = dpA[n-1] * (A-1) + dpB[n-1] * AdpB[n] = dpA[n-1] * B + dpB[n-1] * (B-1)Answer will be dpA[k]. So you have O(|w|2 + k) solution.Also this problem can be solved in time.Author is havalizaC div1. E div2. The second player have easy strategy to hold some chip in position (X, Y) in one of four half-planes — x ≤ X + 2, x ≥ X - 2, y ≤ Y + 2 и y ≥ Y - 2. He can chose one of these half-planes by himself.So, in case max(|x1 - x2|, |y1 - y2|) > 4 the second player wins — he just holds chips in half-planes that have no common cells.Cases for max(|x1 - x2|, |y1 - y2|) ≤ 4 expected to solve using some bruteforce. You can see that moving chips in way of distancing from each other is not profitable for the first player. Therefore you can bruteforce the game in square no more than 5 × 5. If your bruteforce so slow and doesn't fit into 2 sec, you can use precalculation. Also you can write some dp using masks.Also you can check cases max(|x1 - x2|, |y1 - y2|) ≤ 4 by hand. But there you can easy make some mistakes.Author is RipattiD div1. Let's define dp[pre][len] as the minimal prefix of hyperstring that have with prefix of t of length len largest common sequence of length len.Then you have see reccurences:dp[pre][len] = min(dp[pre - 1][len],  leftmost position of letter s[pre] in t that right than dp[pre - 1][len - 1]).For finding value of the second part inside min-function of formula above in O(1), you should calculate some additional dp's: dp1 — for every basic string, positions inside of them and letter you should calculate leftmost position of current letter that right than current position;dp2 — for every element of array of basic strings (it is hyperstring) and letter you should calculate leftmost basic string that have current letter and this string is rinht than current basic string.So you have solution.Author is havaliza.E div1. At the first let's try to solve another problem: we have k chosed vertices in the tree and we want to find sum of subtree that \"spanned\" dy them in time (with any preprocessing time).Let's sort all k vertices in order of dfs traversal — v1, v2, ... , vk. Consider pathes v1-v2, v2-v3, ... , v(k-1)-vk and vk-v1. You can see that they cover only our requred subtree and every edge is covered exactly two times. So you can just find sum of lengths of these pathes (you can do it in required time using LCA algo) and divide obtained value by 2.For solving initial problem you should support set of active vertices in ordered state (for example, you can use std::set) and sum of all pathes between all neighbour vertices. Now you can process insert/remove queries in , and recalculate sum of pathes by finding no more than 3 new pathes also in .So you have solution.Author is Ripatti.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4372",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4850
        }
      ],
      "code_examples": [
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 1",
          "code": "x...\n....\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 2",
          "code": "x...\n....\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 3",
          "code": "x...\n.!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 4",
          "code": "x...\n.!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 5",
          "code": "x...\n.!..\n....\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 6",
          "code": "x...\n.!..\n....\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 7",
          "code": "x...\n.!..\n.!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 8",
          "code": "x...\n.!..\n.!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 9",
          "code": "....\nx!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 10",
          "code": "....\nx!..\n....\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 11",
          "code": "....\nx!..\n!...\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 12",
          "code": "....\nx!..\n!...\n...x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 13",
          "code": "....\nx!..\n!...\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 14",
          "code": "....\nx!..\n!...\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 15",
          "code": "....\nx!..\n!!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 - Codeforces - Code 16",
          "code": "....\nx!..\n!!..\n..x.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4370",
          "author": "Ripatti"
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces - Code 1",
          "code": "dpA[n] = dpA[n-1]*(A-1) + dpB[n-1]*A\ndpB[n] = dpA[n-1]*B + dpB[n-1](B-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4372",
          "author": "jiangly"
        },
        {
          "title": "Croc Champ 2012 — Round 2 — Editorial - Codeforces - Code 2",
          "code": "dpA[n] = dpA[n-1]*(A-1) + dpB[n-1]*A\ndpB[n] = dpA[n-1]*B + dpB[n-1](B-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4372",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int x1 = inf.readInt(1, n, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(1, m, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(1, n, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(1, m, \"y2\");\n    inf.readEoln();\n\n    ensuref(n * m >= 2, \"n * m must be at least 2 (n=%d, m=%d)\", n, m);\n    ensuref(x1 != x2 || y1 != y2, \"The chips must be on different squares (x1=%d, y1=%d, x2=%d, y2=%d)\", x1, y1, x2, y2);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int x1 = inf.readInt(1, n, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(1, m, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(1, n, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(1, m, \"y2\");\n    inf.readEoln();\n\n    ensuref(n * m >= 2, \"n * m must be at least 2 (n=%d, m=%d)\", n, m);\n    ensuref(x1 != x2 || y1 != y2, \"The chips must be on different squares (x1=%d, y1=%d, x2=%d, y2=%d)\", x1, y1, x2, y2);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int x1 = inf.readInt(1, n, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(1, m, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(1, n, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(1, m, \"y2\");\n    inf.readEoln();\n\n    ensuref(n * m >= 2, \"n * m must be at least 2 (n=%d, m=%d)\", n, m);\n    ensuref(x1 != x2 || y1 != y2, \"The chips must be on different squares (x1=%d, y1=%d, x2=%d, y2=%d)\", x1, y1, x2, y2);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that n and m are within constraints\n    ensure(1 <= n && n <= 100);\n    ensure(1 <= m && m <= 100);\n    ensure(n * m >= 2);\n\n    int x1, y1, x2, y2;\n\n    if (type == \"random\") {\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n\n        do {\n            x2 = rnd.next(1, n);\n            y2 = rnd.next(1, m);\n        } while (x1 == x2 && y1 == y2);\n    } else if (type == \"corner\") {\n        x1 = 1;\n        y1 = 1;\n        x2 = n;\n        y2 = m;\n        if (x1 == x2 && y1 == y2) {\n            // Adjust x2, y2 if necessary\n            x2 = n;\n            y2 = m - 1;\n            if (y2 < 1) y2 = 1;\n        }\n    } else if (type == \"adjacent\") {\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n\n        vector<pair<int,int>> directions = {{-1,0}, {1,0}, {0,-1}, {0,1}};\n        vector<pair<int,int>> adj_positions;\n\n        for (auto dir : directions) {\n            int nx = x1 + dir.first;\n            int ny = y1 + dir.second;\n            if (1 <= nx && nx <= n && 1 <= ny && ny <= m) {\n                adj_positions.push_back({nx, ny});\n            }\n        }\n\n        if (adj_positions.empty()) {\n            // No adjacent positions, pick another position\n            do {\n                x2 = rnd.next(1, n);\n                y2 = rnd.next(1, m);\n            } while (x1 == x2 && y1 == y2);\n        } else {\n            int idx = rnd.next(0, (int)adj_positions.size()-1);\n            x2 = adj_positions[idx].first;\n            y2 = adj_positions[idx].second;\n        }\n    } else if (type == \"same_row\") {\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n        do {\n            y2 = rnd.next(1, m);\n        } while (y2 == y1);\n        x2 = x1;\n    } else if (type == \"same_column\") {\n        y1 = rnd.next(1, m);\n        x1 = rnd.next(1, n);\n        do {\n            x2 = rnd.next(1, n);\n        } while (x2 == x1);\n        y2 = y1;\n    } else if (type == \"opposite_corners\") {\n        x1 = 1;\n        y1 = 1;\n        x2 = n;\n        y2 = m;\n        if (x1 == x2 && y1 == y2) {\n            // Adjust if necessary\n            x2 = n;\n            y2 = m - 1;\n            if (y2 < 1) y2 = 1;\n        }\n    } else if (type == \"maximal\") {\n        n = 100;\n        m = 100;\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n        do {\n            x2 = rnd.next(1, n);\n            y2 = rnd.next(1, m);\n        } while (x1 == x2 && y1 == y2);\n    } else {\n        // Default to random\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n\n        do {\n            x2 = rnd.next(1, n);\n            y2 = rnd.next(1, m);\n        } while (x1 == x2 && y1 == y2);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d %d %d\\n\", n, m, x1, y1, x2, y2);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that n and m are within constraints\n    ensure(1 <= n && n <= 100);\n    ensure(1 <= m && m <= 100);\n    ensure(n * m >= 2);\n\n    int x1, y1, x2, y2;\n\n    if (type == \"random\") {\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n\n        do {\n            x2 = rnd.next(1, n);\n            y2 = rnd.next(1, m);\n        } while (x1 == x2 && y1 == y2);\n    } else if (type == \"corner\") {\n        x1 = 1;\n        y1 = 1;\n        x2 = n;\n        y2 = m;\n        if (x1 == x2 && y1 == y2) {\n            // Adjust x2, y2 if necessary\n            x2 = n;\n            y2 = m - 1;\n            if (y2 < 1) y2 = 1;\n        }\n    } else if (type == \"adjacent\") {\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n\n        vector<pair<int,int>> directions = {{-1,0}, {1,0}, {0,-1}, {0,1}};\n        vector<pair<int,int>> adj_positions;\n\n        for (auto dir : directions) {\n            int nx = x1 + dir.first;\n            int ny = y1 + dir.second;\n            if (1 <= nx && nx <= n && 1 <= ny && ny <= m) {\n                adj_positions.push_back({nx, ny});\n            }\n        }\n\n        if (adj_positions.empty()) {\n            // No adjacent positions, pick another position\n            do {\n                x2 = rnd.next(1, n);\n                y2 = rnd.next(1, m);\n            } while (x1 == x2 && y1 == y2);\n        } else {\n            int idx = rnd.next(0, (int)adj_positions.size()-1);\n            x2 = adj_positions[idx].first;\n            y2 = adj_positions[idx].second;\n        }\n    } else if (type == \"same_row\") {\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n        do {\n            y2 = rnd.next(1, m);\n        } while (y2 == y1);\n        x2 = x1;\n    } else if (type == \"same_column\") {\n        y1 = rnd.next(1, m);\n        x1 = rnd.next(1, n);\n        do {\n            x2 = rnd.next(1, n);\n        } while (x2 == x1);\n        y2 = y1;\n    } else if (type == \"opposite_corners\") {\n        x1 = 1;\n        y1 = 1;\n        x2 = n;\n        y2 = m;\n        if (x1 == x2 && y1 == y2) {\n            // Adjust if necessary\n            x2 = n;\n            y2 = m - 1;\n            if (y2 < 1) y2 = 1;\n        }\n    } else if (type == \"maximal\") {\n        n = 100;\n        m = 100;\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n        do {\n            x2 = rnd.next(1, n);\n            y2 = rnd.next(1, m);\n        } while (x1 == x2 && y1 == y2);\n    } else {\n        // Default to random\n        x1 = rnd.next(1, n);\n        y1 = rnd.next(1, m);\n\n        do {\n            x2 = rnd.next(1, n);\n            y2 = rnd.next(1, m);\n        } while (x1 == x2 && y1 == y2);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d %d %d\\n\", n, m, x1, y1, x2, y2);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 2 -type random\n./gen -n 2 -m 1 -type random\n./gen -n 10 -m 10 -type random\n./gen -n 100 -m 100 -type random\n\n./gen -n 1 -m 100 -type corner\n./gen -n 100 -m 1 -type corner\n./gen -n 1 -m 2 -type adjacent\n./gen -n 2 -m 1 -type adjacent\n\n./gen -n 50 -m 50 -type same_row\n./gen -n 50 -m 50 -type same_column\n\n./gen -n 100 -m 100 -type opposite_corners\n\n./gen -n 100 -m 100 -type maximal\n\n./gen -n 10 -m 1 -type random\n./gen -n 1 -m 10 -type random\n\n./gen -n 20 -m 20 -type adjacent\n./gen -n 20 -m 20 -type opposite_corners\n./gen -n 1 -m 99 -type same_row\n./gen -n 99 -m 1 -type same_column\n\n./gen -n 2 -m 50 -type random\n./gen -n 50 -m 2 -type random\n\n./gen -n 2 -m 2 -type adjacent\n./gen -n 2 -m 2 -type random\n\n./gen -n 99 -m 99 -type random\n./gen -n 100 -m 1 -type adjacent\n\n./gen -n 3 -m 3 -type adjacent\n./gen -n 3 -m 3 -type random\n\n./gen -n 99 -m 100 -type random\n./gen -n 100 -m 99 -type random\n\n./gen -n 100 -m 100 -type random\n\n./gen -n 1 -m 3 -type same_row\n./gen -n 3 -m 1 -type same_column\n\n./gen -n 2 -m 2 -type same_row\n./gen -n 2 -m 2 -type same_column\n\n./gen -n 50 -m 50 -type corner\n./gen -n 50 -m 50 -type adjacent\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:51.554739",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "182/A",
      "title": "A. Поле битвы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке заданы два целых числа через пробел: a и b (1 ≤ a, b ≤ 1000), — продолжительность процесса зарядки лазера и продолжительность выстрела лазера в секундах.Во второй строке заданы четыре целых числа через пробел: Ax, Ay, Bx, By ( - 104 ≤ Ax, Ay, Bx, By ≤ 104) — координаты точек А и B. Гарантируется, что точки A и B не принадлежат никакой траншее.В третьей строке задано единственное целое число: n (1 ≤ n ≤ 1000), — количество траншей. В каждой из следующих n строк задано по четыре целых числа через пробел: x1, y1, x2, y2 ( - 104 ≤ xi, yi ≤ 104) — координаты концов соответствующей траншеи.Все координаты заданы в метрах. Гарантируется, что для каждой траншеи либо x1 = x2, либо y1 = y2. Никакие две траншеи не пересекаются. Длина любой траншеи в метрах численно не превосходит b.",
      "output_spec": "Выходные данныеЕсли Вася может попасть из точки A в точку B, то выведите минимальное время, которое ему для этого потребуется. Иначе выведите число -1.Ответ будет считаться правильным, если абсолютная или относительная погрешность не превышает 10 - 4",
      "sample_tests": "ПримерыВходные данныеСкопировать2 40 5 6 530 0 0 41 1 4 16 0 6 4Выходные данныеСкопировать19.0000000000Входные данныеСкопировать5 100 0 10 1015 0 5 9Выходные данныеСкопировать-1",
      "description": "A. Поле битвы\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке заданы два целых числа через пробел: a и b (1 ≤ a, b ≤ 1000), — продолжительность процесса зарядки лазера и продолжительность выстрела лазера в секундах.Во второй строке заданы четыре целых числа через пробел: Ax, Ay, Bx, By ( - 104 ≤ Ax, Ay, Bx, By ≤ 104) — координаты точек А и B. Гарантируется, что точки A и B не принадлежат никакой траншее.В третьей строке задано единственное целое число: n (1 ≤ n ≤ 1000), — количество траншей. В каждой из следующих n строк задано по четыре целых числа через пробел: x1, y1, x2, y2 ( - 104 ≤ xi, yi ≤ 104) — координаты концов соответствующей траншеи.Все координаты заданы в метрах. Гарантируется, что для каждой траншеи либо x1 = x2, либо y1 = y2. Никакие две траншеи не пересекаются. Длина любой траншеи в метрах численно не превосходит b.\n\nВходные данные\n\nВыходные данныеЕсли Вася может попасть из точки A в точку B, то выведите минимальное время, которое ему для этого потребуется. Иначе выведите число -1.Ответ будет считаться правильным, если абсолютная или относительная погрешность не превышает 10 - 4\n\nВыходные данные\n\nВходные данныеСкопировать2 40 5 6 530 0 0 41 1 4 16 0 6 4Выходные данныеСкопировать19.0000000000Входные данныеСкопировать5 100 0 10 1015 0 5 9Выходные данныеСкопировать-1\n\nВходные данныеСкопировать2 40 5 6 530 0 0 41 1 4 16 0 6 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать19.0000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 100 0 10 1015 0 5 9\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces",
          "content": "Всем здравствуйте)Рады приветствовать вас на очередном раунде Codeforces #117 для участников Div. 2. Традиционно, остальные могут поучаствовать в нем вне конкурса.Задачи для вас были подготовлены группой авторов в составе: Павел Холкин (HolkinPV), Иван Фефер (Fefer_Ivan), Николай Кузнецов (NALP) и Геральд Агапов (Gerald). Мы благодарим Михаила Мирзаянова (MikeMirzayanov) за систему Codeforces и Марию Белову (Delinur) за перевод условий.Распределение баллов вновь будет динамическим) Подробнее об этом можно найти здесь.Обращаем внимание, что все задачи сегодня будут даны в произвольном порядке.Некоторые участники Див. 1 зарегистрировались на соревнование раньше, чем была произведена настройка регистрации. До начала раунда это будет исправлено, и они будут участвовать вне конкурса.Надеемся раунд пройдет успешно и всем понравится. Желаем удачи и высокого рейтинга!UPD: условие задачи 182E - Деревянный забор было сформулировано неверно, что привело к несоответствию решений, правильный вариант условия появится совсем скоро, приносим участникам свои извинения.UPD2: контест объявлен нерейтинговым.UPD3: разбор задач можно найти здесь",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4403",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 182"
          },
          "content_length": 1141
        },
        {
          "title": "Codeforces Round #117 (Div. 2) Разбор Задач - Codeforces",
          "content": "Приветствую всех участников раунда!Давайте проведем разбор задач в примерном порядке их сложности182B - Vasya's CalendarОбратим внимание, что Вася должен вручную прибавлять номер дня только тогда, когда заканчивается один месяц, и начинается следующий. Значит, пусть у нас в текущем месяце было x дней, а в следующем уже y. Тогда в первый день следующего месяца часы будут показывать день x + 1 (не забываем про модуль d), а должен показывать номер 1.Очевидно, что Вася должен вручную прибавить d - x дней, чтобы часы показывали то, что нужно.Значит, ответ — это сумма всех чисел d - ai, где 1 ≤ i < n.182D - Common DivisorsЭта задача решается многими способами, но самый простой подход следующий: найдем все делители строки s1, все делители s2 и найдем пересечение этих двух множеств.Как же найти все делители строки? Пусть t — это делитель строки s. Тогда очевидно, что |s| = 0(mod|t|), а также t является префиксом строки s. Эти соображения и позволяют найти все делители строки, а именно переберем длину префикса, проверим делимость, а потом проверим, что префикс записанный подряд нужное количество раз совпадает с s.Всего подходящих префиксов не более , проверка каждого работает за O(|s|), значит, итоговое решение за , где n = max(|s|, |t|).Найти пересечение двух множеств строк несложно, можно воспользоваться стандартными структурами данных182E - Wooden FenceУсловие задачи было сформулировано неверно, что привело к несоответствию решений, правильный вариант условия появится совсем скоро, приносим участникам свои извинения.Основа решения этой задачи — это динамическое программирование.Состояние — (last, type, l), где last — номер последней доски, type характеризует поворот последней доски, а l — длина оставшейся части забора.Пересчитывать эту динамику тоже очень просто: переберем номер следующей доски, ее поворот, проверим подходит ли она в текущее состояние, и прибавим нужную величину.Асимпотика решения — O(n2·len).182C - Optimal SumПредставим мысленно задачу в виде движения слева направо некоторого окошка длины len по исходному массиву. То есть нам нужно найти способ достичь максимума в выбранном окошке, а потом сместить его на одну ячейку вправо.Пусть мы зафиксировали положения окошка, теперь посчитаем ответ. Для этого отдельно запишем все положительные и все отрицательные числа в окошке. Если положительных не больше, чем k, или отрицательных не больше k, то мы можем все числа сделать одинакового знака, и ответ — это сумма модулей чисел в подмассиве. Это простой случай.Несложно понять, что невыгодно некоторые отрицательные числа делать положительными и одновременно некоторые положительные — отрицательными. То есть мы обязательно выберем знак <<+>> или <<->> и k чисел этого знака сделаем противоположными. Также несложно понять, что всегда при смене знака у некоторых чисел выгодно брать ровно k максимальных по модулю чисел этого знака.Для того, чтобы поддерживать движение окошка будем использовать два отдельных дерева отрезков: одно для отрицательных, другое для положительных чисел.Если в вершине дерева хранить пару (количество чисел в поддереве, сумма этих чисел), то такая структура умеет возвращать сумму k максимальных чисел, что нам и требуется.Асимптотика решения — O(n·log(n)).182A - BattlefieldВ этой задаче есть два главных момента: длина любой траншеи в метрах численно не превосходит b траншеи не пересекаются Первый пункт означает, что если Вася забегает в траншею чтобы переждать, пока лазер работает, то за это время он может придти в любую его точку.Второй пункт означает, что пока лазер работает, Вася обязан находиться в той траншее, в которой он на данный момент сидит.Значит, путь Васи — это перебежки от одной траншеи к другой, где он пережидает лазерную атаку. Таким образом все решение задачи — это найти кратчайший по времени путь по траншеям от стартовой точки до конечной (их мы тоже будем считать траншеями, просто нулевой длины), для этого нужно всего лишь предподсчитать матрицу расстояний между отрезками траншей и запустить алгоритм, например, Дейкстры.Два тонких момента: мы не можем перебегать между траншеями, если между ними расстояние больше a пусть Вася прибежал в момент времени t, теперь нам нужно найти момент, когда он сможет убежать дальше. Для этого нужно найти следующий момент времени, когда лазер будет перезаряжаться. Эта величина T несложно ищется по формуле: Асимптотика решения — O(n2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4408",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 182\\s*A"
          },
          "content_length": 4379
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 1",
          "code": "And again score distribution will be dynamic) More information you can find here.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 2",
          "code": "Два забора будем считать одинаковыми, если соответствующие последовательности типов древесины досок заборов совпадают, в противном случае заборы различны.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 3",
          "code": "Два забора будем считать одинаковыми, если соответствующие последовательности типов древесины досок заборов совпадают, в противном случае заборы различны.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 4",
          "code": "6 3\n1 1 1 -2 10 -9\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 5",
          "code": "6 3\n1 1 1 -2 10 -9\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 6",
          "code": "there are no two successive boards of the same type",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 7",
          "code": "there are no two successive boards of the same type",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 8",
          "code": "while (!haveSolution) {\n    head.turnOn();\n    if (head.think() == SOLUTION) {\n        haveSolution = true;\n    }\n}\nfingers.codeSolution();\nsoul.enjoy();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 9",
          "code": "while (!haveSolution) {\n    head.turnOn();\n    if (head.think() == SOLUTION) {\n        haveSolution = true;\n    }\n}\nfingers.codeSolution();\nsoul.enjoy();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 10",
          "code": "while (!haveSolution) {\n    head.turnLeft();\n    ...\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 11",
          "code": "while (!haveSolution) {\n    head.turnLeft();\n    ...\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 12",
          "code": "UPD1: А в чём причина хоть?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 13",
          "code": "UPD1: А в чём причина хоть?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 14",
          "code": "UPD2:'Условие задачи было сформулировано неверно, что привело к несоответствию решений, правильный вариант условия появится совсем скоро, приносим участникам свои извинения.'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 15",
          "code": "UPD2:'Условие задачи было сформулировано неверно, что привело к несоответствию решений, правильный вариант условия появится совсем скоро, приносим участникам свои извинения.'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 16",
          "code": "7 6 \n-4 2 -2 -4 0 3 5 \n2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 17",
          "code": "7 6 \n-4 2 -2 -4 0 3 5 \n2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 18",
          "code": "7 2 \n5 1 -3 -4 -1 -5 1 \n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 19",
          "code": "7 2 \n5 1 -3 -4 -1 -5 1 \n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) Разбор Задач - Codeforces - Code 1",
          "code": "if (s.count(x)==0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4408",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) Разбор Задач - Codeforces - Code 2",
          "code": "if (s.find(x)!=s.end())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4408",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) Разбор Задач - Codeforces - Code 3",
          "code": "s.erase(val)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4408",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) Разбор Задач - Codeforces - Code 4",
          "code": "100 150  \n1 2  \n1 2  \n...  \n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4408",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) Разбор Задач - Codeforces - Code 5",
          "code": "100 150  \n1 2  \n1 2  \n...  \n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4408",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Trench {\n    int x1, y1, x2, y2;\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read a and b\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readEoln();\n\n    // Read Ax, Ay, Bx, By\n    int Ax = inf.readInt(-10000, 10000, \"Ax\");\n    inf.readSpace();\n    int Ay = inf.readInt(-10000, 10000, \"Ay\");\n    inf.readSpace();\n    int Bx = inf.readInt(-10000, 10000, \"Bx\");\n    inf.readSpace();\n    int By = inf.readInt(-10000, 10000, \"By\");\n    inf.readEoln();\n\n    // Read n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    vector<Trench> trenches(n);\n\n    for (int i = 0; i < n; ++i) {\n        int x1 = inf.readInt(-10000, 10000, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(-10000, 10000, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(-10000, 10000, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(-10000, 10000, \"y2\");\n        inf.readEoln();\n\n        // Ensure either x1 == x2 or y1 == y2 (axis-aligned trench)\n        ensuref(x1 == x2 || y1 == y2, \n            \"Trench %d is not axis-aligned (x1=%d, y1=%d, x2=%d, y2=%d)\", i+1, x1, y1, x2, y2);\n\n        // Check trench length ≤ b\n        int length = (x1 == x2) ? abs(y1 - y2) : abs(x1 - x2);\n        ensuref(length <= b, \n            \"Length of trench %d exceeds b (length=%d, b=%d)\", i+1, length, b);\n\n        trenches[i] = {x1, y1, x2, y2};\n    }\n\n    // Check that points A and B are not on any trench\n    for (int i = 0; i < n; ++i) {\n        const Trench& t = trenches[i];\n        // Check if A lies on trench t\n        if (t.x1 == t.x2) { // Vertical trench\n            if (Ax == t.x1 && min(t.y1, t.y2) <= Ay && Ay <= max(t.y1, t.y2)) {\n                ensuref(false, \"Point A lies on trench %d\", i+1);\n            }\n        } else { // Horizontal trench\n            if (Ay == t.y1 && min(t.x1, t.x2) <= Ax && Ax <= max(t.x1, t.x2)) {\n                ensuref(false, \"Point A lies on trench %d\", i+1);\n            }\n        }\n        // Check if B lies on trench t\n        if (t.x1 == t.x2) { // Vertical trench\n            if (Bx == t.x1 && min(t.y1, t.y2) <= By && By <= max(t.y1, t.y2)) {\n                ensuref(false, \"Point B lies on trench %d\", i+1);\n            }\n        } else { // Horizontal trench\n            if (By == t.y1 && min(t.x1, t.x2) <= Bx && Bx <= max(t.x1, t.x2)) {\n                ensuref(false, \"Point B lies on trench %d\", i+1);\n            }\n        }\n    }\n\n    // Check that no two trenches intersect\n    for (int i = 0; i < n; ++i) {\n        const Trench& t1 = trenches[i];\n        for (int j = i + 1; j < n; ++j) {\n            const Trench& t2 = trenches[j];\n            bool intersects = false;\n\n            if (t1.x1 == t1.x2 && t2.x1 == t2.x2) {\n                // Both vertical\n                if (t1.x1 == t2.x1) {\n                    int y1min = min(t1.y1, t1.y2);\n                    int y1max = max(t1.y1, t1.y2);\n                    int y2min = min(t2.y1, t2.y2);\n                    int y2max = max(t2.y1, t2.y2);\n                    if (!(y1max < y2min || y2max < y1min)) {\n                        intersects = true;\n                    }\n                }\n            } else if (t1.y1 == t1.y2 && t2.y1 == t2.y2) {\n                // Both horizontal\n                if (t1.y1 == t2.y1) {\n                    int x1min = min(t1.x1, t1.x2);\n                    int x1max = max(t1.x1, t1.x2);\n                    int x2min = min(t2.x1, t2.x2);\n                    int x2max = max(t2.x1, t2.x2);\n                    if (!(x1max < x2min || x2max < x1min)) {\n                        intersects = true;\n                    }\n                }\n            } else {\n                // One vertical, one horizontal\n                // Check if they intersect at a point\n                if (t1.x1 == t1.x2 && t2.y1 == t2.y2) {\n                    // t1 is vertical, t2 is horizontal\n                    int x = t1.x1, y = t2.y1;\n                    if (min(t1.y1, t1.y2) <= y && y <= max(t1.y1, t1.y2) &&\n                        min(t2.x1, t2.x2) <= x && x <= max(t2.x1, t2.x2)) {\n                        intersects = true;\n                    }\n                } else if (t1.y1 == t1.y2 && t2.x1 == t2.x2) {\n                    // t1 is horizontal, t2 is vertical\n                    int x = t2.x1, y = t1.y1;\n                    if (min(t1.x1, t1.x2) <= x && x <= max(t1.x1, t1.x2) &&\n                        min(t2.y1, t2.y2) <= y && y <= max(t2.y1, t2.y2)) {\n                        intersects = true;\n                    }\n                }\n            }\n\n            if (intersects) {\n                ensuref(false, \"Trenches %d and %d intersect\", i+1, j+1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Trench {\n    int x1, y1, x2, y2;\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read a and b\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readEoln();\n\n    // Read Ax, Ay, Bx, By\n    int Ax = inf.readInt(-10000, 10000, \"Ax\");\n    inf.readSpace();\n    int Ay = inf.readInt(-10000, 10000, \"Ay\");\n    inf.readSpace();\n    int Bx = inf.readInt(-10000, 10000, \"Bx\");\n    inf.readSpace();\n    int By = inf.readInt(-10000, 10000, \"By\");\n    inf.readEoln();\n\n    // Read n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    vector<Trench> trenches(n);\n\n    for (int i = 0; i < n; ++i) {\n        int x1 = inf.readInt(-10000, 10000, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(-10000, 10000, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(-10000, 10000, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(-10000, 10000, \"y2\");\n        inf.readEoln();\n\n        // Ensure either x1 == x2 or y1 == y2 (axis-aligned trench)\n        ensuref(x1 == x2 || y1 == y2, \n            \"Trench %d is not axis-aligned (x1=%d, y1=%d, x2=%d, y2=%d)\", i+1, x1, y1, x2, y2);\n\n        // Check trench length ≤ b\n        int length = (x1 == x2) ? abs(y1 - y2) : abs(x1 - x2);\n        ensuref(length <= b, \n            \"Length of trench %d exceeds b (length=%d, b=%d)\", i+1, length, b);\n\n        trenches[i] = {x1, y1, x2, y2};\n    }\n\n    // Check that points A and B are not on any trench\n    for (int i = 0; i < n; ++i) {\n        const Trench& t = trenches[i];\n        // Check if A lies on trench t\n        if (t.x1 == t.x2) { // Vertical trench\n            if (Ax == t.x1 && min(t.y1, t.y2) <= Ay && Ay <= max(t.y1, t.y2)) {\n                ensuref(false, \"Point A lies on trench %d\", i+1);\n            }\n        } else { // Horizontal trench\n            if (Ay == t.y1 && min(t.x1, t.x2) <= Ax && Ax <= max(t.x1, t.x2)) {\n                ensuref(false, \"Point A lies on trench %d\", i+1);\n            }\n        }\n        // Check if B lies on trench t\n        if (t.x1 == t.x2) { // Vertical trench\n            if (Bx == t.x1 && min(t.y1, t.y2) <= By && By <= max(t.y1, t.y2)) {\n                ensuref(false, \"Point B lies on trench %d\", i+1);\n            }\n        } else { // Horizontal trench\n            if (By == t.y1 && min(t.x1, t.x2) <= Bx && Bx <= max(t.x1, t.x2)) {\n                ensuref(false, \"Point B lies on trench %d\", i+1);\n            }\n        }\n    }\n\n    // Check that no two trenches intersect\n    for (int i = 0; i < n; ++i) {\n        const Trench& t1 = trenches[i];\n        for (int j = i + 1; j < n; ++j) {\n            const Trench& t2 = trenches[j];\n            bool intersects = false;\n\n            if (t1.x1 == t1.x2 && t2.x1 == t2.x2) {\n                // Both vertical\n                if (t1.x1 == t2.x1) {\n                    int y1min = min(t1.y1, t1.y2);\n                    int y1max = max(t1.y1, t1.y2);\n                    int y2min = min(t2.y1, t2.y2);\n                    int y2max = max(t2.y1, t2.y2);\n                    if (!(y1max < y2min || y2max < y1min)) {\n                        intersects = true;\n                    }\n                }\n            } else if (t1.y1 == t1.y2 && t2.y1 == t2.y2) {\n                // Both horizontal\n                if (t1.y1 == t2.y1) {\n                    int x1min = min(t1.x1, t1.x2);\n                    int x1max = max(t1.x1, t1.x2);\n                    int x2min = min(t2.x1, t2.x2);\n                    int x2max = max(t2.x1, t2.x2);\n                    if (!(x1max < x2min || x2max < x1min)) {\n                        intersects = true;\n                    }\n                }\n            } else {\n                // One vertical, one horizontal\n                // Check if they intersect at a point\n                if (t1.x1 == t1.x2 && t2.y1 == t2.y2) {\n                    // t1 is vertical, t2 is horizontal\n                    int x = t1.x1, y = t2.y1;\n                    if (min(t1.y1, t1.y2) <= y && y <= max(t1.y1, t1.y2) &&\n                        min(t2.x1, t2.x2) <= x && x <= max(t2.x1, t2.x2)) {\n                        intersects = true;\n                    }\n                } else if (t1.y1 == t1.y2 && t2.x1 == t2.x2) {\n                    // t1 is horizontal, t2 is vertical\n                    int x = t2.x1, y = t1.y1;\n                    if (min(t1.x1, t1.x2) <= x && x <= max(t1.x1, t1.x2) &&\n                        min(t2.y1, t2.y2) <= y && y <= max(t2.y1, t2.y2)) {\n                        intersects = true;\n                    }\n                }\n            }\n\n            if (intersects) {\n                ensuref(false, \"Trenches %d and %d intersect\", i+1, j+1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Trench {\n    int x1, y1, x2, y2;\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read a and b\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readEoln();\n\n    // Read Ax, Ay, Bx, By\n    int Ax = inf.readInt(-10000, 10000, \"Ax\");\n    inf.readSpace();\n    int Ay = inf.readInt(-10000, 10000, \"Ay\");\n    inf.readSpace();\n    int Bx = inf.readInt(-10000, 10000, \"Bx\");\n    inf.readSpace();\n    int By = inf.readInt(-10000, 10000, \"By\");\n    inf.readEoln();\n\n    // Read n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    vector<Trench> trenches(n);\n\n    for (int i = 0; i < n; ++i) {\n        int x1 = inf.readInt(-10000, 10000, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(-10000, 10000, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(-10000, 10000, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(-10000, 10000, \"y2\");\n        inf.readEoln();\n\n        // Ensure either x1 == x2 or y1 == y2 (axis-aligned trench)\n        ensuref(x1 == x2 || y1 == y2, \n            \"Trench %d is not axis-aligned (x1=%d, y1=%d, x2=%d, y2=%d)\", i+1, x1, y1, x2, y2);\n\n        // Check trench length ≤ b\n        int length = (x1 == x2) ? abs(y1 - y2) : abs(x1 - x2);\n        ensuref(length <= b, \n            \"Length of trench %d exceeds b (length=%d, b=%d)\", i+1, length, b);\n\n        trenches[i] = {x1, y1, x2, y2};\n    }\n\n    // Check that points A and B are not on any trench\n    for (int i = 0; i < n; ++i) {\n        const Trench& t = trenches[i];\n        // Check if A lies on trench t\n        if (t.x1 == t.x2) { // Vertical trench\n            if (Ax == t.x1 && min(t.y1, t.y2) <= Ay && Ay <= max(t.y1, t.y2)) {\n                ensuref(false, \"Point A lies on trench %d\", i+1);\n            }\n        } else { // Horizontal trench\n            if (Ay == t.y1 && min(t.x1, t.x2) <= Ax && Ax <= max(t.x1, t.x2)) {\n                ensuref(false, \"Point A lies on trench %d\", i+1);\n            }\n        }\n        // Check if B lies on trench t\n        if (t.x1 == t.x2) { // Vertical trench\n            if (Bx == t.x1 && min(t.y1, t.y2) <= By && By <= max(t.y1, t.y2)) {\n                ensuref(false, \"Point B lies on trench %d\", i+1);\n            }\n        } else { // Horizontal trench\n            if (By == t.y1 && min(t.x1, t.x2) <= Bx && Bx <= max(t.x1, t.x2)) {\n                ensuref(false, \"Point B lies on trench %d\", i+1);\n            }\n        }\n    }\n\n    // Check that no two trenches intersect\n    for (int i = 0; i < n; ++i) {\n        const Trench& t1 = trenches[i];\n        for (int j = i + 1; j < n; ++j) {\n            const Trench& t2 = trenches[j];\n            bool intersects = false;\n\n            if (t1.x1 == t1.x2 && t2.x1 == t2.x2) {\n                // Both vertical\n                if (t1.x1 == t2.x1) {\n                    int y1min = min(t1.y1, t1.y2);\n                    int y1max = max(t1.y1, t1.y2);\n                    int y2min = min(t2.y1, t2.y2);\n                    int y2max = max(t2.y1, t2.y2);\n                    if (!(y1max < y2min || y2max < y1min)) {\n                        intersects = true;\n                    }\n                }\n            } else if (t1.y1 == t1.y2 && t2.y1 == t2.y2) {\n                // Both horizontal\n                if (t1.y1 == t2.y1) {\n                    int x1min = min(t1.x1, t1.x2);\n                    int x1max = max(t1.x1, t1.x2);\n                    int x2min = min(t2.x1, t2.x2);\n                    int x2max = max(t2.x1, t2.x2);\n                    if (!(x1max < x2min || x2max < x1min)) {\n                        intersects = true;\n                    }\n                }\n            } else {\n                // One vertical, one horizontal\n                // Check if they intersect at a point\n                if (t1.x1 == t1.x2 && t2.y1 == t2.y2) {\n                    // t1 is vertical, t2 is horizontal\n                    int x = t1.x1, y = t2.y1;\n                    if (min(t1.y1, t1.y2) <= y && y <= max(t1.y1, t1.y2) &&\n                        min(t2.x1, t2.x2) <= x && x <= max(t2.x1, t2.x2)) {\n                        intersects = true;\n                    }\n                } else if (t1.y1 == t1.y2 && t2.x1 == t2.x2) {\n                    // t1 is horizontal, t2 is vertical\n                    int x = t2.x1, y = t1.y1;\n                    if (min(t1.x1, t1.x2) <= x && x <= max(t1.x1, t1.x2) &&\n                        min(t2.y1, t2.y2) <= y && y <= max(t2.y1, t2.y2)) {\n                        intersects = true;\n                    }\n                }\n            }\n\n            if (intersects) {\n                ensuref(false, \"Trenches %d and %d intersect\", i+1, j+1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-4;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.5f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.5f', found: '%.5f', error = '%.5f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.5f', expected '%.5f', error '%.5f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Trench {\n    int x1, y1, x2, y2;\n};\n\nbool isIntersect(const Trench& t1, const Trench& t2) {\n    // Check if t1 and t2 intersect\n\n    // Determine if t1 is horizontal or vertical\n    bool t1_is_horizontal = (t1.y1 == t1.y2);\n    bool t2_is_horizontal = (t2.y1 == t2.y2);\n\n    if (t1_is_horizontal && t2_is_horizontal) {\n        // Both horizontal\n        if (t1.y1 != t2.y1) return false;\n        // Check if x ranges overlap\n        int t1_xmin = min(t1.x1, t1.x2);\n        int t1_xmax = max(t1.x1, t1.x2);\n        int t2_xmin = min(t2.x1, t2.x2);\n        int t2_xmax = max(t2.x1, t2.x2);\n        return max(t1_xmin, t2_xmin) <= min(t1_xmax, t2_xmax);\n    } else if (!t1_is_horizontal && !t2_is_horizontal) {\n        // Both vertical\n        if (t1.x1 != t2.x1) return false;\n        // Check if y ranges overlap\n        int t1_ymin = min(t1.y1, t1.y2);\n        int t1_ymax = max(t1.y1, t1.y2);\n        int t2_ymin = min(t2.y1, t2.y2);\n        int t2_ymax = max(t2.y1, t2.y2);\n        return max(t1_ymin, t2_ymin) <= min(t1_ymax, t2_ymax);\n    } else {\n        // One is horizontal, one is vertical\n        Trench h = t1_is_horizontal ? t1 : t2;\n        Trench v = t1_is_horizontal ? t2 : t1;\n        int h_xmin = min(h.x1, h.x2);\n        int h_xmax = max(h.x1, h.x2);\n        int v_ymin = min(v.y1, v.y2);\n        int v_ymax = max(v.y1, v.y2);\n        // Check if the vertical line x == v.x1 crosses horizontal segment h.x1 to h.x2 at y == h.y1\n        return (v.x1 >= h_xmin && v.x1 <= h_xmax) && (h.y1 >= v_ymin && h.y1 <= v_ymax);\n    }\n}\n\nbool pointOnTrench(int x, int y, const Trench& t) {\n    // Check if point (x, y) lies on the trench t\n    if (t.x1 == t.x2) {\n        // Vertical trench\n        if (x != t.x1) return false;\n        int ymin = min(t.y1, t.y2);\n        int ymax = max(t.y1, t.y2);\n        return y >= ymin && y <= ymax;\n    } else {\n        // Horizontal trench\n        if (y != t.y1) return false;\n        int xmin = min(t.x1, t.x2);\n        int xmax = max(t.x1, t.x2);\n        return x >= xmin && x <= xmax;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 100);\n    int maxc = opt<int>(\"maxc\", 10000);\n    int a = opt<int>(\"a\", 500);\n    int b = opt<int>(\"b\", 500);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate a and b within constraints\n    a = max(1, min(1000, a));\n    b = max(1, min(1000, b));\n\n    int Ax = rnd.next(-maxc, maxc);\n    int Ay = rnd.next(-maxc, maxc);\n    int Bx = rnd.next(-maxc, maxc);\n    int By = rnd.next(-maxc, maxc);\n\n    vector<Trench> trenches;\n\n    int attempts = 0;\n\n    while ((int)trenches.size() < n && attempts < n * 10) {\n        attempts++;\n        // Decide whether the trench is horizontal or vertical\n        bool is_horizontal = rnd.next(0, 1);\n        Trench t;\n        if (is_horizontal) {\n            // y1 == y2\n            t.y1 = t.y2 = rnd.next(-maxc, maxc);\n            int length = rnd.next(1, b);\n            t.x1 = rnd.next(-maxc, maxc - length);\n            t.x2 = t.x1 + length;\n            if (t.x1 > t.x2) swap(t.x1, t.x2);\n        } else {\n            // x1 == x2\n            t.x1 = t.x2 = rnd.next(-maxc, maxc);\n            int length = rnd.next(1, b);\n            t.y1 = rnd.next(-maxc, maxc - length);\n            t.y2 = t.y1 + length;\n            if (t.y1 > t.y2) swap(t.y1, t.y2);\n        }\n\n        // Ensure no intersection with existing trenches\n        bool intersects = false;\n        for (const Trench& existing : trenches) {\n            if (isIntersect(t, existing)) {\n                intersects = true;\n                break;\n            }\n        }\n        if (intersects) continue;\n\n        // Ensure trench does not contain A or B\n        if (pointOnTrench(Ax, Ay, t)) continue;\n        if (pointOnTrench(Bx, By, t)) continue;\n\n        // Trench is acceptable\n        trenches.push_back(t);\n    }\n\n    if ((int)trenches.size() < n) {\n        // Not enough trenches generated within the allowed attempts\n        fprintf(stderr, \"Not enough trenches could be generated.\\n\");\n        exit(1);\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", a, b);\n    printf(\"%d %d %d %d\\n\", Ax, Ay, Bx, By);\n    printf(\"%d\\n\", n);\n    for (const Trench& t : trenches) {\n        printf(\"%d %d %d %d\\n\", t.x1, t.y1, t.x2, t.y2);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Trench {\n    int x1, y1, x2, y2;\n};\n\nbool isIntersect(const Trench& t1, const Trench& t2) {\n    // Check if t1 and t2 intersect\n\n    // Determine if t1 is horizontal or vertical\n    bool t1_is_horizontal = (t1.y1 == t1.y2);\n    bool t2_is_horizontal = (t2.y1 == t2.y2);\n\n    if (t1_is_horizontal && t2_is_horizontal) {\n        // Both horizontal\n        if (t1.y1 != t2.y1) return false;\n        // Check if x ranges overlap\n        int t1_xmin = min(t1.x1, t1.x2);\n        int t1_xmax = max(t1.x1, t1.x2);\n        int t2_xmin = min(t2.x1, t2.x2);\n        int t2_xmax = max(t2.x1, t2.x2);\n        return max(t1_xmin, t2_xmin) <= min(t1_xmax, t2_xmax);\n    } else if (!t1_is_horizontal && !t2_is_horizontal) {\n        // Both vertical\n        if (t1.x1 != t2.x1) return false;\n        // Check if y ranges overlap\n        int t1_ymin = min(t1.y1, t1.y2);\n        int t1_ymax = max(t1.y1, t1.y2);\n        int t2_ymin = min(t2.y1, t2.y2);\n        int t2_ymax = max(t2.y1, t2.y2);\n        return max(t1_ymin, t2_ymin) <= min(t1_ymax, t2_ymax);\n    } else {\n        // One is horizontal, one is vertical\n        Trench h = t1_is_horizontal ? t1 : t2;\n        Trench v = t1_is_horizontal ? t2 : t1;\n        int h_xmin = min(h.x1, h.x2);\n        int h_xmax = max(h.x1, h.x2);\n        int v_ymin = min(v.y1, v.y2);\n        int v_ymax = max(v.y1, v.y2);\n        // Check if the vertical line x == v.x1 crosses horizontal segment h.x1 to h.x2 at y == h.y1\n        return (v.x1 >= h_xmin && v.x1 <= h_xmax) && (h.y1 >= v_ymin && h.y1 <= v_ymax);\n    }\n}\n\nbool pointOnTrench(int x, int y, const Trench& t) {\n    // Check if point (x, y) lies on the trench t\n    if (t.x1 == t.x2) {\n        // Vertical trench\n        if (x != t.x1) return false;\n        int ymin = min(t.y1, t.y2);\n        int ymax = max(t.y1, t.y2);\n        return y >= ymin && y <= ymax;\n    } else {\n        // Horizontal trench\n        if (y != t.y1) return false;\n        int xmin = min(t.x1, t.x2);\n        int xmax = max(t.x1, t.x2);\n        return x >= xmin && x <= xmax;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 100);\n    int maxc = opt<int>(\"maxc\", 10000);\n    int a = opt<int>(\"a\", 500);\n    int b = opt<int>(\"b\", 500);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate a and b within constraints\n    a = max(1, min(1000, a));\n    b = max(1, min(1000, b));\n\n    int Ax = rnd.next(-maxc, maxc);\n    int Ay = rnd.next(-maxc, maxc);\n    int Bx = rnd.next(-maxc, maxc);\n    int By = rnd.next(-maxc, maxc);\n\n    vector<Trench> trenches;\n\n    int attempts = 0;\n\n    while ((int)trenches.size() < n && attempts < n * 10) {\n        attempts++;\n        // Decide whether the trench is horizontal or vertical\n        bool is_horizontal = rnd.next(0, 1);\n        Trench t;\n        if (is_horizontal) {\n            // y1 == y2\n            t.y1 = t.y2 = rnd.next(-maxc, maxc);\n            int length = rnd.next(1, b);\n            t.x1 = rnd.next(-maxc, maxc - length);\n            t.x2 = t.x1 + length;\n            if (t.x1 > t.x2) swap(t.x1, t.x2);\n        } else {\n            // x1 == x2\n            t.x1 = t.x2 = rnd.next(-maxc, maxc);\n            int length = rnd.next(1, b);\n            t.y1 = rnd.next(-maxc, maxc - length);\n            t.y2 = t.y1 + length;\n            if (t.y1 > t.y2) swap(t.y1, t.y2);\n        }\n\n        // Ensure no intersection with existing trenches\n        bool intersects = false;\n        for (const Trench& existing : trenches) {\n            if (isIntersect(t, existing)) {\n                intersects = true;\n                break;\n            }\n        }\n        if (intersects) continue;\n\n        // Ensure trench does not contain A or B\n        if (pointOnTrench(Ax, Ay, t)) continue;\n        if (pointOnTrench(Bx, By, t)) continue;\n\n        // Trench is acceptable\n        trenches.push_back(t);\n    }\n\n    if ((int)trenches.size() < n) {\n        // Not enough trenches generated within the allowed attempts\n        fprintf(stderr, \"Not enough trenches could be generated.\\n\");\n        exit(1);\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", a, b);\n    printf(\"%d %d %d %d\\n\", Ax, Ay, Bx, By);\n    printf(\"%d\\n\", n);\n    for (const Trench& t : trenches) {\n        printf(\"%d %d %d %d\\n\", t.x1, t.y1, t.x2, t.y2);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1\n./gen -n 10\n./gen -n 100\n./gen -n 500\n./gen -n 1000\n\n./gen -n 1000 -a 1 -b 1\n./gen -n 1000 -a 1000 -b 1000\n./gen -n 1000 -maxc 1000\n./gen -n 1000 -maxc 10000\n\n./gen -n 1000 -type random\n\n./gen -n 500 -type random\n\n./gen -n 200 -type random\n\n./gen -n 300 -type random\n\n./gen -n 400 -type random\n\n./gen -n 600 -type random\n\n./gen -n 700 -type random\n\n./gen -n 800 -type random\n\n./gen -n 900 -type random\n\n./gen -n 1000 -type random\n\n./gen -n 1000 -a 10 -b 100 -type random\n\n./gen -n 1000 -a 100 -b 10 -type random\n\n./gen -n 1000 -a 1000 -b 1 -type random\n\n./gen -n 1000 -type random -maxc 5000\n\n./gen -n 1000 -type random -maxc 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:53.807369",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "182/B",
      "title": "B. Vasya's Calendar",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains the single number d — the maximum number of the day that Vasya's clock can show (1 ≤ d ≤ 106).The second line contains a single integer n — the number of months in the year (1 ≤ n ≤ 2000).The third line contains n space-separated integers: ai (1 ≤ ai ≤ d) — the number of days in each month in the order in which they follow, starting from the first one.",
      "output_spec": "OutputPrint a single number — the number of times Vasya manually increased the day number by one throughout the last year.",
      "sample_tests": "ExamplesInputCopy422 2OutputCopy2InputCopy533 4 3OutputCopy3InputCopy311231 28 31 30 31 30 31 31 30 31 30 31OutputCopy7",
      "description": "B. Vasya's Calendar\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains the single number d — the maximum number of the day that Vasya's clock can show (1 ≤ d ≤ 106).The second line contains a single integer n — the number of months in the year (1 ≤ n ≤ 2000).The third line contains n space-separated integers: ai (1 ≤ ai ≤ d) — the number of days in each month in the order in which they follow, starting from the first one.\n\nOutputPrint a single number — the number of times Vasya manually increased the day number by one throughout the last year.\n\nInputCopy422 2OutputCopy2InputCopy533 4 3OutputCopy3InputCopy311231 28 31 30 31 30 31 31 30 31 30 31OutputCopy7\n\nInputCopy422 2\n\nOutputCopy2\n\nInputCopy533 4 3\n\nOutputCopy3\n\nInputCopy311231 28 31 30 31 30 31 31 30 31 30 31\n\nOutputCopy7\n\nNoteIn the first sample the situation is like this:   Day 1. Month 1. The clock shows 1. Vasya changes nothing.  Day 2. Month 1. The clock shows 2. Vasya changes nothing.  Day 1. Month 2. The clock shows 3. Vasya manually increases the day number by 1. After that the clock shows 4. Vasya increases the day number by 1 manually. After that the clock shows 1.  Day 2. Month 2. The clock shows 2. Vasya changes nothing.  In total, Vasya manually changed the day number by 1 exactly 2 times.",
      "solutions": [
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces",
          "content": "Welcome friends)We are glad to introduce you regular Codeforces round #117 for Div.2 participants. Everyone can traditionally participate in it.Problems are prepared by command of authors: Pavel Kholkin (HolkinPV), Ivan Fefer (Fefer_Ivan), Nikolay Kuznetsov (NALP) and Gerald Agapov (Gerald). Thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces system and Mary Belova (Delinur) for translating problems.And again score distribution will be dynamic) More information you can find here.Note that all problems today will be given in random order.Some Div.1 participants register for the contest before settings of registration were changed. Before the round it will be fixed and they will participate out of competition.We hope that todays round would be succesful and everyone enjoys it. We wish you good luck and high rating!UPD: the statement for problem 182E - Wooden Fence was formulated incorrect, correct variant of the statement will be soon, we apologize to the participants.UPD2: the contest is declared unrated.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4403",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 182"
          },
          "content_length": 1028
        },
        {
          "title": "Codeforces Round #117 (Div. 2) Разбор Задач - Codeforces",
          "content": "Приветствую всех участников раунда!Давайте проведем разбор задач в примерном порядке их сложности182B - Vasya's CalendarОбратим внимание, что Вася должен вручную прибавлять номер дня только тогда, когда заканчивается один месяц, и начинается следующий. Значит, пусть у нас в текущем месяце было x дней, а в следующем уже y. Тогда в первый день следующего месяца часы будут показывать день x + 1 (не забываем про модуль d), а должен показывать номер 1.Очевидно, что Вася должен вручную прибавить d - x дней, чтобы часы показывали то, что нужно.Значит, ответ — это сумма всех чисел d - ai, где 1 ≤ i < n.182D - Common DivisorsЭта задача решается многими способами, но самый простой подход следующий: найдем все делители строки s1, все делители s2 и найдем пересечение этих двух множеств.Как же найти все делители строки? Пусть t — это делитель строки s. Тогда очевидно, что |s| = 0(mod|t|), а также t является префиксом строки s. Эти соображения и позволяют найти все делители строки, а именно переберем длину префикса, проверим делимость, а потом проверим, что префикс записанный подряд нужное количество раз совпадает с s.Всего подходящих префиксов не более , проверка каждого работает за O(|s|), значит, итоговое решение за , где n = max(|s|, |t|).Найти пересечение двух множеств строк несложно, можно воспользоваться стандартными структурами данных182E - Wooden FenceУсловие задачи было сформулировано неверно, что привело к несоответствию решений, правильный вариант условия появится совсем скоро, приносим участникам свои извинения.Основа решения этой задачи — это динамическое программирование.Состояние — (last, type, l), где last — номер последней доски, type характеризует поворот последней доски, а l — длина оставшейся части забора.Пересчитывать эту динамику тоже очень просто: переберем номер следующей доски, ее поворот, проверим подходит ли она в текущее состояние, и прибавим нужную величину.Асимпотика решения — O(n2·len).182C - Optimal SumПредставим мысленно задачу в виде движения слева направо некоторого окошка длины len по исходному массиву. То есть нам нужно найти способ достичь максимума в выбранном окошке, а потом сместить его на одну ячейку вправо.Пусть мы зафиксировали положения окошка, теперь посчитаем ответ. Для этого отдельно запишем все положительные и все отрицательные числа в окошке. Если положительных не больше, чем k, или отрицательных не больше k, то мы можем все числа сделать одинакового знака, и ответ — это сумма модулей чисел в подмассиве. Это простой случай.Несложно понять, что невыгодно некоторые отрицательные числа делать положительными и одновременно некоторые положительные — отрицательными. То есть мы обязательно выберем знак <<+>> или <<->> и k чисел этого знака сделаем противоположными. Также несложно понять, что всегда при смене знака у некоторых чисел выгодно брать ровно k максимальных по модулю чисел этого знака.Для того, чтобы поддерживать движение окошка будем использовать два отдельных дерева отрезков: одно для отрицательных, другое для положительных чисел.Если в вершине дерева хранить пару (количество чисел в поддереве, сумма этих чисел), то такая структура умеет возвращать сумму k максимальных чисел, что нам и требуется.Асимптотика решения — O(n·log(n)).182A - BattlefieldВ этой задаче есть два главных момента: длина любой траншеи в метрах численно не превосходит b траншеи не пересекаются Первый пункт означает, что если Вася забегает в траншею чтобы переждать, пока лазер работает, то за это время он может придти в любую его точку.Второй пункт означает, что пока лазер работает, Вася обязан находиться в той траншее, в которой он на данный момент сидит.Значит, путь Васи — это перебежки от одной траншеи к другой, где он пережидает лазерную атаку. Таким образом все решение задачи — это найти кратчайший по времени путь по траншеям от стартовой точки до конечной (их мы тоже будем считать траншеями, просто нулевой длины), для этого нужно всего лишь предподсчитать матрицу расстояний между отрезками траншей и запустить алгоритм, например, Дейкстры.Два тонких момента: мы не можем перебегать между траншеями, если между ними расстояние больше a пусть Вася прибежал в момент времени t, теперь нам нужно найти момент, когда он сможет убежать дальше. Для этого нужно найти следующий момент времени, когда лазер будет перезаряжаться. Эта величина T несложно ищется по формуле: Асимптотика решения — O(n2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4408",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 182\\s*B"
          },
          "content_length": 4379
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 1",
          "code": "And again score distribution will be dynamic) More information you can find here.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 2",
          "code": "there are no two successive boards of the same type",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 3",
          "code": "there are no two successive boards of the same type",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 4",
          "code": "7 6 \n-4 2 -2 -4 0 3 5 \n2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 5",
          "code": "7 6 \n-4 2 -2 -4 0 3 5 \n2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 6",
          "code": "7 2 \n5 1 -3 -4 -1 -5 1 \n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 7",
          "code": "7 2 \n5 1 -3 -4 -1 -5 1 \n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int d = inf.readInt(1, 1000000, \"d\");\n    inf.readEoln();\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, d, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int d = inf.readInt(1, 1000000, \"d\");\n    inf.readEoln();\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, d, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int d = inf.readInt(1, 1000000, \"d\");\n    inf.readEoln();\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, d, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n    int ai_value = opt<int>(\"ai\", 1);\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, d);\n    } else if (type == \"min_ai\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"max_ai\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = d;\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? 1 : d;\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = min(1 + i, d);\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = max(d - i, 1);\n    } else if (type == \"flat\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = min(ai_value, d);\n    } else if (type == \"random_d_minus_1\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(max(1, d - 10), d);\n    } else {\n        // Default random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, d);\n    }\n\n    // Output d\n    printf(\"%d\\n\", d);\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n-1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n    int ai_value = opt<int>(\"ai\", 1);\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, d);\n    } else if (type == \"min_ai\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"max_ai\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = d;\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? 1 : d;\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = min(1 + i, d);\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = max(d - i, 1);\n    } else if (type == \"flat\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = min(ai_value, d);\n    } else if (type == \"random_d_minus_1\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(max(1, d - 10), d);\n    } else {\n        // Default random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, d);\n    }\n\n    // Output d\n    printf(\"%d\\n\", d);\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n-1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -d 1 -type min_ai\n./gen -n 2000 -d 1 -type min_ai\n\n./gen -n 5 -d 5 -type random\n./gen -n 5 -d 5 -type min_ai\n./gen -n 5 -d 5 -type max_ai\n\n./gen -n 5 -d 1000000 -type random\n./gen -n 5 -d 1000000 -type min_ai\n./gen -n 5 -d 1000000 -type max_ai\n\n./gen -n 2000 -d 5 -type random\n./gen -n 2000 -d 5 -type min_ai\n./gen -n 2000 -d 5 -type max_ai\n\n./gen -n 2000 -d 1000000 -type random\n./gen -n 2000 -d 1000000 -type min_ai\n./gen -n 2000 -d 1000000 -type max_ai\n\n./gen -n 1000 -d 500000 -type random\n./gen -n 1000 -d 500000 -type alternating\n./gen -n 1000 -d 500000 -type increasing\n./gen -n 1000 -d 500000 -type decreasing\n\n./gen -n 2000 -d 1000000 -type alternating\n./gen -n 2000 -d 1000000 -type increasing\n./gen -n 2000 -d 1000000 -type decreasing\n\n./gen -n 1 -d 1000000 -type random\n./gen -n 1 -d 1000000 -type min_ai\n./gen -n 1 -d 1000000 -type max_ai\n\n./gen -n 2000 -d 500000 -type flat -ai 1\n./gen -n 2000 -d 500000 -type flat -ai 1000\n./gen -n 2000 -d 500000 -type flat -ai 500000\n\n./gen -n 2000 -d 1000000 -type min_ai\n\n./gen -n 2000 -d 1 -type max_ai\n\n./gen -n 2000 -d 1000000 -type flat -ai 999999\n\n./gen -n 2000 -d 1000000 -type random_d_minus_1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:56.094260",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "182/C",
      "title": "C. Optimal Sum",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, len (1 ≤ len ≤ n ≤ 105) — the number of elements in the array and the length of the chosen subinterval of the array, correspondingly. The second line contains a sequence consisting of n integers a1, a2, ..., an (|ai| ≤ 109) — the original array. The third line contains a single integer k (0 ≤ k ≤ n) — the maximum allowed number of operations. All numbers in lines are separated by a single space.",
      "output_spec": "OutputIn a single line print the maximum possible optimal sum after no more than k acceptable operations are fulfilled. Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy5 30 -2 3 -5 12OutputCopy10InputCopy5 21 -3 -10 4 13OutputCopy14InputCopy3 3-2 -5 41OutputCopy11",
      "description": "C. Optimal Sum\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n, len (1 ≤ len ≤ n ≤ 105) — the number of elements in the array and the length of the chosen subinterval of the array, correspondingly. The second line contains a sequence consisting of n integers a1, a2, ..., an (|ai| ≤ 109) — the original array. The third line contains a single integer k (0 ≤ k ≤ n) — the maximum allowed number of operations. All numbers in lines are separated by a single space.\n\nOutputIn a single line print the maximum possible optimal sum after no more than k acceptable operations are fulfilled. Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.\n\nInputCopy5 30 -2 3 -5 12OutputCopy10InputCopy5 21 -3 -10 4 13OutputCopy14InputCopy3 3-2 -5 41OutputCopy11\n\nInputCopy5 30 -2 3 -5 12\n\nOutputCopy10\n\nInputCopy5 21 -3 -10 4 13\n\nOutputCopy14\n\nInputCopy3 3-2 -5 41\n\nOutputCopy11",
      "solutions": [
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces",
          "content": "Welcome friends)We are glad to introduce you regular Codeforces round #117 for Div.2 participants. Everyone can traditionally participate in it.Problems are prepared by command of authors: Pavel Kholkin (HolkinPV), Ivan Fefer (Fefer_Ivan), Nikolay Kuznetsov (NALP) and Gerald Agapov (Gerald). Thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces system and Mary Belova (Delinur) for translating problems.And again score distribution will be dynamic) More information you can find here.Note that all problems today will be given in random order.Some Div.1 participants register for the contest before settings of registration were changed. Before the round it will be fixed and they will participate out of competition.We hope that todays round would be succesful and everyone enjoys it. We wish you good luck and high rating!UPD: the statement for problem 182E - Wooden Fence was formulated incorrect, correct variant of the statement will be soon, we apologize to the participants.UPD2: the contest is declared unrated.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4403",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 182"
          },
          "content_length": 1028
        },
        {
          "title": "Codeforces Round #117 (Div. 2) Разбор Задач - Codeforces",
          "content": "Приветствую всех участников раунда!Давайте проведем разбор задач в примерном порядке их сложности182B - Vasya's CalendarОбратим внимание, что Вася должен вручную прибавлять номер дня только тогда, когда заканчивается один месяц, и начинается следующий. Значит, пусть у нас в текущем месяце было x дней, а в следующем уже y. Тогда в первый день следующего месяца часы будут показывать день x + 1 (не забываем про модуль d), а должен показывать номер 1.Очевидно, что Вася должен вручную прибавить d - x дней, чтобы часы показывали то, что нужно.Значит, ответ — это сумма всех чисел d - ai, где 1 ≤ i < n.182D - Common DivisorsЭта задача решается многими способами, но самый простой подход следующий: найдем все делители строки s1, все делители s2 и найдем пересечение этих двух множеств.Как же найти все делители строки? Пусть t — это делитель строки s. Тогда очевидно, что |s| = 0(mod|t|), а также t является префиксом строки s. Эти соображения и позволяют найти все делители строки, а именно переберем длину префикса, проверим делимость, а потом проверим, что префикс записанный подряд нужное количество раз совпадает с s.Всего подходящих префиксов не более , проверка каждого работает за O(|s|), значит, итоговое решение за , где n = max(|s|, |t|).Найти пересечение двух множеств строк несложно, можно воспользоваться стандартными структурами данных182E - Wooden FenceУсловие задачи было сформулировано неверно, что привело к несоответствию решений, правильный вариант условия появится совсем скоро, приносим участникам свои извинения.Основа решения этой задачи — это динамическое программирование.Состояние — (last, type, l), где last — номер последней доски, type характеризует поворот последней доски, а l — длина оставшейся части забора.Пересчитывать эту динамику тоже очень просто: переберем номер следующей доски, ее поворот, проверим подходит ли она в текущее состояние, и прибавим нужную величину.Асимпотика решения — O(n2·len).182C - Optimal SumПредставим мысленно задачу в виде движения слева направо некоторого окошка длины len по исходному массиву. То есть нам нужно найти способ достичь максимума в выбранном окошке, а потом сместить его на одну ячейку вправо.Пусть мы зафиксировали положения окошка, теперь посчитаем ответ. Для этого отдельно запишем все положительные и все отрицательные числа в окошке. Если положительных не больше, чем k, или отрицательных не больше k, то мы можем все числа сделать одинакового знака, и ответ — это сумма модулей чисел в подмассиве. Это простой случай.Несложно понять, что невыгодно некоторые отрицательные числа делать положительными и одновременно некоторые положительные — отрицательными. То есть мы обязательно выберем знак <<+>> или <<->> и k чисел этого знака сделаем противоположными. Также несложно понять, что всегда при смене знака у некоторых чисел выгодно брать ровно k максимальных по модулю чисел этого знака.Для того, чтобы поддерживать движение окошка будем использовать два отдельных дерева отрезков: одно для отрицательных, другое для положительных чисел.Если в вершине дерева хранить пару (количество чисел в поддереве, сумма этих чисел), то такая структура умеет возвращать сумму k максимальных чисел, что нам и требуется.Асимптотика решения — O(n·log(n)).182A - BattlefieldВ этой задаче есть два главных момента: длина любой траншеи в метрах численно не превосходит b траншеи не пересекаются Первый пункт означает, что если Вася забегает в траншею чтобы переждать, пока лазер работает, то за это время он может придти в любую его точку.Второй пункт означает, что пока лазер работает, Вася обязан находиться в той траншее, в которой он на данный момент сидит.Значит, путь Васи — это перебежки от одной траншеи к другой, где он пережидает лазерную атаку. Таким образом все решение задачи — это найти кратчайший по времени путь по траншеям от стартовой точки до конечной (их мы тоже будем считать траншеями, просто нулевой длины), для этого нужно всего лишь предподсчитать матрицу расстояний между отрезками траншей и запустить алгоритм, например, Дейкстры.Два тонких момента: мы не можем перебегать между траншеями, если между ними расстояние больше a пусть Вася прибежал в момент времени t, теперь нам нужно найти момент, когда он сможет убежать дальше. Для этого нужно найти следующий момент времени, когда лазер будет перезаряжаться. Эта величина T несложно ищется по формуле: Асимптотика решения — O(n2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4408",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 182\\s*C"
          },
          "content_length": 4379
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 1",
          "code": "And again score distribution will be dynamic) More information you can find here.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 2",
          "code": "there are no two successive boards of the same type",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 3",
          "code": "there are no two successive boards of the same type",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 4",
          "code": "7 6 \n-4 2 -2 -4 0 3 5 \n2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 5",
          "code": "7 6 \n-4 2 -2 -4 0 3 5 \n2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 6",
          "code": "7 2 \n5 1 -3 -4 -1 -5 1 \n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 7",
          "code": "7 2 \n5 1 -3 -4 -1 -5 1 \n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int len = inf.readInt(1, n, \"len\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(-1000000000, 1000000000);\n        if (i + 1 < n)\n            inf.readSpace();\n        else\n            inf.readEoln();\n    }\n\n    int k = inf.readInt(0, n, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int len = inf.readInt(1, n, \"len\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(-1000000000, 1000000000);\n        if (i + 1 < n)\n            inf.readSpace();\n        else\n            inf.readEoln();\n    }\n\n    int k = inf.readInt(0, n, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int len = inf.readInt(1, n, \"len\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(-1000000000, 1000000000);\n        if (i + 1 < n)\n            inf.readSpace();\n        else\n            inf.readEoln();\n    }\n\n    int k = inf.readInt(0, n, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int len = opt<int>(\"len\");\n    int k = opt<int>(\"k\", 0);\n    int maxA = opt<int>(\"maxA\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    cout << n << \" \" << len << \"\\n\";\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(-maxA, maxA);\n        }\n    } else if (type == \"all_positive\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(1, maxA);\n        }\n    } else if (type == \"all_negative\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = -rnd.next(1, maxA);\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0)\n                a[i] = rnd.next(1, maxA);\n            else\n                a[i] = -rnd.next(1, maxA);\n        }\n    } else if (type == \"zeros\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = 0;\n        }\n    } else if (type == \"small_numbers\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(-10, 10);\n        }\n    } else if (type == \"big_numbers\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(-maxA, maxA);\n        }\n    } else if (type == \"increasing\") {\n        int start = rnd.next(-maxA / 2, maxA / 2);\n        int delta = rnd.next(1, maxA / n);\n        for (int i = 0; i < n; i++) {\n            a[i] = start + delta * i;\n            if (a[i] > maxA) a[i] = maxA;\n            if (a[i] < -maxA) a[i] = -maxA;\n        }\n    } else if (type == \"decreasing\") {\n        int start = rnd.next(-maxA / 2, maxA / 2);\n        int delta = rnd.next(1, maxA / n);\n        for (int i = 0; i < n; i++) {\n            a[i] = start - delta * i;\n            if (a[i] > maxA) a[i] = maxA;\n            if (a[i] < -maxA) a[i] = -maxA;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(-maxA, maxA);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << a[i] << (i + 1 == n ? \"\\n\" : \" \");\n    }\n\n    cout << k << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int len = opt<int>(\"len\");\n    int k = opt<int>(\"k\", 0);\n    int maxA = opt<int>(\"maxA\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    cout << n << \" \" << len << \"\\n\";\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(-maxA, maxA);\n        }\n    } else if (type == \"all_positive\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(1, maxA);\n        }\n    } else if (type == \"all_negative\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = -rnd.next(1, maxA);\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0)\n                a[i] = rnd.next(1, maxA);\n            else\n                a[i] = -rnd.next(1, maxA);\n        }\n    } else if (type == \"zeros\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = 0;\n        }\n    } else if (type == \"small_numbers\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(-10, 10);\n        }\n    } else if (type == \"big_numbers\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(-maxA, maxA);\n        }\n    } else if (type == \"increasing\") {\n        int start = rnd.next(-maxA / 2, maxA / 2);\n        int delta = rnd.next(1, maxA / n);\n        for (int i = 0; i < n; i++) {\n            a[i] = start + delta * i;\n            if (a[i] > maxA) a[i] = maxA;\n            if (a[i] < -maxA) a[i] = -maxA;\n        }\n    } else if (type == \"decreasing\") {\n        int start = rnd.next(-maxA / 2, maxA / 2);\n        int delta = rnd.next(1, maxA / n);\n        for (int i = 0; i < n; i++) {\n            a[i] = start - delta * i;\n            if (a[i] > maxA) a[i] = maxA;\n            if (a[i] < -maxA) a[i] = -maxA;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(-maxA, maxA);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << a[i] << (i + 1 == n ? \"\\n\" : \" \");\n    }\n\n    cout << k << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case 1: Small random test\n./gen -n 5 -len 3 -k 2 -type random\n\n# Test case 2: All positive numbers\n./gen -n 10 -len 5 -k 3 -type all_positive\n\n# Test case 3: All negative numbers\n./gen -n 10 -len 5 -k 3 -type all_negative\n\n# Test case 4: Alternating signs\n./gen -n 10 -len 5 -k 3 -type alternating\n\n# Test case 5: All zeros\n./gen -n 10 -len 5 -k 3 -type zeros\n\n# Test case 6: Small numbers\n./gen -n 100 -len 50 -k 10 -type small_numbers\n\n# Test case 7: Big numbers\n./gen -n 100 -len 50 -k 10 -maxA 1000000000 -type big_numbers\n\n# Test case 8: Increasing sequence\n./gen -n 100 -len 50 -k 10 -type increasing\n\n# Test case 9: Decreasing sequence\n./gen -n 100 -len 50 -k 10 -type decreasing\n\n# Test case 10: n maximum\n./gen -n 100000 -len 50000 -k 100000 -type random\n\n# Test case 11: len = 1\n./gen -n 10000 -len 1 -k 5000 -type random\n\n# Test case 12: len = n\n./gen -n 10000 -len 10000 -k 5000 -type random\n\n# Test case 13: k = 0\n./gen -n 10000 -len 5000 -k 0 -type random\n\n# Test case 14: k = n\n./gen -n 10000 -len 5000 -k 10000 -type random\n\n# Test case 15: Alternating with big numbers\n./gen -n 100000 -len 99999 -k 50000 -maxA 1000000000 -type alternating\n\n# Test case 16: All positive, no flips allowed\n./gen -n 100000 -len 50000 -k 0 -type all_positive\n\n# Test case 17: All negative, flip all\n./gen -n 100000 -len 50000 -k 100000 -type all_negative\n\n# Test case 18: Zeros with flips\n./gen -n 100000 -len 50000 -k 50000 -type zeros\n\n# Test case 19: Small k\n./gen -n 100000 -len 50000 -k 1 -type random\n\n# Test case 20: All ones\n./gen -n 100000 -len 50000 -k 100000 -maxA 1 -type all_positive\n\n# Test case 21: All negative ones\n./gen -n 100000 -len 50000 -k 99999 -maxA 1 -type all_negative\n\n# Test case 22: Random small numbers with len=1\n./gen -n 100000 -len 1 -k 100000 -type small_numbers\n\n# Test case 23: Random big numbers with len=n\n./gen -n 100000 -len 100000 -k 100000 -type big_numbers\n\n# Test case 24: Decreasing sequence with k=0\n./gen -n 100000 -len 50000 -k 0 -type decreasing\n\n# Test case 25: Increasing sequence with k=n\n./gen -n 100000 -len 50000 -k 100000 -type increasing\n\n# Test case 26: Random, len close to n\n./gen -n 100000 -len 99999 -k 50000 -type random\n\n# Test case 27: Random, len small\n./gen -n 100000 -len 2 -k 5000 -type random\n\n# Test case 28: Random with maximum values\n./gen -n 100000 -len 50000 -k 100000 -maxA 1000000000 -type random\n\n# Test case 29: All zeros, k=0\n./gen -n 100000 -len 50000 -k 0 -type zeros\n\n# Test case 30: Random, k=n/2\n./gen -n 100000 -len 50000 -k 50000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:57.979045",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "182/D",
      "title": "D. Общие делители",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных задана непустая строка s1.Во второй строке входных данных задана непустая строка s2.Длины строк s1 и s2 положительны и не превосходят 105. Строки состоят только из строчных букв латинского алфавита.",
      "output_spec": "Выходные данныеВыведите количество общих делителей строк s1 и s2.",
      "sample_tests": "ПримерыВходные данныеСкопироватьabcdabcdabcdabcdabcdabcdВыходные данныеСкопировать2Входные данныеСкопироватьaaaaaВыходные данныеСкопировать1",
      "description": "D. Общие делители\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных задана непустая строка s1.Во второй строке входных данных задана непустая строка s2.Длины строк s1 и s2 положительны и не превосходят 105. Строки состоят только из строчных букв латинского алфавита.\n\nВходные данные\n\nВыходные данныеВыведите количество общих делителей строк s1 и s2.\n\nВыходные данные\n\nВходные данныеСкопироватьabcdabcdabcdabcdabcdabcdВыходные данныеСкопировать2Входные данныеСкопироватьaaaaaВыходные данныеСкопировать1\n\nВходные данныеСкопироватьabcdabcdabcdabcdabcdabcd\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьaaaaa\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере общими делителями являются строки «abcd» и «abcdabcd».В втором примере общим делителем является единственная строка «a». Строка «aa» не входит в ответ, так как не является делителем строки «aaa».",
      "solutions": [
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces",
          "content": "Всем здравствуйте)Рады приветствовать вас на очередном раунде Codeforces #117 для участников Div. 2. Традиционно, остальные могут поучаствовать в нем вне конкурса.Задачи для вас были подготовлены группой авторов в составе: Павел Холкин (HolkinPV), Иван Фефер (Fefer_Ivan), Николай Кузнецов (NALP) и Геральд Агапов (Gerald). Мы благодарим Михаила Мирзаянова (MikeMirzayanov) за систему Codeforces и Марию Белову (Delinur) за перевод условий.Распределение баллов вновь будет динамическим) Подробнее об этом можно найти здесь.Обращаем внимание, что все задачи сегодня будут даны в произвольном порядке.Некоторые участники Див. 1 зарегистрировались на соревнование раньше, чем была произведена настройка регистрации. До начала раунда это будет исправлено, и они будут участвовать вне конкурса.Надеемся раунд пройдет успешно и всем понравится. Желаем удачи и высокого рейтинга!UPD: условие задачи 182E - Деревянный забор было сформулировано неверно, что привело к несоответствию решений, правильный вариант условия появится совсем скоро, приносим участникам свои извинения.UPD2: контест объявлен нерейтинговым.UPD3: разбор задач можно найти здесь",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4403",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.5,
            "reason": "宽松匹配: 包含题目编号 182"
          },
          "content_length": 1141
        },
        {
          "title": "Codeforces Round #117 (Div. 2) Разбор Задач - Codeforces",
          "content": "Приветствую всех участников раунда!Давайте проведем разбор задач в примерном порядке их сложности182B - Vasya's CalendarОбратим внимание, что Вася должен вручную прибавлять номер дня только тогда, когда заканчивается один месяц, и начинается следующий. Значит, пусть у нас в текущем месяце было x дней, а в следующем уже y. Тогда в первый день следующего месяца часы будут показывать день x + 1 (не забываем про модуль d), а должен показывать номер 1.Очевидно, что Вася должен вручную прибавить d - x дней, чтобы часы показывали то, что нужно.Значит, ответ — это сумма всех чисел d - ai, где 1 ≤ i < n.182D - Common DivisorsЭта задача решается многими способами, но самый простой подход следующий: найдем все делители строки s1, все делители s2 и найдем пересечение этих двух множеств.Как же найти все делители строки? Пусть t — это делитель строки s. Тогда очевидно, что |s| = 0(mod|t|), а также t является префиксом строки s. Эти соображения и позволяют найти все делители строки, а именно переберем длину префикса, проверим делимость, а потом проверим, что префикс записанный подряд нужное количество раз совпадает с s.Всего подходящих префиксов не более , проверка каждого работает за O(|s|), значит, итоговое решение за , где n = max(|s|, |t|).Найти пересечение двух множеств строк несложно, можно воспользоваться стандартными структурами данных182E - Wooden FenceУсловие задачи было сформулировано неверно, что привело к несоответствию решений, правильный вариант условия появится совсем скоро, приносим участникам свои извинения.Основа решения этой задачи — это динамическое программирование.Состояние — (last, type, l), где last — номер последней доски, type характеризует поворот последней доски, а l — длина оставшейся части забора.Пересчитывать эту динамику тоже очень просто: переберем номер следующей доски, ее поворот, проверим подходит ли она в текущее состояние, и прибавим нужную величину.Асимпотика решения — O(n2·len).182C - Optimal SumПредставим мысленно задачу в виде движения слева направо некоторого окошка длины len по исходному массиву. То есть нам нужно найти способ достичь максимума в выбранном окошке, а потом сместить его на одну ячейку вправо.Пусть мы зафиксировали положения окошка, теперь посчитаем ответ. Для этого отдельно запишем все положительные и все отрицательные числа в окошке. Если положительных не больше, чем k, или отрицательных не больше k, то мы можем все числа сделать одинакового знака, и ответ — это сумма модулей чисел в подмассиве. Это простой случай.Несложно понять, что невыгодно некоторые отрицательные числа делать положительными и одновременно некоторые положительные — отрицательными. То есть мы обязательно выберем знак <<+>> или <<->> и k чисел этого знака сделаем противоположными. Также несложно понять, что всегда при смене знака у некоторых чисел выгодно брать ровно k максимальных по модулю чисел этого знака.Для того, чтобы поддерживать движение окошка будем использовать два отдельных дерева отрезков: одно для отрицательных, другое для положительных чисел.Если в вершине дерева хранить пару (количество чисел в поддереве, сумма этих чисел), то такая структура умеет возвращать сумму k максимальных чисел, что нам и требуется.Асимптотика решения — O(n·log(n)).182A - BattlefieldВ этой задаче есть два главных момента: длина любой траншеи в метрах численно не превосходит b траншеи не пересекаются Первый пункт означает, что если Вася забегает в траншею чтобы переждать, пока лазер работает, то за это время он может придти в любую его точку.Второй пункт означает, что пока лазер работает, Вася обязан находиться в той траншее, в которой он на данный момент сидит.Значит, путь Васи — это перебежки от одной траншеи к другой, где он пережидает лазерную атаку. Таким образом все решение задачи — это найти кратчайший по времени путь по траншеям от стартовой точки до конечной (их мы тоже будем считать траншеями, просто нулевой длины), для этого нужно всего лишь предподсчитать матрицу расстояний между отрезками траншей и запустить алгоритм, например, Дейкстры.Два тонких момента: мы не можем перебегать между траншеями, если между ними расстояние больше a пусть Вася прибежал в момент времени t, теперь нам нужно найти момент, когда он сможет убежать дальше. Для этого нужно найти следующий момент времени, когда лазер будет перезаряжаться. Эта величина T несложно ищется по формуле: Асимптотика решения — O(n2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4408",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 182\\s*D"
          },
          "content_length": 4379
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 1",
          "code": "And again score distribution will be dynamic) More information you can find here.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 2",
          "code": "Два забора будем считать одинаковыми, если соответствующие последовательности типов древесины досок заборов совпадают, в противном случае заборы различны.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 3",
          "code": "Два забора будем считать одинаковыми, если соответствующие последовательности типов древесины досок заборов совпадают, в противном случае заборы различны.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 4",
          "code": "6 3\n1 1 1 -2 10 -9\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 5",
          "code": "6 3\n1 1 1 -2 10 -9\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 6",
          "code": "there are no two successive boards of the same type",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 7",
          "code": "there are no two successive boards of the same type",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 8",
          "code": "while (!haveSolution) {\n    head.turnOn();\n    if (head.think() == SOLUTION) {\n        haveSolution = true;\n    }\n}\nfingers.codeSolution();\nsoul.enjoy();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 9",
          "code": "while (!haveSolution) {\n    head.turnOn();\n    if (head.think() == SOLUTION) {\n        haveSolution = true;\n    }\n}\nfingers.codeSolution();\nsoul.enjoy();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 10",
          "code": "while (!haveSolution) {\n    head.turnLeft();\n    ...\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 11",
          "code": "while (!haveSolution) {\n    head.turnLeft();\n    ...\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 12",
          "code": "UPD1: А в чём причина хоть?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 13",
          "code": "UPD1: А в чём причина хоть?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 14",
          "code": "UPD2:'Условие задачи было сформулировано неверно, что привело к несоответствию решений, правильный вариант условия появится совсем скоро, приносим участникам свои извинения.'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 15",
          "code": "UPD2:'Условие задачи было сформулировано неверно, что привело к несоответствию решений, правильный вариант условия появится совсем скоро, приносим участникам свои извинения.'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 16",
          "code": "7 6 \n-4 2 -2 -4 0 3 5 \n2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 17",
          "code": "7 6 \n-4 2 -2 -4 0 3 5 \n2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 18",
          "code": "7 2 \n5 1 -3 -4 -1 -5 1 \n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 19",
          "code": "7 2 \n5 1 -3 -4 -1 -5 1 \n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) Разбор Задач - Codeforces - Code 1",
          "code": "if (s.count(x)==0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4408",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) Разбор Задач - Codeforces - Code 2",
          "code": "if (s.find(x)!=s.end())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4408",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) Разбор Задач - Codeforces - Code 3",
          "code": "s.erase(val)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4408",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) Разбор Задач - Codeforces - Code 4",
          "code": "100 150  \n1 2  \n1 2  \n...  \n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4408",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) Разбор Задач - Codeforces - Code 5",
          "code": "100 150  \n1 2  \n1 2  \n...  \n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4408",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine(\"[a-z]+\", \"s1\");\n    ensuref(1 <= s1.length() && s1.length() <= 100000, \"Length of s1 must be between 1 and 100000, but is %d\", (int)s1.length());\n\n    string s2 = inf.readLine(\"[a-z]+\", \"s2\");\n    ensuref(1 <= s2.length() && s2.length() <= 100000, \"Length of s2 must be between 1 and 100000, but is %d\", (int)s2.length());\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine(\"[a-z]+\", \"s1\");\n    ensuref(1 <= s1.length() && s1.length() <= 100000, \"Length of s1 must be between 1 and 100000, but is %d\", (int)s1.length());\n\n    string s2 = inf.readLine(\"[a-z]+\", \"s2\");\n    ensuref(1 <= s2.length() && s2.length() <= 100000, \"Length of s2 must be between 1 and 100000, but is %d\", (int)s2.length());\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine(\"[a-z]+\", \"s1\");\n    ensuref(1 <= s1.length() && s1.length() <= 100000, \"Length of s1 must be between 1 and 100000, but is %d\", (int)s1.length());\n\n    string s2 = inf.readLine(\"[a-z]+\", \"s2\");\n    ensuref(1 <= s2.length() && s2.length() <= 100000, \"Length of s2 must be between 1 and 100000, but is %d\", (int)s2.length());\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randomString(int len) {\n    string s(len, 'a');\n    for (int i = 0; i < len; ++i)\n        s[i] = 'a' + rnd.next(26);\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    string s1, s2;\n\n    if (type == \"equal\") {\n        if (n != m) {\n            m = n;\n        }\n        s1 = s2 = randomString(n);\n    } else if (type == \"single_char\") {\n        char c = 'a' + rnd.next(26);\n        s1 = string(n, c);\n        s2 = string(m, c);\n    } else if (type == \"random\") {\n        s1 = randomString(n);\n        s2 = randomString(m);\n    } else if (type == \"no_common\") {\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        while (c2 == c1) c2 = 'a' + rnd.next(26);\n        s1 = string(1, c1) + randomString(n - 1);\n        s2 = string(1, c2) + randomString(m - 1);\n    } else if (type == \"one_substring\") {\n        int len_t = rnd.next(1, min(n, m));\n        string t = randomString(len_t);\n        int k1 = (n + len_t - 1) / len_t;\n        int k2 = (m + len_t - 1) / len_t;\n        s1 = \"\";\n        s2 = \"\";\n        for (int i = 0; i < k1; ++i)\n            s1 += t;\n        for (int i = 0; i < k2; ++i)\n            s2 += t;\n        s1 = s1.substr(0, n);\n        s2 = s2.substr(0, m);\n    } else if (type == \"max_common\") {\n        int len_t = 1;\n        string t = randomString(len_t);\n        s1 = \"\";\n        s2 = \"\";\n        while ((int)s1.size() < n)\n            s1 += t;\n        s1 = s1.substr(0, n);\n        while ((int)s2.size() < m)\n            s2 += t;\n        s2 = s2.substr(0, m);\n    } else {\n        s1 = randomString(n);\n        s2 = randomString(m);\n    }\n\n    printf(\"%s\\n\", s1.c_str());\n    printf(\"%s\\n\", s2.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randomString(int len) {\n    string s(len, 'a');\n    for (int i = 0; i < len; ++i)\n        s[i] = 'a' + rnd.next(26);\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    string s1, s2;\n\n    if (type == \"equal\") {\n        if (n != m) {\n            m = n;\n        }\n        s1 = s2 = randomString(n);\n    } else if (type == \"single_char\") {\n        char c = 'a' + rnd.next(26);\n        s1 = string(n, c);\n        s2 = string(m, c);\n    } else if (type == \"random\") {\n        s1 = randomString(n);\n        s2 = randomString(m);\n    } else if (type == \"no_common\") {\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        while (c2 == c1) c2 = 'a' + rnd.next(26);\n        s1 = string(1, c1) + randomString(n - 1);\n        s2 = string(1, c2) + randomString(m - 1);\n    } else if (type == \"one_substring\") {\n        int len_t = rnd.next(1, min(n, m));\n        string t = randomString(len_t);\n        int k1 = (n + len_t - 1) / len_t;\n        int k2 = (m + len_t - 1) / len_t;\n        s1 = \"\";\n        s2 = \"\";\n        for (int i = 0; i < k1; ++i)\n            s1 += t;\n        for (int i = 0; i < k2; ++i)\n            s2 += t;\n        s1 = s1.substr(0, n);\n        s2 = s2.substr(0, m);\n    } else if (type == \"max_common\") {\n        int len_t = 1;\n        string t = randomString(len_t);\n        s1 = \"\";\n        s2 = \"\";\n        while ((int)s1.size() < n)\n            s1 += t;\n        s1 = s1.substr(0, n);\n        while ((int)s2.size() < m)\n            s2 += t;\n        s2 = s2.substr(0, m);\n    } else {\n        s1 = randomString(n);\n        s2 = randomString(m);\n    }\n\n    printf(\"%s\\n\", s1.c_str());\n    printf(\"%s\\n\", s2.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type single_char\n./gen -n 1 -m 1 -type equal\n./gen -n 1 -m 1 -type random\n\n./gen -n 2 -m 3 -type one_substring\n./gen -n 3 -m 2 -type one_substring\n\n./gen -n 10 -m 10 -type equal\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type no_common\n./gen -n 10 -m 10 -type single_char\n./gen -n 10 -m 10 -type max_common\n\n./gen -n 100 -m 200 -type one_substring\n./gen -n 200 -m 100 -type one_substring\n\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type equal\n./gen -n 1000 -m 1000 -type no_common\n./gen -n 1000 -m 1000 -type single_char\n./gen -n 1000 -m 1000 -type max_common\n\n./gen -n 99999 -m 100000 -type random\n./gen -n 100000 -m 100000 -type equal\n./gen -n 100000 -m 100000 -type no_common\n./gen -n 100000 -m 100000 -type single_char\n./gen -n 100000 -m 100000 -type max_common\n\n./gen -n 100000 -m 1 -type single_char\n./gen -n 1 -m 100000 -type single_char\n\n./gen -n 100000 -m 50000 -type one_substring\n./gen -n 50000 -m 100000 -type one_substring\n\n./gen -n 100000 -m 100000 -type one_substring\n./gen -n 99999 -m 100000 -type one_substring\n\n./gen -n 100000 -m 100000 -type max_common\n\n./gen -n 12345 -m 67890 -type random\n./gen -n 100000 -m 1 -type random\n./gen -n 1 -m 100000 -type random\n./gen -n 100000 -m 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:44:59.711143",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "182/E",
      "title": "E. Wooden Fence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and l (1 ≤ n ≤ 100, 1 ≤ l ≤ 3000) — the number of different board types and the fence length, correspondingly. Next n lines contain descriptions of board types: the i-th line contains two integers ai and bi (1 ≤ ai, bi ≤ 100) — the sizes of the board of the i-th type. All numbers on the lines are separated by spaces.",
      "output_spec": "OutputPrint a single integer — the sought number of variants modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy2 31 22 3OutputCopy2InputCopy1 22 2OutputCopy1InputCopy6 62 13 22 53 35 12 1OutputCopy20",
      "description": "E. Wooden Fence\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and l (1 ≤ n ≤ 100, 1 ≤ l ≤ 3000) — the number of different board types and the fence length, correspondingly. Next n lines contain descriptions of board types: the i-th line contains two integers ai and bi (1 ≤ ai, bi ≤ 100) — the sizes of the board of the i-th type. All numbers on the lines are separated by spaces.\n\nOutputPrint a single integer — the sought number of variants modulo 1000000007 (109 + 7).\n\nInputCopy2 31 22 3OutputCopy2InputCopy1 22 2OutputCopy1InputCopy6 62 13 22 53 35 12 1OutputCopy20\n\nInputCopy2 31 22 3\n\nOutputCopy2\n\nInputCopy1 22 2\n\nOutputCopy1\n\nInputCopy6 62 13 22 53 35 12 1\n\nOutputCopy20\n\nNoteIn the first sample there are exactly two variants of arranging a beautiful fence of length 3:   As the first fence board use the board of the first type of length 1 and width 2. As the second board use board of the second type of length 2 and width 3.  Use one board of the second type after you turn it. That makes its length equal 3, and width — 2.",
      "solutions": [
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces",
          "content": "Welcome friends)We are glad to introduce you regular Codeforces round #117 for Div.2 participants. Everyone can traditionally participate in it.Problems are prepared by command of authors: Pavel Kholkin (HolkinPV), Ivan Fefer (Fefer_Ivan), Nikolay Kuznetsov (NALP) and Gerald Agapov (Gerald). Thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces system and Mary Belova (Delinur) for translating problems.And again score distribution will be dynamic) More information you can find here.Note that all problems today will be given in random order.Some Div.1 participants register for the contest before settings of registration were changed. Before the round it will be fixed and they will participate out of competition.We hope that todays round would be succesful and everyone enjoys it. We wish you good luck and high rating!UPD: the statement for problem 182E - Wooden Fence was formulated incorrect, correct variant of the statement will be soon, we apologize to the participants.UPD2: the contest is declared unrated.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4403",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 182\\s*E"
          },
          "content_length": 1028
        },
        {
          "title": "Codeforces Round #117 (Div. 2) Разбор Задач - Codeforces",
          "content": "Приветствую всех участников раунда!Давайте проведем разбор задач в примерном порядке их сложности182B - Vasya's CalendarОбратим внимание, что Вася должен вручную прибавлять номер дня только тогда, когда заканчивается один месяц, и начинается следующий. Значит, пусть у нас в текущем месяце было x дней, а в следующем уже y. Тогда в первый день следующего месяца часы будут показывать день x + 1 (не забываем про модуль d), а должен показывать номер 1.Очевидно, что Вася должен вручную прибавить d - x дней, чтобы часы показывали то, что нужно.Значит, ответ — это сумма всех чисел d - ai, где 1 ≤ i < n.182D - Common DivisorsЭта задача решается многими способами, но самый простой подход следующий: найдем все делители строки s1, все делители s2 и найдем пересечение этих двух множеств.Как же найти все делители строки? Пусть t — это делитель строки s. Тогда очевидно, что |s| = 0(mod|t|), а также t является префиксом строки s. Эти соображения и позволяют найти все делители строки, а именно переберем длину префикса, проверим делимость, а потом проверим, что префикс записанный подряд нужное количество раз совпадает с s.Всего подходящих префиксов не более , проверка каждого работает за O(|s|), значит, итоговое решение за , где n = max(|s|, |t|).Найти пересечение двух множеств строк несложно, можно воспользоваться стандартными структурами данных182E - Wooden FenceУсловие задачи было сформулировано неверно, что привело к несоответствию решений, правильный вариант условия появится совсем скоро, приносим участникам свои извинения.Основа решения этой задачи — это динамическое программирование.Состояние — (last, type, l), где last — номер последней доски, type характеризует поворот последней доски, а l — длина оставшейся части забора.Пересчитывать эту динамику тоже очень просто: переберем номер следующей доски, ее поворот, проверим подходит ли она в текущее состояние, и прибавим нужную величину.Асимпотика решения — O(n2·len).182C - Optimal SumПредставим мысленно задачу в виде движения слева направо некоторого окошка длины len по исходному массиву. То есть нам нужно найти способ достичь максимума в выбранном окошке, а потом сместить его на одну ячейку вправо.Пусть мы зафиксировали положения окошка, теперь посчитаем ответ. Для этого отдельно запишем все положительные и все отрицательные числа в окошке. Если положительных не больше, чем k, или отрицательных не больше k, то мы можем все числа сделать одинакового знака, и ответ — это сумма модулей чисел в подмассиве. Это простой случай.Несложно понять, что невыгодно некоторые отрицательные числа делать положительными и одновременно некоторые положительные — отрицательными. То есть мы обязательно выберем знак <<+>> или <<->> и k чисел этого знака сделаем противоположными. Также несложно понять, что всегда при смене знака у некоторых чисел выгодно брать ровно k максимальных по модулю чисел этого знака.Для того, чтобы поддерживать движение окошка будем использовать два отдельных дерева отрезков: одно для отрицательных, другое для положительных чисел.Если в вершине дерева хранить пару (количество чисел в поддереве, сумма этих чисел), то такая структура умеет возвращать сумму k максимальных чисел, что нам и требуется.Асимптотика решения — O(n·log(n)).182A - BattlefieldВ этой задаче есть два главных момента: длина любой траншеи в метрах численно не превосходит b траншеи не пересекаются Первый пункт означает, что если Вася забегает в траншею чтобы переждать, пока лазер работает, то за это время он может придти в любую его точку.Второй пункт означает, что пока лазер работает, Вася обязан находиться в той траншее, в которой он на данный момент сидит.Значит, путь Васи — это перебежки от одной траншеи к другой, где он пережидает лазерную атаку. Таким образом все решение задачи — это найти кратчайший по времени путь по траншеям от стартовой точки до конечной (их мы тоже будем считать траншеями, просто нулевой длины), для этого нужно всего лишь предподсчитать матрицу расстояний между отрезками траншей и запустить алгоритм, например, Дейкстры.Два тонких момента: мы не можем перебегать между траншеями, если между ними расстояние больше a пусть Вася прибежал в момент времени t, теперь нам нужно найти момент, когда он сможет убежать дальше. Для этого нужно найти следующий момент времени, когда лазер будет перезаряжаться. Эта величина T несложно ищется по формуле: Асимптотика решения — O(n2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4408",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 182\\s*E"
          },
          "content_length": 4379
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 1",
          "code": "And again score distribution will be dynamic) More information you can find here.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 2",
          "code": "there are no two successive boards of the same type",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 3",
          "code": "there are no two successive boards of the same type",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 4",
          "code": "7 6 \n-4 2 -2 -4 0 3 5 \n2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 5",
          "code": "7 6 \n-4 2 -2 -4 0 3 5 \n2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 6",
          "code": "7 2 \n5 1 -3 -4 -1 -5 1 \n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #117 (Div. 2) - Codeforces - Code 7",
          "code": "7 2 \n5 1 -3 -4 -1 -5 1 \n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4403",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 3000, \"l\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, 100, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 100, \"bi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 3000, \"l\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, 100, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 100, \"bi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 3000, \"l\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, 100, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 100, \"bi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    int l = opt<int>(\"l\", 100);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> boards(n); // ai, bi\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 100);\n            int bi = rnd.next(1, 100);\n            boards[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"square\") {\n        for (int i = 0; i < n; ++i) {\n            int side = rnd.next(1, 100);\n            boards[i] = make_pair(side, side);\n        }\n    } else if (type == \"small_ai\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 10);\n            int bi = rnd.next(1, 100);\n            boards[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"large_ai\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(90, 100);\n            int bi = rnd.next(1, 100);\n            boards[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"single_type\") {\n        n = 1;\n        boards.resize(n);\n        int ai = rnd.next(1, 100);\n        int bi = rnd.next(1, 100);\n        boards[0] = make_pair(ai, bi);\n    } else if (type == \"max_n\") {\n        n = 100;\n        boards.resize(n);\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 100);\n            int bi = rnd.next(1, 100);\n            boards[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"min_n\") {\n        n = 1;\n        boards.resize(n);\n        int ai = rnd.next(1, 100);\n        int bi = rnd.next(1, 100);\n        boards[0] = make_pair(ai, bi);\n    } else if (type == \"identical_boards\") {\n        int ai = rnd.next(1, 100);\n        int bi = rnd.next(1, 100);\n        for (int i = 0; i < n; ++i) {\n            boards[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"increasing_dimensions\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = min(i + 1, 100);\n            int bi = min(i + 2, 100);\n            boards[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"decreasing_dimensions\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = max(1, 100 - i);\n            int bi = max(1, 99 - i);\n            boards[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"max_l\") {\n        l = 3000;\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 100);\n            int bi = rnd.next(1, 100);\n            boards[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"min_l\") {\n        l = 1;\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 100);\n            int bi = rnd.next(1, 100);\n            boards[i] = make_pair(ai, bi);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 100);\n            int bi = rnd.next(1, 100);\n            boards[i] = make_pair(ai, bi);\n        }\n    }\n\n    // Now, output n and l\n    printf(\"%d %d\\n\", n, l);\n\n    // Output the ai, bi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", boards[i].first, boards[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    int l = opt<int>(\"l\", 100);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> boards(n); // ai, bi\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 100);\n            int bi = rnd.next(1, 100);\n            boards[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"square\") {\n        for (int i = 0; i < n; ++i) {\n            int side = rnd.next(1, 100);\n            boards[i] = make_pair(side, side);\n        }\n    } else if (type == \"small_ai\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 10);\n            int bi = rnd.next(1, 100);\n            boards[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"large_ai\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(90, 100);\n            int bi = rnd.next(1, 100);\n            boards[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"single_type\") {\n        n = 1;\n        boards.resize(n);\n        int ai = rnd.next(1, 100);\n        int bi = rnd.next(1, 100);\n        boards[0] = make_pair(ai, bi);\n    } else if (type == \"max_n\") {\n        n = 100;\n        boards.resize(n);\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 100);\n            int bi = rnd.next(1, 100);\n            boards[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"min_n\") {\n        n = 1;\n        boards.resize(n);\n        int ai = rnd.next(1, 100);\n        int bi = rnd.next(1, 100);\n        boards[0] = make_pair(ai, bi);\n    } else if (type == \"identical_boards\") {\n        int ai = rnd.next(1, 100);\n        int bi = rnd.next(1, 100);\n        for (int i = 0; i < n; ++i) {\n            boards[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"increasing_dimensions\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = min(i + 1, 100);\n            int bi = min(i + 2, 100);\n            boards[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"decreasing_dimensions\") {\n        for (int i = 0; i < n; ++i) {\n            int ai = max(1, 100 - i);\n            int bi = max(1, 99 - i);\n            boards[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"max_l\") {\n        l = 3000;\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 100);\n            int bi = rnd.next(1, 100);\n            boards[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"min_l\") {\n        l = 1;\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 100);\n            int bi = rnd.next(1, 100);\n            boards[i] = make_pair(ai, bi);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 100);\n            int bi = rnd.next(1, 100);\n            boards[i] = make_pair(ai, bi);\n        }\n    }\n\n    // Now, output n and l\n    printf(\"%d %d\\n\", n, l);\n\n    // Output the ai, bi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", boards[i].first, boards[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -l 1 -type min_n             # Minimal n and l\n./gen -n 1 -l 3000 -type min_n          # Minimal n, maximal l\n./gen -n 100 -l 1 -type min_l           # Maximal n, minimal l\n./gen -n 100 -l 3000 -type max_n        # Max n and l\n./gen -n 50 -l 1500 -type random\n./gen -n 10 -l 100 -type square\n./gen -n 20 -l 500 -type small_ai\n./gen -n 30 -l 1000 -type large_ai\n./gen -n 1 -l 100 -type single_type\n./gen -n 100 -l 3000 -type max_l\n./gen -n 50 -l 3000 -type identical_boards\n./gen -n 100 -l 100 -type increasing_dimensions\n./gen -n 100 -l 100 -type decreasing_dimensions\n./gen -n 10 -l 1 -type min_l\n./gen -n 20 -l 2000 -type random\n./gen -n 30 -l 2500 -type random\n./gen -n 40 -l 1000 -type random\n./gen -n 50 -l 3000 -type random\n./gen -n 60 -l 500 -type square\n./gen -n 70 -l 100 -type small_ai\n./gen -n 80 -l 2000 -type large_ai\n./gen -n 90 -l 50 -type random\n./gen -n 100 -l 3000 -type random\n./gen -n 100 -l 3000 -type square\n./gen -n 1 -l 3000 -type single_type\n./gen -n 99 -l 2999 -type random\n./gen -n 100 -l 2999 -type min_l\n./gen -n 100 -l 1 -type min_l\n./gen -n 100 -l 2 -type min_l\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:01.409989",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "183/A",
      "title": "A. Headquarters",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 2·105) — the number of the car's movements from the headquarters to the stall.Each of the following n lines describes the car's possible movements. It is guaranteed that each possible movement is one of the following strings: \"UL\", \"UR\", \"DL\", \"DR\" or \"ULDR\". All movements are given in chronological order. Please do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin and cout stream or the %I64d specifier.",
      "output_spec": "OutputPrint a single integer — the number of different possible locations of the gang's headquarters.",
      "sample_tests": "ExamplesInputCopy3URULULDROutputCopy9InputCopy2DRDLOutputCopy4",
      "description": "A. Headquarters\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 2·105) — the number of the car's movements from the headquarters to the stall.Each of the following n lines describes the car's possible movements. It is guaranteed that each possible movement is one of the following strings: \"UL\", \"UR\", \"DL\", \"DR\" or \"ULDR\". All movements are given in chronological order. Please do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin and cout stream or the %I64d specifier.\n\nOutputPrint a single integer — the number of different possible locations of the gang's headquarters.\n\nInputCopy3URULULDROutputCopy9InputCopy2DRDLOutputCopy4\n\nInputCopy3URULULDR\n\nOutputCopy9\n\nInputCopy2DRDL\n\nOutputCopy4\n\nNoteThe figure below shows the nine possible positions of the gang headquarters from the first sample:   For example, the following movements can get the car from point (1, 0) to point (0, 0):",
      "solutions": [
        {
          "title": "CROC Champ 2012 — Round 3 (Final) - Codeforces",
          "content": "Croc Champ 2012 - FinalFinal Update: Congratulations to the prize winners! First place: neex.emil — 100000 rubles Runner Up: Dmitry_Egorov — Apple MacBook Pro 15 2nd Runner Up: vepifanov — Apple MacBook Pro 13 Videos for the onsite round (posted by ivan.popelyshev): 1 2 3 4 5 6Congratulations to the winners of the mixed group (onsite & offsite)! ivan.metelsky YuukaKazami neex.emilrng_58 deserves honorable mention for the only competitor to correctly submit both D and E :)Editorial.Hello Codeforces!I am glad to welcome you — both onsite and out-of-competition competitors — to the final round of Open Moscow Programming Championship By CROC. I am the writer of this round — Gerald, ivan.popelyshev and Delinur helped me in the preparation of the problems. This is my second round in Codeforces, so far, thanks to the Codeforces team and MikeMirzayanov for giving me this opportunity again!Please note that this round is held in conjunction with its onsite counterpart, so its starting time may be delayed. Also, since MikeMirzayanov is very busy with the onsite contest at the moment to decrease the load (to avoid any disaster for the onsite competition), I apologize that you may not receive any email reminder about this match.I've taken feedbacks from my last match into account, so the pretests will be fairly strong. The match should be more interesting for you if you decide to try and solve as many problem as possible, instead of stopping and hacking other codes early in the match :)The rules below are copied-modified from Ripatti's post:Competition will happen by usual rules of Codeforces, with hacks and score falling in process of time. The three championship winners will be awarded valuable prizes: 100000 rubles for the first place Apple MacBook Pro 15 for the second place Apple MacBook Pro 13 for the third place Please remember that the round will be rated only for onsite participants and Division 1 contestants, since the problemset may be more tricky than usual (or it may not be :) ). Division 2 coders can participate, but it will not be rated for them.There will be five problems ordered by approximately increasing complexity. The scores will be 500-1000-1500-2000-2500. Don’t forget that during contest your solutions will be tested on a small set of pretests. Testing on full testset will be after end of the round. Pretests can don’t cover all cases of input data, so you should test your solutions very carefully.It is strictly forbidden to publish statements/solutions of the problems before round will be end. Also you shouldn’t to talk about problems, discuss some things about possible solutions of them. Let’s be honest! You can discuss problems after the end of round.Good luck everyone! I will be watching :)",
          "author": "dolphinigle",
          "url": "https://codeforces.com/blog/entry/4425",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2752
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces",
          "content": "This is the editorial for Croc Champ 2012 - Final RemarksOne day, I applied to write another round in Codeforces. To my surprise, I was offered to write CROC instead. I'm quite surprised they offer me (an unknown programmer from a notorious country) to write for such an important match! So I happily oblige — kudos for the open culture nurtured by Codeforces!I like most the problems of this final round. I think all of them are beautiful in some aspects :). Oh, and all of them emits such concise solutions ;). Problem AAuthor: dolphinigle Ad Hoc I supppose...This problem is equivalent to calculating the number of reachable locations from point (0, 0) by doing the allowed moves.The naive solution is to process the information one by one from first to last, and to keep track on all the reachable positions.Claim: At any moment in time, all reachable locations as described above forms a \"diamond\".An extremely informal proof is by induction:For instance, let's use the first example: UR UL ULDRInitially, there's only one possible location (namely, (0, 0)). It forms the basis of our induction: a diamond with width=1 and height=1. \"UR\" (and also \"DL\") extends the width of the diamond into a 2x1 diamond: Then, \"UL\" (and also \"DR\") extends the height of the diamond into a 2x2 diamond: Finally, \"ULDR\" extends both the height and the width of the diamond into a 3x3 diamond: And so there's 9 possible locations.To see that this claim is true, suppose by induction our locations so far forms a diamond. By symmetry we only need to see that in the \"UR\" case, its width is increased by one (I'll omit the similarly seen \"ULDR\" case). The idea is the new possible locations = the previous diamond shifted one step up UNION that diamond shifted one step right. Indeed, the union of these two diamonds accounts for both the \"U\" and the \"R\" moves. It's not hard to proof that the union of two diamonds with equal dimension that is displaced by vector (1, 1) forms the same diamond with its width increased by 1.So, the solution is to keep track the dimension of the diamond, starting from a 1x1 diamond. Then, simply return width * height.Reference: See 1631223 by Endagorion (my favorite CF author! :) ). Problem BAuthor: dolphinigle GeometrySince there are at least one flamingo, all binoculars will be able to see at least one flamingo. When a binocular is able to see more than one flamingos, then those two flamingos and the binocular must form a line. How many such lines are there?Instead of iterating for each pair of binocular and flamingo, we iterate over each pair of flamingos. These two pair of flamingos completely determine the line as described above. If there does not exists a binocular in this line, we can ignore this pair and continue. Otherwise, calculate the number of flamingos in this line, and let it be one of the possible number of flamingos visible from that binocular.After this is done, simply sum the maximum number of flamingos of each binocular. This works in O(M^3). Note that this problem can be made to run in O(M^2 log M), but coding that solution is sort of... boring ;3.For instance, see vepifanov's 1631294 RemarksActually havaliza prepared a much nicer B problem. Unfortunately, we found out at the last moments that the problem may be too similar to a problem (that is used a looooooooong time ago), so we decided to switch that problem with something else. And that's why this problem is here.It's too bad, the problem proposed by havaliza is actually very nice. Perhaps we will see it in one of the upcoming rounds :) Problem CAuthor: dolphinigle DFSLet's drop the (modulo K). That is, the rule becomes: X->Y implies that Y = X+1 Y->X implies that Y = X-1 Notice that this problem is then equivalent to finding the maximum possible K such that the above equation holds for all edges, modulo K.While we still dropping the \"modulo K\" thingy, we try to calculate the values of each node. We iterate over each node, and if we haven't processed the node: Number the node 0 (or any other number you like). let's denote this by no[i] = 0. DFS the node: DFS(X): if there exists X->Y, then no[Y] = no[X]+1. This follows from the first rule. DFS(X): if there exists Y->X, then no[Y] = no[X]-1. This follows from the second rule. If Y is renumbered (that is, the algorithm has renumber it in the past and we renumber it again), consider the difference between the two numbers. We claim that this difference, if not zero, must be a multiple of K. To see this, suppose the two numbers are A and B. By the way our algorithm works, that node must be able to be numbered A or B. Hence, A == B (mod K) must holds. But then, A-B == 0 (mod K) implies that (A-B) is a multiple of K. If a non-empty multiple of K (let's say it's CYCLEN) is not found in the step above, we claim that the answer is the maximum possible answer: N. Indeed if no such value is found, it means that renumbering the nodes into no[i] % N be correct, since every edge is already consistent with no[i]. Otherwise, we can simply brute force all divisors of CYCLEN and try each of them. Since \"trying\" uses O(E) time (that is, by setting each number into no[i] % K and checking whether the two rules holds for all edges) , we have a O(number_of_divisors * E) algorithm, which with the given constraints is less than O(E * sqrt(N)). For instance, sexyprincess91 implemented this. 1632321 Problem DAuthor: dolphinigle Dynamic Programming, Probabilities, and a little GreedySuppose we have decided to bring N1 T-shirts of size 1, N2 T-shirts of size 2, ... NM T-shirts of size M. By the linearity of expectation, the expected number of engineers that will receive a T-shirt is equal to the sum of the expected number of engineers that will receive a T-shirt of size K, for all K.Suppose we bring Ni T-shirts of size i. Define a random variable Xij as the number of engineer that will receive the j-th T-shirt of size Ni that we bring. Hence, the expected number of engineers that will receive the Ni T-shirts of size i that we bring is equal to the sum of Xij over all j. Since Xij is either 0 or 1, Xij is equal to Pij, the probability that there will be an engineer that will receive the j-th T-shirt of size i that we bring. This is equal to the probability that there will be at least j engineers that fits inside T-shirt of size i.As a result of our discussion, to maximize the expectation, it boils to maximizing the sum over Xij. Hence, we receive our first solution: Calculate the value of all Xij, and pick the N largest value. A DP implementation allows us to accumulate all Xij value in O(N*N*M) time, yielding an O(N*N*M) solution.We will now reduce the time limit to O(N*N + N*M). Notice that the algorithm above only need us to find the N largest values of Xij. Denote by f(n, i, j) the probability that, amongst engineers numbere 1 through n, at least j of them fits inside T-shirt of size i. f(n, i, j) can be computed with the following recurrence: f(n, i, j) = f(n-1, i, j-1) * fit_chance(n, i) + f(n-1, i, j) * (1.0 — fit_change(n, i)) Where fit_chance(t-shirt, engineer) is the probability that engineer fits inside the t-shirt size.The formula above can be inferred from simple logic: if the n-th engineer fits inside t-shirt of size i (with fit_change(n, i) probability), then f(n, i, j) is obviously equal to f(n-1, i, j-1). Otherwise, it'll equal f(n-1, i, j).Now, observe that Xij = f(N, i, j). Indeed, this is one of the possible DPs that can lead to the O(N*N*M) solution. However, we will show that we do not need to compute f(n, i, j) for all possible inputs if we're asked to find only the N largest values of Xij.The key observation is the following obvious fact. If Xij is included in the N largest values, then Xi(j-1) must also be included there. Inductively, Xik for k < j must also be included in the N largest values. Indeed, it's obvious that Xij must be non-increasing with respect to j.Hence the algorithm works as follows. First, we create a pool of numbers Xi1, for all i, totalling M numbers. Then, we iterate N times. In each iteration, we pick the largest number in the pool, say, Xij. Then, we add Xij as one of the K largest values. Then, we take out Xij from the pool, and insert Xi(j+1) as its replacement. That it correctly picks the N largest Xij values follows immediately from our argument in the paragraph preceeding this.Now, if we use the recurrence f(n, i, j) above to compute each Xij, what is the complexity of this algorithm? If we memoize f(n, i, j), we claim that it's O(N*N + N*M). To see this, we notice that the only values required to compute f(n, i, j) using the recurrence above are the values f(m, i, l) such that m <= n and l <= j. However, we notice that due to how our algorithm works, when we need to compute Xij, we must have already computed Xi(j-1) before, so that all values f(m, i, l) for m <= n and l <= j-1 are already available. So the only NEW values that we need to compute are f(m, i, j), m <= n. There are n such values.Since we need to compute at most O(N) values of Xij, the total complexity this part contributes is O(N*N). Depending on how you implement the \"pick largest from pool\" algorithm, the total complexity can be either O(N*N + N*M) or O(N*N + N*log M).Yes, somebody did this in the contest :). Dmitry_Egorov 1632270 saved my problem from loneliness :)Bonus Section: Now here's an extremely interesting solution shown by the following Python pseudocode: values = []\nfor size in range(M):\n i = 1\n while (val = f(N, size, i)) > epsilon:\n values.append(val)\n ++i\n end\nend\nPrint the sum of the largest N values in array values.Its correctness is immediate as long as epsilon is reasonably small (since f(N, size, i) is non-increasing with respect to i). What is the complexity of this very simple algorithm?I am unable to come up with a hard, solid proof, but since f(N, size, i) exponentially falls (except if some probabilities are 1, in which case some other T-shirt must have less value to worry on), the complexity is somewhere near O(N * N). Indeed for the current set of test cases, its speed exceeds that of the intended solution.Although rng_58 do not implement this exact algorithm, he used the <EPS ignore idea in his solution 1631960RemarksI really really wanted to link Gerald's handle in the statement :). Too bad Codeforces doesn't support it. Problem EAuthor: dolphinigle Very greedyBrute force P: the number of Packages each kid will have at the end. There are at most N/M possible such value. We will assume that P is fixed during our discussion.If we know P, we know that if kid i purchases a total of X candies, then kid i+1 must purchase at least X+P candies (1 more than each package purchased by kid i). Hence, assume that money[i] <= money[i+1] — P.Two consecutive packages purchased by the SAME kid must differ by at least M. Indeed, otherwise there are less than M-1 packages for the other M-1 kids to buy from (Pigeonhole rocks by the way).For the sake of our discussions below, we refer to the following example with N=8, and M=3 kids. The allowances of the kids are 7, 10, and 14.Suppose we know all candies kid 0 purchased (red bags denote the packages kid 0 purchased).We claim that the optimal solution can be computed rather... easily with the following greedy algorithm: (assume that the candy packages kid 0 purchase is sorted in an ascending order). We iterate over the remaining kids, starting from kid 1. First, let the kid purchase the minimum possible candies:Next, if the allowance is still greater than the sum of candies, and if one of his package(s) can still be shifted to the right while maintaining the condition that a possible solution exists, do so. If there are multiple package(s) that can be shifted, shifting any of them does not change the optimal answer.Note: since we've assumed that money[i] <= money[i+1]-P, the only condition is that between the package purchased by kid 1 an the next package purchased by kid 0, there exists at least N-2 packages. For instance, this is illegal, since there is no package that kid 2 will be able to purchase between 4 and 5.We iterate this once more for kid 2, obtaining:And we're done. It's arguably the maximum possible value, since there is no reason why we shouldn't shift a package for a kid to the right if we can (formal proof by contradiction).Claim: If we know the packages for kid 0, the maximum total candies purchased can be computed in O(M), where M is the number of kids.The algorithm simulates our discussion above. However it is not obvious how to do that in O(M). So, suppose kid 0 purchase the candies like this:Now, try putting the other P-1 packages into the minimum possible locations:The packages inside the yellow boxes denote what we will call FREEDOM. Basically FREEDOM is the count on how many times we can at most shift a package to the right as in our discussion above.Now, consider kid 1. First, as in our discussion, kid 1 takes the minimum amount of packages, which is equal to sum[kid 0] + P. Next, he will attempt to shift the packages if possible. Notice that the only thing that affects the overall sum of the candy is only the number of shifts performed, not which package actually got shifted. So, this means that, the amount of shift can be easily calculated by min(money[1] — (sum[kid 0] + P), FREEDOM). And then, FREEDOM is deducted from this value, while the amount of candies purchased by kid 1 is incremented by this value.Hence, simulating the algorithm in our discussion if we're only to output the total amount of candies can be done in O(M).The result of our discussion so far is this. Notice that the last algorithm only depends on how many candies kid 0 purchased, and FREEDOM.Now we will remove the assumption that we know which packages kid 0 decides to purchase.Claim: It is optimal for kid 0 to purchase as many candies as possible.Suppose kid 0 does not purchase the maximum possible of candies he can purchase. Now, consider whether or not kid 1 \"shifted\" his candies. If he shifted any of them, say package X, then instead of purchasing package X-1, kid 0 should purchase package X, improving the overall amount of candies. That is, instead of It's better to If kid 1 did not \"shift\" his candies because the amount of money he spent is already equal to his allowance, then the amount of candies purchased by kid 0 must be maximum since money[i] <= money[i+1] — P. Otherwise, we can apply this inductively to kid 2 and so forth. That is, instead of It's better to Okay, now we know the sum of candies that we should give to kid 1. Since the performance of our algorithm increase with FREEDOM, we should next try to maximize FREEDOM.Claim: FREEDOM depends only on the position of the FIRST candy package purchased by kid 0.This can be shown by simple computation, and its equal to N — pos — M*P (or something like that).Hence, we should try to minimize the first candy package purchased by kid 0, while keeping the sum maximum. This can be done in O(1) using a bunch of N*(N+1)/M * P formulas.Hence, since there are N/M package numbers to be brute forced, and each iteration uses O(M) time, the total complexity is O(N/M) * O(M) = O(N).For instance, see 1632210 by rng_58 (again :) ).EpilogueThank you for participating in the match!Hope to see you again!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4419",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 15290
        }
      ],
      "code_examples": [
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 1",
          "code": "values = []\nfor size in range(M):\n  i = 1\n  while (val = f(N, size, i)) > epsilon:\n    values.append(val)\n    ++i\n  end\nend\nPrint the sum of the largest N values in array values.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 2",
          "code": "values = []\nfor size in range(M):\n  i = 1\n  while (val = f(N, size, i)) > epsilon:\n    values.append(val)\n    ++i\n  end\nend\nPrint the sum of the largest N values in array values.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 3",
          "code": "void sort(Line a, Line b) {  if (a.gradient != b.gradient) return a.gradient < b.gradient;  return a.intercept < b.intercept; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 4",
          "code": "it means that renumbering the nodes into no[i] % N be correct, since every edge is already consistent with no[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 5",
          "code": "it means that renumbering the nodes into no[i] % N be correct, since every edge is already consistent with no[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"(UL|UR|DL|DR|ULDR)\", \"movement\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"(UL|UR|DL|DR|ULDR)\", \"movement\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"(UL|UR|DL|DR|ULDR)\", \"movement\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<string> allowedMovements = {\"UL\", \"UR\", \"DL\", \"DR\", \"ULDR\"};\n    \n    vector<string> movements(n);\n    \n    if (type == \"all_UL\") {\n        fill(movements.begin(), movements.end(), \"UL\");\n    }\n    else if (type == \"all_UR\") {\n        fill(movements.begin(), movements.end(), \"UR\");\n    }\n    else if (type == \"all_DL\") {\n        fill(movements.begin(), movements.end(), \"DL\");\n    }\n    else if (type == \"all_DR\") {\n        fill(movements.begin(), movements.end(), \"DR\");\n    }\n    else if (type == \"all_ULDR\") {\n        fill(movements.begin(), movements.end(), \"ULDR\");\n    }\n    else if (type == \"alternate_UL_DR\") {\n        for (int i = 0; i < n; ++i) {\n            movements[i] = (i % 2 == 0) ? \"UL\" : \"DR\";\n        }\n    }\n    else if (type == \"alternate_UR_DL\") {\n        for (int i = 0; i < n; ++i) {\n            movements[i] = (i % 2 == 0) ? \"UR\" : \"DL\";\n        }\n    }\n    else if (type == \"half_UL_half_DR\") {\n        for (int i = 0; i < n; ++i) {\n            if (i < n / 2) movements[i] = \"UL\";\n            else movements[i] = \"DR\";\n        }\n    }\n    else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            movements[i] = allowedMovements[rnd.next(allowedMovements.size())];\n        }\n    }\n    else if (type == \"random_weighted\") {\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(10);\n            if (x < 7) movements[i] = \"ULDR\";\n            else movements[i] = allowedMovements[rnd.next(4)];\n        }\n    }\n    else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            movements[i] = allowedMovements[rnd.next(allowedMovements.size())];\n        }\n    }\n    \n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", movements[i].c_str());\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<string> allowedMovements = {\"UL\", \"UR\", \"DL\", \"DR\", \"ULDR\"};\n    \n    vector<string> movements(n);\n    \n    if (type == \"all_UL\") {\n        fill(movements.begin(), movements.end(), \"UL\");\n    }\n    else if (type == \"all_UR\") {\n        fill(movements.begin(), movements.end(), \"UR\");\n    }\n    else if (type == \"all_DL\") {\n        fill(movements.begin(), movements.end(), \"DL\");\n    }\n    else if (type == \"all_DR\") {\n        fill(movements.begin(), movements.end(), \"DR\");\n    }\n    else if (type == \"all_ULDR\") {\n        fill(movements.begin(), movements.end(), \"ULDR\");\n    }\n    else if (type == \"alternate_UL_DR\") {\n        for (int i = 0; i < n; ++i) {\n            movements[i] = (i % 2 == 0) ? \"UL\" : \"DR\";\n        }\n    }\n    else if (type == \"alternate_UR_DL\") {\n        for (int i = 0; i < n; ++i) {\n            movements[i] = (i % 2 == 0) ? \"UR\" : \"DL\";\n        }\n    }\n    else if (type == \"half_UL_half_DR\") {\n        for (int i = 0; i < n; ++i) {\n            if (i < n / 2) movements[i] = \"UL\";\n            else movements[i] = \"DR\";\n        }\n    }\n    else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            movements[i] = allowedMovements[rnd.next(allowedMovements.size())];\n        }\n    }\n    else if (type == \"random_weighted\") {\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(10);\n            if (x < 7) movements[i] = \"ULDR\";\n            else movements[i] = allowedMovements[rnd.next(4)];\n        }\n    }\n    else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            movements[i] = allowedMovements[rnd.next(allowedMovements.size())];\n        }\n    }\n    \n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", movements[i].c_str());\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_UL\n./gen -n 1 -type all_UR\n./gen -n 1 -type all_DL\n./gen -n 1 -type all_DR\n./gen -n 1 -type all_ULDR\n\n./gen -n 2 -type all_UL\n./gen -n 2 -type alternate_UL_DR\n\n./gen -n 10 -type all_ULDR\n./gen -n 10 -type random\n\n./gen -n 100 -type all_UL\n./gen -n 100 -type all_ULDR\n./gen -n 100 -type alternate_UL_DR\n\n./gen -n 1000 -type random\n./gen -n 1000 -type alternate_UR_DL\n\n./gen -n 10000 -type half_UL_half_DR\n\n./gen -n 200000 -type all_UL\n./gen -n 200000 -type all_ULDR\n./gen -n 200000 -type random\n\n./gen -n 200000 -type alternate_UL_DR\n./gen -n 200000 -type alternate_UR_DL\n\n./gen -n 200000 -type half_UL_half_DR\n./gen -n 200000 -type random_weighted\n\n./gen -n 5 -type random\n./gen -n 10 -type alternate_UR_DL\n./gen -n 50000 -type random\n./gen -n 150000 -type all_ULDR\n./gen -n 200000 -type random\n./gen -n 100000 -type random_weighted\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:03.633960",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "183/B",
      "title": "B. Зоопарк",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеПервая строка содержит два целых числа, записанных через пробел: n и m (1 ≤ n ≤ 106, 1 ≤ m ≤ 250) — количество биноклей и количество фламинго, соответственно.Затем следуют m строк, на i-ой строке записаны через пробел два целых числа xi и yi (1 ≤ xi, yi ≤ 109), что означает, что i-ый фламинго находится в точке (xi, yi). Все фламинго находятся в разных точках.",
      "output_spec": "Выходные данныеВыведите единственное целое число — наибольшее общее количество фламинго, которых можно увидеть во все бинокли.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 52 14 13 24 34 4Выходные данныеСкопировать11",
      "description": "ограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит два целых числа, записанных через пробел: n и m (1 ≤ n ≤ 106, 1 ≤ m ≤ 250) — количество биноклей и количество фламинго, соответственно.Затем следуют m строк, на i-ой строке записаны через пробел два целых числа xi и yi (1 ≤ xi, yi ≤ 109), что означает, что i-ый фламинго находится в точке (xi, yi). Все фламинго находятся в разных точках.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — наибольшее общее количество фламинго, которых можно увидеть во все бинокли.\n\nВыходные данные\n\nВходные данныеСкопировать5 52 14 13 24 34 4Выходные данныеСкопировать11\n\nВходные данныеСкопировать5 52 14 13 24 34 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать11\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеОтвет на тест из примера проиллюстрирован ниже.",
      "solutions": [
        {
          "title": "CROC Champ 2012 — Round 3 (Final) - Codeforces",
          "content": "Чемпионат КРОК 2012 - ФиналUPD: ivan.popelyshev видео: 1 2 3 4 5 6UPD: разбор задач (English)UPD: Контест перенесен на 5 минут по техническим причинам.Привет Codeforces!Я рад пригласить вас — онсайт и вне-конкурсных участников — на финальный раунд Открытого чемпионата Москвы и МО по программированию (КРОК). Я автор этого раунда — Gerald, ivan.popelyshev и Delinur помогали мне в подготовке задач. Это мой второй раунд на Codeforces, огромное спасибо команде Codeforces и MikeMirzayanov за данную мне возможность провести раунд!Обратите внимание, что этот раунд проходит одновременно с онсайтом соревнования, поэтому время его начала может быть перенесено. Также по причине сильной занятости техническими проблемами проведения финала MikeMirzayanov не успел разослать письма с приглашением на раунд. Мы приносим извинения за эту небольшую недоработку.Я взял на заметку пожелания участников прошлого моего раунда. В этом раунде претесты будут достаточно сильные. Раунд покажется вам более интересным если вы будет стараться решить как можно больше задач, а не взламывать другие решения :)Правила ниже скопированы и немного изменены из поста пользователя Ripatti:Соревнование будет проходить по обычным правилам Codeforces, с взломами и падением стоимостей задач. Три участника, которые займут самые высокие места получат в качестве призов: 100000 руб. на первое место Apple MacBook Pro 15 за второе место Apple MacBook Pro 13 за третье место</li. Помните что раунд рейтинговый только для участников финала и Div.1, так как задачи могут быть несколько сложнее чем обычно (а может и нет :) ).На раунде будет пять задач расположенных по возрастанию сложности. Баллы за задачи 500-1000-1500-2000-2500. Не забудьте, что ваши решения во время контеста тестируются только на небольшом наборе тестов — претесты. Тестирование на всех тестах будет произведено после окончания раунда. Претесты не покрывают все случаи, поэтому тщательно тестируйте ваши решения.До окончания раунда категорически запрещается публиковать где-либо условия задач/решения/какие-либо мысли и соображения о них. Запрещено общаться на тему задач, обсуждать условия и проч. Будьте честными и пусть выиграют сильнейшие! После того как раунд завершится, можно будет обсуждать задачи и решения. Всем Удачи! Я буду следить за ходом раунда! :) Это перевод оригинального поста автора. Английский в комментариях приветствуется.",
          "author": "dolphinigle",
          "url": "https://codeforces.com/blog/entry/4425",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2383
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces",
          "content": "This is the editorial for Croc Champ 2012 - Final RemarksOne day, I applied to write another round in Codeforces. To my surprise, I was offered to write CROC instead. I'm quite surprised they offer me (an unknown programmer from a notorious country) to write for such an important match! So I happily oblige — kudos for the open culture nurtured by Codeforces!I like most the problems of this final round. I think all of them are beautiful in some aspects :). Oh, and all of them emits such concise solutions ;). Problem AAuthor: dolphinigle Ad Hoc I supppose...This problem is equivalent to calculating the number of reachable locations from point (0, 0) by doing the allowed moves.The naive solution is to process the information one by one from first to last, and to keep track on all the reachable positions.Claim: At any moment in time, all reachable locations as described above forms a \"diamond\".An extremely informal proof is by induction:For instance, let's use the first example: UR UL ULDRInitially, there's only one possible location (namely, (0, 0)). It forms the basis of our induction: a diamond with width=1 and height=1. \"UR\" (and also \"DL\") extends the width of the diamond into a 2x1 diamond: Then, \"UL\" (and also \"DR\") extends the height of the diamond into a 2x2 diamond: Finally, \"ULDR\" extends both the height and the width of the diamond into a 3x3 diamond: And so there's 9 possible locations.To see that this claim is true, suppose by induction our locations so far forms a diamond. By symmetry we only need to see that in the \"UR\" case, its width is increased by one (I'll omit the similarly seen \"ULDR\" case). The idea is the new possible locations = the previous diamond shifted one step up UNION that diamond shifted one step right. Indeed, the union of these two diamonds accounts for both the \"U\" and the \"R\" moves. It's not hard to proof that the union of two diamonds with equal dimension that is displaced by vector (1, 1) forms the same diamond with its width increased by 1.So, the solution is to keep track the dimension of the diamond, starting from a 1x1 diamond. Then, simply return width * height.Reference: See 1631223 by Endagorion (my favorite CF author! :) ). Problem BAuthor: dolphinigle GeometrySince there are at least one flamingo, all binoculars will be able to see at least one flamingo. When a binocular is able to see more than one flamingos, then those two flamingos and the binocular must form a line. How many such lines are there?Instead of iterating for each pair of binocular and flamingo, we iterate over each pair of flamingos. These two pair of flamingos completely determine the line as described above. If there does not exists a binocular in this line, we can ignore this pair and continue. Otherwise, calculate the number of flamingos in this line, and let it be one of the possible number of flamingos visible from that binocular.After this is done, simply sum the maximum number of flamingos of each binocular. This works in O(M^3). Note that this problem can be made to run in O(M^2 log M), but coding that solution is sort of... boring ;3.For instance, see vepifanov's 1631294 RemarksActually havaliza prepared a much nicer B problem. Unfortunately, we found out at the last moments that the problem may be too similar to a problem (that is used a looooooooong time ago), so we decided to switch that problem with something else. And that's why this problem is here.It's too bad, the problem proposed by havaliza is actually very nice. Perhaps we will see it in one of the upcoming rounds :) Problem CAuthor: dolphinigle DFSLet's drop the (modulo K). That is, the rule becomes: X->Y implies that Y = X+1 Y->X implies that Y = X-1 Notice that this problem is then equivalent to finding the maximum possible K such that the above equation holds for all edges, modulo K.While we still dropping the \"modulo K\" thingy, we try to calculate the values of each node. We iterate over each node, and if we haven't processed the node: Number the node 0 (or any other number you like). let's denote this by no[i] = 0. DFS the node: DFS(X): if there exists X->Y, then no[Y] = no[X]+1. This follows from the first rule. DFS(X): if there exists Y->X, then no[Y] = no[X]-1. This follows from the second rule. If Y is renumbered (that is, the algorithm has renumber it in the past and we renumber it again), consider the difference between the two numbers. We claim that this difference, if not zero, must be a multiple of K. To see this, suppose the two numbers are A and B. By the way our algorithm works, that node must be able to be numbered A or B. Hence, A == B (mod K) must holds. But then, A-B == 0 (mod K) implies that (A-B) is a multiple of K. If a non-empty multiple of K (let's say it's CYCLEN) is not found in the step above, we claim that the answer is the maximum possible answer: N. Indeed if no such value is found, it means that renumbering the nodes into no[i] % N be correct, since every edge is already consistent with no[i]. Otherwise, we can simply brute force all divisors of CYCLEN and try each of them. Since \"trying\" uses O(E) time (that is, by setting each number into no[i] % K and checking whether the two rules holds for all edges) , we have a O(number_of_divisors * E) algorithm, which with the given constraints is less than O(E * sqrt(N)). For instance, sexyprincess91 implemented this. 1632321 Problem DAuthor: dolphinigle Dynamic Programming, Probabilities, and a little GreedySuppose we have decided to bring N1 T-shirts of size 1, N2 T-shirts of size 2, ... NM T-shirts of size M. By the linearity of expectation, the expected number of engineers that will receive a T-shirt is equal to the sum of the expected number of engineers that will receive a T-shirt of size K, for all K.Suppose we bring Ni T-shirts of size i. Define a random variable Xij as the number of engineer that will receive the j-th T-shirt of size Ni that we bring. Hence, the expected number of engineers that will receive the Ni T-shirts of size i that we bring is equal to the sum of Xij over all j. Since Xij is either 0 or 1, Xij is equal to Pij, the probability that there will be an engineer that will receive the j-th T-shirt of size i that we bring. This is equal to the probability that there will be at least j engineers that fits inside T-shirt of size i.As a result of our discussion, to maximize the expectation, it boils to maximizing the sum over Xij. Hence, we receive our first solution: Calculate the value of all Xij, and pick the N largest value. A DP implementation allows us to accumulate all Xij value in O(N*N*M) time, yielding an O(N*N*M) solution.We will now reduce the time limit to O(N*N + N*M). Notice that the algorithm above only need us to find the N largest values of Xij. Denote by f(n, i, j) the probability that, amongst engineers numbere 1 through n, at least j of them fits inside T-shirt of size i. f(n, i, j) can be computed with the following recurrence: f(n, i, j) = f(n-1, i, j-1) * fit_chance(n, i) + f(n-1, i, j) * (1.0 — fit_change(n, i)) Where fit_chance(t-shirt, engineer) is the probability that engineer fits inside the t-shirt size.The formula above can be inferred from simple logic: if the n-th engineer fits inside t-shirt of size i (with fit_change(n, i) probability), then f(n, i, j) is obviously equal to f(n-1, i, j-1). Otherwise, it'll equal f(n-1, i, j).Now, observe that Xij = f(N, i, j). Indeed, this is one of the possible DPs that can lead to the O(N*N*M) solution. However, we will show that we do not need to compute f(n, i, j) for all possible inputs if we're asked to find only the N largest values of Xij.The key observation is the following obvious fact. If Xij is included in the N largest values, then Xi(j-1) must also be included there. Inductively, Xik for k < j must also be included in the N largest values. Indeed, it's obvious that Xij must be non-increasing with respect to j.Hence the algorithm works as follows. First, we create a pool of numbers Xi1, for all i, totalling M numbers. Then, we iterate N times. In each iteration, we pick the largest number in the pool, say, Xij. Then, we add Xij as one of the K largest values. Then, we take out Xij from the pool, and insert Xi(j+1) as its replacement. That it correctly picks the N largest Xij values follows immediately from our argument in the paragraph preceeding this.Now, if we use the recurrence f(n, i, j) above to compute each Xij, what is the complexity of this algorithm? If we memoize f(n, i, j), we claim that it's O(N*N + N*M). To see this, we notice that the only values required to compute f(n, i, j) using the recurrence above are the values f(m, i, l) such that m <= n and l <= j. However, we notice that due to how our algorithm works, when we need to compute Xij, we must have already computed Xi(j-1) before, so that all values f(m, i, l) for m <= n and l <= j-1 are already available. So the only NEW values that we need to compute are f(m, i, j), m <= n. There are n such values.Since we need to compute at most O(N) values of Xij, the total complexity this part contributes is O(N*N). Depending on how you implement the \"pick largest from pool\" algorithm, the total complexity can be either O(N*N + N*M) or O(N*N + N*log M).Yes, somebody did this in the contest :). Dmitry_Egorov 1632270 saved my problem from loneliness :)Bonus Section: Now here's an extremely interesting solution shown by the following Python pseudocode: values = []\nfor size in range(M):\n i = 1\n while (val = f(N, size, i)) > epsilon:\n values.append(val)\n ++i\n end\nend\nPrint the sum of the largest N values in array values.Its correctness is immediate as long as epsilon is reasonably small (since f(N, size, i) is non-increasing with respect to i). What is the complexity of this very simple algorithm?I am unable to come up with a hard, solid proof, but since f(N, size, i) exponentially falls (except if some probabilities are 1, in which case some other T-shirt must have less value to worry on), the complexity is somewhere near O(N * N). Indeed for the current set of test cases, its speed exceeds that of the intended solution.Although rng_58 do not implement this exact algorithm, he used the <EPS ignore idea in his solution 1631960RemarksI really really wanted to link Gerald's handle in the statement :). Too bad Codeforces doesn't support it. Problem EAuthor: dolphinigle Very greedyBrute force P: the number of Packages each kid will have at the end. There are at most N/M possible such value. We will assume that P is fixed during our discussion.If we know P, we know that if kid i purchases a total of X candies, then kid i+1 must purchase at least X+P candies (1 more than each package purchased by kid i). Hence, assume that money[i] <= money[i+1] — P.Two consecutive packages purchased by the SAME kid must differ by at least M. Indeed, otherwise there are less than M-1 packages for the other M-1 kids to buy from (Pigeonhole rocks by the way).For the sake of our discussions below, we refer to the following example with N=8, and M=3 kids. The allowances of the kids are 7, 10, and 14.Suppose we know all candies kid 0 purchased (red bags denote the packages kid 0 purchased).We claim that the optimal solution can be computed rather... easily with the following greedy algorithm: (assume that the candy packages kid 0 purchase is sorted in an ascending order). We iterate over the remaining kids, starting from kid 1. First, let the kid purchase the minimum possible candies:Next, if the allowance is still greater than the sum of candies, and if one of his package(s) can still be shifted to the right while maintaining the condition that a possible solution exists, do so. If there are multiple package(s) that can be shifted, shifting any of them does not change the optimal answer.Note: since we've assumed that money[i] <= money[i+1]-P, the only condition is that between the package purchased by kid 1 an the next package purchased by kid 0, there exists at least N-2 packages. For instance, this is illegal, since there is no package that kid 2 will be able to purchase between 4 and 5.We iterate this once more for kid 2, obtaining:And we're done. It's arguably the maximum possible value, since there is no reason why we shouldn't shift a package for a kid to the right if we can (formal proof by contradiction).Claim: If we know the packages for kid 0, the maximum total candies purchased can be computed in O(M), where M is the number of kids.The algorithm simulates our discussion above. However it is not obvious how to do that in O(M). So, suppose kid 0 purchase the candies like this:Now, try putting the other P-1 packages into the minimum possible locations:The packages inside the yellow boxes denote what we will call FREEDOM. Basically FREEDOM is the count on how many times we can at most shift a package to the right as in our discussion above.Now, consider kid 1. First, as in our discussion, kid 1 takes the minimum amount of packages, which is equal to sum[kid 0] + P. Next, he will attempt to shift the packages if possible. Notice that the only thing that affects the overall sum of the candy is only the number of shifts performed, not which package actually got shifted. So, this means that, the amount of shift can be easily calculated by min(money[1] — (sum[kid 0] + P), FREEDOM). And then, FREEDOM is deducted from this value, while the amount of candies purchased by kid 1 is incremented by this value.Hence, simulating the algorithm in our discussion if we're only to output the total amount of candies can be done in O(M).The result of our discussion so far is this. Notice that the last algorithm only depends on how many candies kid 0 purchased, and FREEDOM.Now we will remove the assumption that we know which packages kid 0 decides to purchase.Claim: It is optimal for kid 0 to purchase as many candies as possible.Suppose kid 0 does not purchase the maximum possible of candies he can purchase. Now, consider whether or not kid 1 \"shifted\" his candies. If he shifted any of them, say package X, then instead of purchasing package X-1, kid 0 should purchase package X, improving the overall amount of candies. That is, instead of It's better to If kid 1 did not \"shift\" his candies because the amount of money he spent is already equal to his allowance, then the amount of candies purchased by kid 0 must be maximum since money[i] <= money[i+1] — P. Otherwise, we can apply this inductively to kid 2 and so forth. That is, instead of It's better to Okay, now we know the sum of candies that we should give to kid 1. Since the performance of our algorithm increase with FREEDOM, we should next try to maximize FREEDOM.Claim: FREEDOM depends only on the position of the FIRST candy package purchased by kid 0.This can be shown by simple computation, and its equal to N — pos — M*P (or something like that).Hence, we should try to minimize the first candy package purchased by kid 0, while keeping the sum maximum. This can be done in O(1) using a bunch of N*(N+1)/M * P formulas.Hence, since there are N/M package numbers to be brute forced, and each iteration uses O(M) time, the total complexity is O(N/M) * O(M) = O(N).For instance, see 1632210 by rng_58 (again :) ).EpilogueThank you for participating in the match!Hope to see you again!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4419",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 15290
        }
      ],
      "code_examples": [
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 1",
          "code": "values = []\nfor size in range(M):\n  i = 1\n  while (val = f(N, size, i)) > epsilon:\n    values.append(val)\n    ++i\n  end\nend\nPrint the sum of the largest N values in array values.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 2",
          "code": "values = []\nfor size in range(M):\n  i = 1\n  while (val = f(N, size, i)) > epsilon:\n    values.append(val)\n    ++i\n  end\nend\nPrint the sum of the largest N values in array values.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 3",
          "code": "void sort(Line a, Line b) {  if (a.gradient != b.gradient) return a.gradient < b.gradient;  return a.intercept < b.intercept; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 4",
          "code": "it means that renumbering the nodes into no[i] % N be correct, since every edge is already consistent with no[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 5",
          "code": "it means that renumbering the nodes into no[i] % N be correct, since every edge is already consistent with no[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 250, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int> > flamingo_positions;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, 1000000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 1000000000, \"yi\");\n        inf.readEoln();\n\n        // Ensure that the flamingo positions are unique\n        pair<int,int> pos = make_pair(xi, yi);\n        ensuref(flamingo_positions.count(pos) == 0, \"Flamingo positions must be unique\");\n        flamingo_positions.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 250, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int> > flamingo_positions;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, 1000000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 1000000000, \"yi\");\n        inf.readEoln();\n\n        // Ensure that the flamingo positions are unique\n        pair<int,int> pos = make_pair(xi, yi);\n        ensuref(flamingo_positions.count(pos) == 0, \"Flamingo positions must be unique\");\n        flamingo_positions.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 250, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int> > flamingo_positions;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, 1000000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 1000000000, \"yi\");\n        inf.readEoln();\n\n        // Ensure that the flamingo positions are unique\n        pair<int,int> pos = make_pair(xi, yi);\n        ensuref(flamingo_positions.count(pos) == 0, \"Flamingo positions must be unique\");\n        flamingo_positions.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check the constraints\n    ensure(1 <= n && n <= 1000000);\n    ensure(1 <= m && m <= 250);\n\n    printf(\"%d %d\\n\", n, m);\n\n    vector<pair<int,int> > flamingos;\n\n    if (type == \"random\") {\n        set<pair<int, int> > points;\n        while ((int)points.size() < m) {\n            int x = rnd.next(1, 1000000000);\n            int y = rnd.next(1, 1000000000);\n            points.insert(make_pair(x, y));\n        }\n        for(auto p : points) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else if (type == \"colinear\") {\n        // Ensure x and y remain within [1, 1e9]\n        int maxStep = 1000;\n        int x0 = rnd.next(1, 1000000000 - m * maxStep);\n        int y0 = rnd.next(1, 1000000000 - m * maxStep);\n        int dx = rnd.next(1, maxStep);\n        int dy = rnd.next(1, maxStep);\n        for(int i = 0; i < m; ++i) {\n            int x = x0 + dx * i;\n            int y = y0 + dy * i;\n            flamingos.push_back(make_pair(x, y));\n        }\n        for(auto p : flamingos) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else if (type == \"horizontal\") {\n        int y = rnd.next(1, 1000000000);\n        set<int> xs;\n        while ((int)xs.size() < m) {\n            int x = rnd.next(1, 1000000000);\n            xs.insert(x);\n        }\n        for(int x : xs) {\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"vertical\") {\n        int x = rnd.next(1, 1000000000);\n        set<int> ys;\n        while ((int)ys.size() < m) {\n            int y = rnd.next(1, 1000000000);\n            ys.insert(y);\n        }\n        for(int y : ys) {\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"cluster\") {\n        // Place flamingos near binoculars\n        set<pair<int, int> > points;\n        while ((int)points.size() < m) {\n            int b = rnd.next(1, n); // Binocular position\n            int x = b;\n            int y = rnd.next(1, 10000); // Close to x-axis\n            points.insert(make_pair(x, y));\n        }\n        for(auto p: points) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else if (type == \"single_flamingo\") {\n        // m must be 1\n        ensure(m == 1);\n        int x = rnd.next(1, 1000000000);\n        int y = rnd.next(1, 1000000000);\n        printf(\"%d %d\\n\", x, y);\n    } else {\n        fprintf(stderr, \"Invalid test case type\\n\");\n        exit(1);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check the constraints\n    ensure(1 <= n && n <= 1000000);\n    ensure(1 <= m && m <= 250);\n\n    printf(\"%d %d\\n\", n, m);\n\n    vector<pair<int,int> > flamingos;\n\n    if (type == \"random\") {\n        set<pair<int, int> > points;\n        while ((int)points.size() < m) {\n            int x = rnd.next(1, 1000000000);\n            int y = rnd.next(1, 1000000000);\n            points.insert(make_pair(x, y));\n        }\n        for(auto p : points) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else if (type == \"colinear\") {\n        // Ensure x and y remain within [1, 1e9]\n        int maxStep = 1000;\n        int x0 = rnd.next(1, 1000000000 - m * maxStep);\n        int y0 = rnd.next(1, 1000000000 - m * maxStep);\n        int dx = rnd.next(1, maxStep);\n        int dy = rnd.next(1, maxStep);\n        for(int i = 0; i < m; ++i) {\n            int x = x0 + dx * i;\n            int y = y0 + dy * i;\n            flamingos.push_back(make_pair(x, y));\n        }\n        for(auto p : flamingos) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else if (type == \"horizontal\") {\n        int y = rnd.next(1, 1000000000);\n        set<int> xs;\n        while ((int)xs.size() < m) {\n            int x = rnd.next(1, 1000000000);\n            xs.insert(x);\n        }\n        for(int x : xs) {\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"vertical\") {\n        int x = rnd.next(1, 1000000000);\n        set<int> ys;\n        while ((int)ys.size() < m) {\n            int y = rnd.next(1, 1000000000);\n            ys.insert(y);\n        }\n        for(int y : ys) {\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"cluster\") {\n        // Place flamingos near binoculars\n        set<pair<int, int> > points;\n        while ((int)points.size() < m) {\n            int b = rnd.next(1, n); // Binocular position\n            int x = b;\n            int y = rnd.next(1, 10000); // Close to x-axis\n            points.insert(make_pair(x, y));\n        }\n        for(auto p: points) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else if (type == \"single_flamingo\") {\n        // m must be 1\n        ensure(m == 1);\n        int x = rnd.next(1, 1000000000);\n        int y = rnd.next(1, 1000000000);\n        printf(\"%d %d\\n\", x, y);\n    } else {\n        fprintf(stderr, \"Invalid test case type\\n\");\n        exit(1);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, small m, random positions\n./gen -n 1 -m 1 -type random\n./gen -n 2 -m 2 -type random\n./gen -n 5 -m 3 -type random\n\n# Maximum n, small m, random positions\n./gen -n 1000000 -m 1 -type random\n./gen -n 1000000 -m 10 -type random\n./gen -n 1000000 -m 250 -type random\n\n# Small n, maximum m, random positions\n./gen -n 5 -m 250 -type random\n./gen -n 10 -m 250 -type random\n\n# Random n, m, colinear flamingos\n./gen -n 1000 -m 250 -type colinear\n./gen -n 100000 -m 200 -type colinear\n./gen -n 500000 -m 100 -type colinear\n\n# Random n, m, flamingos aligned horizontally\n./gen -n 1000 -m 250 -type horizontal\n./gen -n 100000 -m 200 -type horizontal\n./gen -n 500000 -m 100 -type horizontal\n\n# Random n, m, flamingos aligned vertically\n./gen -n 1000 -m 250 -type vertical\n./gen -n 100000 -m 200 -type vertical\n./gen -n 500000 -m 100 -type vertical\n\n# Random n, m, cluster near binoculars\n./gen -n 1000 -m 250 -type cluster\n./gen -n 100000 -m 200 -type cluster\n./gen -n 500000 -m 100 -type cluster\n\n# Test cases with a single flamingo\n./gen -n 1 -m 1 -type single_flamingo\n./gen -n 1000 -m 1 -type single_flamingo\n./gen -n 1000000 -m 1 -type single_flamingo\n\n# Edge cases with minimum n and m\n./gen -n 1 -m 1 -type random\n\n# Edge cases with maximum n and m\n./gen -n 1000000 -m 250 -type random\n./gen -n 1000000 -m 250 -type colinear\n./gen -n 1000000 -m 250 -type horizontal\n./gen -n 1000000 -m 250 -type vertical\n./gen -n 1000000 -m 250 -type cluster\n\n# Mixed types with varied n and m\n./gen -n 500000 -m 50 -type random\n./gen -n 800000 -m 150 -type colinear\n./gen -n 300000 -m 100 -type horizontal\n./gen -n 700000 -m 200 -type vertical\n./gen -n 900000 -m 250 -type cluster\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:05.711422",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "183/C",
      "title": "C. Циклическая покраска",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеПервая строка входных данных содержит два целых числа n и m (1 ≤ n, m ≤ 105), разделенных пробелом — количество вершин и дуг орграфа G, соответственно.Следующие m строк содержат по два целых числа ai и bi (1 ≤ ai, bi ≤ n), разделенных пробелом, которые означают, что дуга номер i ведет из вершины номер ai в вершину номер bi.Допустимы кратные дуги и петли.",
      "output_spec": "Выходные данныеВыведите единственное целое число — максимальное возможное количество цветов в покраске (то есть, значение k, описанное в условии). Обратите внимание, что искомое значение k должно удовлетворять неравенству 1 ≤ k ≤ n.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 41 22 13 44 3Выходные данныеСкопировать2Входные данныеСкопировать5 21 42 5Выходные данныеСкопировать5Входные данныеСкопировать4 51 22 33 12 44 1Выходные данныеСкопировать3Входные данныеСкопировать4 41 11 22 11 2Выходные данныеСкопировать1",
      "description": "C. Циклическая покраска\n\nограничение по времени на тест4 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка входных данных содержит два целых числа n и m (1 ≤ n, m ≤ 105), разделенных пробелом — количество вершин и дуг орграфа G, соответственно.Следующие m строк содержат по два целых числа ai и bi (1 ≤ ai, bi ≤ n), разделенных пробелом, которые означают, что дуга номер i ведет из вершины номер ai в вершину номер bi.Допустимы кратные дуги и петли.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — максимальное возможное количество цветов в покраске (то есть, значение k, описанное в условии). Обратите внимание, что искомое значение k должно удовлетворять неравенству 1 ≤ k ≤ n.\n\nВыходные данные\n\nВходные данныеСкопировать4 41 22 13 44 3Выходные данныеСкопировать2Входные данныеСкопировать5 21 42 5Выходные данныеСкопировать5Входные данныеСкопировать4 51 22 33 12 44 1Выходные данныеСкопировать3Входные данныеСкопировать4 41 11 22 11 2Выходные данныеСкопировать1\n\nВходные данныеСкопировать4 41 22 13 44 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 21 42 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 51 22 33 12 44 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 41 11 22 11 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеДля первого примера, k = 2, картинка ниже изображает два цвета (стрелочки показывают какой цвет, для какого следующий).  С k = 2 один из возможных способов раскрасить граф изображен ниже.  Можно доказать, что большее значение k выбрать невозможно.Для второго примера, ниже приведена картинка для k = 5 цветов.  Возможная раскраска графа изображена ниже:  Для третьего примера, ниже приведена картинка для k = 3 цветов.  Возможная раскраска графа изображена ниже:",
      "solutions": [
        {
          "title": "CROC Champ 2012 — Round 3 (Final) - Codeforces",
          "content": "Чемпионат КРОК 2012 - ФиналUPD: ivan.popelyshev видео: 1 2 3 4 5 6UPD: разбор задач (English)UPD: Контест перенесен на 5 минут по техническим причинам.Привет Codeforces!Я рад пригласить вас — онсайт и вне-конкурсных участников — на финальный раунд Открытого чемпионата Москвы и МО по программированию (КРОК). Я автор этого раунда — Gerald, ivan.popelyshev и Delinur помогали мне в подготовке задач. Это мой второй раунд на Codeforces, огромное спасибо команде Codeforces и MikeMirzayanov за данную мне возможность провести раунд!Обратите внимание, что этот раунд проходит одновременно с онсайтом соревнования, поэтому время его начала может быть перенесено. Также по причине сильной занятости техническими проблемами проведения финала MikeMirzayanov не успел разослать письма с приглашением на раунд. Мы приносим извинения за эту небольшую недоработку.Я взял на заметку пожелания участников прошлого моего раунда. В этом раунде претесты будут достаточно сильные. Раунд покажется вам более интересным если вы будет стараться решить как можно больше задач, а не взламывать другие решения :)Правила ниже скопированы и немного изменены из поста пользователя Ripatti:Соревнование будет проходить по обычным правилам Codeforces, с взломами и падением стоимостей задач. Три участника, которые займут самые высокие места получат в качестве призов: 100000 руб. на первое место Apple MacBook Pro 15 за второе место Apple MacBook Pro 13 за третье место</li. Помните что раунд рейтинговый только для участников финала и Div.1, так как задачи могут быть несколько сложнее чем обычно (а может и нет :) ).На раунде будет пять задач расположенных по возрастанию сложности. Баллы за задачи 500-1000-1500-2000-2500. Не забудьте, что ваши решения во время контеста тестируются только на небольшом наборе тестов — претесты. Тестирование на всех тестах будет произведено после окончания раунда. Претесты не покрывают все случаи, поэтому тщательно тестируйте ваши решения.До окончания раунда категорически запрещается публиковать где-либо условия задач/решения/какие-либо мысли и соображения о них. Запрещено общаться на тему задач, обсуждать условия и проч. Будьте честными и пусть выиграют сильнейшие! После того как раунд завершится, можно будет обсуждать задачи и решения. Всем Удачи! Я буду следить за ходом раунда! :) Это перевод оригинального поста автора. Английский в комментариях приветствуется.",
          "author": "dolphinigle",
          "url": "https://codeforces.com/blog/entry/4425",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2383
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces",
          "content": "This is the editorial for Croc Champ 2012 - Final RemarksOne day, I applied to write another round in Codeforces. To my surprise, I was offered to write CROC instead. I'm quite surprised they offer me (an unknown programmer from a notorious country) to write for such an important match! So I happily oblige — kudos for the open culture nurtured by Codeforces!I like most the problems of this final round. I think all of them are beautiful in some aspects :). Oh, and all of them emits such concise solutions ;). Problem AAuthor: dolphinigle Ad Hoc I supppose...This problem is equivalent to calculating the number of reachable locations from point (0, 0) by doing the allowed moves.The naive solution is to process the information one by one from first to last, and to keep track on all the reachable positions.Claim: At any moment in time, all reachable locations as described above forms a \"diamond\".An extremely informal proof is by induction:For instance, let's use the first example: UR UL ULDRInitially, there's only one possible location (namely, (0, 0)). It forms the basis of our induction: a diamond with width=1 and height=1. \"UR\" (and also \"DL\") extends the width of the diamond into a 2x1 diamond: Then, \"UL\" (and also \"DR\") extends the height of the diamond into a 2x2 diamond: Finally, \"ULDR\" extends both the height and the width of the diamond into a 3x3 diamond: And so there's 9 possible locations.To see that this claim is true, suppose by induction our locations so far forms a diamond. By symmetry we only need to see that in the \"UR\" case, its width is increased by one (I'll omit the similarly seen \"ULDR\" case). The idea is the new possible locations = the previous diamond shifted one step up UNION that diamond shifted one step right. Indeed, the union of these two diamonds accounts for both the \"U\" and the \"R\" moves. It's not hard to proof that the union of two diamonds with equal dimension that is displaced by vector (1, 1) forms the same diamond with its width increased by 1.So, the solution is to keep track the dimension of the diamond, starting from a 1x1 diamond. Then, simply return width * height.Reference: See 1631223 by Endagorion (my favorite CF author! :) ). Problem BAuthor: dolphinigle GeometrySince there are at least one flamingo, all binoculars will be able to see at least one flamingo. When a binocular is able to see more than one flamingos, then those two flamingos and the binocular must form a line. How many such lines are there?Instead of iterating for each pair of binocular and flamingo, we iterate over each pair of flamingos. These two pair of flamingos completely determine the line as described above. If there does not exists a binocular in this line, we can ignore this pair and continue. Otherwise, calculate the number of flamingos in this line, and let it be one of the possible number of flamingos visible from that binocular.After this is done, simply sum the maximum number of flamingos of each binocular. This works in O(M^3). Note that this problem can be made to run in O(M^2 log M), but coding that solution is sort of... boring ;3.For instance, see vepifanov's 1631294 RemarksActually havaliza prepared a much nicer B problem. Unfortunately, we found out at the last moments that the problem may be too similar to a problem (that is used a looooooooong time ago), so we decided to switch that problem with something else. And that's why this problem is here.It's too bad, the problem proposed by havaliza is actually very nice. Perhaps we will see it in one of the upcoming rounds :) Problem CAuthor: dolphinigle DFSLet's drop the (modulo K). That is, the rule becomes: X->Y implies that Y = X+1 Y->X implies that Y = X-1 Notice that this problem is then equivalent to finding the maximum possible K such that the above equation holds for all edges, modulo K.While we still dropping the \"modulo K\" thingy, we try to calculate the values of each node. We iterate over each node, and if we haven't processed the node: Number the node 0 (or any other number you like). let's denote this by no[i] = 0. DFS the node: DFS(X): if there exists X->Y, then no[Y] = no[X]+1. This follows from the first rule. DFS(X): if there exists Y->X, then no[Y] = no[X]-1. This follows from the second rule. If Y is renumbered (that is, the algorithm has renumber it in the past and we renumber it again), consider the difference between the two numbers. We claim that this difference, if not zero, must be a multiple of K. To see this, suppose the two numbers are A and B. By the way our algorithm works, that node must be able to be numbered A or B. Hence, A == B (mod K) must holds. But then, A-B == 0 (mod K) implies that (A-B) is a multiple of K. If a non-empty multiple of K (let's say it's CYCLEN) is not found in the step above, we claim that the answer is the maximum possible answer: N. Indeed if no such value is found, it means that renumbering the nodes into no[i] % N be correct, since every edge is already consistent with no[i]. Otherwise, we can simply brute force all divisors of CYCLEN and try each of them. Since \"trying\" uses O(E) time (that is, by setting each number into no[i] % K and checking whether the two rules holds for all edges) , we have a O(number_of_divisors * E) algorithm, which with the given constraints is less than O(E * sqrt(N)). For instance, sexyprincess91 implemented this. 1632321 Problem DAuthor: dolphinigle Dynamic Programming, Probabilities, and a little GreedySuppose we have decided to bring N1 T-shirts of size 1, N2 T-shirts of size 2, ... NM T-shirts of size M. By the linearity of expectation, the expected number of engineers that will receive a T-shirt is equal to the sum of the expected number of engineers that will receive a T-shirt of size K, for all K.Suppose we bring Ni T-shirts of size i. Define a random variable Xij as the number of engineer that will receive the j-th T-shirt of size Ni that we bring. Hence, the expected number of engineers that will receive the Ni T-shirts of size i that we bring is equal to the sum of Xij over all j. Since Xij is either 0 or 1, Xij is equal to Pij, the probability that there will be an engineer that will receive the j-th T-shirt of size i that we bring. This is equal to the probability that there will be at least j engineers that fits inside T-shirt of size i.As a result of our discussion, to maximize the expectation, it boils to maximizing the sum over Xij. Hence, we receive our first solution: Calculate the value of all Xij, and pick the N largest value. A DP implementation allows us to accumulate all Xij value in O(N*N*M) time, yielding an O(N*N*M) solution.We will now reduce the time limit to O(N*N + N*M). Notice that the algorithm above only need us to find the N largest values of Xij. Denote by f(n, i, j) the probability that, amongst engineers numbere 1 through n, at least j of them fits inside T-shirt of size i. f(n, i, j) can be computed with the following recurrence: f(n, i, j) = f(n-1, i, j-1) * fit_chance(n, i) + f(n-1, i, j) * (1.0 — fit_change(n, i)) Where fit_chance(t-shirt, engineer) is the probability that engineer fits inside the t-shirt size.The formula above can be inferred from simple logic: if the n-th engineer fits inside t-shirt of size i (with fit_change(n, i) probability), then f(n, i, j) is obviously equal to f(n-1, i, j-1). Otherwise, it'll equal f(n-1, i, j).Now, observe that Xij = f(N, i, j). Indeed, this is one of the possible DPs that can lead to the O(N*N*M) solution. However, we will show that we do not need to compute f(n, i, j) for all possible inputs if we're asked to find only the N largest values of Xij.The key observation is the following obvious fact. If Xij is included in the N largest values, then Xi(j-1) must also be included there. Inductively, Xik for k < j must also be included in the N largest values. Indeed, it's obvious that Xij must be non-increasing with respect to j.Hence the algorithm works as follows. First, we create a pool of numbers Xi1, for all i, totalling M numbers. Then, we iterate N times. In each iteration, we pick the largest number in the pool, say, Xij. Then, we add Xij as one of the K largest values. Then, we take out Xij from the pool, and insert Xi(j+1) as its replacement. That it correctly picks the N largest Xij values follows immediately from our argument in the paragraph preceeding this.Now, if we use the recurrence f(n, i, j) above to compute each Xij, what is the complexity of this algorithm? If we memoize f(n, i, j), we claim that it's O(N*N + N*M). To see this, we notice that the only values required to compute f(n, i, j) using the recurrence above are the values f(m, i, l) such that m <= n and l <= j. However, we notice that due to how our algorithm works, when we need to compute Xij, we must have already computed Xi(j-1) before, so that all values f(m, i, l) for m <= n and l <= j-1 are already available. So the only NEW values that we need to compute are f(m, i, j), m <= n. There are n such values.Since we need to compute at most O(N) values of Xij, the total complexity this part contributes is O(N*N). Depending on how you implement the \"pick largest from pool\" algorithm, the total complexity can be either O(N*N + N*M) or O(N*N + N*log M).Yes, somebody did this in the contest :). Dmitry_Egorov 1632270 saved my problem from loneliness :)Bonus Section: Now here's an extremely interesting solution shown by the following Python pseudocode: values = []\nfor size in range(M):\n i = 1\n while (val = f(N, size, i)) > epsilon:\n values.append(val)\n ++i\n end\nend\nPrint the sum of the largest N values in array values.Its correctness is immediate as long as epsilon is reasonably small (since f(N, size, i) is non-increasing with respect to i). What is the complexity of this very simple algorithm?I am unable to come up with a hard, solid proof, but since f(N, size, i) exponentially falls (except if some probabilities are 1, in which case some other T-shirt must have less value to worry on), the complexity is somewhere near O(N * N). Indeed for the current set of test cases, its speed exceeds that of the intended solution.Although rng_58 do not implement this exact algorithm, he used the <EPS ignore idea in his solution 1631960RemarksI really really wanted to link Gerald's handle in the statement :). Too bad Codeforces doesn't support it. Problem EAuthor: dolphinigle Very greedyBrute force P: the number of Packages each kid will have at the end. There are at most N/M possible such value. We will assume that P is fixed during our discussion.If we know P, we know that if kid i purchases a total of X candies, then kid i+1 must purchase at least X+P candies (1 more than each package purchased by kid i). Hence, assume that money[i] <= money[i+1] — P.Two consecutive packages purchased by the SAME kid must differ by at least M. Indeed, otherwise there are less than M-1 packages for the other M-1 kids to buy from (Pigeonhole rocks by the way).For the sake of our discussions below, we refer to the following example with N=8, and M=3 kids. The allowances of the kids are 7, 10, and 14.Suppose we know all candies kid 0 purchased (red bags denote the packages kid 0 purchased).We claim that the optimal solution can be computed rather... easily with the following greedy algorithm: (assume that the candy packages kid 0 purchase is sorted in an ascending order). We iterate over the remaining kids, starting from kid 1. First, let the kid purchase the minimum possible candies:Next, if the allowance is still greater than the sum of candies, and if one of his package(s) can still be shifted to the right while maintaining the condition that a possible solution exists, do so. If there are multiple package(s) that can be shifted, shifting any of them does not change the optimal answer.Note: since we've assumed that money[i] <= money[i+1]-P, the only condition is that between the package purchased by kid 1 an the next package purchased by kid 0, there exists at least N-2 packages. For instance, this is illegal, since there is no package that kid 2 will be able to purchase between 4 and 5.We iterate this once more for kid 2, obtaining:And we're done. It's arguably the maximum possible value, since there is no reason why we shouldn't shift a package for a kid to the right if we can (formal proof by contradiction).Claim: If we know the packages for kid 0, the maximum total candies purchased can be computed in O(M), where M is the number of kids.The algorithm simulates our discussion above. However it is not obvious how to do that in O(M). So, suppose kid 0 purchase the candies like this:Now, try putting the other P-1 packages into the minimum possible locations:The packages inside the yellow boxes denote what we will call FREEDOM. Basically FREEDOM is the count on how many times we can at most shift a package to the right as in our discussion above.Now, consider kid 1. First, as in our discussion, kid 1 takes the minimum amount of packages, which is equal to sum[kid 0] + P. Next, he will attempt to shift the packages if possible. Notice that the only thing that affects the overall sum of the candy is only the number of shifts performed, not which package actually got shifted. So, this means that, the amount of shift can be easily calculated by min(money[1] — (sum[kid 0] + P), FREEDOM). And then, FREEDOM is deducted from this value, while the amount of candies purchased by kid 1 is incremented by this value.Hence, simulating the algorithm in our discussion if we're only to output the total amount of candies can be done in O(M).The result of our discussion so far is this. Notice that the last algorithm only depends on how many candies kid 0 purchased, and FREEDOM.Now we will remove the assumption that we know which packages kid 0 decides to purchase.Claim: It is optimal for kid 0 to purchase as many candies as possible.Suppose kid 0 does not purchase the maximum possible of candies he can purchase. Now, consider whether or not kid 1 \"shifted\" his candies. If he shifted any of them, say package X, then instead of purchasing package X-1, kid 0 should purchase package X, improving the overall amount of candies. That is, instead of It's better to If kid 1 did not \"shift\" his candies because the amount of money he spent is already equal to his allowance, then the amount of candies purchased by kid 0 must be maximum since money[i] <= money[i+1] — P. Otherwise, we can apply this inductively to kid 2 and so forth. That is, instead of It's better to Okay, now we know the sum of candies that we should give to kid 1. Since the performance of our algorithm increase with FREEDOM, we should next try to maximize FREEDOM.Claim: FREEDOM depends only on the position of the FIRST candy package purchased by kid 0.This can be shown by simple computation, and its equal to N — pos — M*P (or something like that).Hence, we should try to minimize the first candy package purchased by kid 0, while keeping the sum maximum. This can be done in O(1) using a bunch of N*(N+1)/M * P formulas.Hence, since there are N/M package numbers to be brute forced, and each iteration uses O(M) time, the total complexity is O(N/M) * O(M) = O(N).For instance, see 1632210 by rng_58 (again :) ).EpilogueThank you for participating in the match!Hope to see you again!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4419",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 15290
        }
      ],
      "code_examples": [
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 1",
          "code": "values = []\nfor size in range(M):\n  i = 1\n  while (val = f(N, size, i)) > epsilon:\n    values.append(val)\n    ++i\n  end\nend\nPrint the sum of the largest N values in array values.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 2",
          "code": "values = []\nfor size in range(M):\n  i = 1\n  while (val = f(N, size, i)) > epsilon:\n    values.append(val)\n    ++i\n  end\nend\nPrint the sum of the largest N values in array values.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 3",
          "code": "void sort(Line a, Line b) {  if (a.gradient != b.gradient) return a.gradient < b.gradient;  return a.intercept < b.intercept; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 4",
          "code": "it means that renumbering the nodes into no[i] % N be correct, since every edge is already consistent with no[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 5",
          "code": "it means that renumbering the nodes into no[i] % N be correct, since every edge is already consistent with no[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // default m depends on type\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", -1); // for cycles_with_gcd_k type\n\n    vector<pair<int,int>> edges;\n\n    if (type == \"chain\") {\n        // Create a chain\n        for (int i = 1; i < n; i++) {\n            edges.push_back({i, i+1});\n        }\n        m = edges.size();\n    } else if (type == \"cycle\") {\n        // Create a cycle\n        for (int i = 1; i < n; i++) {\n            edges.push_back({i, i+1});\n        }\n        edges.push_back({n,1});\n        m = edges.size();\n    } else if (type == \"acyclic\") {\n        // Generate acyclic graph\n        int max_edges = n*(n-1)/2;\n        if (m == -1 || m > max_edges) {\n            m = max_edges;\n        }\n\n        set<pair<int,int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n-1);\n            int v = rnd.next(u+1, n);\n            edge_set.insert({u, v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    } else if (type == \"self_loops\") {\n        // Generate n self-loops\n        for (int i = 1; i <= n; i++) {\n            edges.push_back({i, i});\n        }\n        m = edges.size();\n    } else if (type == \"random\") {\n        // Generate m random edges\n        if (m == -1) m = n; // default m\n        for (int i = 0; i < m; i++) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.push_back({u, v});\n        }\n    } else if (type == \"cycles_with_gcd_k\") {\n        if (k == -1 || k == 0) {\n            // k not specified or invalid, set default value\n            k = rnd.next(1, n);\n        }\n        vector<int> cycle_lengths;\n        int total_nodes = 0;\n        while (total_nodes < n) {\n            int max_len = (n - total_nodes) / k;\n            if (max_len == 0) break;\n            int mult = rnd.next(1, max_len);\n            int len = mult * k;\n            if (len == 0) len = k;\n            if (total_nodes + len > n) len = n - total_nodes;\n            total_nodes += len;\n            cycle_lengths.push_back(len);\n        }\n        int node_id = 1;\n        for (int len : cycle_lengths) {\n            vector<int> nodes;\n            for (int i = 0; i < len; i++) {\n                nodes.push_back(node_id++);\n            }\n            for (int i = 0; i < len -1; i++) {\n                edges.push_back({nodes[i], nodes[i+1]});\n            }\n            edges.push_back({nodes[len-1], nodes[0]});\n        }\n        m = edges.size();\n    } else {\n        printf(\"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // default m depends on type\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", -1); // for cycles_with_gcd_k type\n\n    vector<pair<int,int>> edges;\n\n    if (type == \"chain\") {\n        // Create a chain\n        for (int i = 1; i < n; i++) {\n            edges.push_back({i, i+1});\n        }\n        m = edges.size();\n    } else if (type == \"cycle\") {\n        // Create a cycle\n        for (int i = 1; i < n; i++) {\n            edges.push_back({i, i+1});\n        }\n        edges.push_back({n,1});\n        m = edges.size();\n    } else if (type == \"acyclic\") {\n        // Generate acyclic graph\n        int max_edges = n*(n-1)/2;\n        if (m == -1 || m > max_edges) {\n            m = max_edges;\n        }\n\n        set<pair<int,int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n-1);\n            int v = rnd.next(u+1, n);\n            edge_set.insert({u, v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    } else if (type == \"self_loops\") {\n        // Generate n self-loops\n        for (int i = 1; i <= n; i++) {\n            edges.push_back({i, i});\n        }\n        m = edges.size();\n    } else if (type == \"random\") {\n        // Generate m random edges\n        if (m == -1) m = n; // default m\n        for (int i = 0; i < m; i++) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.push_back({u, v});\n        }\n    } else if (type == \"cycles_with_gcd_k\") {\n        if (k == -1 || k == 0) {\n            // k not specified or invalid, set default value\n            k = rnd.next(1, n);\n        }\n        vector<int> cycle_lengths;\n        int total_nodes = 0;\n        while (total_nodes < n) {\n            int max_len = (n - total_nodes) / k;\n            if (max_len == 0) break;\n            int mult = rnd.next(1, max_len);\n            int len = mult * k;\n            if (len == 0) len = k;\n            if (total_nodes + len > n) len = n - total_nodes;\n            total_nodes += len;\n            cycle_lengths.push_back(len);\n        }\n        int node_id = 1;\n        for (int len : cycle_lengths) {\n            vector<int> nodes;\n            for (int i = 0; i < len; i++) {\n                nodes.push_back(node_id++);\n            }\n            for (int i = 0; i < len -1; i++) {\n                edges.push_back({nodes[i], nodes[i+1]});\n            }\n            edges.push_back({nodes[len-1], nodes[0]});\n        }\n        m = edges.size();\n    } else {\n        printf(\"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type chain\n./gen -n 10 -type cycle\n./gen -n 10 -type random -m 15\n./gen -n 10 -type acyclic -m 20\n./gen -n 10 -type self_loops\n\n./gen -n 100 -type chain\n./gen -n 100 -type cycle\n./gen -n 100 -type random -m 1000\n./gen -n 100 -type acyclic -m 3000\n\n./gen -n 1000 -type chain\n./gen -n 1000 -type cycle\n./gen -n 1000 -type random -m 5000\n./gen -n 1000 -type acyclic -m 10000\n\n./gen -n 5000 -type cycles_with_gcd_k -k 10\n./gen -n 5000 -type cycles_with_gcd_k -k 1\n./gen -n 5000 -type cycles_with_gcd_k -k 100\n\n./gen -n 100000 -type chain\n./gen -n 100000 -type cycle\n./gen -n 100000 -type random -m 100000\n./gen -n 100000 -type acyclic -m 100000\n\n./gen -n 100000 -type cycles_with_gcd_k -k 25000\n\n./gen -n 100000 -type self_loops\n\n./gen -n 99999 -type chain\n\n./gen -n 100000 -type cycles_with_gcd_k -k 50000\n\n./gen -n 100000 -type cycles_with_gcd_k -k 1\n\n./gen -n 100000 -type random -m 100000\n\n./gen -n 100000 -type acyclic -m 0\n\n./gen -n 100000 -type acyclic -m 100000\n\n./gen -n 100000 -type cycle\n\n# Edge cases\n./gen -n 1 -type chain\n./gen -n 1 -type cycle\n./gen -n 1 -type random -m 1\n\n./gen -n 2 -type cycles_with_gcd_k -k 2\n./gen -n 2 -type cycles_with_gcd_k -k 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:07.559876",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "183/D",
      "title": "D. T-shirt",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (1 ≤ n ≤ 3000, 1 ≤ m ≤ 300), denoting the number of engineers and the number of T-shirt sizes, respectively.Then n lines follow, each line contains m space-separated integers. The j-th integer in the i-th line represents the probability that the i-th engineer fits in a T-shirt of size j. Each probability will be given as an integer between 0 and 1000, inclusive. The actual probability should be calculated as the given number divided by 1000. It is guaranteed that for any engineer, the sum of the probabilities for all m T-shirts is equal to one.",
      "output_spec": "OutputPrint a single real number denoting the maximum possible expected number of engineers that will receive a T-shirt.For the answer the absolute or relative error of 10 - 9 is acceptable.",
      "sample_tests": "ExamplesInputCopy2 2500 500500 500OutputCopy1.500000000000InputCopy3 31000 0 01000 0 00 1000 0OutputCopy3.000000000000InputCopy1 4100 200 300 400OutputCopy0.400000000000",
      "description": "time limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (1 ≤ n ≤ 3000, 1 ≤ m ≤ 300), denoting the number of engineers and the number of T-shirt sizes, respectively.Then n lines follow, each line contains m space-separated integers. The j-th integer in the i-th line represents the probability that the i-th engineer fits in a T-shirt of size j. Each probability will be given as an integer between 0 and 1000, inclusive. The actual probability should be calculated as the given number divided by 1000. It is guaranteed that for any engineer, the sum of the probabilities for all m T-shirts is equal to one.\n\nOutputPrint a single real number denoting the maximum possible expected number of engineers that will receive a T-shirt.For the answer the absolute or relative error of 10 - 9 is acceptable.\n\nInputCopy2 2500 500500 500OutputCopy1.500000000000InputCopy3 31000 0 01000 0 00 1000 0OutputCopy3.000000000000InputCopy1 4100 200 300 400OutputCopy0.400000000000\n\nInputCopy2 2500 500500 500\n\nOutputCopy1.500000000000\n\nInputCopy3 31000 0 01000 0 00 1000 0\n\nOutputCopy3.000000000000\n\nInputCopy1 4100 200 300 400\n\nOutputCopy0.400000000000\n\nNoteFor the first example, bring one T-shirt of each size. With 0.5 chance, either both engineers fit inside T-shirts of size 1 or both fit inside T-shirts of size 2. With the other 0.5 chance, one engineer fits inside a T-shirt of size 1 and the other inside a T-shirt of size 2. If the first is true, the number of engineers that receive a T-shirt is one. If the second is true, the number of such engineers is two. Hence, the expected number of engineers who receive a T-shirt is 1.5. This is maximum possible expected number of engineers for all sets of T-shirts. For the second example, bring two T-shirts of size 1 and one T-shirt of size 2. This way, each engineer will definitely receive a T-shirt of his size.For the third example, bring one T-shirt of size 4.",
      "solutions": [
        {
          "title": "CROC Champ 2012 — Round 3 (Final) - Codeforces",
          "content": "Croc Champ 2012 - FinalFinal Update: Congratulations to the prize winners! First place: neex.emil — 100000 rubles Runner Up: Dmitry_Egorov — Apple MacBook Pro 15 2nd Runner Up: vepifanov — Apple MacBook Pro 13 Videos for the onsite round (posted by ivan.popelyshev): 1 2 3 4 5 6Congratulations to the winners of the mixed group (onsite & offsite)! ivan.metelsky YuukaKazami neex.emilrng_58 deserves honorable mention for the only competitor to correctly submit both D and E :)Editorial.Hello Codeforces!I am glad to welcome you — both onsite and out-of-competition competitors — to the final round of Open Moscow Programming Championship By CROC. I am the writer of this round — Gerald, ivan.popelyshev and Delinur helped me in the preparation of the problems. This is my second round in Codeforces, so far, thanks to the Codeforces team and MikeMirzayanov for giving me this opportunity again!Please note that this round is held in conjunction with its onsite counterpart, so its starting time may be delayed. Also, since MikeMirzayanov is very busy with the onsite contest at the moment to decrease the load (to avoid any disaster for the onsite competition), I apologize that you may not receive any email reminder about this match.I've taken feedbacks from my last match into account, so the pretests will be fairly strong. The match should be more interesting for you if you decide to try and solve as many problem as possible, instead of stopping and hacking other codes early in the match :)The rules below are copied-modified from Ripatti's post:Competition will happen by usual rules of Codeforces, with hacks and score falling in process of time. The three championship winners will be awarded valuable prizes: 100000 rubles for the first place Apple MacBook Pro 15 for the second place Apple MacBook Pro 13 for the third place Please remember that the round will be rated only for onsite participants and Division 1 contestants, since the problemset may be more tricky than usual (or it may not be :) ). Division 2 coders can participate, but it will not be rated for them.There will be five problems ordered by approximately increasing complexity. The scores will be 500-1000-1500-2000-2500. Don’t forget that during contest your solutions will be tested on a small set of pretests. Testing on full testset will be after end of the round. Pretests can don’t cover all cases of input data, so you should test your solutions very carefully.It is strictly forbidden to publish statements/solutions of the problems before round will be end. Also you shouldn’t to talk about problems, discuss some things about possible solutions of them. Let’s be honest! You can discuss problems after the end of round.Good luck everyone! I will be watching :)",
          "author": "dolphinigle",
          "url": "https://codeforces.com/blog/entry/4425",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2752
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces",
          "content": "This is the editorial for Croc Champ 2012 - Final RemarksOne day, I applied to write another round in Codeforces. To my surprise, I was offered to write CROC instead. I'm quite surprised they offer me (an unknown programmer from a notorious country) to write for such an important match! So I happily oblige — kudos for the open culture nurtured by Codeforces!I like most the problems of this final round. I think all of them are beautiful in some aspects :). Oh, and all of them emits such concise solutions ;). Problem AAuthor: dolphinigle Ad Hoc I supppose...This problem is equivalent to calculating the number of reachable locations from point (0, 0) by doing the allowed moves.The naive solution is to process the information one by one from first to last, and to keep track on all the reachable positions.Claim: At any moment in time, all reachable locations as described above forms a \"diamond\".An extremely informal proof is by induction:For instance, let's use the first example: UR UL ULDRInitially, there's only one possible location (namely, (0, 0)). It forms the basis of our induction: a diamond with width=1 and height=1. \"UR\" (and also \"DL\") extends the width of the diamond into a 2x1 diamond: Then, \"UL\" (and also \"DR\") extends the height of the diamond into a 2x2 diamond: Finally, \"ULDR\" extends both the height and the width of the diamond into a 3x3 diamond: And so there's 9 possible locations.To see that this claim is true, suppose by induction our locations so far forms a diamond. By symmetry we only need to see that in the \"UR\" case, its width is increased by one (I'll omit the similarly seen \"ULDR\" case). The idea is the new possible locations = the previous diamond shifted one step up UNION that diamond shifted one step right. Indeed, the union of these two diamonds accounts for both the \"U\" and the \"R\" moves. It's not hard to proof that the union of two diamonds with equal dimension that is displaced by vector (1, 1) forms the same diamond with its width increased by 1.So, the solution is to keep track the dimension of the diamond, starting from a 1x1 diamond. Then, simply return width * height.Reference: See 1631223 by Endagorion (my favorite CF author! :) ). Problem BAuthor: dolphinigle GeometrySince there are at least one flamingo, all binoculars will be able to see at least one flamingo. When a binocular is able to see more than one flamingos, then those two flamingos and the binocular must form a line. How many such lines are there?Instead of iterating for each pair of binocular and flamingo, we iterate over each pair of flamingos. These two pair of flamingos completely determine the line as described above. If there does not exists a binocular in this line, we can ignore this pair and continue. Otherwise, calculate the number of flamingos in this line, and let it be one of the possible number of flamingos visible from that binocular.After this is done, simply sum the maximum number of flamingos of each binocular. This works in O(M^3). Note that this problem can be made to run in O(M^2 log M), but coding that solution is sort of... boring ;3.For instance, see vepifanov's 1631294 RemarksActually havaliza prepared a much nicer B problem. Unfortunately, we found out at the last moments that the problem may be too similar to a problem (that is used a looooooooong time ago), so we decided to switch that problem with something else. And that's why this problem is here.It's too bad, the problem proposed by havaliza is actually very nice. Perhaps we will see it in one of the upcoming rounds :) Problem CAuthor: dolphinigle DFSLet's drop the (modulo K). That is, the rule becomes: X->Y implies that Y = X+1 Y->X implies that Y = X-1 Notice that this problem is then equivalent to finding the maximum possible K such that the above equation holds for all edges, modulo K.While we still dropping the \"modulo K\" thingy, we try to calculate the values of each node. We iterate over each node, and if we haven't processed the node: Number the node 0 (or any other number you like). let's denote this by no[i] = 0. DFS the node: DFS(X): if there exists X->Y, then no[Y] = no[X]+1. This follows from the first rule. DFS(X): if there exists Y->X, then no[Y] = no[X]-1. This follows from the second rule. If Y is renumbered (that is, the algorithm has renumber it in the past and we renumber it again), consider the difference between the two numbers. We claim that this difference, if not zero, must be a multiple of K. To see this, suppose the two numbers are A and B. By the way our algorithm works, that node must be able to be numbered A or B. Hence, A == B (mod K) must holds. But then, A-B == 0 (mod K) implies that (A-B) is a multiple of K. If a non-empty multiple of K (let's say it's CYCLEN) is not found in the step above, we claim that the answer is the maximum possible answer: N. Indeed if no such value is found, it means that renumbering the nodes into no[i] % N be correct, since every edge is already consistent with no[i]. Otherwise, we can simply brute force all divisors of CYCLEN and try each of them. Since \"trying\" uses O(E) time (that is, by setting each number into no[i] % K and checking whether the two rules holds for all edges) , we have a O(number_of_divisors * E) algorithm, which with the given constraints is less than O(E * sqrt(N)). For instance, sexyprincess91 implemented this. 1632321 Problem DAuthor: dolphinigle Dynamic Programming, Probabilities, and a little GreedySuppose we have decided to bring N1 T-shirts of size 1, N2 T-shirts of size 2, ... NM T-shirts of size M. By the linearity of expectation, the expected number of engineers that will receive a T-shirt is equal to the sum of the expected number of engineers that will receive a T-shirt of size K, for all K.Suppose we bring Ni T-shirts of size i. Define a random variable Xij as the number of engineer that will receive the j-th T-shirt of size Ni that we bring. Hence, the expected number of engineers that will receive the Ni T-shirts of size i that we bring is equal to the sum of Xij over all j. Since Xij is either 0 or 1, Xij is equal to Pij, the probability that there will be an engineer that will receive the j-th T-shirt of size i that we bring. This is equal to the probability that there will be at least j engineers that fits inside T-shirt of size i.As a result of our discussion, to maximize the expectation, it boils to maximizing the sum over Xij. Hence, we receive our first solution: Calculate the value of all Xij, and pick the N largest value. A DP implementation allows us to accumulate all Xij value in O(N*N*M) time, yielding an O(N*N*M) solution.We will now reduce the time limit to O(N*N + N*M). Notice that the algorithm above only need us to find the N largest values of Xij. Denote by f(n, i, j) the probability that, amongst engineers numbere 1 through n, at least j of them fits inside T-shirt of size i. f(n, i, j) can be computed with the following recurrence: f(n, i, j) = f(n-1, i, j-1) * fit_chance(n, i) + f(n-1, i, j) * (1.0 — fit_change(n, i)) Where fit_chance(t-shirt, engineer) is the probability that engineer fits inside the t-shirt size.The formula above can be inferred from simple logic: if the n-th engineer fits inside t-shirt of size i (with fit_change(n, i) probability), then f(n, i, j) is obviously equal to f(n-1, i, j-1). Otherwise, it'll equal f(n-1, i, j).Now, observe that Xij = f(N, i, j). Indeed, this is one of the possible DPs that can lead to the O(N*N*M) solution. However, we will show that we do not need to compute f(n, i, j) for all possible inputs if we're asked to find only the N largest values of Xij.The key observation is the following obvious fact. If Xij is included in the N largest values, then Xi(j-1) must also be included there. Inductively, Xik for k < j must also be included in the N largest values. Indeed, it's obvious that Xij must be non-increasing with respect to j.Hence the algorithm works as follows. First, we create a pool of numbers Xi1, for all i, totalling M numbers. Then, we iterate N times. In each iteration, we pick the largest number in the pool, say, Xij. Then, we add Xij as one of the K largest values. Then, we take out Xij from the pool, and insert Xi(j+1) as its replacement. That it correctly picks the N largest Xij values follows immediately from our argument in the paragraph preceeding this.Now, if we use the recurrence f(n, i, j) above to compute each Xij, what is the complexity of this algorithm? If we memoize f(n, i, j), we claim that it's O(N*N + N*M). To see this, we notice that the only values required to compute f(n, i, j) using the recurrence above are the values f(m, i, l) such that m <= n and l <= j. However, we notice that due to how our algorithm works, when we need to compute Xij, we must have already computed Xi(j-1) before, so that all values f(m, i, l) for m <= n and l <= j-1 are already available. So the only NEW values that we need to compute are f(m, i, j), m <= n. There are n such values.Since we need to compute at most O(N) values of Xij, the total complexity this part contributes is O(N*N). Depending on how you implement the \"pick largest from pool\" algorithm, the total complexity can be either O(N*N + N*M) or O(N*N + N*log M).Yes, somebody did this in the contest :). Dmitry_Egorov 1632270 saved my problem from loneliness :)Bonus Section: Now here's an extremely interesting solution shown by the following Python pseudocode: values = []\nfor size in range(M):\n i = 1\n while (val = f(N, size, i)) > epsilon:\n values.append(val)\n ++i\n end\nend\nPrint the sum of the largest N values in array values.Its correctness is immediate as long as epsilon is reasonably small (since f(N, size, i) is non-increasing with respect to i). What is the complexity of this very simple algorithm?I am unable to come up with a hard, solid proof, but since f(N, size, i) exponentially falls (except if some probabilities are 1, in which case some other T-shirt must have less value to worry on), the complexity is somewhere near O(N * N). Indeed for the current set of test cases, its speed exceeds that of the intended solution.Although rng_58 do not implement this exact algorithm, he used the <EPS ignore idea in his solution 1631960RemarksI really really wanted to link Gerald's handle in the statement :). Too bad Codeforces doesn't support it. Problem EAuthor: dolphinigle Very greedyBrute force P: the number of Packages each kid will have at the end. There are at most N/M possible such value. We will assume that P is fixed during our discussion.If we know P, we know that if kid i purchases a total of X candies, then kid i+1 must purchase at least X+P candies (1 more than each package purchased by kid i). Hence, assume that money[i] <= money[i+1] — P.Two consecutive packages purchased by the SAME kid must differ by at least M. Indeed, otherwise there are less than M-1 packages for the other M-1 kids to buy from (Pigeonhole rocks by the way).For the sake of our discussions below, we refer to the following example with N=8, and M=3 kids. The allowances of the kids are 7, 10, and 14.Suppose we know all candies kid 0 purchased (red bags denote the packages kid 0 purchased).We claim that the optimal solution can be computed rather... easily with the following greedy algorithm: (assume that the candy packages kid 0 purchase is sorted in an ascending order). We iterate over the remaining kids, starting from kid 1. First, let the kid purchase the minimum possible candies:Next, if the allowance is still greater than the sum of candies, and if one of his package(s) can still be shifted to the right while maintaining the condition that a possible solution exists, do so. If there are multiple package(s) that can be shifted, shifting any of them does not change the optimal answer.Note: since we've assumed that money[i] <= money[i+1]-P, the only condition is that between the package purchased by kid 1 an the next package purchased by kid 0, there exists at least N-2 packages. For instance, this is illegal, since there is no package that kid 2 will be able to purchase between 4 and 5.We iterate this once more for kid 2, obtaining:And we're done. It's arguably the maximum possible value, since there is no reason why we shouldn't shift a package for a kid to the right if we can (formal proof by contradiction).Claim: If we know the packages for kid 0, the maximum total candies purchased can be computed in O(M), where M is the number of kids.The algorithm simulates our discussion above. However it is not obvious how to do that in O(M). So, suppose kid 0 purchase the candies like this:Now, try putting the other P-1 packages into the minimum possible locations:The packages inside the yellow boxes denote what we will call FREEDOM. Basically FREEDOM is the count on how many times we can at most shift a package to the right as in our discussion above.Now, consider kid 1. First, as in our discussion, kid 1 takes the minimum amount of packages, which is equal to sum[kid 0] + P. Next, he will attempt to shift the packages if possible. Notice that the only thing that affects the overall sum of the candy is only the number of shifts performed, not which package actually got shifted. So, this means that, the amount of shift can be easily calculated by min(money[1] — (sum[kid 0] + P), FREEDOM). And then, FREEDOM is deducted from this value, while the amount of candies purchased by kid 1 is incremented by this value.Hence, simulating the algorithm in our discussion if we're only to output the total amount of candies can be done in O(M).The result of our discussion so far is this. Notice that the last algorithm only depends on how many candies kid 0 purchased, and FREEDOM.Now we will remove the assumption that we know which packages kid 0 decides to purchase.Claim: It is optimal for kid 0 to purchase as many candies as possible.Suppose kid 0 does not purchase the maximum possible of candies he can purchase. Now, consider whether or not kid 1 \"shifted\" his candies. If he shifted any of them, say package X, then instead of purchasing package X-1, kid 0 should purchase package X, improving the overall amount of candies. That is, instead of It's better to If kid 1 did not \"shift\" his candies because the amount of money he spent is already equal to his allowance, then the amount of candies purchased by kid 0 must be maximum since money[i] <= money[i+1] — P. Otherwise, we can apply this inductively to kid 2 and so forth. That is, instead of It's better to Okay, now we know the sum of candies that we should give to kid 1. Since the performance of our algorithm increase with FREEDOM, we should next try to maximize FREEDOM.Claim: FREEDOM depends only on the position of the FIRST candy package purchased by kid 0.This can be shown by simple computation, and its equal to N — pos — M*P (or something like that).Hence, we should try to minimize the first candy package purchased by kid 0, while keeping the sum maximum. This can be done in O(1) using a bunch of N*(N+1)/M * P formulas.Hence, since there are N/M package numbers to be brute forced, and each iteration uses O(M) time, the total complexity is O(N/M) * O(M) = O(N).For instance, see 1632210 by rng_58 (again :) ).EpilogueThank you for participating in the match!Hope to see you again!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4419",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 15290
        }
      ],
      "code_examples": [
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 1",
          "code": "values = []\nfor size in range(M):\n  i = 1\n  while (val = f(N, size, i)) > epsilon:\n    values.append(val)\n    ++i\n  end\nend\nPrint the sum of the largest N values in array values.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "Qingyu"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 2",
          "code": "values = []\nfor size in range(M):\n  i = 1\n  while (val = f(N, size, i)) > epsilon:\n    values.append(val)\n    ++i\n  end\nend\nPrint the sum of the largest N values in array values.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "Qingyu"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 3",
          "code": "void sort(Line a, Line b) {  if (a.gradient != b.gradient) return a.gradient < b.gradient;  return a.intercept < b.intercept; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "Qingyu"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 4",
          "code": "it means that renumbering the nodes into no[i] % N be correct, since every edge is already consistent with no[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "Qingyu"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 5",
          "code": "it means that renumbering the nodes into no[i] % N be correct, since every edge is already consistent with no[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> probs = inf.readInts(m, 0, 1000, \"probabilities\");\n        inf.readEoln();\n        int sum = 0;\n        for (int p : probs)\n            sum += p;\n        ensuref(sum == 1000, \"Sum of probabilities for engineer %d is %d, expected 1000\", i+1, sum);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> probs = inf.readInts(m, 0, 1000, \"probabilities\");\n        inf.readEoln();\n        int sum = 0;\n        for (int p : probs)\n            sum += p;\n        ensuref(sum == 1000, \"Sum of probabilities for engineer %d is %d, expected 1000\", i+1, sum);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 300, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> probs = inf.readInts(m, 0, 1000, \"probabilities\");\n        inf.readEoln();\n        int sum = 0;\n        for (int p : probs)\n            sum += p;\n        ensuref(sum == 1000, \"Sum of probabilities for engineer %d is %d, expected 1000\", i+1, sum);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register the generator. Do not set the random seed.\n    registerGen(argc, argv, 1);\n\n    // Read command line parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, m);\n\n    if (type == \"random\") {\n        // Random probabilities for each engineer, sum up to 1000\n        for (int i = 0; i < n; ++i) {\n            vector<int> probs(m);\n            for (int j = 0; j < m; ++j) {\n                probs[j] = rnd.next(0, 1000);\n            }\n            int sum = accumulate(probs.begin(), probs.end(), 0);\n            if (sum == 0) {\n                // Assign 1000 to a random size if all zeros\n                probs[rnd.next(0, m - 1)] = 1000;\n            } else {\n                // Normalize to sum up to 1000\n                for (int j = 0; j < m; ++j) {\n                    probs[j] = probs[j] * 1000 / sum;\n                }\n                int total = accumulate(probs.begin(), probs.end(), 0);\n                // Adjust any rounding error to make the sum exactly 1000\n                probs[rnd.next(0, m - 1)] += 1000 - total;\n            }\n            for (int j = 0; j < m; ++j) {\n                printf(\"%d%c\", probs[j], j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"uniform\") {\n        // Equal probability for each size\n        vector<int> base_probs(m, 1000 / m);\n        int remainder = 1000 % m;\n        for (int i = 0; i < remainder; ++i) {\n            base_probs[i]++;\n        }\n        for (int i = 0; i < n; ++i) {\n            // Output the same probabilities for each engineer\n            for (int j = 0; j < m; ++j) {\n                printf(\"%d%c\", base_probs[j], j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"deterministic\") {\n        // Each engineer fits exactly one size\n        for (int i = 0; i < n; ++i) {\n            vector<int> probs(m, 0);\n            int size = rnd.next(0, m - 1); // Randomly choose a size\n            probs[size] = 1000; // 100% probability for that size\n            for (int j = 0; j < m; ++j) {\n                printf(\"%d%c\", probs[j], j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"one_size\") {\n        // All engineers fit only in size 1\n        for (int i = 0; i < n; ++i) {\n            vector<int> probs(m, 0);\n            probs[0] = 1000; // 100% probability for size 1\n            for (int j = 0; j < m; ++j) {\n                printf(\"%d%c\", probs[j], j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"skewed\") {\n        // Probabilities skewed towards certain sizes\n        int k = opt<int>(\"k\", std::max(1, m / 2)); // Number of sizes to skew towards\n        vector<int> skew_sizes(k);\n        iota(skew_sizes.begin(), skew_sizes.end(), 0); // Skew towards sizes 0 to k-1\n        for (int i = 0; i < n; ++i) {\n            vector<int> probs(m, 1); // Start with minimal probability\n            int remaining = 1000 - m; // Remaining probability to distribute\n            // Assign higher probabilities to skewed sizes\n            for (int s : skew_sizes) {\n                int p = rnd.next(0, remaining);\n                probs[s] += p;\n                remaining -= p;\n            }\n            // Distribute any remaining probability randomly\n            while (remaining > 0) {\n                int idx = rnd.next(0, m - 1);\n                int p = rnd.next(1, remaining);\n                probs[idx] += p;\n                remaining -= p;\n            }\n            // Adjust possible rounding errors\n            int total = accumulate(probs.begin(), probs.end(), 0);\n            probs[rnd.next(0, m - 1)] += 1000 - total;\n            for (int j = 0; j < m; ++j) {\n                printf(\"%d%c\", probs[j], j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            vector<int> probs(m);\n            for (int j = 0; j < m; ++j) {\n                probs[j] = rnd.next(0, 1000);\n            }\n            int sum = accumulate(probs.begin(), probs.end(), 0);\n            if (sum == 0) {\n                probs[rnd.next(0, m - 1)] = 1000;\n            } else {\n                for (int j = 0; j < m; ++j) {\n                    probs[j] = probs[j] * 1000 / sum;\n                }\n                int total = accumulate(probs.begin(), probs.end(), 0);\n                probs[rnd.next(0, m - 1)] += 1000 - total;\n            }\n            for (int j = 0; j < m; ++j) {\n                printf(\"%d%c\", probs[j], j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register the generator. Do not set the random seed.\n    registerGen(argc, argv, 1);\n\n    // Read command line parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, m);\n\n    if (type == \"random\") {\n        // Random probabilities for each engineer, sum up to 1000\n        for (int i = 0; i < n; ++i) {\n            vector<int> probs(m);\n            for (int j = 0; j < m; ++j) {\n                probs[j] = rnd.next(0, 1000);\n            }\n            int sum = accumulate(probs.begin(), probs.end(), 0);\n            if (sum == 0) {\n                // Assign 1000 to a random size if all zeros\n                probs[rnd.next(0, m - 1)] = 1000;\n            } else {\n                // Normalize to sum up to 1000\n                for (int j = 0; j < m; ++j) {\n                    probs[j] = probs[j] * 1000 / sum;\n                }\n                int total = accumulate(probs.begin(), probs.end(), 0);\n                // Adjust any rounding error to make the sum exactly 1000\n                probs[rnd.next(0, m - 1)] += 1000 - total;\n            }\n            for (int j = 0; j < m; ++j) {\n                printf(\"%d%c\", probs[j], j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"uniform\") {\n        // Equal probability for each size\n        vector<int> base_probs(m, 1000 / m);\n        int remainder = 1000 % m;\n        for (int i = 0; i < remainder; ++i) {\n            base_probs[i]++;\n        }\n        for (int i = 0; i < n; ++i) {\n            // Output the same probabilities for each engineer\n            for (int j = 0; j < m; ++j) {\n                printf(\"%d%c\", base_probs[j], j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"deterministic\") {\n        // Each engineer fits exactly one size\n        for (int i = 0; i < n; ++i) {\n            vector<int> probs(m, 0);\n            int size = rnd.next(0, m - 1); // Randomly choose a size\n            probs[size] = 1000; // 100% probability for that size\n            for (int j = 0; j < m; ++j) {\n                printf(\"%d%c\", probs[j], j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"one_size\") {\n        // All engineers fit only in size 1\n        for (int i = 0; i < n; ++i) {\n            vector<int> probs(m, 0);\n            probs[0] = 1000; // 100% probability for size 1\n            for (int j = 0; j < m; ++j) {\n                printf(\"%d%c\", probs[j], j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else if (type == \"skewed\") {\n        // Probabilities skewed towards certain sizes\n        int k = opt<int>(\"k\", std::max(1, m / 2)); // Number of sizes to skew towards\n        vector<int> skew_sizes(k);\n        iota(skew_sizes.begin(), skew_sizes.end(), 0); // Skew towards sizes 0 to k-1\n        for (int i = 0; i < n; ++i) {\n            vector<int> probs(m, 1); // Start with minimal probability\n            int remaining = 1000 - m; // Remaining probability to distribute\n            // Assign higher probabilities to skewed sizes\n            for (int s : skew_sizes) {\n                int p = rnd.next(0, remaining);\n                probs[s] += p;\n                remaining -= p;\n            }\n            // Distribute any remaining probability randomly\n            while (remaining > 0) {\n                int idx = rnd.next(0, m - 1);\n                int p = rnd.next(1, remaining);\n                probs[idx] += p;\n                remaining -= p;\n            }\n            // Adjust possible rounding errors\n            int total = accumulate(probs.begin(), probs.end(), 0);\n            probs[rnd.next(0, m - 1)] += 1000 - total;\n            for (int j = 0; j < m; ++j) {\n                printf(\"%d%c\", probs[j], j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            vector<int> probs(m);\n            for (int j = 0; j < m; ++j) {\n                probs[j] = rnd.next(0, 1000);\n            }\n            int sum = accumulate(probs.begin(), probs.end(), 0);\n            if (sum == 0) {\n                probs[rnd.next(0, m - 1)] = 1000;\n            } else {\n                for (int j = 0; j < m; ++j) {\n                    probs[j] = probs[j] * 1000 / sum;\n                }\n                int total = accumulate(probs.begin(), probs.end(), 0);\n                probs[rnd.next(0, m - 1)] += 1000 - total;\n            }\n            for (int j = 0; j < m; ++j) {\n                printf(\"%d%c\", probs[j], j == m - 1 ? '\\n' : ' ');\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal n and m\n./gen -n 1 -m 1 -type deterministic\n./gen -n 1 -m 1 -type uniform\n./gen -n 1 -m 1 -type random\n\n# Minimal n, maximal m\n./gen -n 1 -m 300 -type deterministic\n./gen -n 1 -m 300 -type uniform\n./gen -n 1 -m 300 -type random\n\n# Maximal n, minimal m\n./gen -n 3000 -m 1 -type deterministic\n./gen -n 3000 -m 1 -type uniform\n./gen -n 3000 -m 1 -type random\n\n# Maximal n and m\n./gen -n 3000 -m 300 -type random\n./gen -n 3000 -m 300 -type deterministic\n./gen -n 3000 -m 300 -type uniform\n./gen -n 3000 -m 300 -type one_size\n./gen -n 3000 -m 300 -type skewed -k 10\n\n# Small n and m\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type deterministic\n./gen -n 10 -m 10 -type uniform\n\n# Medium n and m\n./gen -n 100 -m 50 -type random\n./gen -n 100 -m 50 -type deterministic\n./gen -n 100 -m 50 -type skewed -k 5\n\n# Large n, medium m\n./gen -n 1000 -m 100 -type random\n./gen -n 1000 -m 100 -type deterministic\n./gen -n 1000 -m 100 -type skewed -k 20\n./gen -n 1000 -m 100 -type uniform\n./gen -n 1000 -m 100 -type one_size\n\n# Test with engineers preferring the same size\n./gen -n 3000 -m 300 -type one_size\n\n# Test with maximal skew\n./gen -n 3000 -m 300 -type skewed -k 1\n\n# Test with minimal skew\n./gen -n 3000 -m 300 -type skewed -k 299\n\n# Random tests with varying n and m\n./gen -n 500 -m 200 -type random\n./gen -n 1500 -m 150 -type random\n./gen -n 2500 -m 250 -type random\n\n# Edge cases for type customized\n./gen -n 1 -m 300 -type skewed -k 1\n./gen -n 3000 -m 1 -type skewed -k 1\n\n# Uniform probabilities with maximal m\n./gen -n 1000 -m 300 -type uniform\n\n# Deterministic sizes with minimal m\n./gen -n 1000 -m 1 -type deterministic\n\n# Random tests with maximal n\n./gen -n 3000 -m 10 -type random\n./gen -n 3000 -m 50 -type random\n./gen -n 3000 -m 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:09.851679",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "183/E",
      "title": "E. Candy Shop",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (2 ≤ n ≤ 2·105, 2 ≤ m ≤ 5·106, n ≤ m), denoting the number of kids and the maximum number of candies in a package sold by the candy shop, respectively.Then n lines follow, each line will contain a single positive integer not exceeding  denoting the allowance of a kid in rubles. The allowances are given in order from kid 1 to kid n.Please, do not use the %lld specificator to read or write 64-bit integers in C++. It is recommended to use cin, cout streams (also you may use %I64d specificator).",
      "output_spec": "OutputPrint a single integer denoting the maximum number of candies that can be sold by the candy shop.",
      "sample_tests": "ExamplesInputCopy2 5510OutputCopy13InputCopy3 881613OutputCopy32InputCopy2 50000001250000250000012500002500000OutputCopy12500002500000",
      "description": "E. Candy Shop\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (2 ≤ n ≤ 2·105, 2 ≤ m ≤ 5·106, n ≤ m), denoting the number of kids and the maximum number of candies in a package sold by the candy shop, respectively.Then n lines follow, each line will contain a single positive integer not exceeding  denoting the allowance of a kid in rubles. The allowances are given in order from kid 1 to kid n.Please, do not use the %lld specificator to read or write 64-bit integers in C++. It is recommended to use cin, cout streams (also you may use %I64d specificator).\n\nOutputPrint a single integer denoting the maximum number of candies that can be sold by the candy shop.\n\nInputCopy2 5510OutputCopy13InputCopy3 881613OutputCopy32InputCopy2 50000001250000250000012500002500000OutputCopy12500002500000\n\nInputCopy2 5510\n\nOutputCopy13\n\nInputCopy3 881613\n\nOutputCopy32\n\nInputCopy2 50000001250000250000012500002500000\n\nOutputCopy12500002500000\n\nNoteFor the first example, one of the scenarios that will result in 13 purchased candies is as follows.   Turn 1. Kid 1 purchases 1 candy.  Turn 2. Kid 2 purchases 3 candies.  Turn 3. Kid 1 purchases 4 candies.  Turn 4. Kid 2 purchases 5 candies.",
      "solutions": [
        {
          "title": "CROC Champ 2012 — Round 3 (Final) - Codeforces",
          "content": "Croc Champ 2012 - FinalFinal Update: Congratulations to the prize winners! First place: neex.emil — 100000 rubles Runner Up: Dmitry_Egorov — Apple MacBook Pro 15 2nd Runner Up: vepifanov — Apple MacBook Pro 13 Videos for the onsite round (posted by ivan.popelyshev): 1 2 3 4 5 6Congratulations to the winners of the mixed group (onsite & offsite)! ivan.metelsky YuukaKazami neex.emilrng_58 deserves honorable mention for the only competitor to correctly submit both D and E :)Editorial.Hello Codeforces!I am glad to welcome you — both onsite and out-of-competition competitors — to the final round of Open Moscow Programming Championship By CROC. I am the writer of this round — Gerald, ivan.popelyshev and Delinur helped me in the preparation of the problems. This is my second round in Codeforces, so far, thanks to the Codeforces team and MikeMirzayanov for giving me this opportunity again!Please note that this round is held in conjunction with its onsite counterpart, so its starting time may be delayed. Also, since MikeMirzayanov is very busy with the onsite contest at the moment to decrease the load (to avoid any disaster for the onsite competition), I apologize that you may not receive any email reminder about this match.I've taken feedbacks from my last match into account, so the pretests will be fairly strong. The match should be more interesting for you if you decide to try and solve as many problem as possible, instead of stopping and hacking other codes early in the match :)The rules below are copied-modified from Ripatti's post:Competition will happen by usual rules of Codeforces, with hacks and score falling in process of time. The three championship winners will be awarded valuable prizes: 100000 rubles for the first place Apple MacBook Pro 15 for the second place Apple MacBook Pro 13 for the third place Please remember that the round will be rated only for onsite participants and Division 1 contestants, since the problemset may be more tricky than usual (or it may not be :) ). Division 2 coders can participate, but it will not be rated for them.There will be five problems ordered by approximately increasing complexity. The scores will be 500-1000-1500-2000-2500. Don’t forget that during contest your solutions will be tested on a small set of pretests. Testing on full testset will be after end of the round. Pretests can don’t cover all cases of input data, so you should test your solutions very carefully.It is strictly forbidden to publish statements/solutions of the problems before round will be end. Also you shouldn’t to talk about problems, discuss some things about possible solutions of them. Let’s be honest! You can discuss problems after the end of round.Good luck everyone! I will be watching :)",
          "author": "dolphinigle",
          "url": "https://codeforces.com/blog/entry/4425",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2752
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces",
          "content": "This is the editorial for Croc Champ 2012 - Final RemarksOne day, I applied to write another round in Codeforces. To my surprise, I was offered to write CROC instead. I'm quite surprised they offer me (an unknown programmer from a notorious country) to write for such an important match! So I happily oblige — kudos for the open culture nurtured by Codeforces!I like most the problems of this final round. I think all of them are beautiful in some aspects :). Oh, and all of them emits such concise solutions ;). Problem AAuthor: dolphinigle Ad Hoc I supppose...This problem is equivalent to calculating the number of reachable locations from point (0, 0) by doing the allowed moves.The naive solution is to process the information one by one from first to last, and to keep track on all the reachable positions.Claim: At any moment in time, all reachable locations as described above forms a \"diamond\".An extremely informal proof is by induction:For instance, let's use the first example: UR UL ULDRInitially, there's only one possible location (namely, (0, 0)). It forms the basis of our induction: a diamond with width=1 and height=1. \"UR\" (and also \"DL\") extends the width of the diamond into a 2x1 diamond: Then, \"UL\" (and also \"DR\") extends the height of the diamond into a 2x2 diamond: Finally, \"ULDR\" extends both the height and the width of the diamond into a 3x3 diamond: And so there's 9 possible locations.To see that this claim is true, suppose by induction our locations so far forms a diamond. By symmetry we only need to see that in the \"UR\" case, its width is increased by one (I'll omit the similarly seen \"ULDR\" case). The idea is the new possible locations = the previous diamond shifted one step up UNION that diamond shifted one step right. Indeed, the union of these two diamonds accounts for both the \"U\" and the \"R\" moves. It's not hard to proof that the union of two diamonds with equal dimension that is displaced by vector (1, 1) forms the same diamond with its width increased by 1.So, the solution is to keep track the dimension of the diamond, starting from a 1x1 diamond. Then, simply return width * height.Reference: See 1631223 by Endagorion (my favorite CF author! :) ). Problem BAuthor: dolphinigle GeometrySince there are at least one flamingo, all binoculars will be able to see at least one flamingo. When a binocular is able to see more than one flamingos, then those two flamingos and the binocular must form a line. How many such lines are there?Instead of iterating for each pair of binocular and flamingo, we iterate over each pair of flamingos. These two pair of flamingos completely determine the line as described above. If there does not exists a binocular in this line, we can ignore this pair and continue. Otherwise, calculate the number of flamingos in this line, and let it be one of the possible number of flamingos visible from that binocular.After this is done, simply sum the maximum number of flamingos of each binocular. This works in O(M^3). Note that this problem can be made to run in O(M^2 log M), but coding that solution is sort of... boring ;3.For instance, see vepifanov's 1631294 RemarksActually havaliza prepared a much nicer B problem. Unfortunately, we found out at the last moments that the problem may be too similar to a problem (that is used a looooooooong time ago), so we decided to switch that problem with something else. And that's why this problem is here.It's too bad, the problem proposed by havaliza is actually very nice. Perhaps we will see it in one of the upcoming rounds :) Problem CAuthor: dolphinigle DFSLet's drop the (modulo K). That is, the rule becomes: X->Y implies that Y = X+1 Y->X implies that Y = X-1 Notice that this problem is then equivalent to finding the maximum possible K such that the above equation holds for all edges, modulo K.While we still dropping the \"modulo K\" thingy, we try to calculate the values of each node. We iterate over each node, and if we haven't processed the node: Number the node 0 (or any other number you like). let's denote this by no[i] = 0. DFS the node: DFS(X): if there exists X->Y, then no[Y] = no[X]+1. This follows from the first rule. DFS(X): if there exists Y->X, then no[Y] = no[X]-1. This follows from the second rule. If Y is renumbered (that is, the algorithm has renumber it in the past and we renumber it again), consider the difference between the two numbers. We claim that this difference, if not zero, must be a multiple of K. To see this, suppose the two numbers are A and B. By the way our algorithm works, that node must be able to be numbered A or B. Hence, A == B (mod K) must holds. But then, A-B == 0 (mod K) implies that (A-B) is a multiple of K. If a non-empty multiple of K (let's say it's CYCLEN) is not found in the step above, we claim that the answer is the maximum possible answer: N. Indeed if no such value is found, it means that renumbering the nodes into no[i] % N be correct, since every edge is already consistent with no[i]. Otherwise, we can simply brute force all divisors of CYCLEN and try each of them. Since \"trying\" uses O(E) time (that is, by setting each number into no[i] % K and checking whether the two rules holds for all edges) , we have a O(number_of_divisors * E) algorithm, which with the given constraints is less than O(E * sqrt(N)). For instance, sexyprincess91 implemented this. 1632321 Problem DAuthor: dolphinigle Dynamic Programming, Probabilities, and a little GreedySuppose we have decided to bring N1 T-shirts of size 1, N2 T-shirts of size 2, ... NM T-shirts of size M. By the linearity of expectation, the expected number of engineers that will receive a T-shirt is equal to the sum of the expected number of engineers that will receive a T-shirt of size K, for all K.Suppose we bring Ni T-shirts of size i. Define a random variable Xij as the number of engineer that will receive the j-th T-shirt of size Ni that we bring. Hence, the expected number of engineers that will receive the Ni T-shirts of size i that we bring is equal to the sum of Xij over all j. Since Xij is either 0 or 1, Xij is equal to Pij, the probability that there will be an engineer that will receive the j-th T-shirt of size i that we bring. This is equal to the probability that there will be at least j engineers that fits inside T-shirt of size i.As a result of our discussion, to maximize the expectation, it boils to maximizing the sum over Xij. Hence, we receive our first solution: Calculate the value of all Xij, and pick the N largest value. A DP implementation allows us to accumulate all Xij value in O(N*N*M) time, yielding an O(N*N*M) solution.We will now reduce the time limit to O(N*N + N*M). Notice that the algorithm above only need us to find the N largest values of Xij. Denote by f(n, i, j) the probability that, amongst engineers numbere 1 through n, at least j of them fits inside T-shirt of size i. f(n, i, j) can be computed with the following recurrence: f(n, i, j) = f(n-1, i, j-1) * fit_chance(n, i) + f(n-1, i, j) * (1.0 — fit_change(n, i)) Where fit_chance(t-shirt, engineer) is the probability that engineer fits inside the t-shirt size.The formula above can be inferred from simple logic: if the n-th engineer fits inside t-shirt of size i (with fit_change(n, i) probability), then f(n, i, j) is obviously equal to f(n-1, i, j-1). Otherwise, it'll equal f(n-1, i, j).Now, observe that Xij = f(N, i, j). Indeed, this is one of the possible DPs that can lead to the O(N*N*M) solution. However, we will show that we do not need to compute f(n, i, j) for all possible inputs if we're asked to find only the N largest values of Xij.The key observation is the following obvious fact. If Xij is included in the N largest values, then Xi(j-1) must also be included there. Inductively, Xik for k < j must also be included in the N largest values. Indeed, it's obvious that Xij must be non-increasing with respect to j.Hence the algorithm works as follows. First, we create a pool of numbers Xi1, for all i, totalling M numbers. Then, we iterate N times. In each iteration, we pick the largest number in the pool, say, Xij. Then, we add Xij as one of the K largest values. Then, we take out Xij from the pool, and insert Xi(j+1) as its replacement. That it correctly picks the N largest Xij values follows immediately from our argument in the paragraph preceeding this.Now, if we use the recurrence f(n, i, j) above to compute each Xij, what is the complexity of this algorithm? If we memoize f(n, i, j), we claim that it's O(N*N + N*M). To see this, we notice that the only values required to compute f(n, i, j) using the recurrence above are the values f(m, i, l) such that m <= n and l <= j. However, we notice that due to how our algorithm works, when we need to compute Xij, we must have already computed Xi(j-1) before, so that all values f(m, i, l) for m <= n and l <= j-1 are already available. So the only NEW values that we need to compute are f(m, i, j), m <= n. There are n such values.Since we need to compute at most O(N) values of Xij, the total complexity this part contributes is O(N*N). Depending on how you implement the \"pick largest from pool\" algorithm, the total complexity can be either O(N*N + N*M) or O(N*N + N*log M).Yes, somebody did this in the contest :). Dmitry_Egorov 1632270 saved my problem from loneliness :)Bonus Section: Now here's an extremely interesting solution shown by the following Python pseudocode: values = []\nfor size in range(M):\n i = 1\n while (val = f(N, size, i)) > epsilon:\n values.append(val)\n ++i\n end\nend\nPrint the sum of the largest N values in array values.Its correctness is immediate as long as epsilon is reasonably small (since f(N, size, i) is non-increasing with respect to i). What is the complexity of this very simple algorithm?I am unable to come up with a hard, solid proof, but since f(N, size, i) exponentially falls (except if some probabilities are 1, in which case some other T-shirt must have less value to worry on), the complexity is somewhere near O(N * N). Indeed for the current set of test cases, its speed exceeds that of the intended solution.Although rng_58 do not implement this exact algorithm, he used the <EPS ignore idea in his solution 1631960RemarksI really really wanted to link Gerald's handle in the statement :). Too bad Codeforces doesn't support it. Problem EAuthor: dolphinigle Very greedyBrute force P: the number of Packages each kid will have at the end. There are at most N/M possible such value. We will assume that P is fixed during our discussion.If we know P, we know that if kid i purchases a total of X candies, then kid i+1 must purchase at least X+P candies (1 more than each package purchased by kid i). Hence, assume that money[i] <= money[i+1] — P.Two consecutive packages purchased by the SAME kid must differ by at least M. Indeed, otherwise there are less than M-1 packages for the other M-1 kids to buy from (Pigeonhole rocks by the way).For the sake of our discussions below, we refer to the following example with N=8, and M=3 kids. The allowances of the kids are 7, 10, and 14.Suppose we know all candies kid 0 purchased (red bags denote the packages kid 0 purchased).We claim that the optimal solution can be computed rather... easily with the following greedy algorithm: (assume that the candy packages kid 0 purchase is sorted in an ascending order). We iterate over the remaining kids, starting from kid 1. First, let the kid purchase the minimum possible candies:Next, if the allowance is still greater than the sum of candies, and if one of his package(s) can still be shifted to the right while maintaining the condition that a possible solution exists, do so. If there are multiple package(s) that can be shifted, shifting any of them does not change the optimal answer.Note: since we've assumed that money[i] <= money[i+1]-P, the only condition is that between the package purchased by kid 1 an the next package purchased by kid 0, there exists at least N-2 packages. For instance, this is illegal, since there is no package that kid 2 will be able to purchase between 4 and 5.We iterate this once more for kid 2, obtaining:And we're done. It's arguably the maximum possible value, since there is no reason why we shouldn't shift a package for a kid to the right if we can (formal proof by contradiction).Claim: If we know the packages for kid 0, the maximum total candies purchased can be computed in O(M), where M is the number of kids.The algorithm simulates our discussion above. However it is not obvious how to do that in O(M). So, suppose kid 0 purchase the candies like this:Now, try putting the other P-1 packages into the minimum possible locations:The packages inside the yellow boxes denote what we will call FREEDOM. Basically FREEDOM is the count on how many times we can at most shift a package to the right as in our discussion above.Now, consider kid 1. First, as in our discussion, kid 1 takes the minimum amount of packages, which is equal to sum[kid 0] + P. Next, he will attempt to shift the packages if possible. Notice that the only thing that affects the overall sum of the candy is only the number of shifts performed, not which package actually got shifted. So, this means that, the amount of shift can be easily calculated by min(money[1] — (sum[kid 0] + P), FREEDOM). And then, FREEDOM is deducted from this value, while the amount of candies purchased by kid 1 is incremented by this value.Hence, simulating the algorithm in our discussion if we're only to output the total amount of candies can be done in O(M).The result of our discussion so far is this. Notice that the last algorithm only depends on how many candies kid 0 purchased, and FREEDOM.Now we will remove the assumption that we know which packages kid 0 decides to purchase.Claim: It is optimal for kid 0 to purchase as many candies as possible.Suppose kid 0 does not purchase the maximum possible of candies he can purchase. Now, consider whether or not kid 1 \"shifted\" his candies. If he shifted any of them, say package X, then instead of purchasing package X-1, kid 0 should purchase package X, improving the overall amount of candies. That is, instead of It's better to If kid 1 did not \"shift\" his candies because the amount of money he spent is already equal to his allowance, then the amount of candies purchased by kid 0 must be maximum since money[i] <= money[i+1] — P. Otherwise, we can apply this inductively to kid 2 and so forth. That is, instead of It's better to Okay, now we know the sum of candies that we should give to kid 1. Since the performance of our algorithm increase with FREEDOM, we should next try to maximize FREEDOM.Claim: FREEDOM depends only on the position of the FIRST candy package purchased by kid 0.This can be shown by simple computation, and its equal to N — pos — M*P (or something like that).Hence, we should try to minimize the first candy package purchased by kid 0, while keeping the sum maximum. This can be done in O(1) using a bunch of N*(N+1)/M * P formulas.Hence, since there are N/M package numbers to be brute forced, and each iteration uses O(M) time, the total complexity is O(N/M) * O(M) = O(N).For instance, see 1632210 by rng_58 (again :) ).EpilogueThank you for participating in the match!Hope to see you again!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4419",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 15290
        }
      ],
      "code_examples": [
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 1",
          "code": "values = []\nfor size in range(M):\n  i = 1\n  while (val = f(N, size, i)) > epsilon:\n    values.append(val)\n    ++i\n  end\nend\nPrint the sum of the largest N values in array values.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 2",
          "code": "values = []\nfor size in range(M):\n  i = 1\n  while (val = f(N, size, i)) > epsilon:\n    values.append(val)\n    ++i\n  end\nend\nPrint the sum of the largest N values in array values.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 3",
          "code": "void sort(Line a, Line b) {  if (a.gradient != b.gradient) return a.gradient < b.gradient;  return a.intercept < b.intercept; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 4",
          "code": "it means that renumbering the nodes into no[i] % N be correct, since every edge is already consistent with no[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        },
        {
          "title": "CROC Champ 2012 — Round 3 (Editorial) - Codeforces - Code 5",
          "code": "it means that renumbering the nodes into no[i] % N be correct, since every edge is already consistent with no[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4419",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000); // 2 ≤ n ≤ 2×10^5\n    inf.readSpace();\n    int m = inf.readInt(2, 5000000); // 2 ≤ m ≤ 5×10^6\n    inf.readEoln();\n\n    ensuref(n <= m, \"n must be less than or equal to m\");\n\n    for (int i = 0; i < n; ++i) {\n        long long ai = inf.readLong(1LL, 50000000000000LL); // 1 ≤ ai ≤ 5×10^13\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000); // 2 ≤ n ≤ 2×10^5\n    inf.readSpace();\n    int m = inf.readInt(2, 5000000); // 2 ≤ m ≤ 5×10^6\n    inf.readEoln();\n\n    ensuref(n <= m, \"n must be less than or equal to m\");\n\n    for (int i = 0; i < n; ++i) {\n        long long ai = inf.readLong(1LL, 50000000000000LL); // 1 ≤ ai ≤ 5×10^13\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000); // 2 ≤ n ≤ 2×10^5\n    inf.readSpace();\n    int m = inf.readInt(2, 5000000); // 2 ≤ m ≤ 5×10^6\n    inf.readEoln();\n\n    ensuref(n <= m, \"n must be less than or equal to m\");\n\n    for (int i = 0; i < n; ++i) {\n        long long ai = inf.readLong(1LL, 50000000000000LL); // 1 ≤ ai ≤ 5×10^13\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 5000000);\n    m = max(m, n); // Ensure m >= n\n    string type = opt<string>(\"type\", \"random\");\n    long long max_allowance = opt<long long>(\"max_allowance\", 12500002500000LL);\n\n    vector<long long> a(n);\n\n    if (type == \"max_allowance\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = max_allowance;\n    } else if (type == \"min_allowance\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"random_allowance\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1LL, max_allowance);\n    } else if (type == \"constant_allowance\") {\n        long long val = rnd.next(1LL, max_allowance);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"increasing_allowance\") {\n        long long curr = rnd.next(1LL, max_allowance / n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = curr;\n            curr += rnd.next(0LL, (max_allowance - curr) / (n - i + 1));\n            if (curr > max_allowance)\n                curr = max_allowance;\n        }\n    } else if (type == \"decreasing_allowance\") {\n        long long curr = max_allowance - rnd.next(0LL, max_allowance / n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = curr;\n            curr -= rnd.next(0LL, curr / (n - i + 1));\n            if (curr < 1)\n                curr = 1;\n        }\n    } else {\n        // Default random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1LL, max_allowance);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld\\n\", a[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 5000000);\n    m = max(m, n); // Ensure m >= n\n    string type = opt<string>(\"type\", \"random\");\n    long long max_allowance = opt<long long>(\"max_allowance\", 12500002500000LL);\n\n    vector<long long> a(n);\n\n    if (type == \"max_allowance\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = max_allowance;\n    } else if (type == \"min_allowance\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"random_allowance\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1LL, max_allowance);\n    } else if (type == \"constant_allowance\") {\n        long long val = rnd.next(1LL, max_allowance);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"increasing_allowance\") {\n        long long curr = rnd.next(1LL, max_allowance / n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = curr;\n            curr += rnd.next(0LL, (max_allowance - curr) / (n - i + 1));\n            if (curr > max_allowance)\n                curr = max_allowance;\n        }\n    } else if (type == \"decreasing_allowance\") {\n        long long curr = max_allowance - rnd.next(0LL, max_allowance / n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = curr;\n            curr -= rnd.next(0LL, curr / (n - i + 1));\n            if (curr < 1)\n                curr = 1;\n        }\n    } else {\n        // Default random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1LL, max_allowance);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld\\n\", a[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -type min_allowance\n./gen -n 2 -m 2 -type max_allowance\n./gen -n 2 -m 100 -type random_allowance\n\n./gen -n 10 -m 15 -type random_allowance\n./gen -n 10 -m 15 -type constant_allowance\n./gen -n 10 -m 15 -type increasing_allowance\n./gen -n 10 -m 15 -type decreasing_allowance\n\n./gen -n 100 -m 1000 -type random_allowance\n./gen -n 100 -m 1000 -type max_allowance\n\n./gen -n 1000 -m 10000 -type random_allowance\n./gen -n 1000 -m 10000 -type min_allowance\n\n./gen -n 10000 -m 20000 -type random_allowance\n\n./gen -n 50000 -m 100000 -type constant_allowance\n\n./gen -n 100000 -m 500000 -type increasing_allowance\n\n./gen -n 150000 -m 1000000 -type decreasing_allowance\n\n./gen -n 200000 -m 5000000 -type max_allowance\n\n./gen -n 200000 -m 5000000 -type min_allowance\n\n./gen -n 1000 -m 5000 -type min_allowance\n\n./gen -n 100000 -m 100000 -type random_allowance\n\n./gen -n 200000 -m 5000000 -type constant_allowance\n\n./gen -n 200000 -m 5000000 -type random_allowance\n\n./gen -n 2 -m 5000000 -type max_allowance\n\n./gen -n 200000 -m 200000 -type random_allowance\n\n./gen -n 123456 -m 345678 -type random_allowance\n\n./gen -n 199999 -m 4000000 -type random_allowance\n\n./gen -n 200000 -m 5000000 -type random_allowance\n\n./gen -n 190000 -m 4800000 -type random_allowance\n\n# Additional test cases for corner cases\n\n./gen -n 2 -m 2 -type random_allowance\n./gen -n 2 -m 5 -type min_allowance\n./gen -n 2 -m 5 -type max_allowance\n\n./gen -n 3 -m 8 -type random_allowance\n\n./gen -n 2 -m 5000000 -type random_allowance\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:11.677939",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "185/A",
      "title": "A. Травяное растение",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке задано единственное целое число n (0 ≤ n ≤ 1018) — количество полных лет, которое росло растение.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++, вместо него рекомендуется использовать потоки cin, cout, а также спецификатор %I64d.",
      "output_spec": "Выходные данныеВыведите единственное число — остаток от деления количества смотрящих «вверх» растений через n лет на 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать1Выходные данныеСкопировать3Входные данныеСкопировать2Выходные данныеСкопировать10",
      "description": "A. Травяное растение\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке задано единственное целое число n (0 ≤ n ≤ 1018) — количество полных лет, которое росло растение.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++, вместо него рекомендуется использовать потоки cin, cout, а также спецификатор %I64d.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — остаток от деления количества смотрящих «вверх» растений через n лет на 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать1Выходные данныеСкопировать3Входные данныеСкопировать2Выходные данныеСкопировать10\n\nВходные данныеСкопировать1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПервый тестовый пример, соответствует второму треугольнику на рисунке в условии. Второй тестовый пример — третьему.",
      "solutions": [
        {
          "title": "Codeforces Round #118 - Codeforces",
          "content": "Здравствуйте! Уже в ближайшее время состоится второй раунд, в создании которого я принимаю участие. (Первый был — Codeforces Beta Round 56.) Он будет несколько похож на предыдущий. (Но тот вроде бы был не так плох. :-)!) Надеюсь этот Вам тоже понравится.Собственно я являюсь автором всех задач кроме одной, которую мне как раз предложил Gerald.Огромное спасибо Gerald за всё, он постоянно улучшал мои задачи.Так же соавтором со вчерашнего дня является cerealguy, который подготовил, на мой взгляд, самую сложную задачу в наборе. (Он стал соавтором после прорешивания первой версии контеста где-то за один час. :-)!)Также благодарность pashka, который в самом начале подготовки оценивал задачи. Конечно же спасибо главному переводчику кодефорсес — Delinur.А также спасибо системам \"Polygon\" и \"Codeforces\" при реализации раундаИ без грибов не обойдётся и этот раунд!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 865
        },
        {
          "title": "Editorial for Round #118 - Codeforces",
          "content": "Ни одна из задач не была специально взята с \"Wikipedia\". Для меня было очень поразительно, что задача \"B\" была там.A (Div 2). (Идея : Gerald, реализация : Aksenov239, код : 1670635)Если длины строк не равны — то ответ \"NO\". Далее мы ищем позиции, на которых символы в строчках не совпадают. Если таких позиций не 2 — \"NO\". Иначе меняем 2 символа не этих позциях в первой строке, и сравниваем строки.B (Div 2). (Идея : Aksenov239, реализация : Aksenov239, код : 1670637) Можно заметить, что всё можно считать в целых числах, так как k — целое число процентов. Для каждого гнома мы находим оптимальную стратегию — то есть проверяем 2 стратеги и выбираем лучшую. А далее просто сортируем. A (Div 1). (Идея : Aksenov239, реализация : Aksenov239, код : 1652592) Предположим, что после i-го года, у нас было x треугольников вверх и y треугольников вниз. После ещё одной итерации можно заметить, что количество треугольников стало — 3x + y вверх и x + 3y вниз. Рассмотрим разницу между ними: на i-ый год она равна x - y, а не i + 1-ый — (3x + y) - (x + 3y) = 2 * (x - y). Теперь ясно, что разница между количеством треугольников за год увеличивается в 2 раза. Так как на i-th год разница становится 2i и всего треугольников 4i. То на i-ый год количество треугольников, направленных вверх — . Это можно посчитать по модулю p, используя алгоритм быстрого возведения в степень.B (Div 1). (Идея : Aksenov239, реализация : Aksenov239, код : 1652597) Ответ на эту задачу: .Доказательство: . (Это неравенство о среднем арифметическом и среднем геометрическом. Для тех, кто желает ознакомиться.)Равенство достигается только при .Но надо не забывать про нули. Если a = b = c = 0 — вы должны выбрать какую-нибудь подходящую точку — x + y + z ≤ S.C (Div 1). Без комментариев. :-)!D (Div 1). (Идея : Aksenov239, реализация : cerealguy, Gerald, Aksenov239, код : 1652604)Это задачка на теорию чисел.Постараюсь объяснить всё по шагам:1) Сначала докажем, что НОД чисел не больше 2.Пусть . Возводим обе части в квадрат , а нам нужно, чтобы . Это означает, что d может быть только 2.2) Сделаем наше длинное произведение покороче..Мы это можем посчитать по модулю p быстро, и поделить на 2r - l, если k — нечётное.3) Но есть несколько ловушек.Первая — это не работает, когда p = 2 — но Вы справитесь сами.Другая проблема посложнее, что если , это означает, что для любого i ≥ l : , из чего следует,что для любого i ≥ l : k2i + 1 ≡ p2. И наше произведение по модулю p равно 2r - l + 1.E (Div. 1) (Идея : Aksenov239, реализация : cerealguy, код : 1652611)Эту задачу не взяли на РОИ, поэтому я предложил её здесь. На мой взгляд, задача вполне сложная. Если честно, я точно не знаю, что написал cerealguy, но его решение работает за O(nlogn) — без бин-поиска. Для меня это достаточно уже сложно, так как первоначальное решение было с ним. (Вроде, даже такие решения прошли.) Также были ещё решения с более худшей асимптотикой, но некоторые даже быстрее работали.Я могу Вам только дать ключевые идеи решения, которые Вам помогут. (В конце концов, вы можете посмотреть решение cerealguy)Идеи: Для каждого гнома найдём ближайшее метро. Это можно сделать за nlogn с помощью дерева отрезков или чего Вам там больше нравится. Можно заметить, что если гном идёт до метро, то другие гномы с меньшим расстоянием до метро, могут тоже идти туда — это никак не повлияет на ответ. Поэтому отсортируем гномов по этому расстоянию. Точки, до куда гном может дойти за t секунд, представляет собой ромб. И мы можем пересечь все ромбы за O(n) — пересечение будет похоже на прямоугольник. Построим начальное пересечение, когда никто не идёт в метро. Мы получим прямоугольник. Основная идея — для прямоугольника пересечения — ближайшее к нему метро всегда остаётся одним и тем же. Теперь можно пройтись по гномам в отсортированном порядке, мы умеем быстро пересчитывать прямоугольник пересечения — и поэтому можем быстро пересчитывать ответ. И у нас получается решение за O(nlogn). Та-дамс!Спасибо за Ваше внимание и понимание. Мне очень стыдно, за то что я натворил с задачей \"C\".",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4488",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4031
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #118 - Codeforces - Code 1",
          "code": "17:06. Паника!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 2",
          "code": "3\n2 2 2\n1 1 1\n3 3\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 3",
          "code": "3\n2 2 2\n1 1 1\n3 3\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 4",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 5",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 6",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 7",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 8",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 9",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 10",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 11",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 12",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 13",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 14",
          "code": "3 4 1\n\n 3 5\n\n  8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 15",
          "code": "(a+b)/2 >= sqrt(a*b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 16",
          "code": "10 6 1 48\n239 632\n976 315\n797 112\n1 835\n938 862\n531 884\n422 607\n152 331\n413 677\n622 978",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 17",
          "code": "10 6 1 48\n239 632\n976 315\n797 112\n1 835\n938 862\n531 884\n422 607\n152 331\n413 677\n622 978",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 18",
          "code": "5 3788.56\n10 3673.36\n2 3360.12\n6 3289.08\n4 2606.20\n3 2598.64\n9 2525.24\n7 2315.84\n1 2210.84\n8 1184.72",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 19",
          "code": "5 3788.56\n10 3673.36\n2 3360.12\n6 3289.08\n4 2606.20\n3 2598.64\n9 2525.24\n7 2315.84\n1 2210.84\n8 1184.72",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 20",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 21",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 22",
          "code": "cin >> S >> a >> b >> c;\n\nif(a == 0 && b == 0 && c == 0){\n    printf(\"0.0 0.0 0.0\\n\");\n    return 0;\n}\n\ndouble x = a / (double)(a + b + c) * S;\ndouble y = b / (double)(a + b + c) * S;\ndouble z = c / (double)(a + b + c) * S;\nprintf(\"%.20f %.20f %.20f\\n\", x, y, z);\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(0LL, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(0LL, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(0LL, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    long long n;\n\n    if (type == \"small\") {\n        /* Generate small n values: 0 <= n <= 100 */\n        n = rnd.next(0LL, 100LL);\n    } else if (type == \"medium\") {\n        /* Generate medium n values: 1e5 <= n <= 1e10 */\n        n = rnd.next(100000LL, 10000000000LL);\n    } else if (type == \"large\") {\n        /* Generate large n values: 1e17 <= n <= 1e18 */\n        n = rnd.next(100000000000000000LL, 1000000000000000000LL);\n    } else if (type == \"overflow32\") {\n        /* n value that causes 32-bit integer overflow in U_n */\n        n = 16LL;\n    } else if (type == \"overflow64\") {\n        /* n value that causes 64-bit integer overflow in U_n */\n        n = 32LL;\n    } else if (type == \"max\") {\n        /* Maximum n value */\n        n = 1000000000000000000LL;\n    } else if (type == \"min\") {\n        /* Minimum n value */\n        n = 0LL;\n    } else if (type == \"custom\") {\n        /* Custom n value provided via -n parameter */\n        n = opt<long long>(\"n\");\n        ensuref(0LL <= n && n <= 1000000000000000000LL, \"n must be between 0 and 1e18\");\n    } else {\n        /* Generate random n value within allowed range */\n        n = rnd.next(0LL, 1000000000000000000LL);\n    }\n\n    printf(\"%lld\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    long long n;\n\n    if (type == \"small\") {\n        /* Generate small n values: 0 <= n <= 100 */\n        n = rnd.next(0LL, 100LL);\n    } else if (type == \"medium\") {\n        /* Generate medium n values: 1e5 <= n <= 1e10 */\n        n = rnd.next(100000LL, 10000000000LL);\n    } else if (type == \"large\") {\n        /* Generate large n values: 1e17 <= n <= 1e18 */\n        n = rnd.next(100000000000000000LL, 1000000000000000000LL);\n    } else if (type == \"overflow32\") {\n        /* n value that causes 32-bit integer overflow in U_n */\n        n = 16LL;\n    } else if (type == \"overflow64\") {\n        /* n value that causes 64-bit integer overflow in U_n */\n        n = 32LL;\n    } else if (type == \"max\") {\n        /* Maximum n value */\n        n = 1000000000000000000LL;\n    } else if (type == \"min\") {\n        /* Minimum n value */\n        n = 0LL;\n    } else if (type == \"custom\") {\n        /* Custom n value provided via -n parameter */\n        n = opt<long long>(\"n\");\n        ensuref(0LL <= n && n <= 1000000000000000000LL, \"n must be between 0 and 1e18\");\n    } else {\n        /* Generate random n value within allowed range */\n        n = rnd.next(0LL, 1000000000000000000LL);\n    }\n\n    printf(\"%lld\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n values\n./gen -type small\n./gen -type small\n./gen -type small\n\n# Medium n values\n./gen -type medium\n./gen -type medium\n./gen -type medium\n\n# Large n values\n./gen -type large\n./gen -type large\n./gen -type large\n\n# Minimum and maximum n values\n./gen -type min\n./gen -type max\n\n# Overflow test cases for 32-bit and 64-bit integers\n./gen -type overflow32\n./gen -type overflow64\n\n# Random n values within the allowed range\n./gen\n./gen\n./gen\n\n# Custom n values to test specific cases\n./gen -type custom -n 0\n./gen -type custom -n 1\n./gen -type custom -n 2\n./gen -type custom -n 3\n./gen -type custom -n 16\n./gen -type custom -n 32\n./gen -type custom -n 63\n./gen -type custom -n 64\n./gen -type custom -n 100\n./gen -type custom -n 1000\n./gen -type custom -n 1000000\n./gen -type custom -n 999999999999999999\n./gen -type custom -n 500000000000000000\n./gen -type custom -n 1000000000000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:13.655757",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "185/B",
      "title": "B. Mushroom Scientists",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer S (1 ≤ S ≤ 103) — the maximum sum of coordinates of the sought point.The second line contains three space-separated integers a, b, c (0 ≤ a, b, c ≤ 103) — the numbers that describe the metric of mushroom scientists.",
      "output_spec": "OutputPrint three real numbers — the coordinates of the point that reaches maximum value in the metrics of mushroom scientists. If there are multiple answers, print any of them that meets the limitations.A natural logarithm of distance from the center of the Universe to the given point in the metric of mushroom scientists shouldn't differ from the natural logarithm of the maximum distance by more than 10 - 6. We think that ln(0) =  - ∞.",
      "sample_tests": "ExamplesInputCopy31 1 1OutputCopy1.0 1.0 1.0InputCopy32 0 0OutputCopy3.0 0.0 0.0",
      "description": "B. Mushroom Scientists\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer S (1 ≤ S ≤ 103) — the maximum sum of coordinates of the sought point.The second line contains three space-separated integers a, b, c (0 ≤ a, b, c ≤ 103) — the numbers that describe the metric of mushroom scientists.\n\nOutputPrint three real numbers — the coordinates of the point that reaches maximum value in the metrics of mushroom scientists. If there are multiple answers, print any of them that meets the limitations.A natural logarithm of distance from the center of the Universe to the given point in the metric of mushroom scientists shouldn't differ from the natural logarithm of the maximum distance by more than 10 - 6. We think that ln(0) =  - ∞.\n\nInputCopy31 1 1OutputCopy1.0 1.0 1.0InputCopy32 0 0OutputCopy3.0 0.0 0.0\n\nInputCopy31 1 1\n\nOutputCopy1.0 1.0 1.0\n\nInputCopy32 0 0\n\nOutputCopy3.0 0.0 0.0",
      "solutions": [
        {
          "title": "Codeforces Round #118 - Codeforces",
          "content": "Hello everybody! There is less than 3 hours before my second codeforces round, in which I participating as author. (The first one was — Codeforces Beta Round 56.) It will be llok like the previous one. (That was not bad, I wish. :-)!) I wish, you like today's contest.I'm the author of this round, except one problem, which was proposed by Gerald.In preparing this round was participating : Gerald (He always makes problems better.), cerealguy (Who helps in preparing, i think, the hardest problem of this round. He had solved the first version of round — and think, that it's easy.), Delinur (Who translate the problems). And also it was done with help of \"Polygon\" and \"Codeforces\".I wish, you luck in this contest and to have high rating.Problem scores will be as always. I wish, that problems are sorted well.UPD: I'm very bad man, and have written wrong solution in problem \"C\". Problem under investigation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 912
        },
        {
          "title": "Editorial for Round #118 - Codeforces",
          "content": "No problem was specially taken from \"Wikipedia\". For me it's really hard to understand, that problem \"B\" was there.A (Div 2). (Idea : Gerald, realization : Aksenov239, code : 1670635)If the lengths of 2 strings aren't equal — that means \"NO\". We try to find the positions in strings, where chars are different. If there 1 or more than 2 such positions — \"NO\". After that we swap 2 characters in the first string, and check for their equality.B (Div 2). (Idea : Aksenov239, realization : Aksenov239, code : 1670637) We can see, that we can do all in integers, because k is integer number of percent. For each dwarf we should find his optimal strategy — to check 2 strategies with speed. We should sort them. A (Div 1). (Idea : Aksenov239, realization : Aksenov239, code : 1652592) Let's propose, that after the i-th year, there is x triangles up and y triangles down. After another iteration we can see, that amount of triangles became — 3x + y up and x + 3y down. Let's see the difference between them: at the i-th it's x - y and at the i + 1-th — it's (3x + y) - (x + 3y) = 2 * (x - y). We can see, that difference between amount of triangles grown up by 2. Because on the i-th year the difference became 2i and all amount of triangles is 4i. We can see, that on the i-th year the number of our triangles is . That can be computed by modulo p using the fast-power algorithm.B (Div 1). (Idea : Aksenov239, realization : Aksenov239, code : 1652597) This problem was made by my love to inequalities. :-)! The answer for this problem is .Prove: . (This is AM-GM inequality. Link for whom don't know it.)The equality becomes only, when .And you should check on zeroes. If a = b = c = 0 — you can choose any good answer — x + y + z ≤ S.C (Div 1). No comments. :-)!D (Div 1). (Idea : Aksenov239, realization : cerealguy, Gerald, Aksenov239, code : 1652604)This is number theory problem.I'm trying to explain it step by step:1) Let's prove, that LCD is maximum 2.Let . Squaring both sides we get , but we want to . This means, that d can be only 2.2) Let's make this lenghty product simplier..We can count this by modulo p fast, and divide it by 2r - l, if k is odd.3) There is many interesting things in this solution.Firstly, it doesn't work, when p = 2 — but it can easily done by you.The other problem is harder, what if , this means that for each i ≥ l : , and this mean,that for each i ≥ l : k2i + 1 ≡ p2. And the product by modulo p is equal to 2r - l + 1.E (Div. 1) (Idea : Aksenov239, relization : cerealguy, code : 1652611)This problem wasn't taken to ROI, because of that I gave it here. This is pretty hard problem. I can't now realize, what cerealguy wrote, but his solution is O(nlogn) — without binary search. For me it's quite hard to understand, because my first solution was with binary search. And there were solutions, that has a worse asymptothic, but they run faster.Because of that I can only give you key ideas, that can help you. (afterwards you can see the code of cerealguy)Ideas: Let's find for each person the nearest subway point for them. It can be done in nlogn with use of segment tree or something else. We can see, that if one person goes to subway, the others, which distance to subway is smaller, can go to subway too — it doesn't affect the answer. Because of that we sort all persons by their distanse to subway. The area of the person, where he can come in t seconds, is romb. And we can intersect all rombes in O(n) — the intersection is like rectangle. Let's make the first intersection. When nobody goes to subway. We get a rectangle. The main idea, that for this rectangle — the nearest subway becomes always the same. We go throught people in sorted order, we can fast recalculate this small rectangle — and because of that we can fast recalculate the answer. And we get a solution in O(nlogn) time. Ta-dams.Thank you all for your attention. I'm deeply sorry about the problem \"C\".",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4488",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3919
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #118 - Codeforces - Code 1",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 2",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 3",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 4",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 5",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 6",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 7",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 8",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 9",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 10",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 11",
          "code": "3 4 1\n\n 3 5\n\n  8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 12",
          "code": "(a+b)/2 >= sqrt(a*b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 13",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 14",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 15",
          "code": "cin >> S >> a >> b >> c;\n\nif(a == 0 && b == 0 && c == 0){\n    printf(\"0.0 0.0 0.0\\n\");\n    return 0;\n}\n\ndouble x = a / (double)(a + b + c) * S;\ndouble y = b / (double)(a + b + c) * S;\ndouble z = c / (double)(a + b + c) * S;\nprintf(\"%.20f %.20f %.20f\\n\", x, y, z);\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int S = inf.readInt(1, 1000, \"S\");\n    inf.readEoln();\n\n    int a = inf.readInt(0, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 1000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(0, 1000, \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int S = inf.readInt(1, 1000, \"S\");\n    inf.readEoln();\n\n    int a = inf.readInt(0, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 1000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(0, 1000, \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int S = inf.readInt(1, 1000, \"S\");\n    inf.readEoln();\n\n    int a = inf.readInt(0, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 1000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(0, 1000, \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read S, a, b, c from the input file\n    int S = inf.readInt(1, 1000, \"S\");\n    inf.readEoln();\n    int a = inf.readInt(0, 1000, \"a\");\n    int b = inf.readInt(0, 1000, \"b\");\n    int c = inf.readInt(0, 1000, \"c\");\n\n    // Compute the total exponent\n    double totalExponent = a + b + c;\n\n    // Compute the maximum possible ln_D (ln of the maximum distance)\n    double ln_D_max = 0.0;\n    double S_d = static_cast<double>(S);\n    if (totalExponent > 0) {\n        // Calculate the optimal x_max, y_max, z_max\n        double x_max = (a > 0) ? S_d * a / totalExponent : 0.0;\n        double y_max = (b > 0) ? S_d * b / totalExponent : 0.0;\n        double z_max = (c > 0) ? S_d * c / totalExponent : 0.0;\n\n        // Check that variables with positive exponents are greater than zero\n        if ((a > 0 && x_max <= 0.0) || (b > 0 && y_max <= 0.0) || (c > 0 && z_max <= 0.0)) {\n            quitf(_fail, \"Internal error: Expected positive variables for positive exponents.\");\n        }\n\n        // Compute ln_D_max\n        if (a > 0) ln_D_max += a * log(x_max);\n        if (b > 0) ln_D_max += b * log(y_max);\n        if (c > 0) ln_D_max += c * log(z_max);\n    } else {\n        // When totalExponent is zero, the maximum ln_D is zero\n        ln_D_max = 0.0;\n    }\n\n    // Read x, y, z from the contestant's output\n    double x = ouf.readDouble(0.0, 1e100, \"x\");\n    double y = ouf.readDouble(0.0, 1e100, \"y\");\n    double z = ouf.readDouble(0.0, 1e100, \"z\");\n\n    // Check that x, y, z are non-negative and sum to at most S\n    if (x + y + z > S_d + 1e-6) {\n        quitf(_wa, \"The sum of coordinates x + y + z = %.10f exceeds S = %d\", x + y + z, S);\n    }\n\n    // Compute ln_D for the contestant's output\n    double ln_D_participant = 0.0;\n\n    if (a > 0) {\n        if (x <= 0.0) {\n            quitf(_wa, \"x is zero or negative while its exponent a = %d is positive\", a);\n        }\n        ln_D_participant += a * log(x);\n    } else if (a == 0) {\n        // ln_D_participant += 0;\n    }\n\n    if (b > 0) {\n        if (y <= 0.0) {\n            quitf(_wa, \"y is zero or negative while its exponent b = %d is positive\", b);\n        }\n        ln_D_participant += b * log(y);\n    } else if (b == 0) {\n        // ln_D_participant += 0;\n    }\n\n    if (c > 0) {\n        if (z <= 0.0) {\n            quitf(_wa, \"z is zero or negative while its exponent c = %d is positive\", c);\n        }\n        ln_D_participant += c * log(z);\n    } else if (c == 0) {\n        // ln_D_participant += 0;\n    }\n\n    // Check if the participant's ln_D is within acceptable error margin\n    if (ln_D_max - ln_D_participant > 1e-6) {\n        quitf(_wa, \"Participant's solution is not close enough to the optimal solution. ln_D_max = %.10f, ln_D_participant = %.10f\", ln_D_max, ln_D_participant);\n    } else {\n        quitf(_ok, \"Accepted. ln_D_max = %.10f, ln_D_participant = %.10f\", ln_D_max, ln_D_participant);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int S = opt<int>(\"S\", -1);\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int c = opt<int>(\"c\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        if (S == -1) S = rnd.next(1, 1000);\n        if (a == -1) a = rnd.next(0, 1000);\n        if (b == -1) b = rnd.next(0, 1000);\n        if (c == -1) c = rnd.next(0, 1000);\n    } else if (type == \"maxS\") {\n        S = 1000;\n        if (a == -1) a = rnd.next(0, 1000);\n        if (b == -1) b = rnd.next(0, 1000);\n        if (c == -1) c = rnd.next(0, 1000);\n    } else if (type == \"minS\") {\n        S = 1;\n        if (a == -1) a = rnd.next(0, 1000);\n        if (b == -1) b = rnd.next(0, 1000);\n        if (c == -1) c = rnd.next(0, 1000);\n    } else if (type == \"zeros\") {\n        if (S == -1) S = rnd.next(1, 1000);\n        if (a == -1) a = rnd.next(0, 1000);\n        if (b == -1) b = rnd.next(0, 1000);\n        if (c == -1) c = rnd.next(0, 1000);\n        int zeros = rnd.next(1,3);\n        vector<int*> vars = {&a, &b, &c};\n        shuffle(vars.begin(), vars.end());\n        for (int i = 0; i < zeros; ++i) {\n            *vars[i] = 0;\n        }\n    } else if (type == \"maxABC\") {\n        if (S == -1) S = rnd.next(1, 1000);\n        a = b = c = 1000;\n    } else if (type == \"minABC\") {\n        if (S == -1) S = rnd.next(1, 1000);\n        a = b = c = 0;\n    } else if (type == \"edgeSABC\") {\n        S = 1000;\n        a = b = c = 1000;\n    } else if (type == \"smallValues\") {\n        S = rnd.next(1, 10);\n        a = rnd.next(0, 10);\n        b = rnd.next(0, 10);\n        c = rnd.next(0, 10);\n    } else if (type == \"zeroS\") {\n        S = 0;\n        if (a == -1) a = rnd.next(0, 1000);\n        if (b == -1) b = rnd.next(0, 1000);\n        if (c == -1) c = rnd.next(0, 1000);\n    } else if (type == \"cornerCase\") {\n        S = 0;\n        vector<int*> vars = {&a, &b, &c};\n        for (auto ptr : vars) {\n            *ptr = rnd.next(0, 1000);\n        }\n    } else if (type == \"singleNonZeroExponent\") {\n        if (S == -1) S = rnd.next(1, 1000);\n        vector<int*> vars = {&a, &b, &c};\n        shuffle(vars.begin(), vars.end());\n        *vars[0] = rnd.next(1, 1000); // One non-zero exponent\n        *vars[1] = 0;\n        *vars[2] = 0;\n    } else if (type == \"specific\") {\n        // Use S, a, b, c as provided\n        if (S == -1 || a == -1 || b == -1 || c == -1) {\n            fprintf(stderr, \"For type specific, please provide S, a, b, c\\n\");\n            return 1; // Exit with error\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Ensure S in range\n    if (S < 0 || S > 1000) {\n        fprintf(stderr, \"S must be in [0, 1000]\\n\");\n        return 1;\n    }\n\n    // Ensure a,b,c in range\n    if (a < 0 || a > 1000 || b < 0 || b > 1000 || c < 0 || c > 1000) {\n        fprintf(stderr, \"a, b, c must be in [0, 1000]\\n\");\n        return 1;\n    }\n\n    printf(\"%d\\n\", S);\n    printf(\"%d %d %d\\n\", a, b, c);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int S = opt<int>(\"S\", -1);\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int c = opt<int>(\"c\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        if (S == -1) S = rnd.next(1, 1000);\n        if (a == -1) a = rnd.next(0, 1000);\n        if (b == -1) b = rnd.next(0, 1000);\n        if (c == -1) c = rnd.next(0, 1000);\n    } else if (type == \"maxS\") {\n        S = 1000;\n        if (a == -1) a = rnd.next(0, 1000);\n        if (b == -1) b = rnd.next(0, 1000);\n        if (c == -1) c = rnd.next(0, 1000);\n    } else if (type == \"minS\") {\n        S = 1;\n        if (a == -1) a = rnd.next(0, 1000);\n        if (b == -1) b = rnd.next(0, 1000);\n        if (c == -1) c = rnd.next(0, 1000);\n    } else if (type == \"zeros\") {\n        if (S == -1) S = rnd.next(1, 1000);\n        if (a == -1) a = rnd.next(0, 1000);\n        if (b == -1) b = rnd.next(0, 1000);\n        if (c == -1) c = rnd.next(0, 1000);\n        int zeros = rnd.next(1,3);\n        vector<int*> vars = {&a, &b, &c};\n        shuffle(vars.begin(), vars.end());\n        for (int i = 0; i < zeros; ++i) {\n            *vars[i] = 0;\n        }\n    } else if (type == \"maxABC\") {\n        if (S == -1) S = rnd.next(1, 1000);\n        a = b = c = 1000;\n    } else if (type == \"minABC\") {\n        if (S == -1) S = rnd.next(1, 1000);\n        a = b = c = 0;\n    } else if (type == \"edgeSABC\") {\n        S = 1000;\n        a = b = c = 1000;\n    } else if (type == \"smallValues\") {\n        S = rnd.next(1, 10);\n        a = rnd.next(0, 10);\n        b = rnd.next(0, 10);\n        c = rnd.next(0, 10);\n    } else if (type == \"zeroS\") {\n        S = 0;\n        if (a == -1) a = rnd.next(0, 1000);\n        if (b == -1) b = rnd.next(0, 1000);\n        if (c == -1) c = rnd.next(0, 1000);\n    } else if (type == \"cornerCase\") {\n        S = 0;\n        vector<int*> vars = {&a, &b, &c};\n        for (auto ptr : vars) {\n            *ptr = rnd.next(0, 1000);\n        }\n    } else if (type == \"singleNonZeroExponent\") {\n        if (S == -1) S = rnd.next(1, 1000);\n        vector<int*> vars = {&a, &b, &c};\n        shuffle(vars.begin(), vars.end());\n        *vars[0] = rnd.next(1, 1000); // One non-zero exponent\n        *vars[1] = 0;\n        *vars[2] = 0;\n    } else if (type == \"specific\") {\n        // Use S, a, b, c as provided\n        if (S == -1 || a == -1 || b == -1 || c == -1) {\n            fprintf(stderr, \"For type specific, please provide S, a, b, c\\n\");\n            return 1; // Exit with error\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Ensure S in range\n    if (S < 0 || S > 1000) {\n        fprintf(stderr, \"S must be in [0, 1000]\\n\");\n        return 1;\n    }\n\n    // Ensure a,b,c in range\n    if (a < 0 || a > 1000 || b < 0 || b > 1000 || c < 0 || c > 1000) {\n        fprintf(stderr, \"a, b, c must be in [0, 1000]\\n\");\n        return 1;\n    }\n\n    printf(\"%d\\n\", S);\n    printf(\"%d %d %d\\n\", a, b, c);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type maxS\n./gen -type minS\n./gen -type zeros\n./gen -type zeros\n./gen -type maxABC\n./gen -type minABC\n./gen -type edgeSABC\n./gen -type smallValues\n./gen -type smallValues\n./gen -type zeroS\n./gen -type cornerCase\n./gen -type singleNonZeroExponent\n./gen -type singleNonZeroExponent\n./gen -type specific -S 0 -a 0 -b 0 -c 0\n./gen -type specific -S 1000 -a 1000 -b 0 -c 0\n./gen -type specific -S 0 -a 1000 -b 1000 -c 1000\n./gen -type specific -S 1000 -a 0 -b 1000 -c 1000\n./gen -type specific -S 1 -a 0 -b 0 -c 1000\n./gen -type specific -S 0 -a 0 -b 0 -c 1000\n./gen -type specific -S 1000 -a 0 -b 0 -c 0\n./gen -type specific -S 999 -a 0 -b 0 -c 0\n./gen -type specific -S 1000 -a 500 -b 500 -c 0\n./gen -type specific -S 500 -a 0 -b 500 -c 500\n./gen -type specific -S 500 -a 500 -b 0 -c 500\n./gen -type specific -S 1 -a 0 -b 0 -c 0\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:15.947943",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "185/C",
      "title": "C. Хитроумная жирная крыса",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2.5 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записано единственное целое число n (1 ≤ n ≤ 50) — количество уровней с весами.В следующей строке записаны через пробел n целых чисел ai (1 ≤ ai ≤ 106) — массы хлопьев в килограммах.В следующих n строках задано описание весов: в i-й строке записано через пробел (n - i + 1) целых чисел wi, k (1 ≤ wi, k ≤ 106) — параметры выдержки для весов, находящихся на i-ом уровне, в килограммах.",
      "output_spec": "Выходные данныеВыведите «Fat Rat», если права крыса, иначе выведите — «Cerealguy».",
      "sample_tests": "ПримерыВходные данныеСкопировать112Выходные данныеСкопироватьFat RatВходные данныеСкопировать22 21 24Выходные данныеСкопироватьCerealguyВходные данныеСкопировать22 21 25Выходные данныеСкопироватьFat Rat",
      "description": "C. Хитроумная жирная крыса\n\nограничение по времени на тест2.5 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано единственное целое число n (1 ≤ n ≤ 50) — количество уровней с весами.В следующей строке записаны через пробел n целых чисел ai (1 ≤ ai ≤ 106) — массы хлопьев в килограммах.В следующих n строках задано описание весов: в i-й строке записано через пробел (n - i + 1) целых чисел wi, k (1 ≤ wi, k ≤ 106) — параметры выдержки для весов, находящихся на i-ом уровне, в килограммах.\n\nВходные данные\n\nВыходные данныеВыведите «Fat Rat», если права крыса, иначе выведите — «Cerealguy».\n\nВыходные данные\n\nВходные данныеСкопировать112Выходные данныеСкопироватьFat RatВходные данныеСкопировать22 21 24Выходные данныеСкопироватьCerealguyВходные данныеСкопировать22 21 25Выходные данныеСкопироватьFat Rat\n\nВходные данныеСкопировать112\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьFat Rat\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать22 21 24\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьCerealguy\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать22 21 25\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьFat Rat\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПояснения к примерам:   Первый пример: На весы, которые выдерживают 2, падает 1. А это значит, что нижние весы не сломаются.  Второй пример: Все весы на самом верхнем ряду очевидно ломаются, потом хлопья падают на нижний ряд общей массой 4, а это ровно столько сколько «почти выдерживают» нижние весы, а так как 4  ≥  4, то весы ломаются.",
      "solutions": [
        {
          "title": "Codeforces Round #118 - Codeforces",
          "content": "Здравствуйте! Уже в ближайшее время состоится второй раунд, в создании которого я принимаю участие. (Первый был — Codeforces Beta Round 56.) Он будет несколько похож на предыдущий. (Но тот вроде бы был не так плох. :-)!) Надеюсь этот Вам тоже понравится.Собственно я являюсь автором всех задач кроме одной, которую мне как раз предложил Gerald.Огромное спасибо Gerald за всё, он постоянно улучшал мои задачи.Так же соавтором со вчерашнего дня является cerealguy, который подготовил, на мой взгляд, самую сложную задачу в наборе. (Он стал соавтором после прорешивания первой версии контеста где-то за один час. :-)!)Также благодарность pashka, который в самом начале подготовки оценивал задачи. Конечно же спасибо главному переводчику кодефорсес — Delinur.А также спасибо системам \"Polygon\" и \"Codeforces\" при реализации раундаИ без грибов не обойдётся и этот раунд!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 865
        },
        {
          "title": "Editorial for Round #118 - Codeforces",
          "content": "Ни одна из задач не была специально взята с \"Wikipedia\". Для меня было очень поразительно, что задача \"B\" была там.A (Div 2). (Идея : Gerald, реализация : Aksenov239, код : 1670635)Если длины строк не равны — то ответ \"NO\". Далее мы ищем позиции, на которых символы в строчках не совпадают. Если таких позиций не 2 — \"NO\". Иначе меняем 2 символа не этих позциях в первой строке, и сравниваем строки.B (Div 2). (Идея : Aksenov239, реализация : Aksenov239, код : 1670637) Можно заметить, что всё можно считать в целых числах, так как k — целое число процентов. Для каждого гнома мы находим оптимальную стратегию — то есть проверяем 2 стратеги и выбираем лучшую. А далее просто сортируем. A (Div 1). (Идея : Aksenov239, реализация : Aksenov239, код : 1652592) Предположим, что после i-го года, у нас было x треугольников вверх и y треугольников вниз. После ещё одной итерации можно заметить, что количество треугольников стало — 3x + y вверх и x + 3y вниз. Рассмотрим разницу между ними: на i-ый год она равна x - y, а не i + 1-ый — (3x + y) - (x + 3y) = 2 * (x - y). Теперь ясно, что разница между количеством треугольников за год увеличивается в 2 раза. Так как на i-th год разница становится 2i и всего треугольников 4i. То на i-ый год количество треугольников, направленных вверх — . Это можно посчитать по модулю p, используя алгоритм быстрого возведения в степень.B (Div 1). (Идея : Aksenov239, реализация : Aksenov239, код : 1652597) Ответ на эту задачу: .Доказательство: . (Это неравенство о среднем арифметическом и среднем геометрическом. Для тех, кто желает ознакомиться.)Равенство достигается только при .Но надо не забывать про нули. Если a = b = c = 0 — вы должны выбрать какую-нибудь подходящую точку — x + y + z ≤ S.C (Div 1). Без комментариев. :-)!D (Div 1). (Идея : Aksenov239, реализация : cerealguy, Gerald, Aksenov239, код : 1652604)Это задачка на теорию чисел.Постараюсь объяснить всё по шагам:1) Сначала докажем, что НОД чисел не больше 2.Пусть . Возводим обе части в квадрат , а нам нужно, чтобы . Это означает, что d может быть только 2.2) Сделаем наше длинное произведение покороче..Мы это можем посчитать по модулю p быстро, и поделить на 2r - l, если k — нечётное.3) Но есть несколько ловушек.Первая — это не работает, когда p = 2 — но Вы справитесь сами.Другая проблема посложнее, что если , это означает, что для любого i ≥ l : , из чего следует,что для любого i ≥ l : k2i + 1 ≡ p2. И наше произведение по модулю p равно 2r - l + 1.E (Div. 1) (Идея : Aksenov239, реализация : cerealguy, код : 1652611)Эту задачу не взяли на РОИ, поэтому я предложил её здесь. На мой взгляд, задача вполне сложная. Если честно, я точно не знаю, что написал cerealguy, но его решение работает за O(nlogn) — без бин-поиска. Для меня это достаточно уже сложно, так как первоначальное решение было с ним. (Вроде, даже такие решения прошли.) Также были ещё решения с более худшей асимптотикой, но некоторые даже быстрее работали.Я могу Вам только дать ключевые идеи решения, которые Вам помогут. (В конце концов, вы можете посмотреть решение cerealguy)Идеи: Для каждого гнома найдём ближайшее метро. Это можно сделать за nlogn с помощью дерева отрезков или чего Вам там больше нравится. Можно заметить, что если гном идёт до метро, то другие гномы с меньшим расстоянием до метро, могут тоже идти туда — это никак не повлияет на ответ. Поэтому отсортируем гномов по этому расстоянию. Точки, до куда гном может дойти за t секунд, представляет собой ромб. И мы можем пересечь все ромбы за O(n) — пересечение будет похоже на прямоугольник. Построим начальное пересечение, когда никто не идёт в метро. Мы получим прямоугольник. Основная идея — для прямоугольника пересечения — ближайшее к нему метро всегда остаётся одним и тем же. Теперь можно пройтись по гномам в отсортированном порядке, мы умеем быстро пересчитывать прямоугольник пересечения — и поэтому можем быстро пересчитывать ответ. И у нас получается решение за O(nlogn). Та-дамс!Спасибо за Ваше внимание и понимание. Мне очень стыдно, за то что я натворил с задачей \"C\".",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4488",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4031
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #118 - Codeforces - Code 1",
          "code": "17:06. Паника!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 2",
          "code": "3\n2 2 2\n1 1 1\n3 3\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 3",
          "code": "3\n2 2 2\n1 1 1\n3 3\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 4",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 5",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 6",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 7",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 8",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 9",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 10",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 11",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 12",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 13",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 14",
          "code": "3 4 1\n\n 3 5\n\n  8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 15",
          "code": "(a+b)/2 >= sqrt(a*b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 16",
          "code": "10 6 1 48\n239 632\n976 315\n797 112\n1 835\n938 862\n531 884\n422 607\n152 331\n413 677\n622 978",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 17",
          "code": "10 6 1 48\n239 632\n976 315\n797 112\n1 835\n938 862\n531 884\n422 607\n152 331\n413 677\n622 978",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 18",
          "code": "5 3788.56\n10 3673.36\n2 3360.12\n6 3289.08\n4 2606.20\n3 2598.64\n9 2525.24\n7 2315.84\n1 2210.84\n8 1184.72",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 19",
          "code": "5 3788.56\n10 3673.36\n2 3360.12\n6 3289.08\n4 2606.20\n3 2598.64\n9 2525.24\n7 2315.84\n1 2210.84\n8 1184.72",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 20",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 21",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 22",
          "code": "cin >> S >> a >> b >> c;\n\nif(a == 0 && b == 0 && c == 0){\n    printf(\"0.0 0.0 0.0\\n\");\n    return 0;\n}\n\ndouble x = a / (double)(a + b + c) * S;\ndouble y = b / (double)(a + b + c) * S;\ndouble z = c / (double)(a + b + c) * S;\nprintf(\"%.20f %.20f %.20f\\n\", x, y, z);\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        int cnt = n - i + 1;\n        vector<int> wi = inf.readInts(cnt, 1, 1000000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        int cnt = n - i + 1;\n        vector<int> wi = inf.readInts(cnt, 1, 1000000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 1000000);\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        int cnt = n - i + 1;\n        vector<int> wi = inf.readInts(cnt, 1, 1000000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string path = opt<string>(\"path\", \"left\"); // For 'left_path' or 'right_path' types\n\n    const int A_MAX = 1000000; // Max value for ai and wi,k\n\n    vector<int> ai(n);\n    vector<vector<int>> wi(n);\n\n    if (type == \"break_all\") {\n        // All scales will break\n        for (int i = 0; i < n; ++i) {\n            ai[i] = A_MAX;\n        }\n        for (int i = 0; i < n; ++i) {\n            wi[i].resize(n - i);\n            for (int k = 0; k < n - i; ++k) {\n                wi[i][k] = 1;\n            }\n        }\n    } else if (type == \"break_none\") {\n        // No scales will break\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            wi[i].resize(n - i);\n            for (int k = 0; k < n - i; ++k) {\n                wi[i][k] = A_MAX;\n            }\n        }\n    } else if (type == \"left_path\" || type == \"right_path\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(A_MAX / 2, A_MAX);\n        }\n        for (int i = 0; i < n; ++i) {\n            int num_scales = n - i;\n            wi[i].resize(num_scales);\n            for (int k = 0; k < num_scales; ++k) {\n                if (type == \"left_path\" && k == 0) {\n                    wi[i][k] = 1; // Leftmost path\n                } else if (type == \"right_path\" && k == num_scales - 1) {\n                    wi[i][k] = 1; // Rightmost path\n                } else {\n                    wi[i][k] = A_MAX; // Other scales won't break\n                }\n            }\n        }\n    } else if (type == \"mass_equal_capacity\") {\n        // Set ai[i] = wi[0][i], to test the 'mass equal capacity' condition at the top scales\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, A_MAX);\n        }\n        for (int i = 0; i < n; ++i) {\n            int num_scales = n - i;\n            wi[i].resize(num_scales);\n            for (int k = 0; k < num_scales; ++k) {\n                if (i == 0) {\n                    wi[i][k] = ai[k]; // Top scales have capacity equal to the mass\n                } else {\n                    wi[i][k] = A_MAX; // Other scales won't break\n                }\n            }\n        }\n    } else if (type == \"random\") {\n        // Random test case\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, A_MAX);\n        }\n        for (int i = 0; i < n; ++i) {\n            int num_scales = n - i;\n            wi[i].resize(num_scales);\n            for (int k = 0; k < num_scales; ++k) {\n                wi[i][k] = rnd.next(1, A_MAX);\n            }\n        }\n    } else {\n        ensuref(false, \"Invalid type parameter.\");\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", ai[i]);\n    }\n    printf(\"\\n\");\n\n    // Output wi\n    for (int i = 0; i < n; ++i) {\n        int num_scales = n - i;\n        for (int k = 0; k < num_scales; ++k) {\n            if (k > 0) printf(\" \");\n            printf(\"%d\", wi[i][k]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string path = opt<string>(\"path\", \"left\"); // For 'left_path' or 'right_path' types\n\n    const int A_MAX = 1000000; // Max value for ai and wi,k\n\n    vector<int> ai(n);\n    vector<vector<int>> wi(n);\n\n    if (type == \"break_all\") {\n        // All scales will break\n        for (int i = 0; i < n; ++i) {\n            ai[i] = A_MAX;\n        }\n        for (int i = 0; i < n; ++i) {\n            wi[i].resize(n - i);\n            for (int k = 0; k < n - i; ++k) {\n                wi[i][k] = 1;\n            }\n        }\n    } else if (type == \"break_none\") {\n        // No scales will break\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            wi[i].resize(n - i);\n            for (int k = 0; k < n - i; ++k) {\n                wi[i][k] = A_MAX;\n            }\n        }\n    } else if (type == \"left_path\" || type == \"right_path\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(A_MAX / 2, A_MAX);\n        }\n        for (int i = 0; i < n; ++i) {\n            int num_scales = n - i;\n            wi[i].resize(num_scales);\n            for (int k = 0; k < num_scales; ++k) {\n                if (type == \"left_path\" && k == 0) {\n                    wi[i][k] = 1; // Leftmost path\n                } else if (type == \"right_path\" && k == num_scales - 1) {\n                    wi[i][k] = 1; // Rightmost path\n                } else {\n                    wi[i][k] = A_MAX; // Other scales won't break\n                }\n            }\n        }\n    } else if (type == \"mass_equal_capacity\") {\n        // Set ai[i] = wi[0][i], to test the 'mass equal capacity' condition at the top scales\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, A_MAX);\n        }\n        for (int i = 0; i < n; ++i) {\n            int num_scales = n - i;\n            wi[i].resize(num_scales);\n            for (int k = 0; k < num_scales; ++k) {\n                if (i == 0) {\n                    wi[i][k] = ai[k]; // Top scales have capacity equal to the mass\n                } else {\n                    wi[i][k] = A_MAX; // Other scales won't break\n                }\n            }\n        }\n    } else if (type == \"random\") {\n        // Random test case\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, A_MAX);\n        }\n        for (int i = 0; i < n; ++i) {\n            int num_scales = n - i;\n            wi[i].resize(num_scales);\n            for (int k = 0; k < num_scales; ++k) {\n                wi[i][k] = rnd.next(1, A_MAX);\n            }\n        }\n    } else {\n        ensuref(false, \"Invalid type parameter.\");\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", ai[i]);\n    }\n    printf(\"\\n\");\n\n    // Output wi\n    for (int i = 0; i < n; ++i) {\n        int num_scales = n - i;\n        for (int k = 0; k < num_scales; ++k) {\n            if (k > 0) printf(\" \");\n            printf(\"%d\", wi[i][k]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type break_none\n./gen -n 1 -type break_all\n./gen -n 1 -type random\n\n./gen -n 2 -type break_none\n./gen -n 2 -type break_all\n./gen -n 2 -type left_path\n./gen -n 2 -type right_path\n./gen -n 2 -type random\n\n./gen -n 10 -type break_none\n./gen -n 10 -type break_all\n./gen -n 10 -type left_path\n./gen -n 10 -type right_path\n./gen -n 10 -type random\n\n./gen -n 25 -type break_none\n./gen -n 25 -type break_all\n./gen -n 25 -type left_path\n./gen -n 25 -type right_path\n./gen -n 25 -type random\n\n./gen -n 50 -type break_none\n./gen -n 50 -type break_all\n./gen -n 50 -type left_path\n./gen -n 50 -type right_path\n./gen -n 50 -type random\n\n# Test edge cases with minimum and maximum n\n./gen -n 1 -type break_none\n./gen -n 50 -type break_none\n\n# Additional test cases\n./gen -n 30 -type break_none\n./gen -n 30 -type break_all\n./gen -n 30 -type random\n\n./gen -n 40 -type left_path\n./gen -n 40 -type right_path\n\n./gen -n 45 -type mass_equal_capacity\n\n./gen -n 10 -type mass_equal_capacity\n\n./gen -n 25 -type mass_equal_capacity\n\n./gen -n 50 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:17.501346",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "185/D",
      "title": "D. Пришествие",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записано единственное целое число t (1 ≤ t ≤ 105) — количество пришествий короля.В каждой из следующих t строк входных данных записано четыре целых числа, разделённых пробелами, ki, li, ri и pi (1 ≤ ki ≤ 106; 0 ≤ li ≤ ri ≤ 1018; 2 ≤ pi ≤ 109) — числа, которые выбрал Великий Грибной король, и простой модуль, соответственно. Гарантируется, что во всех пришествиях число pi простое.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++, вместо него рекомендуется использовать потоки cin, cout, а также спецификатор %I64d.",
      "output_spec": "Выходные данныеДля каждого пришествия выведите ответ в отдельной строке — остаток от деления количества гномов, которые смогут увидеть короля, на число pi. Ответы для пришествий выводите в том порядке, в котором заданы описания пришествий во входных данных.",
      "sample_tests": "ПримерыВходные данныеСкопировать23 1 10 25 0 4 3Выходные данныеСкопировать00",
      "description": "D. Пришествие\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных записано единственное целое число t (1 ≤ t ≤ 105) — количество пришествий короля.В каждой из следующих t строк входных данных записано четыре целых числа, разделённых пробелами, ki, li, ri и pi (1 ≤ ki ≤ 106; 0 ≤ li ≤ ri ≤ 1018; 2 ≤ pi ≤ 109) — числа, которые выбрал Великий Грибной король, и простой модуль, соответственно. Гарантируется, что во всех пришествиях число pi простое.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++, вместо него рекомендуется использовать потоки cin, cout, а также спецификатор %I64d.\n\nВходные данные\n\nВыходные данныеДля каждого пришествия выведите ответ в отдельной строке — остаток от деления количества гномов, которые смогут увидеть короля, на число pi. Ответы для пришествий выводите в том порядке, в котором заданы описания пришествий во входных данных.\n\nВыходные данные\n\nВходные данныеСкопировать23 1 10 25 0 4 3Выходные данныеСкопировать00\n\nВходные данныеСкопировать23 1 10 25 0 4 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать00\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеСчитается, что LCM(a1, a2, ..., an) обозначает наименьшее общее кратное чисел a1, a2, ..., an.Считается, что x0 = 1, для любых x.",
      "solutions": [
        {
          "title": "Codeforces Round #118 - Codeforces",
          "content": "Здравствуйте! Уже в ближайшее время состоится второй раунд, в создании которого я принимаю участие. (Первый был — Codeforces Beta Round 56.) Он будет несколько похож на предыдущий. (Но тот вроде бы был не так плох. :-)!) Надеюсь этот Вам тоже понравится.Собственно я являюсь автором всех задач кроме одной, которую мне как раз предложил Gerald.Огромное спасибо Gerald за всё, он постоянно улучшал мои задачи.Так же соавтором со вчерашнего дня является cerealguy, который подготовил, на мой взгляд, самую сложную задачу в наборе. (Он стал соавтором после прорешивания первой версии контеста где-то за один час. :-)!)Также благодарность pashka, который в самом начале подготовки оценивал задачи. Конечно же спасибо главному переводчику кодефорсес — Delinur.А также спасибо системам \"Polygon\" и \"Codeforces\" при реализации раундаИ без грибов не обойдётся и этот раунд!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 865
        },
        {
          "title": "Editorial for Round #118 - Codeforces",
          "content": "Ни одна из задач не была специально взята с \"Wikipedia\". Для меня было очень поразительно, что задача \"B\" была там.A (Div 2). (Идея : Gerald, реализация : Aksenov239, код : 1670635)Если длины строк не равны — то ответ \"NO\". Далее мы ищем позиции, на которых символы в строчках не совпадают. Если таких позиций не 2 — \"NO\". Иначе меняем 2 символа не этих позциях в первой строке, и сравниваем строки.B (Div 2). (Идея : Aksenov239, реализация : Aksenov239, код : 1670637) Можно заметить, что всё можно считать в целых числах, так как k — целое число процентов. Для каждого гнома мы находим оптимальную стратегию — то есть проверяем 2 стратеги и выбираем лучшую. А далее просто сортируем. A (Div 1). (Идея : Aksenov239, реализация : Aksenov239, код : 1652592) Предположим, что после i-го года, у нас было x треугольников вверх и y треугольников вниз. После ещё одной итерации можно заметить, что количество треугольников стало — 3x + y вверх и x + 3y вниз. Рассмотрим разницу между ними: на i-ый год она равна x - y, а не i + 1-ый — (3x + y) - (x + 3y) = 2 * (x - y). Теперь ясно, что разница между количеством треугольников за год увеличивается в 2 раза. Так как на i-th год разница становится 2i и всего треугольников 4i. То на i-ый год количество треугольников, направленных вверх — . Это можно посчитать по модулю p, используя алгоритм быстрого возведения в степень.B (Div 1). (Идея : Aksenov239, реализация : Aksenov239, код : 1652597) Ответ на эту задачу: .Доказательство: . (Это неравенство о среднем арифметическом и среднем геометрическом. Для тех, кто желает ознакомиться.)Равенство достигается только при .Но надо не забывать про нули. Если a = b = c = 0 — вы должны выбрать какую-нибудь подходящую точку — x + y + z ≤ S.C (Div 1). Без комментариев. :-)!D (Div 1). (Идея : Aksenov239, реализация : cerealguy, Gerald, Aksenov239, код : 1652604)Это задачка на теорию чисел.Постараюсь объяснить всё по шагам:1) Сначала докажем, что НОД чисел не больше 2.Пусть . Возводим обе части в квадрат , а нам нужно, чтобы . Это означает, что d может быть только 2.2) Сделаем наше длинное произведение покороче..Мы это можем посчитать по модулю p быстро, и поделить на 2r - l, если k — нечётное.3) Но есть несколько ловушек.Первая — это не работает, когда p = 2 — но Вы справитесь сами.Другая проблема посложнее, что если , это означает, что для любого i ≥ l : , из чего следует,что для любого i ≥ l : k2i + 1 ≡ p2. И наше произведение по модулю p равно 2r - l + 1.E (Div. 1) (Идея : Aksenov239, реализация : cerealguy, код : 1652611)Эту задачу не взяли на РОИ, поэтому я предложил её здесь. На мой взгляд, задача вполне сложная. Если честно, я точно не знаю, что написал cerealguy, но его решение работает за O(nlogn) — без бин-поиска. Для меня это достаточно уже сложно, так как первоначальное решение было с ним. (Вроде, даже такие решения прошли.) Также были ещё решения с более худшей асимптотикой, но некоторые даже быстрее работали.Я могу Вам только дать ключевые идеи решения, которые Вам помогут. (В конце концов, вы можете посмотреть решение cerealguy)Идеи: Для каждого гнома найдём ближайшее метро. Это можно сделать за nlogn с помощью дерева отрезков или чего Вам там больше нравится. Можно заметить, что если гном идёт до метро, то другие гномы с меньшим расстоянием до метро, могут тоже идти туда — это никак не повлияет на ответ. Поэтому отсортируем гномов по этому расстоянию. Точки, до куда гном может дойти за t секунд, представляет собой ромб. И мы можем пересечь все ромбы за O(n) — пересечение будет похоже на прямоугольник. Построим начальное пересечение, когда никто не идёт в метро. Мы получим прямоугольник. Основная идея — для прямоугольника пересечения — ближайшее к нему метро всегда остаётся одним и тем же. Теперь можно пройтись по гномам в отсортированном порядке, мы умеем быстро пересчитывать прямоугольник пересечения — и поэтому можем быстро пересчитывать ответ. И у нас получается решение за O(nlogn). Та-дамс!Спасибо за Ваше внимание и понимание. Мне очень стыдно, за то что я натворил с задачей \"C\".",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4488",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4031
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #118 - Codeforces - Code 1",
          "code": "17:06. Паника!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 2",
          "code": "3\n2 2 2\n1 1 1\n3 3\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 3",
          "code": "3\n2 2 2\n1 1 1\n3 3\n5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 4",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 5",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 6",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 7",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 8",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 9",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 10",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 11",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 12",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 13",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 14",
          "code": "3 4 1\n\n 3 5\n\n  8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 15",
          "code": "(a+b)/2 >= sqrt(a*b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 16",
          "code": "10 6 1 48\n239 632\n976 315\n797 112\n1 835\n938 862\n531 884\n422 607\n152 331\n413 677\n622 978",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 17",
          "code": "10 6 1 48\n239 632\n976 315\n797 112\n1 835\n938 862\n531 884\n422 607\n152 331\n413 677\n622 978",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 18",
          "code": "5 3788.56\n10 3673.36\n2 3360.12\n6 3289.08\n4 2606.20\n3 2598.64\n9 2525.24\n7 2315.84\n1 2210.84\n8 1184.72",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 19",
          "code": "5 3788.56\n10 3673.36\n2 3360.12\n6 3289.08\n4 2606.20\n3 2598.64\n9 2525.24\n7 2315.84\n1 2210.84\n8 1184.72",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 20",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 21",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 22",
          "code": "cin >> S >> a >> b >> c;\n\nif(a == 0 && b == 0 && c == 0){\n    printf(\"0.0 0.0 0.0\\n\");\n    return 0;\n}\n\ndouble x = a / (double)(a + b + c) * S;\ndouble y = b / (double)(a + b + c) * S;\ndouble z = c / (double)(a + b + c) * S;\nprintf(\"%.20f %.20f %.20f\\n\", x, y, z);\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint modmul(int a, int b, int mod) {\n    return (int)((1LL * a * b) % mod);\n}\n\nint modpow(int a, int d, int mod) {\n    int result = 1;\n    while (d > 0) {\n        if (d & 1)\n            result = modmul(result, a, mod);\n        a = modmul(a, a, mod);\n        d >>=1;\n    }\n    return result;\n}\n\nbool isPrime(int n) {\n    if (n < 2)\n        return false;\n\n    if (n == 2 || n == 3 || n == 5 || n == 7 || n == 11)\n        return true;\n\n    if (n % 2 == 0 || n % 3 == 0 || n % 5 == 0 || n % 7 == 0 || n % 11 == 0)\n        return false;\n\n    int d = n - 1;\n    int s = 0;\n\n    while (d % 2 == 0) {\n        d /= 2;\n        s++;\n    }\n\n    int bases[] = {2, 3, 5, 7, 11};\n\n    for (int a : bases) {\n        if (a >= n)\n            continue;\n\n        int x = modpow(a, d, n);\n        if (x == 1 || x == n - 1)\n            continue;\n\n        bool composite = true;\n        for (int r = 0; r < s - 1; r++) {\n            x = modmul(x, x, n);\n            if (x == n - 1) {\n                composite = false;\n                break;\n            }\n        }\n\n        if (composite)\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    for (int i = 0; i < t; ++i) {\n        int ki = inf.readInt(1, 1000000);\n        inf.readSpace();\n        long long li = inf.readLong(0, 1000000000000000000LL);\n        inf.readSpace();\n        long long ri = inf.readLong(li, 1000000000000000000LL);\n        inf.readSpace();\n        int pi = inf.readInt(2, 1000000000);\n        inf.readEoln();\n\n        ensuref(isPrime(pi), \"pi=%d is not prime\", pi);\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint modmul(int a, int b, int mod) {\n    return (int)((1LL * a * b) % mod);\n}\n\nint modpow(int a, int d, int mod) {\n    int result = 1;\n    while (d > 0) {\n        if (d & 1)\n            result = modmul(result, a, mod);\n        a = modmul(a, a, mod);\n        d >>=1;\n    }\n    return result;\n}\n\nbool isPrime(int n) {\n    if (n < 2)\n        return false;\n\n    if (n == 2 || n == 3 || n == 5 || n == 7 || n == 11)\n        return true;\n\n    if (n % 2 == 0 || n % 3 == 0 || n % 5 == 0 || n % 7 == 0 || n % 11 == 0)\n        return false;\n\n    int d = n - 1;\n    int s = 0;\n\n    while (d % 2 == 0) {\n        d /= 2;\n        s++;\n    }\n\n    int bases[] = {2, 3, 5, 7, 11};\n\n    for (int a : bases) {\n        if (a >= n)\n            continue;\n\n        int x = modpow(a, d, n);\n        if (x == 1 || x == n - 1)\n            continue;\n\n        bool composite = true;\n        for (int r = 0; r < s - 1; r++) {\n            x = modmul(x, x, n);\n            if (x == n - 1) {\n                composite = false;\n                break;\n            }\n        }\n\n        if (composite)\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    for (int i = 0; i < t; ++i) {\n        int ki = inf.readInt(1, 1000000);\n        inf.readSpace();\n        long long li = inf.readLong(0, 1000000000000000000LL);\n        inf.readSpace();\n        long long ri = inf.readLong(li, 1000000000000000000LL);\n        inf.readSpace();\n        int pi = inf.readInt(2, 1000000000);\n        inf.readEoln();\n\n        ensuref(isPrime(pi), \"pi=%d is not prime\", pi);\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint modmul(int a, int b, int mod) {\n    return (int)((1LL * a * b) % mod);\n}\n\nint modpow(int a, int d, int mod) {\n    int result = 1;\n    while (d > 0) {\n        if (d & 1)\n            result = modmul(result, a, mod);\n        a = modmul(a, a, mod);\n        d >>=1;\n    }\n    return result;\n}\n\nbool isPrime(int n) {\n    if (n < 2)\n        return false;\n\n    if (n == 2 || n == 3 || n == 5 || n == 7 || n == 11)\n        return true;\n\n    if (n % 2 == 0 || n % 3 == 0 || n % 5 == 0 || n % 7 == 0 || n % 11 == 0)\n        return false;\n\n    int d = n - 1;\n    int s = 0;\n\n    while (d % 2 == 0) {\n        d /= 2;\n        s++;\n    }\n\n    int bases[] = {2, 3, 5, 7, 11};\n\n    for (int a : bases) {\n        if (a >= n)\n            continue;\n\n        int x = modpow(a, d, n);\n        if (x == 1 || x == n - 1)\n            continue;\n\n        bool composite = true;\n        for (int r = 0; r < s - 1; r++) {\n            x = modmul(x, x, n);\n            if (x == n - 1) {\n                composite = false;\n                break;\n            }\n        }\n\n        if (composite)\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    for (int i = 0; i < t; ++i) {\n        int ki = inf.readInt(1, 1000000);\n        inf.readSpace();\n        long long li = inf.readLong(0, 1000000000000000000LL);\n        inf.readSpace();\n        long long ri = inf.readLong(li, 1000000000000000000LL);\n        inf.readSpace();\n        int pi = inf.readInt(2, 1000000000);\n        inf.readEoln();\n\n        ensuref(isPrime(pi), \"pi=%d is not prime\", pi);\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll mul_mod(ll a, ll b, ll mod) {\n    return (a % mod) * (b % mod) % mod;\n}\n\nll power_mod(ll a, ll d, ll mod) {\n    ll res = 1 % mod;\n    a %= mod;\n    while (d > 0) {\n        if (d & 1)\n            res = mul_mod(res, a, mod);\n        a = mul_mod(a, a, mod);\n        d >>= 1;\n    }\n    return res;\n}\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    int d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        ++s;\n    }\n    int bases[] = {2, 3, 5, 7, 11, 13};\n    for (int a : bases) {\n        if (a >= n) break;\n        ll x = power_mod(a, d, n);\n        if (x == 1 || x == n - 1) continue;\n        bool composite = true;\n        for (int r = 1; r < s; ++r) {\n            x = mul_mod(x, x, n);\n            if (x == n - 1) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 100000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> small_primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};\n    vector<int> big_primes = {999999937, 999999929, 999999893, 999999883, 999999797, 999999761, 999999757};\n\n    printf(\"%d\\n\", t);\n\n    if (type == \"random\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 1000000);\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n\n            int pick_p_type = rnd.next(1, 3);\n            int p;\n            if (pick_p_type == 1) {\n                // small prime\n                p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n            } else if (pick_p_type == 2) {\n                // big prime\n                p = big_primes[rnd.next(0, (int)big_primes.size() - 1)];\n            } else {\n                // random prime between 2 and 1e9\n                while (true) {\n                    p = rnd.next(2, 1000000000);\n                    if (is_prime(p))\n                        break;\n                }\n            }\n\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"k_min\") {\n        for (int i = 0; i < t; ++i) {\n            int k = 1;\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            int p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"k_max\") {\n        for (int i = 0; i < t; ++i) {\n            int k = 1000000;\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            int p = big_primes[rnd.next(0, (int)big_primes.size() - 1)];\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"k_even\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 500000) * 2;\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            int p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"k_odd\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 500000) * 2 - 1;\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            int p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"l_eq_r\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 1000000);\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = l;\n            int p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"l_zero\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 1000000);\n            long long l = 0;\n            long long r = rnd.next((long long)0, (long long)1e18);\n            int p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"l_eq_r_eq_zero\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 1000000);\n            long long l = 0;\n            long long r = 0;\n            int p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"l_eq_r_eq_max\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 1000000);\n            long long l = (long long)1e18;\n            long long r = (long long)1e18;\n            int p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"p_equals_2\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 1000000);\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            int p = 2;\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"p_small\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 1000000);\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            int p = small_primes[rnd.next(1, (int)small_primes.size() - 1)]; // skip p=2\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"p_large\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 1000000);\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            int p = big_primes[rnd.next(0, (int)big_primes.size() - 1)]; \n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"max_values\") {\n        for (int i = 0; i < t; ++i) {\n            int k = 1000000;\n            long long l = 0;\n            long long r = (long long)1e18;\n            int p = big_primes[rnd.next(0, (int)big_primes.size() - 1)];\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"k_mod_p_zero\") {\n        for (int i = 0; i < t; ++i) {\n            int p = small_primes[rnd.next(1, (int)small_primes.size() - 1)];\n            int k = p * rnd.next(1, 1000);\n            if (k > 1000000) k = p;\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll mul_mod(ll a, ll b, ll mod) {\n    return (a % mod) * (b % mod) % mod;\n}\n\nll power_mod(ll a, ll d, ll mod) {\n    ll res = 1 % mod;\n    a %= mod;\n    while (d > 0) {\n        if (d & 1)\n            res = mul_mod(res, a, mod);\n        a = mul_mod(a, a, mod);\n        d >>= 1;\n    }\n    return res;\n}\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    int d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        ++s;\n    }\n    int bases[] = {2, 3, 5, 7, 11, 13};\n    for (int a : bases) {\n        if (a >= n) break;\n        ll x = power_mod(a, d, n);\n        if (x == 1 || x == n - 1) continue;\n        bool composite = true;\n        for (int r = 1; r < s; ++r) {\n            x = mul_mod(x, x, n);\n            if (x == n - 1) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 100000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> small_primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};\n    vector<int> big_primes = {999999937, 999999929, 999999893, 999999883, 999999797, 999999761, 999999757};\n\n    printf(\"%d\\n\", t);\n\n    if (type == \"random\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 1000000);\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n\n            int pick_p_type = rnd.next(1, 3);\n            int p;\n            if (pick_p_type == 1) {\n                // small prime\n                p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n            } else if (pick_p_type == 2) {\n                // big prime\n                p = big_primes[rnd.next(0, (int)big_primes.size() - 1)];\n            } else {\n                // random prime between 2 and 1e9\n                while (true) {\n                    p = rnd.next(2, 1000000000);\n                    if (is_prime(p))\n                        break;\n                }\n            }\n\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"k_min\") {\n        for (int i = 0; i < t; ++i) {\n            int k = 1;\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            int p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"k_max\") {\n        for (int i = 0; i < t; ++i) {\n            int k = 1000000;\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            int p = big_primes[rnd.next(0, (int)big_primes.size() - 1)];\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"k_even\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 500000) * 2;\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            int p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"k_odd\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 500000) * 2 - 1;\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            int p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"l_eq_r\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 1000000);\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = l;\n            int p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"l_zero\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 1000000);\n            long long l = 0;\n            long long r = rnd.next((long long)0, (long long)1e18);\n            int p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"l_eq_r_eq_zero\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 1000000);\n            long long l = 0;\n            long long r = 0;\n            int p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"l_eq_r_eq_max\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 1000000);\n            long long l = (long long)1e18;\n            long long r = (long long)1e18;\n            int p = small_primes[rnd.next(0, (int)small_primes.size() - 1)];\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"p_equals_2\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 1000000);\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            int p = 2;\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"p_small\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 1000000);\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            int p = small_primes[rnd.next(1, (int)small_primes.size() - 1)]; // skip p=2\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"p_large\") {\n        for (int i = 0; i < t; ++i) {\n            int k = rnd.next(1, 1000000);\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            int p = big_primes[rnd.next(0, (int)big_primes.size() - 1)]; \n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"max_values\") {\n        for (int i = 0; i < t; ++i) {\n            int k = 1000000;\n            long long l = 0;\n            long long r = (long long)1e18;\n            int p = big_primes[rnd.next(0, (int)big_primes.size() - 1)];\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    } else if (type == \"k_mod_p_zero\") {\n        for (int i = 0; i < t; ++i) {\n            int p = small_primes[rnd.next(1, (int)small_primes.size() - 1)];\n            int k = p * rnd.next(1, 1000);\n            if (k > 1000000) k = p;\n            long long l = rnd.next((long long)0, (long long)1e18);\n            long long r = rnd.next(l, (long long)1e18);\n            printf(\"%d %lld %lld %d\\n\", k, l, r, p);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -type p_equals_2\n./gen -t 1 -type k_min\n./gen -t 1 -type random\n\n./gen -t 10 -type l_eq_r_eq_zero\n./gen -t 10 -type l_eq_r_eq_max\n./gen -t 10 -type p_small\n\n./gen -t 100 -type k_odd\n./gen -t 100 -type k_even\n./gen -t 100 -type k_mod_p_zero\n\n./gen -t 1000 -type p_equals_2\n./gen -t 1000 -type l_zero\n./gen -t 1000 -type l_eq_r\n\n./gen -t 10000 -type random\n./gen -t 10000 -type p_large\n./gen -t 10000 -type max_values\n\n./gen -t 50000 -type k_max\n./gen -t 50000 -type k_min\n./gen -t 50000 -type p_small\n\n./gen -t 100000 -type random\n./gen -t 100000 -type k_even\n./gen -t 100000 -type k_mod_p_zero\n\n./gen -t 100000 -type l_zero\n./gen -t 100000 -type l_eq_r\n./gen -t 100000 -type p_small\n\n./gen -t 100000 -type p_large\n./gen -t 100000 -type max_values\n./gen -t 100000 -type k_min\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:19.408036",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "185/E",
      "title": "E. Soap Time! - 2",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test6 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1 ≤ n ≤ 105; 0 ≤ k ≤ 105) — the number of dwarves and the number of subway stations, correspondingly.The next n lines contain the coordinates of the dwarves. The i-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 108) — the coordinates of the i-th dwarf. It is guaranteed that all dwarves are located at different points.The next k lines contain the coordinates of the subway stations. The t-th line contains two space-separated integers xt and yt (|xt|, |yt| ≤ 108) — the coordinates of the t-th subway station. It is guaranteed that all subway stations are located at different points.",
      "output_spec": "OutputPrint a single number — the minimum time, in which all dwarves can gather together at one point to watch the soap.",
      "sample_tests": "ExamplesInputCopy1 02 -2OutputCopy0InputCopy2 25 -3-4 -5-4 0-3 -2OutputCopy6",
      "description": "E. Soap Time! - 2\n\ntime limit per test6 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k (1 ≤ n ≤ 105; 0 ≤ k ≤ 105) — the number of dwarves and the number of subway stations, correspondingly.The next n lines contain the coordinates of the dwarves. The i-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 108) — the coordinates of the i-th dwarf. It is guaranteed that all dwarves are located at different points.The next k lines contain the coordinates of the subway stations. The t-th line contains two space-separated integers xt and yt (|xt|, |yt| ≤ 108) — the coordinates of the t-th subway station. It is guaranteed that all subway stations are located at different points.\n\nOutputPrint a single number — the minimum time, in which all dwarves can gather together at one point to watch the soap.\n\nInputCopy1 02 -2OutputCopy0InputCopy2 25 -3-4 -5-4 0-3 -2OutputCopy6\n\nInputCopy1 02 -2\n\nOutputCopy0\n\nInputCopy2 25 -3-4 -5-4 0-3 -2\n\nOutputCopy6",
      "solutions": [
        {
          "title": "Codeforces Round #118 - Codeforces",
          "content": "Hello everybody! There is less than 3 hours before my second codeforces round, in which I participating as author. (The first one was — Codeforces Beta Round 56.) It will be llok like the previous one. (That was not bad, I wish. :-)!) I wish, you like today's contest.I'm the author of this round, except one problem, which was proposed by Gerald.In preparing this round was participating : Gerald (He always makes problems better.), cerealguy (Who helps in preparing, i think, the hardest problem of this round. He had solved the first version of round — and think, that it's easy.), Delinur (Who translate the problems). And also it was done with help of \"Polygon\" and \"Codeforces\".I wish, you luck in this contest and to have high rating.Problem scores will be as always. I wish, that problems are sorted well.UPD: I'm very bad man, and have written wrong solution in problem \"C\". Problem under investigation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 912
        },
        {
          "title": "Editorial for Round #118 - Codeforces",
          "content": "No problem was specially taken from \"Wikipedia\". For me it's really hard to understand, that problem \"B\" was there.A (Div 2). (Idea : Gerald, realization : Aksenov239, code : 1670635)If the lengths of 2 strings aren't equal — that means \"NO\". We try to find the positions in strings, where chars are different. If there 1 or more than 2 such positions — \"NO\". After that we swap 2 characters in the first string, and check for their equality.B (Div 2). (Idea : Aksenov239, realization : Aksenov239, code : 1670637) We can see, that we can do all in integers, because k is integer number of percent. For each dwarf we should find his optimal strategy — to check 2 strategies with speed. We should sort them. A (Div 1). (Idea : Aksenov239, realization : Aksenov239, code : 1652592) Let's propose, that after the i-th year, there is x triangles up and y triangles down. After another iteration we can see, that amount of triangles became — 3x + y up and x + 3y down. Let's see the difference between them: at the i-th it's x - y and at the i + 1-th — it's (3x + y) - (x + 3y) = 2 * (x - y). We can see, that difference between amount of triangles grown up by 2. Because on the i-th year the difference became 2i and all amount of triangles is 4i. We can see, that on the i-th year the number of our triangles is . That can be computed by modulo p using the fast-power algorithm.B (Div 1). (Idea : Aksenov239, realization : Aksenov239, code : 1652597) This problem was made by my love to inequalities. :-)! The answer for this problem is .Prove: . (This is AM-GM inequality. Link for whom don't know it.)The equality becomes only, when .And you should check on zeroes. If a = b = c = 0 — you can choose any good answer — x + y + z ≤ S.C (Div 1). No comments. :-)!D (Div 1). (Idea : Aksenov239, realization : cerealguy, Gerald, Aksenov239, code : 1652604)This is number theory problem.I'm trying to explain it step by step:1) Let's prove, that LCD is maximum 2.Let . Squaring both sides we get , but we want to . This means, that d can be only 2.2) Let's make this lenghty product simplier..We can count this by modulo p fast, and divide it by 2r - l, if k is odd.3) There is many interesting things in this solution.Firstly, it doesn't work, when p = 2 — but it can easily done by you.The other problem is harder, what if , this means that for each i ≥ l : , and this mean,that for each i ≥ l : k2i + 1 ≡ p2. And the product by modulo p is equal to 2r - l + 1.E (Div. 1) (Idea : Aksenov239, relization : cerealguy, code : 1652611)This problem wasn't taken to ROI, because of that I gave it here. This is pretty hard problem. I can't now realize, what cerealguy wrote, but his solution is O(nlogn) — without binary search. For me it's quite hard to understand, because my first solution was with binary search. And there were solutions, that has a worse asymptothic, but they run faster.Because of that I can only give you key ideas, that can help you. (afterwards you can see the code of cerealguy)Ideas: Let's find for each person the nearest subway point for them. It can be done in nlogn with use of segment tree or something else. We can see, that if one person goes to subway, the others, which distance to subway is smaller, can go to subway too — it doesn't affect the answer. Because of that we sort all persons by their distanse to subway. The area of the person, where he can come in t seconds, is romb. And we can intersect all rombes in O(n) — the intersection is like rectangle. Let's make the first intersection. When nobody goes to subway. We get a rectangle. The main idea, that for this rectangle — the nearest subway becomes always the same. We go throught people in sorted order, we can fast recalculate this small rectangle — and because of that we can fast recalculate the answer. And we get a solution in O(nlogn) time. Ta-dams.Thank you all for your attention. I'm deeply sorry about the problem \"C\".",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4488",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3919
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #118 - Codeforces - Code 1",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 2",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 3",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 4",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 5",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 6",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 7",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 8",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 9",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 10",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 11",
          "code": "3 4 1\n\n 3 5\n\n  8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 12",
          "code": "(a+b)/2 >= sqrt(a*b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 13",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 14",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 15",
          "code": "cin >> S >> a >> b >> c;\n\nif(a == 0 && b == 0 && c == 0){\n    printf(\"0.0 0.0 0.0\\n\");\n    return 0;\n}\n\ndouble x = a / (double)(a + b + c) * S;\ndouble y = b / (double)(a + b + c) * S;\ndouble z = c / (double)(a + b + c) * S;\nprintf(\"%.20f %.20f %.20f\\n\", x, y, z);\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    set<pair<int, int>> dwarf_positions;\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-100000000, 100000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-100000000, 100000000, \"yi\");\n        inf.readEoln();\n\n        pair<int,int> pos = make_pair(xi, yi);\n        ensuref(dwarf_positions.count(pos) == 0, \"Dwarf positions must be unique, duplicate at (%d,%d)\", xi, yi);\n        dwarf_positions.insert(pos);\n    }\n\n    set<pair<int, int>> subway_positions;\n    for (int i = 0; i < k; i++) {\n        int xt = inf.readInt(-100000000, 100000000, \"xt\");\n        inf.readSpace();\n        int yt = inf.readInt(-100000000, 100000000, \"yt\");\n        inf.readEoln();\n\n        pair<int,int> pos = make_pair(xt, yt);\n        ensuref(subway_positions.count(pos) == 0, \"Subway station positions must be unique, duplicate at (%d,%d)\", xt, yt);\n        subway_positions.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    set<pair<int, int>> dwarf_positions;\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-100000000, 100000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-100000000, 100000000, \"yi\");\n        inf.readEoln();\n\n        pair<int,int> pos = make_pair(xi, yi);\n        ensuref(dwarf_positions.count(pos) == 0, \"Dwarf positions must be unique, duplicate at (%d,%d)\", xi, yi);\n        dwarf_positions.insert(pos);\n    }\n\n    set<pair<int, int>> subway_positions;\n    for (int i = 0; i < k; i++) {\n        int xt = inf.readInt(-100000000, 100000000, \"xt\");\n        inf.readSpace();\n        int yt = inf.readInt(-100000000, 100000000, \"yt\");\n        inf.readEoln();\n\n        pair<int,int> pos = make_pair(xt, yt);\n        ensuref(subway_positions.count(pos) == 0, \"Subway station positions must be unique, duplicate at (%d,%d)\", xt, yt);\n        subway_positions.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    set<pair<int, int>> dwarf_positions;\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(-100000000, 100000000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-100000000, 100000000, \"yi\");\n        inf.readEoln();\n\n        pair<int,int> pos = make_pair(xi, yi);\n        ensuref(dwarf_positions.count(pos) == 0, \"Dwarf positions must be unique, duplicate at (%d,%d)\", xi, yi);\n        dwarf_positions.insert(pos);\n    }\n\n    set<pair<int, int>> subway_positions;\n    for (int i = 0; i < k; i++) {\n        int xt = inf.readInt(-100000000, 100000000, \"xt\");\n        inf.readSpace();\n        int yt = inf.readInt(-100000000, 100000000, \"yt\");\n        inf.readEoln();\n\n        pair<int,int> pos = make_pair(xt, yt);\n        ensuref(subway_positions.count(pos) == 0, \"Subway station positions must be unique, duplicate at (%d,%d)\", xt, yt);\n        subway_positions.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MIN_COORD = -1e8;\nconst ll MAX_COORD = 1e8;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    // The coordinates: |xi|, |yi| ≤ 1e8\n    vector<pair<ll, ll>> dwarves;\n    vector<pair<ll, ll>> stations;\n\n    if (type == \"random\") {\n        // Generate random dwarves and subway stations\n        ll total = n + k;\n        ll x0 = rnd.next(MIN_COORD, MAX_COORD - total);\n        vector<ll> xs(total);\n        for (int i = 0; i < total; ++i) {\n            xs[i] = x0 + i;\n        }\n        shuffle(xs.begin(), xs.end());\n        vector<ll> ys(total);\n        for (int i = 0; i < total; ++i) {\n            ys[i] = rnd.next(MIN_COORD, MAX_COORD);\n        }\n        for (int i = 0; i < n; ++i) {\n            dwarves.emplace_back(xs[i], ys[i]);\n        }\n        for (int i = n; i < n + k; ++i) {\n            stations.emplace_back(xs[i], ys[i]);\n        }\n    } else if (type == \"clustered_dwarves\") {\n        // Dwarves are clustered together, subway stations are elsewhere\n        ll base_x = rnd.next(MIN_COORD + 1e4, MAX_COORD - 1e4);\n        ll base_y = rnd.next(MIN_COORD + 1e4, MAX_COORD - 1e4);\n\n        set<pair<ll, ll>> used;\n        for (int i = 0; i < n; ++i) {\n            ll x, y;\n            do {\n                x = base_x + rnd.next(-1e4, 1e4);\n                y = base_y + rnd.next(-1e4, 1e4);\n            } while (used.count({x, y}));\n            dwarves.emplace_back(x, y);\n            used.insert({x, y});\n        }\n\n        // Ensure uniqueness\n        ll x0 = rnd.next(MIN_COORD, MAX_COORD - k);\n        vector<ll> xs(k);\n        for (int i = 0; i < k; ++i) {\n            xs[i] = x0 + i;\n        }\n        shuffle(xs.begin(), xs.end());\n        for (int i = 0; i < k; ++i) {\n            ll y;\n            do {\n                y = rnd.next(MIN_COORD, MAX_COORD);\n            } while (used.count({xs[i], y}));\n            stations.emplace_back(xs[i], y);\n            used.insert({xs[i], y});\n        }\n    } else if (type == \"spread_dwarves\") {\n        // Dwarves are spread out over the maximum coordinate range\n        ll x_step = (2 * (MAX_COORD - MIN_COORD)) / max(n - 1, 1);\n        ll x = MIN_COORD;\n        set<pair<ll, ll>> used;\n        for (int i = 0; i < n; ++i) {\n            ll y;\n            do {\n                y = rnd.next(MIN_COORD, MAX_COORD);\n            } while (used.count({x, y}));\n            dwarves.emplace_back(x, y);\n            used.insert({x, y});\n            x += x_step;\n            if (x > MAX_COORD) x = MAX_COORD;\n        }\n\n        // For stations\n        ll x0 = rnd.next(MIN_COORD, MAX_COORD - k);\n        vector<ll> xs(k);\n        for (int i = 0; i < k; ++i) {\n            xs[i] = x0 + i;\n        }\n        shuffle(xs.begin(), xs.end());\n        for (int i = 0; i < k; ++i) {\n            ll y;\n            do {\n                y = rnd.next(MIN_COORD, MAX_COORD);\n            } while (used.count({xs[i], y}));\n            stations.emplace_back(xs[i], y);\n            used.insert({xs[i], y});\n        }\n    } else if (type == \"no_subway\") {\n        k = 0;\n        ll x0 = rnd.next(MIN_COORD, MAX_COORD - n);\n        vector<ll> xs(n);\n        for (int i = 0; i < n; ++i) {\n            xs[i] = x0 + i;\n        }\n        shuffle(xs.begin(), xs.end());\n        vector<ll> ys(n);\n        for (int i = 0; i < n; ++i) {\n            ys[i] = rnd.next(MIN_COORD, MAX_COORD);\n        }\n        for (int i = 0; i < n; ++i) {\n            dwarves.emplace_back(xs[i], ys[i]);\n        }\n    } else if (type == \"single_dwarf\") {\n        n = 1;\n        dwarves.emplace_back(rnd.next(MIN_COORD, MAX_COORD), rnd.next(MIN_COORD, MAX_COORD));\n        set<pair<ll, ll>> used;\n        used.insert(dwarves[0]);\n        ll x0 = rnd.next(MIN_COORD, MAX_COORD - k);\n        vector<ll> xs(k);\n        for (int i = 0; i < k; ++i) {\n            xs[i] = x0 + i;\n        }\n        shuffle(xs.begin(), xs.end());\n        for (int i = 0; i < k; ++i) {\n            ll y;\n            do {\n                y = rnd.next(MIN_COORD, MAX_COORD);\n            } while (used.count({xs[i], y}));\n            stations.emplace_back(xs[i], y);\n            used.insert({xs[i], y});\n        }\n    } else if (type == \"single_subway\") {\n        k = 1;\n        ll total = n + k;\n        ll x0 = rnd.next(MIN_COORD, MAX_COORD - total);\n        vector<ll> xs(total);\n        for (int i = 0; i < total; ++i) {\n            xs[i] = x0 + i;\n        }\n        shuffle(xs.begin(), xs.end());\n        vector<ll> ys(total);\n        for (int i = 0; i < total; ++i) {\n            ys[i] = rnd.next(MIN_COORD, MAX_COORD);\n        }\n        for (int i = 0; i < n; ++i) {\n            dwarves.emplace_back(xs[i], ys[i]);\n        }\n        stations.emplace_back(xs[n], ys[n]);\n    } else if (type == \"max_coordinates\") {\n        ll x_step = (2 * (MAX_COORD - MIN_COORD)) / max(n - 1, 1);\n        ll x = MIN_COORD;\n        for (int i = 0; i < n; ++i) {\n            dwarves.emplace_back(x, MAX_COORD);\n            x += x_step;\n            if (x > MAX_COORD) x = MAX_COORD;\n        }\n        set<pair<ll, ll>> used(dwarves.begin(), dwarves.end());\n        x = MIN_COORD;\n        x_step = (2 * (MAX_COORD - MIN_COORD)) / max(k - 1, 1);\n        for (int i = 0; i < k; ++i) {\n            stations.emplace_back(x, MIN_COORD);\n            x += x_step;\n            if (x > MAX_COORD) x = MAX_COORD;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for (auto& p : dwarves) {\n        printf(\"%lld %lld\\n\", p.first, p.second);\n    }\n    for (auto& p : stations) {\n        printf(\"%lld %lld\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MIN_COORD = -1e8;\nconst ll MAX_COORD = 1e8;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    // The coordinates: |xi|, |yi| ≤ 1e8\n    vector<pair<ll, ll>> dwarves;\n    vector<pair<ll, ll>> stations;\n\n    if (type == \"random\") {\n        // Generate random dwarves and subway stations\n        ll total = n + k;\n        ll x0 = rnd.next(MIN_COORD, MAX_COORD - total);\n        vector<ll> xs(total);\n        for (int i = 0; i < total; ++i) {\n            xs[i] = x0 + i;\n        }\n        shuffle(xs.begin(), xs.end());\n        vector<ll> ys(total);\n        for (int i = 0; i < total; ++i) {\n            ys[i] = rnd.next(MIN_COORD, MAX_COORD);\n        }\n        for (int i = 0; i < n; ++i) {\n            dwarves.emplace_back(xs[i], ys[i]);\n        }\n        for (int i = n; i < n + k; ++i) {\n            stations.emplace_back(xs[i], ys[i]);\n        }\n    } else if (type == \"clustered_dwarves\") {\n        // Dwarves are clustered together, subway stations are elsewhere\n        ll base_x = rnd.next(MIN_COORD + 1e4, MAX_COORD - 1e4);\n        ll base_y = rnd.next(MIN_COORD + 1e4, MAX_COORD - 1e4);\n\n        set<pair<ll, ll>> used;\n        for (int i = 0; i < n; ++i) {\n            ll x, y;\n            do {\n                x = base_x + rnd.next(-1e4, 1e4);\n                y = base_y + rnd.next(-1e4, 1e4);\n            } while (used.count({x, y}));\n            dwarves.emplace_back(x, y);\n            used.insert({x, y});\n        }\n\n        // Ensure uniqueness\n        ll x0 = rnd.next(MIN_COORD, MAX_COORD - k);\n        vector<ll> xs(k);\n        for (int i = 0; i < k; ++i) {\n            xs[i] = x0 + i;\n        }\n        shuffle(xs.begin(), xs.end());\n        for (int i = 0; i < k; ++i) {\n            ll y;\n            do {\n                y = rnd.next(MIN_COORD, MAX_COORD);\n            } while (used.count({xs[i], y}));\n            stations.emplace_back(xs[i], y);\n            used.insert({xs[i], y});\n        }\n    } else if (type == \"spread_dwarves\") {\n        // Dwarves are spread out over the maximum coordinate range\n        ll x_step = (2 * (MAX_COORD - MIN_COORD)) / max(n - 1, 1);\n        ll x = MIN_COORD;\n        set<pair<ll, ll>> used;\n        for (int i = 0; i < n; ++i) {\n            ll y;\n            do {\n                y = rnd.next(MIN_COORD, MAX_COORD);\n            } while (used.count({x, y}));\n            dwarves.emplace_back(x, y);\n            used.insert({x, y});\n            x += x_step;\n            if (x > MAX_COORD) x = MAX_COORD;\n        }\n\n        // For stations\n        ll x0 = rnd.next(MIN_COORD, MAX_COORD - k);\n        vector<ll> xs(k);\n        for (int i = 0; i < k; ++i) {\n            xs[i] = x0 + i;\n        }\n        shuffle(xs.begin(), xs.end());\n        for (int i = 0; i < k; ++i) {\n            ll y;\n            do {\n                y = rnd.next(MIN_COORD, MAX_COORD);\n            } while (used.count({xs[i], y}));\n            stations.emplace_back(xs[i], y);\n            used.insert({xs[i], y});\n        }\n    } else if (type == \"no_subway\") {\n        k = 0;\n        ll x0 = rnd.next(MIN_COORD, MAX_COORD - n);\n        vector<ll> xs(n);\n        for (int i = 0; i < n; ++i) {\n            xs[i] = x0 + i;\n        }\n        shuffle(xs.begin(), xs.end());\n        vector<ll> ys(n);\n        for (int i = 0; i < n; ++i) {\n            ys[i] = rnd.next(MIN_COORD, MAX_COORD);\n        }\n        for (int i = 0; i < n; ++i) {\n            dwarves.emplace_back(xs[i], ys[i]);\n        }\n    } else if (type == \"single_dwarf\") {\n        n = 1;\n        dwarves.emplace_back(rnd.next(MIN_COORD, MAX_COORD), rnd.next(MIN_COORD, MAX_COORD));\n        set<pair<ll, ll>> used;\n        used.insert(dwarves[0]);\n        ll x0 = rnd.next(MIN_COORD, MAX_COORD - k);\n        vector<ll> xs(k);\n        for (int i = 0; i < k; ++i) {\n            xs[i] = x0 + i;\n        }\n        shuffle(xs.begin(), xs.end());\n        for (int i = 0; i < k; ++i) {\n            ll y;\n            do {\n                y = rnd.next(MIN_COORD, MAX_COORD);\n            } while (used.count({xs[i], y}));\n            stations.emplace_back(xs[i], y);\n            used.insert({xs[i], y});\n        }\n    } else if (type == \"single_subway\") {\n        k = 1;\n        ll total = n + k;\n        ll x0 = rnd.next(MIN_COORD, MAX_COORD - total);\n        vector<ll> xs(total);\n        for (int i = 0; i < total; ++i) {\n            xs[i] = x0 + i;\n        }\n        shuffle(xs.begin(), xs.end());\n        vector<ll> ys(total);\n        for (int i = 0; i < total; ++i) {\n            ys[i] = rnd.next(MIN_COORD, MAX_COORD);\n        }\n        for (int i = 0; i < n; ++i) {\n            dwarves.emplace_back(xs[i], ys[i]);\n        }\n        stations.emplace_back(xs[n], ys[n]);\n    } else if (type == \"max_coordinates\") {\n        ll x_step = (2 * (MAX_COORD - MIN_COORD)) / max(n - 1, 1);\n        ll x = MIN_COORD;\n        for (int i = 0; i < n; ++i) {\n            dwarves.emplace_back(x, MAX_COORD);\n            x += x_step;\n            if (x > MAX_COORD) x = MAX_COORD;\n        }\n        set<pair<ll, ll>> used(dwarves.begin(), dwarves.end());\n        x = MIN_COORD;\n        x_step = (2 * (MAX_COORD - MIN_COORD)) / max(k - 1, 1);\n        for (int i = 0; i < k; ++i) {\n            stations.emplace_back(x, MIN_COORD);\n            x += x_step;\n            if (x > MAX_COORD) x = MAX_COORD;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for (auto& p : dwarves) {\n        printf(\"%lld %lld\\n\", p.first, p.second);\n    }\n    for (auto& p : stations) {\n        printf(\"%lld %lld\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type single_dwarf\n./gen -n 1 -k 1 -type single_dwarf\n./gen -n 2 -k 0 -type no_subway\n./gen -n 5 -k 0 -type no_subway\n./gen -n 100 -k 0 -type no_subway\n./gen -n 1000 -k 0 -type no_subway\n./gen -n 10000 -k 0 -type no_subway\n./gen -n 100000 -k 0 -type no_subway\n\n./gen -n 2 -k 1 -type single_subway\n./gen -n 10 -k 1 -type single_subway\n./gen -n 100 -k 1 -type single_subway\n./gen -n 1000 -k 1 -type single_subway\n./gen -n 100000 -k 1 -type single_subway\n\n./gen -n 100 -k 100 -type random\n./gen -n 1000 -k 1000 -type random\n./gen -n 10000 -k 10000 -type random\n./gen -n 100000 -k 100000 -type random\n\n./gen -n 100000 -k 100000 -type clustered_dwarves\n./gen -n 100000 -k 100000 -type spread_dwarves\n./gen -n 100000 -k 100000 -type max_coordinates\n\n./gen -n 1 -k 100000 -type single_dwarf\n./gen -n 2 -k 100000 -type single_dwarf\n./gen -n 100000 -k 1 -type single_subway\n\n./gen -n 100000 -k 0 -type no_subway\n./gen -n 100000 -k 50000 -type random\n./gen -n 100000 -k 99999 -type random\n\n./gen -n 99999 -k 1 -type single_subway\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:21.235799",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "186/A",
      "title": "A. Comparing Strings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains the first dwarf's genome: a non-empty string, consisting of lowercase Latin letters.The second line contains the second dwarf's genome: a non-empty string, consisting of lowercase Latin letters.The number of letters in each genome doesn't exceed 105. It is guaranteed that the strings that correspond to the genomes are different. The given genomes may have different length.",
      "output_spec": "OutputPrint \"YES\", if the dwarves belong to the same race. Otherwise, print \"NO\".",
      "sample_tests": "ExamplesInputCopyabbaOutputCopyYESInputCopyaaabOutputCopyNO",
      "description": "A. Comparing Strings\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains the first dwarf's genome: a non-empty string, consisting of lowercase Latin letters.The second line contains the second dwarf's genome: a non-empty string, consisting of lowercase Latin letters.The number of letters in each genome doesn't exceed 105. It is guaranteed that the strings that correspond to the genomes are different. The given genomes may have different length.\n\nOutputPrint \"YES\", if the dwarves belong to the same race. Otherwise, print \"NO\".\n\nInputCopyabbaOutputCopyYESInputCopyaaabOutputCopyNO\n\nInputCopyabba\n\nOutputCopyYES\n\nInputCopyaaab\n\nOutputCopyNO\n\nNote  First example: you can simply swap two letters in string \"ab\". So we get \"ba\".  Second example: we can't change string \"aa\" into string \"ab\", because \"aa\" does not contain letter \"b\".",
      "solutions": [
        {
          "title": "Codeforces Round #118 - Codeforces",
          "content": "Hello everybody! There is less than 3 hours before my second codeforces round, in which I participating as author. (The first one was — Codeforces Beta Round 56.) It will be llok like the previous one. (That was not bad, I wish. :-)!) I wish, you like today's contest.I'm the author of this round, except one problem, which was proposed by Gerald.In preparing this round was participating : Gerald (He always makes problems better.), cerealguy (Who helps in preparing, i think, the hardest problem of this round. He had solved the first version of round — and think, that it's easy.), Delinur (Who translate the problems). And also it was done with help of \"Polygon\" and \"Codeforces\".I wish, you luck in this contest and to have high rating.Problem scores will be as always. I wish, that problems are sorted well.UPD: I'm very bad man, and have written wrong solution in problem \"C\". Problem under investigation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 912
        },
        {
          "title": "Editorial for Round #118 - Codeforces",
          "content": "No problem was specially taken from \"Wikipedia\". For me it's really hard to understand, that problem \"B\" was there.A (Div 2). (Idea : Gerald, realization : Aksenov239, code : 1670635)If the lengths of 2 strings aren't equal — that means \"NO\". We try to find the positions in strings, where chars are different. If there 1 or more than 2 such positions — \"NO\". After that we swap 2 characters in the first string, and check for their equality.B (Div 2). (Idea : Aksenov239, realization : Aksenov239, code : 1670637) We can see, that we can do all in integers, because k is integer number of percent. For each dwarf we should find his optimal strategy — to check 2 strategies with speed. We should sort them. A (Div 1). (Idea : Aksenov239, realization : Aksenov239, code : 1652592) Let's propose, that after the i-th year, there is x triangles up and y triangles down. After another iteration we can see, that amount of triangles became — 3x + y up and x + 3y down. Let's see the difference between them: at the i-th it's x - y and at the i + 1-th — it's (3x + y) - (x + 3y) = 2 * (x - y). We can see, that difference between amount of triangles grown up by 2. Because on the i-th year the difference became 2i and all amount of triangles is 4i. We can see, that on the i-th year the number of our triangles is . That can be computed by modulo p using the fast-power algorithm.B (Div 1). (Idea : Aksenov239, realization : Aksenov239, code : 1652597) This problem was made by my love to inequalities. :-)! The answer for this problem is .Prove: . (This is AM-GM inequality. Link for whom don't know it.)The equality becomes only, when .And you should check on zeroes. If a = b = c = 0 — you can choose any good answer — x + y + z ≤ S.C (Div 1). No comments. :-)!D (Div 1). (Idea : Aksenov239, realization : cerealguy, Gerald, Aksenov239, code : 1652604)This is number theory problem.I'm trying to explain it step by step:1) Let's prove, that LCD is maximum 2.Let . Squaring both sides we get , but we want to . This means, that d can be only 2.2) Let's make this lenghty product simplier..We can count this by modulo p fast, and divide it by 2r - l, if k is odd.3) There is many interesting things in this solution.Firstly, it doesn't work, when p = 2 — but it can easily done by you.The other problem is harder, what if , this means that for each i ≥ l : , and this mean,that for each i ≥ l : k2i + 1 ≡ p2. And the product by modulo p is equal to 2r - l + 1.E (Div. 1) (Idea : Aksenov239, relization : cerealguy, code : 1652611)This problem wasn't taken to ROI, because of that I gave it here. This is pretty hard problem. I can't now realize, what cerealguy wrote, but his solution is O(nlogn) — without binary search. For me it's quite hard to understand, because my first solution was with binary search. And there were solutions, that has a worse asymptothic, but they run faster.Because of that I can only give you key ideas, that can help you. (afterwards you can see the code of cerealguy)Ideas: Let's find for each person the nearest subway point for them. It can be done in nlogn with use of segment tree or something else. We can see, that if one person goes to subway, the others, which distance to subway is smaller, can go to subway too — it doesn't affect the answer. Because of that we sort all persons by their distanse to subway. The area of the person, where he can come in t seconds, is romb. And we can intersect all rombes in O(n) — the intersection is like rectangle. Let's make the first intersection. When nobody goes to subway. We get a rectangle. The main idea, that for this rectangle — the nearest subway becomes always the same. We go throught people in sorted order, we can fast recalculate this small rectangle — and because of that we can fast recalculate the answer. And we get a solution in O(nlogn) time. Ta-dams.Thank you all for your attention. I'm deeply sorry about the problem \"C\".",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4488",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3919
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #118 - Codeforces - Code 1",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 2",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 3",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 4",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 5",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 6",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 7",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 8",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 9",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 10",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 11",
          "code": "3 4 1\n\n 3 5\n\n  8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 12",
          "code": "(a+b)/2 >= sqrt(a*b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 13",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 14",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 15",
          "code": "cin >> S >> a >> b >> c;\n\nif(a == 0 && b == 0 && c == 0){\n    printf(\"0.0 0.0 0.0\\n\");\n    return 0;\n}\n\ndouble x = a / (double)(a + b + c) * S;\ndouble y = b / (double)(a + b + c) * S;\ndouble z = c / (double)(a + b + c) * S;\nprintf(\"%.20f %.20f %.20f\\n\", x, y, z);\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine(\"[a-z]{1,100000}\", \"s1\");\n    string s2 = inf.readLine(\"[a-z]{1,100000}\", \"s2\");\n\n    ensuref(s1 != s2, \"The two genomes s1 and s2 must be different\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine(\"[a-z]{1,100000}\", \"s1\");\n    string s2 = inf.readLine(\"[a-z]{1,100000}\", \"s2\");\n\n    ensuref(s1 != s2, \"The two genomes s1 and s2 must be different\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine(\"[a-z]{1,100000}\", \"s1\");\n    string s2 = inf.readLine(\"[a-z]{1,100000}\", \"s2\");\n\n    ensuref(s1 != s2, \"The two genomes s1 and s2 must be different\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring random_string(int n) {\n    string s;\n    s.reserve(n);\n    for (int i = 0; i < n; ++i) {\n        char c = rnd.next('a', 'z');\n        s += c;\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\");\n\n    string s1, s2;\n\n    if (type == \"random_yes\") {\n        if (n < 2) n = 2;\n\n        s1 = random_string(n);\n\n        s2 = s1;\n\n        int i = rnd.next(0, n - 1);\n        int j = i;\n        while (j == i) j = rnd.next(0, n - 1);\n\n        swap(s2[i], s2[j]);\n\n        if (s1 == s2) {\n            bool swapped = false;\n            for (i = 0; i < n; ++i) {\n                for (j = i + 1; j < n; ++j) {\n                    if (s1[i] != s1[j]) {\n                        s2 = s1;\n                        swap(s2[i], s2[j]);\n                        swapped = true;\n                        break;\n                    }\n                }\n                if (swapped) break;\n            }\n            if (!swapped) {\n                s1[0] = 'a';\n                s1[1] = 'b';\n                s2 = s1;\n                swap(s2[0], s2[1]);\n            }\n        }\n    } else if (type == \"random_no\") {\n        if (n < 3) n = 3;\n\n        s1 = random_string(n);\n        s2 = s1;\n\n        set<int> modified_positions;\n        int num_diff = rnd.next(3, n);\n\n        while (modified_positions.size() < num_diff) {\n            int pos = rnd.next(0, n - 1);\n            if (modified_positions.count(pos) == 0) {\n                modified_positions.insert(pos);\n                char original_char = s2[pos];\n                char c = rnd.next('a', 'z');\n                while (c == original_char)\n                    c = rnd.next('a', 'z');\n                s2[pos] = c;\n            }\n        }\n    } else if (type == \"different_lengths\") {\n        if (n == -1) n = rnd.next(1, 100000);\n        if (m == -1) {\n            do {\n                m = rnd.next(1, 100000);\n            } while (m == n);\n        }\n\n        s1 = random_string(n);\n        s2 = random_string(m);\n    } else if (type == \"swap_same_letters\") {\n        if (n < 2) n = 2;\n\n        s1 = random_string(n);\n        bool has_duplicate = false;\n        for (int i = 0; i < n - 1 && !has_duplicate; ++i) {\n            for (int j = i + 1; j < n && !has_duplicate; ++j) {\n                if (s1[i] == s1[j]) {\n                    has_duplicate = true;\n                }\n            }\n        }\n        if (!has_duplicate) {\n            s1[0] = 'a';\n            s1[1] = 'a';\n        }\n\n        s2 = s1;\n        int pos = rnd.next(0, n - 1);\n        char c = s2[pos];\n        while (s2[pos] == c)\n            c = rnd.next('a', 'z');\n        s2[pos] = c;\n\n    } else if (type == \"max_length\") {\n        n = 100000;\n        s1 = random_string(n);\n        s2 = s1;\n\n        int num_diff = 3;\n        set<int> positions;\n        while (positions.size() < num_diff) {\n            int pos = rnd.next(0, n - 1);\n            if (positions.count(pos) == 0) {\n                positions.insert(pos);\n                char c = s2[pos];\n                while (s2[pos] == c)\n                    c = rnd.next('a', 'z');\n                s2[pos] = c;\n            }\n        }\n    } else if (type == \"minimal_length\") {\n        n = 1;\n        s1 = random_string(n);\n        s2 = s1;\n        char c = s2[0];\n        while (s2[0] == c)\n            c = rnd.next('a', 'z');\n        s2[0] = c;\n    } else if (type == \"random\") {\n        if (n == -1) n = rnd.next(1, 100000);\n        int choice = rnd.next(0, 1);\n        if (choice == 0) {\n            s1 = random_string(n);\n            s2 = s1;\n            int i = rnd.next(0, n - 1);\n            int j = i;\n            while (j == i) j = rnd.next(0, n - 1);\n            swap(s2[i], s2[j]);\n            if (s1 == s2) {\n                bool swapped = false;\n                for (i = 0; i < n; ++i) {\n                    for (j = i + 1; j < n; ++j) {\n                        if (s1[i] != s1[j]) {\n                            s2 = s1;\n                            swap(s2[i], s2[j]);\n                            swapped = true;\n                            break;\n                        }\n                    }\n                    if (swapped) break;\n                }\n                if (!swapped) {\n                    s1[0] = 'a';\n                    s1[1] = 'b';\n                    s2 = s1;\n                    swap(s2[0], s2[1]);\n                }\n            }\n        } else {\n            s1 = random_string(n);\n            s2 = s1;\n            int num_diff = rnd.next(3, n);\n            set<int> positions;\n            while (positions.size() < num_diff) {\n                int pos = rnd.next(0, n - 1);\n                if (positions.count(pos) == 0) {\n                    positions.insert(pos);\n                    char c = s2[pos];\n                    while (s2[pos] == c)\n                        c = rnd.next('a', 'z');\n                    s2[pos] = c;\n                }\n            }\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    if (s1 == s2) {\n        int pos = 0;\n        char c = s1[pos];\n        while (s1[pos] == c)\n            c = rnd.next('a', 'z');\n        s2[pos] = c;\n    }\n\n    cout << s1 << endl;\n    cout << s2 << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring random_string(int n) {\n    string s;\n    s.reserve(n);\n    for (int i = 0; i < n; ++i) {\n        char c = rnd.next('a', 'z');\n        s += c;\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\");\n\n    string s1, s2;\n\n    if (type == \"random_yes\") {\n        if (n < 2) n = 2;\n\n        s1 = random_string(n);\n\n        s2 = s1;\n\n        int i = rnd.next(0, n - 1);\n        int j = i;\n        while (j == i) j = rnd.next(0, n - 1);\n\n        swap(s2[i], s2[j]);\n\n        if (s1 == s2) {\n            bool swapped = false;\n            for (i = 0; i < n; ++i) {\n                for (j = i + 1; j < n; ++j) {\n                    if (s1[i] != s1[j]) {\n                        s2 = s1;\n                        swap(s2[i], s2[j]);\n                        swapped = true;\n                        break;\n                    }\n                }\n                if (swapped) break;\n            }\n            if (!swapped) {\n                s1[0] = 'a';\n                s1[1] = 'b';\n                s2 = s1;\n                swap(s2[0], s2[1]);\n            }\n        }\n    } else if (type == \"random_no\") {\n        if (n < 3) n = 3;\n\n        s1 = random_string(n);\n        s2 = s1;\n\n        set<int> modified_positions;\n        int num_diff = rnd.next(3, n);\n\n        while (modified_positions.size() < num_diff) {\n            int pos = rnd.next(0, n - 1);\n            if (modified_positions.count(pos) == 0) {\n                modified_positions.insert(pos);\n                char original_char = s2[pos];\n                char c = rnd.next('a', 'z');\n                while (c == original_char)\n                    c = rnd.next('a', 'z');\n                s2[pos] = c;\n            }\n        }\n    } else if (type == \"different_lengths\") {\n        if (n == -1) n = rnd.next(1, 100000);\n        if (m == -1) {\n            do {\n                m = rnd.next(1, 100000);\n            } while (m == n);\n        }\n\n        s1 = random_string(n);\n        s2 = random_string(m);\n    } else if (type == \"swap_same_letters\") {\n        if (n < 2) n = 2;\n\n        s1 = random_string(n);\n        bool has_duplicate = false;\n        for (int i = 0; i < n - 1 && !has_duplicate; ++i) {\n            for (int j = i + 1; j < n && !has_duplicate; ++j) {\n                if (s1[i] == s1[j]) {\n                    has_duplicate = true;\n                }\n            }\n        }\n        if (!has_duplicate) {\n            s1[0] = 'a';\n            s1[1] = 'a';\n        }\n\n        s2 = s1;\n        int pos = rnd.next(0, n - 1);\n        char c = s2[pos];\n        while (s2[pos] == c)\n            c = rnd.next('a', 'z');\n        s2[pos] = c;\n\n    } else if (type == \"max_length\") {\n        n = 100000;\n        s1 = random_string(n);\n        s2 = s1;\n\n        int num_diff = 3;\n        set<int> positions;\n        while (positions.size() < num_diff) {\n            int pos = rnd.next(0, n - 1);\n            if (positions.count(pos) == 0) {\n                positions.insert(pos);\n                char c = s2[pos];\n                while (s2[pos] == c)\n                    c = rnd.next('a', 'z');\n                s2[pos] = c;\n            }\n        }\n    } else if (type == \"minimal_length\") {\n        n = 1;\n        s1 = random_string(n);\n        s2 = s1;\n        char c = s2[0];\n        while (s2[0] == c)\n            c = rnd.next('a', 'z');\n        s2[0] = c;\n    } else if (type == \"random\") {\n        if (n == -1) n = rnd.next(1, 100000);\n        int choice = rnd.next(0, 1);\n        if (choice == 0) {\n            s1 = random_string(n);\n            s2 = s1;\n            int i = rnd.next(0, n - 1);\n            int j = i;\n            while (j == i) j = rnd.next(0, n - 1);\n            swap(s2[i], s2[j]);\n            if (s1 == s2) {\n                bool swapped = false;\n                for (i = 0; i < n; ++i) {\n                    for (j = i + 1; j < n; ++j) {\n                        if (s1[i] != s1[j]) {\n                            s2 = s1;\n                            swap(s2[i], s2[j]);\n                            swapped = true;\n                            break;\n                        }\n                    }\n                    if (swapped) break;\n                }\n                if (!swapped) {\n                    s1[0] = 'a';\n                    s1[1] = 'b';\n                    s2 = s1;\n                    swap(s2[0], s2[1]);\n                }\n            }\n        } else {\n            s1 = random_string(n);\n            s2 = s1;\n            int num_diff = rnd.next(3, n);\n            set<int> positions;\n            while (positions.size() < num_diff) {\n                int pos = rnd.next(0, n - 1);\n                if (positions.count(pos) == 0) {\n                    positions.insert(pos);\n                    char c = s2[pos];\n                    while (s2[pos] == c)\n                        c = rnd.next('a', 'z');\n                    s2[pos] = c;\n                }\n            }\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    if (s1 == s2) {\n        int pos = 0;\n        char c = s1[pos];\n        while (s1[pos] == c)\n            c = rnd.next('a', 'z');\n        s2[pos] = c;\n    }\n\n    cout << s1 << endl;\n    cout << s2 << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random YES cases, varying n\n./gen -type random_yes -n 2\n./gen -type random_yes -n 10\n./gen -type random_yes -n 100\n./gen -type random_yes -n 1000\n./gen -type random_yes -n 10000\n./gen -type random_yes -n 100000\n\n# Random NO cases, varying n\n./gen -type random_no -n 2\n./gen -type random_no -n 10\n./gen -type random_no -n 100\n./gen -type random_no -n 1000\n./gen -type random_no -n 10000\n./gen -type random_no -n 100000\n\n# Different lengths\n./gen -type different_lengths -n 1000 -m 900\n./gen -type different_lengths -n 1 -m 2\n./gen -type different_lengths -n 100000 -m 99999\n./gen -type different_lengths -n 50000 -m 60000\n\n# Swap same letters (NO cases)\n./gen -type swap_same_letters -n 2\n./gen -type swap_same_letters -n 10\n./gen -type swap_same_letters -n 1000\n./gen -type swap_same_letters -n 10000\n\n# Max length cases\n./gen -type max_length\n./gen -type max_length\n\n# Minimal length cases\n./gen -type minimal_length\n./gen -type minimal_length\n\n# Random cases (YES or NO)\n./gen -type random -n 10\n./gen -type random -n 100\n./gen -type random -n 1000\n./gen -type random -n 10000\n./gen -type random -n 100000\n./gen -type random -n 99999\n\n# Edge cases\n./gen -type random_yes -n 1\n./gen -type random_no -n 1\n\n# Additional test cases\n./gen -type random_yes -n 3\n./gen -type random_no -n 3\n\n# Different lengths (edge cases)\n./gen -type different_lengths -n 1 -m 100000\n./gen -type different_lengths -n 100000 -m 1\n\n# Swap same letters with minimal length\n./gen -type swap_same_letters -n 2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:23.348256",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "186/B",
      "title": "B. Growing Mushrooms",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains four integer numbers n, t1, t2, k (1 ≤ n, t1, t2 ≤ 1000; 1 ≤ k ≤ 100) — the number of participants, the time before the break, the time after the break and the percentage, by which the mushroom growth drops during the break, correspondingly.Each of the following n lines contains two integers. The i-th (1 ≤ i ≤ n) line contains space-separated integers ai, bi (1 ≤ ai, bi ≤ 1000) — the speeds which the participant number i chose.",
      "output_spec": "OutputPrint the final results' table: n lines, each line should contain the number of the corresponding dwarf and the final maximum height of his mushroom with exactly two digits after the decimal point. The answer will be considered correct if it is absolutely accurate.",
      "sample_tests": "ExamplesInputCopy2 3 3 502 44 2OutputCopy1 15.002 15.00InputCopy4 1 1 1544 397280 101280 101693 970OutputCopy4 1656.071 937.032 379.993 379.99",
      "description": "B. Growing Mushrooms\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains four integer numbers n, t1, t2, k (1 ≤ n, t1, t2 ≤ 1000; 1 ≤ k ≤ 100) — the number of participants, the time before the break, the time after the break and the percentage, by which the mushroom growth drops during the break, correspondingly.Each of the following n lines contains two integers. The i-th (1 ≤ i ≤ n) line contains space-separated integers ai, bi (1 ≤ ai, bi ≤ 1000) — the speeds which the participant number i chose.\n\nOutputPrint the final results' table: n lines, each line should contain the number of the corresponding dwarf and the final maximum height of his mushroom with exactly two digits after the decimal point. The answer will be considered correct if it is absolutely accurate.\n\nInputCopy2 3 3 502 44 2OutputCopy1 15.002 15.00InputCopy4 1 1 1544 397280 101280 101693 970OutputCopy4 1656.071 937.032 379.993 379.99\n\nInputCopy2 3 3 502 44 2\n\nOutputCopy1 15.002 15.00\n\nInputCopy4 1 1 1544 397280 101280 101693 970\n\nOutputCopy4 1656.071 937.032 379.993 379.99\n\nNote  First example: for each contestant it is optimal to use firstly speed 2 and afterwards speed 4, because 2·3·0.5 + 4·3 > 4·3·0.5 + 2·3.",
      "solutions": [
        {
          "title": "Codeforces Round #118 - Codeforces",
          "content": "Hello everybody! There is less than 3 hours before my second codeforces round, in which I participating as author. (The first one was — Codeforces Beta Round 56.) It will be llok like the previous one. (That was not bad, I wish. :-)!) I wish, you like today's contest.I'm the author of this round, except one problem, which was proposed by Gerald.In preparing this round was participating : Gerald (He always makes problems better.), cerealguy (Who helps in preparing, i think, the hardest problem of this round. He had solved the first version of round — and think, that it's easy.), Delinur (Who translate the problems). And also it was done with help of \"Polygon\" and \"Codeforces\".I wish, you luck in this contest and to have high rating.Problem scores will be as always. I wish, that problems are sorted well.UPD: I'm very bad man, and have written wrong solution in problem \"C\". Problem under investigation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 912
        },
        {
          "title": "Editorial for Round #118 - Codeforces",
          "content": "No problem was specially taken from \"Wikipedia\". For me it's really hard to understand, that problem \"B\" was there.A (Div 2). (Idea : Gerald, realization : Aksenov239, code : 1670635)If the lengths of 2 strings aren't equal — that means \"NO\". We try to find the positions in strings, where chars are different. If there 1 or more than 2 such positions — \"NO\". After that we swap 2 characters in the first string, and check for their equality.B (Div 2). (Idea : Aksenov239, realization : Aksenov239, code : 1670637) We can see, that we can do all in integers, because k is integer number of percent. For each dwarf we should find his optimal strategy — to check 2 strategies with speed. We should sort them. A (Div 1). (Idea : Aksenov239, realization : Aksenov239, code : 1652592) Let's propose, that after the i-th year, there is x triangles up and y triangles down. After another iteration we can see, that amount of triangles became — 3x + y up and x + 3y down. Let's see the difference between them: at the i-th it's x - y and at the i + 1-th — it's (3x + y) - (x + 3y) = 2 * (x - y). We can see, that difference between amount of triangles grown up by 2. Because on the i-th year the difference became 2i and all amount of triangles is 4i. We can see, that on the i-th year the number of our triangles is . That can be computed by modulo p using the fast-power algorithm.B (Div 1). (Idea : Aksenov239, realization : Aksenov239, code : 1652597) This problem was made by my love to inequalities. :-)! The answer for this problem is .Prove: . (This is AM-GM inequality. Link for whom don't know it.)The equality becomes only, when .And you should check on zeroes. If a = b = c = 0 — you can choose any good answer — x + y + z ≤ S.C (Div 1). No comments. :-)!D (Div 1). (Idea : Aksenov239, realization : cerealguy, Gerald, Aksenov239, code : 1652604)This is number theory problem.I'm trying to explain it step by step:1) Let's prove, that LCD is maximum 2.Let . Squaring both sides we get , but we want to . This means, that d can be only 2.2) Let's make this lenghty product simplier..We can count this by modulo p fast, and divide it by 2r - l, if k is odd.3) There is many interesting things in this solution.Firstly, it doesn't work, when p = 2 — but it can easily done by you.The other problem is harder, what if , this means that for each i ≥ l : , and this mean,that for each i ≥ l : k2i + 1 ≡ p2. And the product by modulo p is equal to 2r - l + 1.E (Div. 1) (Idea : Aksenov239, relization : cerealguy, code : 1652611)This problem wasn't taken to ROI, because of that I gave it here. This is pretty hard problem. I can't now realize, what cerealguy wrote, but his solution is O(nlogn) — without binary search. For me it's quite hard to understand, because my first solution was with binary search. And there were solutions, that has a worse asymptothic, but they run faster.Because of that I can only give you key ideas, that can help you. (afterwards you can see the code of cerealguy)Ideas: Let's find for each person the nearest subway point for them. It can be done in nlogn with use of segment tree or something else. We can see, that if one person goes to subway, the others, which distance to subway is smaller, can go to subway too — it doesn't affect the answer. Because of that we sort all persons by their distanse to subway. The area of the person, where he can come in t seconds, is romb. And we can intersect all rombes in O(n) — the intersection is like rectangle. Let's make the first intersection. When nobody goes to subway. We get a rectangle. The main idea, that for this rectangle — the nearest subway becomes always the same. We go throught people in sorted order, we can fast recalculate this small rectangle — and because of that we can fast recalculate the answer. And we get a solution in O(nlogn) time. Ta-dams.Thank you all for your attention. I'm deeply sorry about the problem \"C\".",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4488",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3919
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #118 - Codeforces - Code 1",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 2",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 3",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 4",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 5",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 6",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 7",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 8",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 9",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 10",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 11",
          "code": "3 4 1\n\n 3 5\n\n  8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 12",
          "code": "(a+b)/2 >= sqrt(a*b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 13",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 14",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 15",
          "code": "cin >> S >> a >> b >> c;\n\nif(a == 0 && b == 0 && c == 0){\n    printf(\"0.0 0.0 0.0\\n\");\n    return 0;\n}\n\ndouble x = a / (double)(a + b + c) * S;\ndouble y = b / (double)(a + b + c) * S;\ndouble z = c / (double)(a + b + c) * S;\nprintf(\"%.20f %.20f %.20f\\n\", x, y, z);\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int t1 = inf.readInt(1, 1000, \"t1\");\n    inf.readSpace();\n    int t2 = inf.readInt(1, 1000, \"t2\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        int ai = inf.readInt(1, 1000, (\"ai[\" + to_string(i) + \"]\").c_str());\n        inf.readSpace();\n        int bi = inf.readInt(1, 1000, (\"bi[\" + to_string(i) + \"]\").c_str());\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int t1 = inf.readInt(1, 1000, \"t1\");\n    inf.readSpace();\n    int t2 = inf.readInt(1, 1000, \"t2\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        int ai = inf.readInt(1, 1000, (\"ai[\" + to_string(i) + \"]\").c_str());\n        inf.readSpace();\n        int bi = inf.readInt(1, 1000, (\"bi[\" + to_string(i) + \"]\").c_str());\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int t1 = inf.readInt(1, 1000, \"t1\");\n    inf.readSpace();\n    int t2 = inf.readInt(1, 1000, \"t2\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; i++) {\n        int ai = inf.readInt(1, 1000, (\"ai[\" + to_string(i) + \"]\").c_str());\n        inf.readSpace();\n        int bi = inf.readInt(1, 1000, (\"bi[\" + to_string(i) + \"]\").c_str());\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int t1 = opt<int>(\"t1\", -1);\n    int t2 = opt<int>(\"t2\", -1);\n    int k = opt<int>(\"k\", -1);\n\n    // Set default values if not specified\n    if (t1 == -1) t1 = rnd.next(1,1000);\n    if (t2 == -1) t2 = rnd.next(1,1000);\n    if (k == -1) k = rnd.next(1,100);\n\n    if (type == \"max_values\") {\n        t1 = 1000;\n        t2 = 1000;\n        k = 100;\n    } else if (type == \"min_values\") {\n        t1 = 1;\n        t2 = 1;\n        k = 1;\n    } else if (type == \"no_reduction\") {\n        k = 1; // minimal k\n    } else if (type == \"total_reduction\") {\n        k = 100; // maximal k\n    }\n\n    printf(\"%d %d %d %d\\n\", n, t1, t2, k);\n\n    vector<pair<int, int> > speeds(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 1000);\n            int bi = rnd.next(1, 1000);\n            speeds[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"same_speeds\") {\n        for(int i = 0; i < n; ++i) {\n            int speed = rnd.next(1, 1000);\n            speeds[i] = make_pair(speed, speed);\n        }\n    } else if (type == \"max_values\") {\n        for(int i = 0; i < n; ++i) {\n            speeds[i] = make_pair(1000, 1000);\n        }\n    } else if (type == \"min_values\") {\n        for(int i = 0; i < n; ++i) {\n            speeds[i] = make_pair(1, 1);\n        }\n    } else if (type == \"equal_heights\") {\n        // Generate speeds such that participants will have same total height\n        int ai = rnd.next(1,1000);\n        int bi = ai;\n        for(int i = 0; i < n; ++i) {\n            speeds[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"precision_test\") {\n        // Generate speeds that result in mushroom heights that differ by small amounts\n        for(int i = 0; i < n; ++i) {\n            int ai = 1000 - i % 10; // Slightly decreasing speeds\n            int bi = 1000 - (i / 10) % 10;\n            speeds[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"no_reduction\" || type == \"total_reduction\") {\n        for(int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 1000);\n            int bi = rnd.next(1, 1000);\n            speeds[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"identical_participants\") {\n        int ai = rnd.next(1, 1000);\n        int bi = rnd.next(1, 1000);\n        for(int i = 0; i < n; ++i) {\n            speeds[i] = make_pair(ai, bi);\n        }\n    } else {\n        // Default random\n        for(int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 1000);\n            int bi = rnd.next(1, 1000);\n            speeds[i] = make_pair(ai, bi);\n        }\n    }\n\n    // Output the speeds\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", speeds[i].first, speeds[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int t1 = opt<int>(\"t1\", -1);\n    int t2 = opt<int>(\"t2\", -1);\n    int k = opt<int>(\"k\", -1);\n\n    // Set default values if not specified\n    if (t1 == -1) t1 = rnd.next(1,1000);\n    if (t2 == -1) t2 = rnd.next(1,1000);\n    if (k == -1) k = rnd.next(1,100);\n\n    if (type == \"max_values\") {\n        t1 = 1000;\n        t2 = 1000;\n        k = 100;\n    } else if (type == \"min_values\") {\n        t1 = 1;\n        t2 = 1;\n        k = 1;\n    } else if (type == \"no_reduction\") {\n        k = 1; // minimal k\n    } else if (type == \"total_reduction\") {\n        k = 100; // maximal k\n    }\n\n    printf(\"%d %d %d %d\\n\", n, t1, t2, k);\n\n    vector<pair<int, int> > speeds(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 1000);\n            int bi = rnd.next(1, 1000);\n            speeds[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"same_speeds\") {\n        for(int i = 0; i < n; ++i) {\n            int speed = rnd.next(1, 1000);\n            speeds[i] = make_pair(speed, speed);\n        }\n    } else if (type == \"max_values\") {\n        for(int i = 0; i < n; ++i) {\n            speeds[i] = make_pair(1000, 1000);\n        }\n    } else if (type == \"min_values\") {\n        for(int i = 0; i < n; ++i) {\n            speeds[i] = make_pair(1, 1);\n        }\n    } else if (type == \"equal_heights\") {\n        // Generate speeds such that participants will have same total height\n        int ai = rnd.next(1,1000);\n        int bi = ai;\n        for(int i = 0; i < n; ++i) {\n            speeds[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"precision_test\") {\n        // Generate speeds that result in mushroom heights that differ by small amounts\n        for(int i = 0; i < n; ++i) {\n            int ai = 1000 - i % 10; // Slightly decreasing speeds\n            int bi = 1000 - (i / 10) % 10;\n            speeds[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"no_reduction\" || type == \"total_reduction\") {\n        for(int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 1000);\n            int bi = rnd.next(1, 1000);\n            speeds[i] = make_pair(ai, bi);\n        }\n    } else if (type == \"identical_participants\") {\n        int ai = rnd.next(1, 1000);\n        int bi = rnd.next(1, 1000);\n        for(int i = 0; i < n; ++i) {\n            speeds[i] = make_pair(ai, bi);\n        }\n    } else {\n        // Default random\n        for(int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, 1000);\n            int bi = rnd.next(1, 1000);\n            speeds[i] = make_pair(ai, bi);\n        }\n    }\n\n    // Output the speeds\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", speeds[i].first, speeds[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case 1: Minimal values\n./gen -n 1 -type min_values\n\n# Test case 2: Maximal values\n./gen -n 1000 -type max_values\n\n# Test case 3: Random case with n = 1000\n./gen -n 1000 -type random\n\n# Test case 4: Random small n\n./gen -n 10 -type random\n\n# Test case 5: Random with t1 much less than t2\n./gen -n 1000 -t1 1 -t2 1000 -k 50 -type random\n\n# Test case 6: Random with t2 much less than t1\n./gen -n 1000 -t1 1000 -t2 1 -k 50 -type random\n\n# Test case 7: Random with k = 1 (minimal k)\n./gen -n 1000 -k 1 -type random\n\n# Test case 8: Random with k = 100 (maximal k)\n./gen -n 1000 -k 100 -type random\n\n# Test case 9: Participants with same speeds (ai = bi)\n./gen -n 1000 -type same_speeds\n\n# Test case 10: Equal mushroom heights\n./gen -n 10 -type equal_heights\n\n# Test case 11: Equal mushroom heights with large n\n./gen -n 1000 -type equal_heights\n\n# Test case 12: Precision test\n./gen -n 1000 -type precision_test\n\n# Test case 13: No reduction (k minimal)\n./gen -n 1000 -type no_reduction\n\n# Test case 14: Total reduction (k maximal)\n./gen -n 1000 -type total_reduction\n\n# Test case 15: Identical participants\n./gen -n 1000 -type identical_participants\n\n# Test case 16: Random with t1 and t2 minimal\n./gen -n 1000 -t1 1 -t2 1 -type random\n\n# Test case 17: Random with t1 and t2 maximal\n./gen -n 1000 -t1 1000 -t2 1000 -type random\n\n# Test case 18: Random with n minimal\n./gen -n 1 -type random\n\n# Test case 19: Random with uneven k\n./gen -n 1000 -k 99 -type random\n\n# Test case 20: Random with t1=999, t2=1, k=1\n./gen -n 1000 -t1 999 -t2 1 -k 1 -type random\n\n# Test case 21: Random with t1=1, t2=999, k=99\n./gen -n 1000 -t1 1 -t2 999 -k 99 -type random\n\n# Test case 22: Maximal t1, t2 with precision test\n./gen -n 1000 -t1 1000 -t2 1000 -type precision_test\n\n# Test case 23: Random with t1 = t2 = 500, k = 50\n./gen -n 1000 -t1 500 -t2 500 -k 50 -type random\n\n# Test case 24: Random with large k, small t1\n./gen -n 1000 -t1 1 -t2 1000 -k 100 -type random\n\n# Test case 25: Random with small k, large t1\n./gen -n 1000 -t1 1000 -t2 1 -k 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:25.776013",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "186/C",
      "title": "C. Plant",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (0 ≤ n ≤ 1018) — the number of full years when the plant grew.Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputPrint a single integer — the remainder of dividing the number of plants that will point \"upwards\" in n years by 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy1OutputCopy3InputCopy2OutputCopy10",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (0 ≤ n ≤ 1018) — the number of full years when the plant grew.Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.\n\nOutputPrint a single integer — the remainder of dividing the number of plants that will point \"upwards\" in n years by 1000000007 (109 + 7).\n\nInputCopy1OutputCopy3InputCopy2OutputCopy10\n\nOutputCopy3\n\nOutputCopy10\n\nNoteThe first test sample corresponds to the second triangle on the figure in the statement. The second test sample corresponds to the third one.",
      "solutions": [
        {
          "title": "Codeforces Round #118 - Codeforces",
          "content": "Hello everybody! There is less than 3 hours before my second codeforces round, in which I participating as author. (The first one was — Codeforces Beta Round 56.) It will be llok like the previous one. (That was not bad, I wish. :-)!) I wish, you like today's contest.I'm the author of this round, except one problem, which was proposed by Gerald.In preparing this round was participating : Gerald (He always makes problems better.), cerealguy (Who helps in preparing, i think, the hardest problem of this round. He had solved the first version of round — and think, that it's easy.), Delinur (Who translate the problems). And also it was done with help of \"Polygon\" and \"Codeforces\".I wish, you luck in this contest and to have high rating.Problem scores will be as always. I wish, that problems are sorted well.UPD: I'm very bad man, and have written wrong solution in problem \"C\". Problem under investigation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 912
        },
        {
          "title": "Editorial for Round #118 - Codeforces",
          "content": "No problem was specially taken from \"Wikipedia\". For me it's really hard to understand, that problem \"B\" was there.A (Div 2). (Idea : Gerald, realization : Aksenov239, code : 1670635)If the lengths of 2 strings aren't equal — that means \"NO\". We try to find the positions in strings, where chars are different. If there 1 or more than 2 such positions — \"NO\". After that we swap 2 characters in the first string, and check for their equality.B (Div 2). (Idea : Aksenov239, realization : Aksenov239, code : 1670637) We can see, that we can do all in integers, because k is integer number of percent. For each dwarf we should find his optimal strategy — to check 2 strategies with speed. We should sort them. A (Div 1). (Idea : Aksenov239, realization : Aksenov239, code : 1652592) Let's propose, that after the i-th year, there is x triangles up and y triangles down. After another iteration we can see, that amount of triangles became — 3x + y up and x + 3y down. Let's see the difference between them: at the i-th it's x - y and at the i + 1-th — it's (3x + y) - (x + 3y) = 2 * (x - y). We can see, that difference between amount of triangles grown up by 2. Because on the i-th year the difference became 2i and all amount of triangles is 4i. We can see, that on the i-th year the number of our triangles is . That can be computed by modulo p using the fast-power algorithm.B (Div 1). (Idea : Aksenov239, realization : Aksenov239, code : 1652597) This problem was made by my love to inequalities. :-)! The answer for this problem is .Prove: . (This is AM-GM inequality. Link for whom don't know it.)The equality becomes only, when .And you should check on zeroes. If a = b = c = 0 — you can choose any good answer — x + y + z ≤ S.C (Div 1). No comments. :-)!D (Div 1). (Idea : Aksenov239, realization : cerealguy, Gerald, Aksenov239, code : 1652604)This is number theory problem.I'm trying to explain it step by step:1) Let's prove, that LCD is maximum 2.Let . Squaring both sides we get , but we want to . This means, that d can be only 2.2) Let's make this lenghty product simplier..We can count this by modulo p fast, and divide it by 2r - l, if k is odd.3) There is many interesting things in this solution.Firstly, it doesn't work, when p = 2 — but it can easily done by you.The other problem is harder, what if , this means that for each i ≥ l : , and this mean,that for each i ≥ l : k2i + 1 ≡ p2. And the product by modulo p is equal to 2r - l + 1.E (Div. 1) (Idea : Aksenov239, relization : cerealguy, code : 1652611)This problem wasn't taken to ROI, because of that I gave it here. This is pretty hard problem. I can't now realize, what cerealguy wrote, but his solution is O(nlogn) — without binary search. For me it's quite hard to understand, because my first solution was with binary search. And there were solutions, that has a worse asymptothic, but they run faster.Because of that I can only give you key ideas, that can help you. (afterwards you can see the code of cerealguy)Ideas: Let's find for each person the nearest subway point for them. It can be done in nlogn with use of segment tree or something else. We can see, that if one person goes to subway, the others, which distance to subway is smaller, can go to subway too — it doesn't affect the answer. Because of that we sort all persons by their distanse to subway. The area of the person, where he can come in t seconds, is romb. And we can intersect all rombes in O(n) — the intersection is like rectangle. Let's make the first intersection. When nobody goes to subway. We get a rectangle. The main idea, that for this rectangle — the nearest subway becomes always the same. We go throught people in sorted order, we can fast recalculate this small rectangle — and because of that we can fast recalculate the answer. And we get a solution in O(nlogn) time. Ta-dams.Thank you all for your attention. I'm deeply sorry about the problem \"C\".",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4488",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3919
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #118 - Codeforces - Code 1",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 2",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 3",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 4",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 5",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 6",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 7",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 8",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 9",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 10",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 11",
          "code": "3 4 1\n\n 3 5\n\n  8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 12",
          "code": "(a+b)/2 >= sqrt(a*b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 13",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 14",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 15",
          "code": "cin >> S >> a >> b >> c;\n\nif(a == 0 && b == 0 && c == 0){\n    printf(\"0.0 0.0 0.0\\n\");\n    return 0;\n}\n\ndouble x = a / (double)(a + b + c) * S;\ndouble y = b / (double)(a + b + c) * S;\ndouble z = c / (double)(a + b + c) * S;\nprintf(\"%.20f %.20f %.20f\\n\", x, y, z);\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(0LL, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(0LL, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(0LL, 1000000000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register the generator (required by testlib).\n    registerGen(argc, argv, 1);\n\n    // Read the \"type\" parameter to decide how to generate n.\n    // Default to \"direct\" if not provided.\n    string type = opt<string>(\"type\", \"direct\");\n\n    // We will store the final value of n here.\n    long long n = 0;\n\n    if (type == \"direct\") {\n        // If \"direct\" is chosen, read the exact value of n.\n        n = opt<long long>(\"n\", 0LL);\n    } else {\n        // If \"random\" is chosen, read the maximum possible value of n,\n        // then generate n in [0, maxN].\n        long long maxN = opt<long long>(\"maxN\", 0LL);\n        n = rnd.next(0LL, maxN);\n    }\n\n    // Output the integer n (one test case).\n    cout << n << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register the generator (required by testlib).\n    registerGen(argc, argv, 1);\n\n    // Read the \"type\" parameter to decide how to generate n.\n    // Default to \"direct\" if not provided.\n    string type = opt<string>(\"type\", \"direct\");\n\n    // We will store the final value of n here.\n    long long n = 0;\n\n    if (type == \"direct\") {\n        // If \"direct\" is chosen, read the exact value of n.\n        n = opt<long long>(\"n\", 0LL);\n    } else {\n        // If \"random\" is chosen, read the maximum possible value of n,\n        // then generate n in [0, maxN].\n        long long maxN = opt<long long>(\"maxN\", 0LL);\n        n = rnd.next(0LL, maxN);\n    }\n\n    // Output the integer n (one test case).\n    cout << n << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# 1. Exact boundary: smallest possible n\n./gen -type direct -n 0\n\n# 2. Small direct value\n./gen -type direct -n 1\n\n# 3. Another small direct value\n./gen -type direct -n 2\n\n# 4. Small direct value\n./gen -type direct -n 3\n\n# 5. Medium direct value\n./gen -type direct -n 100\n\n# 6. Larger direct value\n./gen -type direct -n 99999999\n\n# 7. Exact upper bound\n./gen -type direct -n 1000000000000000000\n\n# 8. Large but just under upper bound\n./gen -type direct -n 999999999999999999\n\n# 9. Small random range\n./gen -type random -maxN 10\n\n# 10. Another small random range\n./gen -type random -maxN 10\n\n# 11. Moderate random range\n./gen -type random -maxN 100\n\n# 12. Moderate random range\n./gen -type random -maxN 12345\n\n# 13. Larger random range\n./gen -type random -maxN 99999999\n\n# 14. Very large random range\n./gen -type random -maxN 1000000000000000000\n\n# 15. Another very large random range\n./gen -type random -maxN 1000000000000000000\n\n# 16. Random range of medium size\n./gen -type random -maxN 500\n\n# 17. Random range close to the upper bound\n./gen -type random -maxN 999999999999999999\n\n# 18. Another random range close to the upper bound\n./gen -type random -maxN 999999999999999999\n\n# 19. Random range in the billions\n./gen -type random -maxN 10000000000\n\n# 20. Another random range in the billions\n./gen -type random -maxN 10000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:27.680159",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "186/D",
      "title": "D. Mushroom Scientists",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer S (1 ≤ S ≤ 103) — the maximum sum of coordinates of the sought point.The second line contains three space-separated integers a, b, c (0 ≤ a, b, c ≤ 103) — the numbers that describe the metric of mushroom scientists.",
      "output_spec": "OutputPrint three real numbers — the coordinates of the point that reaches maximum value in the metrics of mushroom scientists. If there are multiple answers, print any of them that meets the limitations.A natural logarithm of distance from the center of the Universe to the given point in the metric of mushroom scientists shouldn't differ from the natural logarithm of the maximum distance by more than 10 - 6. We think that ln(0) =  - ∞.",
      "sample_tests": "ExamplesInputCopy31 1 1OutputCopy1.0 1.0 1.0InputCopy32 0 0OutputCopy3.0 0.0 0.0",
      "description": "D. Mushroom Scientists\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer S (1 ≤ S ≤ 103) — the maximum sum of coordinates of the sought point.The second line contains three space-separated integers a, b, c (0 ≤ a, b, c ≤ 103) — the numbers that describe the metric of mushroom scientists.\n\nOutputPrint three real numbers — the coordinates of the point that reaches maximum value in the metrics of mushroom scientists. If there are multiple answers, print any of them that meets the limitations.A natural logarithm of distance from the center of the Universe to the given point in the metric of mushroom scientists shouldn't differ from the natural logarithm of the maximum distance by more than 10 - 6. We think that ln(0) =  - ∞.\n\nInputCopy31 1 1OutputCopy1.0 1.0 1.0InputCopy32 0 0OutputCopy3.0 0.0 0.0\n\nInputCopy31 1 1\n\nOutputCopy1.0 1.0 1.0\n\nInputCopy32 0 0\n\nOutputCopy3.0 0.0 0.0",
      "solutions": [
        {
          "title": "Codeforces Round #118 - Codeforces",
          "content": "Hello everybody! There is less than 3 hours before my second codeforces round, in which I participating as author. (The first one was — Codeforces Beta Round 56.) It will be llok like the previous one. (That was not bad, I wish. :-)!) I wish, you like today's contest.I'm the author of this round, except one problem, which was proposed by Gerald.In preparing this round was participating : Gerald (He always makes problems better.), cerealguy (Who helps in preparing, i think, the hardest problem of this round. He had solved the first version of round — and think, that it's easy.), Delinur (Who translate the problems). And also it was done with help of \"Polygon\" and \"Codeforces\".I wish, you luck in this contest and to have high rating.Problem scores will be as always. I wish, that problems are sorted well.UPD: I'm very bad man, and have written wrong solution in problem \"C\". Problem under investigation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 912
        },
        {
          "title": "Editorial for Round #118 - Codeforces",
          "content": "No problem was specially taken from \"Wikipedia\". For me it's really hard to understand, that problem \"B\" was there.A (Div 2). (Idea : Gerald, realization : Aksenov239, code : 1670635)If the lengths of 2 strings aren't equal — that means \"NO\". We try to find the positions in strings, where chars are different. If there 1 or more than 2 such positions — \"NO\". After that we swap 2 characters in the first string, and check for their equality.B (Div 2). (Idea : Aksenov239, realization : Aksenov239, code : 1670637) We can see, that we can do all in integers, because k is integer number of percent. For each dwarf we should find his optimal strategy — to check 2 strategies with speed. We should sort them. A (Div 1). (Idea : Aksenov239, realization : Aksenov239, code : 1652592) Let's propose, that after the i-th year, there is x triangles up and y triangles down. After another iteration we can see, that amount of triangles became — 3x + y up and x + 3y down. Let's see the difference between them: at the i-th it's x - y and at the i + 1-th — it's (3x + y) - (x + 3y) = 2 * (x - y). We can see, that difference between amount of triangles grown up by 2. Because on the i-th year the difference became 2i and all amount of triangles is 4i. We can see, that on the i-th year the number of our triangles is . That can be computed by modulo p using the fast-power algorithm.B (Div 1). (Idea : Aksenov239, realization : Aksenov239, code : 1652597) This problem was made by my love to inequalities. :-)! The answer for this problem is .Prove: . (This is AM-GM inequality. Link for whom don't know it.)The equality becomes only, when .And you should check on zeroes. If a = b = c = 0 — you can choose any good answer — x + y + z ≤ S.C (Div 1). No comments. :-)!D (Div 1). (Idea : Aksenov239, realization : cerealguy, Gerald, Aksenov239, code : 1652604)This is number theory problem.I'm trying to explain it step by step:1) Let's prove, that LCD is maximum 2.Let . Squaring both sides we get , but we want to . This means, that d can be only 2.2) Let's make this lenghty product simplier..We can count this by modulo p fast, and divide it by 2r - l, if k is odd.3) There is many interesting things in this solution.Firstly, it doesn't work, when p = 2 — but it can easily done by you.The other problem is harder, what if , this means that for each i ≥ l : , and this mean,that for each i ≥ l : k2i + 1 ≡ p2. And the product by modulo p is equal to 2r - l + 1.E (Div. 1) (Idea : Aksenov239, relization : cerealguy, code : 1652611)This problem wasn't taken to ROI, because of that I gave it here. This is pretty hard problem. I can't now realize, what cerealguy wrote, but his solution is O(nlogn) — without binary search. For me it's quite hard to understand, because my first solution was with binary search. And there were solutions, that has a worse asymptothic, but they run faster.Because of that I can only give you key ideas, that can help you. (afterwards you can see the code of cerealguy)Ideas: Let's find for each person the nearest subway point for them. It can be done in nlogn with use of segment tree or something else. We can see, that if one person goes to subway, the others, which distance to subway is smaller, can go to subway too — it doesn't affect the answer. Because of that we sort all persons by their distanse to subway. The area of the person, where he can come in t seconds, is romb. And we can intersect all rombes in O(n) — the intersection is like rectangle. Let's make the first intersection. When nobody goes to subway. We get a rectangle. The main idea, that for this rectangle — the nearest subway becomes always the same. We go throught people in sorted order, we can fast recalculate this small rectangle — and because of that we can fast recalculate the answer. And we get a solution in O(nlogn) time. Ta-dams.Thank you all for your attention. I'm deeply sorry about the problem \"C\".",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4488",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3919
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #118 - Codeforces - Code 1",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 2",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 3",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 4",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 5",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 6",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 7",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 8",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 9",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 10",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 11",
          "code": "3 4 1\n\n 3 5\n\n  8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 12",
          "code": "(a+b)/2 >= sqrt(a*b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 13",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 14",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 15",
          "code": "cin >> S >> a >> b >> c;\n\nif(a == 0 && b == 0 && c == 0){\n    printf(\"0.0 0.0 0.0\\n\");\n    return 0;\n}\n\ndouble x = a / (double)(a + b + c) * S;\ndouble y = b / (double)(a + b + c) * S;\ndouble z = c / (double)(a + b + c) * S;\nprintf(\"%.20f %.20f %.20f\\n\", x, y, z);\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int S = inf.readInt(1, 1000, \"S\");\n    inf.readEoln();\n    int a = inf.readInt(0, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 1000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(0, 1000, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int S = inf.readInt(1, 1000, \"S\");\n    inf.readEoln();\n    int a = inf.readInt(0, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 1000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(0, 1000, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int S = inf.readInt(1, 1000, \"S\");\n    inf.readEoln();\n    int a = inf.readInt(0, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 1000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(0, 1000, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <cmath>\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read S, a, b, c\n    int S = inf.readInt();   // 1 <= S <= 1000\n    int a = inf.readInt();   // 0 <= a <= 1000\n    int b = inf.readInt();   // 0 <= b <= 1000\n    int c = inf.readInt();   // 0 <= c <= 1000\n\n    // Calculate sum of exponents\n    long long sumABC = (long long)a + b + c;\n\n    // Compute lnBest\n    double lnBest = 0.0;\n    if (sumABC > 0)\n    {\n        double A = (double)a, B = (double)b, C = (double)c;\n        double T = A + B + C;\n        if (A > 0) lnBest += A * (std::log((double)S) + std::log(A) - std::log(T));\n        if (B > 0) lnBest += B * (std::log((double)S) + std::log(B) - std::log(T));\n        if (C > 0) lnBest += C * (std::log((double)S) + std::log(C) - std::log(T));\n    }\n\n    // Read contestant's x, y, z\n    double x = ouf.readDouble();\n    double y = ouf.readDouble();\n    double z = ouf.readDouble();\n\n    // Check feasibility\n    if (x < 0.0 || y < 0.0 || z < 0.0)\n        quitf(_wa, \"negative coordinate\");\n    if (x + y + z > S + 1e-9)\n        quitf(_wa, \"sum of coordinates exceeds S\");\n\n    // Compute lnDist\n    double lnDist = 0.0;\n    bool invalid = false;\n    if (a > 0 && x <= 0.0) invalid = true;\n    if (b > 0 && y <= 0.0) invalid = true;\n    if (c > 0 && z <= 0.0) invalid = true;\n    if (invalid)\n        lnDist = -1e100; // effectively -∞\n    else\n    {\n        if (a > 0) lnDist += a * std::log(x);\n        if (b > 0) lnDist += b * std::log(y);\n        if (c > 0) lnDist += c * std::log(z);\n    }\n\n    // If sumABC=0 => no check needed; otherwise ensure lnDist >= lnBest - 1e-6\n    if (sumABC > 0 && lnDist < lnBest - 1e-6)\n        quitf(_wa, \"distance too small\");\n\n    // Passed\n    quitf(_ok, \"OK\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int S = opt<int>(\"S\", rnd.next(1, 1000));\n    string type = opt<string>(\"type\", \"random\");\n\n    int a, b, c;\n    if (type == \"random\") {\n        a = rnd.next(0, 1000);\n        b = rnd.next(0, 1000);\n        c = rnd.next(0, 1000);\n    }\n    else if (type == \"exponents_zero\") {\n        a = 0;\n        b = 0;\n        c = 0;\n    }\n    else if (type == \"exponents_max\") {\n        a = 1000;\n        b = 1000;\n        c = 1000;\n    }\n    else if (type == \"one_zero\") {\n        int zero_pos = rnd.next(0, 2);\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        c = rnd.next(1, 1000);\n        if (zero_pos == 0) a = 0;\n        else if (zero_pos == 1) b = 0;\n        else c = 0;\n    }\n    else if (type == \"two_zero\") {\n        vector<int> positions = {0,1,2};\n        shuffle(positions.begin(), positions.end());\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        c = rnd.next(1, 1000);\n        int zero1 = positions[0];\n        int zero2 = positions[1];\n        if (zero1 == 0 || zero2 == 0) a = 0;\n        if (zero1 == 1 || zero2 == 1) b = 0;\n        if (zero1 == 2 || zero2 == 2) c = 0;\n    }\n    else if (type == \"exponents_large_small\") {\n        a = rnd.next(0, 1) * 1000; // Either 0 or 1000\n        b = rnd.next(0, 1) * 1000;\n        c = rnd.next(0, 1) * 1000;\n        if (a == 0 && b == 0 && c == 0) {\n            int non_zero_pos = rnd.next(0,2);\n            if (non_zero_pos == 0) a = 1000;\n            else if (non_zero_pos == 1) b = 1000;\n            else c = 1000;\n        }\n    }\n    else if (type == \"S_min\") {\n        S = 1;\n        a = rnd.next(0, 1000);\n        b = rnd.next(0, 1000);\n        c = rnd.next(0, 1000);\n    }\n    else if (type == \"S_max\") {\n        S = 1000;\n        a = rnd.next(0, 1000);\n        b = rnd.next(0, 1000);\n        c = rnd.next(0, 1000);\n    }\n    else if (type == \"only_a_nonzero\") {\n        a = rnd.next(1, 1000);\n        b = 0;\n        c = 0;\n    }\n    else if (type == \"only_b_nonzero\") {\n        b = rnd.next(1, 1000);\n        a = 0;\n        c = 0;\n    }\n    else if (type == \"only_c_nonzero\") {\n        c = rnd.next(1, 1000);\n        a = 0;\n        b = 0;\n    }\n    else if (type == \"two_nonzeros_ab\") {\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        c = 0;\n    }\n    else if (type == \"two_nonzeros_ac\") {\n        a = rnd.next(1, 1000);\n        b = 0;\n        c = rnd.next(1, 1000);\n    }\n    else if (type == \"two_nonzeros_bc\") {\n        a = 0;\n        b = rnd.next(1, 1000);\n        c = rnd.next(1, 1000);\n    }\n    else {\n        // default to random\n        a = rnd.next(0, 1000);\n        b = rnd.next(0, 1000);\n        c = rnd.next(0, 1000);\n    }\n\n    // Output\n    printf(\"%d\\n\", S);\n    printf(\"%d %d %d\\n\", a, b, c);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int S = opt<int>(\"S\", rnd.next(1, 1000));\n    string type = opt<string>(\"type\", \"random\");\n\n    int a, b, c;\n    if (type == \"random\") {\n        a = rnd.next(0, 1000);\n        b = rnd.next(0, 1000);\n        c = rnd.next(0, 1000);\n    }\n    else if (type == \"exponents_zero\") {\n        a = 0;\n        b = 0;\n        c = 0;\n    }\n    else if (type == \"exponents_max\") {\n        a = 1000;\n        b = 1000;\n        c = 1000;\n    }\n    else if (type == \"one_zero\") {\n        int zero_pos = rnd.next(0, 2);\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        c = rnd.next(1, 1000);\n        if (zero_pos == 0) a = 0;\n        else if (zero_pos == 1) b = 0;\n        else c = 0;\n    }\n    else if (type == \"two_zero\") {\n        vector<int> positions = {0,1,2};\n        shuffle(positions.begin(), positions.end());\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        c = rnd.next(1, 1000);\n        int zero1 = positions[0];\n        int zero2 = positions[1];\n        if (zero1 == 0 || zero2 == 0) a = 0;\n        if (zero1 == 1 || zero2 == 1) b = 0;\n        if (zero1 == 2 || zero2 == 2) c = 0;\n    }\n    else if (type == \"exponents_large_small\") {\n        a = rnd.next(0, 1) * 1000; // Either 0 or 1000\n        b = rnd.next(0, 1) * 1000;\n        c = rnd.next(0, 1) * 1000;\n        if (a == 0 && b == 0 && c == 0) {\n            int non_zero_pos = rnd.next(0,2);\n            if (non_zero_pos == 0) a = 1000;\n            else if (non_zero_pos == 1) b = 1000;\n            else c = 1000;\n        }\n    }\n    else if (type == \"S_min\") {\n        S = 1;\n        a = rnd.next(0, 1000);\n        b = rnd.next(0, 1000);\n        c = rnd.next(0, 1000);\n    }\n    else if (type == \"S_max\") {\n        S = 1000;\n        a = rnd.next(0, 1000);\n        b = rnd.next(0, 1000);\n        c = rnd.next(0, 1000);\n    }\n    else if (type == \"only_a_nonzero\") {\n        a = rnd.next(1, 1000);\n        b = 0;\n        c = 0;\n    }\n    else if (type == \"only_b_nonzero\") {\n        b = rnd.next(1, 1000);\n        a = 0;\n        c = 0;\n    }\n    else if (type == \"only_c_nonzero\") {\n        c = rnd.next(1, 1000);\n        a = 0;\n        b = 0;\n    }\n    else if (type == \"two_nonzeros_ab\") {\n        a = rnd.next(1, 1000);\n        b = rnd.next(1, 1000);\n        c = 0;\n    }\n    else if (type == \"two_nonzeros_ac\") {\n        a = rnd.next(1, 1000);\n        b = 0;\n        c = rnd.next(1, 1000);\n    }\n    else if (type == \"two_nonzeros_bc\") {\n        a = 0;\n        b = rnd.next(1, 1000);\n        c = rnd.next(1, 1000);\n    }\n    else {\n        // default to random\n        a = rnd.next(0, 1000);\n        b = rnd.next(0, 1000);\n        c = rnd.next(0, 1000);\n    }\n\n    // Output\n    printf(\"%d\\n\", S);\n    printf(\"%d %d %d\\n\", a, b, c);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type exponents_zero\n./gen -type exponents_max\n./gen -type one_zero\n./gen -type two_zero\n./gen -type exponents_large_small\n./gen -type S_min\n./gen -type S_max\n./gen -type only_a_nonzero\n./gen -type only_b_nonzero\n./gen -type only_c_nonzero\n./gen -type two_nonzeros_ab\n./gen -type two_nonzeros_ac\n./gen -type two_nonzeros_bc\n./gen -S 1 -type only_a_nonzero\n./gen -S 1 -type only_b_nonzero\n./gen -S 1 -type only_c_nonzero\n./gen -S 1 -type exponents_zero\n./gen -S 1 -type exponents_max\n./gen -S 1000 -type only_a_nonzero\n./gen -S 1000 -type only_b_nonzero\n./gen -S 1000 -type only_c_nonzero\n./gen -S 1000 -type exponents_zero\n./gen -S 1000 -type exponents_max\n./gen -S 500 -type exponents_zero\n./gen -S 500 -type exponents_max\n./gen -S 500 -type random\n./gen -S 2 -type one_zero\n./gen -S 2 -type two_zero\n./gen -S 999 -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:29.589865",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "186/E",
      "title": "E. Clever Fat Rat",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 50) — the number of rows with scales.The next line contains n space-separated integers ai (1 ≤ ai ≤ 106) — the masses of the oats in kilograms.The next n lines contain descriptions of the scales: the i-th line contains (n - i + 1) space-separated integers wi, k (1 ≤ wi, k ≤ 106) — the weight capacity parameters for the scales that stand on the i-th row, in kilograms.",
      "output_spec": "OutputPrint \"Fat Rat\" if the Fat Rat is right, otherwise print \"Cerealguy\".",
      "sample_tests": "ExamplesInputCopy112OutputCopyFat RatInputCopy22 21 24OutputCopyCerealguyInputCopy22 21 25OutputCopyFat Rat",
      "description": "E. Clever Fat Rat\n\ntime limit per test2.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 50) — the number of rows with scales.The next line contains n space-separated integers ai (1 ≤ ai ≤ 106) — the masses of the oats in kilograms.The next n lines contain descriptions of the scales: the i-th line contains (n - i + 1) space-separated integers wi, k (1 ≤ wi, k ≤ 106) — the weight capacity parameters for the scales that stand on the i-th row, in kilograms.\n\nOutputPrint \"Fat Rat\" if the Fat Rat is right, otherwise print \"Cerealguy\".\n\nInputCopy112OutputCopyFat RatInputCopy22 21 24OutputCopyCerealguyInputCopy22 21 25OutputCopyFat Rat\n\nInputCopy112\n\nOutputCopyFat Rat\n\nInputCopy22 21 24\n\nOutputCopyCerealguy\n\nInputCopy22 21 25\n\nOutputCopyFat Rat\n\nNoteNotes to the examples:   The first example: the scale with weight capacity 2 gets 1. That means that the lower scale don't break.  The second sample: all scales in the top row obviously break. Then the oats fall on the lower row. Their total mass is 4,and that's exactly the weight that the lower scale can \"nearly endure\". So, as 4  ≥  4, the scale breaks.",
      "solutions": [
        {
          "title": "Codeforces Round #118 - Codeforces",
          "content": "Hello everybody! There is less than 3 hours before my second codeforces round, in which I participating as author. (The first one was — Codeforces Beta Round 56.) It will be llok like the previous one. (That was not bad, I wish. :-)!) I wish, you like today's contest.I'm the author of this round, except one problem, which was proposed by Gerald.In preparing this round was participating : Gerald (He always makes problems better.), cerealguy (Who helps in preparing, i think, the hardest problem of this round. He had solved the first version of round — and think, that it's easy.), Delinur (Who translate the problems). And also it was done with help of \"Polygon\" and \"Codeforces\".I wish, you luck in this contest and to have high rating.Problem scores will be as always. I wish, that problems are sorted well.UPD: I'm very bad man, and have written wrong solution in problem \"C\". Problem under investigation.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 912
        },
        {
          "title": "Editorial for Round #118 - Codeforces",
          "content": "No problem was specially taken from \"Wikipedia\". For me it's really hard to understand, that problem \"B\" was there.A (Div 2). (Idea : Gerald, realization : Aksenov239, code : 1670635)If the lengths of 2 strings aren't equal — that means \"NO\". We try to find the positions in strings, where chars are different. If there 1 or more than 2 such positions — \"NO\". After that we swap 2 characters in the first string, and check for their equality.B (Div 2). (Idea : Aksenov239, realization : Aksenov239, code : 1670637) We can see, that we can do all in integers, because k is integer number of percent. For each dwarf we should find his optimal strategy — to check 2 strategies with speed. We should sort them. A (Div 1). (Idea : Aksenov239, realization : Aksenov239, code : 1652592) Let's propose, that after the i-th year, there is x triangles up and y triangles down. After another iteration we can see, that amount of triangles became — 3x + y up and x + 3y down. Let's see the difference between them: at the i-th it's x - y and at the i + 1-th — it's (3x + y) - (x + 3y) = 2 * (x - y). We can see, that difference between amount of triangles grown up by 2. Because on the i-th year the difference became 2i and all amount of triangles is 4i. We can see, that on the i-th year the number of our triangles is . That can be computed by modulo p using the fast-power algorithm.B (Div 1). (Idea : Aksenov239, realization : Aksenov239, code : 1652597) This problem was made by my love to inequalities. :-)! The answer for this problem is .Prove: . (This is AM-GM inequality. Link for whom don't know it.)The equality becomes only, when .And you should check on zeroes. If a = b = c = 0 — you can choose any good answer — x + y + z ≤ S.C (Div 1). No comments. :-)!D (Div 1). (Idea : Aksenov239, realization : cerealguy, Gerald, Aksenov239, code : 1652604)This is number theory problem.I'm trying to explain it step by step:1) Let's prove, that LCD is maximum 2.Let . Squaring both sides we get , but we want to . This means, that d can be only 2.2) Let's make this lenghty product simplier..We can count this by modulo p fast, and divide it by 2r - l, if k is odd.3) There is many interesting things in this solution.Firstly, it doesn't work, when p = 2 — but it can easily done by you.The other problem is harder, what if , this means that for each i ≥ l : , and this mean,that for each i ≥ l : k2i + 1 ≡ p2. And the product by modulo p is equal to 2r - l + 1.E (Div. 1) (Idea : Aksenov239, relization : cerealguy, code : 1652611)This problem wasn't taken to ROI, because of that I gave it here. This is pretty hard problem. I can't now realize, what cerealguy wrote, but his solution is O(nlogn) — without binary search. For me it's quite hard to understand, because my first solution was with binary search. And there were solutions, that has a worse asymptothic, but they run faster.Because of that I can only give you key ideas, that can help you. (afterwards you can see the code of cerealguy)Ideas: Let's find for each person the nearest subway point for them. It can be done in nlogn with use of segment tree or something else. We can see, that if one person goes to subway, the others, which distance to subway is smaller, can go to subway too — it doesn't affect the answer. Because of that we sort all persons by their distanse to subway. The area of the person, where he can come in t seconds, is romb. And we can intersect all rombes in O(n) — the intersection is like rectangle. Let's make the first intersection. When nobody goes to subway. We get a rectangle. The main idea, that for this rectangle — the nearest subway becomes always the same. We go throught people in sorted order, we can fast recalculate this small rectangle — and because of that we can fast recalculate the answer. And we get a solution in O(nlogn) time. Ta-dams.Thank you all for your attention. I'm deeply sorry about the problem \"C\".",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4488",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3919
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #118 - Codeforces - Code 1",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 2",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 3",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 4",
          "code": "s/(a+b+c)\n= (a(x/a)+b(y/b)+c(z/c))/(a+b+c)\n>= ((x/a)^a*(y/b)^b*(z/c)^c)^(1/(a+b+c))\n= (x^a*y^b*z^c)^(1/(a+b+c))/(a^a*b^b*c^c)^(1/(a+b+c))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 5",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 6",
          "code": "6\n1 1 2 2 1 1\n1 1 2 2 1 1\n2 4 2 4 2\n2 2 2 2\n4 10 4\n4 4\n8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 7",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 8",
          "code": "2 0 2 2 2\n| | | | |\n2 4 2 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 9",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 10",
          "code": "6\n1 1 1 1 1 1\n1 9 1 1 9 1\n 1 9 1 9 1\n  1 1 1 1\n   2 9 2\n    2 2\n     4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 11",
          "code": "3 4 1\n\n 3 5\n\n  8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 12",
          "code": "(a+b)/2 >= sqrt(a*b)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 13",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 14",
          "code": "Test: #7, time: 30 ms., memory: 1384 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n7\n8 2 2\nOutput\n4.666666667 1.166666667 1.166666667\nAnswer\n4.666666666666667 1.1666666666666667 1.1666666666666667\nChecker Log\nwrong answer X+Y+Z should be <= S. Found 7.0000000010.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #118 - Codeforces - Code 15",
          "code": "cin >> S >> a >> b >> c;\n\nif(a == 0 && b == 0 && c == 0){\n    printf(\"0.0 0.0 0.0\\n\");\n    return 0;\n}\n\ndouble x = a / (double)(a + b + c) * S;\ndouble y = b / (double)(a + b + c) * S;\ndouble z = c / (double)(a + b + c) * S;\nprintf(\"%.20f %.20f %.20f\\n\", x, y, z);\n\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n    for (int i = 1; i <= n; ++i) {\n        int num_w = n - i + 1;\n        vector<int> w = inf.readInts(num_w, 1, 1000000, \"w_{i,k}\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n    for (int i = 1; i <= n; ++i) {\n        int num_w = n - i + 1;\n        vector<int> w = inf.readInts(num_w, 1, 1000000, \"w_{i,k}\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n    for (int i = 1; i <= n; ++i) {\n        int num_w = n - i + 1;\n        vector<int> w = inf.readInts(num_w, 1, 1000000, \"w_{i,k}\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n    vector<vector<int>> w(n);\n\n    const int MIN_A = 1;\n    const int MAX_A = 1000000;\n    const int MIN_W = 1;\n    const int MAX_W = 1000000;\n\n    if (type == \"FatRat\") {\n        // For Fat Rat, make scales unbreakable\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(MIN_A, MIN_A + 10); // Small masses\n        }\n        for (int i = 0; i < n; ++i) {\n            int num_scales = n - i;\n            vector<int> row(num_scales, MAX_W); // Max capacity, scales won't break\n            w[i] = row;\n        }\n    } else if (type == \"Cerealguy\") {\n        // For Cerealguy, make a path where scales break\n        ai[0] = MAX_A; // Max mass on the first scale\n        for (int i = 1; i < n; ++i) {\n            ai[i] = 0;\n        }\n        for (int i = 0; i < n; ++i) {\n            int num_scales = n - i;\n            vector<int> row(num_scales, MAX_W);\n            row[0] = MIN_W; // Scales along the leftmost path will break\n            w[i] = row;\n        }\n    } else {\n        // Random data\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(MIN_A, MAX_A);\n        }\n        for (int i = 0; i < n; ++i) {\n            int num_scales = n - i;\n            vector<int> row(num_scales);\n            for (int k = 0; k < num_scales; ++k) {\n                row[k] = rnd.next(MIN_W, MAX_W);\n            }\n            w[i] = row;\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i + 1 != n) printf(\" \");\n        else printf(\"\\n\");\n    }\n    for (int i = 0; i < n; ++i) {\n        int num_scales = n - i;\n        for (int k = 0; k < num_scales; ++k) {\n            printf(\"%d\", w[i][k]);\n            if (k + 1 != num_scales) printf(\" \");\n            else printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n    vector<vector<int>> w(n);\n\n    const int MIN_A = 1;\n    const int MAX_A = 1000000;\n    const int MIN_W = 1;\n    const int MAX_W = 1000000;\n\n    if (type == \"FatRat\") {\n        // For Fat Rat, make scales unbreakable\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(MIN_A, MIN_A + 10); // Small masses\n        }\n        for (int i = 0; i < n; ++i) {\n            int num_scales = n - i;\n            vector<int> row(num_scales, MAX_W); // Max capacity, scales won't break\n            w[i] = row;\n        }\n    } else if (type == \"Cerealguy\") {\n        // For Cerealguy, make a path where scales break\n        ai[0] = MAX_A; // Max mass on the first scale\n        for (int i = 1; i < n; ++i) {\n            ai[i] = 0;\n        }\n        for (int i = 0; i < n; ++i) {\n            int num_scales = n - i;\n            vector<int> row(num_scales, MAX_W);\n            row[0] = MIN_W; // Scales along the leftmost path will break\n            w[i] = row;\n        }\n    } else {\n        // Random data\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(MIN_A, MAX_A);\n        }\n        for (int i = 0; i < n; ++i) {\n            int num_scales = n - i;\n            vector<int> row(num_scales);\n            for (int k = 0; k < num_scales; ++k) {\n                row[k] = rnd.next(MIN_W, MAX_W);\n            }\n            w[i] = row;\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i + 1 != n) printf(\" \");\n        else printf(\"\\n\");\n    }\n    for (int i = 0; i < n; ++i) {\n        int num_scales = n - i;\n        for (int k = 0; k < num_scales; ++k) {\n            printf(\"%d\", w[i][k]);\n            if (k + 1 != num_scales) printf(\" \");\n            else printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type FatRat\n./gen -n 1 -type Cerealguy\n./gen -n 1 -type random\n\n./gen -n 2 -type FatRat\n./gen -n 2 -type Cerealguy\n./gen -n 2 -type random\n\n./gen -n 5 -type FatRat\n./gen -n 5 -type Cerealguy\n./gen -n 5 -type random\n\n./gen -n 10 -type FatRat\n./gen -n 10 -type Cerealguy\n./gen -n 10 -type random\n\n./gen -n 20 -type FatRat\n./gen -n 20 -type Cerealguy\n./gen -n 20 -type random\n\n./gen -n 30 -type FatRat\n./gen -n 30 -type Cerealguy\n./gen -n 30 -type random\n\n./gen -n 40 -type FatRat\n./gen -n 40 -type Cerealguy\n./gen -n 40 -type random\n\n./gen -n 50 -type FatRat\n./gen -n 50 -type Cerealguy\n./gen -n 50 -type random\n\n# Additional random cases\n./gen -n 25 -type random\n./gen -n 35 -type random\n./gen -n 45 -type random\n\n# Edge cases with minimal and maximal n\n./gen -n 1 -type random\n./gen -n 50 -type random\n\n# Random cases with n ranging from 1 to 50\nfor n in {1..50}; do ./gen -n $n -type random; done\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:31.626556",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "187/A",
      "title": "A. Permutations",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 2·105) — the quantity of the numbers in the both given permutations. Next line contains n space-separated integers — the first permutation. Each number between 1 to n will appear in the permutation exactly once. Next line describe the second permutation in the same format.",
      "output_spec": "OutputPrint a single integer denoting the minimum number of moves required to convert the first permutation to the second.",
      "sample_tests": "ExamplesInputCopy33 2 11 2 3OutputCopy2InputCopy51 2 3 4 51 5 2 3 4OutputCopy1InputCopy51 5 2 3 41 2 3 4 5OutputCopy3",
      "description": "A. Permutations\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 2·105) — the quantity of the numbers in the both given permutations. Next line contains n space-separated integers — the first permutation. Each number between 1 to n will appear in the permutation exactly once. Next line describe the second permutation in the same format.\n\nOutputPrint a single integer denoting the minimum number of moves required to convert the first permutation to the second.\n\nInputCopy33 2 11 2 3OutputCopy2InputCopy51 2 3 4 51 5 2 3 4OutputCopy1InputCopy51 5 2 3 41 2 3 4 5OutputCopy3\n\nInputCopy33 2 11 2 3\n\nOutputCopy2\n\nInputCopy51 2 3 4 51 5 2 3 4\n\nOutputCopy1\n\nInputCopy51 5 2 3 41 2 3 4 5\n\nOutputCopy3\n\nNoteIn the first sample, he removes number 1 from end of the list and places it at the beginning. After that he takes number 2 and places it between 1 and 3.In the second sample, he removes number 5 and inserts it after 1.In the third sample, the sequence of changes are like this:  1 5 2 3 4 1 4 5 2 3 1 3 4 5 2 1 2 3 4 5  So he needs three moves.",
      "solutions": [
        {
          "title": "Codeforces Round #119 - Codeforces",
          "content": "Hello everyone,We are glad to invite you to participate in today’s round. Problems have been prepared by poopi, Mohammad_JRS, Gerald and me. The hero of our contest is called “PMP”. It is actually the base of our team name through the last five years. The stories are metaphoric, but they have some traces in truth.This Codeforces round, is the last round before the incoming ICPC world final. Our best wishes for all participants of that contest, too. I want to specially thank Gerald for his helps and advices in problem preparation, Delinur for translation of statements into Russian and MikeMirzayanov for this great system.And we have a modified version of Burunduk1 ’s advice: “to make the round even more interesting for us, read the statements of ALL problems.” :)We hope you enjoy the problems and have high ratings.Update: Contest is over. Thanks to everyone for taking part and congratulations to the winners of both divisions, specially peter50216 for being the only who solved all the problems of division 1! :)Update: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4520",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1041
        },
        {
          "title": "Codeforces Round #119 — Editorial - Codeforces",
          "content": "Problem 189A — Cut RibbonThe problem is to maximize x+y+z subject to ax+by+cz=n. Constraints are low, so simply iterate over two variables (say x and y) and find the third variable (if any) from the second equation. Find the maximum over all feasible solutions.Other approaches: Use dynamic programming with each state being the remainder of ribbon. Select the next piece to be a, b or c.Problem 189B — Counting RhombiObserve that lots of rhombi have the same shape, but are in different locations. What uniquely determines the shape of a rhombus? Its width and its height. Is it possible to build a rhombus with every width and every height such that the vertices of the rhombus are in integer points? No, it is possible only if the width and the height are both even.How many places we can put a rhombus of width w0 and height h0 in a rectangle of width w and height h? (w * w0 + 1)(h * h0 + 1)So, iterator over all even widths and heights and for each of them add the number of possible locations to the final result.Problem 187A — PermutationsIt is easy to see that if we replace each number in the first permutation with position of that number in the second permutation, the problem reduces to sorting the first permutation.Each time we take a number from the end of array, we can postpone its insertion until we know the most suitable position for insertion. Note that it is not good to insert a number and take it again, as we could make a better decision first time we took the number. So, as long as the remainder of the array is not in increasing order, we should take more numbers from the end. But as soon as you have an increasing subsequence, you can insert the numbers you have taken to make the array sorted. Therefore to solve the problem, we find the largest i such the numbers from 1 to i are in increasing order. The answer would be n-i.Problem 187B — AlgoRaceFirst we solve the problem when the number of allowed car changes is zero (_k=0_). Let W(i,j,l) be the length of shortest path from i to j with car l. We use Floyd-Warshal on graph of each car to find this value. Then answer for the case that we can use only one car for each pair of cities i and j is:ans(0,i,j) = min W(i,j,l) for (_1≤l≤m_)This part has time complexity O(m*n^3).For larger values of maximum number of changes (_k_), we use the following equation:ans(k,i,j) = min (ans(k-1,i,l)+ans(0,l,j)) for (_1≤l≤k_)which can be computed in O(k*n^3) using dynamic programming.But how large can be k in worst case? We know that shortest paths are simple paths (i.e. they have no repeated vertices). Because otherwise we could eliminate the path we go between two appearances of one vertex and have a smaller result. This and the fact that we change the car at most once in each vertex, guarantees in any optimal solution we will not need more that n car changes. Thus the order of the solution would be O(m*n^3+n^4).Problem 187C — Weak MemoryThere were many different correct approaches to this problem during the contest. But I will explain author’s solution.First we can use binary search over the value of q. Now for a fixed q we want to check s-t connectivity.Let K be the set of all intersections with volunteers union s and t. One can use BFS from each k∈K, one by one. Then build a graph G’ with vertices K. For each two vertices k1,k2∈K add an edge between them, if their shortest distance is less than or equal to q. Finally use any path finding algorithm to check the connectivity. Unfortunately this solution has time (and space) complexity of O(|K|*m) which is not good enough.We can optimize the above solution by initiating BFS from all k∈K at once. In other words during the initialization step in BFS algorithm, we push all these vertices in the queue with distance 0. Each element in the queue also maintains its source (i.e. the source it is originating from). In BFS each time we have have a vertex u with source su and we want to set the minimum distance to a vertex v that is already set from a different path with source sv, we connect su and sv in G’ if d(u)+d(v)+1<= q, where d(x) denotes length of the shortest path from a vertex in K to x. As we are only dealing with connectivity, this approach is correct. (Proof of correctness is left as an exercise)BFS takes O(m) time and we add at most O(m) edges to G’, so the overall complexity is O(m) for a fixed q. As we used binary search to find the smallest q, we can solve the problem in O(m*logn).Problem 187D — BRT ContractWe define ti as follows: assume a bus starts moving from i-th intersection exactly at the time when the light changes to green. The time it takes for the bus to get the final station is ti. We call the times when a green interval begins t0 (so every g+r seconds t0 occurs once)If a bus gets to i-th intersection during the red phase, it should wait and then start moving at t0. So considering the fact that all lights are synchronized (and length of segments are fixed) if we have ti for i-th intersection, we can compute the time for the bus to get final station.Clearly tn is the length of the last segments. For computing ti we should find the smallest j such that if a bus starts at t0 from i-th intersection, it gets to j-th intersection during the red phase. So we have:ti=tj+d(i,j)+wwhere d(i,j) is the distance between i-th and j-th intersections and w is the time that the bus should wait behind the red light at j-th intersection. The later value can be computed easily.The only problem that remains is to find j for i-th intersection. So we start iterating over i for (n-1)-th intersection backwards and we compute ti for all intersections. Assume p=g+r and ta=d(i,j)%p. Now if the bus starts from i-th intersection at time t0 and we have ta>=g, in this case we are in red phase at j-th intersection. Actually ta should be in interval [_g, g+r_). Here we can use segment trees. That is for all intersections from i+1 to n, we store some values in the tree that helps us find the smallest j. But we should note the value of ta depends on d(i,j) which changes as i changes. Thus we cannot use ta in the tree. Instead, we define si the be the distance of i-th intersection to the destination. So we have d(i,j)=si-sj and we use the value of sj with storing –sj%p in the segment tree as the key and the value would be j itself. In other words for each intersection we store the key-value pair (-sj%p, j) in the tree. According to what we said so far, to be in the red phase at j-th intersection we should have:ta=(d(i,j)%p)=((si-sj)%p)∈[g,g+r) => -sj%p ∈ [(g-si)%p, (g+r-si)%p)As we stored –sj%p in the tree, we can retrieve the smallest j in the above interval with a query in the segment tree. This way we can compute ti for all intersections. Answering to each query in the problem can be solve in exactly the same way. So the overall complexity would be O((n+q)logn).Problem 187E — Heaven TourStep 1. Solve the problem if the starting man is the leftmost man and the finishing man is the rightmost man.Obviously every segment (the distance between two consecutive men) should be covered at least once. We also argue that at least l (the number of left tickets) segments should be covered at least three times. Proof: Each time you use a left ticket to go to man i with 1<i<n-1, the segment between i-th and (_i+1_)-th men is covered at least three times: Once for you should go after i be in a position to come back. Once for you use a left ticked to come back to i And once again you should go after i, because you want to finish at man number n Note that in the first and the last segments are always covered once, no matter what we do. But except for these two segments, every other segment can be chosen to be among the segments that are covered three times, and every combination that we choose l segments is feasible. (Proof it as practice) So we choose the smallest l segments and the problem can be solved with a simple sort in O(n*logn).Step 2. Solve the problem if the starting man is the leftmost man, but the finishing man can be anywhere.To solve this problem we first fix the finishing man. With reasoning similar to that of step 1, we conclude that at least l segments should be covered with at least two times if they are after the finishing man or three times if they are before him. But obviously every segment after the finishing man is covered at least two times. So it is always good to waste as many left tickets as possible after the finishing man to prevent them from breaching the left side of finishing man and becoming multiple three.So the algorithm would be: iterate over i, the number of finishing man, and maintain the l-(n-i) smallest segments to the right of finishing man as you progress. This can be implemented in O(n*logn).Step 3. Solve the problem if the starting man is fixed, but the finishing man can be anywhere.Assume that the starting man is not the first man or the last man, otherwise we could use algorithm of step 2 to solve the problem. Without loss of generality assume that you finish your tour to the right side of finishing man. Therefore every segment to the left of starting man is covered at least two times and actually it is always possible to arrange visits such that every segment to right is covered exactly two times. So just like what we said in step 2, it is good to waste as many left tickets as possible in this area.So the algorithm would be, choose to finish left or right first, then greedily waste as many bad moves (by bad moves I mean the moves that if breach to the other side will be more costly) as possible there and follow the algorithm in step 2 to solve the whole problem.There are some special cases such as when the tour cannot be finished at all, that we left to readers find a way how to handle them.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4540",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 187\\s*A"
          },
          "content_length": 9777
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #119 - Codeforces - Code 1",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 2",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 3",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 4",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 5",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 6",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    // Read first permutation\n    vector<int> perm1 = inf.readInts(n, 1, n, \"perm1\");\n    inf.readEoln();\n\n    // Check if perm1 is a valid permutation\n    set<int> s1(perm1.begin(), perm1.end());\n    ensuref((int)s1.size() == n, \"First permutation is not a valid permutation\");\n\n    // Read second permutation\n    vector<int> perm2 = inf.readInts(n, 1, n, \"perm2\");\n    inf.readEoln();\n\n    // Check if perm2 is a valid permutation\n    set<int> s2(perm2.begin(), perm2.end());\n    ensuref((int)s2.size() == n, \"Second permutation is not a valid permutation\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    // Read first permutation\n    vector<int> perm1 = inf.readInts(n, 1, n, \"perm1\");\n    inf.readEoln();\n\n    // Check if perm1 is a valid permutation\n    set<int> s1(perm1.begin(), perm1.end());\n    ensuref((int)s1.size() == n, \"First permutation is not a valid permutation\");\n\n    // Read second permutation\n    vector<int> perm2 = inf.readInts(n, 1, n, \"perm2\");\n    inf.readEoln();\n\n    // Check if perm2 is a valid permutation\n    set<int> s2(perm2.begin(), perm2.end());\n    ensuref((int)s2.size() == n, \"Second permutation is not a valid permutation\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    // Read first permutation\n    vector<int> perm1 = inf.readInts(n, 1, n, \"perm1\");\n    inf.readEoln();\n\n    // Check if perm1 is a valid permutation\n    set<int> s1(perm1.begin(), perm1.end());\n    ensuref((int)s1.size() == n, \"First permutation is not a valid permutation\");\n\n    // Read second permutation\n    vector<int> perm2 = inf.readInts(n, 1, n, \"perm2\");\n    inf.readEoln();\n\n    // Check if perm2 is a valid permutation\n    set<int> s2(perm2.begin(), perm2.end());\n    ensuref((int)s2.size() == n, \"Second permutation is not a valid permutation\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> perm1(n);\n    vector<int> perm2(n);\n    for (int i = 0; i < n; ++i)\n        perm1[i] = i + 1;\n    if (type == \"random\") {\n        // Random permutations\n        shuffle(perm1.begin(), perm1.end());\n        perm2 = perm1;\n        shuffle(perm2.begin(), perm2.end());\n    } else if (type == \"sorted\") {\n        // Both permutations sorted\n        perm2 = perm1;\n    } else if (type == \"reversed\") {\n        // First permutation sorted, second reversed\n        perm2 = perm1;\n        reverse(perm2.begin(), perm2.end());\n    } else if (type == \"shifted\") {\n        int k = opt<int>(\"k\", 1);\n        if (k >= n) k %= n;\n        perm2 = perm1;\n        rotate(perm2.begin(), perm2.begin() + k, perm2.end());\n    } else if (type == \"matching_suffix\") {\n        int len = opt<int>(\"len\", 0);\n        if (len > n) len = n;\n        vector<int> suffix(len);\n        vector<int> rest(n - len);\n        for (int i = 0; i < n; ++i) {\n            if (i < n - len) rest[i] = i + 1;\n            else suffix[i - (n - len)] = i + 1;\n        }\n        shuffle(rest.begin(), rest.end());\n        vector<int> perm1_rest = rest;\n        vector<int> perm2_rest = rest;\n        shuffle(perm2_rest.begin(), perm2_rest.end());\n        perm1.assign(perm1_rest.begin(), perm1_rest.end());\n        perm1.insert(perm1.end(), suffix.begin(), suffix.end());\n        perm2.assign(perm2_rest.begin(), perm2_rest.end());\n        perm2.insert(perm2.end(), suffix.begin(), suffix.end());\n    } else if (type == \"matching_prefix\") {\n        int len = opt<int>(\"len\", 0);\n        if (len > n) len = n;\n        vector<int> prefix(len);\n        vector<int> rest(n - len);\n        for (int i = 0; i < n; ++i) {\n            if (i < len) prefix[i] = i + 1;\n            else rest[i - len] = i + 1;\n        }\n        shuffle(rest.begin(), rest.end());\n        vector<int> perm1_rest = rest;\n        vector<int> perm2_rest = rest;\n        shuffle(perm2_rest.begin(), perm2_rest.end());\n        perm1.assign(prefix.begin(), prefix.end());\n        perm1.insert(perm1.end(), perm1_rest.begin(), perm1_rest.end());\n        perm2.assign(prefix.begin(), prefix.end());\n        perm2.insert(perm2.end(), perm2_rest.begin(), perm2_rest.end());\n    } else if (type == \"max_moves\") {\n        // Generate permutations that require maximum moves\n        perm2 = perm1;\n        shuffle(perm2.begin(), perm2.end());\n    } else if (type == \"min_moves\") {\n        // Generate permutations that require minimal moves\n        perm2 = perm1;\n    } else {\n        // Default to random\n        shuffle(perm1.begin(), perm1.end());\n        perm2 = perm1;\n        shuffle(perm2.begin(), perm2.end());\n    }\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output perm1\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", perm1[i], i + 1 == n ? '\\n' : ' ');\n    // Output perm2\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", perm2[i], i + 1 == n ? '\\n' : ' ');\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> perm1(n);\n    vector<int> perm2(n);\n    for (int i = 0; i < n; ++i)\n        perm1[i] = i + 1;\n    if (type == \"random\") {\n        // Random permutations\n        shuffle(perm1.begin(), perm1.end());\n        perm2 = perm1;\n        shuffle(perm2.begin(), perm2.end());\n    } else if (type == \"sorted\") {\n        // Both permutations sorted\n        perm2 = perm1;\n    } else if (type == \"reversed\") {\n        // First permutation sorted, second reversed\n        perm2 = perm1;\n        reverse(perm2.begin(), perm2.end());\n    } else if (type == \"shifted\") {\n        int k = opt<int>(\"k\", 1);\n        if (k >= n) k %= n;\n        perm2 = perm1;\n        rotate(perm2.begin(), perm2.begin() + k, perm2.end());\n    } else if (type == \"matching_suffix\") {\n        int len = opt<int>(\"len\", 0);\n        if (len > n) len = n;\n        vector<int> suffix(len);\n        vector<int> rest(n - len);\n        for (int i = 0; i < n; ++i) {\n            if (i < n - len) rest[i] = i + 1;\n            else suffix[i - (n - len)] = i + 1;\n        }\n        shuffle(rest.begin(), rest.end());\n        vector<int> perm1_rest = rest;\n        vector<int> perm2_rest = rest;\n        shuffle(perm2_rest.begin(), perm2_rest.end());\n        perm1.assign(perm1_rest.begin(), perm1_rest.end());\n        perm1.insert(perm1.end(), suffix.begin(), suffix.end());\n        perm2.assign(perm2_rest.begin(), perm2_rest.end());\n        perm2.insert(perm2.end(), suffix.begin(), suffix.end());\n    } else if (type == \"matching_prefix\") {\n        int len = opt<int>(\"len\", 0);\n        if (len > n) len = n;\n        vector<int> prefix(len);\n        vector<int> rest(n - len);\n        for (int i = 0; i < n; ++i) {\n            if (i < len) prefix[i] = i + 1;\n            else rest[i - len] = i + 1;\n        }\n        shuffle(rest.begin(), rest.end());\n        vector<int> perm1_rest = rest;\n        vector<int> perm2_rest = rest;\n        shuffle(perm2_rest.begin(), perm2_rest.end());\n        perm1.assign(prefix.begin(), prefix.end());\n        perm1.insert(perm1.end(), perm1_rest.begin(), perm1_rest.end());\n        perm2.assign(prefix.begin(), prefix.end());\n        perm2.insert(perm2.end(), perm2_rest.begin(), perm2_rest.end());\n    } else if (type == \"max_moves\") {\n        // Generate permutations that require maximum moves\n        perm2 = perm1;\n        shuffle(perm2.begin(), perm2.end());\n    } else if (type == \"min_moves\") {\n        // Generate permutations that require minimal moves\n        perm2 = perm1;\n    } else {\n        // Default to random\n        shuffle(perm1.begin(), perm1.end());\n        perm2 = perm1;\n        shuffle(perm2.begin(), perm2.end());\n    }\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output perm1\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", perm1[i], i + 1 == n ? '\\n' : ' ');\n    // Output perm2\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", perm2[i], i + 1 == n ? '\\n' : ' ');\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n tests\n./gen -n 1 -type min_moves\n./gen -n 1 -type max_moves\n./gen -n 2 -type random\n./gen -n 2 -type shifted -k 1\n./gen -n 10 -type sorted\n./gen -n 10 -type reversed\n./gen -n 10 -type matching_suffix -len 0\n./gen -n 10 -type matching_suffix -len 10\n./gen -n 10 -type matching_prefix -len 1\n./gen -n 10 -type matching_prefix -len 9\n# Medium n tests\n./gen -n 1000 -type random\n./gen -n 1000 -type shifted -k 500\n./gen -n 1000 -type matching_suffix -len 0\n./gen -n 1000 -type matching_suffix -len 1000\n./gen -n 1000 -type matching_prefix -len 1\n./gen -n 1000 -type matching_prefix -len 999\n./gen -n 1000 -type max_moves\n./gen -n 1000 -type min_moves\n# Large n tests\n./gen -n 200000 -type random\n./gen -n 200000 -type shifted -k 100000\n./gen -n 200000 -type matching_suffix -len 0\n./gen -n 200000 -type matching_suffix -len 200000\n./gen -n 200000 -type matching_prefix -len 1\n./gen -n 200000 -type matching_prefix -len 199999\n./gen -n 200000 -type max_moves\n./gen -n 200000 -type min_moves\n./gen -n 200000 -type matching_suffix -len 100000\n./gen -n 200000 -type matching_prefix -len 100000\n# Random large n tests\n./gen -n 200000 -type random\n./gen -n 200000 -type random\n# Shifted tests\n./gen -n 200000 -type shifted -k 1\n./gen -n 200000 -type shifted -k 199999\n# Edge case n=1\n./gen -n 1 -type random\n./gen -n 1 -type shifted -k 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:33.753808",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "187/B",
      "title": "B. AlgoRace",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers n, m, r (2 ≤ n ≤ 60, 1 ≤ m ≤ 60, 1 ≤ r ≤ 105) — the number of cities, the number of different types of cars and the number of rounds in the competition, correspondingly.Next m sets of n × n matrices of integers between 0 to 106 (inclusive) will follow — describing the time one car requires to traverse different roads. The k-th integer in j-th line of the i-th set is the time that i-th car requires to traverse the road from j-th city to k-th city. These matrices are not necessarily symmetric, but their diagonal is always zero.Next r lines contain description of the rounds. The i-th of these lines contains space-separated integers si, ti, ki (1 ≤ si, ti ≤ n, si ≠ ti, 0 ≤ ki ≤ 1000) — the number of starting city, finishing city and the number of possible car changes in i-th round, correspondingly.",
      "output_spec": "OutputFor each round you should print the minimum required time to complete the round in a single line.",
      "sample_tests": "ExamplesInputCopy4 2 30 1 5 62 0 3 61 3 0 16 6 7 00 3 5 62 0 1 61 3 0 26 6 7 01 4 21 4 11 4 3OutputCopy343InputCopy4 2 30 7 3 38 0 10 51 1 0 48 9 2 00 3 3 97 0 4 93 8 0 44 8 9 02 3 32 1 31 2 2OutputCopy453",
      "description": "B. AlgoRace\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers n, m, r (2 ≤ n ≤ 60, 1 ≤ m ≤ 60, 1 ≤ r ≤ 105) — the number of cities, the number of different types of cars and the number of rounds in the competition, correspondingly.Next m sets of n × n matrices of integers between 0 to 106 (inclusive) will follow — describing the time one car requires to traverse different roads. The k-th integer in j-th line of the i-th set is the time that i-th car requires to traverse the road from j-th city to k-th city. These matrices are not necessarily symmetric, but their diagonal is always zero.Next r lines contain description of the rounds. The i-th of these lines contains space-separated integers si, ti, ki (1 ≤ si, ti ≤ n, si ≠ ti, 0 ≤ ki ≤ 1000) — the number of starting city, finishing city and the number of possible car changes in i-th round, correspondingly.\n\nOutputFor each round you should print the minimum required time to complete the round in a single line.\n\nInputCopy4 2 30 1 5 62 0 3 61 3 0 16 6 7 00 3 5 62 0 1 61 3 0 26 6 7 01 4 21 4 11 4 3OutputCopy343InputCopy4 2 30 7 3 38 0 10 51 1 0 48 9 2 00 3 3 97 0 4 93 8 0 44 8 9 02 3 32 1 31 2 2OutputCopy453\n\nInputCopy4 2 30 1 5 62 0 3 61 3 0 16 6 7 00 3 5 62 0 1 61 3 0 26 6 7 01 4 21 4 11 4 3\n\nOutputCopy343\n\nInputCopy4 2 30 7 3 38 0 10 51 1 0 48 9 2 00 3 3 97 0 4 93 8 0 44 8 9 02 3 32 1 31 2 2\n\nOutputCopy453\n\nNoteIn the first sample, in all rounds PMP goes from city #1 to city #2, then city #3 and finally city #4. But the sequences of types of the cars he uses are (1, 2, 1) in the first round and (1, 2, 2) in the second round. In the third round, although he can change his car three times, he uses the same strategy as the first round which only needs two car changes.",
      "solutions": [
        {
          "title": "Codeforces Round #119 - Codeforces",
          "content": "Hello everyone,We are glad to invite you to participate in today’s round. Problems have been prepared by poopi, Mohammad_JRS, Gerald and me. The hero of our contest is called “PMP”. It is actually the base of our team name through the last five years. The stories are metaphoric, but they have some traces in truth.This Codeforces round, is the last round before the incoming ICPC world final. Our best wishes for all participants of that contest, too. I want to specially thank Gerald for his helps and advices in problem preparation, Delinur for translation of statements into Russian and MikeMirzayanov for this great system.And we have a modified version of Burunduk1 ’s advice: “to make the round even more interesting for us, read the statements of ALL problems.” :)We hope you enjoy the problems and have high ratings.Update: Contest is over. Thanks to everyone for taking part and congratulations to the winners of both divisions, specially peter50216 for being the only who solved all the problems of division 1! :)Update: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4520",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1041
        },
        {
          "title": "Codeforces Round #119 — Editorial - Codeforces",
          "content": "Problem 189A — Cut RibbonThe problem is to maximize x+y+z subject to ax+by+cz=n. Constraints are low, so simply iterate over two variables (say x and y) and find the third variable (if any) from the second equation. Find the maximum over all feasible solutions.Other approaches: Use dynamic programming with each state being the remainder of ribbon. Select the next piece to be a, b or c.Problem 189B — Counting RhombiObserve that lots of rhombi have the same shape, but are in different locations. What uniquely determines the shape of a rhombus? Its width and its height. Is it possible to build a rhombus with every width and every height such that the vertices of the rhombus are in integer points? No, it is possible only if the width and the height are both even.How many places we can put a rhombus of width w0 and height h0 in a rectangle of width w and height h? (w * w0 + 1)(h * h0 + 1)So, iterator over all even widths and heights and for each of them add the number of possible locations to the final result.Problem 187A — PermutationsIt is easy to see that if we replace each number in the first permutation with position of that number in the second permutation, the problem reduces to sorting the first permutation.Each time we take a number from the end of array, we can postpone its insertion until we know the most suitable position for insertion. Note that it is not good to insert a number and take it again, as we could make a better decision first time we took the number. So, as long as the remainder of the array is not in increasing order, we should take more numbers from the end. But as soon as you have an increasing subsequence, you can insert the numbers you have taken to make the array sorted. Therefore to solve the problem, we find the largest i such the numbers from 1 to i are in increasing order. The answer would be n-i.Problem 187B — AlgoRaceFirst we solve the problem when the number of allowed car changes is zero (_k=0_). Let W(i,j,l) be the length of shortest path from i to j with car l. We use Floyd-Warshal on graph of each car to find this value. Then answer for the case that we can use only one car for each pair of cities i and j is:ans(0,i,j) = min W(i,j,l) for (_1≤l≤m_)This part has time complexity O(m*n^3).For larger values of maximum number of changes (_k_), we use the following equation:ans(k,i,j) = min (ans(k-1,i,l)+ans(0,l,j)) for (_1≤l≤k_)which can be computed in O(k*n^3) using dynamic programming.But how large can be k in worst case? We know that shortest paths are simple paths (i.e. they have no repeated vertices). Because otherwise we could eliminate the path we go between two appearances of one vertex and have a smaller result. This and the fact that we change the car at most once in each vertex, guarantees in any optimal solution we will not need more that n car changes. Thus the order of the solution would be O(m*n^3+n^4).Problem 187C — Weak MemoryThere were many different correct approaches to this problem during the contest. But I will explain author’s solution.First we can use binary search over the value of q. Now for a fixed q we want to check s-t connectivity.Let K be the set of all intersections with volunteers union s and t. One can use BFS from each k∈K, one by one. Then build a graph G’ with vertices K. For each two vertices k1,k2∈K add an edge between them, if their shortest distance is less than or equal to q. Finally use any path finding algorithm to check the connectivity. Unfortunately this solution has time (and space) complexity of O(|K|*m) which is not good enough.We can optimize the above solution by initiating BFS from all k∈K at once. In other words during the initialization step in BFS algorithm, we push all these vertices in the queue with distance 0. Each element in the queue also maintains its source (i.e. the source it is originating from). In BFS each time we have have a vertex u with source su and we want to set the minimum distance to a vertex v that is already set from a different path with source sv, we connect su and sv in G’ if d(u)+d(v)+1<= q, where d(x) denotes length of the shortest path from a vertex in K to x. As we are only dealing with connectivity, this approach is correct. (Proof of correctness is left as an exercise)BFS takes O(m) time and we add at most O(m) edges to G’, so the overall complexity is O(m) for a fixed q. As we used binary search to find the smallest q, we can solve the problem in O(m*logn).Problem 187D — BRT ContractWe define ti as follows: assume a bus starts moving from i-th intersection exactly at the time when the light changes to green. The time it takes for the bus to get the final station is ti. We call the times when a green interval begins t0 (so every g+r seconds t0 occurs once)If a bus gets to i-th intersection during the red phase, it should wait and then start moving at t0. So considering the fact that all lights are synchronized (and length of segments are fixed) if we have ti for i-th intersection, we can compute the time for the bus to get final station.Clearly tn is the length of the last segments. For computing ti we should find the smallest j such that if a bus starts at t0 from i-th intersection, it gets to j-th intersection during the red phase. So we have:ti=tj+d(i,j)+wwhere d(i,j) is the distance between i-th and j-th intersections and w is the time that the bus should wait behind the red light at j-th intersection. The later value can be computed easily.The only problem that remains is to find j for i-th intersection. So we start iterating over i for (n-1)-th intersection backwards and we compute ti for all intersections. Assume p=g+r and ta=d(i,j)%p. Now if the bus starts from i-th intersection at time t0 and we have ta>=g, in this case we are in red phase at j-th intersection. Actually ta should be in interval [_g, g+r_). Here we can use segment trees. That is for all intersections from i+1 to n, we store some values in the tree that helps us find the smallest j. But we should note the value of ta depends on d(i,j) which changes as i changes. Thus we cannot use ta in the tree. Instead, we define si the be the distance of i-th intersection to the destination. So we have d(i,j)=si-sj and we use the value of sj with storing –sj%p in the segment tree as the key and the value would be j itself. In other words for each intersection we store the key-value pair (-sj%p, j) in the tree. According to what we said so far, to be in the red phase at j-th intersection we should have:ta=(d(i,j)%p)=((si-sj)%p)∈[g,g+r) => -sj%p ∈ [(g-si)%p, (g+r-si)%p)As we stored –sj%p in the tree, we can retrieve the smallest j in the above interval with a query in the segment tree. This way we can compute ti for all intersections. Answering to each query in the problem can be solve in exactly the same way. So the overall complexity would be O((n+q)logn).Problem 187E — Heaven TourStep 1. Solve the problem if the starting man is the leftmost man and the finishing man is the rightmost man.Obviously every segment (the distance between two consecutive men) should be covered at least once. We also argue that at least l (the number of left tickets) segments should be covered at least three times. Proof: Each time you use a left ticket to go to man i with 1<i<n-1, the segment between i-th and (_i+1_)-th men is covered at least three times: Once for you should go after i be in a position to come back. Once for you use a left ticked to come back to i And once again you should go after i, because you want to finish at man number n Note that in the first and the last segments are always covered once, no matter what we do. But except for these two segments, every other segment can be chosen to be among the segments that are covered three times, and every combination that we choose l segments is feasible. (Proof it as practice) So we choose the smallest l segments and the problem can be solved with a simple sort in O(n*logn).Step 2. Solve the problem if the starting man is the leftmost man, but the finishing man can be anywhere.To solve this problem we first fix the finishing man. With reasoning similar to that of step 1, we conclude that at least l segments should be covered with at least two times if they are after the finishing man or three times if they are before him. But obviously every segment after the finishing man is covered at least two times. So it is always good to waste as many left tickets as possible after the finishing man to prevent them from breaching the left side of finishing man and becoming multiple three.So the algorithm would be: iterate over i, the number of finishing man, and maintain the l-(n-i) smallest segments to the right of finishing man as you progress. This can be implemented in O(n*logn).Step 3. Solve the problem if the starting man is fixed, but the finishing man can be anywhere.Assume that the starting man is not the first man or the last man, otherwise we could use algorithm of step 2 to solve the problem. Without loss of generality assume that you finish your tour to the right side of finishing man. Therefore every segment to the left of starting man is covered at least two times and actually it is always possible to arrange visits such that every segment to right is covered exactly two times. So just like what we said in step 2, it is good to waste as many left tickets as possible in this area.So the algorithm would be, choose to finish left or right first, then greedily waste as many bad moves (by bad moves I mean the moves that if breach to the other side will be more costly) as possible there and follow the algorithm in step 2 to solve the whole problem.There are some special cases such as when the tour cannot be finished at all, that we left to readers find a way how to handle them.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4540",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 187\\s*B"
          },
          "content_length": 9777
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #119 - Codeforces - Code 1",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 2",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 3",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 4",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 5",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 6",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N_MAX = 60;\nconst int M_MAX = 60;\nconst int R_MAX = 100000;\nconst int TIME_MAX = 1000000;\nconst int K_MAX = 1000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, N_MAX, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, M_MAX, \"m\");\n    inf.readSpace();\n    int r = inf.readInt(1, R_MAX, \"r\");\n    inf.readEoln();\n\n    for (int car_type = 0; car_type < m; ++car_type) {\n        for (int row = 0; row < n; ++row) {\n            vector<int> times = inf.readInts(n, 0, TIME_MAX, \"times\");\n            inf.readEoln();\n\n            // Check that diagonal element is zero\n            ensuref(times[row] == 0, \"Diagonal element at car type %d, city %d to %d is not zero\", car_type+1, row+1, row+1);\n        }\n    }\n\n    for (int i = 0; i < r; ++i) {\n        int si = inf.readInt(1, n, \"si\");\n        inf.readSpace();\n        int ti = inf.readInt(1, n, \"ti\");\n        ensuref(si != ti, \"In round %d, si (%d) is equal to ti (%d)\", i+1, si, ti);\n        inf.readSpace();\n        int ki = inf.readInt(0, K_MAX, \"ki\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N_MAX = 60;\nconst int M_MAX = 60;\nconst int R_MAX = 100000;\nconst int TIME_MAX = 1000000;\nconst int K_MAX = 1000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, N_MAX, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, M_MAX, \"m\");\n    inf.readSpace();\n    int r = inf.readInt(1, R_MAX, \"r\");\n    inf.readEoln();\n\n    for (int car_type = 0; car_type < m; ++car_type) {\n        for (int row = 0; row < n; ++row) {\n            vector<int> times = inf.readInts(n, 0, TIME_MAX, \"times\");\n            inf.readEoln();\n\n            // Check that diagonal element is zero\n            ensuref(times[row] == 0, \"Diagonal element at car type %d, city %d to %d is not zero\", car_type+1, row+1, row+1);\n        }\n    }\n\n    for (int i = 0; i < r; ++i) {\n        int si = inf.readInt(1, n, \"si\");\n        inf.readSpace();\n        int ti = inf.readInt(1, n, \"ti\");\n        ensuref(si != ti, \"In round %d, si (%d) is equal to ti (%d)\", i+1, si, ti);\n        inf.readSpace();\n        int ki = inf.readInt(0, K_MAX, \"ki\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N_MAX = 60;\nconst int M_MAX = 60;\nconst int R_MAX = 100000;\nconst int TIME_MAX = 1000000;\nconst int K_MAX = 1000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, N_MAX, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, M_MAX, \"m\");\n    inf.readSpace();\n    int r = inf.readInt(1, R_MAX, \"r\");\n    inf.readEoln();\n\n    for (int car_type = 0; car_type < m; ++car_type) {\n        for (int row = 0; row < n; ++row) {\n            vector<int> times = inf.readInts(n, 0, TIME_MAX, \"times\");\n            inf.readEoln();\n\n            // Check that diagonal element is zero\n            ensuref(times[row] == 0, \"Diagonal element at car type %d, city %d to %d is not zero\", car_type+1, row+1, row+1);\n        }\n    }\n\n    for (int i = 0; i < r; ++i) {\n        int si = inf.readInt(1, n, \"si\");\n        inf.readSpace();\n        int ti = inf.readInt(1, n, \"ti\");\n        ensuref(si != ti, \"In round %d, si (%d) is equal to ti (%d)\", i+1, si, ti);\n        inf.readSpace();\n        int ki = inf.readInt(0, K_MAX, \"ki\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    long long r = opt<long long>(\"r\");\n    int kiParam = opt<int>(\"ki\", -1);\n    int kiMin = opt<int>(\"kiMin\", kiParam == -1 ? 0 : kiParam);\n    int kiMax = opt<int>(\"kiMax\", kiParam == -1 ? 1000 : kiParam);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Validate parameters against constraints\n    ensure(2 <= n && n <= 60);\n    ensure(1 <= m && m <= 60);\n    ensure(1 <= r && r <= 100000);\n    ensure(0 <= kiMin && kiMin <= 1000);\n    ensure(0 <= kiMax && kiMax <= 1000);\n    ensure(kiMin <= kiMax);\n\n    // Generate m time matrices of size n x n\n    vector<vector<vector<int> > > car_times(m, vector<vector<int> >(n, vector<int>(n, 0)));\n\n    // Generate time matrices based on type\n    if(type == \"symmetric\") {\n        // The time matrices are symmetric\n        for(int c = 0; c < m; ++c) {\n            for(int i = 0; i < n; ++i) {\n                for(int j = i; j < n; ++j) {\n                    int time = (i == j) ? 0 : rnd.next(0, 1000000);\n                    car_times[c][i][j] = car_times[c][j][i] = time;\n                }\n            }\n        }\n    } else if(type == \"asymmetric\") {\n        // The time matrices are asymmetric\n        for(int c = 0; c < m; ++c) {\n            for(int i = 0; i < n; ++i) {\n                for(int j = 0; j < n; ++j) {\n                    if(i == j)\n                        car_times[c][i][j] = 0;\n                    else\n                        car_times[c][i][j] = rnd.next(0, 1000000);\n                }\n            }\n        }\n    } else if(type == \"zerotimes\") {\n        // All off-diagonal times are zero\n        for(int c = 0; c < m; ++c) {\n            for(int i = 0; i < n; ++i) {\n                for(int j = 0; j < n; ++j) {\n                    car_times[c][i][j] = (i == j) ? 0 : 0;\n                }\n            }\n        }\n    } else if(type == \"largetimes\") {\n        // All times are near maximum\n        for(int c = 0; c < m; ++c) {\n            for(int i = 0; i < n; ++i) {\n                for(int j = 0; j < n; ++j) {\n                    car_times[c][i][j] = (i == j) ? 0 : 1000000 - rnd.next(0, 1000);\n                }\n            }\n        }\n    } else if(type == \"smalltimes\") {\n        // All times are small positive integers\n        for(int c = 0; c < m; ++c) {\n            for(int i = 0; i < n; ++i) {\n                for(int j = 0; j < n; ++j) {\n                    car_times[c][i][j] = (i == j) ? 0 : rnd.next(1, 10);\n                }\n            }\n        }\n    } else {\n        // Default is random times\n        for(int c = 0; c < m; ++c) {\n            for(int i = 0; i < n; ++i) {\n                for(int j = 0; j < n; ++j) {\n                    car_times[c][i][j] = (i == j) ? 0 : rnd.next(0, 1000000);\n                }\n            }\n        }\n    }\n\n    // Output the first line: n m r\n    printf(\"%d %d %lld\\n\", n, m, r);\n\n    // Output m sets of nxn matrices\n    for(int c = 0; c < m; ++c) {\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                printf(\"%d\", car_times[c][i][j]);\n                if(j < n - 1) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    }\n\n    // Generate r rounds\n    for(long long i = 0; i < r; ++i) {\n        int si = rnd.next(1, n);\n        int ti = rnd.next(1, n);\n        while(ti == si) {\n            ti = rnd.next(1, n);\n        }\n        int ki_i = kiParam != -1 ? kiParam : rnd.next(kiMin, kiMax);\n        printf(\"%d %d %d\\n\", si, ti, ki_i);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    long long r = opt<long long>(\"r\");\n    int kiParam = opt<int>(\"ki\", -1);\n    int kiMin = opt<int>(\"kiMin\", kiParam == -1 ? 0 : kiParam);\n    int kiMax = opt<int>(\"kiMax\", kiParam == -1 ? 1000 : kiParam);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Validate parameters against constraints\n    ensure(2 <= n && n <= 60);\n    ensure(1 <= m && m <= 60);\n    ensure(1 <= r && r <= 100000);\n    ensure(0 <= kiMin && kiMin <= 1000);\n    ensure(0 <= kiMax && kiMax <= 1000);\n    ensure(kiMin <= kiMax);\n\n    // Generate m time matrices of size n x n\n    vector<vector<vector<int> > > car_times(m, vector<vector<int> >(n, vector<int>(n, 0)));\n\n    // Generate time matrices based on type\n    if(type == \"symmetric\") {\n        // The time matrices are symmetric\n        for(int c = 0; c < m; ++c) {\n            for(int i = 0; i < n; ++i) {\n                for(int j = i; j < n; ++j) {\n                    int time = (i == j) ? 0 : rnd.next(0, 1000000);\n                    car_times[c][i][j] = car_times[c][j][i] = time;\n                }\n            }\n        }\n    } else if(type == \"asymmetric\") {\n        // The time matrices are asymmetric\n        for(int c = 0; c < m; ++c) {\n            for(int i = 0; i < n; ++i) {\n                for(int j = 0; j < n; ++j) {\n                    if(i == j)\n                        car_times[c][i][j] = 0;\n                    else\n                        car_times[c][i][j] = rnd.next(0, 1000000);\n                }\n            }\n        }\n    } else if(type == \"zerotimes\") {\n        // All off-diagonal times are zero\n        for(int c = 0; c < m; ++c) {\n            for(int i = 0; i < n; ++i) {\n                for(int j = 0; j < n; ++j) {\n                    car_times[c][i][j] = (i == j) ? 0 : 0;\n                }\n            }\n        }\n    } else if(type == \"largetimes\") {\n        // All times are near maximum\n        for(int c = 0; c < m; ++c) {\n            for(int i = 0; i < n; ++i) {\n                for(int j = 0; j < n; ++j) {\n                    car_times[c][i][j] = (i == j) ? 0 : 1000000 - rnd.next(0, 1000);\n                }\n            }\n        }\n    } else if(type == \"smalltimes\") {\n        // All times are small positive integers\n        for(int c = 0; c < m; ++c) {\n            for(int i = 0; i < n; ++i) {\n                for(int j = 0; j < n; ++j) {\n                    car_times[c][i][j] = (i == j) ? 0 : rnd.next(1, 10);\n                }\n            }\n        }\n    } else {\n        // Default is random times\n        for(int c = 0; c < m; ++c) {\n            for(int i = 0; i < n; ++i) {\n                for(int j = 0; j < n; ++j) {\n                    car_times[c][i][j] = (i == j) ? 0 : rnd.next(0, 1000000);\n                }\n            }\n        }\n    }\n\n    // Output the first line: n m r\n    printf(\"%d %d %lld\\n\", n, m, r);\n\n    // Output m sets of nxn matrices\n    for(int c = 0; c < m; ++c) {\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                printf(\"%d\", car_times[c][i][j]);\n                if(j < n - 1) printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    }\n\n    // Generate r rounds\n    for(long long i = 0; i < r; ++i) {\n        int si = rnd.next(1, n);\n        int ti = rnd.next(1, n);\n        while(ti == si) {\n            ti = rnd.next(1, n);\n        }\n        int ki_i = kiParam != -1 ? kiParam : rnd.next(kiMin, kiMax);\n        printf(\"%d %d %d\\n\", si, ti, ki_i);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -r 1 -ki 0 -type smalltimes\n./gen -n 2 -m 1 -r 1 -ki 0 -type zerotimes\n./gen -n 2 -m 1 -r 1 -ki 0 -type largetimes\n\n./gen -n 60 -m 60 -r 100000 -ki 1000 -type random\n./gen -n 60 -m 60 -r 100000 -ki 0 -type random\n\n./gen -n 60 -m 60 -r 100000 -kiMin 0 -kiMax 1000 -type asymmetric\n./gen -n 60 -m 1 -r 100000 -kiMin 0 -kiMax 1000 -type symmetric\n\n./gen -n 2 -m 1 -r 100000 -kiMin 0 -kiMax 1000 -type smalltimes\n\n./gen -n 60 -m 1 -r 100000 -kiMin 0 -kiMax 1000 -type largetimes\n\n./gen -n 30 -m 30 -r 50000 -ki 0 -type symmetric\n\n./gen -n 30 -m 30 -r 50000 -ki 1000 -type asymmetric\n\n./gen -n 60 -m 60 -r 1 -kiMin 0 -kiMax 1000 -type random\n\n./gen -n 2 -m 60 -r 1 -ki 0 -type smalltimes\n\n./gen -n 60 -m 1 -r 1 -kiMin 0 -kiMax 1000 -type largetimes\n\n./gen -n 60 -m 60 -r 100000 -ki 0 -type smalltimes\n\n./gen -n 60 -m 60 -r 100000 -ki 1000 -type largetimes\n\n./gen -n 50 -m 50 -r 50000 -kiMin 0 -kiMax 1000 -type asymmetric\n\n./gen -n 50 -m 50 -r 50000 -kiMin 0 -kiMax 1000 -type symmetric\n\n./gen -n 10 -m 10 -r 10000 -kiMin 0 -kiMax 1000 -type smalltimes\n\n./gen -n 10 -m 10 -r 10000 -kiMax 5 -type zerotimes\n\n./gen -n 60 -m 60 -r 99999 -type asymmetric\n\n./gen -n 2 -m 2 -r 100000 -ki 0 -type smalltimes\n\n./gen -n 60 -m 60 -r 50 -type largetimes\n\n./gen -n 60 -m 60 -r 100000 -kiMin 999 -kiMax 1000 -type random\n\n./gen -n 60 -m 60 -r 100000 -kiMax 1 -type random\n\n./gen -n 2 -m 60 -r 1000 -type smalltimes\n\n./gen -n 60 -m 2 -r 100000 -type largetimes\n\n./gen -n 60 -m 1 -r 99999 -kiMin 0 -kiMax 1000 -type symmetric\n\n./gen -n 5 -m 5 -r 5000 -ki 0 -type zerotimes\n\n./gen -n 60 -m 60 -r 100000 -type symmetric\n\n./gen -n 60 -m 60 -r 100000 -type asymmetric\n\n./gen -n 60 -m 60 -r 1 -ki 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:35.363493",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "187/C",
      "title": "C. Скверная Память",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны через пробел три целых числа n, m, k (2 ≤ n ≤ 105, 0 ≤ m ≤ 2·105, 1 ≤ k ≤ n) — количество перекрестков, дорог и волонтеров соответственно. В следующей строке записано через пробел k различных целых чисел от 1 до n включительно — номера перекрестков, на которых стоят волонтеры.Следующие m строк описывают дороги. В i-ой строке записаны через пробел два целых числа ui, vi (1 ≤ ui, vi ≤ n, ui ≠ vi) — два перекрестка, соединенные i-ой дорогой. Между любыми двумя перекрестками есть не более одной дороги.Последняя строка входного файла содержит через пробел два целых числа s, t (1 ≤ s, t ≤ n, s ≠ t) — исходная позиция PMP, расположение автобусов. Не гарантируется, что автобусная станция достижима по дорогам парка из перекрестка с номером s.Гарантируется, что на перекрестке s всегда стоит волонтер.",
      "output_spec": "Выходные данныеВыведите на единственной строке ответ к задаче: минимальное значении q, при котором PMP сможет найти автобусы. Если PMP не сможет найти автобусы ни при каком значении q выведите -1.",
      "sample_tests": "ПримерыВходные данныеСкопировать6 6 31 3 61 22 34 25 64 53 41 6Выходные данныеСкопировать3Входные данныеСкопировать6 5 31 5 61 22 33 44 56 31 5Выходные данныеСкопировать3",
      "description": "C. Скверная Память\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны через пробел три целых числа n, m, k (2 ≤ n ≤ 105, 0 ≤ m ≤ 2·105, 1 ≤ k ≤ n) — количество перекрестков, дорог и волонтеров соответственно. В следующей строке записано через пробел k различных целых чисел от 1 до n включительно — номера перекрестков, на которых стоят волонтеры.Следующие m строк описывают дороги. В i-ой строке записаны через пробел два целых числа ui, vi (1 ≤ ui, vi ≤ n, ui ≠ vi) — два перекрестка, соединенные i-ой дорогой. Между любыми двумя перекрестками есть не более одной дороги.Последняя строка входного файла содержит через пробел два целых числа s, t (1 ≤ s, t ≤ n, s ≠ t) — исходная позиция PMP, расположение автобусов. Не гарантируется, что автобусная станция достижима по дорогам парка из перекрестка с номером s.Гарантируется, что на перекрестке s всегда стоит волонтер.\n\nВходные данные\n\nВыходные данныеВыведите на единственной строке ответ к задаче: минимальное значении q, при котором PMP сможет найти автобусы. Если PMP не сможет найти автобусы ни при каком значении q выведите -1.\n\nВыходные данные\n\nВходные данныеСкопировать6 6 31 3 61 22 34 25 64 53 41 6Выходные данныеСкопировать3Входные данныеСкопировать6 5 31 5 61 22 33 44 56 31 5Выходные данныеСкопировать3\n\nВходные данныеСкопировать6 6 31 3 61 22 34 25 64 53 41 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 5 31 5 61 22 33 44 56 31 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПервый пример проиллюстрирован ниже. Синим отмечены перекрестки, в которых находятся волонтеры. Пунктирная линия показывает возможный путь, для такого пути ответ q = 3:  Во втором примере, при q = 3 PMP может дойти до перекрестка номер 6, а потом дойти до автобусной остановки.",
      "solutions": [
        {
          "title": "Codeforces Round #119 - Codeforces",
          "content": "Привет всем, Мы рады пригласить вас принять участие в сегодняшнем раунде.Задачи были подготовлены poopi, Mohammad_JRS, Gerald и мной. Героя сегодняшнего контеста зовут \"PMP\". Это основной состав нашей команды по программированию вот уже пять лет. Все легенды в задачах метафоричны, но некоторые из них имеют пересечения с реальной жизнью.Этот Codeforces раунд последний раунд перед надвигающимся финалом чемпионата мира ACM ICPC. Мы желаем всего самого лучшего участникам этого соревнования.Я хочу поблагодарить Gerald за его помощь и советы по подготовке задач, Delinur за перевод условий на русский и MikeMirzayanov за его замечательную систему.Мы немного изменили фразу сказанную Burunduk1: \"Чтобы раунд был более интересным для нас, прочитайте пожалуйста условия ВСЕХ задач.\" :)Надеюсь вам понравятся задачи, высокого рейтинга!Это перевод оригинального поста с английского. Английский в комментариях приветствуется.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4520",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 919
        },
        {
          "title": "Codeforces Round #119 — Editorial - Codeforces",
          "content": "Problem 189A — Cut RibbonThe problem is to maximize x+y+z subject to ax+by+cz=n. Constraints are low, so simply iterate over two variables (say x and y) and find the third variable (if any) from the second equation. Find the maximum over all feasible solutions.Other approaches: Use dynamic programming with each state being the remainder of ribbon. Select the next piece to be a, b or c.Problem 189B — Counting RhombiObserve that lots of rhombi have the same shape, but are in different locations. What uniquely determines the shape of a rhombus? Its width and its height. Is it possible to build a rhombus with every width and every height such that the vertices of the rhombus are in integer points? No, it is possible only if the width and the height are both even.How many places we can put a rhombus of width w0 and height h0 in a rectangle of width w and height h? (w * w0 + 1)(h * h0 + 1)So, iterator over all even widths and heights and for each of them add the number of possible locations to the final result.Problem 187A — PermutationsIt is easy to see that if we replace each number in the first permutation with position of that number in the second permutation, the problem reduces to sorting the first permutation.Each time we take a number from the end of array, we can postpone its insertion until we know the most suitable position for insertion. Note that it is not good to insert a number and take it again, as we could make a better decision first time we took the number. So, as long as the remainder of the array is not in increasing order, we should take more numbers from the end. But as soon as you have an increasing subsequence, you can insert the numbers you have taken to make the array sorted. Therefore to solve the problem, we find the largest i such the numbers from 1 to i are in increasing order. The answer would be n-i.Problem 187B — AlgoRaceFirst we solve the problem when the number of allowed car changes is zero (_k=0_). Let W(i,j,l) be the length of shortest path from i to j with car l. We use Floyd-Warshal on graph of each car to find this value. Then answer for the case that we can use only one car for each pair of cities i and j is:ans(0,i,j) = min W(i,j,l) for (_1≤l≤m_)This part has time complexity O(m*n^3).For larger values of maximum number of changes (_k_), we use the following equation:ans(k,i,j) = min (ans(k-1,i,l)+ans(0,l,j)) for (_1≤l≤k_)which can be computed in O(k*n^3) using dynamic programming.But how large can be k in worst case? We know that shortest paths are simple paths (i.e. they have no repeated vertices). Because otherwise we could eliminate the path we go between two appearances of one vertex and have a smaller result. This and the fact that we change the car at most once in each vertex, guarantees in any optimal solution we will not need more that n car changes. Thus the order of the solution would be O(m*n^3+n^4).Problem 187C — Weak MemoryThere were many different correct approaches to this problem during the contest. But I will explain author’s solution.First we can use binary search over the value of q. Now for a fixed q we want to check s-t connectivity.Let K be the set of all intersections with volunteers union s and t. One can use BFS from each k∈K, one by one. Then build a graph G’ with vertices K. For each two vertices k1,k2∈K add an edge between them, if their shortest distance is less than or equal to q. Finally use any path finding algorithm to check the connectivity. Unfortunately this solution has time (and space) complexity of O(|K|*m) which is not good enough.We can optimize the above solution by initiating BFS from all k∈K at once. In other words during the initialization step in BFS algorithm, we push all these vertices in the queue with distance 0. Each element in the queue also maintains its source (i.e. the source it is originating from). In BFS each time we have have a vertex u with source su and we want to set the minimum distance to a vertex v that is already set from a different path with source sv, we connect su and sv in G’ if d(u)+d(v)+1<= q, where d(x) denotes length of the shortest path from a vertex in K to x. As we are only dealing with connectivity, this approach is correct. (Proof of correctness is left as an exercise)BFS takes O(m) time and we add at most O(m) edges to G’, so the overall complexity is O(m) for a fixed q. As we used binary search to find the smallest q, we can solve the problem in O(m*logn).Problem 187D — BRT ContractWe define ti as follows: assume a bus starts moving from i-th intersection exactly at the time when the light changes to green. The time it takes for the bus to get the final station is ti. We call the times when a green interval begins t0 (so every g+r seconds t0 occurs once)If a bus gets to i-th intersection during the red phase, it should wait and then start moving at t0. So considering the fact that all lights are synchronized (and length of segments are fixed) if we have ti for i-th intersection, we can compute the time for the bus to get final station.Clearly tn is the length of the last segments. For computing ti we should find the smallest j such that if a bus starts at t0 from i-th intersection, it gets to j-th intersection during the red phase. So we have:ti=tj+d(i,j)+wwhere d(i,j) is the distance between i-th and j-th intersections and w is the time that the bus should wait behind the red light at j-th intersection. The later value can be computed easily.The only problem that remains is to find j for i-th intersection. So we start iterating over i for (n-1)-th intersection backwards and we compute ti for all intersections. Assume p=g+r and ta=d(i,j)%p. Now if the bus starts from i-th intersection at time t0 and we have ta>=g, in this case we are in red phase at j-th intersection. Actually ta should be in interval [_g, g+r_). Here we can use segment trees. That is for all intersections from i+1 to n, we store some values in the tree that helps us find the smallest j. But we should note the value of ta depends on d(i,j) which changes as i changes. Thus we cannot use ta in the tree. Instead, we define si the be the distance of i-th intersection to the destination. So we have d(i,j)=si-sj and we use the value of sj with storing –sj%p in the segment tree as the key and the value would be j itself. In other words for each intersection we store the key-value pair (-sj%p, j) in the tree. According to what we said so far, to be in the red phase at j-th intersection we should have:ta=(d(i,j)%p)=((si-sj)%p)∈[g,g+r) => -sj%p ∈ [(g-si)%p, (g+r-si)%p)As we stored –sj%p in the tree, we can retrieve the smallest j in the above interval with a query in the segment tree. This way we can compute ti for all intersections. Answering to each query in the problem can be solve in exactly the same way. So the overall complexity would be O((n+q)logn).Problem 187E — Heaven TourStep 1. Solve the problem if the starting man is the leftmost man and the finishing man is the rightmost man.Obviously every segment (the distance between two consecutive men) should be covered at least once. We also argue that at least l (the number of left tickets) segments should be covered at least three times. Proof: Each time you use a left ticket to go to man i with 1<i<n-1, the segment between i-th and (_i+1_)-th men is covered at least three times: Once for you should go after i be in a position to come back. Once for you use a left ticked to come back to i And once again you should go after i, because you want to finish at man number n Note that in the first and the last segments are always covered once, no matter what we do. But except for these two segments, every other segment can be chosen to be among the segments that are covered three times, and every combination that we choose l segments is feasible. (Proof it as practice) So we choose the smallest l segments and the problem can be solved with a simple sort in O(n*logn).Step 2. Solve the problem if the starting man is the leftmost man, but the finishing man can be anywhere.To solve this problem we first fix the finishing man. With reasoning similar to that of step 1, we conclude that at least l segments should be covered with at least two times if they are after the finishing man or three times if they are before him. But obviously every segment after the finishing man is covered at least two times. So it is always good to waste as many left tickets as possible after the finishing man to prevent them from breaching the left side of finishing man and becoming multiple three.So the algorithm would be: iterate over i, the number of finishing man, and maintain the l-(n-i) smallest segments to the right of finishing man as you progress. This can be implemented in O(n*logn).Step 3. Solve the problem if the starting man is fixed, but the finishing man can be anywhere.Assume that the starting man is not the first man or the last man, otherwise we could use algorithm of step 2 to solve the problem. Without loss of generality assume that you finish your tour to the right side of finishing man. Therefore every segment to the left of starting man is covered at least two times and actually it is always possible to arrange visits such that every segment to right is covered exactly two times. So just like what we said in step 2, it is good to waste as many left tickets as possible in this area.So the algorithm would be, choose to finish left or right first, then greedily waste as many bad moves (by bad moves I mean the moves that if breach to the other side will be more costly) as possible there and follow the algorithm in step 2 to solve the whole problem.There are some special cases such as when the tour cannot be finished at all, that we left to readers find a way how to handle them.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4540",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 187\\s*C"
          },
          "content_length": 9777
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #119 - Codeforces - Code 1",
          "code": "for(int i=0;i<n;i++)\n\n{\n\n    scanf(\"%d\",&x);\n\n    if (x!=a[i-cnt])\n\n        cnt++;\n\n}\n\nprintf(\"%d\",cnt);`",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 2",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 3",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 4",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 5",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 6",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 7",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> volunteers = inf.readInts(k, 1, n);\n    inf.readEoln();\n    {\n        set<int> volunteer_set(volunteers.begin(), volunteers.end());\n        ensuref((int)volunteer_set.size() == k, \"Volunteer positions are not distinct\");\n    }\n\n    set<pair<int,int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Road %d connects a node to itself\", i+1);\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int,int> e = {a, b};\n        ensuref(edges.count(e) == 0, \"Road between %d and %d appears multiple times\", a, b);\n        edges.insert(e);\n    }\n\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    int t = inf.readInt(1, n, \"t\");\n    inf.readEoln();\n    ensuref(s != t, \"s and t must not be equal\");\n    {\n        set<int> volunteer_set(volunteers.begin(), volunteers.end());\n        ensuref(volunteer_set.count(s) == 1, \"There is no volunteer at intersection s\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> volunteers = inf.readInts(k, 1, n);\n    inf.readEoln();\n    {\n        set<int> volunteer_set(volunteers.begin(), volunteers.end());\n        ensuref((int)volunteer_set.size() == k, \"Volunteer positions are not distinct\");\n    }\n\n    set<pair<int,int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Road %d connects a node to itself\", i+1);\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int,int> e = {a, b};\n        ensuref(edges.count(e) == 0, \"Road between %d and %d appears multiple times\", a, b);\n        edges.insert(e);\n    }\n\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    int t = inf.readInt(1, n, \"t\");\n    inf.readEoln();\n    ensuref(s != t, \"s and t must not be equal\");\n    {\n        set<int> volunteer_set(volunteers.begin(), volunteers.end());\n        ensuref(volunteer_set.count(s) == 1, \"There is no volunteer at intersection s\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> volunteers = inf.readInts(k, 1, n);\n    inf.readEoln();\n    {\n        set<int> volunteer_set(volunteers.begin(), volunteers.end());\n        ensuref((int)volunteer_set.size() == k, \"Volunteer positions are not distinct\");\n    }\n\n    set<pair<int,int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Road %d connects a node to itself\", i+1);\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int,int> e = {a, b};\n        ensuref(edges.count(e) == 0, \"Road between %d and %d appears multiple times\", a, b);\n        edges.insert(e);\n    }\n\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    int t = inf.readInt(1, n, \"t\");\n    inf.readEoln();\n    ensuref(s != t, \"s and t must not be equal\");\n    {\n        set<int> volunteer_set(volunteers.begin(), volunteers.end());\n        ensuref(volunteer_set.count(s) == 1, \"There is no volunteer at intersection s\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // Set to -1 to indicate default value depending on type\n    int k = opt<int>(\"k\", n);\n    int s = opt<int>(\"s\", 1);\n    int t = opt<int>(\"t\", n);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure s != t and within 1..n\n    s = max(1, min(n, s));\n    t = max(1, min(n, t));\n    ensure(s != t);\n    k = min(k, n);\n\n    vector<pair<int, int>> edges;\n    set<pair<int,int>> edgeSet;\n\n    if (type == \"chain\") {\n        m = n - 1;\n        for(int i = 1; i < n; ++i){\n            edges.push_back({i, i+1});\n        }\n    } else if (type == \"star\") {\n        m = n - 1;\n        int center = s;\n        for(int i = 1; i <= n; ++i){\n            if (i != center) {\n                edges.push_back({center, i});\n            }\n        }\n    } else if (type == \"disconnected\") {\n        if (m == -1) m = n - 2; // Minimum edges to form two components\n        // Ensure m is valid\n        m = min(m, n * (n - 1) / 2);\n        vector<int> component1 = {s};\n        vector<int> component2 = {t};\n        for(int i = 1; i <= n; ++i) {\n            if (i != s && i != t) {\n                if (rnd.next(2)) component1.push_back(i);\n                else component2.push_back(i);\n            }\n        }\n        // Create edges within each component\n        auto add_edges = [&](vector<int>& comp){\n            for(int i = 1; i < comp.size(); ++i) {\n                int u = comp[i-1];\n                int v = comp[i];\n                if (!edgeSet.count({u,v})) {\n                    edges.push_back({u,v});\n                    edgeSet.insert({u,v});\n                    edgeSet.insert({v,u});\n                }\n            }\n        };\n        add_edges(component1);\n        add_edges(component2);\n        // Add random edges within components to reach m edges\n        while ((int)edges.size() < m) {\n            int u, v;\n            if (rnd.next(2)) {\n                // From component1\n                u = component1[rnd.next(0, (int)component1.size()-1)];\n                v = component1[rnd.next(0, (int)component1.size()-1)];\n            } else {\n                // From component2\n                u = component2[rnd.next(0, (int)component2.size()-1)];\n                v = component2[rnd.next(0, (int)component2.size()-1)];\n            }\n            if (u == v) continue;\n            if (edgeSet.count({u,v})) continue;\n            edges.push_back({u,v});\n            edgeSet.insert({u,v});\n            edgeSet.insert({v,u});\n        }\n    } else { // random\n        if (m == -1) m = n - 1;\n        m = min(m, n*(n-1)/2); // Max possible edges without multiple edges\n        // Generate a connected graph first\n        vector<int> nodes(n);\n        for(int i = 0; i < n; ++i) nodes[i] = i+1;\n        shuffle(nodes.begin(), nodes.end());\n        for(int i = 1; i < n; ++i){\n            int u = nodes[i];\n            int v = nodes[rnd.next(0, i - 1)];\n            edges.push_back({u, v});\n            edgeSet.insert({u,v});\n            edgeSet.insert({v,u});\n        }\n        // Add random edges to reach m edges\n        while((int)edges.size() < m){\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if(u == v) continue;\n            if(edgeSet.count({u,v})) continue;\n            edges.push_back({u,v});\n            edgeSet.insert({u,v});\n            edgeSet.insert({v,u});\n        }\n    }\n\n    // Now, set up volunteers\n    vector<int> volunteers;\n    volunteers.push_back(s);\n    set<int> volunteerSet;\n    volunteerSet.insert(s);\n\n    for(int i = 1; i <= n && (int)volunteers.size() < k; ++i) {\n        if (i != s) {\n            volunteers.push_back(i);\n            volunteerSet.insert(i);\n        }\n    }\n    // Shuffle volunteers if needed\n    shuffle(volunteers.begin(), volunteers.end());\n\n    // Output\n    printf(\"%d %d %d\\n\", n, (int)edges.size(), k);\n    for(int i = 0; i < k; ++i){\n        printf(\"%d%c\", volunteers[i], \" \\n\"[i == k-1]);\n    }\n    for(auto& e : edges){\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    printf(\"%d %d\\n\", s, t);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // Set to -1 to indicate default value depending on type\n    int k = opt<int>(\"k\", n);\n    int s = opt<int>(\"s\", 1);\n    int t = opt<int>(\"t\", n);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure s != t and within 1..n\n    s = max(1, min(n, s));\n    t = max(1, min(n, t));\n    ensure(s != t);\n    k = min(k, n);\n\n    vector<pair<int, int>> edges;\n    set<pair<int,int>> edgeSet;\n\n    if (type == \"chain\") {\n        m = n - 1;\n        for(int i = 1; i < n; ++i){\n            edges.push_back({i, i+1});\n        }\n    } else if (type == \"star\") {\n        m = n - 1;\n        int center = s;\n        for(int i = 1; i <= n; ++i){\n            if (i != center) {\n                edges.push_back({center, i});\n            }\n        }\n    } else if (type == \"disconnected\") {\n        if (m == -1) m = n - 2; // Minimum edges to form two components\n        // Ensure m is valid\n        m = min(m, n * (n - 1) / 2);\n        vector<int> component1 = {s};\n        vector<int> component2 = {t};\n        for(int i = 1; i <= n; ++i) {\n            if (i != s && i != t) {\n                if (rnd.next(2)) component1.push_back(i);\n                else component2.push_back(i);\n            }\n        }\n        // Create edges within each component\n        auto add_edges = [&](vector<int>& comp){\n            for(int i = 1; i < comp.size(); ++i) {\n                int u = comp[i-1];\n                int v = comp[i];\n                if (!edgeSet.count({u,v})) {\n                    edges.push_back({u,v});\n                    edgeSet.insert({u,v});\n                    edgeSet.insert({v,u});\n                }\n            }\n        };\n        add_edges(component1);\n        add_edges(component2);\n        // Add random edges within components to reach m edges\n        while ((int)edges.size() < m) {\n            int u, v;\n            if (rnd.next(2)) {\n                // From component1\n                u = component1[rnd.next(0, (int)component1.size()-1)];\n                v = component1[rnd.next(0, (int)component1.size()-1)];\n            } else {\n                // From component2\n                u = component2[rnd.next(0, (int)component2.size()-1)];\n                v = component2[rnd.next(0, (int)component2.size()-1)];\n            }\n            if (u == v) continue;\n            if (edgeSet.count({u,v})) continue;\n            edges.push_back({u,v});\n            edgeSet.insert({u,v});\n            edgeSet.insert({v,u});\n        }\n    } else { // random\n        if (m == -1) m = n - 1;\n        m = min(m, n*(n-1)/2); // Max possible edges without multiple edges\n        // Generate a connected graph first\n        vector<int> nodes(n);\n        for(int i = 0; i < n; ++i) nodes[i] = i+1;\n        shuffle(nodes.begin(), nodes.end());\n        for(int i = 1; i < n; ++i){\n            int u = nodes[i];\n            int v = nodes[rnd.next(0, i - 1)];\n            edges.push_back({u, v});\n            edgeSet.insert({u,v});\n            edgeSet.insert({v,u});\n        }\n        // Add random edges to reach m edges\n        while((int)edges.size() < m){\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if(u == v) continue;\n            if(edgeSet.count({u,v})) continue;\n            edges.push_back({u,v});\n            edgeSet.insert({u,v});\n            edgeSet.insert({v,u});\n        }\n    }\n\n    // Now, set up volunteers\n    vector<int> volunteers;\n    volunteers.push_back(s);\n    set<int> volunteerSet;\n    volunteerSet.insert(s);\n\n    for(int i = 1; i <= n && (int)volunteers.size() < k; ++i) {\n        if (i != s) {\n            volunteers.push_back(i);\n            volunteerSet.insert(i);\n        }\n    }\n    // Shuffle volunteers if needed\n    shuffle(volunteers.begin(), volunteers.end());\n\n    // Output\n    printf(\"%d %d %d\\n\", n, (int)edges.size(), k);\n    for(int i = 0; i < k; ++i){\n        printf(\"%d%c\", volunteers[i], \" \\n\"[i == k-1]);\n    }\n    for(auto& e : edges){\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    printf(\"%d %d\\n\", s, t);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -k 1 -type chain\n./gen -n 5 -m 4 -k 1 -type chain\n./gen -n 5 -m 4 -k 2 -type chain\n./gen -n 10 -m 9 -k 3 -type chain\n./gen -n 100 -m 99 -k 10 -type chain\n./gen -n 100000 -type chain\n\n./gen -n 2 -m 1 -k 1 -type star\n./gen -n 5 -m 4 -k 1 -type star\n./gen -n 5 -m 4 -k 2 -type star\n./gen -n 10 -m 9 -k 3 -type star\n./gen -n 100 -m 99 -k 10 -type star\n./gen -n 100000 -type star\n\n./gen -n 2 -m 0 -k 1 -type disconnected\n./gen -n 5 -m 2 -k 2 -type disconnected\n./gen -n 10 -m 5 -k 2 -type disconnected\n./gen -n 100 -m 50 -k 10 -type disconnected\n./gen -n 1000 -m 500 -k 100 -type disconnected\n./gen -n 100000 -m 50000 -k 1000 -type disconnected\n\n./gen -n 2 -m 1 -k 1 -type random\n./gen -n 5 -m 4 -k 2 -type random\n./gen -n 10 -m 15 -k 3 -type random\n./gen -n 100 -m 200 -k 10 -type random\n./gen -n 1000 -m 5000 -k 100 -type random\n./gen -n 100000 -m 200000 -k 1000 -type random\n\n./gen -n 5 -m 4 -k 1 -s 3 -t 5 -type chain\n./gen -n 5 -m 4 -k 2 -s 1 -t 5 -type star\n./gen -n 10 -m 9 -k 3 -s 1 -t 10 -type star\n./gen -n 100 -m 99 -k 10 -s 50 -t 100 -type chain\n./gen -n 100 -m 99 -k 10 -s 1 -t 100 -type chain\n./gen -n 100 -m 99 -k 5 -s 1 -t 2 -type star\n./gen -n 100 -m 99 -k 5 -s 50 -t 51 -type star\n./gen -n 100 -m 99 -k 5 -s 1 -t 100 -type chain\n\n./gen -n 100000 -m 200000 -k 1 -type random\n./gen -n 100000 -m 0 -k 1 -type random\n./gen -n 2 -m 0 -k 1 -type random\n./gen -n 2 -m 0 -k 1 -type disconnected\n\n./gen -n 100 -m 50 -k 10 -type random\n./gen -n 100 -m 99 -k 10 -type random\n./gen -n 100 -m 1000 -k 10 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:37.616553",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "187/D",
      "title": "D. BRT Contract",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains three space-separated positive integers n, g, r (1 ≤ n ≤ 105, 2 ≤ g + r ≤ 109) — the number of intersections, duration of green phase and duration of red phase. Next line contains n + 1 integers li (1 ≤ li ≤ 109) — the time to pass the i-th road segment in the path from source to destination. Next line contains a single integer q (1 ≤ q ≤ 105) — the number of buses in a day. The i-th of next q lines contains a single integer ti (1 ≤ ti ≤ 109) — the time when i-th bus leaves the source station.",
      "output_spec": "OutputIn the i-th line of output you should print a single integer — the time that i-th bus gets to destination.Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy1 3 25 2512345OutputCopy89121212InputCopy5 3 710 1 1 8 900000005 100000000031101000000000OutputCopy190000004019000000402900000030",
      "description": "D. BRT Contract\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains three space-separated positive integers n, g, r (1 ≤ n ≤ 105, 2 ≤ g + r ≤ 109) — the number of intersections, duration of green phase and duration of red phase. Next line contains n + 1 integers li (1 ≤ li ≤ 109) — the time to pass the i-th road segment in the path from source to destination. Next line contains a single integer q (1 ≤ q ≤ 105) — the number of buses in a day. The i-th of next q lines contains a single integer ti (1 ≤ ti ≤ 109) — the time when i-th bus leaves the source station.\n\nOutputIn the i-th line of output you should print a single integer — the time that i-th bus gets to destination.Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.\n\nInputCopy1 3 25 2512345OutputCopy89121212InputCopy5 3 710 1 1 8 900000005 100000000031101000000000OutputCopy190000004019000000402900000030\n\nInputCopy1 3 25 2512345\n\nOutputCopy89121212\n\nInputCopy5 3 710 1 1 8 900000005 100000000031101000000000\n\nOutputCopy190000004019000000402900000030\n\nNoteIn the first sample, buses #1, #2 and #5 will reach the destination without waiting behind the red light. But buses #3 and #4 should wait.In the second sample, first bus should wait at third, fourth and fifth intersections. Second and third buses should wait only at the fifth intersection.",
      "solutions": [
        {
          "title": "Codeforces Round #119 - Codeforces",
          "content": "Hello everyone,We are glad to invite you to participate in today’s round. Problems have been prepared by poopi, Mohammad_JRS, Gerald and me. The hero of our contest is called “PMP”. It is actually the base of our team name through the last five years. The stories are metaphoric, but they have some traces in truth.This Codeforces round, is the last round before the incoming ICPC world final. Our best wishes for all participants of that contest, too. I want to specially thank Gerald for his helps and advices in problem preparation, Delinur for translation of statements into Russian and MikeMirzayanov for this great system.And we have a modified version of Burunduk1 ’s advice: “to make the round even more interesting for us, read the statements of ALL problems.” :)We hope you enjoy the problems and have high ratings.Update: Contest is over. Thanks to everyone for taking part and congratulations to the winners of both divisions, specially peter50216 for being the only who solved all the problems of division 1! :)Update: Editorial",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4520",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1041
        },
        {
          "title": "Codeforces Round #119 — Editorial - Codeforces",
          "content": "Problem 189A — Cut RibbonThe problem is to maximize x+y+z subject to ax+by+cz=n. Constraints are low, so simply iterate over two variables (say x and y) and find the third variable (if any) from the second equation. Find the maximum over all feasible solutions.Other approaches: Use dynamic programming with each state being the remainder of ribbon. Select the next piece to be a, b or c.Problem 189B — Counting RhombiObserve that lots of rhombi have the same shape, but are in different locations. What uniquely determines the shape of a rhombus? Its width and its height. Is it possible to build a rhombus with every width and every height such that the vertices of the rhombus are in integer points? No, it is possible only if the width and the height are both even.How many places we can put a rhombus of width w0 and height h0 in a rectangle of width w and height h? (w * w0 + 1)(h * h0 + 1)So, iterator over all even widths and heights and for each of them add the number of possible locations to the final result.Problem 187A — PermutationsIt is easy to see that if we replace each number in the first permutation with position of that number in the second permutation, the problem reduces to sorting the first permutation.Each time we take a number from the end of array, we can postpone its insertion until we know the most suitable position for insertion. Note that it is not good to insert a number and take it again, as we could make a better decision first time we took the number. So, as long as the remainder of the array is not in increasing order, we should take more numbers from the end. But as soon as you have an increasing subsequence, you can insert the numbers you have taken to make the array sorted. Therefore to solve the problem, we find the largest i such the numbers from 1 to i are in increasing order. The answer would be n-i.Problem 187B — AlgoRaceFirst we solve the problem when the number of allowed car changes is zero (_k=0_). Let W(i,j,l) be the length of shortest path from i to j with car l. We use Floyd-Warshal on graph of each car to find this value. Then answer for the case that we can use only one car for each pair of cities i and j is:ans(0,i,j) = min W(i,j,l) for (_1≤l≤m_)This part has time complexity O(m*n^3).For larger values of maximum number of changes (_k_), we use the following equation:ans(k,i,j) = min (ans(k-1,i,l)+ans(0,l,j)) for (_1≤l≤k_)which can be computed in O(k*n^3) using dynamic programming.But how large can be k in worst case? We know that shortest paths are simple paths (i.e. they have no repeated vertices). Because otherwise we could eliminate the path we go between two appearances of one vertex and have a smaller result. This and the fact that we change the car at most once in each vertex, guarantees in any optimal solution we will not need more that n car changes. Thus the order of the solution would be O(m*n^3+n^4).Problem 187C — Weak MemoryThere were many different correct approaches to this problem during the contest. But I will explain author’s solution.First we can use binary search over the value of q. Now for a fixed q we want to check s-t connectivity.Let K be the set of all intersections with volunteers union s and t. One can use BFS from each k∈K, one by one. Then build a graph G’ with vertices K. For each two vertices k1,k2∈K add an edge between them, if their shortest distance is less than or equal to q. Finally use any path finding algorithm to check the connectivity. Unfortunately this solution has time (and space) complexity of O(|K|*m) which is not good enough.We can optimize the above solution by initiating BFS from all k∈K at once. In other words during the initialization step in BFS algorithm, we push all these vertices in the queue with distance 0. Each element in the queue also maintains its source (i.e. the source it is originating from). In BFS each time we have have a vertex u with source su and we want to set the minimum distance to a vertex v that is already set from a different path with source sv, we connect su and sv in G’ if d(u)+d(v)+1<= q, where d(x) denotes length of the shortest path from a vertex in K to x. As we are only dealing with connectivity, this approach is correct. (Proof of correctness is left as an exercise)BFS takes O(m) time and we add at most O(m) edges to G’, so the overall complexity is O(m) for a fixed q. As we used binary search to find the smallest q, we can solve the problem in O(m*logn).Problem 187D — BRT ContractWe define ti as follows: assume a bus starts moving from i-th intersection exactly at the time when the light changes to green. The time it takes for the bus to get the final station is ti. We call the times when a green interval begins t0 (so every g+r seconds t0 occurs once)If a bus gets to i-th intersection during the red phase, it should wait and then start moving at t0. So considering the fact that all lights are synchronized (and length of segments are fixed) if we have ti for i-th intersection, we can compute the time for the bus to get final station.Clearly tn is the length of the last segments. For computing ti we should find the smallest j such that if a bus starts at t0 from i-th intersection, it gets to j-th intersection during the red phase. So we have:ti=tj+d(i,j)+wwhere d(i,j) is the distance between i-th and j-th intersections and w is the time that the bus should wait behind the red light at j-th intersection. The later value can be computed easily.The only problem that remains is to find j for i-th intersection. So we start iterating over i for (n-1)-th intersection backwards and we compute ti for all intersections. Assume p=g+r and ta=d(i,j)%p. Now if the bus starts from i-th intersection at time t0 and we have ta>=g, in this case we are in red phase at j-th intersection. Actually ta should be in interval [_g, g+r_). Here we can use segment trees. That is for all intersections from i+1 to n, we store some values in the tree that helps us find the smallest j. But we should note the value of ta depends on d(i,j) which changes as i changes. Thus we cannot use ta in the tree. Instead, we define si the be the distance of i-th intersection to the destination. So we have d(i,j)=si-sj and we use the value of sj with storing –sj%p in the segment tree as the key and the value would be j itself. In other words for each intersection we store the key-value pair (-sj%p, j) in the tree. According to what we said so far, to be in the red phase at j-th intersection we should have:ta=(d(i,j)%p)=((si-sj)%p)∈[g,g+r) => -sj%p ∈ [(g-si)%p, (g+r-si)%p)As we stored –sj%p in the tree, we can retrieve the smallest j in the above interval with a query in the segment tree. This way we can compute ti for all intersections. Answering to each query in the problem can be solve in exactly the same way. So the overall complexity would be O((n+q)logn).Problem 187E — Heaven TourStep 1. Solve the problem if the starting man is the leftmost man and the finishing man is the rightmost man.Obviously every segment (the distance between two consecutive men) should be covered at least once. We also argue that at least l (the number of left tickets) segments should be covered at least three times. Proof: Each time you use a left ticket to go to man i with 1<i<n-1, the segment between i-th and (_i+1_)-th men is covered at least three times: Once for you should go after i be in a position to come back. Once for you use a left ticked to come back to i And once again you should go after i, because you want to finish at man number n Note that in the first and the last segments are always covered once, no matter what we do. But except for these two segments, every other segment can be chosen to be among the segments that are covered three times, and every combination that we choose l segments is feasible. (Proof it as practice) So we choose the smallest l segments and the problem can be solved with a simple sort in O(n*logn).Step 2. Solve the problem if the starting man is the leftmost man, but the finishing man can be anywhere.To solve this problem we first fix the finishing man. With reasoning similar to that of step 1, we conclude that at least l segments should be covered with at least two times if they are after the finishing man or three times if they are before him. But obviously every segment after the finishing man is covered at least two times. So it is always good to waste as many left tickets as possible after the finishing man to prevent them from breaching the left side of finishing man and becoming multiple three.So the algorithm would be: iterate over i, the number of finishing man, and maintain the l-(n-i) smallest segments to the right of finishing man as you progress. This can be implemented in O(n*logn).Step 3. Solve the problem if the starting man is fixed, but the finishing man can be anywhere.Assume that the starting man is not the first man or the last man, otherwise we could use algorithm of step 2 to solve the problem. Without loss of generality assume that you finish your tour to the right side of finishing man. Therefore every segment to the left of starting man is covered at least two times and actually it is always possible to arrange visits such that every segment to right is covered exactly two times. So just like what we said in step 2, it is good to waste as many left tickets as possible in this area.So the algorithm would be, choose to finish left or right first, then greedily waste as many bad moves (by bad moves I mean the moves that if breach to the other side will be more costly) as possible there and follow the algorithm in step 2 to solve the whole problem.There are some special cases such as when the tour cannot be finished at all, that we left to readers find a way how to handle them.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4540",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 187\\s*D"
          },
          "content_length": 9777
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #119 - Codeforces - Code 1",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 2",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 3",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 4",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 5",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 6",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int g = inf.readInt(1, 1000000000 - 1, \"g\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000000 - 1, \"r\");\n    inf.readEoln();\n\n    ensuref(g + r <= 1000000000, \"g + r must be ≤ 1e9\");\n\n    vector<int> li = inf.readInts(n + 1, 1, 1000000000, \"li\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int ti = inf.readInt(1, 1000000000, \"t_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int g = inf.readInt(1, 1000000000 - 1, \"g\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000000 - 1, \"r\");\n    inf.readEoln();\n\n    ensuref(g + r <= 1000000000, \"g + r must be ≤ 1e9\");\n\n    vector<int> li = inf.readInts(n + 1, 1, 1000000000, \"li\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int ti = inf.readInt(1, 1000000000, \"t_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int g = inf.readInt(1, 1000000000 - 1, \"g\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000000 - 1, \"r\");\n    inf.readEoln();\n\n    ensuref(g + r <= 1000000000, \"g + r must be ≤ 1e9\");\n\n    vector<int> li = inf.readInts(n + 1, 1, 1000000000, \"li\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int ti = inf.readInt(1, 1000000000, \"t_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    int g = opt<int>(\"g\");\n    int r = opt<int>(\"r\");\n\n    string li_type = opt<string>(\"li_type\", \"random\");\n    string ti_type = opt<string>(\"ti_type\", \"random\");\n\n    vector<int> li(n + 1);\n\n    if (li_type == \"constant\") {\n        int L = opt<int>(\"L\", 1);\n        for (int i = 0; i <= n; ++i)\n            li[i] = L;\n    } else if (li_type == \"random\") {\n        for (int i = 0; i <= n; ++i)\n            li[i] = rnd.next(1, 1000000000);\n    } else if (li_type == \"alternating\") {\n        int L1 = opt<int>(\"L1\", 1);\n        int L2 = opt<int>(\"L2\", 1000000000);\n        for (int i = 0; i <= n; ++i)\n            li[i] = (i % 2 == 0) ? L1 : L2;\n    } else if (li_type == \"small_large\") {\n        int L_small = opt<int>(\"L_small\", 1);\n        int L_large = opt<int>(\"L_large\", 1000000000);\n        for (int i = 0; i <= n; ++i) {\n            if (i < n / 2)\n                li[i] = L_small;\n            else\n                li[i] = L_large;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i <= n; ++i)\n            li[i] = rnd.next(1, 1000000000);\n    }\n\n    vector<int> ti(q);\n\n    if (ti_type == \"constant\") {\n        int T = opt<int>(\"T\", 1);\n        for (int i = 0; i < q; ++i)\n            ti[i] = T;\n    } else if (ti_type == \"increasing\") {\n        int ti_start = opt<int>(\"ti_start\", 1);\n        int ti_step = opt<int>(\"ti_step\", 1);\n        for (int i = 0; i < q; ++i) {\n            ti[i] = ti_start + i * ti_step;\n            if (ti[i] > 1000000000) ti[i] = 1000000000;\n        }\n    } else if (ti_type == \"aligned\") {\n        int cycle = g + r;\n        int k_start = opt<int>(\"k_start\", 0);\n        for (int i = 0; i < q; ++i) {\n            int k = k_start + i;\n            int arrival_time = k * cycle;\n            ti[i] = arrival_time - li[0];\n            if (ti[i] < 1) ti[i] = 1;\n            if (ti[i] > 1000000000) ti[i] = 1000000000;\n        }\n    } else if (ti_type == \"random\") {\n        for (int i = 0; i < q; ++i)\n            ti[i] = rnd.next(1, 1000000000);\n    } else {\n        // Default to random\n        for (int i = 0; i < q; ++i)\n            ti[i] = rnd.next(1, 1000000000);\n    }\n\n    // Output n, g, r\n    cout << n << ' ' << g << ' ' << r << '\\n';\n\n    // Output li[0..n]\n    for (int i = 0; i <= n; ++i) {\n        cout << li[i];\n        if (i != n)\n            cout << ' ';\n        else\n            cout << '\\n';\n    }\n\n    // Output q\n    cout << q << '\\n';\n\n    // Output ti[0..q-1]\n    for (int i = 0; i < q; ++i)\n        cout << ti[i] << '\\n';\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    int g = opt<int>(\"g\");\n    int r = opt<int>(\"r\");\n\n    string li_type = opt<string>(\"li_type\", \"random\");\n    string ti_type = opt<string>(\"ti_type\", \"random\");\n\n    vector<int> li(n + 1);\n\n    if (li_type == \"constant\") {\n        int L = opt<int>(\"L\", 1);\n        for (int i = 0; i <= n; ++i)\n            li[i] = L;\n    } else if (li_type == \"random\") {\n        for (int i = 0; i <= n; ++i)\n            li[i] = rnd.next(1, 1000000000);\n    } else if (li_type == \"alternating\") {\n        int L1 = opt<int>(\"L1\", 1);\n        int L2 = opt<int>(\"L2\", 1000000000);\n        for (int i = 0; i <= n; ++i)\n            li[i] = (i % 2 == 0) ? L1 : L2;\n    } else if (li_type == \"small_large\") {\n        int L_small = opt<int>(\"L_small\", 1);\n        int L_large = opt<int>(\"L_large\", 1000000000);\n        for (int i = 0; i <= n; ++i) {\n            if (i < n / 2)\n                li[i] = L_small;\n            else\n                li[i] = L_large;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i <= n; ++i)\n            li[i] = rnd.next(1, 1000000000);\n    }\n\n    vector<int> ti(q);\n\n    if (ti_type == \"constant\") {\n        int T = opt<int>(\"T\", 1);\n        for (int i = 0; i < q; ++i)\n            ti[i] = T;\n    } else if (ti_type == \"increasing\") {\n        int ti_start = opt<int>(\"ti_start\", 1);\n        int ti_step = opt<int>(\"ti_step\", 1);\n        for (int i = 0; i < q; ++i) {\n            ti[i] = ti_start + i * ti_step;\n            if (ti[i] > 1000000000) ti[i] = 1000000000;\n        }\n    } else if (ti_type == \"aligned\") {\n        int cycle = g + r;\n        int k_start = opt<int>(\"k_start\", 0);\n        for (int i = 0; i < q; ++i) {\n            int k = k_start + i;\n            int arrival_time = k * cycle;\n            ti[i] = arrival_time - li[0];\n            if (ti[i] < 1) ti[i] = 1;\n            if (ti[i] > 1000000000) ti[i] = 1000000000;\n        }\n    } else if (ti_type == \"random\") {\n        for (int i = 0; i < q; ++i)\n            ti[i] = rnd.next(1, 1000000000);\n    } else {\n        // Default to random\n        for (int i = 0; i < q; ++i)\n            ti[i] = rnd.next(1, 1000000000);\n    }\n\n    // Output n, g, r\n    cout << n << ' ' << g << ' ' << r << '\\n';\n\n    // Output li[0..n]\n    for (int i = 0; i <= n; ++i) {\n        cout << li[i];\n        if (i != n)\n            cout << ' ';\n        else\n            cout << '\\n';\n    }\n\n    // Output q\n    cout << q << '\\n';\n\n    // Output ti[0..q-1]\n    for (int i = 0; i < q; ++i)\n        cout << ti[i] << '\\n';\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal test case\n./gen -n 1 -q 1 -g 1 -r 1 -li_type constant -L 1 -ti_type constant -T 1\n\n# Small test cases with constant li and ti\n./gen -n 10 -q 10 -g 5 -r 5 -li_type constant -L 10 -ti_type constant -T 1\n./gen -n 10 -q 10 -g 5 -r 5 -li_type constant -L 1000000000 -ti_type constant -T 1000000000\n\n# Small test cases with random li and ti\n./gen -n 10 -q 10 -g 5 -r 5 -li_type random -ti_type random\n\n# Test case where buses always have to wait at intersections\n./gen -n 1000 -q 1000 -g 1 -r 1000 -li_type constant -L 1 -ti_type constant -T 1\n\n# Test case where buses never wait at intersections\n./gen -n 1000 -q 1000 -g 1000 -r 1 -li_type constant -L 1 -ti_type constant -T 1\n\n# Test case with alternating li\n./gen -n 1000 -q 1000 -g 500 -r 500 -li_type alternating -L1 1 -L2 1000000000 -ti_type increasing -ti_start 1 -ti_step 1\n\n# Test case with small_large li\n./gen -n 1000 -q 1000 -g 500 -r 500 -li_type small_large -L_small 1 -L_large 1000000000 -ti_type random\n\n# Test case with aligned ti to traffic light cycles\n./gen -n 1000 -q 1000 -g 500 -r 500 -li_type random -ti_type aligned\n\n# Maximal n and q with random li and ti\n./gen -n 100000 -q 100000 -g 500000000 -r 500000000 -li_type random -ti_type random\n\n# Test case with maximal g and minimal r\n./gen -n 100000 -q 100000 -g 1000000000 -r 1 -li_type constant -L 1000 -ti_type increasing -ti_start 1 -ti_step 1\n\n# Test case with minimal g and maximal r\n./gen -n 100000 -q 100000 -g 1 -r 1000000000 -li_type constant -L 1000 -ti_type increasing -ti_start 1 -ti_step 1\n\n# Test case where buses arrive at intersections exactly when lights turn red\n./gen -n 1000 -q 1000 -g 500 -r 500 -li_type constant -L 1 -ti_type aligned -k_start 0\n\n# Test case where buses arrive at intersections exactly when lights turn green\n./gen -n 1000 -q 1000 -g 500 -r 500 -li_type constant -L 1 -ti_type aligned -k_start 1\n\n# Test case with large li and ti values\n./gen -n 100000 -q 100000 -g 500000000 -r 500000000 -li_type constant -L 1000000000 -ti_type constant -T 1000000000\n\n# Test case where buses depart at random times\n./gen -n 100000 -q 100000 -g 500000000 -r 500000000 -li_type random -ti_type random\n\n# Test case with buses departing at maximum time\n./gen -n 100000 -q 100000 -g 500000000 -r 500000000 -li_type random -ti_type constant -T 1000000000\n\n# Test case with li alternating between small and large values\n./gen -n 100000 -q 100000 -g 500000000 -r 500000000 -li_type alternating -L1 1 -L2 1000000000 -ti_type random\n\n# Test case with ti increasing rapidly\n./gen -n 100000 -q 100000 -g 500000000 -r 500000000 -li_type random -ti_type increasing -ti_start 1 -ti_step 10000\n\n# Test case with all buses starting at time 1\n./gen -n 100000 -q 100000 -g 500000000 -r 500000000 -li_type random -ti_type constant -T 1\n\n# Test case with minimal li values\n./gen -n 100000 -q 100000 -g 500000000 -r 500000000 -li_type constant -L 1 -ti_type random\n\n# Test case with maximal li values\n./gen -n 100000 -q 100000 -g 500000000 -r 500000000 -li_type constant -L 1000000000 -ti_type random\n\n# Test case with g + r at its minimum allowed value (2)\n./gen -n 1000 -q 1000 -g 1 -r 1 -li_type random -ti_type random\n\n# Test case with g + r at its maximum allowed value (1e9)\n./gen -n 1000 -q 1000 -g 500000000 -r 500000000 -li_type random -ti_type random\n\n# Test case with n = 1e5, q = 1e5, random li and ti\n./gen -n 100000 -q 100000 -g 500000000 -r 500000000 -li_type random -ti_type random\n\n# Test case with n = 1e5 but q = 1\n./gen -n 100000 -q 1 -g 500000000 -r 500000000 -li_type random -ti_type random\n\n# Test case with n = 1, q = 1e5\n./gen -n 1 -q 100000 -g 500000000 -r 500000000 -li_type random -ti_type random\n\n# Test case with ti decreasing (should not happen, but let's test increasing with negative step)\n./gen -n 1000 -q 1000 -g 500 -r 500 -li_type random -ti_type increasing -ti_start 1000000000 -ti_step -1\n\n# Test case with buses departing at exact multiples of the cycle time\n./gen -n 1000 -q 1000 -g 500 -r 500 -li_type constant -L 1 -ti_type aligned -k_start 0\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:39.460811",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "187/E",
      "title": "E. Heaven Tour",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains three space-separated integers n, l, s (2 ≤ n ≤ 105, 0 ≤ l < n, 1 ≤ s ≤ n) — the number of people to visit, the number left tickets PMP got, and initial location of PMP. Next line contains n space-separated integers. The i-th integer in this line is xi (0 = x1 < x2 < ... < xn ≤ 109) — the location of i-th man.",
      "output_spec": "OutputIf PMP cannot visit all men with the tickets he got print -1 in the only line of output. Otherwise, in the first line you should print the minimum time PMP can visit all men. In the second line you should print n - 1 integers that are the numbers of the men that PMP should visit in order in one optimal solution. If there are multiple answers, output any of them.Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy5 2 20 10 11 21 22OutputCopy331 3 5 4InputCopy4 3 10 1 2 3OutputCopy-1InputCopy7 3 20 100 200 201 301 303 305OutputCopy4091 3 4 7 6 5",
      "description": "E. Heaven Tour\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains three space-separated integers n, l, s (2 ≤ n ≤ 105, 0 ≤ l < n, 1 ≤ s ≤ n) — the number of people to visit, the number left tickets PMP got, and initial location of PMP. Next line contains n space-separated integers. The i-th integer in this line is xi (0 = x1 < x2 < ... < xn ≤ 109) — the location of i-th man.\n\nOutputIf PMP cannot visit all men with the tickets he got print -1 in the only line of output. Otherwise, in the first line you should print the minimum time PMP can visit all men. In the second line you should print n - 1 integers that are the numbers of the men that PMP should visit in order in one optimal solution. If there are multiple answers, output any of them.Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.\n\nInputCopy5 2 20 10 11 21 22OutputCopy331 3 5 4InputCopy4 3 10 1 2 3OutputCopy-1InputCopy7 3 20 100 200 201 301 303 305OutputCopy4091 3 4 7 6 5\n\nInputCopy5 2 20 10 11 21 22\n\nOutputCopy331 3 5 4\n\nInputCopy4 3 10 1 2 3\n\nOutputCopy-1\n\nInputCopy7 3 20 100 200 201 301 303 305\n\nOutputCopy4091 3 4 7 6 5\n\nNoteLet us remind here, a great contestant of all times, who left us about a year ago. May Renat Mullakhanov rest in peace.",
      "solutions": [
        {
          "title": "Codeforces Round #119 - Codeforces",
          "content": "Hello everyone,We are glad to invite you to participate in today’s round. Problems have been prepared by poopi, Mohammad_JRS, Gerald and me. The hero of our contest is called “PMP”. It is actually the base of our team name through the last five years. The stories are metaphoric, but they have some traces in truth.This Codeforces round, is the last round before the incoming ICPC world final. Our best wishes for all participants of that contest, too. I want to specially thank Gerald for his helps and advices in problem preparation, Delinur for translation of statements into Russian and MikeMirzayanov for this great system.And we have a modified version of Burunduk1 ’s advice: “to make the round even more interesting for us, read the statements of ALL problems.” :)We hope you enjoy the problems and have high ratings.Update: Contest is over. Thanks to everyone for taking part and congratulations to the winners of both divisions, specially peter50216 for being the only who solved all the problems of division 1! :)Update: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4520",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1041
        },
        {
          "title": "Codeforces Round #119 — Editorial - Codeforces",
          "content": "Problem 189A — Cut RibbonThe problem is to maximize x+y+z subject to ax+by+cz=n. Constraints are low, so simply iterate over two variables (say x and y) and find the third variable (if any) from the second equation. Find the maximum over all feasible solutions.Other approaches: Use dynamic programming with each state being the remainder of ribbon. Select the next piece to be a, b or c.Problem 189B — Counting RhombiObserve that lots of rhombi have the same shape, but are in different locations. What uniquely determines the shape of a rhombus? Its width and its height. Is it possible to build a rhombus with every width and every height such that the vertices of the rhombus are in integer points? No, it is possible only if the width and the height are both even.How many places we can put a rhombus of width w0 and height h0 in a rectangle of width w and height h? (w * w0 + 1)(h * h0 + 1)So, iterator over all even widths and heights and for each of them add the number of possible locations to the final result.Problem 187A — PermutationsIt is easy to see that if we replace each number in the first permutation with position of that number in the second permutation, the problem reduces to sorting the first permutation.Each time we take a number from the end of array, we can postpone its insertion until we know the most suitable position for insertion. Note that it is not good to insert a number and take it again, as we could make a better decision first time we took the number. So, as long as the remainder of the array is not in increasing order, we should take more numbers from the end. But as soon as you have an increasing subsequence, you can insert the numbers you have taken to make the array sorted. Therefore to solve the problem, we find the largest i such the numbers from 1 to i are in increasing order. The answer would be n-i.Problem 187B — AlgoRaceFirst we solve the problem when the number of allowed car changes is zero (_k=0_). Let W(i,j,l) be the length of shortest path from i to j with car l. We use Floyd-Warshal on graph of each car to find this value. Then answer for the case that we can use only one car for each pair of cities i and j is:ans(0,i,j) = min W(i,j,l) for (_1≤l≤m_)This part has time complexity O(m*n^3).For larger values of maximum number of changes (_k_), we use the following equation:ans(k,i,j) = min (ans(k-1,i,l)+ans(0,l,j)) for (_1≤l≤k_)which can be computed in O(k*n^3) using dynamic programming.But how large can be k in worst case? We know that shortest paths are simple paths (i.e. they have no repeated vertices). Because otherwise we could eliminate the path we go between two appearances of one vertex and have a smaller result. This and the fact that we change the car at most once in each vertex, guarantees in any optimal solution we will not need more that n car changes. Thus the order of the solution would be O(m*n^3+n^4).Problem 187C — Weak MemoryThere were many different correct approaches to this problem during the contest. But I will explain author’s solution.First we can use binary search over the value of q. Now for a fixed q we want to check s-t connectivity.Let K be the set of all intersections with volunteers union s and t. One can use BFS from each k∈K, one by one. Then build a graph G’ with vertices K. For each two vertices k1,k2∈K add an edge between them, if their shortest distance is less than or equal to q. Finally use any path finding algorithm to check the connectivity. Unfortunately this solution has time (and space) complexity of O(|K|*m) which is not good enough.We can optimize the above solution by initiating BFS from all k∈K at once. In other words during the initialization step in BFS algorithm, we push all these vertices in the queue with distance 0. Each element in the queue also maintains its source (i.e. the source it is originating from). In BFS each time we have have a vertex u with source su and we want to set the minimum distance to a vertex v that is already set from a different path with source sv, we connect su and sv in G’ if d(u)+d(v)+1<= q, where d(x) denotes length of the shortest path from a vertex in K to x. As we are only dealing with connectivity, this approach is correct. (Proof of correctness is left as an exercise)BFS takes O(m) time and we add at most O(m) edges to G’, so the overall complexity is O(m) for a fixed q. As we used binary search to find the smallest q, we can solve the problem in O(m*logn).Problem 187D — BRT ContractWe define ti as follows: assume a bus starts moving from i-th intersection exactly at the time when the light changes to green. The time it takes for the bus to get the final station is ti. We call the times when a green interval begins t0 (so every g+r seconds t0 occurs once)If a bus gets to i-th intersection during the red phase, it should wait and then start moving at t0. So considering the fact that all lights are synchronized (and length of segments are fixed) if we have ti for i-th intersection, we can compute the time for the bus to get final station.Clearly tn is the length of the last segments. For computing ti we should find the smallest j such that if a bus starts at t0 from i-th intersection, it gets to j-th intersection during the red phase. So we have:ti=tj+d(i,j)+wwhere d(i,j) is the distance between i-th and j-th intersections and w is the time that the bus should wait behind the red light at j-th intersection. The later value can be computed easily.The only problem that remains is to find j for i-th intersection. So we start iterating over i for (n-1)-th intersection backwards and we compute ti for all intersections. Assume p=g+r and ta=d(i,j)%p. Now if the bus starts from i-th intersection at time t0 and we have ta>=g, in this case we are in red phase at j-th intersection. Actually ta should be in interval [_g, g+r_). Here we can use segment trees. That is for all intersections from i+1 to n, we store some values in the tree that helps us find the smallest j. But we should note the value of ta depends on d(i,j) which changes as i changes. Thus we cannot use ta in the tree. Instead, we define si the be the distance of i-th intersection to the destination. So we have d(i,j)=si-sj and we use the value of sj with storing –sj%p in the segment tree as the key and the value would be j itself. In other words for each intersection we store the key-value pair (-sj%p, j) in the tree. According to what we said so far, to be in the red phase at j-th intersection we should have:ta=(d(i,j)%p)=((si-sj)%p)∈[g,g+r) => -sj%p ∈ [(g-si)%p, (g+r-si)%p)As we stored –sj%p in the tree, we can retrieve the smallest j in the above interval with a query in the segment tree. This way we can compute ti for all intersections. Answering to each query in the problem can be solve in exactly the same way. So the overall complexity would be O((n+q)logn).Problem 187E — Heaven TourStep 1. Solve the problem if the starting man is the leftmost man and the finishing man is the rightmost man.Obviously every segment (the distance between two consecutive men) should be covered at least once. We also argue that at least l (the number of left tickets) segments should be covered at least three times. Proof: Each time you use a left ticket to go to man i with 1<i<n-1, the segment between i-th and (_i+1_)-th men is covered at least three times: Once for you should go after i be in a position to come back. Once for you use a left ticked to come back to i And once again you should go after i, because you want to finish at man number n Note that in the first and the last segments are always covered once, no matter what we do. But except for these two segments, every other segment can be chosen to be among the segments that are covered three times, and every combination that we choose l segments is feasible. (Proof it as practice) So we choose the smallest l segments and the problem can be solved with a simple sort in O(n*logn).Step 2. Solve the problem if the starting man is the leftmost man, but the finishing man can be anywhere.To solve this problem we first fix the finishing man. With reasoning similar to that of step 1, we conclude that at least l segments should be covered with at least two times if they are after the finishing man or three times if they are before him. But obviously every segment after the finishing man is covered at least two times. So it is always good to waste as many left tickets as possible after the finishing man to prevent them from breaching the left side of finishing man and becoming multiple three.So the algorithm would be: iterate over i, the number of finishing man, and maintain the l-(n-i) smallest segments to the right of finishing man as you progress. This can be implemented in O(n*logn).Step 3. Solve the problem if the starting man is fixed, but the finishing man can be anywhere.Assume that the starting man is not the first man or the last man, otherwise we could use algorithm of step 2 to solve the problem. Without loss of generality assume that you finish your tour to the right side of finishing man. Therefore every segment to the left of starting man is covered at least two times and actually it is always possible to arrange visits such that every segment to right is covered exactly two times. So just like what we said in step 2, it is good to waste as many left tickets as possible in this area.So the algorithm would be, choose to finish left or right first, then greedily waste as many bad moves (by bad moves I mean the moves that if breach to the other side will be more costly) as possible there and follow the algorithm in step 2 to solve the whole problem.There are some special cases such as when the tour cannot be finished at all, that we left to readers find a way how to handle them.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4540",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 187\\s*E"
          },
          "content_length": 9777
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #119 - Codeforces - Code 1",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 2",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 3",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 4",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 5",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 6",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(0, n - 1, \"l\");\n    inf.readSpace();\n    int s = inf.readInt(1, n, \"s\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 0, 1000000000, \"x\");\n    inf.readEoln();\n\n    for (int i = 0; i < n - 1; ++i) {\n        ensuref(x[i] < x[i + 1], \"x[%d]=%d should be less than x[%d]=%d\", i + 1, x[i], i + 2, x[i + 1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(0, n - 1, \"l\");\n    inf.readSpace();\n    int s = inf.readInt(1, n, \"s\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 0, 1000000000, \"x\");\n    inf.readEoln();\n\n    for (int i = 0; i < n - 1; ++i) {\n        ensuref(x[i] < x[i + 1], \"x[%d]=%d should be less than x[%d]=%d\", i + 1, x[i], i + 2, x[i + 1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(0, n - 1, \"l\");\n    inf.readSpace();\n    int s = inf.readInt(1, n, \"s\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 0, 1000000000, \"x\");\n    inf.readEoln();\n\n    for (int i = 0; i < n - 1; ++i) {\n        ensuref(x[i] < x[i + 1], \"x[%d]=%d should be less than x[%d]=%d\", i + 1, x[i], i + 2, x[i + 1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const long long INF = LLONG_MAX;\n\nint n, l, s;\nvector<long long> x; // coordinates\n\n// Read and check one solution (either from jury's answer or participant's output).\n// If the solution is \"-1\", return -1. Otherwise, verify feasibility and compute its time.\n// If infeasible, it quits with _wa (or _fail if we're checking the jury's answer).\nlong long readSolution(InStream &stream)\n{\n    // Attempt to read a token (it can be either \"-1\" or the minimal time).\n    string firstToken = stream.readToken();\n    if (firstToken == \"-1\")\n    {\n        // If solution claims no way to visit everyone, return -1\n        return -1;\n    }\n\n    // Otherwise, the first token must be the minimal time\n    long long solTime = stringToLongLong(stream, firstToken);\n\n    // Now read n - 1 men in visiting order\n    vector<int> route(n - 1);\n    for (int i = 0; i < n - 1; i++)\n    {\n        route[i] = stream.readInt(1, n, format(\"route[%d]\", i + 1).c_str());\n    }\n\n    // Check distinctness, ticket usage, and the calculated time:\n    vector<bool> used(n + 1, false);\n    used[s] = true; // start from s\n    for (int man : route)\n    {\n        if (used[man])\n        {\n            stream.quitf(_wa, \"man %d is visited more than once\", man);\n        }\n        used[man] = true;\n        if (man == s)\n        {\n            stream.quitf(_wa, \"the output route must not include the starting man %d again\", s);\n        }\n    }\n\n    long long totalDist = 0;\n    int usedLeft = 0, usedRight = 0;\n    int cur = s;\n    for (int nxt : route)\n    {\n        long long dist = llabs(x[cur - 1] - x[nxt - 1]);\n        totalDist += dist;\n        if (x[nxt - 1] < x[cur - 1])\n            usedLeft++;\n        else\n            usedRight++;\n        cur = nxt;\n    }\n\n    if (usedLeft > l)\n    {\n        stream.quitf(_wa, \"too many left moves: used %d, available %d\", usedLeft, l);\n    }\n    if (usedRight > (n - 1 - l))\n    {\n        stream.quitf(_wa, \"too many right moves: used %d, available %d\", usedRight, (n - 1 - l));\n    }\n\n    // Compare with the printed solution time\n    if (totalDist != solTime)\n    {\n        stream.quitf(_wa,\n            \"the printed answer time (%lld) does not match the actual computed time (%lld)\",\n            solTime, totalDist);\n    }\n\n    return solTime;\n}\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read input\n    n = inf.readInt();\n    l = inf.readInt();\n    s = inf.readInt();\n    x.resize(n);\n    for (int i = 0; i < n; i++)\n    {\n        x[i] = inf.readLong();\n    }\n\n    // Read the jury's (correct) answer\n    long long juryTime = -1;\n    ans.seekEof();\n    if (!ans.eof())\n    {\n        ans.reset();\n        juryTime = readSolution(ans);\n    }\n\n    // Read the participant's output\n    if (ouf.eof())\n    {\n        // Participant output is empty\n        quitf(_wa, \"no output\");\n    }\n\n    // Attempt to read participant's first token; it might be -1 or a time\n    string firstToken = ouf.readToken();\n    if (firstToken == \"-1\")\n    {\n        // Participant claims no solution\n        if (juryTime == -1)\n        {\n            // Both say no solution\n            quitf(_ok, \"both official answer and participant's answer are -1\");\n        }\n        else\n        {\n            // Jury found a valid solution, participant did not\n            quitf(_wa, \"jury has a valid solution but participant printed -1\");\n        }\n    }\n    else\n    {\n        // Participant presumably found a valid solution\n        long long partTime = stringToLongLong(ouf, firstToken);\n\n        // Read exactly n - 1 men\n        vector<int> route(n - 1);\n        for (int i = 0; i < n - 1; i++)\n        {\n            route[i] = ouf.readInt(1, n, format(\"route[%d]\", i + 1).c_str());\n        }\n\n        // Verify tickets and compute time\n        vector<bool> used(n + 1, false);\n        used[s] = true;\n        long long computedTime = 0;\n        int usedLeft = 0, usedRight = 0;\n        int cur = s;\n        for (int nxt : route)\n        {\n            if (used[nxt])\n            {\n                quitf(_wa, \"man %d is visited more than once in participant's solution\", nxt);\n            }\n            used[nxt] = true;\n            long long dist = llabs(x[cur - 1] - x[nxt - 1]);\n            computedTime += dist;\n            if (x[nxt - 1] < x[cur - 1])\n                usedLeft++;\n            else\n                usedRight++;\n            cur = nxt;\n        }\n\n        if (usedLeft > l)\n        {\n            quitf(_wa, \"too many left moves in participant's answer: used %d, available %d\", usedLeft, l);\n        }\n        if (usedRight > (n - 1 - l))\n        {\n            quitf(_wa, \"too many right moves in participant's answer: used %d, available %d\",\n                  usedRight, (n - 1 - l));\n        }\n\n        if (computedTime != partTime)\n        {\n            quitf(_wa,\n                  \"the printed answer time (%lld) doesn't match the actual computed time (%lld)\",\n                  partTime, computedTime);\n        }\n\n        // Compare with juryTime\n        if (juryTime == -1)\n        {\n            // Jury says no solution, participant found one\n            quitf(_fail, \"participant's valid solution (time = %lld) but jury's answer is -1\", computedTime);\n        }\n        else\n        {\n            // Both solutions are valid\n            if (partTime > juryTime)\n            {\n                quitf(_wa, \"participant's answer is worse than jury's: jury = %lld, participant = %lld\",\n                      juryTime, partTime);\n            }\n            else if (partTime == juryTime)\n            {\n                quitf(_ok, \"correct solution with time = %lld\", partTime);\n            }\n            else\n            {\n                quitf(_fail, \"participant's answer is better (%lld) than jury's (%lld)\",\n                      partTime, juryTime);\n            }\n        }\n    }\n\n    // Should not reach here in normal flow\n    quitf(_fail, \"unexpected end of checker\");\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\", -1);  // Set default to -1 to detect if not specified\n    int s = opt<int>(\"s\", -1);  // Set default to -1\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check parameters\n    ensure(2 <= n && n <= 100000);\n\n    // Set l and s as per type\n    if (type == \"leftonly\") {\n        l = n -1;\n        if (s == -1)\n            s = n;\n    } else if (type == \"rightonly\") {\n        l = 0;\n        if (s == -1)\n            s = 1;\n    } else if (type == \"impossible\") {\n        l = 0;\n        s = n;\n    } else {\n        if (l == -1)\n            l = rnd.next(0, n -1);\n        if (s == -1)\n            s = rnd.next(1, n);\n    }\n\n    ensure(0 <= l && l < n);\n    ensure(1 <= s && s <= n);\n\n    vector<int> xi(n);\n    const int MAXX = int(1e9);\n\n    if (type == \"random\") {\n        // Generate xi[0..n-1] as per the random method\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(0, MAXX - n);\n        sort(xi.begin(), xi.end());\n        for (int i = 0; i < n; ++i)\n            xi[i] += i + 1; // xi[i] >= i+1, xi[i] < xi[i+1]\n    } else if (type == \"min\") {\n        // xi[i] = i\n        for (int i = 0; i < n; ++i)\n            xi[i] = i;\n    } else if (type == \"max\") {\n        // xi[i] spread to maximum\n        for (int i = 0; i < n; ++i)\n            xi[i] = (long long)i * MAXX / (n - 1);\n    } else if (type == \"onespacing\") {\n        int start = rnd.next(0, MAXX - n);\n        for (int i = 0; i < n; ++i)\n            xi[i] = start + i;\n    } else if (type == \"largegap\") {\n        int gap = MAXX / n;\n        int start = rnd.next(0, MAXX - n * gap);\n        for (int i = 0; i < n; ++i)\n            xi[i] = start + (long long)i * gap;\n    } else if (type == \"leftonly\") {\n        // xi decreasing\n        for (int i = 0; i < n; ++i)\n            xi[i] = MAXX - i;\n        reverse(xi.begin(), xi.end());\n    } else if (type == \"rightonly\") {\n        // xi increasing\n        for (int i = 0; i < n; ++i)\n            xi[i] = i;\n    } else if (type == \"impossible\") {\n        // Construct an impossible case\n        for (int i = 0; i < n; ++i)\n            xi[i] = i;\n    } else if (type == \"start_leftmost\") {\n        // s = 1\n        s = 1;\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(0, MAXX - n);\n        sort(xi.begin(), xi.end());\n        for (int i = 0; i < n; ++i)\n            xi[i] += i + 1;\n    } else if (type == \"start_rightmost\") {\n        // s = n\n        s = n;\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(0, MAXX - n);\n        sort(xi.begin(), xi.end());\n        for (int i = 0; i < n; ++i)\n            xi[i] += i + 1;\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(0, MAXX - n);\n        sort(xi.begin(), xi.end());\n        for (int i = 0; i < n; ++i)\n            xi[i] += i + 1; // xi[i] >= i+1, xi[i] < xi[i+1]\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, l, s);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", xi[i], (i == n - 1) ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\", -1);  // Set default to -1 to detect if not specified\n    int s = opt<int>(\"s\", -1);  // Set default to -1\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check parameters\n    ensure(2 <= n && n <= 100000);\n\n    // Set l and s as per type\n    if (type == \"leftonly\") {\n        l = n -1;\n        if (s == -1)\n            s = n;\n    } else if (type == \"rightonly\") {\n        l = 0;\n        if (s == -1)\n            s = 1;\n    } else if (type == \"impossible\") {\n        l = 0;\n        s = n;\n    } else {\n        if (l == -1)\n            l = rnd.next(0, n -1);\n        if (s == -1)\n            s = rnd.next(1, n);\n    }\n\n    ensure(0 <= l && l < n);\n    ensure(1 <= s && s <= n);\n\n    vector<int> xi(n);\n    const int MAXX = int(1e9);\n\n    if (type == \"random\") {\n        // Generate xi[0..n-1] as per the random method\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(0, MAXX - n);\n        sort(xi.begin(), xi.end());\n        for (int i = 0; i < n; ++i)\n            xi[i] += i + 1; // xi[i] >= i+1, xi[i] < xi[i+1]\n    } else if (type == \"min\") {\n        // xi[i] = i\n        for (int i = 0; i < n; ++i)\n            xi[i] = i;\n    } else if (type == \"max\") {\n        // xi[i] spread to maximum\n        for (int i = 0; i < n; ++i)\n            xi[i] = (long long)i * MAXX / (n - 1);\n    } else if (type == \"onespacing\") {\n        int start = rnd.next(0, MAXX - n);\n        for (int i = 0; i < n; ++i)\n            xi[i] = start + i;\n    } else if (type == \"largegap\") {\n        int gap = MAXX / n;\n        int start = rnd.next(0, MAXX - n * gap);\n        for (int i = 0; i < n; ++i)\n            xi[i] = start + (long long)i * gap;\n    } else if (type == \"leftonly\") {\n        // xi decreasing\n        for (int i = 0; i < n; ++i)\n            xi[i] = MAXX - i;\n        reverse(xi.begin(), xi.end());\n    } else if (type == \"rightonly\") {\n        // xi increasing\n        for (int i = 0; i < n; ++i)\n            xi[i] = i;\n    } else if (type == \"impossible\") {\n        // Construct an impossible case\n        for (int i = 0; i < n; ++i)\n            xi[i] = i;\n    } else if (type == \"start_leftmost\") {\n        // s = 1\n        s = 1;\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(0, MAXX - n);\n        sort(xi.begin(), xi.end());\n        for (int i = 0; i < n; ++i)\n            xi[i] += i + 1;\n    } else if (type == \"start_rightmost\") {\n        // s = n\n        s = n;\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(0, MAXX - n);\n        sort(xi.begin(), xi.end());\n        for (int i = 0; i < n; ++i)\n            xi[i] += i + 1;\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i)\n            xi[i] = rnd.next(0, MAXX - n);\n        sort(xi.begin(), xi.end());\n        for (int i = 0; i < n; ++i)\n            xi[i] += i + 1; // xi[i] >= i+1, xi[i] < xi[i+1]\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, l, s);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", xi[i], (i == n - 1) ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -l 0 -s 1 -type random\n./gen -n 2 -l 1 -s 2 -type impossible\n\n./gen -n 10 -l 0 -s 1 -type rightonly\n./gen -n 10 -l 9 -s 10 -type leftonly\n\n./gen -n 10 -l 5 -s 5 -type random\n./gen -n 10 -l 5 -s 5 -type largegap\n./gen -n 10 -l 5 -s 5 -type onespacing\n\n./gen -n 1000 -l 0 -s 1 -type rightonly\n./gen -n 1000 -l 999 -s 1000 -type leftonly\n\n./gen -n 1000 -l 500 -s 500 -type random\n./gen -n 1000 -l 500 -s 500 -type largegap\n./gen -n 1000 -l 500 -s 500 -type onespacing\n\n./gen -n 100000 -l 0 -s 1 -type rightonly\n./gen -n 100000 -l 99999 -s 100000 -type leftonly\n\n./gen -n 100000 -l 50000 -s 50000 -type random\n./gen -n 100000 -l 50000 -s 50000 -type largegap\n./gen -n 100000 -l 50000 -s 50000 -type onespacing\n\n./gen -n 100000 -l 0 -s 1 -type start_leftmost\n./gen -n 100000 -l 0 -s 100000 -type impossible\n./gen -n 100000 -l 0 -s 100000 -type rightonly\n\n./gen -n 100000 -l 0 -s 1 -type impossible\n./gen -n 100000 -l 99999 -s 1 -type impossible\n\n./gen -n 50000 -l 0 -s 50000 -type impossible\n./gen -n 50000 -l 50000 -s 1 -type impossible\n\n./gen -n 100000 -l 0 -s 50000 -type random\n./gen -n 100000 -l 99999 -s 50000 -type random\n\n./gen -n 100000 -l 25000 -s 25000 -type min\n./gen -n 100000 -l 75000 -s 75000 -type max\n\n./gen -n 99999 -l 49999 -s 50000 -type random\n\n./gen -n 2 -l 0 -s 2 -type impossible\n./gen -n 2 -l 1 -s 1 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:41.059082",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "189/A",
      "title": "A. Cut Ribbon",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four space-separated integers n, a, b and c (1 ≤ n, a, b, c ≤ 4000) — the length of the original ribbon and the acceptable lengths of the ribbon pieces after the cutting, correspondingly. The numbers a, b and c can coincide.",
      "output_spec": "OutputPrint a single number — the maximum possible number of ribbon pieces. It is guaranteed that at least one correct ribbon cutting exists.",
      "sample_tests": "ExamplesInputCopy5 5 3 2OutputCopy2InputCopy7 5 5 2OutputCopy2",
      "description": "A. Cut Ribbon\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains four space-separated integers n, a, b and c (1 ≤ n, a, b, c ≤ 4000) — the length of the original ribbon and the acceptable lengths of the ribbon pieces after the cutting, correspondingly. The numbers a, b and c can coincide.\n\nOutputPrint a single number — the maximum possible number of ribbon pieces. It is guaranteed that at least one correct ribbon cutting exists.\n\nInputCopy5 5 3 2OutputCopy2InputCopy7 5 5 2OutputCopy2\n\nInputCopy5 5 3 2\n\nOutputCopy2\n\nInputCopy7 5 5 2\n\nOutputCopy2\n\nNoteIn the first example Polycarpus can cut the ribbon in such way: the first piece has length 2, the second piece has length 3.In the second example Polycarpus can cut the ribbon in such way: the first piece has length 5, the second piece has length 2.",
      "solutions": [
        {
          "title": "Codeforces Round #119 - Codeforces",
          "content": "Hello everyone,We are glad to invite you to participate in today’s round. Problems have been prepared by poopi, Mohammad_JRS, Gerald and me. The hero of our contest is called “PMP”. It is actually the base of our team name through the last five years. The stories are metaphoric, but they have some traces in truth.This Codeforces round, is the last round before the incoming ICPC world final. Our best wishes for all participants of that contest, too. I want to specially thank Gerald for his helps and advices in problem preparation, Delinur for translation of statements into Russian and MikeMirzayanov for this great system.And we have a modified version of Burunduk1 ’s advice: “to make the round even more interesting for us, read the statements of ALL problems.” :)We hope you enjoy the problems and have high ratings.Update: Contest is over. Thanks to everyone for taking part and congratulations to the winners of both divisions, specially peter50216 for being the only who solved all the problems of division 1! :)Update: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4520",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1041
        },
        {
          "title": "Codeforces Round #119 — Editorial - Codeforces",
          "content": "Problem 189A — Cut RibbonThe problem is to maximize x+y+z subject to ax+by+cz=n. Constraints are low, so simply iterate over two variables (say x and y) and find the third variable (if any) from the second equation. Find the maximum over all feasible solutions.Other approaches: Use dynamic programming with each state being the remainder of ribbon. Select the next piece to be a, b or c.Problem 189B — Counting RhombiObserve that lots of rhombi have the same shape, but are in different locations. What uniquely determines the shape of a rhombus? Its width and its height. Is it possible to build a rhombus with every width and every height such that the vertices of the rhombus are in integer points? No, it is possible only if the width and the height are both even.How many places we can put a rhombus of width w0 and height h0 in a rectangle of width w and height h? (w * w0 + 1)(h * h0 + 1)So, iterator over all even widths and heights and for each of them add the number of possible locations to the final result.Problem 187A — PermutationsIt is easy to see that if we replace each number in the first permutation with position of that number in the second permutation, the problem reduces to sorting the first permutation.Each time we take a number from the end of array, we can postpone its insertion until we know the most suitable position for insertion. Note that it is not good to insert a number and take it again, as we could make a better decision first time we took the number. So, as long as the remainder of the array is not in increasing order, we should take more numbers from the end. But as soon as you have an increasing subsequence, you can insert the numbers you have taken to make the array sorted. Therefore to solve the problem, we find the largest i such the numbers from 1 to i are in increasing order. The answer would be n-i.Problem 187B — AlgoRaceFirst we solve the problem when the number of allowed car changes is zero (_k=0_). Let W(i,j,l) be the length of shortest path from i to j with car l. We use Floyd-Warshal on graph of each car to find this value. Then answer for the case that we can use only one car for each pair of cities i and j is:ans(0,i,j) = min W(i,j,l) for (_1≤l≤m_)This part has time complexity O(m*n^3).For larger values of maximum number of changes (_k_), we use the following equation:ans(k,i,j) = min (ans(k-1,i,l)+ans(0,l,j)) for (_1≤l≤k_)which can be computed in O(k*n^3) using dynamic programming.But how large can be k in worst case? We know that shortest paths are simple paths (i.e. they have no repeated vertices). Because otherwise we could eliminate the path we go between two appearances of one vertex and have a smaller result. This and the fact that we change the car at most once in each vertex, guarantees in any optimal solution we will not need more that n car changes. Thus the order of the solution would be O(m*n^3+n^4).Problem 187C — Weak MemoryThere were many different correct approaches to this problem during the contest. But I will explain author’s solution.First we can use binary search over the value of q. Now for a fixed q we want to check s-t connectivity.Let K be the set of all intersections with volunteers union s and t. One can use BFS from each k∈K, one by one. Then build a graph G’ with vertices K. For each two vertices k1,k2∈K add an edge between them, if their shortest distance is less than or equal to q. Finally use any path finding algorithm to check the connectivity. Unfortunately this solution has time (and space) complexity of O(|K|*m) which is not good enough.We can optimize the above solution by initiating BFS from all k∈K at once. In other words during the initialization step in BFS algorithm, we push all these vertices in the queue with distance 0. Each element in the queue also maintains its source (i.e. the source it is originating from). In BFS each time we have have a vertex u with source su and we want to set the minimum distance to a vertex v that is already set from a different path with source sv, we connect su and sv in G’ if d(u)+d(v)+1<= q, where d(x) denotes length of the shortest path from a vertex in K to x. As we are only dealing with connectivity, this approach is correct. (Proof of correctness is left as an exercise)BFS takes O(m) time and we add at most O(m) edges to G’, so the overall complexity is O(m) for a fixed q. As we used binary search to find the smallest q, we can solve the problem in O(m*logn).Problem 187D — BRT ContractWe define ti as follows: assume a bus starts moving from i-th intersection exactly at the time when the light changes to green. The time it takes for the bus to get the final station is ti. We call the times when a green interval begins t0 (so every g+r seconds t0 occurs once)If a bus gets to i-th intersection during the red phase, it should wait and then start moving at t0. So considering the fact that all lights are synchronized (and length of segments are fixed) if we have ti for i-th intersection, we can compute the time for the bus to get final station.Clearly tn is the length of the last segments. For computing ti we should find the smallest j such that if a bus starts at t0 from i-th intersection, it gets to j-th intersection during the red phase. So we have:ti=tj+d(i,j)+wwhere d(i,j) is the distance between i-th and j-th intersections and w is the time that the bus should wait behind the red light at j-th intersection. The later value can be computed easily.The only problem that remains is to find j for i-th intersection. So we start iterating over i for (n-1)-th intersection backwards and we compute ti for all intersections. Assume p=g+r and ta=d(i,j)%p. Now if the bus starts from i-th intersection at time t0 and we have ta>=g, in this case we are in red phase at j-th intersection. Actually ta should be in interval [_g, g+r_). Here we can use segment trees. That is for all intersections from i+1 to n, we store some values in the tree that helps us find the smallest j. But we should note the value of ta depends on d(i,j) which changes as i changes. Thus we cannot use ta in the tree. Instead, we define si the be the distance of i-th intersection to the destination. So we have d(i,j)=si-sj and we use the value of sj with storing –sj%p in the segment tree as the key and the value would be j itself. In other words for each intersection we store the key-value pair (-sj%p, j) in the tree. According to what we said so far, to be in the red phase at j-th intersection we should have:ta=(d(i,j)%p)=((si-sj)%p)∈[g,g+r) => -sj%p ∈ [(g-si)%p, (g+r-si)%p)As we stored –sj%p in the tree, we can retrieve the smallest j in the above interval with a query in the segment tree. This way we can compute ti for all intersections. Answering to each query in the problem can be solve in exactly the same way. So the overall complexity would be O((n+q)logn).Problem 187E — Heaven TourStep 1. Solve the problem if the starting man is the leftmost man and the finishing man is the rightmost man.Obviously every segment (the distance between two consecutive men) should be covered at least once. We also argue that at least l (the number of left tickets) segments should be covered at least three times. Proof: Each time you use a left ticket to go to man i with 1<i<n-1, the segment between i-th and (_i+1_)-th men is covered at least three times: Once for you should go after i be in a position to come back. Once for you use a left ticked to come back to i And once again you should go after i, because you want to finish at man number n Note that in the first and the last segments are always covered once, no matter what we do. But except for these two segments, every other segment can be chosen to be among the segments that are covered three times, and every combination that we choose l segments is feasible. (Proof it as practice) So we choose the smallest l segments and the problem can be solved with a simple sort in O(n*logn).Step 2. Solve the problem if the starting man is the leftmost man, but the finishing man can be anywhere.To solve this problem we first fix the finishing man. With reasoning similar to that of step 1, we conclude that at least l segments should be covered with at least two times if they are after the finishing man or three times if they are before him. But obviously every segment after the finishing man is covered at least two times. So it is always good to waste as many left tickets as possible after the finishing man to prevent them from breaching the left side of finishing man and becoming multiple three.So the algorithm would be: iterate over i, the number of finishing man, and maintain the l-(n-i) smallest segments to the right of finishing man as you progress. This can be implemented in O(n*logn).Step 3. Solve the problem if the starting man is fixed, but the finishing man can be anywhere.Assume that the starting man is not the first man or the last man, otherwise we could use algorithm of step 2 to solve the problem. Without loss of generality assume that you finish your tour to the right side of finishing man. Therefore every segment to the left of starting man is covered at least two times and actually it is always possible to arrange visits such that every segment to right is covered exactly two times. So just like what we said in step 2, it is good to waste as many left tickets as possible in this area.So the algorithm would be, choose to finish left or right first, then greedily waste as many bad moves (by bad moves I mean the moves that if breach to the other side will be more costly) as possible there and follow the algorithm in step 2 to solve the whole problem.There are some special cases such as when the tour cannot be finished at all, that we left to readers find a way how to handle them.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4540",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 189\\s*A"
          },
          "content_length": 9777
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #119 - Codeforces - Code 1",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 2",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 3",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 4",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 5",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 6",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 4000, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(1, 4000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 4000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 4000, \"c\");\n    inf.readEoln();\n\n    // Check that at least one correct ribbon cutting exists.\n    vector<int> dp(n + 1, -1);\n    dp[0] = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (i >= a && dp[i - a] != -1) {\n            dp[i] = max(dp[i], dp[i - a] + 1);\n        }\n        if (i >= b && dp[i - b] != -1) {\n            dp[i] = max(dp[i], dp[i - b] + 1);\n        }\n        if (i >= c && dp[i - c] != -1) {\n            dp[i] = max(dp[i], dp[i - c] + 1);\n        }\n    }\n    ensuref(dp[n] != -1, \"No valid ribbon cutting exists for n=%d, a=%d, b=%d, c=%d\", n, a, b, c);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 4000, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(1, 4000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 4000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 4000, \"c\");\n    inf.readEoln();\n\n    // Check that at least one correct ribbon cutting exists.\n    vector<int> dp(n + 1, -1);\n    dp[0] = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (i >= a && dp[i - a] != -1) {\n            dp[i] = max(dp[i], dp[i - a] + 1);\n        }\n        if (i >= b && dp[i - b] != -1) {\n            dp[i] = max(dp[i], dp[i - b] + 1);\n        }\n        if (i >= c && dp[i - c] != -1) {\n            dp[i] = max(dp[i], dp[i - c] + 1);\n        }\n    }\n    ensuref(dp[n] != -1, \"No valid ribbon cutting exists for n=%d, a=%d, b=%d, c=%d\", n, a, b, c);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 4000, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(1, 4000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 4000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 4000, \"c\");\n    inf.readEoln();\n\n    // Check that at least one correct ribbon cutting exists.\n    vector<int> dp(n + 1, -1);\n    dp[0] = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (i >= a && dp[i - a] != -1) {\n            dp[i] = max(dp[i], dp[i - a] + 1);\n        }\n        if (i >= b && dp[i - b] != -1) {\n            dp[i] = max(dp[i], dp[i - b] + 1);\n        }\n        if (i >= c && dp[i - c] != -1) {\n            dp[i] = max(dp[i], dp[i - c] + 1);\n        }\n    }\n    ensuref(dp[n] != -1, \"No valid ribbon cutting exists for n=%d, a=%d, b=%d, c=%d\", n, a, b, c);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    int a, b, c;\n\n    if (type == \"equal\") {\n        // a == b == c\n        a = b = c = rnd.next(1, 4000);\n        if (n == -1) {\n            n = a * rnd.next(1, 4000 / a);\n        } else {\n            n = a * max(1, n / a);  // Ensure that n is multiple of a\n            n = min(n, 4000);\n        }\n    } else if (type == \"ones\") {\n        // a == b == c ==1\n        a = b = c = 1;\n        if (n == -1) {\n            n = rnd.next(1, 4000);\n        } else {\n            n = min(max(n, 1), 4000);\n        }\n    } else if (type == \"max\") {\n        // a, b, c are maximum\n        a = b = c = 4000;\n        if (n == -1) n = 4000;\n        else n = min(max(n / a * a, a), 4000);\n    } else if (type == \"min\") {\n        // a, b, c are minimum\n        a = b = c = 1;\n        if (n == -1)\n            n = rnd.next(1, 4000);\n        else\n            n = min(max(n, 1), 4000);\n    } else if (type == \"random\" || type == \"max_n\") {\n        a = rnd.next(1, 4000);\n        b = rnd.next(1, 4000);\n        c = rnd.next(1, 4000);\n        if (n == -1 || n > 4000 || n < 1) n = rnd.next(1, 4000);\n        // Ensure that n can be formed by a,b,c\n        // Use DP\n        vector<int> dp(n+1, -1); // dp[i]: max number of pieces to get sum i\n        dp[0] = 0;\n        for(int i=1; i<=n; ++i) {\n            if (i >= a && dp[i-a] != -1)\n                dp[i] = max(dp[i], dp[i-a]+1);\n            if (i >= b && dp[i-b] != -1)\n                dp[i] = max(dp[i], dp[i-b]+1);\n            if (i >= c && dp[i-c] != -1)\n                dp[i] = max(dp[i], dp[i-c]+1);\n        }\n        if (dp[n]==-1) {\n            // Cannot form n, adjust n\n            for (int i = n; i >=1; --i) {\n                if (dp[i]!=-1) {\n                    n = i;\n                    break;\n                }\n            }\n            if (dp[n]==-1) n = a; // If all else fails\n        }\n    } else if (type == \"large_pieces\") {\n        // a, b, c are large\n        a = rnd.next(3000, 4000);\n        b = rnd.next(3000, 4000);\n        c = rnd.next(3000, 4000);\n        if (n == -1) {\n            int x = rnd.next(1, 1);\n            n = a * x;\n        } else {\n            n = a * max(1, n / a);\n            n = min(n, 4000);\n        }\n    } else if (type == \"small_pieces\") {\n        // a, b, c are small\n        a = rnd.next(1, 10);\n        b = rnd.next(1, 10);\n        c = rnd.next(1, 10);\n        if (n == -1 || n > 4000 || n < 1)\n            n = rnd.next(1, 4000);\n        // Ensure that n can be formed\n        vector<int> dp(n+1, -1);\n        dp[0]=0;\n        for(int i=1; i<=n; ++i) {\n            if(i>=a && dp[i-a]!=-1)\n                dp[i]=max(dp[i], dp[i-a]+1);\n            if(i>=b && dp[i-b]!=-1)\n                dp[i]=max(dp[i], dp[i-b]+1);\n            if(i>=c && dp[i-c]!=-1)\n                dp[i]=max(dp[i], dp[i-c]+1);\n        }\n        if(dp[n]==-1){\n            for (int i = n; i >=1; --i) {\n                if (dp[i]!=-1) {\n                    n = i;\n                    break;\n                }\n            }\n            if (dp[n]==-1) n = a; // If all else fails\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n a b c\n    printf(\"%d %d %d %d\\n\", n, a, b, c);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    int a, b, c;\n\n    if (type == \"equal\") {\n        // a == b == c\n        a = b = c = rnd.next(1, 4000);\n        if (n == -1) {\n            n = a * rnd.next(1, 4000 / a);\n        } else {\n            n = a * max(1, n / a);  // Ensure that n is multiple of a\n            n = min(n, 4000);\n        }\n    } else if (type == \"ones\") {\n        // a == b == c ==1\n        a = b = c = 1;\n        if (n == -1) {\n            n = rnd.next(1, 4000);\n        } else {\n            n = min(max(n, 1), 4000);\n        }\n    } else if (type == \"max\") {\n        // a, b, c are maximum\n        a = b = c = 4000;\n        if (n == -1) n = 4000;\n        else n = min(max(n / a * a, a), 4000);\n    } else if (type == \"min\") {\n        // a, b, c are minimum\n        a = b = c = 1;\n        if (n == -1)\n            n = rnd.next(1, 4000);\n        else\n            n = min(max(n, 1), 4000);\n    } else if (type == \"random\" || type == \"max_n\") {\n        a = rnd.next(1, 4000);\n        b = rnd.next(1, 4000);\n        c = rnd.next(1, 4000);\n        if (n == -1 || n > 4000 || n < 1) n = rnd.next(1, 4000);\n        // Ensure that n can be formed by a,b,c\n        // Use DP\n        vector<int> dp(n+1, -1); // dp[i]: max number of pieces to get sum i\n        dp[0] = 0;\n        for(int i=1; i<=n; ++i) {\n            if (i >= a && dp[i-a] != -1)\n                dp[i] = max(dp[i], dp[i-a]+1);\n            if (i >= b && dp[i-b] != -1)\n                dp[i] = max(dp[i], dp[i-b]+1);\n            if (i >= c && dp[i-c] != -1)\n                dp[i] = max(dp[i], dp[i-c]+1);\n        }\n        if (dp[n]==-1) {\n            // Cannot form n, adjust n\n            for (int i = n; i >=1; --i) {\n                if (dp[i]!=-1) {\n                    n = i;\n                    break;\n                }\n            }\n            if (dp[n]==-1) n = a; // If all else fails\n        }\n    } else if (type == \"large_pieces\") {\n        // a, b, c are large\n        a = rnd.next(3000, 4000);\n        b = rnd.next(3000, 4000);\n        c = rnd.next(3000, 4000);\n        if (n == -1) {\n            int x = rnd.next(1, 1);\n            n = a * x;\n        } else {\n            n = a * max(1, n / a);\n            n = min(n, 4000);\n        }\n    } else if (type == \"small_pieces\") {\n        // a, b, c are small\n        a = rnd.next(1, 10);\n        b = rnd.next(1, 10);\n        c = rnd.next(1, 10);\n        if (n == -1 || n > 4000 || n < 1)\n            n = rnd.next(1, 4000);\n        // Ensure that n can be formed\n        vector<int> dp(n+1, -1);\n        dp[0]=0;\n        for(int i=1; i<=n; ++i) {\n            if(i>=a && dp[i-a]!=-1)\n                dp[i]=max(dp[i], dp[i-a]+1);\n            if(i>=b && dp[i-b]!=-1)\n                dp[i]=max(dp[i], dp[i-b]+1);\n            if(i>=c && dp[i-c]!=-1)\n                dp[i]=max(dp[i], dp[i-c]+1);\n        }\n        if(dp[n]==-1){\n            for (int i = n; i >=1; --i) {\n                if (dp[i]!=-1) {\n                    n = i;\n                    break;\n                }\n            }\n            if (dp[n]==-1) n = a; // If all else fails\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n a b c\n    printf(\"%d %d %d %d\\n\", n, a, b, c);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type ones\n./gen -n 1 -type ones\n./gen -n 4000 -type ones\n./gen -n 100 -type ones\n\n./gen -type equal\n./gen -n 1 -type equal\n./gen -n 4000 -type equal\n./gen -n 800 -type equal\n\n./gen -n 1 -type max\n./gen -n 4000 -type max\n\n./gen -type random\n./gen -n 4000 -type random\n./gen -n 2000 -type random\n./gen -n 1 -type random\n\n./gen -type max_n\n\n./gen -type large_pieces\n./gen -n 4000 -type large_pieces\n./gen -n 3000 -type large_pieces\n\n./gen -type small_pieces\n./gen -n 4000 -type small_pieces\n./gen -n 1000 -type small_pieces\n\n./gen -n 50 -type random\n./gen -n 100 -type random\n./gen -n 150 -type random\n./gen -n 200 -type random\n./gen -n 500 -type random\n\n./gen -n 3998 -type random\n./gen -n 3997 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:43.313315",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "189/B",
      "title": "B. Counting Rhombi",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers w and h (1 ≤ w, h ≤ 4000) — the rectangle's sizes.",
      "output_spec": "OutputPrint a single number — the number of sought rhombi.Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy2 2OutputCopy1InputCopy1 2OutputCopy0",
      "description": "B. Counting Rhombi\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers w and h (1 ≤ w, h ≤ 4000) — the rectangle's sizes.\n\nOutputPrint a single number — the number of sought rhombi.Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.\n\nInputCopy2 2OutputCopy1InputCopy1 2OutputCopy0\n\nInputCopy2 2\n\nOutputCopy1\n\nInputCopy1 2\n\nOutputCopy0\n\nNoteIn the first example there exists only one such rhombus. Its vertices are located at points (1, 0), (2, 1), (1, 2), (0, 1).",
      "solutions": [
        {
          "title": "Codeforces Round #119 - Codeforces",
          "content": "Hello everyone,We are glad to invite you to participate in today’s round. Problems have been prepared by poopi, Mohammad_JRS, Gerald and me. The hero of our contest is called “PMP”. It is actually the base of our team name through the last five years. The stories are metaphoric, but they have some traces in truth.This Codeforces round, is the last round before the incoming ICPC world final. Our best wishes for all participants of that contest, too. I want to specially thank Gerald for his helps and advices in problem preparation, Delinur for translation of statements into Russian and MikeMirzayanov for this great system.And we have a modified version of Burunduk1 ’s advice: “to make the round even more interesting for us, read the statements of ALL problems.” :)We hope you enjoy the problems and have high ratings.Update: Contest is over. Thanks to everyone for taking part and congratulations to the winners of both divisions, specially peter50216 for being the only who solved all the problems of division 1! :)Update: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4520",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1041
        },
        {
          "title": "Codeforces Round #119 — Editorial - Codeforces",
          "content": "Problem 189A — Cut RibbonThe problem is to maximize x+y+z subject to ax+by+cz=n. Constraints are low, so simply iterate over two variables (say x and y) and find the third variable (if any) from the second equation. Find the maximum over all feasible solutions.Other approaches: Use dynamic programming with each state being the remainder of ribbon. Select the next piece to be a, b or c.Problem 189B — Counting RhombiObserve that lots of rhombi have the same shape, but are in different locations. What uniquely determines the shape of a rhombus? Its width and its height. Is it possible to build a rhombus with every width and every height such that the vertices of the rhombus are in integer points? No, it is possible only if the width and the height are both even.How many places we can put a rhombus of width w0 and height h0 in a rectangle of width w and height h? (w * w0 + 1)(h * h0 + 1)So, iterator over all even widths and heights and for each of them add the number of possible locations to the final result.Problem 187A — PermutationsIt is easy to see that if we replace each number in the first permutation with position of that number in the second permutation, the problem reduces to sorting the first permutation.Each time we take a number from the end of array, we can postpone its insertion until we know the most suitable position for insertion. Note that it is not good to insert a number and take it again, as we could make a better decision first time we took the number. So, as long as the remainder of the array is not in increasing order, we should take more numbers from the end. But as soon as you have an increasing subsequence, you can insert the numbers you have taken to make the array sorted. Therefore to solve the problem, we find the largest i such the numbers from 1 to i are in increasing order. The answer would be n-i.Problem 187B — AlgoRaceFirst we solve the problem when the number of allowed car changes is zero (_k=0_). Let W(i,j,l) be the length of shortest path from i to j with car l. We use Floyd-Warshal on graph of each car to find this value. Then answer for the case that we can use only one car for each pair of cities i and j is:ans(0,i,j) = min W(i,j,l) for (_1≤l≤m_)This part has time complexity O(m*n^3).For larger values of maximum number of changes (_k_), we use the following equation:ans(k,i,j) = min (ans(k-1,i,l)+ans(0,l,j)) for (_1≤l≤k_)which can be computed in O(k*n^3) using dynamic programming.But how large can be k in worst case? We know that shortest paths are simple paths (i.e. they have no repeated vertices). Because otherwise we could eliminate the path we go between two appearances of one vertex and have a smaller result. This and the fact that we change the car at most once in each vertex, guarantees in any optimal solution we will not need more that n car changes. Thus the order of the solution would be O(m*n^3+n^4).Problem 187C — Weak MemoryThere were many different correct approaches to this problem during the contest. But I will explain author’s solution.First we can use binary search over the value of q. Now for a fixed q we want to check s-t connectivity.Let K be the set of all intersections with volunteers union s and t. One can use BFS from each k∈K, one by one. Then build a graph G’ with vertices K. For each two vertices k1,k2∈K add an edge between them, if their shortest distance is less than or equal to q. Finally use any path finding algorithm to check the connectivity. Unfortunately this solution has time (and space) complexity of O(|K|*m) which is not good enough.We can optimize the above solution by initiating BFS from all k∈K at once. In other words during the initialization step in BFS algorithm, we push all these vertices in the queue with distance 0. Each element in the queue also maintains its source (i.e. the source it is originating from). In BFS each time we have have a vertex u with source su and we want to set the minimum distance to a vertex v that is already set from a different path with source sv, we connect su and sv in G’ if d(u)+d(v)+1<= q, where d(x) denotes length of the shortest path from a vertex in K to x. As we are only dealing with connectivity, this approach is correct. (Proof of correctness is left as an exercise)BFS takes O(m) time and we add at most O(m) edges to G’, so the overall complexity is O(m) for a fixed q. As we used binary search to find the smallest q, we can solve the problem in O(m*logn).Problem 187D — BRT ContractWe define ti as follows: assume a bus starts moving from i-th intersection exactly at the time when the light changes to green. The time it takes for the bus to get the final station is ti. We call the times when a green interval begins t0 (so every g+r seconds t0 occurs once)If a bus gets to i-th intersection during the red phase, it should wait and then start moving at t0. So considering the fact that all lights are synchronized (and length of segments are fixed) if we have ti for i-th intersection, we can compute the time for the bus to get final station.Clearly tn is the length of the last segments. For computing ti we should find the smallest j such that if a bus starts at t0 from i-th intersection, it gets to j-th intersection during the red phase. So we have:ti=tj+d(i,j)+wwhere d(i,j) is the distance between i-th and j-th intersections and w is the time that the bus should wait behind the red light at j-th intersection. The later value can be computed easily.The only problem that remains is to find j for i-th intersection. So we start iterating over i for (n-1)-th intersection backwards and we compute ti for all intersections. Assume p=g+r and ta=d(i,j)%p. Now if the bus starts from i-th intersection at time t0 and we have ta>=g, in this case we are in red phase at j-th intersection. Actually ta should be in interval [_g, g+r_). Here we can use segment trees. That is for all intersections from i+1 to n, we store some values in the tree that helps us find the smallest j. But we should note the value of ta depends on d(i,j) which changes as i changes. Thus we cannot use ta in the tree. Instead, we define si the be the distance of i-th intersection to the destination. So we have d(i,j)=si-sj and we use the value of sj with storing –sj%p in the segment tree as the key and the value would be j itself. In other words for each intersection we store the key-value pair (-sj%p, j) in the tree. According to what we said so far, to be in the red phase at j-th intersection we should have:ta=(d(i,j)%p)=((si-sj)%p)∈[g,g+r) => -sj%p ∈ [(g-si)%p, (g+r-si)%p)As we stored –sj%p in the tree, we can retrieve the smallest j in the above interval with a query in the segment tree. This way we can compute ti for all intersections. Answering to each query in the problem can be solve in exactly the same way. So the overall complexity would be O((n+q)logn).Problem 187E — Heaven TourStep 1. Solve the problem if the starting man is the leftmost man and the finishing man is the rightmost man.Obviously every segment (the distance between two consecutive men) should be covered at least once. We also argue that at least l (the number of left tickets) segments should be covered at least three times. Proof: Each time you use a left ticket to go to man i with 1<i<n-1, the segment between i-th and (_i+1_)-th men is covered at least three times: Once for you should go after i be in a position to come back. Once for you use a left ticked to come back to i And once again you should go after i, because you want to finish at man number n Note that in the first and the last segments are always covered once, no matter what we do. But except for these two segments, every other segment can be chosen to be among the segments that are covered three times, and every combination that we choose l segments is feasible. (Proof it as practice) So we choose the smallest l segments and the problem can be solved with a simple sort in O(n*logn).Step 2. Solve the problem if the starting man is the leftmost man, but the finishing man can be anywhere.To solve this problem we first fix the finishing man. With reasoning similar to that of step 1, we conclude that at least l segments should be covered with at least two times if they are after the finishing man or three times if they are before him. But obviously every segment after the finishing man is covered at least two times. So it is always good to waste as many left tickets as possible after the finishing man to prevent them from breaching the left side of finishing man and becoming multiple three.So the algorithm would be: iterate over i, the number of finishing man, and maintain the l-(n-i) smallest segments to the right of finishing man as you progress. This can be implemented in O(n*logn).Step 3. Solve the problem if the starting man is fixed, but the finishing man can be anywhere.Assume that the starting man is not the first man or the last man, otherwise we could use algorithm of step 2 to solve the problem. Without loss of generality assume that you finish your tour to the right side of finishing man. Therefore every segment to the left of starting man is covered at least two times and actually it is always possible to arrange visits such that every segment to right is covered exactly two times. So just like what we said in step 2, it is good to waste as many left tickets as possible in this area.So the algorithm would be, choose to finish left or right first, then greedily waste as many bad moves (by bad moves I mean the moves that if breach to the other side will be more costly) as possible there and follow the algorithm in step 2 to solve the whole problem.There are some special cases such as when the tour cannot be finished at all, that we left to readers find a way how to handle them.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4540",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 189\\s*B"
          },
          "content_length": 9777
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #119 - Codeforces - Code 1",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 2",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 3",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 4",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 5",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 6",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int w = inf.readInt(1, 4000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(1, 4000, \"h\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int w = inf.readInt(1, 4000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(1, 4000, \"h\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int w = inf.readInt(1, 4000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(1, 4000, \"h\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int w = opt<int>(\"w\", -1);\n    int h = opt<int>(\"h\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"max\") {\n        w = 4000;\n        h = 4000;\n    } else if (type == \"min\") {\n        w = 1;\n        h = 1;\n    } else if (type == \"maxw\") {\n        w = 4000;\n        if(h == -1)\n            h = rnd.next(1,4000);\n    } else if (type == \"maxh\") {\n        h = 4000;\n        if(w == -1)\n            w = rnd.next(1,4000);\n    } else if (type == \"random\") {\n        if(w == -1)\n            w = rnd.next(1,4000);\n        if(h == -1)\n            h = rnd.next(1,4000);\n    } else if (type == \"small\") {\n        if(w == -1)\n            w = rnd.next(1,10);\n        if(h == -1)\n            h = rnd.next(1,10);\n    } else if (type == \"onebigw\") {\n        w = 1;\n        h = 4000;\n    } else if (type == \"onebigh\") {\n        w = 4000;\n        h = 1;\n    } else if (type == \"same\") {\n        if(w == -1 && h == -1) {\n            int n = rnd.next(1,4000);\n            w = n;\n            h = n;\n        } else if(w != -1 && h == -1) {\n            h = w;\n        } else if(w == -1 && h != -1) {\n            w = h;\n        }\n    } else if (type == \"prime\") {\n        // Generate random primes between 1 and 4000\n        vector<int> primes;\n        vector<bool> is_prime(4001, true);\n        is_prime[0] = is_prime[1] = false;\n        for(int i = 2; i <= 4000; ++i) {\n            if(is_prime[i]) {\n                primes.push_back(i);\n                for(int j = i * 2; j <= 4000; j += i)\n                    is_prime[j] = false;\n            }\n        }\n        w = primes[rnd.next(0, (int)primes.size()-1)];\n        h = primes[rnd.next(0, (int)primes.size()-1)];\n    } else {\n        // We can set w and h directly\n        if(w == -1)\n            w = rnd.next(1, 4000);\n        if(h == -1)\n            h = rnd.next(1, 4000);\n    }\n\n    // Ensure w and h are within the constraints\n    w = max(1, min(w, 4000));\n    h = max(1, min(h, 4000));\n\n    printf(\"%d %d\\n\", w, h);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int w = opt<int>(\"w\", -1);\n    int h = opt<int>(\"h\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"max\") {\n        w = 4000;\n        h = 4000;\n    } else if (type == \"min\") {\n        w = 1;\n        h = 1;\n    } else if (type == \"maxw\") {\n        w = 4000;\n        if(h == -1)\n            h = rnd.next(1,4000);\n    } else if (type == \"maxh\") {\n        h = 4000;\n        if(w == -1)\n            w = rnd.next(1,4000);\n    } else if (type == \"random\") {\n        if(w == -1)\n            w = rnd.next(1,4000);\n        if(h == -1)\n            h = rnd.next(1,4000);\n    } else if (type == \"small\") {\n        if(w == -1)\n            w = rnd.next(1,10);\n        if(h == -1)\n            h = rnd.next(1,10);\n    } else if (type == \"onebigw\") {\n        w = 1;\n        h = 4000;\n    } else if (type == \"onebigh\") {\n        w = 4000;\n        h = 1;\n    } else if (type == \"same\") {\n        if(w == -1 && h == -1) {\n            int n = rnd.next(1,4000);\n            w = n;\n            h = n;\n        } else if(w != -1 && h == -1) {\n            h = w;\n        } else if(w == -1 && h != -1) {\n            w = h;\n        }\n    } else if (type == \"prime\") {\n        // Generate random primes between 1 and 4000\n        vector<int> primes;\n        vector<bool> is_prime(4001, true);\n        is_prime[0] = is_prime[1] = false;\n        for(int i = 2; i <= 4000; ++i) {\n            if(is_prime[i]) {\n                primes.push_back(i);\n                for(int j = i * 2; j <= 4000; j += i)\n                    is_prime[j] = false;\n            }\n        }\n        w = primes[rnd.next(0, (int)primes.size()-1)];\n        h = primes[rnd.next(0, (int)primes.size()-1)];\n    } else {\n        // We can set w and h directly\n        if(w == -1)\n            w = rnd.next(1, 4000);\n        if(h == -1)\n            h = rnd.next(1, 4000);\n    }\n\n    // Ensure w and h are within the constraints\n    w = max(1, min(w, 4000));\n    h = max(1, min(h, 4000));\n\n    printf(\"%d %d\\n\", w, h);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type small\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type same\n./gen -w 1000 -type same\n./gen -h 1000 -type same\n./gen -type onebigw\n./gen -type onebigh\n./gen -w 4000 -h 4000\n./gen -w 1 -h 1\n./gen -w 1 -h 4000\n./gen -w 4000 -h 1\n./gen -type maxw\n./gen -type maxh\n./gen -type prime\n./gen -type prime\n./gen -type prime\n./gen -w 2 -h 2\n./gen -w 3 -h 3\n./gen -w 4 -h 4\n./gen -w 5 -h 5\n./gen -w 10 -h 10\n./gen -w 1 -h 2\n./gen -w 2 -h 1\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:44.898486",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "189/C",
      "title": "C. Permutations",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 2·105) — the quantity of the numbers in the both given permutations. Next line contains n space-separated integers — the first permutation. Each number between 1 to n will appear in the permutation exactly once. Next line describe the second permutation in the same format.",
      "output_spec": "OutputPrint a single integer denoting the minimum number of moves required to convert the first permutation to the second.",
      "sample_tests": "ExamplesInputCopy33 2 11 2 3OutputCopy2InputCopy51 2 3 4 51 5 2 3 4OutputCopy1InputCopy51 5 2 3 41 2 3 4 5OutputCopy3",
      "description": "C. Permutations\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 2·105) — the quantity of the numbers in the both given permutations. Next line contains n space-separated integers — the first permutation. Each number between 1 to n will appear in the permutation exactly once. Next line describe the second permutation in the same format.\n\nOutputPrint a single integer denoting the minimum number of moves required to convert the first permutation to the second.\n\nInputCopy33 2 11 2 3OutputCopy2InputCopy51 2 3 4 51 5 2 3 4OutputCopy1InputCopy51 5 2 3 41 2 3 4 5OutputCopy3\n\nInputCopy33 2 11 2 3\n\nOutputCopy2\n\nInputCopy51 2 3 4 51 5 2 3 4\n\nOutputCopy1\n\nInputCopy51 5 2 3 41 2 3 4 5\n\nOutputCopy3\n\nNoteIn the first sample, he removes number 1 from end of the list and places it at the beginning. After that he takes number 2 and places it between 1 and 3.In the second sample, he removes number 5 and inserts it after 1.In the third sample, the sequence of changes are like this:  1 5 2 3 4 1 4 5 2 3 1 3 4 5 2 1 2 3 4 5  So he needs three moves.",
      "solutions": [
        {
          "title": "Codeforces Round #119 - Codeforces",
          "content": "Hello everyone,We are glad to invite you to participate in today’s round. Problems have been prepared by poopi, Mohammad_JRS, Gerald and me. The hero of our contest is called “PMP”. It is actually the base of our team name through the last five years. The stories are metaphoric, but they have some traces in truth.This Codeforces round, is the last round before the incoming ICPC world final. Our best wishes for all participants of that contest, too. I want to specially thank Gerald for his helps and advices in problem preparation, Delinur for translation of statements into Russian and MikeMirzayanov for this great system.And we have a modified version of Burunduk1 ’s advice: “to make the round even more interesting for us, read the statements of ALL problems.” :)We hope you enjoy the problems and have high ratings.Update: Contest is over. Thanks to everyone for taking part and congratulations to the winners of both divisions, specially peter50216 for being the only who solved all the problems of division 1! :)Update: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4520",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1041
        },
        {
          "title": "Codeforces Round #119 — Editorial - Codeforces",
          "content": "Problem 189A — Cut RibbonThe problem is to maximize x+y+z subject to ax+by+cz=n. Constraints are low, so simply iterate over two variables (say x and y) and find the third variable (if any) from the second equation. Find the maximum over all feasible solutions.Other approaches: Use dynamic programming with each state being the remainder of ribbon. Select the next piece to be a, b or c.Problem 189B — Counting RhombiObserve that lots of rhombi have the same shape, but are in different locations. What uniquely determines the shape of a rhombus? Its width and its height. Is it possible to build a rhombus with every width and every height such that the vertices of the rhombus are in integer points? No, it is possible only if the width and the height are both even.How many places we can put a rhombus of width w0 and height h0 in a rectangle of width w and height h? (w * w0 + 1)(h * h0 + 1)So, iterator over all even widths and heights and for each of them add the number of possible locations to the final result.Problem 187A — PermutationsIt is easy to see that if we replace each number in the first permutation with position of that number in the second permutation, the problem reduces to sorting the first permutation.Each time we take a number from the end of array, we can postpone its insertion until we know the most suitable position for insertion. Note that it is not good to insert a number and take it again, as we could make a better decision first time we took the number. So, as long as the remainder of the array is not in increasing order, we should take more numbers from the end. But as soon as you have an increasing subsequence, you can insert the numbers you have taken to make the array sorted. Therefore to solve the problem, we find the largest i such the numbers from 1 to i are in increasing order. The answer would be n-i.Problem 187B — AlgoRaceFirst we solve the problem when the number of allowed car changes is zero (_k=0_). Let W(i,j,l) be the length of shortest path from i to j with car l. We use Floyd-Warshal on graph of each car to find this value. Then answer for the case that we can use only one car for each pair of cities i and j is:ans(0,i,j) = min W(i,j,l) for (_1≤l≤m_)This part has time complexity O(m*n^3).For larger values of maximum number of changes (_k_), we use the following equation:ans(k,i,j) = min (ans(k-1,i,l)+ans(0,l,j)) for (_1≤l≤k_)which can be computed in O(k*n^3) using dynamic programming.But how large can be k in worst case? We know that shortest paths are simple paths (i.e. they have no repeated vertices). Because otherwise we could eliminate the path we go between two appearances of one vertex and have a smaller result. This and the fact that we change the car at most once in each vertex, guarantees in any optimal solution we will not need more that n car changes. Thus the order of the solution would be O(m*n^3+n^4).Problem 187C — Weak MemoryThere were many different correct approaches to this problem during the contest. But I will explain author’s solution.First we can use binary search over the value of q. Now for a fixed q we want to check s-t connectivity.Let K be the set of all intersections with volunteers union s and t. One can use BFS from each k∈K, one by one. Then build a graph G’ with vertices K. For each two vertices k1,k2∈K add an edge between them, if their shortest distance is less than or equal to q. Finally use any path finding algorithm to check the connectivity. Unfortunately this solution has time (and space) complexity of O(|K|*m) which is not good enough.We can optimize the above solution by initiating BFS from all k∈K at once. In other words during the initialization step in BFS algorithm, we push all these vertices in the queue with distance 0. Each element in the queue also maintains its source (i.e. the source it is originating from). In BFS each time we have have a vertex u with source su and we want to set the minimum distance to a vertex v that is already set from a different path with source sv, we connect su and sv in G’ if d(u)+d(v)+1<= q, where d(x) denotes length of the shortest path from a vertex in K to x. As we are only dealing with connectivity, this approach is correct. (Proof of correctness is left as an exercise)BFS takes O(m) time and we add at most O(m) edges to G’, so the overall complexity is O(m) for a fixed q. As we used binary search to find the smallest q, we can solve the problem in O(m*logn).Problem 187D — BRT ContractWe define ti as follows: assume a bus starts moving from i-th intersection exactly at the time when the light changes to green. The time it takes for the bus to get the final station is ti. We call the times when a green interval begins t0 (so every g+r seconds t0 occurs once)If a bus gets to i-th intersection during the red phase, it should wait and then start moving at t0. So considering the fact that all lights are synchronized (and length of segments are fixed) if we have ti for i-th intersection, we can compute the time for the bus to get final station.Clearly tn is the length of the last segments. For computing ti we should find the smallest j such that if a bus starts at t0 from i-th intersection, it gets to j-th intersection during the red phase. So we have:ti=tj+d(i,j)+wwhere d(i,j) is the distance between i-th and j-th intersections and w is the time that the bus should wait behind the red light at j-th intersection. The later value can be computed easily.The only problem that remains is to find j for i-th intersection. So we start iterating over i for (n-1)-th intersection backwards and we compute ti for all intersections. Assume p=g+r and ta=d(i,j)%p. Now if the bus starts from i-th intersection at time t0 and we have ta>=g, in this case we are in red phase at j-th intersection. Actually ta should be in interval [_g, g+r_). Here we can use segment trees. That is for all intersections from i+1 to n, we store some values in the tree that helps us find the smallest j. But we should note the value of ta depends on d(i,j) which changes as i changes. Thus we cannot use ta in the tree. Instead, we define si the be the distance of i-th intersection to the destination. So we have d(i,j)=si-sj and we use the value of sj with storing –sj%p in the segment tree as the key and the value would be j itself. In other words for each intersection we store the key-value pair (-sj%p, j) in the tree. According to what we said so far, to be in the red phase at j-th intersection we should have:ta=(d(i,j)%p)=((si-sj)%p)∈[g,g+r) => -sj%p ∈ [(g-si)%p, (g+r-si)%p)As we stored –sj%p in the tree, we can retrieve the smallest j in the above interval with a query in the segment tree. This way we can compute ti for all intersections. Answering to each query in the problem can be solve in exactly the same way. So the overall complexity would be O((n+q)logn).Problem 187E — Heaven TourStep 1. Solve the problem if the starting man is the leftmost man and the finishing man is the rightmost man.Obviously every segment (the distance between two consecutive men) should be covered at least once. We also argue that at least l (the number of left tickets) segments should be covered at least three times. Proof: Each time you use a left ticket to go to man i with 1<i<n-1, the segment between i-th and (_i+1_)-th men is covered at least three times: Once for you should go after i be in a position to come back. Once for you use a left ticked to come back to i And once again you should go after i, because you want to finish at man number n Note that in the first and the last segments are always covered once, no matter what we do. But except for these two segments, every other segment can be chosen to be among the segments that are covered three times, and every combination that we choose l segments is feasible. (Proof it as practice) So we choose the smallest l segments and the problem can be solved with a simple sort in O(n*logn).Step 2. Solve the problem if the starting man is the leftmost man, but the finishing man can be anywhere.To solve this problem we first fix the finishing man. With reasoning similar to that of step 1, we conclude that at least l segments should be covered with at least two times if they are after the finishing man or three times if they are before him. But obviously every segment after the finishing man is covered at least two times. So it is always good to waste as many left tickets as possible after the finishing man to prevent them from breaching the left side of finishing man and becoming multiple three.So the algorithm would be: iterate over i, the number of finishing man, and maintain the l-(n-i) smallest segments to the right of finishing man as you progress. This can be implemented in O(n*logn).Step 3. Solve the problem if the starting man is fixed, but the finishing man can be anywhere.Assume that the starting man is not the first man or the last man, otherwise we could use algorithm of step 2 to solve the problem. Without loss of generality assume that you finish your tour to the right side of finishing man. Therefore every segment to the left of starting man is covered at least two times and actually it is always possible to arrange visits such that every segment to right is covered exactly two times. So just like what we said in step 2, it is good to waste as many left tickets as possible in this area.So the algorithm would be, choose to finish left or right first, then greedily waste as many bad moves (by bad moves I mean the moves that if breach to the other side will be more costly) as possible there and follow the algorithm in step 2 to solve the whole problem.There are some special cases such as when the tour cannot be finished at all, that we left to readers find a way how to handle them.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4540",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 189 和字母"
          },
          "content_length": 9777
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #119 - Codeforces - Code 1",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 2",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 3",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 4",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 5",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 6",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> p1 = inf.readInts(n, 1, n, \"p1\");\n    inf.readEoln();\n    vector<int> p2 = inf.readInts(n, 1, n, \"p2\");\n    inf.readEoln();\n    inf.readEof();\n\n    set<int> s1(p1.begin(), p1.end());\n    ensuref(int(s1.size()) == n, \"p1 must be a permutation of 1..n\");\n\n    set<int> s2(p2.begin(), p2.end());\n    ensuref(int(s2.size()) == n, \"p2 must be a permutation of 1..n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> p1 = inf.readInts(n, 1, n, \"p1\");\n    inf.readEoln();\n    vector<int> p2 = inf.readInts(n, 1, n, \"p2\");\n    inf.readEoln();\n    inf.readEof();\n\n    set<int> s1(p1.begin(), p1.end());\n    ensuref(int(s1.size()) == n, \"p1 must be a permutation of 1..n\");\n\n    set<int> s2(p2.begin(), p2.end());\n    ensuref(int(s2.size()) == n, \"p2 must be a permutation of 1..n\");\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> p1 = inf.readInts(n, 1, n, \"p1\");\n    inf.readEoln();\n    vector<int> p2 = inf.readInts(n, 1, n, \"p2\");\n    inf.readEoln();\n    inf.readEof();\n\n    set<int> s1(p1.begin(), p1.end());\n    ensuref(int(s1.size()) == n, \"p1 must be a permutation of 1..n\");\n\n    set<int> s2(p2.begin(), p2.end());\n    ensuref(int(s2.size()) == n, \"p2 must be a permutation of 1..n\");\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p1(n);\n    vector<int> p2(n);\n\n    if (type == \"identical\") {\n        // Generate a random permutation for p1\n        for (int i = 0; i < n; ++i)\n            p1[i] = i + 1;\n        shuffle(p1.begin(), p1.end());\n        // p2 is same as p1\n        p2 = p1;\n    } else if (type == \"reverse\") {\n        // Generate random permutation for p1\n        for (int i = 0; i < n; ++i)\n            p1[i] = i + 1;\n        shuffle(p1.begin(), p1.end());\n        // p2 is reverse of p1\n        p2 = p1;\n        reverse(p2.begin(), p2.end());\n    } else if (type == \"shifted\") {\n        // Generate random permutation for p1\n        for (int i = 0; i < n; ++i)\n            p1[i] = i + 1;\n        shuffle(p1.begin(), p1.end());\n        // p2 is p1 rotated by a random amount\n        int shift = rnd.next(1, n - 1); // shift by at least 1, up to n - 1\n        p2 = p1;\n        rotate(p2.begin(), p2.begin() + shift, p2.end());\n    } else if (type == \"single_swap\") {\n        // Generate random permutation for p1\n        for (int i = 0; i < n; ++i)\n            p1[i] = i + 1;\n        shuffle(p1.begin(), p1.end());\n        // p2 is p1 with two elements swapped\n        p2 = p1;\n        int i = rnd.next(0, n - 1);\n        int j = rnd.next(0, n - 1);\n        while (i == j) {\n            j = rnd.next(0, n - 1);\n        }\n        swap(p2[i], p2[j]);\n    } else if (type == \"almost_sorted\") {\n        // p1 is sorted\n        for (int i = 0; i < n; ++i)\n            p1[i] = i + 1;\n        // p2 is p1 with some adjacent swaps\n        p2 = p1;\n        int k = rnd.next(1, min(n, 10)); // introduce between 1 and 10 inversions\n        for (int i = 0; i < k; ++i) {\n            int a = rnd.next(0, n - 2);\n            swap(p2[a], p2[a + 1]);\n        }\n    } else if (type == \"random\") {\n        // Generate p1 and p2 as random permutations\n        for (int i = 0; i < n; ++i)\n            p1[i] = i + 1;\n        shuffle(p1.begin(), p1.end());\n        p2 = p1;\n        shuffle(p2.begin(), p2.end());\n    } else {\n        // Default case: random\n        for (int i = 0; i < n; ++i)\n            p1[i] = i + 1;\n        shuffle(p1.begin(), p1.end());\n        p2 = p1;\n        shuffle(p2.begin(), p2.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output p1\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p1[i], i == n - 1 ? '\\n' : ' ');\n    }\n    // Output p2\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p2[i], i == n - 1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p1(n);\n    vector<int> p2(n);\n\n    if (type == \"identical\") {\n        // Generate a random permutation for p1\n        for (int i = 0; i < n; ++i)\n            p1[i] = i + 1;\n        shuffle(p1.begin(), p1.end());\n        // p2 is same as p1\n        p2 = p1;\n    } else if (type == \"reverse\") {\n        // Generate random permutation for p1\n        for (int i = 0; i < n; ++i)\n            p1[i] = i + 1;\n        shuffle(p1.begin(), p1.end());\n        // p2 is reverse of p1\n        p2 = p1;\n        reverse(p2.begin(), p2.end());\n    } else if (type == \"shifted\") {\n        // Generate random permutation for p1\n        for (int i = 0; i < n; ++i)\n            p1[i] = i + 1;\n        shuffle(p1.begin(), p1.end());\n        // p2 is p1 rotated by a random amount\n        int shift = rnd.next(1, n - 1); // shift by at least 1, up to n - 1\n        p2 = p1;\n        rotate(p2.begin(), p2.begin() + shift, p2.end());\n    } else if (type == \"single_swap\") {\n        // Generate random permutation for p1\n        for (int i = 0; i < n; ++i)\n            p1[i] = i + 1;\n        shuffle(p1.begin(), p1.end());\n        // p2 is p1 with two elements swapped\n        p2 = p1;\n        int i = rnd.next(0, n - 1);\n        int j = rnd.next(0, n - 1);\n        while (i == j) {\n            j = rnd.next(0, n - 1);\n        }\n        swap(p2[i], p2[j]);\n    } else if (type == \"almost_sorted\") {\n        // p1 is sorted\n        for (int i = 0; i < n; ++i)\n            p1[i] = i + 1;\n        // p2 is p1 with some adjacent swaps\n        p2 = p1;\n        int k = rnd.next(1, min(n, 10)); // introduce between 1 and 10 inversions\n        for (int i = 0; i < k; ++i) {\n            int a = rnd.next(0, n - 2);\n            swap(p2[a], p2[a + 1]);\n        }\n    } else if (type == \"random\") {\n        // Generate p1 and p2 as random permutations\n        for (int i = 0; i < n; ++i)\n            p1[i] = i + 1;\n        shuffle(p1.begin(), p1.end());\n        p2 = p1;\n        shuffle(p2.begin(), p2.end());\n    } else {\n        // Default case: random\n        for (int i = 0; i < n; ++i)\n            p1[i] = i + 1;\n        shuffle(p1.begin(), p1.end());\n        p2 = p1;\n        shuffle(p2.begin(), p2.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output p1\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p1[i], i == n - 1 ? '\\n' : ' ');\n    }\n    // Output p2\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p2[i], i == n - 1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type identical\n./gen -n 1 -type random\n\n./gen -n 2 -type identical\n./gen -n 2 -type single_swap\n./gen -n 2 -type reverse\n\n./gen -n 5 -type identical\n./gen -n 5 -type reverse\n./gen -n 5 -type shifted\n./gen -n 5 -type single_swap\n./gen -n 5 -type almost_sorted\n./gen -n 5 -type random\n\n./gen -n 1000 -type identical\n./gen -n 1000 -type reverse\n./gen -n 1000 -type shifted\n./gen -n 1000 -type single_swap\n./gen -n 1000 -type almost_sorted\n./gen -n 1000 -type random\n\n./gen -n 5000 -type identical\n./gen -n 5000 -type reverse\n./gen -n 5000 -type shifted\n./gen -n 5000 -type almost_sorted\n./gen -n 5000 -type random\n\n./gen -n 100000 -type identical\n./gen -n 100000 -type reverse\n./gen -n 100000 -type shifted\n./gen -n 100000 -type almost_sorted\n./gen -n 100000 -type random\n\n./gen -n 200000 -type identical\n./gen -n 200000 -type reverse\n./gen -n 200000 -type shifted\n./gen -n 200000 -type almost_sorted\n./gen -n 200000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:46.938683",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "189/D",
      "title": "D. AlgoRace",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers n, m, r (2 ≤ n ≤ 60, 1 ≤ m ≤ 60, 1 ≤ r ≤ 105) — the number of cities, the number of different types of cars and the number of rounds in the competition, correspondingly.Next m sets of n × n matrices of integers between 0 to 106 (inclusive) will follow — describing the time one car requires to traverse different roads. The k-th integer in j-th line of the i-th set is the time that i-th car requires to traverse the road from j-th city to k-th city. These matrices are not necessarily symmetric, but their diagonal is always zero.Next r lines contain description of the rounds. The i-th of these lines contains space-separated integers si, ti, ki (1 ≤ si, ti ≤ n, si ≠ ti, 0 ≤ ki ≤ 1000) — the number of starting city, finishing city and the number of possible car changes in i-th round, correspondingly.",
      "output_spec": "OutputFor each round you should print the minimum required time to complete the round in a single line.",
      "sample_tests": "ExamplesInputCopy4 2 30 1 5 62 0 3 61 3 0 16 6 7 00 3 5 62 0 1 61 3 0 26 6 7 01 4 21 4 11 4 3OutputCopy343InputCopy4 2 30 7 3 38 0 10 51 1 0 48 9 2 00 3 3 97 0 4 93 8 0 44 8 9 02 3 32 1 31 2 2OutputCopy453",
      "description": "D. AlgoRace\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers n, m, r (2 ≤ n ≤ 60, 1 ≤ m ≤ 60, 1 ≤ r ≤ 105) — the number of cities, the number of different types of cars and the number of rounds in the competition, correspondingly.Next m sets of n × n matrices of integers between 0 to 106 (inclusive) will follow — describing the time one car requires to traverse different roads. The k-th integer in j-th line of the i-th set is the time that i-th car requires to traverse the road from j-th city to k-th city. These matrices are not necessarily symmetric, but their diagonal is always zero.Next r lines contain description of the rounds. The i-th of these lines contains space-separated integers si, ti, ki (1 ≤ si, ti ≤ n, si ≠ ti, 0 ≤ ki ≤ 1000) — the number of starting city, finishing city and the number of possible car changes in i-th round, correspondingly.\n\nOutputFor each round you should print the minimum required time to complete the round in a single line.\n\nInputCopy4 2 30 1 5 62 0 3 61 3 0 16 6 7 00 3 5 62 0 1 61 3 0 26 6 7 01 4 21 4 11 4 3OutputCopy343InputCopy4 2 30 7 3 38 0 10 51 1 0 48 9 2 00 3 3 97 0 4 93 8 0 44 8 9 02 3 32 1 31 2 2OutputCopy453\n\nInputCopy4 2 30 1 5 62 0 3 61 3 0 16 6 7 00 3 5 62 0 1 61 3 0 26 6 7 01 4 21 4 11 4 3\n\nOutputCopy343\n\nInputCopy4 2 30 7 3 38 0 10 51 1 0 48 9 2 00 3 3 97 0 4 93 8 0 44 8 9 02 3 32 1 31 2 2\n\nOutputCopy453\n\nNoteIn the first sample, in all rounds PMP goes from city #1 to city #2, then city #3 and finally city #4. But the sequences of types of the cars he uses are (1, 2, 1) in the first round and (1, 2, 2) in the second round. In the third round, although he can change his car three times, he uses the same strategy as the first round which only needs two car changes.",
      "solutions": [
        {
          "title": "Codeforces Round #119 - Codeforces",
          "content": "Hello everyone,We are glad to invite you to participate in today’s round. Problems have been prepared by poopi, Mohammad_JRS, Gerald and me. The hero of our contest is called “PMP”. It is actually the base of our team name through the last five years. The stories are metaphoric, but they have some traces in truth.This Codeforces round, is the last round before the incoming ICPC world final. Our best wishes for all participants of that contest, too. I want to specially thank Gerald for his helps and advices in problem preparation, Delinur for translation of statements into Russian and MikeMirzayanov for this great system.And we have a modified version of Burunduk1 ’s advice: “to make the round even more interesting for us, read the statements of ALL problems.” :)We hope you enjoy the problems and have high ratings.Update: Contest is over. Thanks to everyone for taking part and congratulations to the winners of both divisions, specially peter50216 for being the only who solved all the problems of division 1! :)Update: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4520",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1041
        },
        {
          "title": "Codeforces Round #119 — Editorial - Codeforces",
          "content": "Problem 189A — Cut RibbonThe problem is to maximize x+y+z subject to ax+by+cz=n. Constraints are low, so simply iterate over two variables (say x and y) and find the third variable (if any) from the second equation. Find the maximum over all feasible solutions.Other approaches: Use dynamic programming with each state being the remainder of ribbon. Select the next piece to be a, b or c.Problem 189B — Counting RhombiObserve that lots of rhombi have the same shape, but are in different locations. What uniquely determines the shape of a rhombus? Its width and its height. Is it possible to build a rhombus with every width and every height such that the vertices of the rhombus are in integer points? No, it is possible only if the width and the height are both even.How many places we can put a rhombus of width w0 and height h0 in a rectangle of width w and height h? (w * w0 + 1)(h * h0 + 1)So, iterator over all even widths and heights and for each of them add the number of possible locations to the final result.Problem 187A — PermutationsIt is easy to see that if we replace each number in the first permutation with position of that number in the second permutation, the problem reduces to sorting the first permutation.Each time we take a number from the end of array, we can postpone its insertion until we know the most suitable position for insertion. Note that it is not good to insert a number and take it again, as we could make a better decision first time we took the number. So, as long as the remainder of the array is not in increasing order, we should take more numbers from the end. But as soon as you have an increasing subsequence, you can insert the numbers you have taken to make the array sorted. Therefore to solve the problem, we find the largest i such the numbers from 1 to i are in increasing order. The answer would be n-i.Problem 187B — AlgoRaceFirst we solve the problem when the number of allowed car changes is zero (_k=0_). Let W(i,j,l) be the length of shortest path from i to j with car l. We use Floyd-Warshal on graph of each car to find this value. Then answer for the case that we can use only one car for each pair of cities i and j is:ans(0,i,j) = min W(i,j,l) for (_1≤l≤m_)This part has time complexity O(m*n^3).For larger values of maximum number of changes (_k_), we use the following equation:ans(k,i,j) = min (ans(k-1,i,l)+ans(0,l,j)) for (_1≤l≤k_)which can be computed in O(k*n^3) using dynamic programming.But how large can be k in worst case? We know that shortest paths are simple paths (i.e. they have no repeated vertices). Because otherwise we could eliminate the path we go between two appearances of one vertex and have a smaller result. This and the fact that we change the car at most once in each vertex, guarantees in any optimal solution we will not need more that n car changes. Thus the order of the solution would be O(m*n^3+n^4).Problem 187C — Weak MemoryThere were many different correct approaches to this problem during the contest. But I will explain author’s solution.First we can use binary search over the value of q. Now for a fixed q we want to check s-t connectivity.Let K be the set of all intersections with volunteers union s and t. One can use BFS from each k∈K, one by one. Then build a graph G’ with vertices K. For each two vertices k1,k2∈K add an edge between them, if their shortest distance is less than or equal to q. Finally use any path finding algorithm to check the connectivity. Unfortunately this solution has time (and space) complexity of O(|K|*m) which is not good enough.We can optimize the above solution by initiating BFS from all k∈K at once. In other words during the initialization step in BFS algorithm, we push all these vertices in the queue with distance 0. Each element in the queue also maintains its source (i.e. the source it is originating from). In BFS each time we have have a vertex u with source su and we want to set the minimum distance to a vertex v that is already set from a different path with source sv, we connect su and sv in G’ if d(u)+d(v)+1<= q, where d(x) denotes length of the shortest path from a vertex in K to x. As we are only dealing with connectivity, this approach is correct. (Proof of correctness is left as an exercise)BFS takes O(m) time and we add at most O(m) edges to G’, so the overall complexity is O(m) for a fixed q. As we used binary search to find the smallest q, we can solve the problem in O(m*logn).Problem 187D — BRT ContractWe define ti as follows: assume a bus starts moving from i-th intersection exactly at the time when the light changes to green. The time it takes for the bus to get the final station is ti. We call the times when a green interval begins t0 (so every g+r seconds t0 occurs once)If a bus gets to i-th intersection during the red phase, it should wait and then start moving at t0. So considering the fact that all lights are synchronized (and length of segments are fixed) if we have ti for i-th intersection, we can compute the time for the bus to get final station.Clearly tn is the length of the last segments. For computing ti we should find the smallest j such that if a bus starts at t0 from i-th intersection, it gets to j-th intersection during the red phase. So we have:ti=tj+d(i,j)+wwhere d(i,j) is the distance between i-th and j-th intersections and w is the time that the bus should wait behind the red light at j-th intersection. The later value can be computed easily.The only problem that remains is to find j for i-th intersection. So we start iterating over i for (n-1)-th intersection backwards and we compute ti for all intersections. Assume p=g+r and ta=d(i,j)%p. Now if the bus starts from i-th intersection at time t0 and we have ta>=g, in this case we are in red phase at j-th intersection. Actually ta should be in interval [_g, g+r_). Here we can use segment trees. That is for all intersections from i+1 to n, we store some values in the tree that helps us find the smallest j. But we should note the value of ta depends on d(i,j) which changes as i changes. Thus we cannot use ta in the tree. Instead, we define si the be the distance of i-th intersection to the destination. So we have d(i,j)=si-sj and we use the value of sj with storing –sj%p in the segment tree as the key and the value would be j itself. In other words for each intersection we store the key-value pair (-sj%p, j) in the tree. According to what we said so far, to be in the red phase at j-th intersection we should have:ta=(d(i,j)%p)=((si-sj)%p)∈[g,g+r) => -sj%p ∈ [(g-si)%p, (g+r-si)%p)As we stored –sj%p in the tree, we can retrieve the smallest j in the above interval with a query in the segment tree. This way we can compute ti for all intersections. Answering to each query in the problem can be solve in exactly the same way. So the overall complexity would be O((n+q)logn).Problem 187E — Heaven TourStep 1. Solve the problem if the starting man is the leftmost man and the finishing man is the rightmost man.Obviously every segment (the distance between two consecutive men) should be covered at least once. We also argue that at least l (the number of left tickets) segments should be covered at least three times. Proof: Each time you use a left ticket to go to man i with 1<i<n-1, the segment between i-th and (_i+1_)-th men is covered at least three times: Once for you should go after i be in a position to come back. Once for you use a left ticked to come back to i And once again you should go after i, because you want to finish at man number n Note that in the first and the last segments are always covered once, no matter what we do. But except for these two segments, every other segment can be chosen to be among the segments that are covered three times, and every combination that we choose l segments is feasible. (Proof it as practice) So we choose the smallest l segments and the problem can be solved with a simple sort in O(n*logn).Step 2. Solve the problem if the starting man is the leftmost man, but the finishing man can be anywhere.To solve this problem we first fix the finishing man. With reasoning similar to that of step 1, we conclude that at least l segments should be covered with at least two times if they are after the finishing man or three times if they are before him. But obviously every segment after the finishing man is covered at least two times. So it is always good to waste as many left tickets as possible after the finishing man to prevent them from breaching the left side of finishing man and becoming multiple three.So the algorithm would be: iterate over i, the number of finishing man, and maintain the l-(n-i) smallest segments to the right of finishing man as you progress. This can be implemented in O(n*logn).Step 3. Solve the problem if the starting man is fixed, but the finishing man can be anywhere.Assume that the starting man is not the first man or the last man, otherwise we could use algorithm of step 2 to solve the problem. Without loss of generality assume that you finish your tour to the right side of finishing man. Therefore every segment to the left of starting man is covered at least two times and actually it is always possible to arrange visits such that every segment to right is covered exactly two times. So just like what we said in step 2, it is good to waste as many left tickets as possible in this area.So the algorithm would be, choose to finish left or right first, then greedily waste as many bad moves (by bad moves I mean the moves that if breach to the other side will be more costly) as possible there and follow the algorithm in step 2 to solve the whole problem.There are some special cases such as when the tour cannot be finished at all, that we left to readers find a way how to handle them.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4540",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 189 和字母"
          },
          "content_length": 9777
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #119 - Codeforces - Code 1",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 2",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 3",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 4",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 5",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 6",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 60, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 60, \"m\");\n    inf.readSpace();\n    int r = inf.readInt(1, 100000, \"r\");\n    inf.readEoln();\n\n    for (int car = 1; car <= m; ++car) {\n        for (int row = 1; row <= n; ++row) {\n            vector<int> line = inf.readInts(n, 0, 1000000, \"matrix_row\");\n            ensuref(line[row -1] == 0, \"Diagonal entry of matrix %d, row %d is not zero\", car, row);\n            inf.readEoln();\n        }\n    }\n\n    for (int rd = 1; rd <= r; ++rd) {\n        int si = inf.readInt(1, n, \"si\");\n        inf.readSpace();\n        int ti = inf.readInt(1, n, \"ti\");\n        ensuref(si != ti, \"In round %d, si (%d) must not equal ti (%d)\", rd, si, ti);\n        inf.readSpace();\n        int ki = inf.readInt(0, 1000, \"ki\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 60, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 60, \"m\");\n    inf.readSpace();\n    int r = inf.readInt(1, 100000, \"r\");\n    inf.readEoln();\n\n    for (int car = 1; car <= m; ++car) {\n        for (int row = 1; row <= n; ++row) {\n            vector<int> line = inf.readInts(n, 0, 1000000, \"matrix_row\");\n            ensuref(line[row -1] == 0, \"Diagonal entry of matrix %d, row %d is not zero\", car, row);\n            inf.readEoln();\n        }\n    }\n\n    for (int rd = 1; rd <= r; ++rd) {\n        int si = inf.readInt(1, n, \"si\");\n        inf.readSpace();\n        int ti = inf.readInt(1, n, \"ti\");\n        ensuref(si != ti, \"In round %d, si (%d) must not equal ti (%d)\", rd, si, ti);\n        inf.readSpace();\n        int ki = inf.readInt(0, 1000, \"ki\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 60, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 60, \"m\");\n    inf.readSpace();\n    int r = inf.readInt(1, 100000, \"r\");\n    inf.readEoln();\n\n    for (int car = 1; car <= m; ++car) {\n        for (int row = 1; row <= n; ++row) {\n            vector<int> line = inf.readInts(n, 0, 1000000, \"matrix_row\");\n            ensuref(line[row -1] == 0, \"Diagonal entry of matrix %d, row %d is not zero\", car, row);\n            inf.readEoln();\n        }\n    }\n\n    for (int rd = 1; rd <= r; ++rd) {\n        int si = inf.readInt(1, n, \"si\");\n        inf.readSpace();\n        int ti = inf.readInt(1, n, \"ti\");\n        ensuref(si != ti, \"In round %d, si (%d) must not equal ti (%d)\", rd, si, ti);\n        inf.readSpace();\n        int ki = inf.readInt(0, 1000, \"ki\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Build the m matrices: m x n x n\n\n    vector<vector<vector<int>>> times(m, vector<vector<int>>(n, vector<int>(n)));\n\n    if (type == \"random\") {\n        // For each car type\n        for (int car = 0; car < m; ++car) {\n            for (int i = 0; i < n; ++i) {\n                times[car][i][i] = 0; // diagonal zero\n                for (int j = i+1; j < n; ++j) {\n                    int t = rnd.next(0, 1000000); // time from i to j\n                    int t2 = rnd.next(0, 1000000); // time from j to i\n                    times[car][i][j] = t;\n                    times[car][j][i] = t2;\n                }\n            }\n        }\n    } else if (type == \"one_car_better\") {\n        // Suppose car 0 is better on all roads\n        for (int car = 0; car < m; ++car) {\n            for (int i = 0; i < n; ++i) {\n                times[car][i][i] = 0;\n                for (int j = i+1; j < n; ++j) {\n                    int t;\n                    if (car == 0)\n                        t = rnd.next(0, 1000);\n                    else\n                        t = rnd.next(10000, 1000000);\n                    int t2;\n                    if (car == 0)\n                        t2 = rnd.next(0, 1000);\n                    else\n                        t2 = rnd.next(10000, 1000000);\n                    times[car][i][j] = t;\n                    times[car][j][i] = t2; // To make it asymmetric\n                }\n            }\n        }\n    } else if (type == \"asymmetric\") {\n        // Generate asymmetric times\n        for (int car = 0; car < m; ++car) {\n            for (int i = 0; i < n; ++i) {\n                times[car][i][i] = 0;\n                for (int j = 0; j < n; ++j) {\n                    if (i != j) {\n                        times[car][i][j] = rnd.next(0, 1000000);\n                    }\n                }\n            }\n        }\n    } else if (type == \"large_times\") {\n        // Generate times near the max limit\n        for (int car = 0; car < m; ++car) {\n            for (int i = 0; i < n; ++i) {\n                times[car][i][i] = 0;\n                for (int j = 0; j < n; ++j) {\n                    if (i != j) {\n                        times[car][i][j] = rnd.next(999999, 1000000);\n                    }\n                }\n            }\n        }\n    } else if (type == \"zero_changes\") {\n        // Generate times normally, set k_i = 0 in rounds\n        for (int car = 0; car < m; ++car) {\n            for (int i = 0; i < n; ++i) {\n                times[car][i][i] = 0;\n                for (int j = i+1; j < n; ++j) {\n                    int t = rnd.next(0, 1000000);\n                    int t2 = rnd.next(0, 1000000);\n                    times[car][i][j] = t;\n                    times[car][j][i] = t2;\n                }\n            }\n        }\n    } else if (type == \"max_changes\") {\n        // Generate times normally, set k_i = 1000 in rounds\n        for (int car = 0; car < m; ++car) {\n            for (int i = 0; i < n; ++i) {\n                times[car][i][i] = 0;\n                for (int j = i+1; j < n; ++j) {\n                    int t = rnd.next(0, 1000000);\n                    int t2 = rnd.next(0, 1000000);\n                    times[car][i][j] = t;\n                    times[car][j][i] = t2;\n                }\n            }\n        }\n    } else if (type == \"k_variety\") {\n        // Generate times normally, k_i varies\n        for (int car = 0; car < m; ++car) {\n            for (int i = 0; i < n; ++i) {\n                times[car][i][i] = 0;\n                for (int j = i+1; j < n; ++j) {\n                    int t = rnd.next(0, 1000000);\n                    int t2 = rnd.next(0, 1000000);\n                    times[car][i][j] = t;\n                    times[car][j][i] = t2;\n                }\n            }\n        }\n    } else {\n        // Default to random\n        for (int car = 0; car < m; ++car) {\n            for (int i = 0; i < n; ++i) {\n                times[car][i][i] = 0; // diagonal zero\n                for (int j = i+1; j < n; ++j) {\n                    int t = rnd.next(0, 1000000); // time from i to j\n                    int t2 = rnd.next(0, 1000000); // time from j to i\n                    times[car][i][j] = t;\n                    times[car][j][i] = t2;\n                }\n            }\n        }\n    }\n\n    // Output n, m, r\n    printf(\"%d %d %d\\n\", n, m, r);\n\n    // Output the m matrices\n    for (int car = 0; car < m; ++car) {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                printf(\"%d\", times[car][i][j]);\n                if (j + 1 < n)\n                    printf(\" \");\n                else\n                    printf(\"\\n\");\n            }\n        }\n    }\n\n    // Now generate r rounds\n    for (int i = 0; i < r; ++i) {\n        int s_i = rnd.next(1, n);\n        int t_i = rnd.next(1, n);\n        while (t_i == s_i) {\n            t_i = rnd.next(1, n);\n        }\n        int k_i;\n        if (type == \"zero_changes\") {\n            k_i = 0;\n        } else if (type == \"max_changes\") {\n            k_i = 1000;\n        } else if (type == \"random\") {\n            k_i = rnd.next(0, 1000);\n        } else if (type == \"k_variety\") {\n            // Use various k_i values\n            if (i % 3 == 0)\n                k_i = 0;\n            else if (i % 3 == 1)\n                k_i = 1;\n            else\n                k_i = 1000;\n        } else {\n            k_i = rnd.next(0, 1000);\n        }\n        printf(\"%d %d %d\\n\", s_i, t_i, k_i);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Build the m matrices: m x n x n\n\n    vector<vector<vector<int>>> times(m, vector<vector<int>>(n, vector<int>(n)));\n\n    if (type == \"random\") {\n        // For each car type\n        for (int car = 0; car < m; ++car) {\n            for (int i = 0; i < n; ++i) {\n                times[car][i][i] = 0; // diagonal zero\n                for (int j = i+1; j < n; ++j) {\n                    int t = rnd.next(0, 1000000); // time from i to j\n                    int t2 = rnd.next(0, 1000000); // time from j to i\n                    times[car][i][j] = t;\n                    times[car][j][i] = t2;\n                }\n            }\n        }\n    } else if (type == \"one_car_better\") {\n        // Suppose car 0 is better on all roads\n        for (int car = 0; car < m; ++car) {\n            for (int i = 0; i < n; ++i) {\n                times[car][i][i] = 0;\n                for (int j = i+1; j < n; ++j) {\n                    int t;\n                    if (car == 0)\n                        t = rnd.next(0, 1000);\n                    else\n                        t = rnd.next(10000, 1000000);\n                    int t2;\n                    if (car == 0)\n                        t2 = rnd.next(0, 1000);\n                    else\n                        t2 = rnd.next(10000, 1000000);\n                    times[car][i][j] = t;\n                    times[car][j][i] = t2; // To make it asymmetric\n                }\n            }\n        }\n    } else if (type == \"asymmetric\") {\n        // Generate asymmetric times\n        for (int car = 0; car < m; ++car) {\n            for (int i = 0; i < n; ++i) {\n                times[car][i][i] = 0;\n                for (int j = 0; j < n; ++j) {\n                    if (i != j) {\n                        times[car][i][j] = rnd.next(0, 1000000);\n                    }\n                }\n            }\n        }\n    } else if (type == \"large_times\") {\n        // Generate times near the max limit\n        for (int car = 0; car < m; ++car) {\n            for (int i = 0; i < n; ++i) {\n                times[car][i][i] = 0;\n                for (int j = 0; j < n; ++j) {\n                    if (i != j) {\n                        times[car][i][j] = rnd.next(999999, 1000000);\n                    }\n                }\n            }\n        }\n    } else if (type == \"zero_changes\") {\n        // Generate times normally, set k_i = 0 in rounds\n        for (int car = 0; car < m; ++car) {\n            for (int i = 0; i < n; ++i) {\n                times[car][i][i] = 0;\n                for (int j = i+1; j < n; ++j) {\n                    int t = rnd.next(0, 1000000);\n                    int t2 = rnd.next(0, 1000000);\n                    times[car][i][j] = t;\n                    times[car][j][i] = t2;\n                }\n            }\n        }\n    } else if (type == \"max_changes\") {\n        // Generate times normally, set k_i = 1000 in rounds\n        for (int car = 0; car < m; ++car) {\n            for (int i = 0; i < n; ++i) {\n                times[car][i][i] = 0;\n                for (int j = i+1; j < n; ++j) {\n                    int t = rnd.next(0, 1000000);\n                    int t2 = rnd.next(0, 1000000);\n                    times[car][i][j] = t;\n                    times[car][j][i] = t2;\n                }\n            }\n        }\n    } else if (type == \"k_variety\") {\n        // Generate times normally, k_i varies\n        for (int car = 0; car < m; ++car) {\n            for (int i = 0; i < n; ++i) {\n                times[car][i][i] = 0;\n                for (int j = i+1; j < n; ++j) {\n                    int t = rnd.next(0, 1000000);\n                    int t2 = rnd.next(0, 1000000);\n                    times[car][i][j] = t;\n                    times[car][j][i] = t2;\n                }\n            }\n        }\n    } else {\n        // Default to random\n        for (int car = 0; car < m; ++car) {\n            for (int i = 0; i < n; ++i) {\n                times[car][i][i] = 0; // diagonal zero\n                for (int j = i+1; j < n; ++j) {\n                    int t = rnd.next(0, 1000000); // time from i to j\n                    int t2 = rnd.next(0, 1000000); // time from j to i\n                    times[car][i][j] = t;\n                    times[car][j][i] = t2;\n                }\n            }\n        }\n    }\n\n    // Output n, m, r\n    printf(\"%d %d %d\\n\", n, m, r);\n\n    // Output the m matrices\n    for (int car = 0; car < m; ++car) {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                printf(\"%d\", times[car][i][j]);\n                if (j + 1 < n)\n                    printf(\" \");\n                else\n                    printf(\"\\n\");\n            }\n        }\n    }\n\n    // Now generate r rounds\n    for (int i = 0; i < r; ++i) {\n        int s_i = rnd.next(1, n);\n        int t_i = rnd.next(1, n);\n        while (t_i == s_i) {\n            t_i = rnd.next(1, n);\n        }\n        int k_i;\n        if (type == \"zero_changes\") {\n            k_i = 0;\n        } else if (type == \"max_changes\") {\n            k_i = 1000;\n        } else if (type == \"random\") {\n            k_i = rnd.next(0, 1000);\n        } else if (type == \"k_variety\") {\n            // Use various k_i values\n            if (i % 3 == 0)\n                k_i = 0;\n            else if (i % 3 == 1)\n                k_i = 1;\n            else\n                k_i = 1000;\n        } else {\n            k_i = rnd.next(0, 1000);\n        }\n        printf(\"%d %d %d\\n\", s_i, t_i, k_i);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random cases with varying n, m, r\n./gen -n 10 -m 5 -r 100 -type random\n./gen -n 15 -m 10 -r 500 -type random\n./gen -n 20 -m 15 -r 1000 -type random\n./gen -n 30 -m 30 -r 2000 -type random\n./gen -n 50 -m 50 -r 5000 -type random\n./gen -n 60 -m 60 -r 10000 -type random\n\n# Cases with maximal sizes\n./gen -n 60 -m 60 -r 100000 -type random\n./gen -n 60 -m 60 -r 100000 -type large_times\n./gen -n 60 -m 60 -r 100000 -type asymmetric\n./gen -n 60 -m 60 -r 100000 -type zero_changes\n./gen -n 60 -m 60 -r 100000 -type max_changes\n\n# Cases with small n\n./gen -n 2 -m 2 -r 100000 -type random\n./gen -n 2 -m 2 -r 100000 -type zero_changes\n\n# Cases focusing on k_i = 0\n./gen -n 30 -m 15 -r 5000 -type zero_changes\n\n# Cases focusing on max k_i\n./gen -n 30 -m 15 -r 5000 -type max_changes\n\n# Cases with varying k_i\n./gen -n 50 -m 20 -r 10000 -type k_variety\n\n# Cases where one car is better\n./gen -n 50 -m 10 -r 10000 -type one_car_better\n\n# Cases with asymmetric times\n./gen -n 50 -m 30 -r 10000 -type asymmetric\n\n# Cases with large times\n./gen -n 60 -m 60 -r 100000 -type large_times\n\n# Edge case with n=2\n./gen -n 2 -m 60 -r 100000 -type random\n\n# Edge case with m=1\n./gen -n 60 -m 1 -r 100000 -type random\n\n# Edge case with k_i=0 and m=1\n./gen -n 60 -m 1 -r 100000 -type zero_changes\n\n# Cases with only one round\n./gen -n 60 -m 60 -r 1 -type random\n\n# Cases where k_i alternates between 0 and max\n./gen -n 60 -m 60 -r 100000 -type k_variety\n\n# Additional random cases\n./gen -n 40 -m 20 -r 50000 -type random\n./gen -n 50 -m 25 -r 75000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:49.203862",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "189/E",
      "title": "E. Weak Memory",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers n, m, k (2 ≤ n ≤ 105, 0 ≤ m ≤ 2·105, 1 ≤ k ≤ n) — the number of intersections, roads and volunteers, respectively. Next line contains k distinct space-separated integers between 1 and n inclusive — the numbers of cities where volunteers are located.Next m lines describe the roads. The i-th of these lines contains two space-separated integers ui, vi (1 ≤ ui, vi ≤ n, ui ≠ vi) — two intersections that i-th road connects. There will be at most one road between any two intersections.Last line of input contains two space-separated integers s, t (1 ≤ s, t ≤ n, s ≠ t) — the initial location of PMP and the location of the buses. It might not always be possible to reach t from s.It is guaranteed that there is always a volunteer at intersection s.",
      "output_spec": "OutputPrint on the only line the answer to the problem — the minimum value of q which guarantees that PMP can find the buses. If PMP cannot reach the buses at all, output -1 instead.",
      "sample_tests": "ExamplesInputCopy6 6 31 3 61 22 34 25 64 53 41 6OutputCopy3InputCopy6 5 31 5 61 22 33 44 56 31 5OutputCopy3",
      "description": "E. Weak Memory\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers n, m, k (2 ≤ n ≤ 105, 0 ≤ m ≤ 2·105, 1 ≤ k ≤ n) — the number of intersections, roads and volunteers, respectively. Next line contains k distinct space-separated integers between 1 and n inclusive — the numbers of cities where volunteers are located.Next m lines describe the roads. The i-th of these lines contains two space-separated integers ui, vi (1 ≤ ui, vi ≤ n, ui ≠ vi) — two intersections that i-th road connects. There will be at most one road between any two intersections.Last line of input contains two space-separated integers s, t (1 ≤ s, t ≤ n, s ≠ t) — the initial location of PMP and the location of the buses. It might not always be possible to reach t from s.It is guaranteed that there is always a volunteer at intersection s.\n\nOutputPrint on the only line the answer to the problem — the minimum value of q which guarantees that PMP can find the buses. If PMP cannot reach the buses at all, output -1 instead.\n\nInputCopy6 6 31 3 61 22 34 25 64 53 41 6OutputCopy3InputCopy6 5 31 5 61 22 33 44 56 31 5OutputCopy3\n\nInputCopy6 6 31 3 61 22 34 25 64 53 41 6\n\nOutputCopy3\n\nInputCopy6 5 31 5 61 22 33 44 56 31 5\n\nOutputCopy3\n\nNoteThe first sample is illustrated below. Blue intersections are where volunteers are located. If PMP goes in the path of dashed line, it can reach the buses with q = 3:  In the second sample, PMP uses intersection 6 as an intermediate intersection, thus the answer is 3.",
      "solutions": [
        {
          "title": "Codeforces Round #119 - Codeforces",
          "content": "Hello everyone,We are glad to invite you to participate in today’s round. Problems have been prepared by poopi, Mohammad_JRS, Gerald and me. The hero of our contest is called “PMP”. It is actually the base of our team name through the last five years. The stories are metaphoric, but they have some traces in truth.This Codeforces round, is the last round before the incoming ICPC world final. Our best wishes for all participants of that contest, too. I want to specially thank Gerald for his helps and advices in problem preparation, Delinur for translation of statements into Russian and MikeMirzayanov for this great system.And we have a modified version of Burunduk1 ’s advice: “to make the round even more interesting for us, read the statements of ALL problems.” :)We hope you enjoy the problems and have high ratings.Update: Contest is over. Thanks to everyone for taking part and congratulations to the winners of both divisions, specially peter50216 for being the only who solved all the problems of division 1! :)Update: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4520",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1041
        },
        {
          "title": "Codeforces Round #119 — Editorial - Codeforces",
          "content": "Problem 189A — Cut RibbonThe problem is to maximize x+y+z subject to ax+by+cz=n. Constraints are low, so simply iterate over two variables (say x and y) and find the third variable (if any) from the second equation. Find the maximum over all feasible solutions.Other approaches: Use dynamic programming with each state being the remainder of ribbon. Select the next piece to be a, b or c.Problem 189B — Counting RhombiObserve that lots of rhombi have the same shape, but are in different locations. What uniquely determines the shape of a rhombus? Its width and its height. Is it possible to build a rhombus with every width and every height such that the vertices of the rhombus are in integer points? No, it is possible only if the width and the height are both even.How many places we can put a rhombus of width w0 and height h0 in a rectangle of width w and height h? (w * w0 + 1)(h * h0 + 1)So, iterator over all even widths and heights and for each of them add the number of possible locations to the final result.Problem 187A — PermutationsIt is easy to see that if we replace each number in the first permutation with position of that number in the second permutation, the problem reduces to sorting the first permutation.Each time we take a number from the end of array, we can postpone its insertion until we know the most suitable position for insertion. Note that it is not good to insert a number and take it again, as we could make a better decision first time we took the number. So, as long as the remainder of the array is not in increasing order, we should take more numbers from the end. But as soon as you have an increasing subsequence, you can insert the numbers you have taken to make the array sorted. Therefore to solve the problem, we find the largest i such the numbers from 1 to i are in increasing order. The answer would be n-i.Problem 187B — AlgoRaceFirst we solve the problem when the number of allowed car changes is zero (_k=0_). Let W(i,j,l) be the length of shortest path from i to j with car l. We use Floyd-Warshal on graph of each car to find this value. Then answer for the case that we can use only one car for each pair of cities i and j is:ans(0,i,j) = min W(i,j,l) for (_1≤l≤m_)This part has time complexity O(m*n^3).For larger values of maximum number of changes (_k_), we use the following equation:ans(k,i,j) = min (ans(k-1,i,l)+ans(0,l,j)) for (_1≤l≤k_)which can be computed in O(k*n^3) using dynamic programming.But how large can be k in worst case? We know that shortest paths are simple paths (i.e. they have no repeated vertices). Because otherwise we could eliminate the path we go between two appearances of one vertex and have a smaller result. This and the fact that we change the car at most once in each vertex, guarantees in any optimal solution we will not need more that n car changes. Thus the order of the solution would be O(m*n^3+n^4).Problem 187C — Weak MemoryThere were many different correct approaches to this problem during the contest. But I will explain author’s solution.First we can use binary search over the value of q. Now for a fixed q we want to check s-t connectivity.Let K be the set of all intersections with volunteers union s and t. One can use BFS from each k∈K, one by one. Then build a graph G’ with vertices K. For each two vertices k1,k2∈K add an edge between them, if their shortest distance is less than or equal to q. Finally use any path finding algorithm to check the connectivity. Unfortunately this solution has time (and space) complexity of O(|K|*m) which is not good enough.We can optimize the above solution by initiating BFS from all k∈K at once. In other words during the initialization step in BFS algorithm, we push all these vertices in the queue with distance 0. Each element in the queue also maintains its source (i.e. the source it is originating from). In BFS each time we have have a vertex u with source su and we want to set the minimum distance to a vertex v that is already set from a different path with source sv, we connect su and sv in G’ if d(u)+d(v)+1<= q, where d(x) denotes length of the shortest path from a vertex in K to x. As we are only dealing with connectivity, this approach is correct. (Proof of correctness is left as an exercise)BFS takes O(m) time and we add at most O(m) edges to G’, so the overall complexity is O(m) for a fixed q. As we used binary search to find the smallest q, we can solve the problem in O(m*logn).Problem 187D — BRT ContractWe define ti as follows: assume a bus starts moving from i-th intersection exactly at the time when the light changes to green. The time it takes for the bus to get the final station is ti. We call the times when a green interval begins t0 (so every g+r seconds t0 occurs once)If a bus gets to i-th intersection during the red phase, it should wait and then start moving at t0. So considering the fact that all lights are synchronized (and length of segments are fixed) if we have ti for i-th intersection, we can compute the time for the bus to get final station.Clearly tn is the length of the last segments. For computing ti we should find the smallest j such that if a bus starts at t0 from i-th intersection, it gets to j-th intersection during the red phase. So we have:ti=tj+d(i,j)+wwhere d(i,j) is the distance between i-th and j-th intersections and w is the time that the bus should wait behind the red light at j-th intersection. The later value can be computed easily.The only problem that remains is to find j for i-th intersection. So we start iterating over i for (n-1)-th intersection backwards and we compute ti for all intersections. Assume p=g+r and ta=d(i,j)%p. Now if the bus starts from i-th intersection at time t0 and we have ta>=g, in this case we are in red phase at j-th intersection. Actually ta should be in interval [_g, g+r_). Here we can use segment trees. That is for all intersections from i+1 to n, we store some values in the tree that helps us find the smallest j. But we should note the value of ta depends on d(i,j) which changes as i changes. Thus we cannot use ta in the tree. Instead, we define si the be the distance of i-th intersection to the destination. So we have d(i,j)=si-sj and we use the value of sj with storing –sj%p in the segment tree as the key and the value would be j itself. In other words for each intersection we store the key-value pair (-sj%p, j) in the tree. According to what we said so far, to be in the red phase at j-th intersection we should have:ta=(d(i,j)%p)=((si-sj)%p)∈[g,g+r) => -sj%p ∈ [(g-si)%p, (g+r-si)%p)As we stored –sj%p in the tree, we can retrieve the smallest j in the above interval with a query in the segment tree. This way we can compute ti for all intersections. Answering to each query in the problem can be solve in exactly the same way. So the overall complexity would be O((n+q)logn).Problem 187E — Heaven TourStep 1. Solve the problem if the starting man is the leftmost man and the finishing man is the rightmost man.Obviously every segment (the distance between two consecutive men) should be covered at least once. We also argue that at least l (the number of left tickets) segments should be covered at least three times. Proof: Each time you use a left ticket to go to man i with 1<i<n-1, the segment between i-th and (_i+1_)-th men is covered at least three times: Once for you should go after i be in a position to come back. Once for you use a left ticked to come back to i And once again you should go after i, because you want to finish at man number n Note that in the first and the last segments are always covered once, no matter what we do. But except for these two segments, every other segment can be chosen to be among the segments that are covered three times, and every combination that we choose l segments is feasible. (Proof it as practice) So we choose the smallest l segments and the problem can be solved with a simple sort in O(n*logn).Step 2. Solve the problem if the starting man is the leftmost man, but the finishing man can be anywhere.To solve this problem we first fix the finishing man. With reasoning similar to that of step 1, we conclude that at least l segments should be covered with at least two times if they are after the finishing man or three times if they are before him. But obviously every segment after the finishing man is covered at least two times. So it is always good to waste as many left tickets as possible after the finishing man to prevent them from breaching the left side of finishing man and becoming multiple three.So the algorithm would be: iterate over i, the number of finishing man, and maintain the l-(n-i) smallest segments to the right of finishing man as you progress. This can be implemented in O(n*logn).Step 3. Solve the problem if the starting man is fixed, but the finishing man can be anywhere.Assume that the starting man is not the first man or the last man, otherwise we could use algorithm of step 2 to solve the problem. Without loss of generality assume that you finish your tour to the right side of finishing man. Therefore every segment to the left of starting man is covered at least two times and actually it is always possible to arrange visits such that every segment to right is covered exactly two times. So just like what we said in step 2, it is good to waste as many left tickets as possible in this area.So the algorithm would be, choose to finish left or right first, then greedily waste as many bad moves (by bad moves I mean the moves that if breach to the other side will be more costly) as possible there and follow the algorithm in step 2 to solve the whole problem.There are some special cases such as when the tour cannot be finished at all, that we left to readers find a way how to handle them.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4540",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 189 和字母"
          },
          "content_length": 9777
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #119 - Codeforces - Code 1",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 2",
          "code": "for(int c=1;c<1000;c++)\n        for(int c2=1;c2<1000;c2++)\n            for(int c3=1;c3<1000;c3++)\n                if((c-c2)%c3!=0&&(c-c3)%c2!=0&&c%(c2+c3)==0)\n                    std::cout<<c<<\" \"<<c2<<\" \"<<c3<<std::endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 3",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 4",
          "code": "timer[i][j][k] = min(timer[i][j][k], timer[i][j][f] + timer[i][f][k]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 5",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #119 - Codeforces - Code 6",
          "code": "timer[i][k][f] = min(timer[i][k][f], timer[i][k][j] + timer[i][j][f]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4520",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100000, \"n\"); // 2 ≤ n ≤ 1e5\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\"); // 0 ≤ m ≤ 2e5\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\"); // 1 ≤ k ≤ n\n    inf.readEoln();\n    \n    vector<int> volunteers = inf.readInts(k, 1, n, \"volunteers\");\n    inf.readEoln();\n\n    // Ensure volunteers are distinct\n    set<int> volunteerSet(volunteers.begin(), volunteers.end());\n    ensuref(volunteerSet.size() == volunteers.size(), \"Volunteer positions must be distinct\");\n    \n    // Read and process m edges\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(ui != vi, \"Road cannot connect an intersection to itself (ui != vi)\");\n        pair<int,int> edge = {min(ui, vi), max(ui, vi)};\n        ensuref(edges.count(edge) == 0, \"Duplicate edges between intersections %d and %d\", edge.first, edge.second);\n        edges.insert(edge);\n    }\n    \n    // Read s and t\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    int t = inf.readInt(1, n, \"t\");\n    inf.readEoln();\n    \n    ensuref(s != t, \"s cannot be equal to t\");\n    \n    // Ensure there is a volunteer at intersection s\n    ensuref(volunteerSet.count(s) == 1, \"There must be a volunteer at intersection s\");\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100000, \"n\"); // 2 ≤ n ≤ 1e5\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\"); // 0 ≤ m ≤ 2e5\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\"); // 1 ≤ k ≤ n\n    inf.readEoln();\n    \n    vector<int> volunteers = inf.readInts(k, 1, n, \"volunteers\");\n    inf.readEoln();\n\n    // Ensure volunteers are distinct\n    set<int> volunteerSet(volunteers.begin(), volunteers.end());\n    ensuref(volunteerSet.size() == volunteers.size(), \"Volunteer positions must be distinct\");\n    \n    // Read and process m edges\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(ui != vi, \"Road cannot connect an intersection to itself (ui != vi)\");\n        pair<int,int> edge = {min(ui, vi), max(ui, vi)};\n        ensuref(edges.count(edge) == 0, \"Duplicate edges between intersections %d and %d\", edge.first, edge.second);\n        edges.insert(edge);\n    }\n    \n    // Read s and t\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    int t = inf.readInt(1, n, \"t\");\n    inf.readEoln();\n    \n    ensuref(s != t, \"s cannot be equal to t\");\n    \n    // Ensure there is a volunteer at intersection s\n    ensuref(volunteerSet.count(s) == 1, \"There must be a volunteer at intersection s\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100000, \"n\"); // 2 ≤ n ≤ 1e5\n    inf.readSpace();\n    int m = inf.readInt(0, 200000, \"m\"); // 0 ≤ m ≤ 2e5\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\"); // 1 ≤ k ≤ n\n    inf.readEoln();\n    \n    vector<int> volunteers = inf.readInts(k, 1, n, \"volunteers\");\n    inf.readEoln();\n\n    // Ensure volunteers are distinct\n    set<int> volunteerSet(volunteers.begin(), volunteers.end());\n    ensuref(volunteerSet.size() == volunteers.size(), \"Volunteer positions must be distinct\");\n    \n    // Read and process m edges\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(ui != vi, \"Road cannot connect an intersection to itself (ui != vi)\");\n        pair<int,int> edge = {min(ui, vi), max(ui, vi)};\n        ensuref(edges.count(edge) == 0, \"Duplicate edges between intersections %d and %d\", edge.first, edge.second);\n        edges.insert(edge);\n    }\n    \n    // Read s and t\n    int s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    int t = inf.readInt(1, n, \"t\");\n    inf.readEoln();\n    \n    ensuref(s != t, \"s cannot be equal to t\");\n    \n    // Ensure there is a volunteer at intersection s\n    ensuref(volunteerSet.count(s) == 1, \"There must be a volunteer at intersection s\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\");\n    int s = opt<int>(\"s\", -1);\n    int t = opt<int>(\"t\", -1);\n\n    // Ensure n and m are within constraints\n    n = min(n, 100000);\n    m = min(m, 200000);\n\n    // Ensure s and t are valid\n    if (s == -1) s = rnd.next(1, n);\n    if (t == -1) {\n        do {\n            t = rnd.next(1, n);\n        } while (t == s);\n    }\n\n    // Ensure k >= 1, and s is among volunteers\n    // Because the problem says: There is always a volunteer at intersection s.\n\n    set<int> volunteer_set;\n    volunteer_set.insert(s);\n\n    if (type == \"volunteer_at_t\") {\n        volunteer_set.insert(t);\n    }\n\n    while ((int)volunteer_set.size() < k) {\n        int v = rnd.next(1, n);\n        volunteer_set.insert(v);\n    }\n    vector<int> volunteers(volunteer_set.begin(), volunteer_set.end());\n    shuffle(volunteers.begin(), volunteers.end());\n\n    // Generate edges\n    vector<pair<int,int>> edges;\n\n    if (type == \"random\") {\n        set<pair<int,int>> edge_set;\n\n        if (m >= n - 1) {\n            // Generate a random connected tree\n            vector<int> parent(n + 1);\n            parent[1] = 1;\n            for (int i = 2; i <= n; i++) {\n                int p = rnd.next(1, i - 1);\n                parent[i] = p;\n                int u = i;\n                int v = p;\n                if (u > v) swap(u,v);\n                edge_set.insert({u,v});\n            }\n            // Now, add extra random edges\n            while ((int)edge_set.size() < m) {\n                int u = rnd.next(1, n);\n                int v = rnd.next(1, n);\n                if (u == v) continue;\n                if (u > v) swap(u,v);\n                if (edge_set.count({u,v})) continue;\n                edge_set.insert({u,v});\n            }\n        } else {\n            // m < n -1, generate random edges\n            while ((int)edge_set.size() < m) {\n                int u = rnd.next(1, n);\n                int v = rnd.next(1, n);\n                if (u == v) continue;\n                if (u > v) swap(u,v);\n                if (edge_set.count({u,v})) continue;\n                edge_set.insert({u,v});\n            }\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n    else if (type == \"chain\") {\n        vector<int> nodes;\n        for (int i = 1; i <= n; i++) {\n            if (i != s && i != t) {\n                nodes.push_back(i);\n            }\n        }\n        shuffle(nodes.begin(), nodes.end());\n        vector<int> path;\n        path.push_back(s);\n        for (int x : nodes) {\n            path.push_back(x);\n        }\n        path.push_back(t);\n        int path_len = path.size();\n        set<pair<int,int>> edge_set;\n        for (int i = 0; i + 1 < path_len; i++) {\n            int u = path[i];\n            int v = path[i + 1];\n            if (u > v) swap(u,v);\n            edge_set.insert({u,v});\n        }\n        // Add extra edges if needed\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u,v);\n            if (edge_set.count({u,v})) continue;\n            edge_set.insert({u,v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n    else if (type == \"star\") {\n        int center = s;\n        set<pair<int,int>> edge_set;\n        for (int i = 1; i <= n; i++) {\n            if (i == center) continue;\n            int u = min(center, i);\n            int v = max(center, i);\n            edge_set.insert({u, v});\n            if ((int)edge_set.size() >= m) break;\n        }\n        // Add extra edges if needed\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u,v);\n            if (edge_set.count({u,v})) continue;\n            edge_set.insert({u,v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n    else if (type == \"disconnected\") {\n        assert(n >= 2);\n        // Split nodes into two sets, one with s, one with t\n        vector<int> comp1, comp2;\n        comp1.push_back(s);\n        for (int i = 1; i <= n; i++) {\n            if (i != s && i != t) {\n                if (rnd.next(0, 1) == 0)\n                    comp1.push_back(i);\n                else\n                    comp2.push_back(i);\n            }\n        }\n        comp2.push_back(t);\n        // Now generate edges within comp1 and comp2\n        set<pair<int,int>> edge_set;\n        auto add_edges = [&](vector<int>& comp) {\n            int csize = comp.size();\n            if (csize <= 1) return;\n            for (int i = 1; i < csize; i++) {\n                int u = comp[i];\n                int v = comp[rnd.next(0, i - 1)];\n                if (u > v) swap(u, v);\n                edge_set.insert({u, v});\n            }\n        };\n        add_edges(comp1);\n        add_edges(comp2);\n\n        // Add extra edges within components if needed\n        while ((int)edge_set.size() < m) {\n            // Randomly pick a component\n            vector<int>& comp = rnd.next(0, 1) == 0 ? comp1 : comp2;\n            if (comp.size() < 2) continue;\n            int u = comp[rnd.next(0, (int)comp.size() - 1)];\n            int v = comp[rnd.next(0, (int)comp.size() - 1)];\n            if (u == v) continue;\n            if (u > v) swap(u,v);\n            if (edge_set.count({u,v})) continue;\n            edge_set.insert({u,v});\n        }\n\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n    else if (type == \"no_edges\") {\n        edges.clear();\n    }\n    else if (type == \"volunteer_at_t\") {\n        // Ensure t is included in volunteers (already ensured above)\n        // Generate random graph (connectivity not guaranteed)\n        set<pair<int,int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u,v);\n            if (edge_set.count({u,v})) continue;\n            edge_set.insert({u,v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n    else {\n        // Default to random type\n        set<pair<int,int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u,v);\n            if (edge_set.count({u,v})) continue;\n            edge_set.insert({u,v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output volunteers\n    for (int i = 0; i < k; i++) {\n        printf(\"%d%c\", volunteers[i], i + 1 == k ? '\\n' : ' ');\n    }\n\n    // Output m edges\n    for (size_t i = 0; i < edges.size(); i++) {\n        printf(\"%d %d\\n\", edges[i].first, edges[i].second);\n    }\n\n    // Output s and t\n    printf(\"%d %d\\n\", s, t);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\");\n    int s = opt<int>(\"s\", -1);\n    int t = opt<int>(\"t\", -1);\n\n    // Ensure n and m are within constraints\n    n = min(n, 100000);\n    m = min(m, 200000);\n\n    // Ensure s and t are valid\n    if (s == -1) s = rnd.next(1, n);\n    if (t == -1) {\n        do {\n            t = rnd.next(1, n);\n        } while (t == s);\n    }\n\n    // Ensure k >= 1, and s is among volunteers\n    // Because the problem says: There is always a volunteer at intersection s.\n\n    set<int> volunteer_set;\n    volunteer_set.insert(s);\n\n    if (type == \"volunteer_at_t\") {\n        volunteer_set.insert(t);\n    }\n\n    while ((int)volunteer_set.size() < k) {\n        int v = rnd.next(1, n);\n        volunteer_set.insert(v);\n    }\n    vector<int> volunteers(volunteer_set.begin(), volunteer_set.end());\n    shuffle(volunteers.begin(), volunteers.end());\n\n    // Generate edges\n    vector<pair<int,int>> edges;\n\n    if (type == \"random\") {\n        set<pair<int,int>> edge_set;\n\n        if (m >= n - 1) {\n            // Generate a random connected tree\n            vector<int> parent(n + 1);\n            parent[1] = 1;\n            for (int i = 2; i <= n; i++) {\n                int p = rnd.next(1, i - 1);\n                parent[i] = p;\n                int u = i;\n                int v = p;\n                if (u > v) swap(u,v);\n                edge_set.insert({u,v});\n            }\n            // Now, add extra random edges\n            while ((int)edge_set.size() < m) {\n                int u = rnd.next(1, n);\n                int v = rnd.next(1, n);\n                if (u == v) continue;\n                if (u > v) swap(u,v);\n                if (edge_set.count({u,v})) continue;\n                edge_set.insert({u,v});\n            }\n        } else {\n            // m < n -1, generate random edges\n            while ((int)edge_set.size() < m) {\n                int u = rnd.next(1, n);\n                int v = rnd.next(1, n);\n                if (u == v) continue;\n                if (u > v) swap(u,v);\n                if (edge_set.count({u,v})) continue;\n                edge_set.insert({u,v});\n            }\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n    else if (type == \"chain\") {\n        vector<int> nodes;\n        for (int i = 1; i <= n; i++) {\n            if (i != s && i != t) {\n                nodes.push_back(i);\n            }\n        }\n        shuffle(nodes.begin(), nodes.end());\n        vector<int> path;\n        path.push_back(s);\n        for (int x : nodes) {\n            path.push_back(x);\n        }\n        path.push_back(t);\n        int path_len = path.size();\n        set<pair<int,int>> edge_set;\n        for (int i = 0; i + 1 < path_len; i++) {\n            int u = path[i];\n            int v = path[i + 1];\n            if (u > v) swap(u,v);\n            edge_set.insert({u,v});\n        }\n        // Add extra edges if needed\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u,v);\n            if (edge_set.count({u,v})) continue;\n            edge_set.insert({u,v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n    else if (type == \"star\") {\n        int center = s;\n        set<pair<int,int>> edge_set;\n        for (int i = 1; i <= n; i++) {\n            if (i == center) continue;\n            int u = min(center, i);\n            int v = max(center, i);\n            edge_set.insert({u, v});\n            if ((int)edge_set.size() >= m) break;\n        }\n        // Add extra edges if needed\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u,v);\n            if (edge_set.count({u,v})) continue;\n            edge_set.insert({u,v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n    else if (type == \"disconnected\") {\n        assert(n >= 2);\n        // Split nodes into two sets, one with s, one with t\n        vector<int> comp1, comp2;\n        comp1.push_back(s);\n        for (int i = 1; i <= n; i++) {\n            if (i != s && i != t) {\n                if (rnd.next(0, 1) == 0)\n                    comp1.push_back(i);\n                else\n                    comp2.push_back(i);\n            }\n        }\n        comp2.push_back(t);\n        // Now generate edges within comp1 and comp2\n        set<pair<int,int>> edge_set;\n        auto add_edges = [&](vector<int>& comp) {\n            int csize = comp.size();\n            if (csize <= 1) return;\n            for (int i = 1; i < csize; i++) {\n                int u = comp[i];\n                int v = comp[rnd.next(0, i - 1)];\n                if (u > v) swap(u, v);\n                edge_set.insert({u, v});\n            }\n        };\n        add_edges(comp1);\n        add_edges(comp2);\n\n        // Add extra edges within components if needed\n        while ((int)edge_set.size() < m) {\n            // Randomly pick a component\n            vector<int>& comp = rnd.next(0, 1) == 0 ? comp1 : comp2;\n            if (comp.size() < 2) continue;\n            int u = comp[rnd.next(0, (int)comp.size() - 1)];\n            int v = comp[rnd.next(0, (int)comp.size() - 1)];\n            if (u == v) continue;\n            if (u > v) swap(u,v);\n            if (edge_set.count({u,v})) continue;\n            edge_set.insert({u,v});\n        }\n\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n    else if (type == \"no_edges\") {\n        edges.clear();\n    }\n    else if (type == \"volunteer_at_t\") {\n        // Ensure t is included in volunteers (already ensured above)\n        // Generate random graph (connectivity not guaranteed)\n        set<pair<int,int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u,v);\n            if (edge_set.count({u,v})) continue;\n            edge_set.insert({u,v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n    else {\n        // Default to random type\n        set<pair<int,int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u,v);\n            if (edge_set.count({u,v})) continue;\n            edge_set.insert({u,v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    }\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output volunteers\n    for (int i = 0; i < k; i++) {\n        printf(\"%d%c\", volunteers[i], i + 1 == k ? '\\n' : ' ');\n    }\n\n    // Output m edges\n    for (size_t i = 0; i < edges.size(); i++) {\n        printf(\"%d %d\\n\", edges[i].first, edges[i].second);\n    }\n\n    // Output s and t\n    printf(\"%d %d\\n\", s, t);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small graphs\n./gen -n 2 -m 1 -k 1 -type random\n./gen -n 2 -m 0 -k 1 -type no_edges\n\n# Chain graphs\n./gen -n 10 -m 9 -k 1 -type chain\n./gen -n 100 -m 99 -k 1 -type chain\n./gen -n 1000 -m 999 -k 1 -type chain\n./gen -n 10000 -m 9999 -k 1 -type chain\n./gen -n 100000 -m 99999 -k 1 -type chain\n\n# Star graphs\n./gen -n 10 -m 9 -k 1 -type star\n./gen -n 100 -m 99 -k 1 -type star\n./gen -n 1000 -m 999 -k 1 -type star\n./gen -n 10000 -m 9999 -k 1 -type star\n./gen -n 100000 -m 99999 -k 1 -type star\n\n# Random graphs\n./gen -n 10 -m 20 -k 2 -type random\n./gen -n 100 -m 200 -k 5 -type random\n./gen -n 1000 -m 5000 -k 10 -type random\n./gen -n 10000 -m 50000 -k 100 -type random\n./gen -n 100000 -m 200000 -k 1000 -type random\n\n# Disconnected graphs\n./gen -n 10 -m 5 -k 2 -type disconnected\n./gen -n 100 -m 50 -k 5 -type disconnected\n./gen -n 1000 -m 500 -k 10 -type disconnected\n./gen -n 10000 -m 5000 -k 100 -type disconnected\n\n# Volunteering at t\n./gen -n 10 -m 15 -k 3 -type volunteer_at_t\n./gen -n 100 -m 150 -k 5 -type volunteer_at_t\n./gen -n 1000 -m 2000 -k 50 -type volunteer_at_t\n./gen -n 10000 -m 20000 -k 500 -type volunteer_at_t\n\n# Maximum edges\n./gen -n 100000 -m 200000 -k 10000 -type random\n\n# No edges\n./gen -n 100000 -m 0 -k 1 -type no_edges\n\n# Minimum volunteers\n./gen -n 100000 -m 100000 -k 1 -type random\n\n# Volunteers everywhere\n./gen -n 100000 -m 200000 -k 100000 -type random\n\n# Minimum q large\n./gen -n 100000 -m 99999 -k 2 -type chain\n\n# Minimum q small\n./gen -n 100000 -m 199998 -k 2 -type star\n\n# No path between s and t\n./gen -n 100000 -m 1000 -k 100 -type disconnected\n\n# Graphs with m less than n-1\n./gen -n 1000 -m 500 -k 10 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:51.268040",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "19/A",
      "title": "A. Чемпионат мира по футболу",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест64 megabytes",
      "input_spec": "Входные данныеВ первой строке входных данных написано единственное целое число n (1 ≤ n ≤ 50) — количество команд, прошедших в финальную часть ЧМ. Далее в n строках написаны названия команд, представляющие собой строки из строчных и прописных латинских букв длиной не более 30 символов. Следующие n·(n - 1) / 2 строк описывают проведенные матчи в формате name1-name2 num1:num2, где name1, name2 — названия команд; num1, num2 (0 ≤ num1, num2 ≤ 100) — количество голов, забитых соответствующими командами. Гарантируется корректность описания чемпионата, в частности, не существуют двух команд с одинаковыми с точностью до регистра названиями, не существует описания матча, в котором команда играет сама с собой, каждый матч встречается в описании ровно один раз.",
      "output_spec": "Выходные данныеВыведите в выходной файл n / 2 строк — названия вышедших в плей-офф команд в лексикографическом порядке. Каждое название выводите на отдельной строке. Посторонние символы (включая пробелы) не допускаются. Гарантируется, что описанные правила позволяют однозначно упорядочить команды.",
      "sample_tests": "ПримерыВходные данныеСкопировать4ABCDA-B 1:1A-C 2:2A-D 1:0B-C 1:0B-D 0:3C-D 0:3Выходные данныеСкопироватьADВходные данныеСкопировать2aAa-A 2:1Выходные данныеСкопироватьa",
      "description": "A. Чемпионат мира по футболу\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест64 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных написано единственное целое число n (1 ≤ n ≤ 50) — количество команд, прошедших в финальную часть ЧМ. Далее в n строках написаны названия команд, представляющие собой строки из строчных и прописных латинских букв длиной не более 30 символов. Следующие n·(n - 1) / 2 строк описывают проведенные матчи в формате name1-name2 num1:num2, где name1, name2 — названия команд; num1, num2 (0 ≤ num1, num2 ≤ 100) — количество голов, забитых соответствующими командами. Гарантируется корректность описания чемпионата, в частности, не существуют двух команд с одинаковыми с точностью до регистра названиями, не существует описания матча, в котором команда играет сама с собой, каждый матч встречается в описании ровно один раз.\n\nВходные данные\n\nВыходные данныеВыведите в выходной файл n / 2 строк — названия вышедших в плей-офф команд в лексикографическом порядке. Каждое название выводите на отдельной строке. Посторонние символы (включая пробелы) не допускаются. Гарантируется, что описанные правила позволяют однозначно упорядочить команды.\n\nВыходные данные\n\nВходные данныеСкопировать4ABCDA-B 1:1A-C 2:2A-D 1:0B-C 1:0B-D 0:3C-D 0:3Выходные данныеСкопироватьADВходные данныеСкопировать2aAa-A 2:1Выходные данныеСкопироватьa\n\nВходные данныеСкопировать4ABCDA-B 1:1A-C 2:2A-D 1:0B-C 1:0B-D 0:3C-D 0:3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьAD\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2aAa-A 2:1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьa\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #19 - Codeforces",
          "content": "Доброго времени суток всем.В этот чудесный летний день приглашаю вас принять участие в Codeforces Beta Round #19. Сегодня авторами задач для Вас буду я и Артем Рахов. Также выражаю благодарность всем, кто помогает нам в организации этого соревнования: Михаилу Мирзаянову, Эдварду Давтяну  и Юлии Сатушиной.Надеюсь, что вам понравится.Всем успехов!P.S. После начала соревнования вы сможете скачать условия на русском и на английском языках.UPD. Контест окончен, всем спасибо за участие. Поздравляем победителя, единственного участника, который решил все предложенные задачи - kalinovВы можете посмотреть результаты и задачи.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/484",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 19 和字母"
          },
          "content_length": 623
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces",
          "content": "I find that no one write a solution about this contest..So I write one.. A. World Football Cup I think is' just a problem about writing code  quickly and correctly.Just follow the statement. if you use c++ STL will make you life easier B. Checkout Assistant First,for every i increase ti by 1..then you will  see that statement require sum of t of the items  bigger or equal to n..and their sum of c should  be minimal..so it's just a 0-1 knapsack problem. C. Deletion of Repeats First let's generate all repeats.In a repeat,the  first number and the middle number must be the  same, so we just look at all pair of postion which  have same number..Thank to the statement..There  are at most O(10N) such pair..And use suffix array  to check if each pair can build a repeat...Then  just sort all the interval and go through then to  get the answer...http://en.wikipedia.org/wiki/Suffix_arraymaybe you think suffix array is hard to code..you can use hash and binary search to do the same..my code here http://www.ideone.com/N5zPS D. Points First of all,do the discretization.Then the biggest  value of x is n,so we can build a Segment Tree to  Ask the question \"what is the first place from   postion x and its value is bigger than y\"..if we  find such postion we just find the smallest Y-value  bigger than y in such postion--it can be done using  set's operation upper_bound...http://en.wikipedia.org/wiki/Segment_tree so the algorithm is clear..For every possible value  of x use a set to store all y value in it..And every  time the action is \"find\" or \"remove\" just change  this set and update the Segment Tree..otherwise use  Segment Tree to find the answer..my code here http://www.ideone.com/4iNolE. Fairy It's a interesting problem.If you for every edge,  try to remove it and check if it is a bipartite  graph..I think it will get TLE..so let's analysis  the property of bipartite graph..http://en.wikipedia.org/wiki/Bipartite_graphAfter reading it...we know.. It should never contain a cycle of odd length... and it can be 2-colored.. so first build a spanning forest for the graph.. and do the 2-color on it(Tree can be 2-colored). for convenience. Let TreeEdge={all edge in forest} NotTreeEdge={All edge}/TreeEdge ErrorEdge={all edge that two endpoint have the same color..} NotErorEdge=NotTreeEdge/ErroEdge.. First,consider a edge form NotTreeEdge,remove it  can't change any node's color..so.. if |ErrorEdge|=0 of course we can remove all NotTreeEdge if =1 we just can remove the ErrorEdge if >1 we can't remove any from NotTreeEdge Now,Let consider a Edge e from TreeEdge.. Let Path(Edge e)=the path in forest between e's two endpoints.. if there is a Edge e' from ErrorEdge that Path(e')  didn't  go through e..it will destroy the bipartite  graph.. if there is a Edge e' from ErrorEdge that Path(e') go through e and there is a Edge e'' from NotErrorEdge that Path(e'') go through e..it will also destroy the bipartite graph.. so now we need to know for every edge,how many such path go through it..it require a data structure... one way is to use heavy-light decomposition then we can update every path in O(LogN^2)... another way is to use Link-Cut Tree..It can do the same in O(LogN)....if you didn't see Link-Cut tree before,you can read thishttp://www.cs.cmu.edu/~sleator/papers/dynamic-trees.pdfor my code..use heavy-light decomposition http://www.ideone.com/dPS5N",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/559",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3385
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #19 - Codeforces - Code 1",
          "code": "<A HREF=\"http://ideone.com/djbUe\">Code</A> is here. Can anyone tell where i am wrong.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/484",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 1",
          "code": "http://www.ideone.com/dPS5N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 2",
          "code": "12 1 2 1 3 4 2 1 2 1 3 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 3",
          "code": "6 1 2 1 3 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 4",
          "code": "5 2 1 3 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    ensuref(n % 2 == 0, \"n must be even but n = %d\", n);\n    inf.readEoln();\n\n    vector<string> team_names;\n    set<string> team_names_set;\n    map<string, int> team_name_to_index;\n    string team_name_pattern = \"[a-zA-Z]{1,30}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(team_name_pattern, \"team_name\");\n        ensuref(team_names_set.count(s) == 0, \"Team name '%s' is duplicate\", s.c_str());\n        team_names.push_back(s);\n        team_names_set.insert(s);\n        team_name_to_index[s] = i;\n    }\n\n    int m = n * (n - 1) / 2;\n    set<pair<int, int>> matches_set;\n\n    string num_pattern = \"(0|[1-9][0-9]?|100)\";\n    string match_line_pattern = team_name_pattern + \"-\" + team_name_pattern + \" \" + num_pattern + \":\" + num_pattern;\n    for (int i = 0; i < m; ++i) {\n        string line = inf.readLine(match_line_pattern, \"match_line\");\n\n        // Now parse the line to extract parts\n        size_t dash_pos = line.find('-');\n        ensuref(dash_pos != string::npos, \"Invalid match line format; missing '-'\");\n\n        string name1 = line.substr(0, dash_pos);\n        size_t space_pos = line.find(' ', dash_pos + 1);\n        ensuref(space_pos != string::npos, \"Invalid match line format; missing space after team names\");\n\n        string name2 = line.substr(dash_pos + 1, space_pos - dash_pos - 1);\n\n        string scores_str = line.substr(space_pos + 1);\n        size_t colon_pos = scores_str.find(':');\n        ensuref(colon_pos != string::npos, \"Invalid match line format; missing ':' in scores\");\n\n        string num1_str = scores_str.substr(0, colon_pos);\n        string num2_str = scores_str.substr(colon_pos + 1);\n\n        ensuref(team_names_set.count(name1) == 1, \"Team name1 '%s' not found in the team list\", name1.c_str());\n        ensuref(team_names_set.count(name2) == 1, \"Team name2 '%s' not found in the team list\", name2.c_str());\n        ensuref(name1 != name2, \"Team cannot play against itself: %s vs %s\", name1.c_str(), name2.c_str());\n\n        int idx1 = team_name_to_index[name1];\n        int idx2 = team_name_to_index[name2];\n\n        ensuref(idx1 != idx2, \"Team cannot play against itself\");\n\n        int a = min(idx1, idx2);\n        int b = max(idx1, idx2);\n        pair<int, int> match_pair = make_pair(a, b);\n\n        ensuref(matches_set.count(match_pair) == 0, \"Duplicate match between '%s' and '%s'\", name1.c_str(), name2.c_str());\n        matches_set.insert(match_pair);\n\n        // Check that num1_str and num2_str are valid numbers between 0 and 100\n        int num1 = stoi(num1_str);\n        int num2 = stoi(num2_str);\n\n        ensuref(0 <= num1 && num1 <= 100, \"Score num1 must be between 0 and 100 inclusive, but got %d\", num1);\n        ensuref(0 <= num2 && num2 <= 100, \"Score num2 must be between 0 and 100 inclusive, but got %d\", num2);\n    }\n\n    ensuref(matches_set.size() == m, \"Expected %d matches, but got %d unique matches\", m, matches_set.size());\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    ensuref(n % 2 == 0, \"n must be even but n = %d\", n);\n    inf.readEoln();\n\n    vector<string> team_names;\n    set<string> team_names_set;\n    map<string, int> team_name_to_index;\n    string team_name_pattern = \"[a-zA-Z]{1,30}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(team_name_pattern, \"team_name\");\n        ensuref(team_names_set.count(s) == 0, \"Team name '%s' is duplicate\", s.c_str());\n        team_names.push_back(s);\n        team_names_set.insert(s);\n        team_name_to_index[s] = i;\n    }\n\n    int m = n * (n - 1) / 2;\n    set<pair<int, int>> matches_set;\n\n    string num_pattern = \"(0|[1-9][0-9]?|100)\";\n    string match_line_pattern = team_name_pattern + \"-\" + team_name_pattern + \" \" + num_pattern + \":\" + num_pattern;\n    for (int i = 0; i < m; ++i) {\n        string line = inf.readLine(match_line_pattern, \"match_line\");\n\n        // Now parse the line to extract parts\n        size_t dash_pos = line.find('-');\n        ensuref(dash_pos != string::npos, \"Invalid match line format; missing '-'\");\n\n        string name1 = line.substr(0, dash_pos);\n        size_t space_pos = line.find(' ', dash_pos + 1);\n        ensuref(space_pos != string::npos, \"Invalid match line format; missing space after team names\");\n\n        string name2 = line.substr(dash_pos + 1, space_pos - dash_pos - 1);\n\n        string scores_str = line.substr(space_pos + 1);\n        size_t colon_pos = scores_str.find(':');\n        ensuref(colon_pos != string::npos, \"Invalid match line format; missing ':' in scores\");\n\n        string num1_str = scores_str.substr(0, colon_pos);\n        string num2_str = scores_str.substr(colon_pos + 1);\n\n        ensuref(team_names_set.count(name1) == 1, \"Team name1 '%s' not found in the team list\", name1.c_str());\n        ensuref(team_names_set.count(name2) == 1, \"Team name2 '%s' not found in the team list\", name2.c_str());\n        ensuref(name1 != name2, \"Team cannot play against itself: %s vs %s\", name1.c_str(), name2.c_str());\n\n        int idx1 = team_name_to_index[name1];\n        int idx2 = team_name_to_index[name2];\n\n        ensuref(idx1 != idx2, \"Team cannot play against itself\");\n\n        int a = min(idx1, idx2);\n        int b = max(idx1, idx2);\n        pair<int, int> match_pair = make_pair(a, b);\n\n        ensuref(matches_set.count(match_pair) == 0, \"Duplicate match between '%s' and '%s'\", name1.c_str(), name2.c_str());\n        matches_set.insert(match_pair);\n\n        // Check that num1_str and num2_str are valid numbers between 0 and 100\n        int num1 = stoi(num1_str);\n        int num2 = stoi(num2_str);\n\n        ensuref(0 <= num1 && num1 <= 100, \"Score num1 must be between 0 and 100 inclusive, but got %d\", num1);\n        ensuref(0 <= num2 && num2 <= 100, \"Score num2 must be between 0 and 100 inclusive, but got %d\", num2);\n    }\n\n    ensuref(matches_set.size() == m, \"Expected %d matches, but got %d unique matches\", m, matches_set.size());\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    ensuref(n % 2 == 0, \"n must be even but n = %d\", n);\n    inf.readEoln();\n\n    vector<string> team_names;\n    set<string> team_names_set;\n    map<string, int> team_name_to_index;\n    string team_name_pattern = \"[a-zA-Z]{1,30}\";\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(team_name_pattern, \"team_name\");\n        ensuref(team_names_set.count(s) == 0, \"Team name '%s' is duplicate\", s.c_str());\n        team_names.push_back(s);\n        team_names_set.insert(s);\n        team_name_to_index[s] = i;\n    }\n\n    int m = n * (n - 1) / 2;\n    set<pair<int, int>> matches_set;\n\n    string num_pattern = \"(0|[1-9][0-9]?|100)\";\n    string match_line_pattern = team_name_pattern + \"-\" + team_name_pattern + \" \" + num_pattern + \":\" + num_pattern;\n    for (int i = 0; i < m; ++i) {\n        string line = inf.readLine(match_line_pattern, \"match_line\");\n\n        // Now parse the line to extract parts\n        size_t dash_pos = line.find('-');\n        ensuref(dash_pos != string::npos, \"Invalid match line format; missing '-'\");\n\n        string name1 = line.substr(0, dash_pos);\n        size_t space_pos = line.find(' ', dash_pos + 1);\n        ensuref(space_pos != string::npos, \"Invalid match line format; missing space after team names\");\n\n        string name2 = line.substr(dash_pos + 1, space_pos - dash_pos - 1);\n\n        string scores_str = line.substr(space_pos + 1);\n        size_t colon_pos = scores_str.find(':');\n        ensuref(colon_pos != string::npos, \"Invalid match line format; missing ':' in scores\");\n\n        string num1_str = scores_str.substr(0, colon_pos);\n        string num2_str = scores_str.substr(colon_pos + 1);\n\n        ensuref(team_names_set.count(name1) == 1, \"Team name1 '%s' not found in the team list\", name1.c_str());\n        ensuref(team_names_set.count(name2) == 1, \"Team name2 '%s' not found in the team list\", name2.c_str());\n        ensuref(name1 != name2, \"Team cannot play against itself: %s vs %s\", name1.c_str(), name2.c_str());\n\n        int idx1 = team_name_to_index[name1];\n        int idx2 = team_name_to_index[name2];\n\n        ensuref(idx1 != idx2, \"Team cannot play against itself\");\n\n        int a = min(idx1, idx2);\n        int b = max(idx1, idx2);\n        pair<int, int> match_pair = make_pair(a, b);\n\n        ensuref(matches_set.count(match_pair) == 0, \"Duplicate match between '%s' and '%s'\", name1.c_str(), name2.c_str());\n        matches_set.insert(match_pair);\n\n        // Check that num1_str and num2_str are valid numbers between 0 and 100\n        int num1 = stoi(num1_str);\n        int num2 = stoi(num2_str);\n\n        ensuref(0 <= num1 && num1 <= 100, \"Score num1 must be between 0 and 100 inclusive, but got %d\", num1);\n        ensuref(0 <= num2 && num2 <= 100, \"Score num2 must be between 0 and 100 inclusive, but got %d\", num2);\n    }\n\n    ensuref(matches_set.size() == m, \"Expected %d matches, but got %d unique matches\", m, matches_set.size());\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateTeams(vector<string>& teams, int n, string type) {\n    if (type == \"similar_names\") {\n        for (int i = 0; i < n; ++i) {\n            string name = \"Team\" + to_string(i / 10);\n            for (char & ch : name) {\n                if (rnd.next(2))\n                    ch = toupper(ch);\n                else\n                    ch = tolower(ch);\n            }\n            teams.push_back(name);\n        }\n    } else if (type == \"case_sensitivity\") {\n        for (int i = 0; i < n; ++i) {\n            string name = string(1, 'A' + (i % 26));\n            if (rnd.next(2))\n                name[0] = toupper(name[0]);\n            else\n                name[0] = tolower(name[0]);\n            teams.push_back(name);\n        }\n    } else {\n        set<string> used_names;\n        while ((int)teams.size() < n) {\n            int len = rnd.next(1, 30);\n            string name;\n            for (int i = 0; i < len; ++i) {\n                char ch = 'A' + rnd.next(52);\n                if (ch > 'Z') ch = 'a' + (ch - 'A' - 26);\n                name += ch;\n            }\n            if (used_names.count(name)) continue;\n            used_names.insert(name);\n            teams.push_back(name);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    if (n < 1 || n > 50 || n % 2 != 0) {\n        fprintf(stderr, \"Invalid value of n: %d\\n\", n);\n        return 1;\n    }\n    \n    vector<string> teams;\n    generateTeams(teams, n, type);\n    \n    shuffle(teams.begin(), teams.end());\n    \n    printf(\"%d\\n\", n);\n    for (string& name : teams)\n        printf(\"%s\\n\", name.c_str());\n        \n    // Generate matches\n    vector<pair<int, int>> matches;\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j)\n            matches.push_back({i, j});\n            \n    shuffle(matches.begin(), matches.end());\n    \n    // Initialize scores\n    vector<int> points(n, 0);\n    vector<int> goals_scored(n, 0);\n    vector<int> goals_against(n, 0);\n    \n    vector<tuple<int, int, int, int>> match_results; // (team1, team2, score1, score2)\n    \n    if (type == \"max_scores\") {\n        for (auto& m : matches) {\n            int a = m.first, b = m.second;\n            int score1 = 100, score2 = 100;\n            match_results.push_back(make_tuple(a, b, score1, score2));\n            goals_scored[a] += score1;\n            goals_against[a] += score2;\n            goals_scored[b] += score2;\n            goals_against[b] += score1;\n            points[a] += 1;\n            points[b] += 1;\n        }\n    } else if (type == \"min_scores\") {\n        for (auto& m : matches) {\n            int a = m.first, b = m.second;\n            int score1 = 0, score2 = 0;\n            match_results.push_back(make_tuple(a, b, score1, score2));\n            goals_scored[a] += score1;\n            goals_against[a] += score2;\n            goals_scored[b] += score2;\n            goals_against[b] += score1;\n            points[a] += 1;\n            points[b] += 1;\n        }\n    } else if (type == \"tie_same_points_diff_goal_diff\") {\n        for (auto& m : matches) {\n            int a = m.first, b = m.second;\n            int score1 = 1, score2 = 1;\n            match_results.push_back(make_tuple(a, b, score1, score2));\n            goals_scored[a] += score1;\n            goals_against[a] += score2;\n            goals_scored[b] += score2;\n            goals_against[b] += score1;\n            points[a] += 1;\n            points[b] += 1;\n        }\n        int changes = n / 2;\n        for (int i = 0; i < changes && i < matches.size(); ++i) {\n            int idx = i;\n            int a = matches[idx].first, b = matches[idx].second;\n            int prev_score1 = 1, prev_score2 = 1;\n            points[a] -= 1;\n            points[b] -= 1;\n            goals_scored[a] -= prev_score1;\n            goals_against[a] -= prev_score2;\n            goals_scored[b] -= prev_score2;\n            goals_against[b] -= prev_score1;\n            int score1 = 2 + i, score2 = 1;\n            match_results[idx] = make_tuple(a, b, score1, score2);\n            goals_scored[a] += score1;\n            goals_against[a] += score2;\n            goals_scored[b] += score2;\n            goals_against[b] += score1;\n            points[a] += 3;\n        }\n    } else if (type == \"tie_same_points_goal_diff_diff_goals_scored\") {\n        int score = 0;\n        for (auto& m : matches) {\n            int a = m.first, b = m.second;\n            int score1 = score;\n            int score2 = score;\n            match_results.push_back(make_tuple(a, b, score1, score2));\n            goals_scored[a] += score1;\n            goals_against[a] += score2;\n            goals_scored[b] += score2;\n            goals_against[b] += score1;\n            points[a] += 1;\n            points[b] += 1;\n            score = (score + 1) % 3;\n        }\n    } else if (type == \"all_teams_identical_stats\") {\n        int draw_score = rnd.next(0, 100);\n        for (auto& m : matches) {\n            int a = m.first, b = m.second;\n            int score1 = draw_score, score2 = draw_score;\n            match_results.push_back(make_tuple(a, b, score1, score2));\n            goals_scored[a] += score1;\n            goals_against[a] += score2;\n            goals_scored[b] += score2;\n            goals_against[b] += score1;\n            points[a] += 1;\n            points[b] += 1;\n        }\n    } else {\n        for (auto& m : matches) {\n            int a = m.first, b = m.second;\n            int score1 = rnd.next(0, 100);\n            int score2 = rnd.next(0, 100);\n            match_results.push_back(make_tuple(a, b, score1, score2));\n            goals_scored[a] += score1;\n            goals_against[a] += score2;\n            goals_scored[b] += score2;\n            goals_against[b] += score1;\n            if (score1 > score2) {\n                points[a] += 3;\n            } else if (score1 == score2) {\n                points[a] += 1;\n                points[b] += 1;\n            } else {\n                points[b] += 3;\n            }\n        }\n    }\n    \n    for (size_t i = 0; i < matches.size(); ++i) {\n        int a = get<0>(match_results[i]);\n        int b = get<1>(match_results[i]);\n        int score1 = get<2>(match_results[i]);\n        int score2 = get<3>(match_results[i]);\n        printf(\"%s-%s %d:%d\\n\", teams[a].c_str(), teams[b].c_str(), score1, score2);\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateTeams(vector<string>& teams, int n, string type) {\n    if (type == \"similar_names\") {\n        for (int i = 0; i < n; ++i) {\n            string name = \"Team\" + to_string(i / 10);\n            for (char & ch : name) {\n                if (rnd.next(2))\n                    ch = toupper(ch);\n                else\n                    ch = tolower(ch);\n            }\n            teams.push_back(name);\n        }\n    } else if (type == \"case_sensitivity\") {\n        for (int i = 0; i < n; ++i) {\n            string name = string(1, 'A' + (i % 26));\n            if (rnd.next(2))\n                name[0] = toupper(name[0]);\n            else\n                name[0] = tolower(name[0]);\n            teams.push_back(name);\n        }\n    } else {\n        set<string> used_names;\n        while ((int)teams.size() < n) {\n            int len = rnd.next(1, 30);\n            string name;\n            for (int i = 0; i < len; ++i) {\n                char ch = 'A' + rnd.next(52);\n                if (ch > 'Z') ch = 'a' + (ch - 'A' - 26);\n                name += ch;\n            }\n            if (used_names.count(name)) continue;\n            used_names.insert(name);\n            teams.push_back(name);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    if (n < 1 || n > 50 || n % 2 != 0) {\n        fprintf(stderr, \"Invalid value of n: %d\\n\", n);\n        return 1;\n    }\n    \n    vector<string> teams;\n    generateTeams(teams, n, type);\n    \n    shuffle(teams.begin(), teams.end());\n    \n    printf(\"%d\\n\", n);\n    for (string& name : teams)\n        printf(\"%s\\n\", name.c_str());\n        \n    // Generate matches\n    vector<pair<int, int>> matches;\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j)\n            matches.push_back({i, j});\n            \n    shuffle(matches.begin(), matches.end());\n    \n    // Initialize scores\n    vector<int> points(n, 0);\n    vector<int> goals_scored(n, 0);\n    vector<int> goals_against(n, 0);\n    \n    vector<tuple<int, int, int, int>> match_results; // (team1, team2, score1, score2)\n    \n    if (type == \"max_scores\") {\n        for (auto& m : matches) {\n            int a = m.first, b = m.second;\n            int score1 = 100, score2 = 100;\n            match_results.push_back(make_tuple(a, b, score1, score2));\n            goals_scored[a] += score1;\n            goals_against[a] += score2;\n            goals_scored[b] += score2;\n            goals_against[b] += score1;\n            points[a] += 1;\n            points[b] += 1;\n        }\n    } else if (type == \"min_scores\") {\n        for (auto& m : matches) {\n            int a = m.first, b = m.second;\n            int score1 = 0, score2 = 0;\n            match_results.push_back(make_tuple(a, b, score1, score2));\n            goals_scored[a] += score1;\n            goals_against[a] += score2;\n            goals_scored[b] += score2;\n            goals_against[b] += score1;\n            points[a] += 1;\n            points[b] += 1;\n        }\n    } else if (type == \"tie_same_points_diff_goal_diff\") {\n        for (auto& m : matches) {\n            int a = m.first, b = m.second;\n            int score1 = 1, score2 = 1;\n            match_results.push_back(make_tuple(a, b, score1, score2));\n            goals_scored[a] += score1;\n            goals_against[a] += score2;\n            goals_scored[b] += score2;\n            goals_against[b] += score1;\n            points[a] += 1;\n            points[b] += 1;\n        }\n        int changes = n / 2;\n        for (int i = 0; i < changes && i < matches.size(); ++i) {\n            int idx = i;\n            int a = matches[idx].first, b = matches[idx].second;\n            int prev_score1 = 1, prev_score2 = 1;\n            points[a] -= 1;\n            points[b] -= 1;\n            goals_scored[a] -= prev_score1;\n            goals_against[a] -= prev_score2;\n            goals_scored[b] -= prev_score2;\n            goals_against[b] -= prev_score1;\n            int score1 = 2 + i, score2 = 1;\n            match_results[idx] = make_tuple(a, b, score1, score2);\n            goals_scored[a] += score1;\n            goals_against[a] += score2;\n            goals_scored[b] += score2;\n            goals_against[b] += score1;\n            points[a] += 3;\n        }\n    } else if (type == \"tie_same_points_goal_diff_diff_goals_scored\") {\n        int score = 0;\n        for (auto& m : matches) {\n            int a = m.first, b = m.second;\n            int score1 = score;\n            int score2 = score;\n            match_results.push_back(make_tuple(a, b, score1, score2));\n            goals_scored[a] += score1;\n            goals_against[a] += score2;\n            goals_scored[b] += score2;\n            goals_against[b] += score1;\n            points[a] += 1;\n            points[b] += 1;\n            score = (score + 1) % 3;\n        }\n    } else if (type == \"all_teams_identical_stats\") {\n        int draw_score = rnd.next(0, 100);\n        for (auto& m : matches) {\n            int a = m.first, b = m.second;\n            int score1 = draw_score, score2 = draw_score;\n            match_results.push_back(make_tuple(a, b, score1, score2));\n            goals_scored[a] += score1;\n            goals_against[a] += score2;\n            goals_scored[b] += score2;\n            goals_against[b] += score1;\n            points[a] += 1;\n            points[b] += 1;\n        }\n    } else {\n        for (auto& m : matches) {\n            int a = m.first, b = m.second;\n            int score1 = rnd.next(0, 100);\n            int score2 = rnd.next(0, 100);\n            match_results.push_back(make_tuple(a, b, score1, score2));\n            goals_scored[a] += score1;\n            goals_against[a] += score2;\n            goals_scored[b] += score2;\n            goals_against[b] += score1;\n            if (score1 > score2) {\n                points[a] += 3;\n            } else if (score1 == score2) {\n                points[a] += 1;\n                points[b] += 1;\n            } else {\n                points[b] += 3;\n            }\n        }\n    }\n    \n    for (size_t i = 0; i < matches.size(); ++i) {\n        int a = get<0>(match_results[i]);\n        int b = get<1>(match_results[i]);\n        int score1 = get<2>(match_results[i]);\n        int score2 = get<3>(match_results[i]);\n        printf(\"%s-%s %d:%d\\n\", teams[a].c_str(), teams[b].c_str(), score1, score2);\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type minimal_n\n./gen -n 2 -type case_sensitivity\n./gen -n 2 -type random\n./gen -n 2 -type min_scores\n./gen -n 2 -type max_scores\n./gen -n 4 -type minimal_n\n./gen -n 4 -type case_sensitivity\n./gen -n 4 -type random\n./gen -n 4 -type similar_names\n./gen -n 4 -type tie_same_points_diff_goal_diff\n./gen -n 4 -type tie_same_points_goal_diff_diff_goals_scored\n./gen -n 4 -type all_teams_identical_stats\n./gen -n 6 -type random\n./gen -n 8 -type random\n./gen -n 10 -type random\n./gen -n 12 -type random\n./gen -n 14 -type random\n./gen -n 16 -type random\n./gen -n 18 -type random\n./gen -n 20 -type random\n./gen -n 22 -type random\n./gen -n 24 -type random\n./gen -n 26 -type random\n./gen -n 28 -type random\n./gen -n 30 -type random\n./gen -n 32 -type random\n./gen -n 34 -type random\n./gen -n 36 -type random\n./gen -n 38 -type random\n./gen -n 40 -type random\n./gen -n 42 -type random\n./gen -n 44 -type random\n./gen -n 46 -type random\n./gen -n 48 -type random\n./gen -n 50 -type random\n./gen -n 50 -type max_scores\n./gen -n 50 -type min_scores\n./gen -n 50 -type similar_names\n./gen -n 50 -type case_sensitivity\n./gen -n 50 -type tie_same_points_diff_goal_diff\n./gen -n 50 -type tie_same_points_goal_diff_diff_goals_scored\n./gen -n 50 -type all_teams_identical_stats\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:53.089412",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "19/B",
      "title": "B. Checkout Assistant",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains number n (1 ≤ n ≤ 2000). In each of the following n lines each item is described by a pair of numbers ti, ci (0 ≤ ti ≤ 2000, 1 ≤ ci ≤ 109). If ti is 0, Bob won't be able to steal anything, while the checkout assistant is occupied with item i.",
      "output_spec": "OutputOutput one number — answer to the problem: what is the minimum amount of money that Bob will have to pay.",
      "sample_tests": "ExamplesInputCopy42 100 201 51 3OutputCopy8InputCopy30 10 100 100OutputCopy111",
      "description": "B. Checkout Assistant\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains number n (1 ≤ n ≤ 2000). In each of the following n lines each item is described by a pair of numbers ti, ci (0 ≤ ti ≤ 2000, 1 ≤ ci ≤ 109). If ti is 0, Bob won't be able to steal anything, while the checkout assistant is occupied with item i.\n\nOutputOutput one number — answer to the problem: what is the minimum amount of money that Bob will have to pay.\n\nInputCopy42 100 201 51 3OutputCopy8InputCopy30 10 100 100OutputCopy111\n\nInputCopy42 100 201 51 3\n\nOutputCopy8\n\nInputCopy30 10 100 100\n\nOutputCopy111",
      "solutions": [
        {
          "title": "Codeforces Beta Round #19 - Codeforces",
          "content": "Welcome to Codeforces Beta Round #19.Authors of today's contest are Artem Rakhov and me. Thanks to Mike Mirzayanov, Edvard Davtyan and Julia Satushina for help in the organisation.I hope, you will have fun.Good luck!P.S. After start of the contest, you can download the statements:EnglishRussianUPD. The contest has finished and you can see the standings and tasks. The winner and only participant who has solved all the problems is kalinov. Congratulations!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/484",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 19 和字母"
          },
          "content_length": 458
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces",
          "content": "I find that no one write a solution about this contest..So I write one.. A. World Football Cup I think is' just a problem about writing code  quickly and correctly.Just follow the statement. if you use c++ STL will make you life easier B. Checkout Assistant First,for every i increase ti by 1..then you will  see that statement require sum of t of the items  bigger or equal to n..and their sum of c should  be minimal..so it's just a 0-1 knapsack problem. C. Deletion of Repeats First let's generate all repeats.In a repeat,the  first number and the middle number must be the  same, so we just look at all pair of postion which  have same number..Thank to the statement..There  are at most O(10N) such pair..And use suffix array  to check if each pair can build a repeat...Then  just sort all the interval and go through then to  get the answer...http://en.wikipedia.org/wiki/Suffix_arraymaybe you think suffix array is hard to code..you can use hash and binary search to do the same..my code here http://www.ideone.com/N5zPS D. Points First of all,do the discretization.Then the biggest  value of x is n,so we can build a Segment Tree to  Ask the question \"what is the first place from   postion x and its value is bigger than y\"..if we  find such postion we just find the smallest Y-value  bigger than y in such postion--it can be done using  set's operation upper_bound...http://en.wikipedia.org/wiki/Segment_tree so the algorithm is clear..For every possible value  of x use a set to store all y value in it..And every  time the action is \"find\" or \"remove\" just change  this set and update the Segment Tree..otherwise use  Segment Tree to find the answer..my code here http://www.ideone.com/4iNolE. Fairy It's a interesting problem.If you for every edge,  try to remove it and check if it is a bipartite  graph..I think it will get TLE..so let's analysis  the property of bipartite graph..http://en.wikipedia.org/wiki/Bipartite_graphAfter reading it...we know.. It should never contain a cycle of odd length... and it can be 2-colored.. so first build a spanning forest for the graph.. and do the 2-color on it(Tree can be 2-colored). for convenience. Let TreeEdge={all edge in forest} NotTreeEdge={All edge}/TreeEdge ErrorEdge={all edge that two endpoint have the same color..} NotErorEdge=NotTreeEdge/ErroEdge.. First,consider a edge form NotTreeEdge,remove it  can't change any node's color..so.. if |ErrorEdge|=0 of course we can remove all NotTreeEdge if =1 we just can remove the ErrorEdge if >1 we can't remove any from NotTreeEdge Now,Let consider a Edge e from TreeEdge.. Let Path(Edge e)=the path in forest between e's two endpoints.. if there is a Edge e' from ErrorEdge that Path(e')  didn't  go through e..it will destroy the bipartite  graph.. if there is a Edge e' from ErrorEdge that Path(e') go through e and there is a Edge e'' from NotErrorEdge that Path(e'') go through e..it will also destroy the bipartite graph.. so now we need to know for every edge,how many such path go through it..it require a data structure... one way is to use heavy-light decomposition then we can update every path in O(LogN^2)... another way is to use Link-Cut Tree..It can do the same in O(LogN)....if you didn't see Link-Cut tree before,you can read thishttp://www.cs.cmu.edu/~sleator/papers/dynamic-trees.pdfor my code..use heavy-light decomposition http://www.ideone.com/dPS5N",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/559",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3385
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #19 - Codeforces - Code 1",
          "code": "<A HREF=\"http://ideone.com/djbUe\">Code</A> is here. Can anyone tell where i am wrong.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/484",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 1",
          "code": "http://www.ideone.com/dPS5N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 2",
          "code": "12 1 2 1 3 4 2 1 2 1 3 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 3",
          "code": "6 1 2 1 3 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 4",
          "code": "5 2 1 3 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ti = inf.readInt(0, 2000, \"ti\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ti = inf.readInt(0, 2000, \"ti\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ti = inf.readInt(0, 2000, \"ti\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = rnd.next(0, 2000);\n            int ci = rnd.next(1, 1000000000);\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else if (type == \"all_ti_zero\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = 0;\n            int ci = rnd.next(1, 1000000000);\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else if (type == \"all_ti_max\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = 2000;\n            int ci = rnd.next(1, 1000000000);\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else if (type == \"max_ci\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = rnd.next(0, 2000);\n            int ci = 1000000000;\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else if (type == \"min_ci\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = rnd.next(0, 2000);\n            int ci = 1;\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else if (type == \"mixed\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = (i % 2 == 0) ? 0 : 2000;\n            int ci = (i % 3 == 0) ? 1 : 1000000000;\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else if (type == \"ti_zero_expensive\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = 0;\n            int ci = 1000000000;\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else if (type == \"ti_max_cheap\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = 2000;\n            int ci = 1;\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else if (type == \"worst_case\") {\n        int m = n / 2;\n        for (int i = 0; i < m; ++i) {\n            int ti = 0;\n            int ci = 1000000000;\n            printf(\"%d %d\\n\", ti, ci);\n        }\n        for (int i = m; i < n; ++i) {\n            int ti = 2000;\n            int ci = 1;\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = (i % 2 == 0) ? 0 : 2000;\n            int ci = (i % 2 == 0) ? 1 : 1000000000;\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            int ti = rnd.next(0, 2000);\n            int ci = rnd.next(1, 1000000000);\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = rnd.next(0, 2000);\n            int ci = rnd.next(1, 1000000000);\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else if (type == \"all_ti_zero\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = 0;\n            int ci = rnd.next(1, 1000000000);\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else if (type == \"all_ti_max\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = 2000;\n            int ci = rnd.next(1, 1000000000);\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else if (type == \"max_ci\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = rnd.next(0, 2000);\n            int ci = 1000000000;\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else if (type == \"min_ci\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = rnd.next(0, 2000);\n            int ci = 1;\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else if (type == \"mixed\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = (i % 2 == 0) ? 0 : 2000;\n            int ci = (i % 3 == 0) ? 1 : 1000000000;\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else if (type == \"ti_zero_expensive\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = 0;\n            int ci = 1000000000;\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else if (type == \"ti_max_cheap\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = 2000;\n            int ci = 1;\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else if (type == \"worst_case\") {\n        int m = n / 2;\n        for (int i = 0; i < m; ++i) {\n            int ti = 0;\n            int ci = 1000000000;\n            printf(\"%d %d\\n\", ti, ci);\n        }\n        for (int i = m; i < n; ++i) {\n            int ti = 2000;\n            int ci = 1;\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = (i % 2 == 0) ? 0 : 2000;\n            int ci = (i % 2 == 0) ? 1 : 1000000000;\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            int ti = rnd.next(0, 2000);\n            int ci = rnd.next(1, 1000000000);\n            printf(\"%d %d\\n\", ti, ci);\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type all_ti_zero\n./gen -n 1 -type all_ti_max\n./gen -n 1 -type max_ci\n./gen -n 1 -type min_ci\n\n./gen -n 2 -type random\n./gen -n 2 -type mixed\n\n./gen -n 5 -type random\n./gen -n 5 -type alternating\n\n./gen -n 10 -type ti_zero_expensive\n./gen -n 10 -type ti_max_cheap\n\n./gen -n 50 -type worst_case\n\n./gen -n 100 -type random\n./gen -n 100 -type all_ti_zero\n./gen -n 100 -type all_ti_max\n./gen -n 100 -type mixed\n\n./gen -n 1000 -type random\n./gen -n 1000 -type ti_zero_expensive\n./gen -n 1000 -type worst_case\n\n./gen -n 2000 -type random\n./gen -n 2000 -type all_ti_zero\n./gen -n 2000 -type all_ti_max\n./gen -n 2000 -type mixed\n./gen -n 2000 -type worst_case\n./gen -n 2000 -type ti_zero_expensive\n./gen -n 2000 -type ti_max_cheap\n./gen -n 2000 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:54.830391",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "19/C",
      "title": "C. Deletion of Repeats",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains integer n (1 ≤ n ≤ 105) — length of the string. The following line contains n space-separated integer numbers from 0 to 109 inclusive — numbers that stand for the letters of the string. It's guaranteed that each letter can be met in the string at most 10 times.",
      "output_spec": "OutputIn the first line output the length of the string's part, left after Bob's deletions. In the second line output all the letters (separated by a space) of the string, left after Bob deleted all the repeats in the described way.",
      "sample_tests": "ExamplesInputCopy61 2 3 1 2 3OutputCopy31 2 3 InputCopy74 5 6 5 6 7 7OutputCopy17",
      "description": "C. Deletion of Repeats\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains integer n (1 ≤ n ≤ 105) — length of the string. The following line contains n space-separated integer numbers from 0 to 109 inclusive — numbers that stand for the letters of the string. It's guaranteed that each letter can be met in the string at most 10 times.\n\nOutputIn the first line output the length of the string's part, left after Bob's deletions. In the second line output all the letters (separated by a space) of the string, left after Bob deleted all the repeats in the described way.\n\nInputCopy61 2 3 1 2 3OutputCopy31 2 3 InputCopy74 5 6 5 6 7 7OutputCopy17\n\nInputCopy61 2 3 1 2 3\n\nOutputCopy31 2 3\n\nInputCopy74 5 6 5 6 7 7\n\nOutputCopy17",
      "solutions": [
        {
          "title": "Codeforces Beta Round #19 - Codeforces",
          "content": "Welcome to Codeforces Beta Round #19.Authors of today's contest are Artem Rakhov and me. Thanks to Mike Mirzayanov, Edvard Davtyan and Julia Satushina for help in the organisation.I hope, you will have fun.Good luck!P.S. After start of the contest, you can download the statements:EnglishRussianUPD. The contest has finished and you can see the standings and tasks. The winner and only participant who has solved all the problems is kalinov. Congratulations!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/484",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 19 和字母"
          },
          "content_length": 458
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces",
          "content": "I find that no one write a solution about this contest..So I write one.. A. World Football Cup I think is' just a problem about writing code  quickly and correctly.Just follow the statement. if you use c++ STL will make you life easier B. Checkout Assistant First,for every i increase ti by 1..then you will  see that statement require sum of t of the items  bigger or equal to n..and their sum of c should  be minimal..so it's just a 0-1 knapsack problem. C. Deletion of Repeats First let's generate all repeats.In a repeat,the  first number and the middle number must be the  same, so we just look at all pair of postion which  have same number..Thank to the statement..There  are at most O(10N) such pair..And use suffix array  to check if each pair can build a repeat...Then  just sort all the interval and go through then to  get the answer...http://en.wikipedia.org/wiki/Suffix_arraymaybe you think suffix array is hard to code..you can use hash and binary search to do the same..my code here http://www.ideone.com/N5zPS D. Points First of all,do the discretization.Then the biggest  value of x is n,so we can build a Segment Tree to  Ask the question \"what is the first place from   postion x and its value is bigger than y\"..if we  find such postion we just find the smallest Y-value  bigger than y in such postion--it can be done using  set's operation upper_bound...http://en.wikipedia.org/wiki/Segment_tree so the algorithm is clear..For every possible value  of x use a set to store all y value in it..And every  time the action is \"find\" or \"remove\" just change  this set and update the Segment Tree..otherwise use  Segment Tree to find the answer..my code here http://www.ideone.com/4iNolE. Fairy It's a interesting problem.If you for every edge,  try to remove it and check if it is a bipartite  graph..I think it will get TLE..so let's analysis  the property of bipartite graph..http://en.wikipedia.org/wiki/Bipartite_graphAfter reading it...we know.. It should never contain a cycle of odd length... and it can be 2-colored.. so first build a spanning forest for the graph.. and do the 2-color on it(Tree can be 2-colored). for convenience. Let TreeEdge={all edge in forest} NotTreeEdge={All edge}/TreeEdge ErrorEdge={all edge that two endpoint have the same color..} NotErorEdge=NotTreeEdge/ErroEdge.. First,consider a edge form NotTreeEdge,remove it  can't change any node's color..so.. if |ErrorEdge|=0 of course we can remove all NotTreeEdge if =1 we just can remove the ErrorEdge if >1 we can't remove any from NotTreeEdge Now,Let consider a Edge e from TreeEdge.. Let Path(Edge e)=the path in forest between e's two endpoints.. if there is a Edge e' from ErrorEdge that Path(e')  didn't  go through e..it will destroy the bipartite  graph.. if there is a Edge e' from ErrorEdge that Path(e') go through e and there is a Edge e'' from NotErrorEdge that Path(e'') go through e..it will also destroy the bipartite graph.. so now we need to know for every edge,how many such path go through it..it require a data structure... one way is to use heavy-light decomposition then we can update every path in O(LogN^2)... another way is to use Link-Cut Tree..It can do the same in O(LogN)....if you didn't see Link-Cut tree before,you can read thishttp://www.cs.cmu.edu/~sleator/papers/dynamic-trees.pdfor my code..use heavy-light decomposition http://www.ideone.com/dPS5N",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/559",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3385
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #19 - Codeforces - Code 1",
          "code": "<A HREF=\"http://ideone.com/djbUe\">Code</A> is here. Can anyone tell where i am wrong.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/484",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 1",
          "code": "http://www.ideone.com/dPS5N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 2",
          "code": "12 1 2 1 3 4 2 1 2 1 3 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 3",
          "code": "6 1 2 1 3 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 4",
          "code": "5 2 1 3 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read n integers a_i\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Check that each letter appears at most 10 times\n    map<int, int> cnt;\n    for (int i = 0; i < n; ++i) {\n        cnt[a[i]]++;\n        ensuref(cnt[a[i]] <= 10, \"Number %d appears more than 10 times\", a[i]);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read n integers a_i\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Check that each letter appears at most 10 times\n    map<int, int> cnt;\n    for (int i = 0; i < n; ++i) {\n        cnt[a[i]]++;\n        ensuref(cnt[a[i]] <= 10, \"Number %d appears more than 10 times\", a[i]);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    // Read n integers a_i\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Check that each letter appears at most 10 times\n    map<int, int> cnt;\n    for (int i = 0; i < n; ++i) {\n        cnt[a[i]]++;\n        ensuref(cnt[a[i]] <= 10, \"Number %d appears more than 10 times\", a[i]);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> letters;\n\n    if (type == \"random\") {\n        // Generate random counts ensuring per-letter occurrence ≤ 10\n        int min_unique = (n + 9) / 10; // minimal number of unique letters\n        int max_unique = n; // maximum number of unique letters\n        int k = rnd.next(min_unique, max_unique);\n\n        vector<int> counts(k, 1);\n        int rem = n - k;\n\n        while (rem > 0) {\n            int idx = rnd.next(0, k - 1);\n            if (counts[idx] < 10) {\n                counts[idx]++;\n                rem--;\n            }\n        }\n\n        // Assign random unique letters from 0 to 1e9 inclusive\n        unordered_set<int> used_numbers;\n        vector<int> letter_values;\n        for (int i = 0; i < k; ++i) {\n            int num;\n            do {\n                num = rnd.next(int(0), int(1e9));\n            } while (used_numbers.count(num));\n            used_numbers.insert(num);\n            letter_values.push_back(num);\n        }\n\n        // Build the letters vector\n        for (int i = 0; i < k; ++i) {\n            for (int j = 0; j < counts[i]; ++j) {\n                letters.push_back(letter_values[i]);\n            }\n        }\n\n        // Shuffle the letters\n        shuffle(letters.begin(), letters.end());\n\n    } else if (type == \"single_occurrence\") {\n        // Each letter occurs exactly once\n        vector<int> letter_values;\n        unordered_set<int> used_numbers;\n        for (int i = 0; i < n; ++i) {\n            int num;\n            do {\n                num = rnd.next(0, int(1e9));\n            } while (used_numbers.count(num));\n            used_numbers.insert(num);\n            letter_values.push_back(num);\n        }\n        letters = letter_values;\n        // Shuffle the letters\n        shuffle(letters.begin(), letters.end());\n\n    } else if (type == \"max_repeats\") {\n        // Minimize the number of unique letters\n        int max_count = 10;\n        int num_letters = (n + max_count - 1) / max_count; // ceil(n / 10)\n        vector<int> counts(num_letters, max_count);\n\n        int total = max_count * num_letters;\n        int rem = total - n;\n        // Reduce counts to match total n\n        for (int i = 0; i < num_letters && rem > 0; ++i) {\n            int reduce = min(rem, counts[i] - 1);\n            counts[i] -= reduce;\n            rem -= reduce;\n        }\n\n        // Assign random unique letters\n        unordered_set<int> used_numbers;\n        vector<int> letter_values;\n        for (int i = 0; i < num_letters; ++i) {\n            int num;\n            do {\n                num = rnd.next(0, int(1e9));\n            } while (used_numbers.count(num));\n            used_numbers.insert(num);\n            letter_values.push_back(num);\n        }\n\n        // Build letters vector\n        for (int i = 0; i < num_letters; ++i) {\n            for (int j = 0; j < counts[i]; ++j) {\n                letters.push_back(letter_values[i]);\n            }\n        }\n\n        // Shuffle the letters\n        shuffle(letters.begin(), letters.end());\n\n    } else if (type == \"repeated_patterns\") {\n        // Build a string with repeated patterns\n        vector<int> letter_values;\n        unordered_set<int> used_numbers;\n        int num_letters = 2;\n        for (int i = 0; i < num_letters; ++i) {\n            int num;\n            do {\n                num = rnd.next(0, int(1e9));\n            } while (used_numbers.count(num));\n            used_numbers.insert(num);\n            letter_values.push_back(num);\n        }\n\n        vector<int> counts(num_letters, 0);\n\n        // Each letter can occur up to 10 times\n        counts[0] = min(10, (n + 1) / 2);\n        counts[1] = min(10, n / 2);\n\n        int total_counts = counts[0] + counts[1];\n\n        if (total_counts < n) {\n            // Need to add more letters\n            int letters_needed = (n - total_counts + 9) / 10;\n            for (int i = 0; i < letters_needed; ++i) {\n                int num;\n                do {\n                    num = rnd.next(0, int(1e9));\n                } while (used_numbers.count(num));\n                used_numbers.insert(num);\n                letter_values.push_back(num);\n                counts.push_back(min(10, n - total_counts));\n                total_counts += counts.back();\n            }\n        }\n\n        // Now build the letters vector\n        // Repeat pattern\n        letters.clear();\n        int idx = 0;\n        while (letters.size() < n) {\n            if (counts[idx] > 0) {\n                letters.push_back(letter_values[idx]);\n                counts[idx]--;\n            }\n            idx = (idx + 1) % counts.size();\n        }\n\n    } else {\n        // default to random\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", letters[i]);\n        if (i < n -1) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> letters;\n\n    if (type == \"random\") {\n        // Generate random counts ensuring per-letter occurrence ≤ 10\n        int min_unique = (n + 9) / 10; // minimal number of unique letters\n        int max_unique = n; // maximum number of unique letters\n        int k = rnd.next(min_unique, max_unique);\n\n        vector<int> counts(k, 1);\n        int rem = n - k;\n\n        while (rem > 0) {\n            int idx = rnd.next(0, k - 1);\n            if (counts[idx] < 10) {\n                counts[idx]++;\n                rem--;\n            }\n        }\n\n        // Assign random unique letters from 0 to 1e9 inclusive\n        unordered_set<int> used_numbers;\n        vector<int> letter_values;\n        for (int i = 0; i < k; ++i) {\n            int num;\n            do {\n                num = rnd.next(int(0), int(1e9));\n            } while (used_numbers.count(num));\n            used_numbers.insert(num);\n            letter_values.push_back(num);\n        }\n\n        // Build the letters vector\n        for (int i = 0; i < k; ++i) {\n            for (int j = 0; j < counts[i]; ++j) {\n                letters.push_back(letter_values[i]);\n            }\n        }\n\n        // Shuffle the letters\n        shuffle(letters.begin(), letters.end());\n\n    } else if (type == \"single_occurrence\") {\n        // Each letter occurs exactly once\n        vector<int> letter_values;\n        unordered_set<int> used_numbers;\n        for (int i = 0; i < n; ++i) {\n            int num;\n            do {\n                num = rnd.next(0, int(1e9));\n            } while (used_numbers.count(num));\n            used_numbers.insert(num);\n            letter_values.push_back(num);\n        }\n        letters = letter_values;\n        // Shuffle the letters\n        shuffle(letters.begin(), letters.end());\n\n    } else if (type == \"max_repeats\") {\n        // Minimize the number of unique letters\n        int max_count = 10;\n        int num_letters = (n + max_count - 1) / max_count; // ceil(n / 10)\n        vector<int> counts(num_letters, max_count);\n\n        int total = max_count * num_letters;\n        int rem = total - n;\n        // Reduce counts to match total n\n        for (int i = 0; i < num_letters && rem > 0; ++i) {\n            int reduce = min(rem, counts[i] - 1);\n            counts[i] -= reduce;\n            rem -= reduce;\n        }\n\n        // Assign random unique letters\n        unordered_set<int> used_numbers;\n        vector<int> letter_values;\n        for (int i = 0; i < num_letters; ++i) {\n            int num;\n            do {\n                num = rnd.next(0, int(1e9));\n            } while (used_numbers.count(num));\n            used_numbers.insert(num);\n            letter_values.push_back(num);\n        }\n\n        // Build letters vector\n        for (int i = 0; i < num_letters; ++i) {\n            for (int j = 0; j < counts[i]; ++j) {\n                letters.push_back(letter_values[i]);\n            }\n        }\n\n        // Shuffle the letters\n        shuffle(letters.begin(), letters.end());\n\n    } else if (type == \"repeated_patterns\") {\n        // Build a string with repeated patterns\n        vector<int> letter_values;\n        unordered_set<int> used_numbers;\n        int num_letters = 2;\n        for (int i = 0; i < num_letters; ++i) {\n            int num;\n            do {\n                num = rnd.next(0, int(1e9));\n            } while (used_numbers.count(num));\n            used_numbers.insert(num);\n            letter_values.push_back(num);\n        }\n\n        vector<int> counts(num_letters, 0);\n\n        // Each letter can occur up to 10 times\n        counts[0] = min(10, (n + 1) / 2);\n        counts[1] = min(10, n / 2);\n\n        int total_counts = counts[0] + counts[1];\n\n        if (total_counts < n) {\n            // Need to add more letters\n            int letters_needed = (n - total_counts + 9) / 10;\n            for (int i = 0; i < letters_needed; ++i) {\n                int num;\n                do {\n                    num = rnd.next(0, int(1e9));\n                } while (used_numbers.count(num));\n                used_numbers.insert(num);\n                letter_values.push_back(num);\n                counts.push_back(min(10, n - total_counts));\n                total_counts += counts.back();\n            }\n        }\n\n        // Now build the letters vector\n        // Repeat pattern\n        letters.clear();\n        int idx = 0;\n        while (letters.size() < n) {\n            if (counts[idx] > 0) {\n                letters.push_back(letter_values[idx]);\n                counts[idx]--;\n            }\n            idx = (idx + 1) % counts.size();\n        }\n\n    } else {\n        // default to random\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", letters[i]);\n        if (i < n -1) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type single_occurrence\n./gen -n 1 -type max_repeats\n./gen -n 1 -type repeated_patterns\n\n./gen -n 2 -type random\n./gen -n 2 -type single_occurrence\n./gen -n 2 -type max_repeats\n./gen -n 2 -type repeated_patterns\n\n./gen -n 9 -type random\n./gen -n 9 -type single_occurrence\n./gen -n 9 -type max_repeats\n./gen -n 9 -type repeated_patterns\n\n./gen -n 10 -type random\n./gen -n 10 -type single_occurrence\n./gen -n 10 -type max_repeats\n./gen -n 10 -type repeated_patterns\n\n./gen -n 100 -type random\n./gen -n 100 -type single_occurrence\n./gen -n 100 -type max_repeats\n./gen -n 100 -type repeated_patterns\n\n./gen -n 1000 -type random\n./gen -n 1000 -type single_occurrence\n./gen -n 1000 -type max_repeats\n./gen -n 1000 -type repeated_patterns\n\n./gen -n 10000 -type random\n./gen -n 10000 -type single_occurrence\n./gen -n 10000 -type max_repeats\n./gen -n 10000 -type repeated_patterns\n\n./gen -n 100000 -type random\n./gen -n 100000 -type single_occurrence\n./gen -n 100000 -type max_repeats\n./gen -n 100000 -type repeated_patterns\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:57.071463",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "19/D",
      "title": "D. Точки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке входного файла содержится число n (1 ≤ n ≤ 2·105) — количество запросов. Далее следует n строк — описания запросов. add x y описывает запрос на добавление точки, remove x y — запрос на удаление точки, find x y — запрос на нахождение нижней левой точки. Все координаты во входном файле неотрицательны и не превосходят 109.",
      "output_spec": "Выходные данныеДля каждого запроса вида find x y выведите в отдельной строке ответ на него — координаты самой нижней из всех самых левых отмеченных точек, находящихся строго выше и правее точки (x, y). Если строго выше и правее нет отмеченных точек, выведите -1.",
      "sample_tests": "ПримерыВходные данныеСкопировать7add 1 1add 3 4find 0 0remove 1 1find 0 0add 1 1find 0 0Выходные данныеСкопировать1 13 41 1Входные данныеСкопировать13add 5 5add 5 6add 5 7add 6 5add 6 6add 6 7add 7 5add 7 6add 7 7find 6 6remove 7 7find 6 6find 4 4Выходные данныеСкопировать7 7-15 5",
      "description": "ограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входного файла содержится число n (1 ≤ n ≤ 2·105) — количество запросов. Далее следует n строк — описания запросов. add x y описывает запрос на добавление точки, remove x y — запрос на удаление точки, find x y — запрос на нахождение нижней левой точки. Все координаты во входном файле неотрицательны и не превосходят 109.\n\nВходные данные\n\nВыходные данныеДля каждого запроса вида find x y выведите в отдельной строке ответ на него — координаты самой нижней из всех самых левых отмеченных точек, находящихся строго выше и правее точки (x, y). Если строго выше и правее нет отмеченных точек, выведите -1.\n\nВыходные данные\n\nВходные данныеСкопировать7add 1 1add 3 4find 0 0remove 1 1find 0 0add 1 1find 0 0Выходные данныеСкопировать1 13 41 1Входные данныеСкопировать13add 5 5add 5 6add 5 7add 6 5add 6 6add 6 7add 7 5add 7 6add 7 7find 6 6remove 7 7find 6 6find 4 4Выходные данныеСкопировать7 7-15 5\n\nВходные данныеСкопировать7add 1 1add 3 4find 0 0remove 1 1find 0 0add 1 1find 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 13 41 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать13add 5 5add 5 6add 5 7add 6 5add 6 6add 6 7add 7 5add 7 6add 7 7find 6 6remove 7 7find 6 6find 4 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать7 7-15 5\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #19 - Codeforces",
          "content": "Доброго времени суток всем.В этот чудесный летний день приглашаю вас принять участие в Codeforces Beta Round #19. Сегодня авторами задач для Вас буду я и Артем Рахов. Также выражаю благодарность всем, кто помогает нам в организации этого соревнования: Михаилу Мирзаянову, Эдварду Давтяну  и Юлии Сатушиной.Надеюсь, что вам понравится.Всем успехов!P.S. После начала соревнования вы сможете скачать условия на русском и на английском языках.UPD. Контест окончен, всем спасибо за участие. Поздравляем победителя, единственного участника, который решил все предложенные задачи - kalinovВы можете посмотреть результаты и задачи.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/484",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 19 和字母"
          },
          "content_length": 623
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces",
          "content": "I find that no one write a solution about this contest..So I write one.. A. World Football Cup I think is' just a problem about writing code  quickly and correctly.Just follow the statement. if you use c++ STL will make you life easier B. Checkout Assistant First,for every i increase ti by 1..then you will  see that statement require sum of t of the items  bigger or equal to n..and their sum of c should  be minimal..so it's just a 0-1 knapsack problem. C. Deletion of Repeats First let's generate all repeats.In a repeat,the  first number and the middle number must be the  same, so we just look at all pair of postion which  have same number..Thank to the statement..There  are at most O(10N) such pair..And use suffix array  to check if each pair can build a repeat...Then  just sort all the interval and go through then to  get the answer...http://en.wikipedia.org/wiki/Suffix_arraymaybe you think suffix array is hard to code..you can use hash and binary search to do the same..my code here http://www.ideone.com/N5zPS D. Points First of all,do the discretization.Then the biggest  value of x is n,so we can build a Segment Tree to  Ask the question \"what is the first place from   postion x and its value is bigger than y\"..if we  find such postion we just find the smallest Y-value  bigger than y in such postion--it can be done using  set's operation upper_bound...http://en.wikipedia.org/wiki/Segment_tree so the algorithm is clear..For every possible value  of x use a set to store all y value in it..And every  time the action is \"find\" or \"remove\" just change  this set and update the Segment Tree..otherwise use  Segment Tree to find the answer..my code here http://www.ideone.com/4iNolE. Fairy It's a interesting problem.If you for every edge,  try to remove it and check if it is a bipartite  graph..I think it will get TLE..so let's analysis  the property of bipartite graph..http://en.wikipedia.org/wiki/Bipartite_graphAfter reading it...we know.. It should never contain a cycle of odd length... and it can be 2-colored.. so first build a spanning forest for the graph.. and do the 2-color on it(Tree can be 2-colored). for convenience. Let TreeEdge={all edge in forest} NotTreeEdge={All edge}/TreeEdge ErrorEdge={all edge that two endpoint have the same color..} NotErorEdge=NotTreeEdge/ErroEdge.. First,consider a edge form NotTreeEdge,remove it  can't change any node's color..so.. if |ErrorEdge|=0 of course we can remove all NotTreeEdge if =1 we just can remove the ErrorEdge if >1 we can't remove any from NotTreeEdge Now,Let consider a Edge e from TreeEdge.. Let Path(Edge e)=the path in forest between e's two endpoints.. if there is a Edge e' from ErrorEdge that Path(e')  didn't  go through e..it will destroy the bipartite  graph.. if there is a Edge e' from ErrorEdge that Path(e') go through e and there is a Edge e'' from NotErrorEdge that Path(e'') go through e..it will also destroy the bipartite graph.. so now we need to know for every edge,how many such path go through it..it require a data structure... one way is to use heavy-light decomposition then we can update every path in O(LogN^2)... another way is to use Link-Cut Tree..It can do the same in O(LogN)....if you didn't see Link-Cut tree before,you can read thishttp://www.cs.cmu.edu/~sleator/papers/dynamic-trees.pdfor my code..use heavy-light decomposition http://www.ideone.com/dPS5N",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/559",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3385
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #19 - Codeforces - Code 1",
          "code": "<A HREF=\"http://ideone.com/djbUe\">Code</A> is here. Can anyone tell where i am wrong.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/484",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 1",
          "code": "http://www.ideone.com/dPS5N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 2",
          "code": "12 1 2 1 3 4 2 1 2 1 3 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 3",
          "code": "6 1 2 1 3 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 4",
          "code": "5 2 1 3 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> markedPoints;\n\n    for (int i = 0; i < n; ++i) {\n        string requestType = inf.readToken(\"add|remove|find\", \"requestType\");\n        inf.readSpace();\n        int x = inf.readInt(0, 1000000000, \"x\");\n        inf.readSpace();\n        int y = inf.readInt(0, 1000000000, \"y\");\n        inf.readEoln();\n\n        if (requestType == \"add\") {\n            ensuref(markedPoints.count({x, y}) == 0, \"Point (%d, %d) is already marked at request %d\", x, y, i + 1);\n            markedPoints.insert({x, y});\n        } else if (requestType == \"remove\") {\n            ensuref(markedPoints.count({x, y}) == 1, \"Point (%d, %d) is not marked at request %d\", x, y, i + 1);\n            markedPoints.erase({x, y});\n        } else if (requestType == \"find\") {\n            // No additional constraints for 'find' requests\n        } else {\n            ensuref(false, \"Invalid request type '%s' at request %d\", requestType.c_str(), i + 1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> markedPoints;\n\n    for (int i = 0; i < n; ++i) {\n        string requestType = inf.readToken(\"add|remove|find\", \"requestType\");\n        inf.readSpace();\n        int x = inf.readInt(0, 1000000000, \"x\");\n        inf.readSpace();\n        int y = inf.readInt(0, 1000000000, \"y\");\n        inf.readEoln();\n\n        if (requestType == \"add\") {\n            ensuref(markedPoints.count({x, y}) == 0, \"Point (%d, %d) is already marked at request %d\", x, y, i + 1);\n            markedPoints.insert({x, y});\n        } else if (requestType == \"remove\") {\n            ensuref(markedPoints.count({x, y}) == 1, \"Point (%d, %d) is not marked at request %d\", x, y, i + 1);\n            markedPoints.erase({x, y});\n        } else if (requestType == \"find\") {\n            // No additional constraints for 'find' requests\n        } else {\n            ensuref(false, \"Invalid request type '%s' at request %d\", requestType.c_str(), i + 1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> markedPoints;\n\n    for (int i = 0; i < n; ++i) {\n        string requestType = inf.readToken(\"add|remove|find\", \"requestType\");\n        inf.readSpace();\n        int x = inf.readInt(0, 1000000000, \"x\");\n        inf.readSpace();\n        int y = inf.readInt(0, 1000000000, \"y\");\n        inf.readEoln();\n\n        if (requestType == \"add\") {\n            ensuref(markedPoints.count({x, y}) == 0, \"Point (%d, %d) is already marked at request %d\", x, y, i + 1);\n            markedPoints.insert({x, y});\n        } else if (requestType == \"remove\") {\n            ensuref(markedPoints.count({x, y}) == 1, \"Point (%d, %d) is not marked at request %d\", x, y, i + 1);\n            markedPoints.erase({x, y});\n        } else if (requestType == \"find\") {\n            // No additional constraints for 'find' requests\n        } else {\n            ensuref(false, \"Invalid request type '%s' at request %d\", requestType.c_str(), i + 1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int maxx = opt<int>(\"maxx\", (int)1e9);\n    int maxy = opt<int>(\"maxy\", (int)1e9);\n\n    set<pair<int,int>> added_points;\n    vector<pair<int,int>> current_points;\n    vector<string> operations;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ) {\n            if (current_points.empty()) {\n                // Can't 'remove', only 'add' or 'find'\n                int op = rnd.next(2); // 0: add, 1: find\n                if (op == 0) { // Add\n                    int x, y;\n                    do {\n                        x = rnd.next(0, maxx);\n                        y = rnd.next(0, maxy);\n                    } while (added_points.count({x,y}));\n                    added_points.insert({x, y});\n                    current_points.push_back({x, y});\n                    operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n                    i++;\n                } else { // Find\n                    int x = rnd.next(0, maxx);\n                    int y = rnd.next(0, maxy);\n                    operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n                    i++;\n                }\n            } else {\n                // Randomly choose among 'add', 'remove', 'find'\n                int op = rnd.next(3); // 0: add, 1: remove, 2: find\n                if (op == 0) { // Add\n                    int x, y;\n                    do {\n                        x = rnd.next(0, maxx);\n                        y = rnd.next(0, maxy);\n                    } while (added_points.count({x,y}));\n                    added_points.insert({x,y});\n                    current_points.push_back({x,y});\n                    operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n                    i++;\n                } else if (op ==1 ) { // Remove\n                    int idx = rnd.next(0, (int)current_points.size()-1);\n                    pair<int,int> p = current_points[idx];\n                    swap(current_points[idx], current_points.back());\n                    current_points.pop_back();\n                    added_points.erase(p);\n                    operations.push_back(\"remove \" + to_string(p.first) + \" \" + to_string(p.second));\n                    i++;\n                } else { // Find\n                    int x = rnd.next(0, maxx);\n                    int y = rnd.next(0, maxy);\n                    operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n                    i++;\n                }\n            }\n        }\n    } else if (type == \"negative\") {\n        int num_add = n / 2;\n        int num_find = n - num_add;\n\n        for (int i = 0; i < num_add; i++) {\n            int x, y;\n            do {\n                x = rnd.next(0, maxx / 2);\n                y = rnd.next(0, maxy / 2);\n            } while (added_points.count({x,y}));\n            added_points.insert({x,y});\n            current_points.push_back({x,y});\n            operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n        }\n\n        for (int i = 0; i < num_find; i++) {\n            int x = rnd.next(maxx / 2 + 1, maxx);\n            int y = rnd.next(maxy / 2 + 1, maxy);\n            operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n        }\n    } else if (type == \"same_x\") {\n        int num_add = n / 2;\n        int num_find = n - num_add;\n\n        int x = rnd.next(0, maxx);\n        for (int i = 0; i < num_add; i++) {\n            int y;\n            do {\n                y = rnd.next(0, maxy);\n            } while (added_points.count({x,y}));\n            added_points.insert({x,y});\n            current_points.push_back({x,y});\n            operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n        }\n\n        for (int i = 0; i < num_find; i++) {\n            int fx = x - rnd.next(0,1); // x or x-1\n            int y = rnd.next(0, maxy);\n            operations.push_back(\"find \" + to_string(fx) + \" \" + to_string(y));\n        }\n    } else if (type == \"same_y\") {\n        int num_add = n / 2;\n        int num_find = n - num_add;\n\n        int y = rnd.next(0, maxy);\n        for (int i = 0; i < num_add; i++) {\n            int x;\n            do {\n                x = rnd.next(0, maxx);\n            } while (added_points.count({x,y}));\n            added_points.insert({x,y});\n            current_points.push_back({x,y});\n            operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n        }\n\n        for (int i = 0; i < num_find; i++) {\n            int x = rnd.next(0, maxx);\n            int fy = y - rnd.next(0,1); // y or y-1\n            operations.push_back(\"find \" + to_string(x) + \" \" + to_string(fy));\n        }\n    } else if (type == \"max_coordinate\") {\n        int num_add = n / 2;\n        int num_find = n - num_add;\n\n        for (int i = 0; i < num_add; i++) {\n            int x, y;\n            do {\n                x = rnd.next(maxx - 1000, maxx);\n                y = rnd.next(maxy - 1000, maxy);\n            } while (added_points.count({x,y}));\n            added_points.insert({x,y});\n            current_points.push_back({x,y});\n            operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n        }\n\n        for (int i = 0; i < num_find; i++) {\n            int x = rnd.next(maxx - 500, maxx);\n            int y = rnd.next(maxy - 500, maxy);\n            operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n        }\n    } else if (type == \"small_coordinates\") {\n        int num_add = n / 2;\n        int num_find = n - num_add;\n\n        int max_small = 1000;\n\n        for (int i = 0; i < num_add; i++) {\n            int x, y;\n            do {\n                x = rnd.next(0, max_small);\n                y = rnd.next(0, max_small);\n            } while (added_points.count({x,y}));\n            added_points.insert({x,y});\n            current_points.push_back({x,y});\n            operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n        }\n\n        for (int i = 0; i < num_find; i++) {\n            int x = rnd.next(0, max_small);\n            int y = rnd.next(0, max_small);\n            operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n        }\n    } else if (type == \"all_adds_then_finds\") {\n        int num_add = n / 2 + n % 2;\n        int num_find = n - num_add;\n\n        for (int i = 0; i < num_add; i++) {\n            int x, y;\n            do {\n                x = rnd.next(0, maxx);\n                y = rnd.next(0, maxy);\n            } while (added_points.count({x,y}));\n            added_points.insert({x,y});\n            current_points.push_back({x,y});\n            operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n        }\n\n        for (int i = 0; i < num_find; i++) {\n            int x = rnd.next(0, maxx);\n            int y = rnd.next(0, maxy);\n            operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n        }\n    } else if (type == \"multiple_same_x\") {\n        int num_add = n / 2;\n        int num_find = n - num_add;\n\n        int x0 = rnd.next(0, maxx / 2);\n        for (int i = 0; i < num_add; i++) {\n            int y;\n            do {\n                y = rnd.next(0, maxy);\n            } while (added_points.count({x0,y}));\n            added_points.insert({x0,y});\n            current_points.push_back({x0,y});\n            operations.push_back(\"add \" + to_string(x0) + \" \" + to_string(y));\n        }\n\n        for (int i = 0; i < num_find; i++) {\n            int x = x0 - 1; // So all added points are strictly to the right\n            int y = rnd.next(0, maxy);\n            operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n        }\n    } else if (type == \"multiple_same_y\") {\n        int num_add = n / 2;\n        int num_find = n - num_add;\n\n        int y0 = rnd.next(0, maxy / 2);\n        for (int i = 0; i < num_add; i++) {\n            int x;\n            do {\n                x = rnd.next(0, maxx);\n            } while (added_points.count({x,y0}));\n            added_points.insert({x,y0});\n            current_points.push_back({x,y0});\n            operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y0));\n        }\n\n        for (int i = 0; i < num_find; i++) {\n            int x = rnd.next(0, maxx);\n            int y = y0 - 1; // So all added points are strictly above\n            operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n        }\n    } else {\n        // Default to random if unknown type\n        // You can add additional types as needed\n        for (int i = 0; i < n; ) {\n            if (current_points.empty()) {\n                // Can't 'remove', only 'add' or 'find'\n                int op = rnd.next(2); // 0: add, 1: find\n                if (op == 0) { // Add\n                    int x, y;\n                    do {\n                        x = rnd.next(0, maxx);\n                        y = rnd.next(0, maxy);\n                    } while (added_points.count({x,y}));\n                    added_points.insert({x, y});\n                    current_points.push_back({x, y});\n                    operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n                    i++;\n                } else { // Find\n                    int x = rnd.next(0, maxx);\n                    int y = rnd.next(0, maxy);\n                    operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n                    i++;\n                }\n            } else {\n                // Randomly choose among 'add', 'remove', 'find'\n                int op = rnd.next(3); // 0: add, 1: remove, 2: find\n                if (op == 0) { // Add\n                    int x, y;\n                    do {\n                        x = rnd.next(0, maxx);\n                        y = rnd.next(0, maxy);\n                    } while (added_points.count({x,y}));\n                    added_points.insert({x,y});\n                    current_points.push_back({x,y});\n                    operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n                    i++;\n                } else if (op ==1 ) { // Remove\n                    int idx = rnd.next(0, (int)current_points.size()-1);\n                    pair<int,int> p = current_points[idx];\n                    swap(current_points[idx], current_points.back());\n                    current_points.pop_back();\n                    added_points.erase(p);\n                    operations.push_back(\"remove \" + to_string(p.first) + \" \" + to_string(p.second));\n                    i++;\n                } else { // Find\n                    int x = rnd.next(0, maxx);\n                    int y = rnd.next(0, maxy);\n                    operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n                    i++;\n                }\n            }\n        }\n    }\n\n    // Output n and the operations\n    printf(\"%d\\n\", n);\n    for (string s : operations)\n        printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int maxx = opt<int>(\"maxx\", (int)1e9);\n    int maxy = opt<int>(\"maxy\", (int)1e9);\n\n    set<pair<int,int>> added_points;\n    vector<pair<int,int>> current_points;\n    vector<string> operations;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ) {\n            if (current_points.empty()) {\n                // Can't 'remove', only 'add' or 'find'\n                int op = rnd.next(2); // 0: add, 1: find\n                if (op == 0) { // Add\n                    int x, y;\n                    do {\n                        x = rnd.next(0, maxx);\n                        y = rnd.next(0, maxy);\n                    } while (added_points.count({x,y}));\n                    added_points.insert({x, y});\n                    current_points.push_back({x, y});\n                    operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n                    i++;\n                } else { // Find\n                    int x = rnd.next(0, maxx);\n                    int y = rnd.next(0, maxy);\n                    operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n                    i++;\n                }\n            } else {\n                // Randomly choose among 'add', 'remove', 'find'\n                int op = rnd.next(3); // 0: add, 1: remove, 2: find\n                if (op == 0) { // Add\n                    int x, y;\n                    do {\n                        x = rnd.next(0, maxx);\n                        y = rnd.next(0, maxy);\n                    } while (added_points.count({x,y}));\n                    added_points.insert({x,y});\n                    current_points.push_back({x,y});\n                    operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n                    i++;\n                } else if (op ==1 ) { // Remove\n                    int idx = rnd.next(0, (int)current_points.size()-1);\n                    pair<int,int> p = current_points[idx];\n                    swap(current_points[idx], current_points.back());\n                    current_points.pop_back();\n                    added_points.erase(p);\n                    operations.push_back(\"remove \" + to_string(p.first) + \" \" + to_string(p.second));\n                    i++;\n                } else { // Find\n                    int x = rnd.next(0, maxx);\n                    int y = rnd.next(0, maxy);\n                    operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n                    i++;\n                }\n            }\n        }\n    } else if (type == \"negative\") {\n        int num_add = n / 2;\n        int num_find = n - num_add;\n\n        for (int i = 0; i < num_add; i++) {\n            int x, y;\n            do {\n                x = rnd.next(0, maxx / 2);\n                y = rnd.next(0, maxy / 2);\n            } while (added_points.count({x,y}));\n            added_points.insert({x,y});\n            current_points.push_back({x,y});\n            operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n        }\n\n        for (int i = 0; i < num_find; i++) {\n            int x = rnd.next(maxx / 2 + 1, maxx);\n            int y = rnd.next(maxy / 2 + 1, maxy);\n            operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n        }\n    } else if (type == \"same_x\") {\n        int num_add = n / 2;\n        int num_find = n - num_add;\n\n        int x = rnd.next(0, maxx);\n        for (int i = 0; i < num_add; i++) {\n            int y;\n            do {\n                y = rnd.next(0, maxy);\n            } while (added_points.count({x,y}));\n            added_points.insert({x,y});\n            current_points.push_back({x,y});\n            operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n        }\n\n        for (int i = 0; i < num_find; i++) {\n            int fx = x - rnd.next(0,1); // x or x-1\n            int y = rnd.next(0, maxy);\n            operations.push_back(\"find \" + to_string(fx) + \" \" + to_string(y));\n        }\n    } else if (type == \"same_y\") {\n        int num_add = n / 2;\n        int num_find = n - num_add;\n\n        int y = rnd.next(0, maxy);\n        for (int i = 0; i < num_add; i++) {\n            int x;\n            do {\n                x = rnd.next(0, maxx);\n            } while (added_points.count({x,y}));\n            added_points.insert({x,y});\n            current_points.push_back({x,y});\n            operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n        }\n\n        for (int i = 0; i < num_find; i++) {\n            int x = rnd.next(0, maxx);\n            int fy = y - rnd.next(0,1); // y or y-1\n            operations.push_back(\"find \" + to_string(x) + \" \" + to_string(fy));\n        }\n    } else if (type == \"max_coordinate\") {\n        int num_add = n / 2;\n        int num_find = n - num_add;\n\n        for (int i = 0; i < num_add; i++) {\n            int x, y;\n            do {\n                x = rnd.next(maxx - 1000, maxx);\n                y = rnd.next(maxy - 1000, maxy);\n            } while (added_points.count({x,y}));\n            added_points.insert({x,y});\n            current_points.push_back({x,y});\n            operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n        }\n\n        for (int i = 0; i < num_find; i++) {\n            int x = rnd.next(maxx - 500, maxx);\n            int y = rnd.next(maxy - 500, maxy);\n            operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n        }\n    } else if (type == \"small_coordinates\") {\n        int num_add = n / 2;\n        int num_find = n - num_add;\n\n        int max_small = 1000;\n\n        for (int i = 0; i < num_add; i++) {\n            int x, y;\n            do {\n                x = rnd.next(0, max_small);\n                y = rnd.next(0, max_small);\n            } while (added_points.count({x,y}));\n            added_points.insert({x,y});\n            current_points.push_back({x,y});\n            operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n        }\n\n        for (int i = 0; i < num_find; i++) {\n            int x = rnd.next(0, max_small);\n            int y = rnd.next(0, max_small);\n            operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n        }\n    } else if (type == \"all_adds_then_finds\") {\n        int num_add = n / 2 + n % 2;\n        int num_find = n - num_add;\n\n        for (int i = 0; i < num_add; i++) {\n            int x, y;\n            do {\n                x = rnd.next(0, maxx);\n                y = rnd.next(0, maxy);\n            } while (added_points.count({x,y}));\n            added_points.insert({x,y});\n            current_points.push_back({x,y});\n            operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n        }\n\n        for (int i = 0; i < num_find; i++) {\n            int x = rnd.next(0, maxx);\n            int y = rnd.next(0, maxy);\n            operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n        }\n    } else if (type == \"multiple_same_x\") {\n        int num_add = n / 2;\n        int num_find = n - num_add;\n\n        int x0 = rnd.next(0, maxx / 2);\n        for (int i = 0; i < num_add; i++) {\n            int y;\n            do {\n                y = rnd.next(0, maxy);\n            } while (added_points.count({x0,y}));\n            added_points.insert({x0,y});\n            current_points.push_back({x0,y});\n            operations.push_back(\"add \" + to_string(x0) + \" \" + to_string(y));\n        }\n\n        for (int i = 0; i < num_find; i++) {\n            int x = x0 - 1; // So all added points are strictly to the right\n            int y = rnd.next(0, maxy);\n            operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n        }\n    } else if (type == \"multiple_same_y\") {\n        int num_add = n / 2;\n        int num_find = n - num_add;\n\n        int y0 = rnd.next(0, maxy / 2);\n        for (int i = 0; i < num_add; i++) {\n            int x;\n            do {\n                x = rnd.next(0, maxx);\n            } while (added_points.count({x,y0}));\n            added_points.insert({x,y0});\n            current_points.push_back({x,y0});\n            operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y0));\n        }\n\n        for (int i = 0; i < num_find; i++) {\n            int x = rnd.next(0, maxx);\n            int y = y0 - 1; // So all added points are strictly above\n            operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n        }\n    } else {\n        // Default to random if unknown type\n        // You can add additional types as needed\n        for (int i = 0; i < n; ) {\n            if (current_points.empty()) {\n                // Can't 'remove', only 'add' or 'find'\n                int op = rnd.next(2); // 0: add, 1: find\n                if (op == 0) { // Add\n                    int x, y;\n                    do {\n                        x = rnd.next(0, maxx);\n                        y = rnd.next(0, maxy);\n                    } while (added_points.count({x,y}));\n                    added_points.insert({x, y});\n                    current_points.push_back({x, y});\n                    operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n                    i++;\n                } else { // Find\n                    int x = rnd.next(0, maxx);\n                    int y = rnd.next(0, maxy);\n                    operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n                    i++;\n                }\n            } else {\n                // Randomly choose among 'add', 'remove', 'find'\n                int op = rnd.next(3); // 0: add, 1: remove, 2: find\n                if (op == 0) { // Add\n                    int x, y;\n                    do {\n                        x = rnd.next(0, maxx);\n                        y = rnd.next(0, maxy);\n                    } while (added_points.count({x,y}));\n                    added_points.insert({x,y});\n                    current_points.push_back({x,y});\n                    operations.push_back(\"add \" + to_string(x) + \" \" + to_string(y));\n                    i++;\n                } else if (op ==1 ) { // Remove\n                    int idx = rnd.next(0, (int)current_points.size()-1);\n                    pair<int,int> p = current_points[idx];\n                    swap(current_points[idx], current_points.back());\n                    current_points.pop_back();\n                    added_points.erase(p);\n                    operations.push_back(\"remove \" + to_string(p.first) + \" \" + to_string(p.second));\n                    i++;\n                } else { // Find\n                    int x = rnd.next(0, maxx);\n                    int y = rnd.next(0, maxy);\n                    operations.push_back(\"find \" + to_string(x) + \" \" + to_string(y));\n                    i++;\n                }\n            }\n        }\n    }\n\n    // Output n and the operations\n    printf(\"%d\\n\", n);\n    for (string s : operations)\n        printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 200000 -type random\n\n./gen -n 200000 -type negative\n\n./gen -n 200000 -type same_x\n./gen -n 200000 -type same_y\n\n./gen -n 200000 -type max_coordinate\n./gen -n 200000 -type small_coordinates\n\n./gen -n 200000 -type all_adds_then_finds\n./gen -n 200000 -type multiple_same_x\n./gen -n 200000 -type multiple_same_y\n\n# Edge cases with minimal n\n./gen -n 1 -type random\n./gen -n 2 -type negative\n./gen -n 2 -type same_x\n\n# Edge cases with maximal coordinates\n./gen -n 200000 -maxx 1000000000 -maxy 1000000000 -type max_coordinate\n\n# Dense area\n./gen -n 200000 -maxx 1000 -maxy 1000 -type small_coordinates\n\n# Testing with specified maxx and maxy\n./gen -n 200000 -maxx 500000000 -maxy 500000000 -type random\n\n# Random test with small n\n./gen -n 1234 -type random\n\n# Random test with n near maximum\n./gen -n 199999 -type random\n\n# All 'find' operations\n./gen -n 200000 -type all_adds_then_finds\n\n# All 'add' operations followed by all 'remove' operations\n./gen -n 200000 -type all_adds_then_removes\n\n# Multiple 'add' and 'remove' of same point\n./gen -n 200000 -type multiple_same_point\n\n# Points on boundary coordinates\n./gen -n 200000 -type boundary_points\n\n# Testing with large x and small y\n./gen -n 200000 -maxx 1000000000 -maxy 10 -type random\n\n# Testing with small x and large y\n./gen -n 200000 -maxx 10 -maxy 1000000000 -type random\n\n# Find operations that always find the same point\n./gen -n 200000 -type identical_answer\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:45:59.085239",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "19/E",
      "title": "E. Fairy",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains two integer numbers: n — amount of the drawn points and m — amount of the drawn segments (1 ≤ n ≤ 104, 0 ≤ m ≤ 104). The following m lines contain the descriptions of the segments. Each description contains two different space-separated integer numbers v, u (1 ≤ v ≤ n, 1 ≤ u ≤ n) — indexes of the points, joined by this segment. No segment is met in the description twice.",
      "output_spec": "OutputIn the first line output number k — amount of the segments in the answer. In the second line output k space-separated numbers — indexes of these segments in ascending order. Each index should be output only once. Segments are numbered from 1 in the input order.",
      "sample_tests": "ExamplesInputCopy4 41 21 32 43 4OutputCopy41 2 3 4 InputCopy4 51 22 33 44 11 3OutputCopy15",
      "description": "time limit per test1.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains two integer numbers: n — amount of the drawn points and m — amount of the drawn segments (1 ≤ n ≤ 104, 0 ≤ m ≤ 104). The following m lines contain the descriptions of the segments. Each description contains two different space-separated integer numbers v, u (1 ≤ v ≤ n, 1 ≤ u ≤ n) — indexes of the points, joined by this segment. No segment is met in the description twice.\n\nOutputIn the first line output number k — amount of the segments in the answer. In the second line output k space-separated numbers — indexes of these segments in ascending order. Each index should be output only once. Segments are numbered from 1 in the input order.\n\nInputCopy4 41 21 32 43 4OutputCopy41 2 3 4 InputCopy4 51 22 33 44 11 3OutputCopy15\n\nInputCopy4 41 21 32 43 4\n\nOutputCopy41 2 3 4\n\nInputCopy4 51 22 33 44 11 3\n\nOutputCopy15",
      "solutions": [
        {
          "title": "Codeforces Beta Round #19 - Codeforces",
          "content": "Welcome to Codeforces Beta Round #19.Authors of today's contest are Artem Rakhov and me. Thanks to Mike Mirzayanov, Edvard Davtyan and Julia Satushina for help in the organisation.I hope, you will have fun.Good luck!P.S. After start of the contest, you can download the statements:EnglishRussianUPD. The contest has finished and you can see the standings and tasks. The winner and only participant who has solved all the problems is kalinov. Congratulations!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/484",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 19 和字母"
          },
          "content_length": 458
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces",
          "content": "I find that no one write a solution about this contest..So I write one.. A. World Football Cup I think is' just a problem about writing code  quickly and correctly.Just follow the statement. if you use c++ STL will make you life easier B. Checkout Assistant First,for every i increase ti by 1..then you will  see that statement require sum of t of the items  bigger or equal to n..and their sum of c should  be minimal..so it's just a 0-1 knapsack problem. C. Deletion of Repeats First let's generate all repeats.In a repeat,the  first number and the middle number must be the  same, so we just look at all pair of postion which  have same number..Thank to the statement..There  are at most O(10N) such pair..And use suffix array  to check if each pair can build a repeat...Then  just sort all the interval and go through then to  get the answer...http://en.wikipedia.org/wiki/Suffix_arraymaybe you think suffix array is hard to code..you can use hash and binary search to do the same..my code here http://www.ideone.com/N5zPS D. Points First of all,do the discretization.Then the biggest  value of x is n,so we can build a Segment Tree to  Ask the question \"what is the first place from   postion x and its value is bigger than y\"..if we  find such postion we just find the smallest Y-value  bigger than y in such postion--it can be done using  set's operation upper_bound...http://en.wikipedia.org/wiki/Segment_tree so the algorithm is clear..For every possible value  of x use a set to store all y value in it..And every  time the action is \"find\" or \"remove\" just change  this set and update the Segment Tree..otherwise use  Segment Tree to find the answer..my code here http://www.ideone.com/4iNolE. Fairy It's a interesting problem.If you for every edge,  try to remove it and check if it is a bipartite  graph..I think it will get TLE..so let's analysis  the property of bipartite graph..http://en.wikipedia.org/wiki/Bipartite_graphAfter reading it...we know.. It should never contain a cycle of odd length... and it can be 2-colored.. so first build a spanning forest for the graph.. and do the 2-color on it(Tree can be 2-colored). for convenience. Let TreeEdge={all edge in forest} NotTreeEdge={All edge}/TreeEdge ErrorEdge={all edge that two endpoint have the same color..} NotErorEdge=NotTreeEdge/ErroEdge.. First,consider a edge form NotTreeEdge,remove it  can't change any node's color..so.. if |ErrorEdge|=0 of course we can remove all NotTreeEdge if =1 we just can remove the ErrorEdge if >1 we can't remove any from NotTreeEdge Now,Let consider a Edge e from TreeEdge.. Let Path(Edge e)=the path in forest between e's two endpoints.. if there is a Edge e' from ErrorEdge that Path(e')  didn't  go through e..it will destroy the bipartite  graph.. if there is a Edge e' from ErrorEdge that Path(e') go through e and there is a Edge e'' from NotErrorEdge that Path(e'') go through e..it will also destroy the bipartite graph.. so now we need to know for every edge,how many such path go through it..it require a data structure... one way is to use heavy-light decomposition then we can update every path in O(LogN^2)... another way is to use Link-Cut Tree..It can do the same in O(LogN)....if you didn't see Link-Cut tree before,you can read thishttp://www.cs.cmu.edu/~sleator/papers/dynamic-trees.pdfor my code..use heavy-light decomposition http://www.ideone.com/dPS5N",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/559",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3385
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #19 - Codeforces - Code 1",
          "code": "<A HREF=\"http://ideone.com/djbUe\">Code</A> is here. Can anyone tell where i am wrong.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/484",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 1",
          "code": "http://www.ideone.com/dPS5N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 2",
          "code": "12 1 2 1 3 4 2 1 2 1 3 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 3",
          "code": "6 1 2 1 3 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        },
        {
          "title": "Code Force Beta Round 19 Solution - Codeforces - Code 4",
          "code": "5 2 1 3 4 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/559",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include <bits/stdc++.h>\n#include \"testlib.h\"\nusing namespace std;\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 10000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readEoln();\n\n        ensuref(v != u, \"Edge %d: v = u = %d\", i+1, v);\n\n        int a = min(v,u);\n        int b = max(v,u);\n        pair<int,int> edge = make_pair(a,b);\n\n        ensuref(edges.count(edge) == 0, \"Edge %d: Duplicate edge between %d and %d\", i+1, a, b);\n        edges.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include <bits/stdc++.h>\n#include \"testlib.h\"\nusing namespace std;\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 10000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readEoln();\n\n        ensuref(v != u, \"Edge %d: v = u = %d\", i+1, v);\n\n        int a = min(v,u);\n        int b = max(v,u);\n        pair<int,int> edge = make_pair(a,b);\n\n        ensuref(edges.count(edge) == 0, \"Edge %d: Duplicate edge between %d and %d\", i+1, a, b);\n        edges.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include <bits/stdc++.h>\n#include \"testlib.h\"\nusing namespace std;\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 10000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readEoln();\n\n        ensuref(v != u, \"Edge %d: v = u = %d\", i+1, v);\n\n        int a = min(v,u);\n        int b = max(v,u);\n        pair<int,int> edge = make_pair(a,b);\n\n        ensuref(edges.count(edge) == 0, \"Edge %d: Duplicate edge between %d and %d\", i+1, a, b);\n        edges.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"random\") {\n        if (m == -1) {\n            m = rnd.next(0LL, min(1LL * n * (n - 1) / 2, 10000LL));\n        }\n        m = min(m, (int)(1LL * n * (n - 1) / 2));\n        set<pair<int, int>> edgeSet;\n        while ((int)edgeSet.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            edgeSet.insert(make_pair(u, v));\n        }\n        for (auto e : edgeSet) {\n            edges.push_back(e);\n        }\n    } else if (type == \"complete\") {\n        n = min(n, 141); // Ensure n*(n-1)/2 ≤ 10000\n        m = n * (n - 1) / 2;\n        for (int u = 1; u <= n; u++) {\n            for (int v = u + 1; v <= n; v++) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else if (type == \"tree\") {\n        m = n - 1;\n        for (int i = 2; i <= n; i++) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back(make_pair(u, v));\n        }\n        shuffle(edges.begin(), edges.end());\n    } else if (type == \"cycle\") {\n        m = n;\n        for (int i = 1; i <= n; i++) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back(make_pair(u, v));\n        }\n    } else if (type == \"bipartite\") {\n        int k = rnd.next(1, n - 1);\n        vector<int> nodes(n);\n        for (int i = 0; i < n; i++) nodes[i] = i + 1;\n        shuffle(nodes.begin(), nodes.end());\n        vector<int> A(nodes.begin(), nodes.begin() + k);\n        vector<int> B(nodes.begin() + k, nodes.end());\n        int max_edges = k * (n - k);\n        if (max_edges == 0) {\n            m = 0;\n        } else {\n            if (m == -1) {\n                m = rnd.next(0, min(max_edges, 10000));\n            }\n            m = min(m, max_edges);\n        }\n        set<pair<int, int>> edgeSet;\n        while ((int)edgeSet.size() < m) {\n            int u = A[rnd.next(0, (int)A.size() - 1)];\n            int v = B[rnd.next(0, (int)B.size() - 1)];\n            if (u > v) swap(u, v);\n            edgeSet.insert(make_pair(u, v));\n        }\n        for (auto e : edgeSet) {\n            edges.push_back(e);\n        }\n    } else if (type == \"almost_bipartite\") {\n        int k = rnd.next(1, n - 1);\n        vector<int> nodes(n);\n        for (int i = 0; i < n; i++) nodes[i] = i + 1;\n        shuffle(nodes.begin(), nodes.end());\n        vector<int> A(nodes.begin(), nodes.begin() + k);\n        vector<int> B(nodes.begin() + k, nodes.end());\n        int max_edges = k * (n - k);\n        if (max_edges == 0) {\n            m = 1;\n        } else {\n            if (m == -1) {\n                m = rnd.next(1, min(max_edges + 1, 10000));\n            }\n            m = min(m, max_edges + 1);\n        }\n        set<pair<int, int>> edgeSet;\n        int m1 = min(m - 1, max_edges);\n        while ((int)edgeSet.size() < m1) {\n            int u = A[rnd.next(0, (int)A.size() - 1)];\n            int v = B[rnd.next(0, (int)B.size() - 1)];\n            if (u > v) swap(u, v);\n            edgeSet.insert(make_pair(u, v));\n        }\n        // Add one edge between two nodes in the same set\n        int u, v;\n        bool edge_added = false;\n        if (A.size() >= 2 && (rnd.next(0, 1) == 0 || B.size() < 2)) {\n            u = A[rnd.next(0, (int)A.size() - 1)];\n            v = A[rnd.next(0, (int)A.size() - 1)];\n            while (u == v) {\n                v = A[rnd.next(0, (int)A.size() - 1)];\n            }\n            if (u > v) swap(u, v);\n            edgeSet.insert(make_pair(u, v));\n            edge_added = true;\n        } else if (B.size() >= 2) {\n            u = B[rnd.next(0, (int)B.size() - 1)];\n            v = B[rnd.next(0, (int)B.size() - 1)];\n            while (u == v) {\n                v = B[rnd.next(0, (int)B.size() - 1)];\n            }\n            if (u > v) swap(u, v);\n            edgeSet.insert(make_pair(u, v));\n            edge_added = true;\n        }\n        if (!edge_added && m1 < m) {\n            m = m1;\n        }\n        for (auto e : edgeSet) {\n            edges.push_back(e);\n        }\n    } else {\n        cerr << \"Invalid type\" << endl;\n        return 1;\n    }\n\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (int i = 0; i < (int)edges.size(); i++) {\n        printf(\"%d %d\\n\", edges[i].first, edges[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"random\") {\n        if (m == -1) {\n            m = rnd.next(0LL, min(1LL * n * (n - 1) / 2, 10000LL));\n        }\n        m = min(m, (int)(1LL * n * (n - 1) / 2));\n        set<pair<int, int>> edgeSet;\n        while ((int)edgeSet.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            edgeSet.insert(make_pair(u, v));\n        }\n        for (auto e : edgeSet) {\n            edges.push_back(e);\n        }\n    } else if (type == \"complete\") {\n        n = min(n, 141); // Ensure n*(n-1)/2 ≤ 10000\n        m = n * (n - 1) / 2;\n        for (int u = 1; u <= n; u++) {\n            for (int v = u + 1; v <= n; v++) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else if (type == \"tree\") {\n        m = n - 1;\n        for (int i = 2; i <= n; i++) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back(make_pair(u, v));\n        }\n        shuffle(edges.begin(), edges.end());\n    } else if (type == \"cycle\") {\n        m = n;\n        for (int i = 1; i <= n; i++) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back(make_pair(u, v));\n        }\n    } else if (type == \"bipartite\") {\n        int k = rnd.next(1, n - 1);\n        vector<int> nodes(n);\n        for (int i = 0; i < n; i++) nodes[i] = i + 1;\n        shuffle(nodes.begin(), nodes.end());\n        vector<int> A(nodes.begin(), nodes.begin() + k);\n        vector<int> B(nodes.begin() + k, nodes.end());\n        int max_edges = k * (n - k);\n        if (max_edges == 0) {\n            m = 0;\n        } else {\n            if (m == -1) {\n                m = rnd.next(0, min(max_edges, 10000));\n            }\n            m = min(m, max_edges);\n        }\n        set<pair<int, int>> edgeSet;\n        while ((int)edgeSet.size() < m) {\n            int u = A[rnd.next(0, (int)A.size() - 1)];\n            int v = B[rnd.next(0, (int)B.size() - 1)];\n            if (u > v) swap(u, v);\n            edgeSet.insert(make_pair(u, v));\n        }\n        for (auto e : edgeSet) {\n            edges.push_back(e);\n        }\n    } else if (type == \"almost_bipartite\") {\n        int k = rnd.next(1, n - 1);\n        vector<int> nodes(n);\n        for (int i = 0; i < n; i++) nodes[i] = i + 1;\n        shuffle(nodes.begin(), nodes.end());\n        vector<int> A(nodes.begin(), nodes.begin() + k);\n        vector<int> B(nodes.begin() + k, nodes.end());\n        int max_edges = k * (n - k);\n        if (max_edges == 0) {\n            m = 1;\n        } else {\n            if (m == -1) {\n                m = rnd.next(1, min(max_edges + 1, 10000));\n            }\n            m = min(m, max_edges + 1);\n        }\n        set<pair<int, int>> edgeSet;\n        int m1 = min(m - 1, max_edges);\n        while ((int)edgeSet.size() < m1) {\n            int u = A[rnd.next(0, (int)A.size() - 1)];\n            int v = B[rnd.next(0, (int)B.size() - 1)];\n            if (u > v) swap(u, v);\n            edgeSet.insert(make_pair(u, v));\n        }\n        // Add one edge between two nodes in the same set\n        int u, v;\n        bool edge_added = false;\n        if (A.size() >= 2 && (rnd.next(0, 1) == 0 || B.size() < 2)) {\n            u = A[rnd.next(0, (int)A.size() - 1)];\n            v = A[rnd.next(0, (int)A.size() - 1)];\n            while (u == v) {\n                v = A[rnd.next(0, (int)A.size() - 1)];\n            }\n            if (u > v) swap(u, v);\n            edgeSet.insert(make_pair(u, v));\n            edge_added = true;\n        } else if (B.size() >= 2) {\n            u = B[rnd.next(0, (int)B.size() - 1)];\n            v = B[rnd.next(0, (int)B.size() - 1)];\n            while (u == v) {\n                v = B[rnd.next(0, (int)B.size() - 1)];\n            }\n            if (u > v) swap(u, v);\n            edgeSet.insert(make_pair(u, v));\n            edge_added = true;\n        }\n        if (!edge_added && m1 < m) {\n            m = m1;\n        }\n        for (auto e : edgeSet) {\n            edges.push_back(e);\n        }\n    } else {\n        cerr << \"Invalid type\" << endl;\n        return 1;\n    }\n\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (int i = 0; i < (int)edges.size(); i++) {\n        printf(\"%d %d\\n\", edges[i].first, edges[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal input\n./gen -n 1 -m 0 -type random\n\n# Small random graph\n./gen -n 5 -m 4 -type random\n\n# Small complete graph\n./gen -n 5 -type complete\n\n# Small cycle\n./gen -n 5 -type cycle\n\n# Small tree\n./gen -n 5 -type tree\n\n# Small bipartite graph\n./gen -n 5 -m 6 -type bipartite\n\n# Small almost bipartite graph\n./gen -n 5 -m 7 -type almost_bipartite\n\n# Complete graph with maximal n\n./gen -n 141 -type complete\n\n# Large random graph\n./gen -n 10000 -m 10000 -type random\n\n# Large tree\n./gen -n 10000 -type tree\n\n# Large cycle\n./gen -n 10000 -type cycle\n\n# Large bipartite graph\n./gen -n 10000 -m 10000 -type bipartite\n\n# Large almost bipartite graph\n./gen -n 10000 -m 10000 -type almost_bipartite\n\n# Random graph with maximal m\n./gen -n 5000 -m 10000 -type random\n\n# Random graph with random m\n./gen -n 1000 -type random\n\n# Bipartite graph with random m\n./gen -n 1000 -type bipartite\n\n# Almost bipartite graph with random m\n./gen -n 1000 -type almost_bipartite\n\n# Complete graph with minimal n\n./gen -n 2 -type complete\n\n# Cycle graph with small n\n./gen -n 3 -type cycle\n\n# Edge case with n=10000 and m=0\n./gen -n 10000 -m 0 -type random\n\n# Edge case with m=1\n./gen -n 10000 -m 1 -type random\n\n# Graph with n=9999, m=10000\n./gen -n 9999 -m 10000 -type random\n\n# Random tree with small n\n./gen -n 10 -type tree\n\n# Random bipartite graph with small m\n./gen -n 1000 -m 500 -type bipartite\n\n# Random almost bipartite graph with m near maximum\n./gen -n 1000 -m 1000 -type almost_bipartite\n\n# Random graph with n=m=10000\n./gen -n 10000 -m 10000 -type random\n\n# Tree with maximum n\n./gen -n 10000 -type tree\n\n# Cycle with n=10000\n./gen -n 10000 -type cycle\n\n# Complete graph with n=141\n./gen -n 141 -type complete\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:00.829631",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "190/A",
      "title": "A. Вася и автобусы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВходные данные состоят из одной строки, в которой через пробел заданы два целых числа n и m (0 ≤ n, m ≤ 105) — количество взрослых и количество детей в автобусе, соответственно.",
      "output_spec": "Выходные данныеЕсли в автобусе могли ехать n взрослых и m детей в единственной строке выведите через пробел два числа — минимальную и максимальную возможную стоимость проезда этих людей, соответственно. В противном случае выведите «Impossible» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать1 2Выходные данныеСкопировать2 2Входные данныеСкопировать0 5Выходные данныеСкопироватьImpossibleВходные данныеСкопировать2 2Выходные данныеСкопировать2 3",
      "description": "A. Вася и автобусы\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВходные данные состоят из одной строки, в которой через пробел заданы два целых числа n и m (0 ≤ n, m ≤ 105) — количество взрослых и количество детей в автобусе, соответственно.\n\nВходные данные\n\nВыходные данныеЕсли в автобусе могли ехать n взрослых и m детей в единственной строке выведите через пробел два числа — минимальную и максимальную возможную стоимость проезда этих людей, соответственно. В противном случае выведите «Impossible» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать1 2Выходные данныеСкопировать2 2Входные данныеСкопировать0 5Выходные данныеСкопироватьImpossibleВходные данныеСкопировать2 2Выходные данныеСкопировать2 3\n\nВходные данныеСкопировать1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать0 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьImpossible\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере один взрослый едет с двумя детьми и платит два рубля.Во втором примере в автобусе только дети, чего случиться не могло. В третьем примере могло быть два случая:  Каждый из двух пассажиров провозил одного ребенка и заплатил по одному рублю. В этом случае суммарная стоимость проезда — два рубля.  Один из пассажиров вез двоих детей и заплатил два рубля, а другой ехал один и заплатил один рубль. Суммарная стоимость — три рубля.",
      "solutions": [
        {
          "title": "Codeforces Round #120 (Div. 2) - Codeforces",
          "content": "Пришло время для Валеры оказаться и нам (я и Kostroma) по ту сторону контеста.Мы являемся авторами сегодняшнего раунда и надеемся, что вы сможете понять условия он вам (а главное нам) понравится.В этот раз вы столкнетесь с очередной историей про частого героя местных задач — Васю.Как вы могли бы догадаться, этот раунд для участников из второго дивизиона, но мы думаем, что и div.1 найдет, что сегодня порешать.Спасибо за помощь в подготовке STAJIKER, HeroShadow, victor_kamashev, Abra, ifsmirnov, Aksenov239 и, конечно, Gerald, а также MikeMirzayanov за платформу CodeForces и Delinur за английскую версию условийУспехов!UPD2: Разбалловка стандартная, фиксированная, 500-1000-1500-2000-2500. Авторы думают, что задачи упорядочены по сложности.UPD3: Мы извиняемся, по нашей вине произошла ошибка, на несколько минут был случайно опубликован разбор задач. Тем, кто его видел, просьба не обсуждать задачи. В любом случае контест будет проводиться. Вопрос о рейтинговости раунда будет решен после контеста.UPD4: Выяснилось, что во время нахождения разбора в общем доступе только три человека из div2 просматривали пост с разбором (а всего восемь). Мы не будем называть никаких имен, но очень сильно просим не разглашать никакой информации про раунд и не пользоваться никакими материалами поста, если они у вас остались. Спасибо за понимание.UPD5: Пожалуйсте, не устраивайте панику, вы можете решать следующие задачи, пока ваше решение не тестируется.UPD6: Раунд объявляется нерейтинговым. Это связано с техническими причинами (тестирование не начинается более часа). В сумме с произошедшим инцидентом с разбором, это явлется веской причиной для подобного решения. Вы можете посылать свои решения в контест. Мы обязательно протестируем все попытки. Мы надеемся что технические проблемы не сильно испортят ваше впечатление от задач. Наши искренние извинения за эти недоработки.UPD7: Контест завершен. Опубликован разбор. Надеемся, что вам понравились подготовленные нами задачи. Думаю, мы еще вернемся. Еще раз мои извинения.P.S: К сожалению, я не знаю, когда протестируется решения.UPD8: Тестирование завершено.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4554",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2108
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces",
          "content": "Прежде чем опубликовать разбор задач сегодняшнего раунда, приношу извинения администрации и участникам за свою глупую ошибку, допущенную по криворукости и неопытности.Несмотря на то что раунд откровенно не удался, мы, авторы, рады, что многим участникам задачи понравились. Вот, собственно, решения:A — Вася и автобусыВо-первых, если n = 0, то ни одного ребенка по условию нельзя провезти. Значит, если при этом m = 0, от ответ (0, 0), иначе ответ Impossible.Теперь n > 0. Если m = 0, то ответ, очевидно, (n, n). Иначе, чем больше родителей везет с собой по ребенку, тем меньше плата за проезд. Поэтому максимальная плата будет тогда, когда всех детей везет один родитель — получаем ответ n + m - 1. Если n <  = m, то все n родителей везут детей, и ровно n детей не платят за проезд. Если же n > m, то все m детей распределяются по родителям и не платят за проезд. В обоих случаях получаем минимальный ответ max(n, m).B — ОкружениеНайдем минимальное расстояние между окружностями L. Тогда ответ к задаче равен L / 2.- Пусть окружности лежат вне друг друга. Покажем, что L = d - R - r. Во-первых, ясно, что он достигается. Проведем отрезок соединяющий центры. Его часть, лежащая между точками пересечения с окружностями как раз имеет такую длину. Докажем, что меньшее расстояние недостижимо, построим отрезок между двумя окружностями. Тогда R + r + L >  = d, откуда L >  = d - R - r, чтд. Для окружностей, лежащих внутри друг друга аналогичными рассуждениями получаем L = R - d - r, где R — радиус наружной окружности, r — внутренней. Для пересекающихся окружностей ответ 0. C — STLПусть нам дан массив строк (s1, s2, ...sn), где si  = pair либо int.Рассмотрим числа bali = разность количества pair и int на отрезке массива от 1 до i. Тогда утверждается, что восстановить тип по данному массиву строк можно, причем однозначно  <  =  >  bali >  = 0 при 1 <  = i < n и baln =  - 1. Здесь возникает очевидная аналогия с правильными скобочными последовательностями.Докажем это утверждение по индукции по количеству int в данном массиве. База для n = 1 очевидна. Пусть у нас есть тип pair < type1, type2 > . Тогда baln = 1 +  balntype1+balntype2  =  - 1. Также можем получить, что bali >  = 0 для 1 <  = i < n.Пусть теперь у нас есть массив строк s, и в нем выполняется данное утверждение. Тогда первый элемент в нем — pair. Возьмем наименьшее i, что bali = 0 — оно существует по соображениям дискретной непрерывности (и не равно n, ибо baln =  - 1) — в этой позиции должен заканчиваться type1. Тогда на отрезке [2, i] (для него несложно проверить предположение индукции) можно расставить знаки препинания, чтобы получился тип. Аналогичное верно и для отрезка [i + 1, n]. Значит, и из всего отрезка [1, n] можно составить тип, причем тоже единственным образом.Теперь, если мы получили, что из данного массива строк можно составить тип, заведем функцию gettype(i), которая будет строить тип, начинающийся в si, и возвращать индекс, следующий после того, в котором она завершила построение. Как она будет работать? Пусть сейчас запущена gettype(i). Если si = pair, выведем int и вернем i + 1. Иначе выведем \"pair < \", запустим gettype(i + 1) — пусть он вернул нам j. Выведем \", \" и запустим gettype(j), он вернул нам k, выведем \" > \" и вернем k. Итого, запустив gettype(0), мы построим и выведем восстановленный тип.Можно обойтись без предварительной проверки, можно ли составить тип из данного массива. Для этого можно запустить функцию gettype и, если в ходе построения типа получаются противоречия, выводить \"Error occurred\".Асимптотическая сложность решения — O(количества данных строк).D — Несекретный шифрРешение riadwaw: Воспользуемся методом двух указателей. Будем поддерживать для каждого элемента, сколько раз он встречается на текущем отрезке [l, r]. При фиксированном l будем увеличивать r, если элемент a[r] встречается k раз, то этот отрезок и все отрезки вида [l, t], t > r нужно добавить в ответ и увеличить l. Чтобы поддерживать кол-во элементов нужно либо сжать координаты, либо воспользоваться структурой map. Также нужно не забыть, что ответ может достигать n * (n + 1) / 2, т.е не влазить в int.Решение Kostroma: для начала сожмем координаты, аналогично первому решению. Выпишем для каждого числа список позиций, в которых оно встречается в нашем массиве. Теперь создадим массив b, в bi будем хранить номер позиции, в которой стоит число ai, при этом на отрезке [i, bi] число ai встречается ровно k раз (если такой позиции нет, то bi = n + 1). Это несложно сделать одним проходом по нашим спискам. Найдем, сколько отрезков с началом в i удовлетворяют условию задачи — для этого из n нужно вычесть такое минимальное j, что на отрезке [i, j] есть k одинаковых чисел (если такого отрезка нет, то j будем считать равным n + 1). Но такое минимальное j есть . Такие минимумы для всех i можно найти, пройдя массив a один раз с конца. Осталось только просуммировать ответы для всех i от 1 до n.E — КонтратакаУ этой задачи много различных решений. Для начала, конечно же, сопоставим городам вершины графа, а дорогам — ребра. Теперь нам нужно найти все компоненты связности в дополнении данного графа.Решение Gerald: будем хранить set a вершин, которые еще не были посещены, и запустим серию обходов в глубину. Предварительно отсортируем списки смежности каждой вершины — теперь мы можем за O(logn) проверять, есть ли в данном графе произвольное ребро. Пусть мы сейчас находимся в вершине v. Пройдемся по всем элементам a, пусть мы сейчас рассматриваем вершину . Если ребра (v, u) нет в данном графе, то в его дополнении оно есть  =  >  выкинем из a вершину u и добавим ее в очередь. Иначе ничего с вершиной u не делаем. Сколько же раз с вершиной u будет повторена такая операция? Заметим, что вершина u остается в set-е только тогда, когда в данном графе есть ребро (u, v), то есть не больше раз, чем степень вершины u. Значит, асимпотика такого решения равна O(M * logn). Логарифм появляется из бинарного поиска. Это решение без каких бы то ни было оптимизаций тратит чуть больше 2 секунд. Если использовать хеш-таблицы, чтобы узнавать, есть ли в графе определенное ребро, получим асимптотику O(m).Решение Kostroma: Рассмотрим компоненты дополнения нашего графа. Рассмотрим такой набор компонент дополнения, что их суммарный размер не больше n / 2 и наиболее близок к n / 2 (если такого набора не существует, то в дополнении одна компонента) — пусть в них в сумме c вершин — назовем это множество A. Тогда все ребра между этими с вершинами и остальными n - c вершинами должны быть в данном графе, то есть c·(n - c) <  = m. Отсюда получаем, что . Если n2 <  = 4·m, то n <  = 2·103, тогда c <  = 103. Иначе при фиксированном m для роста оценки на c нужно уменьшать n — вплоть до того, пока не выполнится n2 = 4·m. Тогда . Значит, мы получили, что c <  = 103.Рассмотрим теперь любую другую компоненту, пусть в ней b вершин. Тогда c + b >  = n - c, так как c + b > n / 2 в силу выбора множества A, а значит, если c + b < n - c, то можно взять множество компонент, в которое входят все компоненты, кроме A и еще одной компоненты из b вершин — в нем n - c - b вершин, и c < n - c - b, n - c - b <  = n / 2. Значит, если в дополнении больше одной компоненты, то есть компонента размеров не меньше чем n - 2·c (назовем ее большой), значит, во всех остальных компонентах в сумме не больше чем 2·c вершин (причем в A ровно c вершин, значит во всех компонентах, кроме большой, не больше чем c вершин). Тогда не лежать в большой компоненте могут только вершины, степень которых в исходном графе как минимум n - c. Значит, все вершины со степенью  < n - c лежат в одной компоненте, а значит, все вершины со степенью  < n - 1000 тем более лежат в одной компоненте. Множество этих вершин назовем B. Построим новый граф из вершин, не принадлежащих множеству B и еще одной вершины: для каждой пары вершин не из B ребро будет проведено тогда и только тогда, когда в исходном графе его не было. Сопоставим множеству B вершину D, тогда ребра между D и произвольной вершиной v не будет тогда и только тогда, когда в исходном графе v соединена со всеми вершинами из B.Сколько же в новом графе будет вершин? Количество вершин, степень которых в данном графе как минимум n - 1000, и еще вершина D, то есть не больше чем  + 1 =  . Значит, ребер в графе будет O(m). Теперь запустим серию обходов в глубину или ширину на таком графе и найдем в нем компоненты связности. Теперь нетрудно восстановить компоненты связности дополнения: для этого нужно лишь вспомнить, какие вершины попали в множество B. Получаем решение за O(m), работающее чуть меньше секунды.Решение riadwaw:- Посчитаем степень каждой вершины в исходном графе, выберем вершину с минимальной степенью — назовем её V. O(m)- Заметим, что ее степень не больше средней степени вершин, т.е .- Заметим, что все вершины, кроме соединенных с V в исходном графе, будут лежать в дополнении в той же компоненте связности, что и V — назовем это множество вершин A.- Таким образом, можно явно построить дополнение графа, содержащего V и все вершины, соединенные с ней. Всего ребер там , так как m < n·n. Переберем все эти ребра, объединим с помощью СНМ соединенные вершины. Кроме того, объединим с компонентой, содержащей V, вершины, которые в исходном графе соединены не со всеми вершинами из A.В асимптотике могут вылезать лишние логарифмы из СНМ или сжатия координат. Общая асимптотика от O(m) до O(mlogn), решение работает около секунды.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4556",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 9370
        },
        {
          "title": "Codeforces Round #120 (Div. 2) - Codeforces",
          "content": "Пришло время для Валеры оказаться и нам (я и Kostroma) по ту сторону контеста.Мы являемся авторами сегодняшнего раунда и надеемся, что вы сможете понять условия он вам (а главное нам) понравится.В этот раз вы столкнетесь с очередной историей про частого героя местных задач — Васю.Как вы могли бы догадаться, этот раунд для участников из второго дивизиона, но мы думаем, что и div.1 найдет, что сегодня порешать.Спасибо за помощь в подготовке STAJIKER, HeroShadow, victor_kamashev, Abra, ifsmirnov, Aksenov239 и, конечно, Gerald, а также MikeMirzayanov за платформу CodeForces и Delinur за английскую версию условийУспехов!UPD2: Разбалловка стандартная, фиксированная, 500-1000-1500-2000-2500. Авторы думают, что задачи упорядочены по сложности.UPD3: Мы извиняемся, по нашей вине произошла ошибка, на несколько минут был случайно опубликован разбор задач. Тем, кто его видел, просьба не обсуждать задачи. В любом случае контест будет проводиться. Вопрос о рейтинговости раунда будет решен после контеста.UPD4: Выяснилось, что во время нахождения разбора в общем доступе только три человека из div2 просматривали пост с разбором (а всего восемь). Мы не будем называть никаких имен, но очень сильно просим не разглашать никакой информации про раунд и не пользоваться никакими материалами поста, если они у вас остались. Спасибо за понимание.UPD5: Пожалуйсте, не устраивайте панику, вы можете решать следующие задачи, пока ваше решение не тестируется.UPD6: Раунд объявляется нерейтинговым. Это связано с техническими причинами (тестирование не начинается более часа). В сумме с произошедшим инцидентом с разбором, это явлется веской причиной для подобного решения. Вы можете посылать свои решения в контест. Мы обязательно протестируем все попытки. Мы надеемся что технические проблемы не сильно испортят ваше впечатление от задач. Наши искренние извинения за эти недоработки.UPD7: Контест завершен. Опубликован разбор. Надеемся, что вам понравились подготовленные нами задачи. Думаю, мы еще вернемся. Еще раз мои извинения.P.S: К сожалению, я не знаю, когда протестируется решения.UPD8: Тестирование завершено.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4554",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2108
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #120 (Div. 2) - Codeforces - Code 1",
          "code": "<s>Зачёркнутый текст</s>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4554",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 1",
          "code": "set.clear()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 2",
          "code": "set = new HashSet<Integer> ();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 3",
          "code": "s=\"pair\", b=2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 4",
          "code": "s=\"pair int int\", b=0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 5",
          "code": "int pos = -1;\nvoid Go() {                        \n   if (t[++pos] == \"int\")\n      res.Append(\"int\");\n   else {\n      res.Append(\"pair<\");\n      Go();\n      res.Append(\",\");\n      Go();\n      res.Append(\">\");\n   }            \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 6",
          "code": "int pos = -1;\nvoid Go() {                        \n   if (t[++pos] == \"int\")\n      res.Append(\"int\");\n   else {\n      res.Append(\"pair<\");\n      Go();\n      res.Append(\",\");\n      Go();\n      res.Append(\">\");\n   }            \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 7",
          "code": "String s = \"\";\nfor (int i = 0; i < 100000; i++)\n    s += 'a';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 8",
          "code": "String s = \"\";\nfor (int i = 0; i < 100000; i++)\n    s += 'a';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 9",
          "code": "String s = \"\";\nfor (int i = 0; i < 100000; i++)\n    s = new StringBuilder(s).append('a').toString();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 10",
          "code": "String s = \"\";\nfor (int i = 0; i < 100000; i++)\n    s = new StringBuilder(s).append('a').toString();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 11",
          "code": "g[V].insert(g[V].begin(), -1);\ng[V].pb(n);//в начало -1, в конец - n, чтобы было удобно перебирать вершины\nfor (unsigned int i = 0; i < size(g[V]); i++)\n for (unsigned int j = g[V][i] + 1; j < g[V][i + 1]; j++)\n  union_set(V, j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 12",
          "code": "g[V].insert(g[V].begin(), -1);\ng[V].pb(n);//в начало -1, в конец - n, чтобы было удобно перебирать вершины\nfor (unsigned int i = 0; i < size(g[V]); i++)\n for (unsigned int j = g[V][i] + 1; j < g[V][i + 1]; j++)\n  union_set(V, j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 13",
          "code": "x *= 10; x += t - '0';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 14",
          "code": "HashSet<int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 15",
          "code": "HashSet<Int64>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 16",
          "code": "500000*u + v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 17",
          "code": "500000*v + u",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 18",
          "code": "O(m+n log^2 n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 19",
          "code": "O(m+n log n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div. 2) - Codeforces - Code 1",
          "code": "<s>Зачёркнутый текст</s>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4554",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(0, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\", -1); // default -1 indicating not provided\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    if (type == \"impossible\") {\n        n = 0;\n        if (m == -1) m = rnd.next(1, 100000);\n    } else if (type == \"min_n_m\") {\n        n = 0;\n        m = 0;\n    } else if (type == \"max_n_m\") {\n        n = 100000;\n        m = 100000;\n    } else if (type == \"m_greater_n\") {\n        if (n == -1) n = rnd.next(1, 99999);\n        if (m == -1) m = rnd.next(n+1, 100000);\n    } else if (type == \"m_less_n\") {\n        if (m == -1) m = rnd.next(0, 99999);\n        if (n == -1) n = rnd.next(m+1, 100000);\n    } else if (type == \"m_equals_n\") {\n        if (n == -1) n = rnd.next(0, 100000);\n        m = n;\n    } else if (type == \"random\") {\n        if (n == -1) n = rnd.next(0, 100000);\n        if (m == -1) m = rnd.next(0, 100000);\n    } else {\n        // type unknown, error\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\", -1); // default -1 indicating not provided\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    if (type == \"impossible\") {\n        n = 0;\n        if (m == -1) m = rnd.next(1, 100000);\n    } else if (type == \"min_n_m\") {\n        n = 0;\n        m = 0;\n    } else if (type == \"max_n_m\") {\n        n = 100000;\n        m = 100000;\n    } else if (type == \"m_greater_n\") {\n        if (n == -1) n = rnd.next(1, 99999);\n        if (m == -1) m = rnd.next(n+1, 100000);\n    } else if (type == \"m_less_n\") {\n        if (m == -1) m = rnd.next(0, 99999);\n        if (n == -1) n = rnd.next(m+1, 100000);\n    } else if (type == \"m_equals_n\") {\n        if (n == -1) n = rnd.next(0, 100000);\n        m = n;\n    } else if (type == \"random\") {\n        if (n == -1) n = rnd.next(0, 100000);\n        if (m == -1) m = rnd.next(0, 100000);\n    } else {\n        // type unknown, error\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type impossible\n\n./gen -type min_n_m\n\n./gen -type max_n_m\n\n./gen -type m_equals_n\n\n./gen -type m_less_n\n\n./gen -type m_greater_n\n\n./gen -type random\n\n./gen -n 0 -m 0 -type min_n_m\n\n./gen -n 0 -m 1000 -type impossible\n\n./gen -n 100000 -m 100000 -type max_n_m\n\n./gen -n 1 -m 0 -type random\n\n./gen -n 0 -m 0 -type random\n\n./gen -n 0 -m 100000 -type impossible\n\n./gen -n 1 -m 100000 -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -n 0 -m 0 -type random\n\n./gen -n 100000 -m 99999 -type m_less_n\n\n./gen -n 99999 -m 100000 -type m_greater_n\n\n./gen -n 100000 -m 0 -type random\n\n./gen -n 100000 -m 0 -type m_equals_n\n\n./gen -n 100000 -m 100000 -type m_equals_n\n\n./gen -n 50000 -m 50000 -type m_equals_n\n\n# Random cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Edge cases\n./gen -n 0 -m 1 -type impossible\n\n./gen -n 1 -m 1 -type random\n\n./gen -n 1 -m 2 -type m_greater_n\n\n./gen -n 100000 -m 1 -type m_less_n\n\n./gen -n 1 -m 100000 -type m_greater_n\n\n./gen -n 50000 -m 50000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:02.665296",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "190/B",
      "title": "B. Surrounded",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input files consist of two lines. Each line represents the city and the flatland ring that surrounds it as three space-separated integers xi, yi, ri (|xi|, |yi| ≤ 104; 1 ≤ ri ≤ 104) — the city's coordinates and the distance from the city to the flatlanders, correspondingly.It is guaranteed that the cities are located at different points.",
      "output_spec": "OutputPrint a single real number — the minimum detection radius of the described radar. The answer is considered correct if the absolute or relative error does not exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy0 0 16 0 3OutputCopy1.000000000000000InputCopy-10 10 310 -10 3OutputCopy11.142135623730951",
      "description": "B. Surrounded\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input files consist of two lines. Each line represents the city and the flatland ring that surrounds it as three space-separated integers xi, yi, ri (|xi|, |yi| ≤ 104; 1 ≤ ri ≤ 104) — the city's coordinates and the distance from the city to the flatlanders, correspondingly.It is guaranteed that the cities are located at different points.\n\nOutputPrint a single real number — the minimum detection radius of the described radar. The answer is considered correct if the absolute or relative error does not exceed 10 - 6.\n\nInputCopy0 0 16 0 3OutputCopy1.000000000000000InputCopy-10 10 310 -10 3OutputCopy11.142135623730951\n\nInputCopy0 0 16 0 3\n\nOutputCopy1.000000000000000\n\nInputCopy-10 10 310 -10 3\n\nOutputCopy11.142135623730951\n\nNoteThe figure below shows the answer to the first sample. In this sample the best decision is to put the radar at point with coordinates (2, 0).   The figure below shows the answer for the second sample. In this sample the best decision is to put the radar at point with coordinates (0, 0).",
      "solutions": [
        {
          "title": "Codeforces Round #120 (Div. 2) - Codeforces",
          "content": "Kostroma and I are problemsetters of Codeforces Round #120. It's first our contest and we hope you (and we too) will like it.It's round for second division, but we think that everyone will find interesting problem for him.Thanks for the help STAJIKER, HeroShadow, victor_kamashev, Abra, ifsmirnov, Aksenov239 and Gerald.Thanks MikeMirzayanov for CodeForces platform and Delinur for English statements. Good luck!UPD: As usual, problems will cost 500-1000-1500-2000-2500 points.UPD2: Problems are sorted according to expected difficulty.UPD3: There was our mistake. The editorial was available for few minutes. If you see it, please not discuss problems and solutions. Now it is hided. In any case the round will be held. Decision, will contest rated or not will be made after contest. We are sorry for that.UPD4: It's now known that only three participants from Div.2 have seen page with editorial while it was published (and 8 people in total). We'll not say any names, but we ask this people to not say anybody anything about the problem and to not use any post materials, if you have them. Thanks in advance.UPD5: Please, don't panic. While your solution is in queue, you may solve other problems.UPD6: Due to technical issues round is considered unrated. This problem and incident with editorial are strong enough reason for this decision. You may send your solutions to contest. They will be judged. We hope, that these technical problems will not spoil your impression about this round. Our sincere apologies. UPD7: Contest is over. Editorial is published. We hope, you like problems, prepared by us. We apologize again.P.S: Excuse me, I don't know, when solution will be judged.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4554",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1685
        },
        {
          "title": "Codeforces Round #120 (Div.2) — editorial - Codeforces",
          "content": "A — Vasya and the BusFirstly, if n = 0, then children can't be in the bus, so if m = 0 then the answer is (0, 0), otherwise the answer is \"Impossible\". Now n > 0. If m =  = 0, than it is only one possible variant of passage — the answer is (n, n). Otherwise, more grown-up take some children, less the sum that people pay. So, if only one adult takes all children, than we get maximal sum — n + m - 1. Maximum min(n, m) adults can take the children with them, so the minimal answer is n + m - min(n, m) = max(n, m).B — SurroundedLet's find the minimum distance between two circles L. Then the answer to our problem is L / 2.Now d is the distance between the centers of the circles, R, r — their radiuses. There are 3 possible cases:- Circles don't intersect. Then L = d - R - r. Firstly, it's reachable: let's consider the segment, connecting the centers of the circles, and take its part, which is out of both circles — its length is exactly d - R - r. Let's prove that lesser distance is impossible. If the segment connecting two points of distinct circles have length l, than R + l + r >  = d, so l >  = d - R - r. - If one circle is into another, than analogically the answer is R - d - r, where R is the radius of the bigger circle.- If the circles intersect, then the answer is 0.C — STLIn this problem we have an array of strings (s1, s2, ...sn), where si  = pair or int.Let's consider bali = the difference between number of \"pair\" and \"int\" int the subarray (s1, s2, ...si).Than we can prove that the type can be reestablished from the array s  <  =  >  bali >  = 0 for 1 <  = i < n and baln =  - 1. This can be proved using mathematical induction, the parameter is the number of \"int\"-s in the array.And how to find the solution, if we know that is exists? Consider the function gettype(inti), which builds the type beginning in the position i and returns the index, next to the position where it finished building of type. How it works? If si =  \"int\", then the function prints \"int\" and returns i + 1. Else it prints \"pair < \", gettype(i + 1) is launched, let it returns j. Then we print \", \" and launch gettype(j) (it returns k), then we print \" > \" and return k.We can not to do check if the type can be reestablished from the array in the beginning: launch gettype() and print \"Error occurred\" if there became some contradiction during the building of type. D — Non-secret CypherFirst solution: Let's use the method of two pointers. For every number we will know how many times it occurs in the current segment [l, r]. For fixed l we increase r until a[r] occurs in the current segment less than k times. If a[r] occurs int the segment [l, r] k times, we add to the answer all segments [l, t] for all t >  = r and increase l (and do not forget to decrease the number of a[l] in the current segment).To keep the number of every value in the segment we can use map or compression of the coordinates. Also it's important not to forget that the maximal answer is , which doesn't fit in int.Second solution: firstly, let's do the compression of the coordinates. For every value X we write the list of the positions i such that a[i] = X. Now using that we fill the array b: b[i] is the minimum index that segment [i, b[i]] contains k numbers equal to a[i] (obviosly, a[b[i]] = a[i]), if this index doesn't exist, then b[i] = n + 1.Let's find for every index i a minimal index j such that segment [i, j] contsins k equal numbers (if such j doesn't exist, we say that j = n + 1) — then we add to the answer n + 1 - j. This j is equal to . All that minimums can be found in a single pass through a from its end. Then we can sum the answers for all indexes 1 <  = i <  = n.The complexity of these solutions is O(nlogn).E — Counter AttackThis problem has several different solutions. Anyway, we should consider towns as the vertices of the graph, roads as its edges. Now we are to find the connected components of the complementary graph (CG) of the given graph. Let's take the vertex A with the minimal degree c: . We call the set of the vertices who are connected with A — B, that are not connected — D . All vertices which don't connect with A will be in the same connected component of the CG. Let's build the complemented graph to the subgraph including A and set B — there are vertices and  =   =  O(m) edges.Let's build DSU for the vertices of given graph and merge components which we have found using the new-built graph. All that we should do after it is to consider vertices from B: now we look to the vertex v. We put v in the same component as A if v has edges not to all vertices of D (we do it using DSU too). The complexity of this solution is O(m) or O(mlogn).Another solution: we keep set a, which contains vertices, which haven't been visited yet. Let's run series of bfs to find the components of CG. If we are working now with the vertex v, pass through a. Consider u is the element of a. If edge (u, v) isn't in the given graph, than u is in the same component of CG as v, so, we can erase it from a and add to queue. Otherwise, we do nothing.What is the complexity of this solution? To understand that, we must know how many times whe consider fixed vertex u in the set a. u remains int a when we run to them from vertex v  <  =  >  edge (u, v) is in the given graph. So, every vertex u remains in a no more than its degree. So, the complexity of this algorithm is O(mlogn) (log n because of binsearch — we need use it to know, is (u, v) in the graph). If we use HashMap, we'll get O(m).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4556",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5514
        },
        {
          "title": "Codeforces Round #120 (Div. 2) - Codeforces",
          "content": "Kostroma and I are problemsetters of Codeforces Round #120. It's first our contest and we hope you (and we too) will like it.It's round for second division, but we think that everyone will find interesting problem for him.Thanks for the help STAJIKER, HeroShadow, victor_kamashev, Abra, ifsmirnov, Aksenov239 and Gerald.Thanks MikeMirzayanov for CodeForces platform and Delinur for English statements. Good luck!UPD: As usual, problems will cost 500-1000-1500-2000-2500 points.UPD2: Problems are sorted according to expected difficulty.UPD3: There was our mistake. The editorial was available for few minutes. If you see it, please not discuss problems and solutions. Now it is hided. In any case the round will be held. Decision, will contest rated or not will be made after contest. We are sorry for that.UPD4: It's now known that only three participants from Div.2 have seen page with editorial while it was published (and 8 people in total). We'll not say any names, but we ask this people to not say anybody anything about the problem and to not use any post materials, if you have them. Thanks in advance.UPD5: Please, don't panic. While your solution is in queue, you may solve other problems.UPD6: Due to technical issues round is considered unrated. This problem and incident with editorial are strong enough reason for this decision. You may send your solutions to contest. They will be judged. We hope, that these technical problems will not spoil your impression about this round. Our sincere apologies. UPD7: Contest is over. Editorial is published. We hope, you like problems, prepared by us. We apologize again.P.S: Excuse me, I don't know, when solution will be judged.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4554",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1685
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #120 (Div.2) — editorial - Codeforces - Code 1",
          "code": "O(m+n log^2 n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — editorial - Codeforces - Code 2",
          "code": "O(m+n log n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x1 = inf.readInt(-10000, 10000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-10000, 10000, \"y1\");\n    inf.readSpace();\n    int r1 = inf.readInt(1, 10000, \"r1\");\n    inf.readEoln();\n\n    int x2 = inf.readInt(-10000, 10000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-10000, 10000, \"y2\");\n    inf.readSpace();\n    int r2 = inf.readInt(1, 10000, \"r2\");\n    inf.readEoln();\n\n    ensuref(x1 != x2 || y1 != y2, \"The cities are at the same coordinates (%d, %d)\", x1, y1);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x1 = inf.readInt(-10000, 10000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-10000, 10000, \"y1\");\n    inf.readSpace();\n    int r1 = inf.readInt(1, 10000, \"r1\");\n    inf.readEoln();\n\n    int x2 = inf.readInt(-10000, 10000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-10000, 10000, \"y2\");\n    inf.readSpace();\n    int r2 = inf.readInt(1, 10000, \"r2\");\n    inf.readEoln();\n\n    ensuref(x1 != x2 || y1 != y2, \"The cities are at the same coordinates (%d, %d)\", x1, y1);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x1 = inf.readInt(-10000, 10000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-10000, 10000, \"y1\");\n    inf.readSpace();\n    int r1 = inf.readInt(1, 10000, \"r1\");\n    inf.readEoln();\n\n    int x2 = inf.readInt(-10000, 10000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-10000, 10000, \"y2\");\n    inf.readSpace();\n    int r2 = inf.readInt(1, 10000, \"r2\");\n    inf.readEoln();\n\n    ensuref(x1 != x2 || y1 != y2, \"The cities are at the same coordinates (%d, %d)\", x1, y1);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst double PI = acos(-1.0);\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int max_coordinate = opt<int>(\"max_coordinate\",10000);\n    int max_radius = opt<int>(\"max_radius\",10000);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Variables to store the outputs\n    int x1, y1, r1, x2, y2, r2;\n\n    if (type == \"random\") {\n        x1 = rnd.next(-max_coordinate, max_coordinate);\n        y1 = rnd.next(-max_coordinate, max_coordinate);\n        do {\n            x2 = rnd.next(-max_coordinate, max_coordinate);\n            y2 = rnd.next(-max_coordinate, max_coordinate);\n        } while (x2 == x1 && y2 == y1); // Ensure cities are at different points\n\n        r1 = rnd.next(1, max_radius);\n        r2 = rnd.next(1, max_radius);\n\n    } else if (type == \"touching\") {\n        // Rings touch externally\n        r1 = rnd.next(1, max_radius);\n        r2 = rnd.next(1, max_radius);\n\n        // Set city 1 at (0,0)\n        x1 = 0;\n        y1 = 0;\n\n        // City 2 at distance d = r1 + r2\n        int d = r1 + r2;\n        // Select random angle\n        double angle = rnd.next(0.0, 2 * PI);\n        x2 = x1 + int(d * cos(angle));\n        y2 = y1 + int(d * sin(angle));\n\n        // Ensure cities are within coordinates bounds\n        int max_abs_coord = max_coordinate;\n        if(abs(x2) > max_abs_coord || abs(y2) > max_abs_coord) {\n            // Scale down coordinates proportionally\n            double scale = (double)max_abs_coord / max(abs(x2), abs(y2));\n            x2 = x1 + int(d * cos(angle) * scale);\n            y2 = y1 + int(d * sin(angle) * scale);\n        }\n\n    } else if (type == \"overlapping\") {\n        // Rings overlap\n\n        r1 = rnd.next(1, max_radius);\n        r2 = rnd.next(1, max_radius);\n\n        // Set city 1 at (0,0)\n        x1 = 0;\n        y1 = 0;\n\n        // Distance between centers d < r1 + r2\n        int sum_radii = r1 + r2;\n        int d = rnd.next(1, sum_radii - 1);\n\n        // Random angle\n        double angle = rnd.next(0.0, 2 * PI);\n        x2 = x1 + int(d * cos(angle));\n        y2 = y1 + int(d * sin(angle));\n\n        // Ensure cities are within coordinates bounds\n        int max_abs_coord = max_coordinate;\n        if(abs(x2) > max_abs_coord || abs(y2) > max_abs_coord) {\n            // Scale down coordinates proportionally\n            double scale = (double)max_abs_coord / max(abs(x2), abs(y2));\n            x2 = x1 + int(d * cos(angle) * scale);\n            y2 = y1 + int(d * sin(angle) * scale);\n        }\n\n    } else if (type == \"non-overlapping\") {\n        // Rings do not touch or overlap\n\n        r1 = rnd.next(1, max_radius);\n        r2 = rnd.next(1, max_radius);\n\n        // Set city 1 at (0,0)\n        x1 = 0;\n        y1 = 0;\n\n        // Distance between centers d > r1 + r2\n        int sum_radii = r1 + r2;\n        int d = sum_radii + rnd.next(1, max_coordinate);\n\n        // Random angle\n        double angle = rnd.next(0.0, 2 * PI);\n        x2 = x1 + int(d * cos(angle));\n        y2 = y1 + int(d * sin(angle));\n\n        // Ensure cities are within coordinates bounds\n        int max_abs_coord = max_coordinate;\n        if(abs(x2) > max_abs_coord || abs(y2) > max_abs_coord) {\n            // Scale down coordinates\n            double scale = (double)max_abs_coord / max(abs(x2), abs(y2));\n            x2 = x1 + int(d * cos(angle) * scale);\n            y2 = y1 + int(d * sin(angle) * scale);\n        }\n\n    } else if (type == \"enclosed\") {\n        // One ring entirely within the other\n\n        // Choose r1 > r2\n        r1 = rnd.next(max_radius / 2, max_radius);\n        r2 = rnd.next(1, r1 - 1);\n\n        // Distance between centers d < r1 - r2\n\n        int delta = rnd.next(1, r1 - r2 - 1);\n        int d = r1 - r2 - delta;\n\n        // Random angle\n        double angle = rnd.next(0.0, 2 * PI);\n        x1 = 0;\n        y1 = 0;\n        x2 = x1 + int(d * cos(angle));\n        y2 = y1 + int(d * sin(angle));\n\n        // Ensure cities are within coordinates bounds\n        int max_abs_coord = max_coordinate;\n        if(abs(x2) > max_abs_coord || abs(y2) > max_abs_coord) {\n            // Scale down coordinates\n            double scale = (double)max_abs_coord / max(abs(x2), abs(y2));\n            x2 = x1 + int(d * cos(angle) * scale);\n            y2 = y1 + int(d * sin(angle) * scale);\n        }\n\n    } else if (type == \"same_radius\") {\n        r1 = r2 = rnd.next(1, max_radius);\n\n        x1 = rnd.next(-max_coordinate, max_coordinate);\n        y1 = rnd.next(-max_coordinate, max_coordinate);\n\n        do {\n            x2 = rnd.next(-max_coordinate, max_coordinate);\n            y2 = rnd.next(-max_coordinate, max_coordinate);\n        } while (x2 == x1 && y2 == y1);\n\n    } else if (type == \"max_coordinates\") {\n        x1 = max_coordinate;\n        y1 = max_coordinate;\n\n        x2 = -max_coordinate;\n        y2 = -max_coordinate;\n\n        r1 = rnd.next(1, max_radius);\n        r2 = rnd.next(1, max_radius);\n\n    } else if (type == \"min_coordinates\") {\n        x1 = y1 = 0;\n        x2 = y2 = 1; // Ensure different points\n        r1 = rnd.next(1, max_radius);\n        r2 = rnd.next(1, max_radius);\n\n    } else if (type == \"negative_coordinates\") {\n        x1 = rnd.next(-max_coordinate, 0);\n        y1 = rnd.next(-max_coordinate, 0);\n\n        do {\n            x2 = rnd.next(-max_coordinate, 0);\n            y2 = rnd.next(-max_coordinate, 0);\n        } while (x2 == x1 && y2 == y1);\n\n        r1 = rnd.next(1, max_radius);\n        r2 = rnd.next(1, max_radius);\n\n    } else if (type == \"edge_case_1\") {\n        // Edge case where minimal radius is zero\n        // Rings touch at a point\n        r1 = rnd.next(1, max_radius);\n        r2 = rnd.next(1, max_radius);\n\n        // Place cities such that the rings touch at a point\n        int d = r1 + r2;\n        x1 = 0;\n        y1 = 0;\n        x2 = d;\n        y2 = 0;\n\n    } else {\n        // Default to random\n        x1 = rnd.next(-max_coordinate, max_coordinate);\n        y1 = rnd.next(-max_coordinate, max_coordinate);\n        do {\n            x2 = rnd.next(-max_coordinate, max_coordinate);\n            y2 = rnd.next(-max_coordinate, max_coordinate);\n        } while (x2 == x1 && y2 == y1); // Ensure cities are at different points\n\n        r1 = rnd.next(1, max_radius);\n        r2 = rnd.next(1, max_radius);\n    }\n\n    // Now, print the result\n\n    printf(\"%d %d %d\\n\", x1, y1, r1);\n    printf(\"%d %d %d\\n\", x2, y2, r2);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst double PI = acos(-1.0);\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int max_coordinate = opt<int>(\"max_coordinate\",10000);\n    int max_radius = opt<int>(\"max_radius\",10000);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Variables to store the outputs\n    int x1, y1, r1, x2, y2, r2;\n\n    if (type == \"random\") {\n        x1 = rnd.next(-max_coordinate, max_coordinate);\n        y1 = rnd.next(-max_coordinate, max_coordinate);\n        do {\n            x2 = rnd.next(-max_coordinate, max_coordinate);\n            y2 = rnd.next(-max_coordinate, max_coordinate);\n        } while (x2 == x1 && y2 == y1); // Ensure cities are at different points\n\n        r1 = rnd.next(1, max_radius);\n        r2 = rnd.next(1, max_radius);\n\n    } else if (type == \"touching\") {\n        // Rings touch externally\n        r1 = rnd.next(1, max_radius);\n        r2 = rnd.next(1, max_radius);\n\n        // Set city 1 at (0,0)\n        x1 = 0;\n        y1 = 0;\n\n        // City 2 at distance d = r1 + r2\n        int d = r1 + r2;\n        // Select random angle\n        double angle = rnd.next(0.0, 2 * PI);\n        x2 = x1 + int(d * cos(angle));\n        y2 = y1 + int(d * sin(angle));\n\n        // Ensure cities are within coordinates bounds\n        int max_abs_coord = max_coordinate;\n        if(abs(x2) > max_abs_coord || abs(y2) > max_abs_coord) {\n            // Scale down coordinates proportionally\n            double scale = (double)max_abs_coord / max(abs(x2), abs(y2));\n            x2 = x1 + int(d * cos(angle) * scale);\n            y2 = y1 + int(d * sin(angle) * scale);\n        }\n\n    } else if (type == \"overlapping\") {\n        // Rings overlap\n\n        r1 = rnd.next(1, max_radius);\n        r2 = rnd.next(1, max_radius);\n\n        // Set city 1 at (0,0)\n        x1 = 0;\n        y1 = 0;\n\n        // Distance between centers d < r1 + r2\n        int sum_radii = r1 + r2;\n        int d = rnd.next(1, sum_radii - 1);\n\n        // Random angle\n        double angle = rnd.next(0.0, 2 * PI);\n        x2 = x1 + int(d * cos(angle));\n        y2 = y1 + int(d * sin(angle));\n\n        // Ensure cities are within coordinates bounds\n        int max_abs_coord = max_coordinate;\n        if(abs(x2) > max_abs_coord || abs(y2) > max_abs_coord) {\n            // Scale down coordinates proportionally\n            double scale = (double)max_abs_coord / max(abs(x2), abs(y2));\n            x2 = x1 + int(d * cos(angle) * scale);\n            y2 = y1 + int(d * sin(angle) * scale);\n        }\n\n    } else if (type == \"non-overlapping\") {\n        // Rings do not touch or overlap\n\n        r1 = rnd.next(1, max_radius);\n        r2 = rnd.next(1, max_radius);\n\n        // Set city 1 at (0,0)\n        x1 = 0;\n        y1 = 0;\n\n        // Distance between centers d > r1 + r2\n        int sum_radii = r1 + r2;\n        int d = sum_radii + rnd.next(1, max_coordinate);\n\n        // Random angle\n        double angle = rnd.next(0.0, 2 * PI);\n        x2 = x1 + int(d * cos(angle));\n        y2 = y1 + int(d * sin(angle));\n\n        // Ensure cities are within coordinates bounds\n        int max_abs_coord = max_coordinate;\n        if(abs(x2) > max_abs_coord || abs(y2) > max_abs_coord) {\n            // Scale down coordinates\n            double scale = (double)max_abs_coord / max(abs(x2), abs(y2));\n            x2 = x1 + int(d * cos(angle) * scale);\n            y2 = y1 + int(d * sin(angle) * scale);\n        }\n\n    } else if (type == \"enclosed\") {\n        // One ring entirely within the other\n\n        // Choose r1 > r2\n        r1 = rnd.next(max_radius / 2, max_radius);\n        r2 = rnd.next(1, r1 - 1);\n\n        // Distance between centers d < r1 - r2\n\n        int delta = rnd.next(1, r1 - r2 - 1);\n        int d = r1 - r2 - delta;\n\n        // Random angle\n        double angle = rnd.next(0.0, 2 * PI);\n        x1 = 0;\n        y1 = 0;\n        x2 = x1 + int(d * cos(angle));\n        y2 = y1 + int(d * sin(angle));\n\n        // Ensure cities are within coordinates bounds\n        int max_abs_coord = max_coordinate;\n        if(abs(x2) > max_abs_coord || abs(y2) > max_abs_coord) {\n            // Scale down coordinates\n            double scale = (double)max_abs_coord / max(abs(x2), abs(y2));\n            x2 = x1 + int(d * cos(angle) * scale);\n            y2 = y1 + int(d * sin(angle) * scale);\n        }\n\n    } else if (type == \"same_radius\") {\n        r1 = r2 = rnd.next(1, max_radius);\n\n        x1 = rnd.next(-max_coordinate, max_coordinate);\n        y1 = rnd.next(-max_coordinate, max_coordinate);\n\n        do {\n            x2 = rnd.next(-max_coordinate, max_coordinate);\n            y2 = rnd.next(-max_coordinate, max_coordinate);\n        } while (x2 == x1 && y2 == y1);\n\n    } else if (type == \"max_coordinates\") {\n        x1 = max_coordinate;\n        y1 = max_coordinate;\n\n        x2 = -max_coordinate;\n        y2 = -max_coordinate;\n\n        r1 = rnd.next(1, max_radius);\n        r2 = rnd.next(1, max_radius);\n\n    } else if (type == \"min_coordinates\") {\n        x1 = y1 = 0;\n        x2 = y2 = 1; // Ensure different points\n        r1 = rnd.next(1, max_radius);\n        r2 = rnd.next(1, max_radius);\n\n    } else if (type == \"negative_coordinates\") {\n        x1 = rnd.next(-max_coordinate, 0);\n        y1 = rnd.next(-max_coordinate, 0);\n\n        do {\n            x2 = rnd.next(-max_coordinate, 0);\n            y2 = rnd.next(-max_coordinate, 0);\n        } while (x2 == x1 && y2 == y1);\n\n        r1 = rnd.next(1, max_radius);\n        r2 = rnd.next(1, max_radius);\n\n    } else if (type == \"edge_case_1\") {\n        // Edge case where minimal radius is zero\n        // Rings touch at a point\n        r1 = rnd.next(1, max_radius);\n        r2 = rnd.next(1, max_radius);\n\n        // Place cities such that the rings touch at a point\n        int d = r1 + r2;\n        x1 = 0;\n        y1 = 0;\n        x2 = d;\n        y2 = 0;\n\n    } else {\n        // Default to random\n        x1 = rnd.next(-max_coordinate, max_coordinate);\n        y1 = rnd.next(-max_coordinate, max_coordinate);\n        do {\n            x2 = rnd.next(-max_coordinate, max_coordinate);\n            y2 = rnd.next(-max_coordinate, max_coordinate);\n        } while (x2 == x1 && y2 == y1); // Ensure cities are at different points\n\n        r1 = rnd.next(1, max_radius);\n        r2 = rnd.next(1, max_radius);\n    }\n\n    // Now, print the result\n\n    printf(\"%d %d %d\\n\", x1, y1, r1);\n    printf(\"%d %d %d\\n\", x2, y2, r2);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random -max_coordinate 10000 -max_radius 10000\n./gen -type random -max_coordinate 1000 -max_radius 1000\n./gen -type random -max_coordinate 100 -max_radius 100\n./gen -type random -max_coordinate 10 -max_radius 10\n./gen -type random -max_coordinate 1 -max_radius 1\n\n./gen -type touching\n./gen -type touching -max_radius 10000\n./gen -type touching -max_coordinate 5000\n\n./gen -type overlapping\n./gen -type overlapping -max_radius 10000\n./gen -type overlapping -max_coordinate 5000\n\n./gen -type non-overlapping\n./gen -type non-overlapping -max_radius 10000\n./gen -type non-overlapping -max_coordinate 5000\n\n./gen -type enclosed\n./gen -type enclosed -max_radius 10000\n./gen -type enclosed -max_coordinate 5000\n\n./gen -type same_radius\n./gen -type same_radius -max_radius 10000\n./gen -type same_radius -max_coordinate 5000\n\n./gen -type max_coordinates\n./gen -type max_coordinates -max_coordinate 10000\n./gen -type min_coordinates\n\n./gen -type negative_coordinates\n./gen -type negative_coordinates -max_coordinate 5000\n\n./gen -type edge_case_1\n\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type random -max_coordinate 5000 -max_radius 5000\n./gen -type random -max_coordinate 9999 -max_radius 9999\n\n./gen -type random -max_radius 1\n./gen -type random -max_radius 10\n./gen -type random -max_radius 100\n./gen -type random -max_radius 1000\n./gen -type random -max_radius 10000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:04.841270",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "190/C",
      "title": "C. STL",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записано единственное целое число n (1 ≤ n ≤ 105) — количество чисел, которое хранит тип продиктованный Геной.Во второй строке через пробел записаны слова, сказанные Геной. Каждое из них — «pair» или «int» (без кавычек).Гарантируется, что общее количество слов не превосходит 105 и что среди произнесенных слов будет ровно n слов «int».",
      "output_spec": "Выходные данныеЕсли можно расставить знаки препинания так, чтобы получился корректный тип языка X--, выведите единственную строку обозначающую полученный тип. Иначе выведите «Error occurred» (без кавычек). Запись типа не должна содержать внутри себя лишних пробелов и других символов. Гарантируется, что если такой тип существует, то он единственен.Обратите внимание, что нужно вывести тип, произнесенный Геной (если такой существует), а не любой, в котором помещается n значений.",
      "sample_tests": "ПримерыВходные данныеСкопировать3pair pair int int intВыходные данныеСкопироватьpair<pair<int,int>,int>Входные данныеСкопировать1pair intВыходные данныеСкопироватьError occurred",
      "description": "ограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано единственное целое число n (1 ≤ n ≤ 105) — количество чисел, которое хранит тип продиктованный Геной.Во второй строке через пробел записаны слова, сказанные Геной. Каждое из них — «pair» или «int» (без кавычек).Гарантируется, что общее количество слов не превосходит 105 и что среди произнесенных слов будет ровно n слов «int».\n\nВходные данные\n\nВыходные данныеЕсли можно расставить знаки препинания так, чтобы получился корректный тип языка X--, выведите единственную строку обозначающую полученный тип. Иначе выведите «Error occurred» (без кавычек). Запись типа не должна содержать внутри себя лишних пробелов и других символов. Гарантируется, что если такой тип существует, то он единственен.Обратите внимание, что нужно вывести тип, произнесенный Геной (если такой существует), а не любой, в котором помещается n значений.\n\nВыходные данные\n\nВходные данныеСкопировать3pair pair int int intВыходные данныеСкопироватьpair<pair<int,int>,int>Входные данныеСкопировать1pair intВыходные данныеСкопироватьError occurred\n\nВходные данныеСкопировать3pair pair int int int\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьpair<pair<int,int>,int>\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1pair int\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьError occurred\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #120 (Div. 2) - Codeforces",
          "content": "Пришло время для Валеры оказаться и нам (я и Kostroma) по ту сторону контеста.Мы являемся авторами сегодняшнего раунда и надеемся, что вы сможете понять условия он вам (а главное нам) понравится.В этот раз вы столкнетесь с очередной историей про частого героя местных задач — Васю.Как вы могли бы догадаться, этот раунд для участников из второго дивизиона, но мы думаем, что и div.1 найдет, что сегодня порешать.Спасибо за помощь в подготовке STAJIKER, HeroShadow, victor_kamashev, Abra, ifsmirnov, Aksenov239 и, конечно, Gerald, а также MikeMirzayanov за платформу CodeForces и Delinur за английскую версию условийУспехов!UPD2: Разбалловка стандартная, фиксированная, 500-1000-1500-2000-2500. Авторы думают, что задачи упорядочены по сложности.UPD3: Мы извиняемся, по нашей вине произошла ошибка, на несколько минут был случайно опубликован разбор задач. Тем, кто его видел, просьба не обсуждать задачи. В любом случае контест будет проводиться. Вопрос о рейтинговости раунда будет решен после контеста.UPD4: Выяснилось, что во время нахождения разбора в общем доступе только три человека из div2 просматривали пост с разбором (а всего восемь). Мы не будем называть никаких имен, но очень сильно просим не разглашать никакой информации про раунд и не пользоваться никакими материалами поста, если они у вас остались. Спасибо за понимание.UPD5: Пожалуйсте, не устраивайте панику, вы можете решать следующие задачи, пока ваше решение не тестируется.UPD6: Раунд объявляется нерейтинговым. Это связано с техническими причинами (тестирование не начинается более часа). В сумме с произошедшим инцидентом с разбором, это явлется веской причиной для подобного решения. Вы можете посылать свои решения в контест. Мы обязательно протестируем все попытки. Мы надеемся что технические проблемы не сильно испортят ваше впечатление от задач. Наши искренние извинения за эти недоработки.UPD7: Контест завершен. Опубликован разбор. Надеемся, что вам понравились подготовленные нами задачи. Думаю, мы еще вернемся. Еще раз мои извинения.P.S: К сожалению, я не знаю, когда протестируется решения.UPD8: Тестирование завершено.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4554",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2108
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces",
          "content": "Прежде чем опубликовать разбор задач сегодняшнего раунда, приношу извинения администрации и участникам за свою глупую ошибку, допущенную по криворукости и неопытности.Несмотря на то что раунд откровенно не удался, мы, авторы, рады, что многим участникам задачи понравились. Вот, собственно, решения:A — Вася и автобусыВо-первых, если n = 0, то ни одного ребенка по условию нельзя провезти. Значит, если при этом m = 0, от ответ (0, 0), иначе ответ Impossible.Теперь n > 0. Если m = 0, то ответ, очевидно, (n, n). Иначе, чем больше родителей везет с собой по ребенку, тем меньше плата за проезд. Поэтому максимальная плата будет тогда, когда всех детей везет один родитель — получаем ответ n + m - 1. Если n <  = m, то все n родителей везут детей, и ровно n детей не платят за проезд. Если же n > m, то все m детей распределяются по родителям и не платят за проезд. В обоих случаях получаем минимальный ответ max(n, m).B — ОкружениеНайдем минимальное расстояние между окружностями L. Тогда ответ к задаче равен L / 2.- Пусть окружности лежат вне друг друга. Покажем, что L = d - R - r. Во-первых, ясно, что он достигается. Проведем отрезок соединяющий центры. Его часть, лежащая между точками пересечения с окружностями как раз имеет такую длину. Докажем, что меньшее расстояние недостижимо, построим отрезок между двумя окружностями. Тогда R + r + L >  = d, откуда L >  = d - R - r, чтд. Для окружностей, лежащих внутри друг друга аналогичными рассуждениями получаем L = R - d - r, где R — радиус наружной окружности, r — внутренней. Для пересекающихся окружностей ответ 0. C — STLПусть нам дан массив строк (s1, s2, ...sn), где si  = pair либо int.Рассмотрим числа bali = разность количества pair и int на отрезке массива от 1 до i. Тогда утверждается, что восстановить тип по данному массиву строк можно, причем однозначно  <  =  >  bali >  = 0 при 1 <  = i < n и baln =  - 1. Здесь возникает очевидная аналогия с правильными скобочными последовательностями.Докажем это утверждение по индукции по количеству int в данном массиве. База для n = 1 очевидна. Пусть у нас есть тип pair < type1, type2 > . Тогда baln = 1 +  balntype1+balntype2  =  - 1. Также можем получить, что bali >  = 0 для 1 <  = i < n.Пусть теперь у нас есть массив строк s, и в нем выполняется данное утверждение. Тогда первый элемент в нем — pair. Возьмем наименьшее i, что bali = 0 — оно существует по соображениям дискретной непрерывности (и не равно n, ибо baln =  - 1) — в этой позиции должен заканчиваться type1. Тогда на отрезке [2, i] (для него несложно проверить предположение индукции) можно расставить знаки препинания, чтобы получился тип. Аналогичное верно и для отрезка [i + 1, n]. Значит, и из всего отрезка [1, n] можно составить тип, причем тоже единственным образом.Теперь, если мы получили, что из данного массива строк можно составить тип, заведем функцию gettype(i), которая будет строить тип, начинающийся в si, и возвращать индекс, следующий после того, в котором она завершила построение. Как она будет работать? Пусть сейчас запущена gettype(i). Если si = pair, выведем int и вернем i + 1. Иначе выведем \"pair < \", запустим gettype(i + 1) — пусть он вернул нам j. Выведем \", \" и запустим gettype(j), он вернул нам k, выведем \" > \" и вернем k. Итого, запустив gettype(0), мы построим и выведем восстановленный тип.Можно обойтись без предварительной проверки, можно ли составить тип из данного массива. Для этого можно запустить функцию gettype и, если в ходе построения типа получаются противоречия, выводить \"Error occurred\".Асимптотическая сложность решения — O(количества данных строк).D — Несекретный шифрРешение riadwaw: Воспользуемся методом двух указателей. Будем поддерживать для каждого элемента, сколько раз он встречается на текущем отрезке [l, r]. При фиксированном l будем увеличивать r, если элемент a[r] встречается k раз, то этот отрезок и все отрезки вида [l, t], t > r нужно добавить в ответ и увеличить l. Чтобы поддерживать кол-во элементов нужно либо сжать координаты, либо воспользоваться структурой map. Также нужно не забыть, что ответ может достигать n * (n + 1) / 2, т.е не влазить в int.Решение Kostroma: для начала сожмем координаты, аналогично первому решению. Выпишем для каждого числа список позиций, в которых оно встречается в нашем массиве. Теперь создадим массив b, в bi будем хранить номер позиции, в которой стоит число ai, при этом на отрезке [i, bi] число ai встречается ровно k раз (если такой позиции нет, то bi = n + 1). Это несложно сделать одним проходом по нашим спискам. Найдем, сколько отрезков с началом в i удовлетворяют условию задачи — для этого из n нужно вычесть такое минимальное j, что на отрезке [i, j] есть k одинаковых чисел (если такого отрезка нет, то j будем считать равным n + 1). Но такое минимальное j есть . Такие минимумы для всех i можно найти, пройдя массив a один раз с конца. Осталось только просуммировать ответы для всех i от 1 до n.E — КонтратакаУ этой задачи много различных решений. Для начала, конечно же, сопоставим городам вершины графа, а дорогам — ребра. Теперь нам нужно найти все компоненты связности в дополнении данного графа.Решение Gerald: будем хранить set a вершин, которые еще не были посещены, и запустим серию обходов в глубину. Предварительно отсортируем списки смежности каждой вершины — теперь мы можем за O(logn) проверять, есть ли в данном графе произвольное ребро. Пусть мы сейчас находимся в вершине v. Пройдемся по всем элементам a, пусть мы сейчас рассматриваем вершину . Если ребра (v, u) нет в данном графе, то в его дополнении оно есть  =  >  выкинем из a вершину u и добавим ее в очередь. Иначе ничего с вершиной u не делаем. Сколько же раз с вершиной u будет повторена такая операция? Заметим, что вершина u остается в set-е только тогда, когда в данном графе есть ребро (u, v), то есть не больше раз, чем степень вершины u. Значит, асимпотика такого решения равна O(M * logn). Логарифм появляется из бинарного поиска. Это решение без каких бы то ни было оптимизаций тратит чуть больше 2 секунд. Если использовать хеш-таблицы, чтобы узнавать, есть ли в графе определенное ребро, получим асимптотику O(m).Решение Kostroma: Рассмотрим компоненты дополнения нашего графа. Рассмотрим такой набор компонент дополнения, что их суммарный размер не больше n / 2 и наиболее близок к n / 2 (если такого набора не существует, то в дополнении одна компонента) — пусть в них в сумме c вершин — назовем это множество A. Тогда все ребра между этими с вершинами и остальными n - c вершинами должны быть в данном графе, то есть c·(n - c) <  = m. Отсюда получаем, что . Если n2 <  = 4·m, то n <  = 2·103, тогда c <  = 103. Иначе при фиксированном m для роста оценки на c нужно уменьшать n — вплоть до того, пока не выполнится n2 = 4·m. Тогда . Значит, мы получили, что c <  = 103.Рассмотрим теперь любую другую компоненту, пусть в ней b вершин. Тогда c + b >  = n - c, так как c + b > n / 2 в силу выбора множества A, а значит, если c + b < n - c, то можно взять множество компонент, в которое входят все компоненты, кроме A и еще одной компоненты из b вершин — в нем n - c - b вершин, и c < n - c - b, n - c - b <  = n / 2. Значит, если в дополнении больше одной компоненты, то есть компонента размеров не меньше чем n - 2·c (назовем ее большой), значит, во всех остальных компонентах в сумме не больше чем 2·c вершин (причем в A ровно c вершин, значит во всех компонентах, кроме большой, не больше чем c вершин). Тогда не лежать в большой компоненте могут только вершины, степень которых в исходном графе как минимум n - c. Значит, все вершины со степенью  < n - c лежат в одной компоненте, а значит, все вершины со степенью  < n - 1000 тем более лежат в одной компоненте. Множество этих вершин назовем B. Построим новый граф из вершин, не принадлежащих множеству B и еще одной вершины: для каждой пары вершин не из B ребро будет проведено тогда и только тогда, когда в исходном графе его не было. Сопоставим множеству B вершину D, тогда ребра между D и произвольной вершиной v не будет тогда и только тогда, когда в исходном графе v соединена со всеми вершинами из B.Сколько же в новом графе будет вершин? Количество вершин, степень которых в данном графе как минимум n - 1000, и еще вершина D, то есть не больше чем  + 1 =  . Значит, ребер в графе будет O(m). Теперь запустим серию обходов в глубину или ширину на таком графе и найдем в нем компоненты связности. Теперь нетрудно восстановить компоненты связности дополнения: для этого нужно лишь вспомнить, какие вершины попали в множество B. Получаем решение за O(m), работающее чуть меньше секунды.Решение riadwaw:- Посчитаем степень каждой вершины в исходном графе, выберем вершину с минимальной степенью — назовем её V. O(m)- Заметим, что ее степень не больше средней степени вершин, т.е .- Заметим, что все вершины, кроме соединенных с V в исходном графе, будут лежать в дополнении в той же компоненте связности, что и V — назовем это множество вершин A.- Таким образом, можно явно построить дополнение графа, содержащего V и все вершины, соединенные с ней. Всего ребер там , так как m < n·n. Переберем все эти ребра, объединим с помощью СНМ соединенные вершины. Кроме того, объединим с компонентой, содержащей V, вершины, которые в исходном графе соединены не со всеми вершинами из A.В асимптотике могут вылезать лишние логарифмы из СНМ или сжатия координат. Общая асимптотика от O(m) до O(mlogn), решение работает около секунды.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4556",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 9370
        },
        {
          "title": "Codeforces Round #120 (Div. 2) - Codeforces",
          "content": "Пришло время для Валеры оказаться и нам (я и Kostroma) по ту сторону контеста.Мы являемся авторами сегодняшнего раунда и надеемся, что вы сможете понять условия он вам (а главное нам) понравится.В этот раз вы столкнетесь с очередной историей про частого героя местных задач — Васю.Как вы могли бы догадаться, этот раунд для участников из второго дивизиона, но мы думаем, что и div.1 найдет, что сегодня порешать.Спасибо за помощь в подготовке STAJIKER, HeroShadow, victor_kamashev, Abra, ifsmirnov, Aksenov239 и, конечно, Gerald, а также MikeMirzayanov за платформу CodeForces и Delinur за английскую версию условийУспехов!UPD2: Разбалловка стандартная, фиксированная, 500-1000-1500-2000-2500. Авторы думают, что задачи упорядочены по сложности.UPD3: Мы извиняемся, по нашей вине произошла ошибка, на несколько минут был случайно опубликован разбор задач. Тем, кто его видел, просьба не обсуждать задачи. В любом случае контест будет проводиться. Вопрос о рейтинговости раунда будет решен после контеста.UPD4: Выяснилось, что во время нахождения разбора в общем доступе только три человека из div2 просматривали пост с разбором (а всего восемь). Мы не будем называть никаких имен, но очень сильно просим не разглашать никакой информации про раунд и не пользоваться никакими материалами поста, если они у вас остались. Спасибо за понимание.UPD5: Пожалуйсте, не устраивайте панику, вы можете решать следующие задачи, пока ваше решение не тестируется.UPD6: Раунд объявляется нерейтинговым. Это связано с техническими причинами (тестирование не начинается более часа). В сумме с произошедшим инцидентом с разбором, это явлется веской причиной для подобного решения. Вы можете посылать свои решения в контест. Мы обязательно протестируем все попытки. Мы надеемся что технические проблемы не сильно испортят ваше впечатление от задач. Наши искренние извинения за эти недоработки.UPD7: Контест завершен. Опубликован разбор. Надеемся, что вам понравились подготовленные нами задачи. Думаю, мы еще вернемся. Еще раз мои извинения.P.S: К сожалению, я не знаю, когда протестируется решения.UPD8: Тестирование завершено.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4554",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2108
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #120 (Div. 2) - Codeforces - Code 1",
          "code": "<s>Зачёркнутый текст</s>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4554",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 1",
          "code": "set.clear()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 2",
          "code": "set = new HashSet<Integer> ();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 3",
          "code": "s=\"pair\", b=2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 4",
          "code": "s=\"pair int int\", b=0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 5",
          "code": "int pos = -1;\nvoid Go() {                        \n   if (t[++pos] == \"int\")\n      res.Append(\"int\");\n   else {\n      res.Append(\"pair<\");\n      Go();\n      res.Append(\",\");\n      Go();\n      res.Append(\">\");\n   }            \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 6",
          "code": "int pos = -1;\nvoid Go() {                        \n   if (t[++pos] == \"int\")\n      res.Append(\"int\");\n   else {\n      res.Append(\"pair<\");\n      Go();\n      res.Append(\",\");\n      Go();\n      res.Append(\">\");\n   }            \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 7",
          "code": "String s = \"\";\nfor (int i = 0; i < 100000; i++)\n    s += 'a';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 8",
          "code": "String s = \"\";\nfor (int i = 0; i < 100000; i++)\n    s += 'a';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 9",
          "code": "String s = \"\";\nfor (int i = 0; i < 100000; i++)\n    s = new StringBuilder(s).append('a').toString();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 10",
          "code": "String s = \"\";\nfor (int i = 0; i < 100000; i++)\n    s = new StringBuilder(s).append('a').toString();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 11",
          "code": "g[V].insert(g[V].begin(), -1);\ng[V].pb(n);//в начало -1, в конец - n, чтобы было удобно перебирать вершины\nfor (unsigned int i = 0; i < size(g[V]); i++)\n for (unsigned int j = g[V][i] + 1; j < g[V][i + 1]; j++)\n  union_set(V, j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 12",
          "code": "g[V].insert(g[V].begin(), -1);\ng[V].pb(n);//в начало -1, в конец - n, чтобы было удобно перебирать вершины\nfor (unsigned int i = 0; i < size(g[V]); i++)\n for (unsigned int j = g[V][i] + 1; j < g[V][i + 1]; j++)\n  union_set(V, j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 13",
          "code": "x *= 10; x += t - '0';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 14",
          "code": "HashSet<int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 15",
          "code": "HashSet<Int64>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 16",
          "code": "500000*u + v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 17",
          "code": "500000*v + u",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 18",
          "code": "O(m+n log^2 n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 19",
          "code": "O(m+n log n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div. 2) - Codeforces - Code 1",
          "code": "<s>Зачёркнутый текст</s>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4554",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string line = inf.readLine();\n\n    istringstream iss(line);\n    string s;\n    int totalWords = 0;\n    int countInt = 0;\n\n    while (iss >> s) {\n        ensuref(s == \"int\" || s == \"pair\", \"Invalid word: %s\", s.c_str());\n        totalWords++;\n        ensuref(totalWords <= 100000, \"Total number of words exceeds 1e5\");\n        if (s == \"int\")\n            countInt++;\n    }\n\n    ensuref(countInt == n, \"Number of 'int' words (%d) does not match n (%d)\", countInt, n);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string line = inf.readLine();\n\n    istringstream iss(line);\n    string s;\n    int totalWords = 0;\n    int countInt = 0;\n\n    while (iss >> s) {\n        ensuref(s == \"int\" || s == \"pair\", \"Invalid word: %s\", s.c_str());\n        totalWords++;\n        ensuref(totalWords <= 100000, \"Total number of words exceeds 1e5\");\n        if (s == \"int\")\n            countInt++;\n    }\n\n    ensuref(countInt == n, \"Number of 'int' words (%d) does not match n (%d)\", countInt, n);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string line = inf.readLine();\n\n    istringstream iss(line);\n    string s;\n    int totalWords = 0;\n    int countInt = 0;\n\n    while (iss >> s) {\n        ensuref(s == \"int\" || s == \"pair\", \"Invalid word: %s\", s.c_str());\n        totalWords++;\n        ensuref(totalWords <= 100000, \"Total number of words exceeds 1e5\");\n        if (s == \"int\")\n            countInt++;\n    }\n\n    ensuref(countInt == n, \"Number of 'int' words (%d) does not match n (%d)\", countInt, n);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateDeep(int n);\nvoid generateBalanced(int n);\nvoid generateRandom(int n);\nvoid generateInvalid(int n, string reason);\n\nvector<string> words;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"valid\"); // \"valid\" or \"invalid\"\n    string structure = opt<string>(\"structure\", \"deep\"); // For valid: \"deep\", \"balanced\", \"random\"\n    string reason = opt<string>(\"reason\", \"random\"); // For invalid: \"mismatch\", \"missing_int\", \"random\"\n\n    if (type == \"valid\") {\n        if (structure == \"deep\") {\n            generateDeep(n);\n        } else if (structure == \"balanced\") {\n            generateBalanced(n);\n        } else if (structure == \"random\") {\n            generateRandom(n);\n        } else {\n            // Default to random structure\n            generateRandom(n);\n        }\n    } else if (type == \"invalid\") {\n        generateInvalid(n, reason);\n    } else {\n        // Default to valid deep structure\n        generateDeep(n);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output words\n    for (size_t i = 0; i < words.size(); ++i) {\n        printf(\"%s\", words[i].c_str());\n        if (i + 1 != words.size())\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n\n// Generate deep nesting type\nvoid generateDeep(int n) {\n    if (n == 1) {\n        words.push_back(\"int\");\n    } else {\n        words.push_back(\"pair\");\n        words.push_back(\"int\");\n        generateDeep(n - 1);\n    }\n}\n\n// Generate balanced nesting type\nvoid generateBalanced(int n) {\n    if (n == 1) {\n        words.push_back(\"int\");\n    } else {\n        int n1 = n / 2;\n        int n2 = n - n1;\n        words.push_back(\"pair\");\n        generateBalanced(n1);\n        generateBalanced(n2);\n    }\n}\n\n// Generate random nesting type\nvoid generateRandom(int n) {\n    if (n == 1) {\n        words.push_back(\"int\");\n    } else {\n        words.push_back(\"pair\");\n        int n1 = rnd.next(1, n - 1);\n        int n2 = n - n1;\n        if (rnd.next(0, 1)) {\n            generateRandom(n1);\n            generateRandom(n2);\n        } else {\n            generateRandom(n2);\n            generateRandom(n1);\n        }\n    }\n}\n\n// Generate invalid input\nvoid generateInvalid(int n, string reason) {\n    if (reason == \"mismatch\") {\n        // Create mismatched number of \"pair\" and \"int\" words\n        int num_int = n;\n        int num_pair = n; // One extra \"pair\" to cause error\n        int total_words = num_int + num_pair;\n        words.resize(total_words);\n        for (int i = 0; i < num_int; ++i)\n            words[i] = \"int\";\n        for (int i = num_int; i < total_words; ++i)\n            words[i] = \"pair\";\n        // Shuffle words to make parsing fail\n        shuffle(words.begin(), words.end());\n    } else if (reason == \"missing_int\") {\n        // Remove one \"int\" to cause insufficient \"int\"s\n        generateBalanced(n);\n        for (size_t i = 0; i < words.size(); ++i) {\n            if (words[i] == \"int\") {\n                words.erase(words.begin() + i);\n                break;\n            }\n        }\n    } else {\n        // Generate random invalid sequence\n        int total_words = rnd.next(n + 1, 2 * n + 1);\n        for (int i = 0; i < total_words; ++i) {\n            int choice = rnd.next(0, 1);\n            if (choice == 0)\n                words.push_back(\"int\");\n            else\n                words.push_back(\"pair\");\n        }\n    }\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateDeep(int n);\nvoid generateBalanced(int n);\nvoid generateRandom(int n);\nvoid generateInvalid(int n, string reason);\n\nvector<string> words;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"valid\"); // \"valid\" or \"invalid\"\n    string structure = opt<string>(\"structure\", \"deep\"); // For valid: \"deep\", \"balanced\", \"random\"\n    string reason = opt<string>(\"reason\", \"random\"); // For invalid: \"mismatch\", \"missing_int\", \"random\"\n\n    if (type == \"valid\") {\n        if (structure == \"deep\") {\n            generateDeep(n);\n        } else if (structure == \"balanced\") {\n            generateBalanced(n);\n        } else if (structure == \"random\") {\n            generateRandom(n);\n        } else {\n            // Default to random structure\n            generateRandom(n);\n        }\n    } else if (type == \"invalid\") {\n        generateInvalid(n, reason);\n    } else {\n        // Default to valid deep structure\n        generateDeep(n);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output words\n    for (size_t i = 0; i < words.size(); ++i) {\n        printf(\"%s\", words[i].c_str());\n        if (i + 1 != words.size())\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n\n// Generate deep nesting type\nvoid generateDeep(int n) {\n    if (n == 1) {\n        words.push_back(\"int\");\n    } else {\n        words.push_back(\"pair\");\n        words.push_back(\"int\");\n        generateDeep(n - 1);\n    }\n}\n\n// Generate balanced nesting type\nvoid generateBalanced(int n) {\n    if (n == 1) {\n        words.push_back(\"int\");\n    } else {\n        int n1 = n / 2;\n        int n2 = n - n1;\n        words.push_back(\"pair\");\n        generateBalanced(n1);\n        generateBalanced(n2);\n    }\n}\n\n// Generate random nesting type\nvoid generateRandom(int n) {\n    if (n == 1) {\n        words.push_back(\"int\");\n    } else {\n        words.push_back(\"pair\");\n        int n1 = rnd.next(1, n - 1);\n        int n2 = n - n1;\n        if (rnd.next(0, 1)) {\n            generateRandom(n1);\n            generateRandom(n2);\n        } else {\n            generateRandom(n2);\n            generateRandom(n1);\n        }\n    }\n}\n\n// Generate invalid input\nvoid generateInvalid(int n, string reason) {\n    if (reason == \"mismatch\") {\n        // Create mismatched number of \"pair\" and \"int\" words\n        int num_int = n;\n        int num_pair = n; // One extra \"pair\" to cause error\n        int total_words = num_int + num_pair;\n        words.resize(total_words);\n        for (int i = 0; i < num_int; ++i)\n            words[i] = \"int\";\n        for (int i = num_int; i < total_words; ++i)\n            words[i] = \"pair\";\n        // Shuffle words to make parsing fail\n        shuffle(words.begin(), words.end());\n    } else if (reason == \"missing_int\") {\n        // Remove one \"int\" to cause insufficient \"int\"s\n        generateBalanced(n);\n        for (size_t i = 0; i < words.size(); ++i) {\n            if (words[i] == \"int\") {\n                words.erase(words.begin() + i);\n                break;\n            }\n        }\n    } else {\n        // Generate random invalid sequence\n        int total_words = rnd.next(n + 1, 2 * n + 1);\n        for (int i = 0; i < total_words; ++i) {\n            int choice = rnd.next(0, 1);\n            if (choice == 0)\n                words.push_back(\"int\");\n            else\n                words.push_back(\"pair\");\n        }\n    }\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Valid test cases with deep nesting\n./gen -n 1 -type valid -structure deep\n./gen -n 2 -type valid -structure deep\n./gen -n 10 -type valid -structure deep\n./gen -n 100 -type valid -structure deep\n./gen -n 1000 -type valid -structure deep\n./gen -n 10000 -type valid -structure deep\n./gen -n 100000 -type valid -structure deep\n\n# Valid test cases with balanced nesting\n./gen -n 1 -type valid -structure balanced\n./gen -n 2 -type valid -structure balanced\n./gen -n 10 -type valid -structure balanced\n./gen -n 100 -type valid -structure balanced\n./gen -n 1000 -type valid -structure balanced\n./gen -n 10000 -type valid -structure balanced\n./gen -n 100000 -type valid -structure balanced\n\n# Valid test cases with random nesting\n./gen -n 2 -type valid -structure random\n./gen -n 10 -type valid -structure random\n./gen -n 100 -type valid -structure random\n./gen -n 1000 -type valid -structure random\n./gen -n 10000 -type valid -structure random\n./gen -n 100000 -type valid -structure random\n\n# Invalid test cases with mismatched counts\n./gen -n 1 -type invalid -reason mismatch\n./gen -n 2 -type invalid -reason mismatch\n./gen -n 10 -type invalid -reason mismatch\n./gen -n 100 -type invalid -reason mismatch\n./gen -n 1000 -type invalid -reason mismatch\n./gen -n 10000 -type invalid -reason mismatch\n./gen -n 100000 -type invalid -reason mismatch\n\n# Invalid test cases with missing int\n./gen -n 2 -type invalid -reason missing_int\n./gen -n 10 -type invalid -reason missing_int\n./gen -n 100 -type invalid -reason missing_int\n./gen -n 1000 -type invalid -reason missing_int\n./gen -n 10000 -type invalid -reason missing_int\n./gen -n 100000 -type invalid -reason missing_int\n\n# Invalid test cases with random invalid sequence\n./gen -n 2 -type invalid -reason random\n./gen -n 10 -type invalid -reason random\n./gen -n 100 -type invalid -reason random\n./gen -n 1000 -type invalid -reason random\n./gen -n 10000 -type invalid -reason random\n./gen -n 100000 -type invalid -reason random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:06.845595",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "190/D",
      "title": "D. Несекретный шифр",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке через пробел записаны два целых числа n, k (1 ≤ k ≤ n ≤ 4·105) — количество чисел в массиве и требуемое количество одинаковых чисел в подмассивах, соответственно. Во второй строке через пробел записаны n целых чисел ai (1 ≤ ai ≤ 109) — элементы массива.",
      "output_spec": "Выходные данныеВыведите единственное число — количество подмассивов массива a таких, что в них есть как минимум k одинаковых чисел.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 21 2 1 2Выходные данныеСкопировать3Входные данныеСкопировать5 31 2 1 1 3Выходные данныеСкопировать2Входные данныеСкопировать3 11 1 1Выходные данныеСкопировать6",
      "description": "D. Несекретный шифр\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке через пробел записаны два целых числа n, k (1 ≤ k ≤ n ≤ 4·105) — количество чисел в массиве и требуемое количество одинаковых чисел в подмассивах, соответственно. Во второй строке через пробел записаны n целых чисел ai (1 ≤ ai ≤ 109) — элементы массива.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — количество подмассивов массива a таких, что в них есть как минимум k одинаковых чисел.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать4 21 2 1 2Выходные данныеСкопировать3Входные данныеСкопировать5 31 2 1 1 3Выходные данныеСкопировать2Входные данныеСкопировать3 11 1 1Выходные данныеСкопировать6\n\nВходные данныеСкопировать4 21 2 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 31 2 1 1 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 11 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере существует три подмассива, содержащих хотя бы два одинаковых числа: (1,2,1), (2,1,2) и (1,2,1,2).Во втором примере существует два подмассива, содержащих три одинаковых числа: (1,2,1,1,3) и (1,2,1,1).В третьем примере любой подмассив содержит хотя бы 1 число. Всего их 6: (1), (1), (1), (1,1), (1,1) и (1,1,1).",
      "solutions": [
        {
          "title": "Codeforces Round #120 (Div. 2) - Codeforces",
          "content": "Пришло время для Валеры оказаться и нам (я и Kostroma) по ту сторону контеста.Мы являемся авторами сегодняшнего раунда и надеемся, что вы сможете понять условия он вам (а главное нам) понравится.В этот раз вы столкнетесь с очередной историей про частого героя местных задач — Васю.Как вы могли бы догадаться, этот раунд для участников из второго дивизиона, но мы думаем, что и div.1 найдет, что сегодня порешать.Спасибо за помощь в подготовке STAJIKER, HeroShadow, victor_kamashev, Abra, ifsmirnov, Aksenov239 и, конечно, Gerald, а также MikeMirzayanov за платформу CodeForces и Delinur за английскую версию условийУспехов!UPD2: Разбалловка стандартная, фиксированная, 500-1000-1500-2000-2500. Авторы думают, что задачи упорядочены по сложности.UPD3: Мы извиняемся, по нашей вине произошла ошибка, на несколько минут был случайно опубликован разбор задач. Тем, кто его видел, просьба не обсуждать задачи. В любом случае контест будет проводиться. Вопрос о рейтинговости раунда будет решен после контеста.UPD4: Выяснилось, что во время нахождения разбора в общем доступе только три человека из div2 просматривали пост с разбором (а всего восемь). Мы не будем называть никаких имен, но очень сильно просим не разглашать никакой информации про раунд и не пользоваться никакими материалами поста, если они у вас остались. Спасибо за понимание.UPD5: Пожалуйсте, не устраивайте панику, вы можете решать следующие задачи, пока ваше решение не тестируется.UPD6: Раунд объявляется нерейтинговым. Это связано с техническими причинами (тестирование не начинается более часа). В сумме с произошедшим инцидентом с разбором, это явлется веской причиной для подобного решения. Вы можете посылать свои решения в контест. Мы обязательно протестируем все попытки. Мы надеемся что технические проблемы не сильно испортят ваше впечатление от задач. Наши искренние извинения за эти недоработки.UPD7: Контест завершен. Опубликован разбор. Надеемся, что вам понравились подготовленные нами задачи. Думаю, мы еще вернемся. Еще раз мои извинения.P.S: К сожалению, я не знаю, когда протестируется решения.UPD8: Тестирование завершено.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4554",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2108
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces",
          "content": "Прежде чем опубликовать разбор задач сегодняшнего раунда, приношу извинения администрации и участникам за свою глупую ошибку, допущенную по криворукости и неопытности.Несмотря на то что раунд откровенно не удался, мы, авторы, рады, что многим участникам задачи понравились. Вот, собственно, решения:A — Вася и автобусыВо-первых, если n = 0, то ни одного ребенка по условию нельзя провезти. Значит, если при этом m = 0, от ответ (0, 0), иначе ответ Impossible.Теперь n > 0. Если m = 0, то ответ, очевидно, (n, n). Иначе, чем больше родителей везет с собой по ребенку, тем меньше плата за проезд. Поэтому максимальная плата будет тогда, когда всех детей везет один родитель — получаем ответ n + m - 1. Если n <  = m, то все n родителей везут детей, и ровно n детей не платят за проезд. Если же n > m, то все m детей распределяются по родителям и не платят за проезд. В обоих случаях получаем минимальный ответ max(n, m).B — ОкружениеНайдем минимальное расстояние между окружностями L. Тогда ответ к задаче равен L / 2.- Пусть окружности лежат вне друг друга. Покажем, что L = d - R - r. Во-первых, ясно, что он достигается. Проведем отрезок соединяющий центры. Его часть, лежащая между точками пересечения с окружностями как раз имеет такую длину. Докажем, что меньшее расстояние недостижимо, построим отрезок между двумя окружностями. Тогда R + r + L >  = d, откуда L >  = d - R - r, чтд. Для окружностей, лежащих внутри друг друга аналогичными рассуждениями получаем L = R - d - r, где R — радиус наружной окружности, r — внутренней. Для пересекающихся окружностей ответ 0. C — STLПусть нам дан массив строк (s1, s2, ...sn), где si  = pair либо int.Рассмотрим числа bali = разность количества pair и int на отрезке массива от 1 до i. Тогда утверждается, что восстановить тип по данному массиву строк можно, причем однозначно  <  =  >  bali >  = 0 при 1 <  = i < n и baln =  - 1. Здесь возникает очевидная аналогия с правильными скобочными последовательностями.Докажем это утверждение по индукции по количеству int в данном массиве. База для n = 1 очевидна. Пусть у нас есть тип pair < type1, type2 > . Тогда baln = 1 +  balntype1+balntype2  =  - 1. Также можем получить, что bali >  = 0 для 1 <  = i < n.Пусть теперь у нас есть массив строк s, и в нем выполняется данное утверждение. Тогда первый элемент в нем — pair. Возьмем наименьшее i, что bali = 0 — оно существует по соображениям дискретной непрерывности (и не равно n, ибо baln =  - 1) — в этой позиции должен заканчиваться type1. Тогда на отрезке [2, i] (для него несложно проверить предположение индукции) можно расставить знаки препинания, чтобы получился тип. Аналогичное верно и для отрезка [i + 1, n]. Значит, и из всего отрезка [1, n] можно составить тип, причем тоже единственным образом.Теперь, если мы получили, что из данного массива строк можно составить тип, заведем функцию gettype(i), которая будет строить тип, начинающийся в si, и возвращать индекс, следующий после того, в котором она завершила построение. Как она будет работать? Пусть сейчас запущена gettype(i). Если si = pair, выведем int и вернем i + 1. Иначе выведем \"pair < \", запустим gettype(i + 1) — пусть он вернул нам j. Выведем \", \" и запустим gettype(j), он вернул нам k, выведем \" > \" и вернем k. Итого, запустив gettype(0), мы построим и выведем восстановленный тип.Можно обойтись без предварительной проверки, можно ли составить тип из данного массива. Для этого можно запустить функцию gettype и, если в ходе построения типа получаются противоречия, выводить \"Error occurred\".Асимптотическая сложность решения — O(количества данных строк).D — Несекретный шифрРешение riadwaw: Воспользуемся методом двух указателей. Будем поддерживать для каждого элемента, сколько раз он встречается на текущем отрезке [l, r]. При фиксированном l будем увеличивать r, если элемент a[r] встречается k раз, то этот отрезок и все отрезки вида [l, t], t > r нужно добавить в ответ и увеличить l. Чтобы поддерживать кол-во элементов нужно либо сжать координаты, либо воспользоваться структурой map. Также нужно не забыть, что ответ может достигать n * (n + 1) / 2, т.е не влазить в int.Решение Kostroma: для начала сожмем координаты, аналогично первому решению. Выпишем для каждого числа список позиций, в которых оно встречается в нашем массиве. Теперь создадим массив b, в bi будем хранить номер позиции, в которой стоит число ai, при этом на отрезке [i, bi] число ai встречается ровно k раз (если такой позиции нет, то bi = n + 1). Это несложно сделать одним проходом по нашим спискам. Найдем, сколько отрезков с началом в i удовлетворяют условию задачи — для этого из n нужно вычесть такое минимальное j, что на отрезке [i, j] есть k одинаковых чисел (если такого отрезка нет, то j будем считать равным n + 1). Но такое минимальное j есть . Такие минимумы для всех i можно найти, пройдя массив a один раз с конца. Осталось только просуммировать ответы для всех i от 1 до n.E — КонтратакаУ этой задачи много различных решений. Для начала, конечно же, сопоставим городам вершины графа, а дорогам — ребра. Теперь нам нужно найти все компоненты связности в дополнении данного графа.Решение Gerald: будем хранить set a вершин, которые еще не были посещены, и запустим серию обходов в глубину. Предварительно отсортируем списки смежности каждой вершины — теперь мы можем за O(logn) проверять, есть ли в данном графе произвольное ребро. Пусть мы сейчас находимся в вершине v. Пройдемся по всем элементам a, пусть мы сейчас рассматриваем вершину . Если ребра (v, u) нет в данном графе, то в его дополнении оно есть  =  >  выкинем из a вершину u и добавим ее в очередь. Иначе ничего с вершиной u не делаем. Сколько же раз с вершиной u будет повторена такая операция? Заметим, что вершина u остается в set-е только тогда, когда в данном графе есть ребро (u, v), то есть не больше раз, чем степень вершины u. Значит, асимпотика такого решения равна O(M * logn). Логарифм появляется из бинарного поиска. Это решение без каких бы то ни было оптимизаций тратит чуть больше 2 секунд. Если использовать хеш-таблицы, чтобы узнавать, есть ли в графе определенное ребро, получим асимптотику O(m).Решение Kostroma: Рассмотрим компоненты дополнения нашего графа. Рассмотрим такой набор компонент дополнения, что их суммарный размер не больше n / 2 и наиболее близок к n / 2 (если такого набора не существует, то в дополнении одна компонента) — пусть в них в сумме c вершин — назовем это множество A. Тогда все ребра между этими с вершинами и остальными n - c вершинами должны быть в данном графе, то есть c·(n - c) <  = m. Отсюда получаем, что . Если n2 <  = 4·m, то n <  = 2·103, тогда c <  = 103. Иначе при фиксированном m для роста оценки на c нужно уменьшать n — вплоть до того, пока не выполнится n2 = 4·m. Тогда . Значит, мы получили, что c <  = 103.Рассмотрим теперь любую другую компоненту, пусть в ней b вершин. Тогда c + b >  = n - c, так как c + b > n / 2 в силу выбора множества A, а значит, если c + b < n - c, то можно взять множество компонент, в которое входят все компоненты, кроме A и еще одной компоненты из b вершин — в нем n - c - b вершин, и c < n - c - b, n - c - b <  = n / 2. Значит, если в дополнении больше одной компоненты, то есть компонента размеров не меньше чем n - 2·c (назовем ее большой), значит, во всех остальных компонентах в сумме не больше чем 2·c вершин (причем в A ровно c вершин, значит во всех компонентах, кроме большой, не больше чем c вершин). Тогда не лежать в большой компоненте могут только вершины, степень которых в исходном графе как минимум n - c. Значит, все вершины со степенью  < n - c лежат в одной компоненте, а значит, все вершины со степенью  < n - 1000 тем более лежат в одной компоненте. Множество этих вершин назовем B. Построим новый граф из вершин, не принадлежащих множеству B и еще одной вершины: для каждой пары вершин не из B ребро будет проведено тогда и только тогда, когда в исходном графе его не было. Сопоставим множеству B вершину D, тогда ребра между D и произвольной вершиной v не будет тогда и только тогда, когда в исходном графе v соединена со всеми вершинами из B.Сколько же в новом графе будет вершин? Количество вершин, степень которых в данном графе как минимум n - 1000, и еще вершина D, то есть не больше чем  + 1 =  . Значит, ребер в графе будет O(m). Теперь запустим серию обходов в глубину или ширину на таком графе и найдем в нем компоненты связности. Теперь нетрудно восстановить компоненты связности дополнения: для этого нужно лишь вспомнить, какие вершины попали в множество B. Получаем решение за O(m), работающее чуть меньше секунды.Решение riadwaw:- Посчитаем степень каждой вершины в исходном графе, выберем вершину с минимальной степенью — назовем её V. O(m)- Заметим, что ее степень не больше средней степени вершин, т.е .- Заметим, что все вершины, кроме соединенных с V в исходном графе, будут лежать в дополнении в той же компоненте связности, что и V — назовем это множество вершин A.- Таким образом, можно явно построить дополнение графа, содержащего V и все вершины, соединенные с ней. Всего ребер там , так как m < n·n. Переберем все эти ребра, объединим с помощью СНМ соединенные вершины. Кроме того, объединим с компонентой, содержащей V, вершины, которые в исходном графе соединены не со всеми вершинами из A.В асимптотике могут вылезать лишние логарифмы из СНМ или сжатия координат. Общая асимптотика от O(m) до O(mlogn), решение работает около секунды.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4556",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 9370
        },
        {
          "title": "Codeforces Round #120 (Div. 2) - Codeforces",
          "content": "Пришло время для Валеры оказаться и нам (я и Kostroma) по ту сторону контеста.Мы являемся авторами сегодняшнего раунда и надеемся, что вы сможете понять условия он вам (а главное нам) понравится.В этот раз вы столкнетесь с очередной историей про частого героя местных задач — Васю.Как вы могли бы догадаться, этот раунд для участников из второго дивизиона, но мы думаем, что и div.1 найдет, что сегодня порешать.Спасибо за помощь в подготовке STAJIKER, HeroShadow, victor_kamashev, Abra, ifsmirnov, Aksenov239 и, конечно, Gerald, а также MikeMirzayanov за платформу CodeForces и Delinur за английскую версию условийУспехов!UPD2: Разбалловка стандартная, фиксированная, 500-1000-1500-2000-2500. Авторы думают, что задачи упорядочены по сложности.UPD3: Мы извиняемся, по нашей вине произошла ошибка, на несколько минут был случайно опубликован разбор задач. Тем, кто его видел, просьба не обсуждать задачи. В любом случае контест будет проводиться. Вопрос о рейтинговости раунда будет решен после контеста.UPD4: Выяснилось, что во время нахождения разбора в общем доступе только три человека из div2 просматривали пост с разбором (а всего восемь). Мы не будем называть никаких имен, но очень сильно просим не разглашать никакой информации про раунд и не пользоваться никакими материалами поста, если они у вас остались. Спасибо за понимание.UPD5: Пожалуйсте, не устраивайте панику, вы можете решать следующие задачи, пока ваше решение не тестируется.UPD6: Раунд объявляется нерейтинговым. Это связано с техническими причинами (тестирование не начинается более часа). В сумме с произошедшим инцидентом с разбором, это явлется веской причиной для подобного решения. Вы можете посылать свои решения в контест. Мы обязательно протестируем все попытки. Мы надеемся что технические проблемы не сильно испортят ваше впечатление от задач. Наши искренние извинения за эти недоработки.UPD7: Контест завершен. Опубликован разбор. Надеемся, что вам понравились подготовленные нами задачи. Думаю, мы еще вернемся. Еще раз мои извинения.P.S: К сожалению, я не знаю, когда протестируется решения.UPD8: Тестирование завершено.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4554",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2108
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #120 (Div. 2) - Codeforces - Code 1",
          "code": "<s>Зачёркнутый текст</s>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4554",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 1",
          "code": "set.clear()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 2",
          "code": "set = new HashSet<Integer> ();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 3",
          "code": "s=\"pair\", b=2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 4",
          "code": "s=\"pair int int\", b=0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 5",
          "code": "int pos = -1;\nvoid Go() {                        \n   if (t[++pos] == \"int\")\n      res.Append(\"int\");\n   else {\n      res.Append(\"pair<\");\n      Go();\n      res.Append(\",\");\n      Go();\n      res.Append(\">\");\n   }            \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 6",
          "code": "int pos = -1;\nvoid Go() {                        \n   if (t[++pos] == \"int\")\n      res.Append(\"int\");\n   else {\n      res.Append(\"pair<\");\n      Go();\n      res.Append(\",\");\n      Go();\n      res.Append(\">\");\n   }            \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 7",
          "code": "String s = \"\";\nfor (int i = 0; i < 100000; i++)\n    s += 'a';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 8",
          "code": "String s = \"\";\nfor (int i = 0; i < 100000; i++)\n    s += 'a';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 9",
          "code": "String s = \"\";\nfor (int i = 0; i < 100000; i++)\n    s = new StringBuilder(s).append('a').toString();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 10",
          "code": "String s = \"\";\nfor (int i = 0; i < 100000; i++)\n    s = new StringBuilder(s).append('a').toString();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 11",
          "code": "g[V].insert(g[V].begin(), -1);\ng[V].pb(n);//в начало -1, в конец - n, чтобы было удобно перебирать вершины\nfor (unsigned int i = 0; i < size(g[V]); i++)\n for (unsigned int j = g[V][i] + 1; j < g[V][i + 1]; j++)\n  union_set(V, j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 12",
          "code": "g[V].insert(g[V].begin(), -1);\ng[V].pb(n);//в начало -1, в конец - n, чтобы было удобно перебирать вершины\nfor (unsigned int i = 0; i < size(g[V]); i++)\n for (unsigned int j = g[V][i] + 1; j < g[V][i + 1]; j++)\n  union_set(V, j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 13",
          "code": "x *= 10; x += t - '0';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 14",
          "code": "HashSet<int>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 15",
          "code": "HashSet<Int64>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 16",
          "code": "500000*u + v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 17",
          "code": "500000*v + u",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 18",
          "code": "O(m+n log^2 n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — разбор - Codeforces - Code 19",
          "code": "O(m+n log n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div. 2) - Codeforces - Code 1",
          "code": "<s>Зачёркнутый текст</s>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4554",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 400000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 400000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 400000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int64_t minVal = opt<int64_t>(\"minVal\", 1);\n    int64_t maxVal = opt<int64_t>(\"maxVal\", 1000000000);\n\n    vector<int64_t> a(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(minVal, maxVal);\n        }\n    } else if (type == \"all_same\") {\n        int64_t x = rnd.next(minVal, maxVal);\n        for(int i = 0; i < n; ++i) {\n            a[i] = x;\n        }\n    } else if (type == \"all_distinct\") {\n        assert(maxVal - minVal + 1 >= n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = minVal + i;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"increasing\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = minVal + i;\n        }\n    } else if (type == \"decreasing\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = minVal + n - i - 1;\n        }\n    } else if (type == \"repeating\") {\n        int patternLength = opt<int>(\"patternLength\", 2);\n        vector<int64_t> pattern(patternLength);\n        for(int i = 0; i < patternLength; ++i) {\n            pattern[i] = rnd.next(minVal, maxVal);\n        }\n        for(int i = 0; i < n; ++i) {\n            a[i] = pattern[i % patternLength];\n        }\n    } else if (type == \"max_frequency\") {\n        // Generate an array where one number appears exactly k-1 times\n        int64_t x = rnd.next(minVal, maxVal);\n        int freq = k - 1;\n        assert(freq <= n);\n        for(int i = 0; i < freq; ++i) {\n            a[i] = x;\n        }\n        for(int i = freq; i < n; ++i) {\n            int64_t y = rnd.next(minVal, maxVal);\n            while(y == x) y = rnd.next(minVal, maxVal);\n            a[i] = y;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"single_element_k_times\") {\n        // Generate minimal size where a subarray has k equal elements\n        assert(k <= n);\n        int64_t x = rnd.next(minVal, maxVal);\n        int freq = k;\n        for(int i = 0; i < freq; ++i) {\n            a[i] = x;\n        }\n        for(int i = freq; i < n; ++i) {\n            int64_t y = rnd.next(minVal, maxVal);\n            while(y == x) y = rnd.next(minVal, maxVal);\n            a[i] = y;\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int64_t minVal = opt<int64_t>(\"minVal\", 1);\n    int64_t maxVal = opt<int64_t>(\"maxVal\", 1000000000);\n\n    vector<int64_t> a(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(minVal, maxVal);\n        }\n    } else if (type == \"all_same\") {\n        int64_t x = rnd.next(minVal, maxVal);\n        for(int i = 0; i < n; ++i) {\n            a[i] = x;\n        }\n    } else if (type == \"all_distinct\") {\n        assert(maxVal - minVal + 1 >= n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = minVal + i;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"increasing\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = minVal + i;\n        }\n    } else if (type == \"decreasing\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = minVal + n - i - 1;\n        }\n    } else if (type == \"repeating\") {\n        int patternLength = opt<int>(\"patternLength\", 2);\n        vector<int64_t> pattern(patternLength);\n        for(int i = 0; i < patternLength; ++i) {\n            pattern[i] = rnd.next(minVal, maxVal);\n        }\n        for(int i = 0; i < n; ++i) {\n            a[i] = pattern[i % patternLength];\n        }\n    } else if (type == \"max_frequency\") {\n        // Generate an array where one number appears exactly k-1 times\n        int64_t x = rnd.next(minVal, maxVal);\n        int freq = k - 1;\n        assert(freq <= n);\n        for(int i = 0; i < freq; ++i) {\n            a[i] = x;\n        }\n        for(int i = freq; i < n; ++i) {\n            int64_t y = rnd.next(minVal, maxVal);\n            while(y == x) y = rnd.next(minVal, maxVal);\n            a[i] = y;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"single_element_k_times\") {\n        // Generate minimal size where a subarray has k equal elements\n        assert(k <= n);\n        int64_t x = rnd.next(minVal, maxVal);\n        int freq = k;\n        for(int i = 0; i < freq; ++i) {\n            a[i] = x;\n        }\n        for(int i = freq; i < n; ++i) {\n            int64_t y = rnd.next(minVal, maxVal);\n            while(y == x) y = rnd.next(minVal, maxVal);\n            a[i] = y;\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type all_same\n./gen -n 1 -k 1 -type random\n\n./gen -n 5 -k 1 -type random\n./gen -n 5 -k 3 -type random\n./gen -n 5 -k 5 -type random\n\n./gen -n 10 -k 1 -type all_same\n./gen -n 10 -k 5 -type all_same\n./gen -n 10 -k 10 -type all_same\n\n./gen -n 10 -k 1 -type all_distinct -minVal 1 -maxVal 20\n./gen -n 10 -k 5 -type all_distinct -minVal 1 -maxVal 20\n./gen -n 100 -k 50 -type all_distinct -minVal 1 -maxVal 1000\n\n./gen -n 15 -k 1 -type increasing -minVal 1\n./gen -n 15 -k 5 -type increasing -minVal 1\n\n./gen -n 15 -k 1 -type decreasing -minVal 1\n./gen -n 15 -k 5 -type decreasing -minVal 1\n\n./gen -n 20 -k 4 -type repeating -patternLength 2 -minVal 1 -maxVal 5\n./gen -n 20 -k 3 -type repeating -patternLength 5 -minVal 1 -maxVal 10\n\n./gen -n 100 -k 10 -type single_element_k_times -minVal 1 -maxVal 100\n./gen -n 5000 -k 1000 -type single_element_k_times -minVal 1 -maxVal 1000\n\n./gen -n 100 -k 10 -type max_frequency -minVal 1 -maxVal 100\n./gen -n 1000 -k 50 -type max_frequency -minVal 1 -maxVal 1000\n\n./gen -n 100000 -k 1 -type random -minVal 1 -maxVal 1000000000\n./gen -n 100000 -k 100000 -type all_same\n\n./gen -n 100000 -k 1000 -type random -minVal 1 -maxVal 10\n./gen -n 100000 -k 1000 -type random -minVal 100000000 -maxVal 1000000000\n\n./gen -n 400000 -k 1 -type all_same\n\n./gen -n 400000 -k 400000 -type all_distinct -minVal 1 -maxVal 500000000\n\n./gen -n 400000 -k 200000 -type random -minVal 1 -maxVal 100000000\n\n./gen -n 400000 -k 1 -type random -minVal 1 -maxVal 1000000000\n\n./gen -n 400000 -k 400000 -type random -minVal 1 -maxVal 1000000000\n\n./gen -n 3 -k 3 -type all_same\n\n./gen -n 5 -k 5 -type random -minVal 1 -maxVal 5\n\n./gen -n 100000 -k 99999 -type random -minVal 1 -maxVal 10000000\n\n./gen -n 400000 -k 1 -type repeating -patternLength 1000 -minVal 1 -maxVal 1000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:08.708389",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "190/E",
      "title": "E. Counter Attack",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (1 ≤ n ≤ 5·105, 0 ≤ m ≤ 106) — the number of cities and the number of roads marked on the flatland map, correspondingly.Next m lines contain descriptions of the cities on the map. The i-th line contains two integers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi) — the numbers of cities that are connected by the i-th road on the flatland map.It is guaranteed that each pair of cities occurs in the input no more than once.",
      "output_spec": "OutputOn the first line print number k — the number of groups of cities in Flatland, such that in each group you can get from any city to any other one by flatland roads. At the same time, the cities from different groups should be unreachable by flatland roads.On each of the following k lines first print ti (1 ≤ ti ≤ n) — the number of vertexes in the i-th group. Then print space-separated numbers of cities in the i-th group.The order of printing groups and the order of printing numbers in the groups does not matter. The total sum ti for all k groups must equal n.",
      "sample_tests": "ExamplesInputCopy4 41 21 34 24 3OutputCopy22 1 4 2 2 3 InputCopy3 11 2OutputCopy13 1 2 3",
      "description": "E. Counter Attack\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (1 ≤ n ≤ 5·105, 0 ≤ m ≤ 106) — the number of cities and the number of roads marked on the flatland map, correspondingly.Next m lines contain descriptions of the cities on the map. The i-th line contains two integers ai and bi (1 ≤ ai, bi ≤ n, ai ≠ bi) — the numbers of cities that are connected by the i-th road on the flatland map.It is guaranteed that each pair of cities occurs in the input no more than once.\n\nOutputOn the first line print number k — the number of groups of cities in Flatland, such that in each group you can get from any city to any other one by flatland roads. At the same time, the cities from different groups should be unreachable by flatland roads.On each of the following k lines first print ti (1 ≤ ti ≤ n) — the number of vertexes in the i-th group. Then print space-separated numbers of cities in the i-th group.The order of printing groups and the order of printing numbers in the groups does not matter. The total sum ti for all k groups must equal n.\n\nInputCopy4 41 21 34 24 3OutputCopy22 1 4 2 2 3 InputCopy3 11 2OutputCopy13 1 2 3\n\nInputCopy4 41 21 34 24 3\n\nOutputCopy22 1 4 2 2 3\n\nInputCopy3 11 2\n\nOutputCopy13 1 2 3\n\nNoteIn the first sample there are roads only between pairs of cities 1-4 and 2-3.In the second sample there is no road between cities 1 and 2, but still you can get from one city to the other one through city number 3.",
      "solutions": [
        {
          "title": "Codeforces Round #120 (Div. 2) - Codeforces",
          "content": "Kostroma and I are problemsetters of Codeforces Round #120. It's first our contest and we hope you (and we too) will like it.It's round for second division, but we think that everyone will find interesting problem for him.Thanks for the help STAJIKER, HeroShadow, victor_kamashev, Abra, ifsmirnov, Aksenov239 and Gerald.Thanks MikeMirzayanov for CodeForces platform and Delinur for English statements. Good luck!UPD: As usual, problems will cost 500-1000-1500-2000-2500 points.UPD2: Problems are sorted according to expected difficulty.UPD3: There was our mistake. The editorial was available for few minutes. If you see it, please not discuss problems and solutions. Now it is hided. In any case the round will be held. Decision, will contest rated or not will be made after contest. We are sorry for that.UPD4: It's now known that only three participants from Div.2 have seen page with editorial while it was published (and 8 people in total). We'll not say any names, but we ask this people to not say anybody anything about the problem and to not use any post materials, if you have them. Thanks in advance.UPD5: Please, don't panic. While your solution is in queue, you may solve other problems.UPD6: Due to technical issues round is considered unrated. This problem and incident with editorial are strong enough reason for this decision. You may send your solutions to contest. They will be judged. We hope, that these technical problems will not spoil your impression about this round. Our sincere apologies. UPD7: Contest is over. Editorial is published. We hope, you like problems, prepared by us. We apologize again.P.S: Excuse me, I don't know, when solution will be judged.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4554",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1685
        },
        {
          "title": "Codeforces Round #120 (Div.2) — editorial - Codeforces",
          "content": "A — Vasya and the BusFirstly, if n = 0, then children can't be in the bus, so if m = 0 then the answer is (0, 0), otherwise the answer is \"Impossible\". Now n > 0. If m =  = 0, than it is only one possible variant of passage — the answer is (n, n). Otherwise, more grown-up take some children, less the sum that people pay. So, if only one adult takes all children, than we get maximal sum — n + m - 1. Maximum min(n, m) adults can take the children with them, so the minimal answer is n + m - min(n, m) = max(n, m).B — SurroundedLet's find the minimum distance between two circles L. Then the answer to our problem is L / 2.Now d is the distance between the centers of the circles, R, r — their radiuses. There are 3 possible cases:- Circles don't intersect. Then L = d - R - r. Firstly, it's reachable: let's consider the segment, connecting the centers of the circles, and take its part, which is out of both circles — its length is exactly d - R - r. Let's prove that lesser distance is impossible. If the segment connecting two points of distinct circles have length l, than R + l + r >  = d, so l >  = d - R - r. - If one circle is into another, than analogically the answer is R - d - r, where R is the radius of the bigger circle.- If the circles intersect, then the answer is 0.C — STLIn this problem we have an array of strings (s1, s2, ...sn), where si  = pair or int.Let's consider bali = the difference between number of \"pair\" and \"int\" int the subarray (s1, s2, ...si).Than we can prove that the type can be reestablished from the array s  <  =  >  bali >  = 0 for 1 <  = i < n and baln =  - 1. This can be proved using mathematical induction, the parameter is the number of \"int\"-s in the array.And how to find the solution, if we know that is exists? Consider the function gettype(inti), which builds the type beginning in the position i and returns the index, next to the position where it finished building of type. How it works? If si =  \"int\", then the function prints \"int\" and returns i + 1. Else it prints \"pair < \", gettype(i + 1) is launched, let it returns j. Then we print \", \" and launch gettype(j) (it returns k), then we print \" > \" and return k.We can not to do check if the type can be reestablished from the array in the beginning: launch gettype() and print \"Error occurred\" if there became some contradiction during the building of type. D — Non-secret CypherFirst solution: Let's use the method of two pointers. For every number we will know how many times it occurs in the current segment [l, r]. For fixed l we increase r until a[r] occurs in the current segment less than k times. If a[r] occurs int the segment [l, r] k times, we add to the answer all segments [l, t] for all t >  = r and increase l (and do not forget to decrease the number of a[l] in the current segment).To keep the number of every value in the segment we can use map or compression of the coordinates. Also it's important not to forget that the maximal answer is , which doesn't fit in int.Second solution: firstly, let's do the compression of the coordinates. For every value X we write the list of the positions i such that a[i] = X. Now using that we fill the array b: b[i] is the minimum index that segment [i, b[i]] contains k numbers equal to a[i] (obviosly, a[b[i]] = a[i]), if this index doesn't exist, then b[i] = n + 1.Let's find for every index i a minimal index j such that segment [i, j] contsins k equal numbers (if such j doesn't exist, we say that j = n + 1) — then we add to the answer n + 1 - j. This j is equal to . All that minimums can be found in a single pass through a from its end. Then we can sum the answers for all indexes 1 <  = i <  = n.The complexity of these solutions is O(nlogn).E — Counter AttackThis problem has several different solutions. Anyway, we should consider towns as the vertices of the graph, roads as its edges. Now we are to find the connected components of the complementary graph (CG) of the given graph. Let's take the vertex A with the minimal degree c: . We call the set of the vertices who are connected with A — B, that are not connected — D . All vertices which don't connect with A will be in the same connected component of the CG. Let's build the complemented graph to the subgraph including A and set B — there are vertices and  =   =  O(m) edges.Let's build DSU for the vertices of given graph and merge components which we have found using the new-built graph. All that we should do after it is to consider vertices from B: now we look to the vertex v. We put v in the same component as A if v has edges not to all vertices of D (we do it using DSU too). The complexity of this solution is O(m) or O(mlogn).Another solution: we keep set a, which contains vertices, which haven't been visited yet. Let's run series of bfs to find the components of CG. If we are working now with the vertex v, pass through a. Consider u is the element of a. If edge (u, v) isn't in the given graph, than u is in the same component of CG as v, so, we can erase it from a and add to queue. Otherwise, we do nothing.What is the complexity of this solution? To understand that, we must know how many times whe consider fixed vertex u in the set a. u remains int a when we run to them from vertex v  <  =  >  edge (u, v) is in the given graph. So, every vertex u remains in a no more than its degree. So, the complexity of this algorithm is O(mlogn) (log n because of binsearch — we need use it to know, is (u, v) in the graph). If we use HashMap, we'll get O(m).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4556",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5514
        },
        {
          "title": "Codeforces Round #120 (Div. 2) - Codeforces",
          "content": "Kostroma and I are problemsetters of Codeforces Round #120. It's first our contest and we hope you (and we too) will like it.It's round for second division, but we think that everyone will find interesting problem for him.Thanks for the help STAJIKER, HeroShadow, victor_kamashev, Abra, ifsmirnov, Aksenov239 and Gerald.Thanks MikeMirzayanov for CodeForces platform and Delinur for English statements. Good luck!UPD: As usual, problems will cost 500-1000-1500-2000-2500 points.UPD2: Problems are sorted according to expected difficulty.UPD3: There was our mistake. The editorial was available for few minutes. If you see it, please not discuss problems and solutions. Now it is hided. In any case the round will be held. Decision, will contest rated or not will be made after contest. We are sorry for that.UPD4: It's now known that only three participants from Div.2 have seen page with editorial while it was published (and 8 people in total). We'll not say any names, but we ask this people to not say anybody anything about the problem and to not use any post materials, if you have them. Thanks in advance.UPD5: Please, don't panic. While your solution is in queue, you may solve other problems.UPD6: Due to technical issues round is considered unrated. This problem and incident with editorial are strong enough reason for this decision. You may send your solutions to contest. They will be judged. We hope, that these technical problems will not spoil your impression about this round. Our sincere apologies. UPD7: Contest is over. Editorial is published. We hope, you like problems, prepared by us. We apologize again.P.S: Excuse me, I don't know, when solution will be judged.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4554",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1685
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #120 (Div.2) — editorial - Codeforces - Code 1",
          "code": "O(m+n log^2 n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #120 (Div.2) — editorial - Codeforces - Code 2",
          "code": "O(m+n log n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4556",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 1000000, \"m\");\n    inf.readEoln();\n\n    int64_t N = n; // For key computations\n    unordered_set<int64_t> edge_set;\n\n    for (int i = 0; i < m; ++i) {\n        int a_i = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b_i = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a_i != b_i, \"Self-loops are not allowed between city %d\", a_i);\n\n        int u = min(a_i, b_i);\n        int v = max(a_i, b_i);\n\n        int64_t key = (int64_t)u * N + v;\n\n        ensuref(edge_set.find(key) == edge_set.end(), \"Edge between %d and %d occurs more than once\", a_i, b_i);\n        edge_set.insert(key);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 1000000, \"m\");\n    inf.readEoln();\n\n    int64_t N = n; // For key computations\n    unordered_set<int64_t> edge_set;\n\n    for (int i = 0; i < m; ++i) {\n        int a_i = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b_i = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a_i != b_i, \"Self-loops are not allowed between city %d\", a_i);\n\n        int u = min(a_i, b_i);\n        int v = max(a_i, b_i);\n\n        int64_t key = (int64_t)u * N + v;\n\n        ensuref(edge_set.find(key) == edge_set.end(), \"Edge between %d and %d occurs more than once\", a_i, b_i);\n        edge_set.insert(key);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 1000000, \"m\");\n    inf.readEoln();\n\n    int64_t N = n; // For key computations\n    unordered_set<int64_t> edge_set;\n\n    for (int i = 0; i < m; ++i) {\n        int a_i = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b_i = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a_i != b_i, \"Self-loops are not allowed between city %d\", a_i);\n\n        int u = min(a_i, b_i);\n        int v = max(a_i, b_i);\n\n        int64_t key = (int64_t)u * N + v;\n\n        ensuref(edge_set.find(key) == edge_set.end(), \"Edge between %d and %d occurs more than once\", a_i, b_i);\n        edge_set.insert(key);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 500005;\n\nint n, m;\nvector<int> Adj_map[MAXN];\nset<int> S;\nint comp_id[MAXN]; // The component ID for each node according to the actual graph\nint comp_id2[MAXN]; // The component ID for each node according to the participant's output\n\nvoid compute_components() {\n    // Initialize unvisited nodes set S with nodes from 1 to n\n    for (int i = 1; i <= n; i++)\n        S.insert(i);\n    int component_counter = 0;\n    // Process the connected components in the actual graph\n    while (!S.empty()) {\n        component_counter++;\n        int u = *S.begin();\n        S.erase(u);\n        comp_id[u] = component_counter;\n\n        queue<int> q;\n        q.push(u);\n\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n\n            // Build set of nodes connected to v in actual graph\n            // The nodes connected to v in the actual graph are nodes not in Adj_map[v]\n            // They are in S set\n            vector<int> neighbors;\n            auto it = S.begin();\n            while (it != S.end()) {\n                int w = *it;\n                if (binary_search(Adj_map[v].begin(), Adj_map[v].end(), w)) {\n                    ++it; // Not connected in actual graph\n                } else {\n                    neighbors.push_back(w);\n                    it = S.erase(it); // Node w is being visited\n                }\n            }\n\n            // Process neighbors\n            for (int w : neighbors) {\n                comp_id[w] = component_counter;\n                q.push(w);\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input file\n    n = inf.readInt();\n    m = inf.readInt();\n    // Build the adjacency list for the map graph (complement of the actual graph)\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n);\n        int v = inf.readInt(1, n);\n        if (u == v)\n            quitf(_fail, \"Self-loop detected in input: node %d\", u);\n        Adj_map[u].push_back(v);\n        Adj_map[v].push_back(u);\n    }\n    // Sort adjacency lists for efficient lookup\n    for (int i = 1; i <= n; i++) {\n        sort(Adj_map[i].begin(), Adj_map[i].end());\n    }\n\n    // Compute the connected components of the actual graph\n    compute_components();\n\n    // Read participant's output\n    int k = ouf.readInt(1, n, \"number of groups\");\n    int total_nodes = 0;\n    vector<int> node_count(k);\n    vector<vector<int>> participant_components(k);\n    set<int> participant_nodes; // To check for duplicates and missing nodes\n\n    for (int i = 0; i < k; i++) {\n        int ti = ouf.readInt(1, n, format(\"ti[%d]\", i + 1).c_str());\n        total_nodes += ti;\n        participant_components[i].resize(ti);\n        for (int j = 0; j < ti; j++) {\n            int v = ouf.readInt(1, n, format(\"component[%d][%d]\", i + 1, j + 1).c_str());\n            participant_components[i][j] = v;\n            if (participant_nodes.count(v) > 0)\n                quitf(_wa, \"Node %d appears multiple times in participant's output\", v);\n            participant_nodes.insert(v);\n            comp_id2[v] = i + 1; // Assign component ID according to participant's output\n        }\n    }\n    if (total_nodes != n)\n        quitf(_wa, \"Total number of nodes in participant's output is %d, expected %d\", total_nodes, n);\n    if ((int)participant_nodes.size() != n)\n        quitf(_wa, \"Participant's output does not include all nodes\");\n\n    // Compare comp_id and comp_id2\n    for (int u = 1; u <= n; u++) {\n        if (comp_id[u] != comp_id2[u]) {\n            quitf(_wa, \"Node %d is in component %d in the correct answer, but in component %d in participant's output\", u, comp_id[u], comp_id2[u]);\n        }\n    }\n\n    // All checks passed\n    quitf(_ok, \"Correct partition into connected components\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    const int MAX_M = 1000000;\n    int m;\n    vector<pair<int, int>> edges_on_map;\n\n    if (type == \"complete\") {\n        // m = 0\n        m = 0;\n        // No edges on map\n    } else if (type == \"empty\") {\n        // m = n*(n-1)/2, but n(n-1)/2 <= 1e6\n        if (n * (n - 1LL) / 2 > MAX_M) {\n            cerr << \"n too large for empty type\" << endl;\n            exit(1);\n        }\n        m = n * (n - 1) / 2;\n        // Generate all possible edges\n        for (int i = 1; i <= n; i++) {\n            for (int j = i + 1; j <= n; j++) {\n                edges_on_map.emplace_back(i, j);\n            }\n        }\n    } else if (type == \"path\") {\n        // n must be such that number of edges on map <= MAX_M\n        if (n * (n - 1LL) / 2 - (n - 1) > MAX_M) {\n            cerr << \"n too large for path type\" << endl;\n            exit(1);\n        }\n        // Actual graph is a path, so edges on map are all other pairs\n        m = n * (n - 1) / 2 - (n - 1);\n        set<pair<int, int>> edge_set;\n        for (int i = 1; i <= n; i++) {\n            for (int j = i + 1; j <= n; j++) {\n                edge_set.emplace(i, j);\n            }\n        }\n        for (int i = 1; i < n; i++) {\n            edge_set.erase({i, i + 1});\n        }\n        edges_on_map.assign(edge_set.begin(), edge_set.end());\n    } else if (type == \"star\") {\n        // n must be such that number of edges on map <= MAX_M\n        if (n * (n - 1LL) / 2 - (n - 1) > MAX_M) {\n            cerr << \"n too large for star type\" << endl;\n            exit(1);\n        }\n        m = n * (n - 1) / 2 - (n - 1);\n        set<pair<int, int>> edge_set;\n        for (int i = 2; i <= n; i++) {\n            for (int j = i + 1; j <= n; j++) {\n                edge_set.emplace(i, j);\n            }\n        }\n        edges_on_map.assign(edge_set.begin(), edge_set.end());\n    } else if (type == \"random\") {\n        m = opt<int>(\"m\", MAX_M);\n        if (m > MAX_M) {\n            cerr << \"m exceeds MAX_M\" << endl;\n            exit(1);\n        }\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            edge_set.emplace(u, v);\n        }\n        edges_on_map.assign(edge_set.begin(), edge_set.end());\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Shuffle edges\n    shuffle(edges_on_map.begin(), edges_on_map.end());\n    // Output edges\n    for (auto e : edges_on_map) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    const int MAX_M = 1000000;\n    int m;\n    vector<pair<int, int>> edges_on_map;\n\n    if (type == \"complete\") {\n        // m = 0\n        m = 0;\n        // No edges on map\n    } else if (type == \"empty\") {\n        // m = n*(n-1)/2, but n(n-1)/2 <= 1e6\n        if (n * (n - 1LL) / 2 > MAX_M) {\n            cerr << \"n too large for empty type\" << endl;\n            exit(1);\n        }\n        m = n * (n - 1) / 2;\n        // Generate all possible edges\n        for (int i = 1; i <= n; i++) {\n            for (int j = i + 1; j <= n; j++) {\n                edges_on_map.emplace_back(i, j);\n            }\n        }\n    } else if (type == \"path\") {\n        // n must be such that number of edges on map <= MAX_M\n        if (n * (n - 1LL) / 2 - (n - 1) > MAX_M) {\n            cerr << \"n too large for path type\" << endl;\n            exit(1);\n        }\n        // Actual graph is a path, so edges on map are all other pairs\n        m = n * (n - 1) / 2 - (n - 1);\n        set<pair<int, int>> edge_set;\n        for (int i = 1; i <= n; i++) {\n            for (int j = i + 1; j <= n; j++) {\n                edge_set.emplace(i, j);\n            }\n        }\n        for (int i = 1; i < n; i++) {\n            edge_set.erase({i, i + 1});\n        }\n        edges_on_map.assign(edge_set.begin(), edge_set.end());\n    } else if (type == \"star\") {\n        // n must be such that number of edges on map <= MAX_M\n        if (n * (n - 1LL) / 2 - (n - 1) > MAX_M) {\n            cerr << \"n too large for star type\" << endl;\n            exit(1);\n        }\n        m = n * (n - 1) / 2 - (n - 1);\n        set<pair<int, int>> edge_set;\n        for (int i = 2; i <= n; i++) {\n            for (int j = i + 1; j <= n; j++) {\n                edge_set.emplace(i, j);\n            }\n        }\n        edges_on_map.assign(edge_set.begin(), edge_set.end());\n    } else if (type == \"random\") {\n        m = opt<int>(\"m\", MAX_M);\n        if (m > MAX_M) {\n            cerr << \"m exceeds MAX_M\" << endl;\n            exit(1);\n        }\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            edge_set.emplace(u, v);\n        }\n        edges_on_map.assign(edge_set.begin(), edge_set.end());\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Shuffle edges\n    shuffle(edges_on_map.begin(), edges_on_map.end());\n    // Output edges\n    for (auto e : edges_on_map) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n tests (n=5)\n./gen -n 5 -type complete\n./gen -n 5 -type empty\n./gen -n 5 -type path\n./gen -n 5 -type star\n./gen -n 5 -type random -m 5\n\n# Medium n tests (n=100)\n./gen -n 100 -type complete\n./gen -n 100 -type empty\n./gen -n 100 -type path\n./gen -n 100 -type star\n./gen -n 100 -type random -m 500\n\n# n=1000\n./gen -n 1000 -type complete\n./gen -n 1000 -type random -m 5000\n\n# Max n for empty, path, star types (n=1414)\n./gen -n 1414 -type empty\n./gen -n 1414 -type path\n./gen -n 1414 -type star\n\n# n=10000\n./gen -n 10000 -type random -m 100000\n\n# Large n tests\n./gen -n 100000 -type complete\n./gen -n 100000 -type random -m 100000\n\n./gen -n 100000 -type random -m 1000000\n\n# Max n tests\n./gen -n 500000 -type random -m 1000000\n./gen -n 500000 -type complete\n\n# Edge cases\n# n=1\n./gen -n 1 -type complete\n\n# m=0\n./gen -n 100000 -type complete\n\n# m=max\n./gen -n 100000 -type random -m 1000000\n\n# m=1\n./gen -n 500000 -type random -m 1\n\n# m=50\n./gen -n 100000 -type random -m 50\n\n# m close to max\n./gen -n 500000 -type random -m 999999\n\n# m in middle\n./gen -n 500000 -type random -m 500000\n\n# Random tests with varying m\n./gen -n 500000 -type random -m 250000\n./gen -n 500000 -type random -m 750000\n./gen -n 500000 -type random -m 100000\n\n# Additional tests\n./gen -n 2 -type complete\n./gen -n 2 -type empty\n./gen -n 3 -type path\n./gen -n 3 -type star\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:10.948149",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "191/A",
      "title": "A. Dynasty Puzzles",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 5·105) — the number of names in Vasya's list. Next n lines contain n abbreviated names, one per line. An abbreviated name is a non-empty sequence of lowercase Latin letters. Its length does not exceed 10 characters.",
      "output_spec": "OutputPrint a single number — length of the sought dynasty's name in letters.If Vasya's list is wrong and no dynasty can be found there, print a single number 0.",
      "sample_tests": "ExamplesInputCopy3abccacbaOutputCopy6InputCopy4vvpvvpdamvvpOutputCopy0InputCopy3abcdefOutputCopy1",
      "description": "A. Dynasty Puzzles\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 5·105) — the number of names in Vasya's list. Next n lines contain n abbreviated names, one per line. An abbreviated name is a non-empty sequence of lowercase Latin letters. Its length does not exceed 10 characters.\n\nOutputPrint a single number — length of the sought dynasty's name in letters.If Vasya's list is wrong and no dynasty can be found there, print a single number 0.\n\nInputCopy3abccacbaOutputCopy6InputCopy4vvpvvpdamvvpOutputCopy0InputCopy3abcdefOutputCopy1\n\nInputCopy3abccacba\n\nOutputCopy6\n\nInputCopy4vvpvvpdamvvp\n\nOutputCopy0\n\nInputCopy3abcdef\n\nOutputCopy1\n\nNoteIn the first sample two dynasties can exist: the one called \"abcca\" (with the first and second kings) and the one called \"abccba\" (with the first and third kings). In the second sample there aren't acceptable dynasties.The only dynasty in the third sample consists of one king, his name is \"c\".",
      "solutions": [
        {
          "title": "Codeforces Round #121 - Codeforces",
          "content": "Hello, dear Codeforces community!I'm glad to present you the next Codeforces Round #121. The contest is brought to you by Ivan Smirnov (ifsmirnov) and Aleksandr Timin (AlTimin), the students of Moscow Institute of Physics and Technology. In our first round we will offer you a good time in Berland: you will hold a demonstration, prevent the demonstration, deal with the most important problems of Berland (with both of them!) and much more.We thank Gerald a lot for the invaluable help he gave as during the contest preparation. He is also the author of one task in the contest. We also thank Delinur for the English version of statements, Aksenov239 for proofreading the statements and MikeMirzayanov for an opportunity to hold a contest on this wonderful site.As usual, the contest will be held in both divisions and the problemsets will overlap. The scoring will be published later.We wish you good luck and hope that you enjoy the contest!UPD1: The scoring is classic in both divisions — 500-1000-1500-2000-2500.UPD2: The contest authors apologize to the contesters for a possibility of misunderstanding of problem B div 1 (D div 2). The statement was fixed soon enough and the incorrect understanding of the problem didn't pass pretests, so the round is rated.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4635",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1266
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces",
          "content": "Задача 192A - Модные числаКратко о решении: переборПодробно о решении: Нетрудно заметить, что это числа положительны, следовательно каждое из слагаемых меньше N. То есть всего различных возможных слагаемых порядка . Это значит то, что мы взять и одно из слагаемых перебрать. Тогда нам нужно научиться проверять, является ли какое-то число треугольным. Заметим, что если мы заранее выпишем все слагаемые в порядке увеличения то мы сможем с помощью бинарного поиска в массиве искать наше число. Это даем там решение за . Если перебирать первое слагаемое в порядке увеличения, то можно использовать два указателя, что дает нам решение за .Задача 192B - Прогулки под дождемКратко о решении: динамика.Подробно о решении: динамика d[i] — количество дней, в течении которых плитка номер i доступна. Пересчет: d[i] = min(a[i], max(d[i - 1], d[i - 2]))Асимптотика решения: O(N)Задача 191A - Династические головоломкиКратко о решении: динамикаПодробно о решении: динамика d[i][j], i — первый символ в имени династии, j — последний текущий символ. d[i][j] — максимальная текущая длина. Переход: для слова с первой буквой l, последней буквой r и длиной s для всех возможных первых букв i состояние d[i][r] может быть улучшено значением d[i][l] + s.Ответом будет являться максимальное значение d[i][i] для всех i.Асимптотика решения: O(N * alpha), где alpha — это размер алфавита.Задача 191B - МитингКратко о решении: конструктивПодробно о решении: заметим, что на последнюю площадь никогда не выгодно подавать заявку (денег мэрии не потратим, ничего не изменится, мы просто потеряем ход). Переберем площадь, на которой мы хотим провести митинг. У нас есть k - 1 ход на то, чтобы потратить деньги мэрии (один ход нам нужен на подачу заявки на искомую площадь). Тратить деньги выгоднее всего на самых дорогих площадях, за исключением последней. Осталось научиться быстро выбирать k - 1 максимум из всего массива, за исключением данного элемента. Для этого сначала отсортируем массив и получим k максимумов (последнюю площадь мы не должны рассматривать). Проверяем, лежит ли наше текущее значение в k - 1 максимальных (бинпоиск и не только). Если лежит, то искомые k - 1 максимумов — это максимальные k элементов без нашего. Если не лежит, то это просто максимальные k элементов. Теперь когда мы понимаем, сколько денег мэрии мы можем потратить, то тратим их и смотрим, остаются ли еще у мэрии деньги на проведение события на нашей текущей площадиАсимптотика решения: Задача 191C - Дураки и дорогиКратко о решении: lcaПодробно о решении: Разобьем каждый путь на два, строго идущих вверх к наименьшему общему предку. Теперь у нас есть только \"вертикальные пути\". Для каждой вершины насчитаем такую величину: количество вертикальных путей, начинающихся в ней минус количество вертикальных путей в ней заканчивающихся. Если мы насчитали эту величину, то ответ для ребра — это сумма значений в его поддереве. Насчитать такую величину довольно просто: берем для каждой пары дураков считаем lca этой пары. В города дураков прибавляем единичку, в lca значение уменьшаем на два.Асимптотика решения: Задача 191D - Схема метроКратко о решении: снова динамикаПодробно о решении: динамика d[v][rest][cycle] — количество линий, которое требуется для того, чтобы в поддереве вершины v все покрасить, в v остаются rest незамкнутым, cycle — правда ли, что нам надо обрабатывать цикл, в котором мы находимся. Если мы находимся не в вершине цикла, то обрабатываем всех детей, говоря что мы хотим, чтобы в них было по одному незакрытому пути. Пусть у нас есть s сыновей, нам надо взять и замкнуть все лишние линии, а недостающие нагенерить. То есть ответ это , если s > rest, и в противном случае.Если мы находимся в вершине цикла, то либо мы покрываем этот цикл кольцом и это стоит нам , где u — это вершина на цикле. отличная от v. Другой вариант — покрыть все участки кольца радиальными линиями. Утверждение: это всегда можно оптимально сделать ровно двумя радиальными. Пусть это не так. Тогда рассмотрим некоторую вершину, в которой радиальные линии <<подвешиваются>> к кольцу. От неё по кольцу в разные стороны уходят два тоннеля, принадлежащие этим линиям. Так как различных линий на кольце сейчас не менее трех, то мы можем перенаправить радиальные линии следующим образом: соединить куски вне кольца друг с другом, а кольцо замкнуть. На кольце останется не менее двух кусков, следовательно все линии останутся валидными, а их число не изменится. Теперь надо выбрать две станции, из поддерева которых будут выходить радиальные ветки, покрывшее кольцо. Стоимость такой станции это d[u][2][0], а обычной — d[u][0][0] (d[v][rest][0] в случае той вершины, которую мы сейчас обрабатываем) . Соответственно, нам надо выбрать две станции с максимальным значением d[u][2][0] - d[u][0][0].Асимптотика решения: O(N)Задача 191E - Разгон митинговКратко о решении: бинарный поиск по ответуПодробно о решении: Сделаем бинарный поиск по ответу. Нам надо посчитать количество отрезков, на которых сумма больше нашего некоторого значения. Как мы это будем делать: будем обрабатывать все отрезки в порядке увеличения правых концов. Отрезки с одинаковыми правыми концами будем обрабатывать пачками. Более подробно: мы будем поддерживать некоторую структуру данных в которой будут храниться суммы всех отрезков c фиксированным правым концом. Для того, чтобы быстро пересчитывать, нам нужно всего добавить в множество некоторый элемент ( 0, если точнее) и добавить ко всем элементам множества некоторое значение (a[i], если быть точнее). Еще нам нужно уметь отвечать на запрос <<количество элементов, больших данного на отрезке>>. Все это умеет быстро реализовывать, например, декартово дерево. Но нам придется дополнительно хранить некоторую величину X, означающую <<надо прибавить к элементу из декартова дерева X, чтобы получить реальное значение>>. Тогда при добавлении элемента a в нашу структуру надо будет положить в декартово дерево величину a - X, а прибавление некоторой величины ко всему множеству реализуется простым изменением X. То есть у нас есть структура данных, которая умеет все эти операции выполнять за . То есть одна итерация внешнего бинпоиска работает за , следовательно весь алгоритм работает за Асимптотика решения:",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4634",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 191\\s*A"
          },
          "content_length": 6193
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #121 - Codeforces - Code 1",
          "code": "return printf(\"%I64d\\n\",end+1), 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #121 - Codeforces - Code 2",
          "code": "return !printf(\"%I64d\\n\",end+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 1",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 2",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[a-z]{1,10}\", \"name\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[a-z]{1,10}\", \"name\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[a-z]{1,10}\", \"name\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> names(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 10);\n            string s;\n            for (int j = 0; j < len; ++j) {\n                s += (char)('a' + rnd.next(26));\n            }\n            names[i] = s;\n        }\n    }\n    else if (type == \"max_random\") {\n        for (int i = 0; i < n; ++i) {\n            int len = 10;\n            string s;\n            for (int j = 0; j < len; ++j) {\n                s += (char)('a' + rnd.next(26));\n            }\n            names[i] = s;\n        }\n    }\n    else if (type == \"big_cyclic\") {\n        // Generate a big cyclic dynasty using all n names\n\n        vector<char> first_letters(n);\n        vector<char> last_letters(n);\n\n        // Generate random last letters\n        for (int i = 0; i < n; ++i) {\n            last_letters[i] = (char)('a' + rnd.next(26));\n        }\n\n        // Set first letter of each name to match last letter of previous name\n        for (int i = 1; i < n; ++i) {\n            first_letters[i] = last_letters[i - 1];\n        }\n        // Ensure the first letter of first name equals last letter of last name\n        first_letters[0] = last_letters[n - 1];\n\n        // Now generate names accordingly\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(2, 10); // Length at least 2 to have distinct first and last letters\n            string s;\n            s += first_letters[i];\n            for (int j = 1; j < len - 1; ++j) {\n                s += (char)('a' + rnd.next(26));\n            }\n            s += last_letters[i];\n            names[i] = s;\n        }\n    }\n    else if (type == \"no_solution\") {\n        // Generate names where no dynasty can be formed\n        // No names with first letter equal to last letter\n        // So any name has first and last letters different\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(2, 10); // Length at least 2 to have distinct first and last letters\n            char first, last;\n            do {\n                first = (char)('a' + rnd.next(26));\n                last = (char)('a' + rnd.next(26));\n            } while (first == last);\n            string s;\n            s += first;\n            for (int j = 1; j < len - 1; ++j) {\n                s += (char)('a' + rnd.next(26));\n            }\n            s += last;\n            names[i] = s;\n        }\n    }\n    else if (type == \"single_name\") {\n        // Only possible dynasty is a single name\n        // So generate names where only a name(s) with first letter equal to last letter\n        // In addition, all other names can't be connected to this one\n        int special_index = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            if (i == special_index) {\n                // Generate a name with first and last letter same\n                int len = rnd.next(1, 10);\n                char ch = (char)('a' + rnd.next(26));\n                string s;\n                s += ch;\n                for (int j = 1; j < len - 1; ++j) {\n                    s += (char)('a' + rnd.next(26));\n                }\n                if (len > 1) {\n                    s += ch;\n                }\n                names[i] = s;\n            } else {\n                // Generate names where first and last letters are different from ch\n                int len = rnd.next(2, 10); // Length at least 2\n                char first, last;\n                char ch = names[special_index][0];\n                do {\n                    first = (char)('a' + rnd.next(26));\n                } while (first == ch);\n                do {\n                    last = (char)('a' + rnd.next(26));\n                } while (last == ch || last == first);\n                string s;\n                s += first;\n                for (int j = 1; j < len - 1; ++j) {\n                    s += (char)('a' + rnd.next(26));\n                }\n                s += last;\n                names[i] = s;\n            }\n        }\n    }\n    else if (type == \"max_repeat\") {\n        // Generate names that repeat many times\n        // Possibly to test if contestants handle duplicates properly\n        string s;\n        int len = 10;\n        for (int j = 0; j < len; ++j) {\n            s += (char)('a' + rnd.next(26));\n        }\n        for (int i = 0; i < n; ++i) {\n            names[i] = s;\n        }\n    }\n    else {\n        // Default random\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 10);\n            string s;\n            for (int j = 0; j < len; ++j) {\n                s += (char)('a' + rnd.next(26));\n            }\n            names[i] = s;\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", names[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> names(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 10);\n            string s;\n            for (int j = 0; j < len; ++j) {\n                s += (char)('a' + rnd.next(26));\n            }\n            names[i] = s;\n        }\n    }\n    else if (type == \"max_random\") {\n        for (int i = 0; i < n; ++i) {\n            int len = 10;\n            string s;\n            for (int j = 0; j < len; ++j) {\n                s += (char)('a' + rnd.next(26));\n            }\n            names[i] = s;\n        }\n    }\n    else if (type == \"big_cyclic\") {\n        // Generate a big cyclic dynasty using all n names\n\n        vector<char> first_letters(n);\n        vector<char> last_letters(n);\n\n        // Generate random last letters\n        for (int i = 0; i < n; ++i) {\n            last_letters[i] = (char)('a' + rnd.next(26));\n        }\n\n        // Set first letter of each name to match last letter of previous name\n        for (int i = 1; i < n; ++i) {\n            first_letters[i] = last_letters[i - 1];\n        }\n        // Ensure the first letter of first name equals last letter of last name\n        first_letters[0] = last_letters[n - 1];\n\n        // Now generate names accordingly\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(2, 10); // Length at least 2 to have distinct first and last letters\n            string s;\n            s += first_letters[i];\n            for (int j = 1; j < len - 1; ++j) {\n                s += (char)('a' + rnd.next(26));\n            }\n            s += last_letters[i];\n            names[i] = s;\n        }\n    }\n    else if (type == \"no_solution\") {\n        // Generate names where no dynasty can be formed\n        // No names with first letter equal to last letter\n        // So any name has first and last letters different\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(2, 10); // Length at least 2 to have distinct first and last letters\n            char first, last;\n            do {\n                first = (char)('a' + rnd.next(26));\n                last = (char)('a' + rnd.next(26));\n            } while (first == last);\n            string s;\n            s += first;\n            for (int j = 1; j < len - 1; ++j) {\n                s += (char)('a' + rnd.next(26));\n            }\n            s += last;\n            names[i] = s;\n        }\n    }\n    else if (type == \"single_name\") {\n        // Only possible dynasty is a single name\n        // So generate names where only a name(s) with first letter equal to last letter\n        // In addition, all other names can't be connected to this one\n        int special_index = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            if (i == special_index) {\n                // Generate a name with first and last letter same\n                int len = rnd.next(1, 10);\n                char ch = (char)('a' + rnd.next(26));\n                string s;\n                s += ch;\n                for (int j = 1; j < len - 1; ++j) {\n                    s += (char)('a' + rnd.next(26));\n                }\n                if (len > 1) {\n                    s += ch;\n                }\n                names[i] = s;\n            } else {\n                // Generate names where first and last letters are different from ch\n                int len = rnd.next(2, 10); // Length at least 2\n                char first, last;\n                char ch = names[special_index][0];\n                do {\n                    first = (char)('a' + rnd.next(26));\n                } while (first == ch);\n                do {\n                    last = (char)('a' + rnd.next(26));\n                } while (last == ch || last == first);\n                string s;\n                s += first;\n                for (int j = 1; j < len - 1; ++j) {\n                    s += (char)('a' + rnd.next(26));\n                }\n                s += last;\n                names[i] = s;\n            }\n        }\n    }\n    else if (type == \"max_repeat\") {\n        // Generate names that repeat many times\n        // Possibly to test if contestants handle duplicates properly\n        string s;\n        int len = 10;\n        for (int j = 0; j < len; ++j) {\n            s += (char)('a' + rnd.next(26));\n        }\n        for (int i = 0; i < n; ++i) {\n            names[i] = s;\n        }\n    }\n    else {\n        // Default random\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 10);\n            string s;\n            for (int j = 0; j < len; ++j) {\n                s += (char)('a' + rnd.next(26));\n            }\n            names[i] = s;\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", names[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type random\n./gen -n 5 -type no_solution\n./gen -n 5 -type single_name\n./gen -n 5 -type big_cyclic\n./gen -n 10 -type random\n./gen -n 10 -type no_solution\n./gen -n 10 -type single_name\n./gen -n 10 -type big_cyclic\n./gen -n 50 -type random\n./gen -n 50 -type no_solution\n./gen -n 50 -type single_name\n./gen -n 50 -type big_cyclic\n./gen -n 100 -type random\n./gen -n 100 -type no_solution\n./gen -n 100 -type single_name\n./gen -n 100 -type big_cyclic\n./gen -n 1000 -type random\n./gen -n 1000 -type no_solution\n./gen -n 1000 -type single_name\n./gen -n 1000 -type big_cyclic\n./gen -n 5000 -type random\n./gen -n 5000 -type max_random\n./gen -n 5000 -type max_repeat\n./gen -n 5000 -type big_cyclic\n./gen -n 10000 -type random\n./gen -n 10000 -type no_solution\n./gen -n 10000 -type single_name\n./gen -n 10000 -type big_cyclic\n./gen -n 500000 -type random\n./gen -n 500000 -type max_random\n./gen -n 500000 -type max_repeat\n./gen -n 500000 -type big_cyclic\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:12.947602",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "191/B",
      "title": "B. Demonstration",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k — the number of squares and days left before the meeting, correspondingly (1 ≤ k < n ≤ 105).The second line contains a single integer b — the number of bourles the administration has (1 ≤ b ≤ 1018).The third line contains n space-separated integers ai — the sum of money, needed to organise an event on square i (1 ≤ ai ≤ 109).Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "output_spec": "OutputPrint a single number — the minimum number of the square where the opposition can organize the demonstration.",
      "sample_tests": "ExamplesInputCopy5 282 4 5 3 1OutputCopy2InputCopy5 283 2 4 1 5OutputCopy5InputCopy5 410000000000000005 4 3 2 1OutputCopy5",
      "description": "B. Demonstration\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k — the number of squares and days left before the meeting, correspondingly (1 ≤ k < n ≤ 105).The second line contains a single integer b — the number of bourles the administration has (1 ≤ b ≤ 1018).The third line contains n space-separated integers ai — the sum of money, needed to organise an event on square i (1 ≤ ai ≤ 109).Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nOutputPrint a single number — the minimum number of the square where the opposition can organize the demonstration.\n\nInputCopy5 282 4 5 3 1OutputCopy2InputCopy5 283 2 4 1 5OutputCopy5InputCopy5 410000000000000005 4 3 2 1OutputCopy5\n\nInputCopy5 282 4 5 3 1\n\nOutputCopy2\n\nInputCopy5 283 2 4 1 5\n\nOutputCopy5\n\nInputCopy5 410000000000000005 4 3 2 1\n\nOutputCopy5\n\nNoteIn the first sample the opposition can act like this. On day one it applies for square 3. The administration has to organize an event there and end up with 3 bourles. If on the second day the opposition applies for square 2, the administration won't have the money to intervene.In the second sample the opposition has only the chance for the last square. If its first move occupies one of the first four squares, the administration is left with at least 4 bourles, which means that next day it can use its next move to move the opposition from any square to the last one.In the third sample administration has a lot of money, so opposition can occupy only last square.",
      "solutions": [
        {
          "title": "Codeforces Round #121 - Codeforces",
          "content": "Hello, dear Codeforces community!I'm glad to present you the next Codeforces Round #121. The contest is brought to you by Ivan Smirnov (ifsmirnov) and Aleksandr Timin (AlTimin), the students of Moscow Institute of Physics and Technology. In our first round we will offer you a good time in Berland: you will hold a demonstration, prevent the demonstration, deal with the most important problems of Berland (with both of them!) and much more.We thank Gerald a lot for the invaluable help he gave as during the contest preparation. He is also the author of one task in the contest. We also thank Delinur for the English version of statements, Aksenov239 for proofreading the statements and MikeMirzayanov for an opportunity to hold a contest on this wonderful site.As usual, the contest will be held in both divisions and the problemsets will overlap. The scoring will be published later.We wish you good luck and hope that you enjoy the contest!UPD1: The scoring is classic in both divisions — 500-1000-1500-2000-2500.UPD2: The contest authors apologize to the contesters for a possibility of misunderstanding of problem B div 1 (D div 2). The statement was fixed soon enough and the incorrect understanding of the problem didn't pass pretests, so the round is rated.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4635",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1266
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces",
          "content": "Задача 192A - Модные числаКратко о решении: переборПодробно о решении: Нетрудно заметить, что это числа положительны, следовательно каждое из слагаемых меньше N. То есть всего различных возможных слагаемых порядка . Это значит то, что мы взять и одно из слагаемых перебрать. Тогда нам нужно научиться проверять, является ли какое-то число треугольным. Заметим, что если мы заранее выпишем все слагаемые в порядке увеличения то мы сможем с помощью бинарного поиска в массиве искать наше число. Это даем там решение за . Если перебирать первое слагаемое в порядке увеличения, то можно использовать два указателя, что дает нам решение за .Задача 192B - Прогулки под дождемКратко о решении: динамика.Подробно о решении: динамика d[i] — количество дней, в течении которых плитка номер i доступна. Пересчет: d[i] = min(a[i], max(d[i - 1], d[i - 2]))Асимптотика решения: O(N)Задача 191A - Династические головоломкиКратко о решении: динамикаПодробно о решении: динамика d[i][j], i — первый символ в имени династии, j — последний текущий символ. d[i][j] — максимальная текущая длина. Переход: для слова с первой буквой l, последней буквой r и длиной s для всех возможных первых букв i состояние d[i][r] может быть улучшено значением d[i][l] + s.Ответом будет являться максимальное значение d[i][i] для всех i.Асимптотика решения: O(N * alpha), где alpha — это размер алфавита.Задача 191B - МитингКратко о решении: конструктивПодробно о решении: заметим, что на последнюю площадь никогда не выгодно подавать заявку (денег мэрии не потратим, ничего не изменится, мы просто потеряем ход). Переберем площадь, на которой мы хотим провести митинг. У нас есть k - 1 ход на то, чтобы потратить деньги мэрии (один ход нам нужен на подачу заявки на искомую площадь). Тратить деньги выгоднее всего на самых дорогих площадях, за исключением последней. Осталось научиться быстро выбирать k - 1 максимум из всего массива, за исключением данного элемента. Для этого сначала отсортируем массив и получим k максимумов (последнюю площадь мы не должны рассматривать). Проверяем, лежит ли наше текущее значение в k - 1 максимальных (бинпоиск и не только). Если лежит, то искомые k - 1 максимумов — это максимальные k элементов без нашего. Если не лежит, то это просто максимальные k элементов. Теперь когда мы понимаем, сколько денег мэрии мы можем потратить, то тратим их и смотрим, остаются ли еще у мэрии деньги на проведение события на нашей текущей площадиАсимптотика решения: Задача 191C - Дураки и дорогиКратко о решении: lcaПодробно о решении: Разобьем каждый путь на два, строго идущих вверх к наименьшему общему предку. Теперь у нас есть только \"вертикальные пути\". Для каждой вершины насчитаем такую величину: количество вертикальных путей, начинающихся в ней минус количество вертикальных путей в ней заканчивающихся. Если мы насчитали эту величину, то ответ для ребра — это сумма значений в его поддереве. Насчитать такую величину довольно просто: берем для каждой пары дураков считаем lca этой пары. В города дураков прибавляем единичку, в lca значение уменьшаем на два.Асимптотика решения: Задача 191D - Схема метроКратко о решении: снова динамикаПодробно о решении: динамика d[v][rest][cycle] — количество линий, которое требуется для того, чтобы в поддереве вершины v все покрасить, в v остаются rest незамкнутым, cycle — правда ли, что нам надо обрабатывать цикл, в котором мы находимся. Если мы находимся не в вершине цикла, то обрабатываем всех детей, говоря что мы хотим, чтобы в них было по одному незакрытому пути. Пусть у нас есть s сыновей, нам надо взять и замкнуть все лишние линии, а недостающие нагенерить. То есть ответ это , если s > rest, и в противном случае.Если мы находимся в вершине цикла, то либо мы покрываем этот цикл кольцом и это стоит нам , где u — это вершина на цикле. отличная от v. Другой вариант — покрыть все участки кольца радиальными линиями. Утверждение: это всегда можно оптимально сделать ровно двумя радиальными. Пусть это не так. Тогда рассмотрим некоторую вершину, в которой радиальные линии <<подвешиваются>> к кольцу. От неё по кольцу в разные стороны уходят два тоннеля, принадлежащие этим линиям. Так как различных линий на кольце сейчас не менее трех, то мы можем перенаправить радиальные линии следующим образом: соединить куски вне кольца друг с другом, а кольцо замкнуть. На кольце останется не менее двух кусков, следовательно все линии останутся валидными, а их число не изменится. Теперь надо выбрать две станции, из поддерева которых будут выходить радиальные ветки, покрывшее кольцо. Стоимость такой станции это d[u][2][0], а обычной — d[u][0][0] (d[v][rest][0] в случае той вершины, которую мы сейчас обрабатываем) . Соответственно, нам надо выбрать две станции с максимальным значением d[u][2][0] - d[u][0][0].Асимптотика решения: O(N)Задача 191E - Разгон митинговКратко о решении: бинарный поиск по ответуПодробно о решении: Сделаем бинарный поиск по ответу. Нам надо посчитать количество отрезков, на которых сумма больше нашего некоторого значения. Как мы это будем делать: будем обрабатывать все отрезки в порядке увеличения правых концов. Отрезки с одинаковыми правыми концами будем обрабатывать пачками. Более подробно: мы будем поддерживать некоторую структуру данных в которой будут храниться суммы всех отрезков c фиксированным правым концом. Для того, чтобы быстро пересчитывать, нам нужно всего добавить в множество некоторый элемент ( 0, если точнее) и добавить ко всем элементам множества некоторое значение (a[i], если быть точнее). Еще нам нужно уметь отвечать на запрос <<количество элементов, больших данного на отрезке>>. Все это умеет быстро реализовывать, например, декартово дерево. Но нам придется дополнительно хранить некоторую величину X, означающую <<надо прибавить к элементу из декартова дерева X, чтобы получить реальное значение>>. Тогда при добавлении элемента a в нашу структуру надо будет положить в декартово дерево величину a - X, а прибавление некоторой величины ко всему множеству реализуется простым изменением X. То есть у нас есть структура данных, которая умеет все эти операции выполнять за . То есть одна итерация внешнего бинпоиска работает за , следовательно весь алгоритм работает за Асимптотика решения:",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4634",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 191\\s*B"
          },
          "content_length": 6193
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #121 - Codeforces - Code 1",
          "code": "return printf(\"%I64d\\n\",end+1), 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #121 - Codeforces - Code 2",
          "code": "return !printf(\"%I64d\\n\",end+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 1",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 2",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n\n    long long b = inf.readLong(1, 1000000000000000000LL, \"b\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n\n    long long b = inf.readLong(1, 1000000000000000000LL, \"b\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n\n    long long b = inf.readLong(1, 1000000000000000000LL, \"b\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    long long b = opt<long long>(\"b\", -1);\n    string atype = opt<string>(\"atype\", \"random\");\n    int mina = opt<int>(\"mina\", 1);\n    int maxa = opt<int>(\"maxa\", int(1e9));\n\n    vector<int> a(n);\n\n    long long sum_a = 0;\n\n    if (atype == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(mina, maxa);\n            sum_a += a[i];\n        }\n    } else if (atype == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = mina;\n            sum_a += a[i];\n        }\n    } else if (atype == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = maxa;\n            sum_a += a[i];\n        }\n    } else if (atype == \"ascending\") {\n        a[0] = rnd.next(mina, maxa);\n        sum_a += a[0];\n        for (int i = 1; i < n; ++i) {\n            a[i] = min(a[i - 1] + rnd.next(0, (maxa - a[i - 1]) / 10 + 1), maxa);\n            sum_a += a[i];\n        }\n    } else if (atype == \"descending\") {\n        a[0] = rnd.next(mina, maxa);\n        sum_a += a[0];\n        for (int i = 1; i < n; ++i) {\n            a[i] = max(a[i - 1] - rnd.next(0, (a[i - 1] - mina) / 10 + 1), mina);\n            sum_a += a[i];\n        }\n    } else if (atype == \"constant\") {\n        int val = rnd.next(mina, maxa);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            sum_a += a[i];\n        }\n    } else if (atype == \"worst_case1\") {\n        // Opposition must accept worst square\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = 1;\n            sum_a += a[i];\n        }\n        a[n - 1] = int(1e9);\n        sum_a += a[n - 1];\n        if (b == -1) {\n            b = sum_a - 1; // Administration can block all squares except worst\n            if (b < 1) b = 1;\n        }\n    } else if (atype == \"sum_b_minus_one\") {\n        // Generate a_i in [mina, maxa], set b = sum_a - 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(mina, maxa);\n            sum_a += a[i];\n        }\n        if (b == -1) {\n            b = sum_a - 1;\n            if (b < 1) b = 1;\n        }\n    } else {\n        fprintf(stderr, \"Unknown atype: %s\\n\", atype.c_str());\n        return 1;\n    }\n\n    if (b == -1) {\n        b = rnd.next(1LL, 1000000000000000000LL);\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%lld\\n\", b);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    long long b = opt<long long>(\"b\", -1);\n    string atype = opt<string>(\"atype\", \"random\");\n    int mina = opt<int>(\"mina\", 1);\n    int maxa = opt<int>(\"maxa\", int(1e9));\n\n    vector<int> a(n);\n\n    long long sum_a = 0;\n\n    if (atype == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(mina, maxa);\n            sum_a += a[i];\n        }\n    } else if (atype == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = mina;\n            sum_a += a[i];\n        }\n    } else if (atype == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = maxa;\n            sum_a += a[i];\n        }\n    } else if (atype == \"ascending\") {\n        a[0] = rnd.next(mina, maxa);\n        sum_a += a[0];\n        for (int i = 1; i < n; ++i) {\n            a[i] = min(a[i - 1] + rnd.next(0, (maxa - a[i - 1]) / 10 + 1), maxa);\n            sum_a += a[i];\n        }\n    } else if (atype == \"descending\") {\n        a[0] = rnd.next(mina, maxa);\n        sum_a += a[0];\n        for (int i = 1; i < n; ++i) {\n            a[i] = max(a[i - 1] - rnd.next(0, (a[i - 1] - mina) / 10 + 1), mina);\n            sum_a += a[i];\n        }\n    } else if (atype == \"constant\") {\n        int val = rnd.next(mina, maxa);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            sum_a += a[i];\n        }\n    } else if (atype == \"worst_case1\") {\n        // Opposition must accept worst square\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = 1;\n            sum_a += a[i];\n        }\n        a[n - 1] = int(1e9);\n        sum_a += a[n - 1];\n        if (b == -1) {\n            b = sum_a - 1; // Administration can block all squares except worst\n            if (b < 1) b = 1;\n        }\n    } else if (atype == \"sum_b_minus_one\") {\n        // Generate a_i in [mina, maxa], set b = sum_a - 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(mina, maxa);\n            sum_a += a[i];\n        }\n        if (b == -1) {\n            b = sum_a - 1;\n            if (b < 1) b = 1;\n        }\n    } else {\n        fprintf(stderr, \"Unknown atype: %s\\n\", atype.c_str());\n        return 1;\n    }\n\n    if (b == -1) {\n        b = rnd.next(1LL, 1000000000000000000LL);\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%lld\\n\", b);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -k 2 -atype random\n\n./gen -n 100000 -k 99999 -atype random -b 1000000000000000000\n\n./gen -n 100000 -k 1 -atype random -b 1000000000000000000\n\n./gen -n 100000 -k 50000 -atype min -b 1000000000000000000\n\n./gen -n 100000 -k 50000 -atype max -b 1000000000000000000\n\n./gen -n 10 -k 5 -atype descending\n\n./gen -n 10 -k 5 -atype ascending\n\n./gen -n 10 -k 5 -atype constant\n\n./gen -n 100000 -k 1 -atype constant\n\n./gen -n 100000 -k 99999 -atype descending\n\n./gen -n 100000 -k 50000 -atype worst_case1\n\n./gen -n 100000 -k 99999 -atype random -b 0\n\n./gen -n 100000 -k 1 -atype random -b 1\n\n./gen -n 5 -k 1 -atype random -b 1\n\n./gen -n 100000 -k 1 -atype min -b 99999\n\n./gen -n 100000 -k 99999 -atype max -b 100000000000000\n\n./gen -n 100000 -k 1 -atype ascending\n\n./gen -n 100000 -k 1 -atype descending\n\n./gen -n 100000 -k 99999 -atype ascending\n\n./gen -n 2 -k 1 -atype random\n\n./gen -n 2 -k 1 -atype min\n\n./gen -n 2 -k 1 -atype max\n\n./gen -n 100000 -k 99999 -atype max -b 100000000000000\n\n./gen -n 100000 -k 99999 -atype max -b 1\n\n./gen -n 100000 -k 1 -atype min -b 1000000000000000000\n\n./gen -n 100000 -k 99999 -atype random\n\n./gen -n 100000 -k 99999 -atype sum_b_minus_one -mina 1 -maxa 10\n\n./gen -n 100000 -k 50000 -atype sum_b_minus_one -mina 1 -maxa 10000000\n\n./gen -n 100000 -k 99999 -atype min -b 1\n\n./gen -n 100000 -k 1 -atype sum_b_minus_one -mina 1 -maxa 1000000000\n\n./gen -n 100000 -k 99999 -atype sum_b_minus_one -mina 1 -maxa 1000000000\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:15.063187",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "191/C",
      "title": "C. Fools and Roads",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (2 ≤ n ≤ 105) — the number of cities. Each of the next n - 1 lines contains two space-separated integers ui, vi (1 ≤ ui, vi ≤ n, ui ≠ vi), that means that there is a road connecting cities ui and vi. The next line contains integer k (0 ≤ k ≤ 105) — the number of pairs of fools who visit each other. Next k lines contain two space-separated numbers. The i-th line (i > 0) contains numbers ai, bi (1 ≤ ai, bi ≤ n). That means that the fool number 2i - 1 lives in city ai and visits the fool number 2i, who lives in city bi. The given pairs describe simple paths, because between every pair of cities there is only one simple path.",
      "output_spec": "OutputPrint n - 1 integer. The integers should be separated by spaces. The i-th number should equal the number of fools who can go on the i-th road. The roads are numbered starting from one in the order, in which they occur in the input.",
      "sample_tests": "ExamplesInputCopy51 21 32 42 521 43 5OutputCopy2 1 1 1 InputCopy53 44 51 42 432 31 33 5OutputCopy3 1 1 1",
      "description": "C. Fools and Roads\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (2 ≤ n ≤ 105) — the number of cities. Each of the next n - 1 lines contains two space-separated integers ui, vi (1 ≤ ui, vi ≤ n, ui ≠ vi), that means that there is a road connecting cities ui and vi. The next line contains integer k (0 ≤ k ≤ 105) — the number of pairs of fools who visit each other. Next k lines contain two space-separated numbers. The i-th line (i > 0) contains numbers ai, bi (1 ≤ ai, bi ≤ n). That means that the fool number 2i - 1 lives in city ai and visits the fool number 2i, who lives in city bi. The given pairs describe simple paths, because between every pair of cities there is only one simple path.\n\nOutputPrint n - 1 integer. The integers should be separated by spaces. The i-th number should equal the number of fools who can go on the i-th road. The roads are numbered starting from one in the order, in which they occur in the input.\n\nInputCopy51 21 32 42 521 43 5OutputCopy2 1 1 1 InputCopy53 44 51 42 432 31 33 5OutputCopy3 1 1 1\n\nInputCopy51 21 32 42 521 43 5\n\nOutputCopy2 1 1 1\n\nInputCopy53 44 51 42 432 31 33 5\n\nOutputCopy3 1 1 1\n\nNoteIn the first sample the fool number one goes on the first and third road and the fool number 3 goes on the second, first and fourth ones.In the second sample, the fools number 1, 3 and 5 go on the first road, the fool number 5 will go on the second road, on the third road goes the fool number 3, and on the fourth one goes fool number 1.",
      "solutions": [
        {
          "title": "Codeforces Round #121 - Codeforces",
          "content": "Hello, dear Codeforces community!I'm glad to present you the next Codeforces Round #121. The contest is brought to you by Ivan Smirnov (ifsmirnov) and Aleksandr Timin (AlTimin), the students of Moscow Institute of Physics and Technology. In our first round we will offer you a good time in Berland: you will hold a demonstration, prevent the demonstration, deal with the most important problems of Berland (with both of them!) and much more.We thank Gerald a lot for the invaluable help he gave as during the contest preparation. He is also the author of one task in the contest. We also thank Delinur for the English version of statements, Aksenov239 for proofreading the statements and MikeMirzayanov for an opportunity to hold a contest on this wonderful site.As usual, the contest will be held in both divisions and the problemsets will overlap. The scoring will be published later.We wish you good luck and hope that you enjoy the contest!UPD1: The scoring is classic in both divisions — 500-1000-1500-2000-2500.UPD2: The contest authors apologize to the contesters for a possibility of misunderstanding of problem B div 1 (D div 2). The statement was fixed soon enough and the incorrect understanding of the problem didn't pass pretests, so the round is rated.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4635",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1266
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces",
          "content": "Задача 192A - Модные числаКратко о решении: переборПодробно о решении: Нетрудно заметить, что это числа положительны, следовательно каждое из слагаемых меньше N. То есть всего различных возможных слагаемых порядка . Это значит то, что мы взять и одно из слагаемых перебрать. Тогда нам нужно научиться проверять, является ли какое-то число треугольным. Заметим, что если мы заранее выпишем все слагаемые в порядке увеличения то мы сможем с помощью бинарного поиска в массиве искать наше число. Это даем там решение за . Если перебирать первое слагаемое в порядке увеличения, то можно использовать два указателя, что дает нам решение за .Задача 192B - Прогулки под дождемКратко о решении: динамика.Подробно о решении: динамика d[i] — количество дней, в течении которых плитка номер i доступна. Пересчет: d[i] = min(a[i], max(d[i - 1], d[i - 2]))Асимптотика решения: O(N)Задача 191A - Династические головоломкиКратко о решении: динамикаПодробно о решении: динамика d[i][j], i — первый символ в имени династии, j — последний текущий символ. d[i][j] — максимальная текущая длина. Переход: для слова с первой буквой l, последней буквой r и длиной s для всех возможных первых букв i состояние d[i][r] может быть улучшено значением d[i][l] + s.Ответом будет являться максимальное значение d[i][i] для всех i.Асимптотика решения: O(N * alpha), где alpha — это размер алфавита.Задача 191B - МитингКратко о решении: конструктивПодробно о решении: заметим, что на последнюю площадь никогда не выгодно подавать заявку (денег мэрии не потратим, ничего не изменится, мы просто потеряем ход). Переберем площадь, на которой мы хотим провести митинг. У нас есть k - 1 ход на то, чтобы потратить деньги мэрии (один ход нам нужен на подачу заявки на искомую площадь). Тратить деньги выгоднее всего на самых дорогих площадях, за исключением последней. Осталось научиться быстро выбирать k - 1 максимум из всего массива, за исключением данного элемента. Для этого сначала отсортируем массив и получим k максимумов (последнюю площадь мы не должны рассматривать). Проверяем, лежит ли наше текущее значение в k - 1 максимальных (бинпоиск и не только). Если лежит, то искомые k - 1 максимумов — это максимальные k элементов без нашего. Если не лежит, то это просто максимальные k элементов. Теперь когда мы понимаем, сколько денег мэрии мы можем потратить, то тратим их и смотрим, остаются ли еще у мэрии деньги на проведение события на нашей текущей площадиАсимптотика решения: Задача 191C - Дураки и дорогиКратко о решении: lcaПодробно о решении: Разобьем каждый путь на два, строго идущих вверх к наименьшему общему предку. Теперь у нас есть только \"вертикальные пути\". Для каждой вершины насчитаем такую величину: количество вертикальных путей, начинающихся в ней минус количество вертикальных путей в ней заканчивающихся. Если мы насчитали эту величину, то ответ для ребра — это сумма значений в его поддереве. Насчитать такую величину довольно просто: берем для каждой пары дураков считаем lca этой пары. В города дураков прибавляем единичку, в lca значение уменьшаем на два.Асимптотика решения: Задача 191D - Схема метроКратко о решении: снова динамикаПодробно о решении: динамика d[v][rest][cycle] — количество линий, которое требуется для того, чтобы в поддереве вершины v все покрасить, в v остаются rest незамкнутым, cycle — правда ли, что нам надо обрабатывать цикл, в котором мы находимся. Если мы находимся не в вершине цикла, то обрабатываем всех детей, говоря что мы хотим, чтобы в них было по одному незакрытому пути. Пусть у нас есть s сыновей, нам надо взять и замкнуть все лишние линии, а недостающие нагенерить. То есть ответ это , если s > rest, и в противном случае.Если мы находимся в вершине цикла, то либо мы покрываем этот цикл кольцом и это стоит нам , где u — это вершина на цикле. отличная от v. Другой вариант — покрыть все участки кольца радиальными линиями. Утверждение: это всегда можно оптимально сделать ровно двумя радиальными. Пусть это не так. Тогда рассмотрим некоторую вершину, в которой радиальные линии <<подвешиваются>> к кольцу. От неё по кольцу в разные стороны уходят два тоннеля, принадлежащие этим линиям. Так как различных линий на кольце сейчас не менее трех, то мы можем перенаправить радиальные линии следующим образом: соединить куски вне кольца друг с другом, а кольцо замкнуть. На кольце останется не менее двух кусков, следовательно все линии останутся валидными, а их число не изменится. Теперь надо выбрать две станции, из поддерева которых будут выходить радиальные ветки, покрывшее кольцо. Стоимость такой станции это d[u][2][0], а обычной — d[u][0][0] (d[v][rest][0] в случае той вершины, которую мы сейчас обрабатываем) . Соответственно, нам надо выбрать две станции с максимальным значением d[u][2][0] - d[u][0][0].Асимптотика решения: O(N)Задача 191E - Разгон митинговКратко о решении: бинарный поиск по ответуПодробно о решении: Сделаем бинарный поиск по ответу. Нам надо посчитать количество отрезков, на которых сумма больше нашего некоторого значения. Как мы это будем делать: будем обрабатывать все отрезки в порядке увеличения правых концов. Отрезки с одинаковыми правыми концами будем обрабатывать пачками. Более подробно: мы будем поддерживать некоторую структуру данных в которой будут храниться суммы всех отрезков c фиксированным правым концом. Для того, чтобы быстро пересчитывать, нам нужно всего добавить в множество некоторый элемент ( 0, если точнее) и добавить ко всем элементам множества некоторое значение (a[i], если быть точнее). Еще нам нужно уметь отвечать на запрос <<количество элементов, больших данного на отрезке>>. Все это умеет быстро реализовывать, например, декартово дерево. Но нам придется дополнительно хранить некоторую величину X, означающую <<надо прибавить к элементу из декартова дерева X, чтобы получить реальное значение>>. Тогда при добавлении элемента a в нашу структуру надо будет положить в декартово дерево величину a - X, а прибавление некоторой величины ко всему множеству реализуется простым изменением X. То есть у нас есть структура данных, которая умеет все эти операции выполнять за . То есть одна итерация внешнего бинпоиска работает за , следовательно весь алгоритм работает за Асимптотика решения:",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4634",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 191\\s*C"
          },
          "content_length": 6193
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #121 - Codeforces - Code 1",
          "code": "return printf(\"%I64d\\n\",end+1), 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #121 - Codeforces - Code 2",
          "code": "return !printf(\"%I64d\\n\",end+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 1",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 2",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, MAXN, \"n\");\n    inf.readEoln();\n\n    vector<pair<int,int>> edges;\n\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u[\" + to_string(i + 1) + \"]\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v[\" + to_string(i + 1) + \"]\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge %d connects a node to itself: %d == %d\", i + 1, u, v);\n\n        edges.push_back({u, v});\n    }\n\n    // Union-Find to check for cycles and connectedness\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++) parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        return parent[x] == x ? x : parent[x] = find(parent[x]);\n    };\n\n    for (int i = 0; i < edges.size(); i++) {\n        int u = edges[i].first, v = edges[i].second;\n        int pu = find(u), pv = find(v);\n        ensuref(pu != pv, \"Graph contains a cycle with edge %d connecting nodes %d and %d\", i + 1, u, v);\n        parent[pu] = pv;\n    }\n\n    int k = inf.readInt(0, MAXN, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; i++) {\n        int a = inf.readInt(1, n, \"a[\" + to_string(i + 1) + \"]\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b[\" + to_string(i + 1) + \"]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, MAXN, \"n\");\n    inf.readEoln();\n\n    vector<pair<int,int>> edges;\n\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u[\" + to_string(i + 1) + \"]\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v[\" + to_string(i + 1) + \"]\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge %d connects a node to itself: %d == %d\", i + 1, u, v);\n\n        edges.push_back({u, v});\n    }\n\n    // Union-Find to check for cycles and connectedness\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++) parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        return parent[x] == x ? x : parent[x] = find(parent[x]);\n    };\n\n    for (int i = 0; i < edges.size(); i++) {\n        int u = edges[i].first, v = edges[i].second;\n        int pu = find(u), pv = find(v);\n        ensuref(pu != pv, \"Graph contains a cycle with edge %d connecting nodes %d and %d\", i + 1, u, v);\n        parent[pu] = pv;\n    }\n\n    int k = inf.readInt(0, MAXN, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; i++) {\n        int a = inf.readInt(1, n, \"a[\" + to_string(i + 1) + \"]\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b[\" + to_string(i + 1) + \"]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, MAXN, \"n\");\n    inf.readEoln();\n\n    vector<pair<int,int>> edges;\n\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u[\" + to_string(i + 1) + \"]\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v[\" + to_string(i + 1) + \"]\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge %d connects a node to itself: %d == %d\", i + 1, u, v);\n\n        edges.push_back({u, v});\n    }\n\n    // Union-Find to check for cycles and connectedness\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++) parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        return parent[x] == x ? x : parent[x] = find(parent[x]);\n    };\n\n    for (int i = 0; i < edges.size(); i++) {\n        int u = edges[i].first, v = edges[i].second;\n        int pu = find(u), pv = find(v);\n        ensuref(pu != pv, \"Graph contains a cycle with edge %d connecting nodes %d and %d\", i + 1, u, v);\n        parent[pu] = pv;\n    }\n\n    int k = inf.readInt(0, MAXN, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; i++) {\n        int a = inf.readInt(1, n, \"a[\" + to_string(i + 1) + \"]\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b[\" + to_string(i + 1) + \"]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 0);\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string path_type = opt<string>(\"path_type\", \"random\");\n    bool allow_duplicates = opt<bool>(\"allow_duplicates\", false);\n\n    vector<pair<int, int>> edges;\n    vector<pair<int, int>> queries;\n\n    // Generate the tree based on tree_type\n    if (tree_type == \"chain\") {\n        // A chain\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        // A star\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"binary\") {\n        // A balanced binary tree\n        for (int i = 1; i <= n; ++i) {\n            if (2 * i <= n)\n                edges.push_back({i, 2 * i});\n            if (2 * i + 1 <= n)\n                edges.push_back({i, 2 * i + 1});\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int p = rnd.next(1, i - 1);\n            edges.push_back({p, i});\n        }\n    }\n\n    // Permute node labels\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin() + 1, perm.end());\n\n    for (auto& e : edges) {\n        e.first = perm[e.first];\n        e.second = perm[e.second];\n    }\n\n    // Shuffle the edges\n    shuffle(edges.begin(), edges.end());\n\n    // Generate the queries based on path_type\n\n    set<pair<int, int>> used;\n    vector<int> degree(n + 1, 0);\n    for (auto e : edges) {\n        int u = e.first, v = e.second;\n        ++degree[u];\n        ++degree[v];\n    }\n    vector<int> leaves;\n    for (int i = 1; i <= n; ++i) {\n        if (degree[i] == 1) leaves.push_back(i);\n    }\n\n    if (path_type == \"random\") {\n        for (int i = 0; i < k; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (!allow_duplicates) {\n                while (used.count({a, b})) {\n                    a = rnd.next(1, n);\n                    b = rnd.next(1, n);\n                }\n                used.insert({a, b});\n            }\n            queries.push_back({a, b});\n        }\n    } else if (path_type == \"all_same\") {\n        int a = rnd.next(1, n);\n        int b = rnd.next(1, n);\n        for (int i = 0; i < k; ++i) {\n            queries.push_back({a, b});\n        }\n    } else if (path_type == \"leaf_to_leaf\") {\n        if (leaves.size() >= 2) {\n            for (int i = 0; i < k; ++i) {\n                int idx1 = rnd.next(0, (int)leaves.size() - 1);\n                int idx2 = rnd.next(0, (int)leaves.size() - 1);\n                int a = leaves[idx1];\n                int b = leaves[idx2];\n                if (!allow_duplicates) {\n                    while (a == b || used.count({a, b})) {\n                        idx1 = rnd.next(0, (int)leaves.size() - 1);\n                        idx2 = rnd.next(0, (int)leaves.size() - 1);\n                        a = leaves[idx1];\n                        b = leaves[idx2];\n                    }\n                    used.insert({a, b});\n                }\n                queries.push_back({a, b});\n            }\n        } else {\n            // Not enough leaves, generate random queries\n            for (int i = 0; i < k; ++i) {\n                int a = rnd.next(1, n);\n                int b = rnd.next(1, n);\n                queries.push_back({a, b});\n            }\n        }\n    } else if (path_type == \"root_to_leaf\") {\n        int root = perm[1]; // Assuming the root is the permuted node 1\n        vector<int> non_root_leaves;\n        for (int leaf : leaves) {\n            if (leaf != root) {\n                non_root_leaves.push_back(leaf);\n            }\n        }\n        if (non_root_leaves.empty()) {\n            // Only root is present\n            for (int i = 0; i < k; ++i) {\n                queries.push_back({root, root});\n            }\n        } else {\n            for (int i = 0; i < k; ++i) {\n                int idx = rnd.next(0, (int)non_root_leaves.size() - 1);\n                int b = non_root_leaves[idx];\n                queries.push_back({root, b});\n            }\n        }\n    } else if (path_type == \"ai_equal_bi\") {\n        for (int i = 0; i < k; ++i) {\n            int a = rnd.next(1, n);\n            queries.push_back({a, a});\n        }\n    } else {\n        // Default to random queries\n        for (int i = 0; i < k; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            queries.push_back({a, b});\n        }\n    }\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    printf(\"%d\\n\", k);\n    for (auto q : queries) {\n        printf(\"%d %d\\n\", q.first, q.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 0);\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string path_type = opt<string>(\"path_type\", \"random\");\n    bool allow_duplicates = opt<bool>(\"allow_duplicates\", false);\n\n    vector<pair<int, int>> edges;\n    vector<pair<int, int>> queries;\n\n    // Generate the tree based on tree_type\n    if (tree_type == \"chain\") {\n        // A chain\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        // A star\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"binary\") {\n        // A balanced binary tree\n        for (int i = 1; i <= n; ++i) {\n            if (2 * i <= n)\n                edges.push_back({i, 2 * i});\n            if (2 * i + 1 <= n)\n                edges.push_back({i, 2 * i + 1});\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int p = rnd.next(1, i - 1);\n            edges.push_back({p, i});\n        }\n    }\n\n    // Permute node labels\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin() + 1, perm.end());\n\n    for (auto& e : edges) {\n        e.first = perm[e.first];\n        e.second = perm[e.second];\n    }\n\n    // Shuffle the edges\n    shuffle(edges.begin(), edges.end());\n\n    // Generate the queries based on path_type\n\n    set<pair<int, int>> used;\n    vector<int> degree(n + 1, 0);\n    for (auto e : edges) {\n        int u = e.first, v = e.second;\n        ++degree[u];\n        ++degree[v];\n    }\n    vector<int> leaves;\n    for (int i = 1; i <= n; ++i) {\n        if (degree[i] == 1) leaves.push_back(i);\n    }\n\n    if (path_type == \"random\") {\n        for (int i = 0; i < k; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (!allow_duplicates) {\n                while (used.count({a, b})) {\n                    a = rnd.next(1, n);\n                    b = rnd.next(1, n);\n                }\n                used.insert({a, b});\n            }\n            queries.push_back({a, b});\n        }\n    } else if (path_type == \"all_same\") {\n        int a = rnd.next(1, n);\n        int b = rnd.next(1, n);\n        for (int i = 0; i < k; ++i) {\n            queries.push_back({a, b});\n        }\n    } else if (path_type == \"leaf_to_leaf\") {\n        if (leaves.size() >= 2) {\n            for (int i = 0; i < k; ++i) {\n                int idx1 = rnd.next(0, (int)leaves.size() - 1);\n                int idx2 = rnd.next(0, (int)leaves.size() - 1);\n                int a = leaves[idx1];\n                int b = leaves[idx2];\n                if (!allow_duplicates) {\n                    while (a == b || used.count({a, b})) {\n                        idx1 = rnd.next(0, (int)leaves.size() - 1);\n                        idx2 = rnd.next(0, (int)leaves.size() - 1);\n                        a = leaves[idx1];\n                        b = leaves[idx2];\n                    }\n                    used.insert({a, b});\n                }\n                queries.push_back({a, b});\n            }\n        } else {\n            // Not enough leaves, generate random queries\n            for (int i = 0; i < k; ++i) {\n                int a = rnd.next(1, n);\n                int b = rnd.next(1, n);\n                queries.push_back({a, b});\n            }\n        }\n    } else if (path_type == \"root_to_leaf\") {\n        int root = perm[1]; // Assuming the root is the permuted node 1\n        vector<int> non_root_leaves;\n        for (int leaf : leaves) {\n            if (leaf != root) {\n                non_root_leaves.push_back(leaf);\n            }\n        }\n        if (non_root_leaves.empty()) {\n            // Only root is present\n            for (int i = 0; i < k; ++i) {\n                queries.push_back({root, root});\n            }\n        } else {\n            for (int i = 0; i < k; ++i) {\n                int idx = rnd.next(0, (int)non_root_leaves.size() - 1);\n                int b = non_root_leaves[idx];\n                queries.push_back({root, b});\n            }\n        }\n    } else if (path_type == \"ai_equal_bi\") {\n        for (int i = 0; i < k; ++i) {\n            int a = rnd.next(1, n);\n            queries.push_back({a, a});\n        }\n    } else {\n        // Default to random queries\n        for (int i = 0; i < k; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            queries.push_back({a, b});\n        }\n    }\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    printf(\"%d\\n\", k);\n    for (auto q : queries) {\n        printf(\"%d %d\\n\", q.first, q.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -k 0 -tree_type chain -path_type random\n./gen -n 5 -k 2 -tree_type chain -path_type ai_equal_bi\n./gen -n 5 -k 10 -tree_type star -path_type root_to_leaf\n\n./gen -n 100 -k 50 -tree_type random -path_type random\n./gen -n 100 -k 0 -tree_type binary -path_type random\n./gen -n 100 -k 1000 -tree_type binary -path_type leaf_to_leaf\n\n./gen -n 1000 -k 1000 -tree_type chain -path_type all_same\n./gen -n 1000 -k 1000 -tree_type star -path_type root_to_leaf\n./gen -n 1000 -k 1000 -tree_type random -path_type ai_equal_bi\n\n./gen -n 10000 -k 10000 -tree_type random -path_type random\n./gen -n 10000 -k 5000 -tree_type binary -path_type leaf_to_leaf\n./gen -n 10000 -k 5000 -tree_type binary -path_type random\n./gen -n 10000 -k 0 -tree_type chain -path_type random\n\n./gen -n 100000 -k 100000 -tree_type random -path_type random\n./gen -n 100000 -k 100000 -tree_type chain -path_type all_same\n./gen -n 100000 -k 100000 -tree_type star -path_type root_to_leaf\n./gen -n 100000 -k 100000 -tree_type star -path_type ai_equal_bi\n\n./gen -n 100000 -k 50000 -tree_type binary -path_type leaf_to_leaf\n./gen -n 100000 -k 50000 -tree_type binary -path_type ai_equal_bi\n\n./gen -n 99999 -k 99999 -tree_type random -path_type random\n./gen -n 99999 -k 0 -tree_type random -path_type random\n\n./gen -n 2 -k 1 -tree_type star -path_type ai_equal_bi\n./gen -n 3 -k 3 -tree_type chain -path_type root_to_leaf\n\n# Edge cases with small n\n./gen -n 2 -k 0 -tree_type random -path_type random\n./gen -n 2 -k 1 -tree_type chain -path_type ai_equal_bi\n\n# Edge case with maximum n and k\n./gen -n 100000 -k 0 -tree_type binary -path_type ai_equal_bi\n\n# Repeating the same queries\n./gen -n 100000 -k 100000 -tree_type random -path_type all_same\n\n# Allow duplicates in queries\n./gen -n 100000 -k 100000 -tree_type random -path_type random -allow_duplicates\n\n# No duplicates in queries\n./gen -n 100000 -k 100000 -tree_type random -path_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:17.157840",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "191/D",
      "title": "D. Схема метро",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеНа первой строке записаны два целых числа n и m (1 ≤ n ≤ 105, 0 ≤ m ≤ 3·105) — количество станций и тоннелей, соответственно.На следующих m строках содержатся по два целых числа — номера станций, которые соединяет соответствующий тоннель. Станции нумеруются целыми числами от 1 до n.Гарантируется, что в графе, который соответствует метро, нет кратных ребер и петель, что он связен и что он является вершинным кактусом.",
      "output_spec": "Выходные данныеВыведите два числа — минимальное и максимальное количество линий, соответственно.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 31 22 33 1Выходные данныеСкопировать1 3Входные данныеСкопировать8 81 22 33 44 56 44 77 22 8Выходные данныеСкопировать2 8Входные данныеСкопировать6 61 22 32 55 63 43 5Выходные данныеСкопировать3 6",
      "description": "D. Схема метро\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеНа первой строке записаны два целых числа n и m (1 ≤ n ≤ 105, 0 ≤ m ≤ 3·105) — количество станций и тоннелей, соответственно.На следующих m строках содержатся по два целых числа — номера станций, которые соединяет соответствующий тоннель. Станции нумеруются целыми числами от 1 до n.Гарантируется, что в графе, который соответствует метро, нет кратных ребер и петель, что он связен и что он является вершинным кактусом.\n\nВходные данные\n\nВыходные данныеВыведите два числа — минимальное и максимальное количество линий, соответственно.\n\nВыходные данные\n\nВходные данныеСкопировать3 31 22 33 1Выходные данныеСкопировать1 3Входные данныеСкопировать8 81 22 33 44 56 44 77 22 8Выходные данныеСкопировать2 8Входные данныеСкопировать6 61 22 32 55 63 43 5Выходные данныеСкопировать3 6\n\nВходные данныеСкопировать3 31 22 33 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать8 81 22 33 44 56 44 77 22 8\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 8\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 61 22 32 55 63 43 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3 6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеСхема метро с минимально возможным количеством линий для второго примера:",
      "solutions": [
        {
          "title": "Codeforces Round #121 - Codeforces",
          "content": "Здравствуй, сообщество Codeforces!Очередной раунд Codeforces #121 для вас сделали студенты ФИВТ МФТИ Александр Тимин (AlTimin) и Иван Смирнов (ifsmirnov). В своем первом раунде мы предложим вам хорошо провести время в старой доброй Берляндии: провести митинг, разогнать митинг, разобраться с главными берляндскими проблемами (обеими!) и многое другое.За неоценимую помощь в подготовке контеста хочется сказать огромное спасибо Gerald. Он же является автором одной из задач. Кроме того, мы выражаем благодарность Delinur за перевод условий на английский язык, Aksenov239 за вычитку условий и MikeMirzayanov за возможность провести контест на замечательной платформе Codeforces.Традиционно, раунд пройдет в обоих дивизионах на частично пересекающемся наборе задач. Информация о разбалловке будет опубликована позже.Мы желаем вам успехов и надеемся, что раунд вам понравится!РазборUPD1: Разбалловка в обоих дивизионах стандартная, 500-1000-1500-2000-2500.UPD2: Авторы контеста приносят участникам свои извинения за неточности в условии задачи B div 1 (D div 2). Так как проблема с условием была решена достаточно быстро, а неправильное понимание задачи не проходило претесты, раунд объявляется рейтинговым.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4635",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1203
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces",
          "content": "Задача 192A - Модные числаКратко о решении: переборПодробно о решении: Нетрудно заметить, что это числа положительны, следовательно каждое из слагаемых меньше N. То есть всего различных возможных слагаемых порядка . Это значит то, что мы взять и одно из слагаемых перебрать. Тогда нам нужно научиться проверять, является ли какое-то число треугольным. Заметим, что если мы заранее выпишем все слагаемые в порядке увеличения то мы сможем с помощью бинарного поиска в массиве искать наше число. Это даем там решение за . Если перебирать первое слагаемое в порядке увеличения, то можно использовать два указателя, что дает нам решение за .Задача 192B - Прогулки под дождемКратко о решении: динамика.Подробно о решении: динамика d[i] — количество дней, в течении которых плитка номер i доступна. Пересчет: d[i] = min(a[i], max(d[i - 1], d[i - 2]))Асимптотика решения: O(N)Задача 191A - Династические головоломкиКратко о решении: динамикаПодробно о решении: динамика d[i][j], i — первый символ в имени династии, j — последний текущий символ. d[i][j] — максимальная текущая длина. Переход: для слова с первой буквой l, последней буквой r и длиной s для всех возможных первых букв i состояние d[i][r] может быть улучшено значением d[i][l] + s.Ответом будет являться максимальное значение d[i][i] для всех i.Асимптотика решения: O(N * alpha), где alpha — это размер алфавита.Задача 191B - МитингКратко о решении: конструктивПодробно о решении: заметим, что на последнюю площадь никогда не выгодно подавать заявку (денег мэрии не потратим, ничего не изменится, мы просто потеряем ход). Переберем площадь, на которой мы хотим провести митинг. У нас есть k - 1 ход на то, чтобы потратить деньги мэрии (один ход нам нужен на подачу заявки на искомую площадь). Тратить деньги выгоднее всего на самых дорогих площадях, за исключением последней. Осталось научиться быстро выбирать k - 1 максимум из всего массива, за исключением данного элемента. Для этого сначала отсортируем массив и получим k максимумов (последнюю площадь мы не должны рассматривать). Проверяем, лежит ли наше текущее значение в k - 1 максимальных (бинпоиск и не только). Если лежит, то искомые k - 1 максимумов — это максимальные k элементов без нашего. Если не лежит, то это просто максимальные k элементов. Теперь когда мы понимаем, сколько денег мэрии мы можем потратить, то тратим их и смотрим, остаются ли еще у мэрии деньги на проведение события на нашей текущей площадиАсимптотика решения: Задача 191C - Дураки и дорогиКратко о решении: lcaПодробно о решении: Разобьем каждый путь на два, строго идущих вверх к наименьшему общему предку. Теперь у нас есть только \"вертикальные пути\". Для каждой вершины насчитаем такую величину: количество вертикальных путей, начинающихся в ней минус количество вертикальных путей в ней заканчивающихся. Если мы насчитали эту величину, то ответ для ребра — это сумма значений в его поддереве. Насчитать такую величину довольно просто: берем для каждой пары дураков считаем lca этой пары. В города дураков прибавляем единичку, в lca значение уменьшаем на два.Асимптотика решения: Задача 191D - Схема метроКратко о решении: снова динамикаПодробно о решении: динамика d[v][rest][cycle] — количество линий, которое требуется для того, чтобы в поддереве вершины v все покрасить, в v остаются rest незамкнутым, cycle — правда ли, что нам надо обрабатывать цикл, в котором мы находимся. Если мы находимся не в вершине цикла, то обрабатываем всех детей, говоря что мы хотим, чтобы в них было по одному незакрытому пути. Пусть у нас есть s сыновей, нам надо взять и замкнуть все лишние линии, а недостающие нагенерить. То есть ответ это , если s > rest, и в противном случае.Если мы находимся в вершине цикла, то либо мы покрываем этот цикл кольцом и это стоит нам , где u — это вершина на цикле. отличная от v. Другой вариант — покрыть все участки кольца радиальными линиями. Утверждение: это всегда можно оптимально сделать ровно двумя радиальными. Пусть это не так. Тогда рассмотрим некоторую вершину, в которой радиальные линии <<подвешиваются>> к кольцу. От неё по кольцу в разные стороны уходят два тоннеля, принадлежащие этим линиям. Так как различных линий на кольце сейчас не менее трех, то мы можем перенаправить радиальные линии следующим образом: соединить куски вне кольца друг с другом, а кольцо замкнуть. На кольце останется не менее двух кусков, следовательно все линии останутся валидными, а их число не изменится. Теперь надо выбрать две станции, из поддерева которых будут выходить радиальные ветки, покрывшее кольцо. Стоимость такой станции это d[u][2][0], а обычной — d[u][0][0] (d[v][rest][0] в случае той вершины, которую мы сейчас обрабатываем) . Соответственно, нам надо выбрать две станции с максимальным значением d[u][2][0] - d[u][0][0].Асимптотика решения: O(N)Задача 191E - Разгон митинговКратко о решении: бинарный поиск по ответуПодробно о решении: Сделаем бинарный поиск по ответу. Нам надо посчитать количество отрезков, на которых сумма больше нашего некоторого значения. Как мы это будем делать: будем обрабатывать все отрезки в порядке увеличения правых концов. Отрезки с одинаковыми правыми концами будем обрабатывать пачками. Более подробно: мы будем поддерживать некоторую структуру данных в которой будут храниться суммы всех отрезков c фиксированным правым концом. Для того, чтобы быстро пересчитывать, нам нужно всего добавить в множество некоторый элемент ( 0, если точнее) и добавить ко всем элементам множества некоторое значение (a[i], если быть точнее). Еще нам нужно уметь отвечать на запрос <<количество элементов, больших данного на отрезке>>. Все это умеет быстро реализовывать, например, декартово дерево. Но нам придется дополнительно хранить некоторую величину X, означающую <<надо прибавить к элементу из декартова дерева X, чтобы получить реальное значение>>. Тогда при добавлении элемента a в нашу структуру надо будет положить в декартово дерево величину a - X, а прибавление некоторой величины ко всему множеству реализуется простым изменением X. То есть у нас есть структура данных, которая умеет все эти операции выполнять за . То есть одна итерация внешнего бинпоиска работает за , следовательно весь алгоритм работает за Асимптотика решения:",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4634",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 191\\s*D"
          },
          "content_length": 6193
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #121 - Codeforces - Code 1",
          "code": "for (int i = 1; i * (i + 1) < n + n; i++)\n r[i] = i * (i + 1) / 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #121 - Codeforces - Code 2",
          "code": "for (int i = 1; i * (i + 1) < n + n; i++)\n r[i] = i * (i + 1) / 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #121 - Codeforces - Code 3",
          "code": "// fprintf(stderr, \"cnt(av=%lld) = %lld\\n\", av, cnt);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #121 - Codeforces - Code 4",
          "code": "// fprintf(stderr, \"cnt(av=%lld) = %lld\\n\", av, cnt);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #121 - Codeforces - Code 5",
          "code": "return printf(\"%I64d\\n\",end+1), 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #121 - Codeforces - Code 6",
          "code": "return !printf(\"%I64d\\n\",end+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 1",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 2",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 300000, \"m\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1);\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"No loops allowed: edge connects node %d to itself\", u);\n\n        int a = min(u, v);\n        int b = max(u, v);\n        ensuref(edgeSet.count({a, b}) == 0, \"No multiple edges between nodes %d and %d\", a, b);\n        edgeSet.insert({a, b});\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    vector<int> visited(n + 1, 0);\n    vector<int> parent(n + 1, -1);\n    vector<int> cycle_of_node(n + 1, 0);\n    int cycle_id = 1;\n\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = 1;\n        for (int v : adj[u]) {\n            if (v == parent[u]) continue;\n            if (!visited[v]) {\n                parent[v] = u;\n                dfs(v);\n            } else {\n                // Back edge detected\n                // Construct the cycle from u to v\n                int temp = u;\n                while (temp != v) {\n                    ensuref(cycle_of_node[temp] == 0, \"Node %d is in more than one simple cycle\", temp);\n                    cycle_of_node[temp] = cycle_id;\n                    temp = parent[temp];\n                    ensuref(temp != -1, \"Invalid back edge from node %d to node %d\", u, v);\n                }\n                ensuref(cycle_of_node[v] == 0, \"Node %d is in more than one simple cycle\", v);\n                cycle_of_node[v] = cycle_id;\n                cycle_id++;\n            }\n        }\n    };\n\n    dfs(1);\n\n    for (int u = 1; u <= n; u++) {\n        ensuref(visited[u] == 1, \"Graph is not connected: node %d is not reachable\", u);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 300000, \"m\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1);\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"No loops allowed: edge connects node %d to itself\", u);\n\n        int a = min(u, v);\n        int b = max(u, v);\n        ensuref(edgeSet.count({a, b}) == 0, \"No multiple edges between nodes %d and %d\", a, b);\n        edgeSet.insert({a, b});\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    vector<int> visited(n + 1, 0);\n    vector<int> parent(n + 1, -1);\n    vector<int> cycle_of_node(n + 1, 0);\n    int cycle_id = 1;\n\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = 1;\n        for (int v : adj[u]) {\n            if (v == parent[u]) continue;\n            if (!visited[v]) {\n                parent[v] = u;\n                dfs(v);\n            } else {\n                // Back edge detected\n                // Construct the cycle from u to v\n                int temp = u;\n                while (temp != v) {\n                    ensuref(cycle_of_node[temp] == 0, \"Node %d is in more than one simple cycle\", temp);\n                    cycle_of_node[temp] = cycle_id;\n                    temp = parent[temp];\n                    ensuref(temp != -1, \"Invalid back edge from node %d to node %d\", u, v);\n                }\n                ensuref(cycle_of_node[v] == 0, \"Node %d is in more than one simple cycle\", v);\n                cycle_of_node[v] = cycle_id;\n                cycle_id++;\n            }\n        }\n    };\n\n    dfs(1);\n\n    for (int u = 1; u <= n; u++) {\n        ensuref(visited[u] == 1, \"Graph is not connected: node %d is not reachable\", u);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 300000, \"m\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1);\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"No loops allowed: edge connects node %d to itself\", u);\n\n        int a = min(u, v);\n        int b = max(u, v);\n        ensuref(edgeSet.count({a, b}) == 0, \"No multiple edges between nodes %d and %d\", a, b);\n        edgeSet.insert({a, b});\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    vector<int> visited(n + 1, 0);\n    vector<int> parent(n + 1, -1);\n    vector<int> cycle_of_node(n + 1, 0);\n    int cycle_id = 1;\n\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = 1;\n        for (int v : adj[u]) {\n            if (v == parent[u]) continue;\n            if (!visited[v]) {\n                parent[v] = u;\n                dfs(v);\n            } else {\n                // Back edge detected\n                // Construct the cycle from u to v\n                int temp = u;\n                while (temp != v) {\n                    ensuref(cycle_of_node[temp] == 0, \"Node %d is in more than one simple cycle\", temp);\n                    cycle_of_node[temp] = cycle_id;\n                    temp = parent[temp];\n                    ensuref(temp != -1, \"Invalid back edge from node %d to node %d\", u, v);\n                }\n                ensuref(cycle_of_node[v] == 0, \"Node %d is in more than one simple cycle\", v);\n                cycle_of_node[v] = cycle_id;\n                cycle_id++;\n            }\n        }\n    };\n\n    dfs(1);\n\n    for (int u = 1; u <= n; u++) {\n        ensuref(visited[u] == 1, \"Graph is not connected: node %d is not reachable\", u);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int> > edges;\n\n    if (type == \"path\") {\n        // Generate a path (a tree with depth n)\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (type == \"star\") {\n        // Generate a star (a tree with depth 1)\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"cycle\") {\n        // Generate a single cycle including all nodes\n        if (n < 3) {\n            fprintf(stderr, \"Number of nodes must be at least 3 for a cycle.\\n\");\n            return 1;\n        }\n        for (int i = 1; i <= n; ++i) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back({u, v});\n        }\n    } else if (type == \"tree\") {\n        // Generate a random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back({u, v});\n        }\n    } else if (type == \"max_cycles\") {\n        // Generate a cactus graph with maximum number of cycles\n        int cycles = n / 3;\n        int nodes_used = cycles * 3;\n        int remaining_nodes = n - nodes_used;\n        int node_id = 1;\n\n        // Create cycles of size 3\n        for (int i = 0; i < cycles; ++i) {\n            int u = node_id++;\n            int v = node_id++;\n            int w = node_id++;\n            edges.push_back({u, v});\n            edges.push_back({v, w});\n            edges.push_back({w, u});\n        }\n\n        // Connect remaining nodes to keep the graph connected\n        for (int i = 0; i < remaining_nodes; ++i) {\n            int u = node_id++;\n            int v = rnd.next(1, n - remaining_nodes);\n            edges.push_back({u, v});\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Shuffle edges to randomize their order\n    shuffle(edges.begin(), edges.end());\n\n    // Output the graph\n    int m = edges.size();\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edges) {\n        int u = e.first;\n        int v = e.second;\n        printf(\"%d %d\\n\", u, v);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int> > edges;\n\n    if (type == \"path\") {\n        // Generate a path (a tree with depth n)\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (type == \"star\") {\n        // Generate a star (a tree with depth 1)\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"cycle\") {\n        // Generate a single cycle including all nodes\n        if (n < 3) {\n            fprintf(stderr, \"Number of nodes must be at least 3 for a cycle.\\n\");\n            return 1;\n        }\n        for (int i = 1; i <= n; ++i) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back({u, v});\n        }\n    } else if (type == \"tree\") {\n        // Generate a random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back({u, v});\n        }\n    } else if (type == \"max_cycles\") {\n        // Generate a cactus graph with maximum number of cycles\n        int cycles = n / 3;\n        int nodes_used = cycles * 3;\n        int remaining_nodes = n - nodes_used;\n        int node_id = 1;\n\n        // Create cycles of size 3\n        for (int i = 0; i < cycles; ++i) {\n            int u = node_id++;\n            int v = node_id++;\n            int w = node_id++;\n            edges.push_back({u, v});\n            edges.push_back({v, w});\n            edges.push_back({w, u});\n        }\n\n        // Connect remaining nodes to keep the graph connected\n        for (int i = 0; i < remaining_nodes; ++i) {\n            int u = node_id++;\n            int v = rnd.next(1, n - remaining_nodes);\n            edges.push_back({u, v});\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Shuffle edges to randomize their order\n    shuffle(edges.begin(), edges.end());\n\n    // Output the graph\n    int m = edges.size();\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edges) {\n        int u = e.first;\n        int v = e.second;\n        printf(\"%d %d\\n\", u, v);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type tree\n./gen -n 1 -type path\n./gen -n 1 -type star\n./gen -n 2 -type path\n./gen -n 3 -type cycle\n./gen -n 5 -type path\n./gen -n 5 -type star\n./gen -n 5 -type cycle\n./gen -n 5 -type tree\n./gen -n 6 -type max_cycles\n./gen -n 10 -type tree\n./gen -n 10 -type max_cycles\n./gen -n 10 -type path\n./gen -n 10 -type star\n./gen -n 100 -type tree\n./gen -n 100 -type max_cycles\n./gen -n 100 -type path\n./gen -n 100 -type star\n./gen -n 1000 -type tree\n./gen -n 1000 -type max_cycles\n./gen -n 1000 -type path\n./gen -n 1000 -type star\n./gen -n 10000 -type tree\n./gen -n 10000 -type max_cycles\n./gen -n 10000 -type path\n./gen -n 10000 -type star\n./gen -n 100000 -type tree\n./gen -n 100000 -type max_cycles\n./gen -n 100000 -type path\n./gen -n 100000 -type star\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:19.209911",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "191/E",
      "title": "E. Thwarting Demonstrations",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test6 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains two integers n and k  — the number of soldiers in the detachment and the number of times somebody goes on duty.The second line contains n space-separated integers ai, their absolute value doesn't exceed 109 — the soldiers' reliabilities.Please do not use the %lld specifier to read or write 64-bit integers in С++, it is preferred to use cin, cout streams of the %I64d specifier.",
      "output_spec": "OutputPrint a single number — the sought minimum reliability of the groups that go on duty during these k days.",
      "sample_tests": "ExamplesInputCopy3 41 4 2OutputCopy4InputCopy4 62 -1 2 -1OutputCopy1InputCopy8 101 -2 3 -4 5 -6 7 -8OutputCopy2",
      "description": "E. Thwarting Demonstrations\n\ntime limit per test6 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k  — the number of soldiers in the detachment and the number of times somebody goes on duty.The second line contains n space-separated integers ai, their absolute value doesn't exceed 109 — the soldiers' reliabilities.Please do not use the %lld specifier to read or write 64-bit integers in С++, it is preferred to use cin, cout streams of the %I64d specifier.\n\nOutputPrint a single number — the sought minimum reliability of the groups that go on duty during these k days.\n\nInputCopy3 41 4 2OutputCopy4InputCopy4 62 -1 2 -1OutputCopy1InputCopy8 101 -2 3 -4 5 -6 7 -8OutputCopy2\n\nInputCopy3 41 4 2\n\nOutputCopy4\n\nInputCopy4 62 -1 2 -1\n\nOutputCopy1\n\nInputCopy8 101 -2 3 -4 5 -6 7 -8\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Round #121 - Codeforces",
          "content": "Hello, dear Codeforces community!I'm glad to present you the next Codeforces Round #121. The contest is brought to you by Ivan Smirnov (ifsmirnov) and Aleksandr Timin (AlTimin), the students of Moscow Institute of Physics and Technology. In our first round we will offer you a good time in Berland: you will hold a demonstration, prevent the demonstration, deal with the most important problems of Berland (with both of them!) and much more.We thank Gerald a lot for the invaluable help he gave as during the contest preparation. He is also the author of one task in the contest. We also thank Delinur for the English version of statements, Aksenov239 for proofreading the statements and MikeMirzayanov for an opportunity to hold a contest on this wonderful site.As usual, the contest will be held in both divisions and the problemsets will overlap. The scoring will be published later.We wish you good luck and hope that you enjoy the contest!UPD1: The scoring is classic in both divisions — 500-1000-1500-2000-2500.UPD2: The contest authors apologize to the contesters for a possibility of misunderstanding of problem B div 1 (D div 2). The statement was fixed soon enough and the incorrect understanding of the problem didn't pass pretests, so the round is rated.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4635",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1266
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces",
          "content": "Задача 192A - Модные числаКратко о решении: переборПодробно о решении: Нетрудно заметить, что это числа положительны, следовательно каждое из слагаемых меньше N. То есть всего различных возможных слагаемых порядка . Это значит то, что мы взять и одно из слагаемых перебрать. Тогда нам нужно научиться проверять, является ли какое-то число треугольным. Заметим, что если мы заранее выпишем все слагаемые в порядке увеличения то мы сможем с помощью бинарного поиска в массиве искать наше число. Это даем там решение за . Если перебирать первое слагаемое в порядке увеличения, то можно использовать два указателя, что дает нам решение за .Задача 192B - Прогулки под дождемКратко о решении: динамика.Подробно о решении: динамика d[i] — количество дней, в течении которых плитка номер i доступна. Пересчет: d[i] = min(a[i], max(d[i - 1], d[i - 2]))Асимптотика решения: O(N)Задача 191A - Династические головоломкиКратко о решении: динамикаПодробно о решении: динамика d[i][j], i — первый символ в имени династии, j — последний текущий символ. d[i][j] — максимальная текущая длина. Переход: для слова с первой буквой l, последней буквой r и длиной s для всех возможных первых букв i состояние d[i][r] может быть улучшено значением d[i][l] + s.Ответом будет являться максимальное значение d[i][i] для всех i.Асимптотика решения: O(N * alpha), где alpha — это размер алфавита.Задача 191B - МитингКратко о решении: конструктивПодробно о решении: заметим, что на последнюю площадь никогда не выгодно подавать заявку (денег мэрии не потратим, ничего не изменится, мы просто потеряем ход). Переберем площадь, на которой мы хотим провести митинг. У нас есть k - 1 ход на то, чтобы потратить деньги мэрии (один ход нам нужен на подачу заявки на искомую площадь). Тратить деньги выгоднее всего на самых дорогих площадях, за исключением последней. Осталось научиться быстро выбирать k - 1 максимум из всего массива, за исключением данного элемента. Для этого сначала отсортируем массив и получим k максимумов (последнюю площадь мы не должны рассматривать). Проверяем, лежит ли наше текущее значение в k - 1 максимальных (бинпоиск и не только). Если лежит, то искомые k - 1 максимумов — это максимальные k элементов без нашего. Если не лежит, то это просто максимальные k элементов. Теперь когда мы понимаем, сколько денег мэрии мы можем потратить, то тратим их и смотрим, остаются ли еще у мэрии деньги на проведение события на нашей текущей площадиАсимптотика решения: Задача 191C - Дураки и дорогиКратко о решении: lcaПодробно о решении: Разобьем каждый путь на два, строго идущих вверх к наименьшему общему предку. Теперь у нас есть только \"вертикальные пути\". Для каждой вершины насчитаем такую величину: количество вертикальных путей, начинающихся в ней минус количество вертикальных путей в ней заканчивающихся. Если мы насчитали эту величину, то ответ для ребра — это сумма значений в его поддереве. Насчитать такую величину довольно просто: берем для каждой пары дураков считаем lca этой пары. В города дураков прибавляем единичку, в lca значение уменьшаем на два.Асимптотика решения: Задача 191D - Схема метроКратко о решении: снова динамикаПодробно о решении: динамика d[v][rest][cycle] — количество линий, которое требуется для того, чтобы в поддереве вершины v все покрасить, в v остаются rest незамкнутым, cycle — правда ли, что нам надо обрабатывать цикл, в котором мы находимся. Если мы находимся не в вершине цикла, то обрабатываем всех детей, говоря что мы хотим, чтобы в них было по одному незакрытому пути. Пусть у нас есть s сыновей, нам надо взять и замкнуть все лишние линии, а недостающие нагенерить. То есть ответ это , если s > rest, и в противном случае.Если мы находимся в вершине цикла, то либо мы покрываем этот цикл кольцом и это стоит нам , где u — это вершина на цикле. отличная от v. Другой вариант — покрыть все участки кольца радиальными линиями. Утверждение: это всегда можно оптимально сделать ровно двумя радиальными. Пусть это не так. Тогда рассмотрим некоторую вершину, в которой радиальные линии <<подвешиваются>> к кольцу. От неё по кольцу в разные стороны уходят два тоннеля, принадлежащие этим линиям. Так как различных линий на кольце сейчас не менее трех, то мы можем перенаправить радиальные линии следующим образом: соединить куски вне кольца друг с другом, а кольцо замкнуть. На кольце останется не менее двух кусков, следовательно все линии останутся валидными, а их число не изменится. Теперь надо выбрать две станции, из поддерева которых будут выходить радиальные ветки, покрывшее кольцо. Стоимость такой станции это d[u][2][0], а обычной — d[u][0][0] (d[v][rest][0] в случае той вершины, которую мы сейчас обрабатываем) . Соответственно, нам надо выбрать две станции с максимальным значением d[u][2][0] - d[u][0][0].Асимптотика решения: O(N)Задача 191E - Разгон митинговКратко о решении: бинарный поиск по ответуПодробно о решении: Сделаем бинарный поиск по ответу. Нам надо посчитать количество отрезков, на которых сумма больше нашего некоторого значения. Как мы это будем делать: будем обрабатывать все отрезки в порядке увеличения правых концов. Отрезки с одинаковыми правыми концами будем обрабатывать пачками. Более подробно: мы будем поддерживать некоторую структуру данных в которой будут храниться суммы всех отрезков c фиксированным правым концом. Для того, чтобы быстро пересчитывать, нам нужно всего добавить в множество некоторый элемент ( 0, если точнее) и добавить ко всем элементам множества некоторое значение (a[i], если быть точнее). Еще нам нужно уметь отвечать на запрос <<количество элементов, больших данного на отрезке>>. Все это умеет быстро реализовывать, например, декартово дерево. Но нам придется дополнительно хранить некоторую величину X, означающую <<надо прибавить к элементу из декартова дерева X, чтобы получить реальное значение>>. Тогда при добавлении элемента a в нашу структуру надо будет положить в декартово дерево величину a - X, а прибавление некоторой величины ко всему множеству реализуется простым изменением X. То есть у нас есть структура данных, которая умеет все эти операции выполнять за . То есть одна итерация внешнего бинпоиска работает за , следовательно весь алгоритм работает за Асимптотика решения:",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4634",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 191\\s*E"
          },
          "content_length": 6193
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #121 - Codeforces - Code 1",
          "code": "return printf(\"%I64d\\n\",end+1), 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #121 - Codeforces - Code 2",
          "code": "return !printf(\"%I64d\\n\",end+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 1",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 2",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    long long k = inf.readLong(1LL, (long long)n * (n + 1) / 2, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    long long k = inf.readLong(1LL, (long long)n * (n + 1) / 2, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    long long k = inf.readLong(1LL, (long long)n * (n + 1) / 2, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long k = opt<long long>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_zero\") {\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"all_positive\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    } else if (type == \"all_negative\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = -rnd.next(1, 1000000000);\n    } else if (type == \"alternate\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? rnd.next(1, 1000000000) : -rnd.next(1, 1000000000);\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"max_sum\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 1000000000;\n    } else if (type == \"min_sum\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = -1000000000;\n    } else if (type == \"spike\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n        int num_spikes = min(10, n);\n        for(int i = 0; i < num_spikes; ++i)\n            a[rnd.next(0, n - 1)] = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"single_large\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n        a[rnd.next(0, n - 1)] = 1000000000;\n    } else if (type == \"single_small\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n        a[rnd.next(0, n - 1)] = -1000000000;\n    } else if (type == \"prefix_max\") {\n        a[0] = rnd.next(1, 1000000000);\n        for(int i = 1; i < n; ++i)\n            a[i] = rnd.next(0, 1000000000);\n    } else {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    }\n\n    printf(\"%d %lld\\n\", n, k);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long k = opt<long long>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_zero\") {\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"all_positive\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000000000);\n    } else if (type == \"all_negative\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = -rnd.next(1, 1000000000);\n    } else if (type == \"alternate\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? rnd.next(1, 1000000000) : -rnd.next(1, 1000000000);\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"max_sum\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 1000000000;\n    } else if (type == \"min_sum\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = -1000000000;\n    } else if (type == \"spike\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n        int num_spikes = min(10, n);\n        for(int i = 0; i < num_spikes; ++i)\n            a[rnd.next(0, n - 1)] = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"single_large\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n        a[rnd.next(0, n - 1)] = 1000000000;\n    } else if (type == \"single_small\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n        a[rnd.next(0, n - 1)] = -1000000000;\n    } else if (type == \"prefix_max\") {\n        a[0] = rnd.next(1, 1000000000);\n        for(int i = 1; i < n; ++i)\n            a[i] = rnd.next(0, 1000000000);\n    } else {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000000000, 1000000000);\n    }\n\n    printf(\"%d %lld\\n\", n, k);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type all_zero\n./gen -n 1 -k 1 -type all_positive\n./gen -n 1 -k 1 -type all_negative\n./gen -n 1 -k 1 -type random\n\n./gen -n 10 -k 10 -type all_positive\n./gen -n 10 -k 10 -type all_negative\n./gen -n 10 -k 10 -type alternate\n\n./gen -n 100 -k 1000 -type random\n./gen -n 100 -k 1000 -type all_zero\n\n./gen -n 1000 -k 500000 -type random\n./gen -n 1000 -k 500000 -type all_positive\n\n./gen -n 5000 -k 10000000 -type all_negative\n./gen -n 5000 -k 10000000 -type random\n\n./gen -n 10000 -k 50005000 -type single_large\n./gen -n 10000 -k 50005000 -type single_small\n\n./gen -n 20000 -k 200010000 -type spike\n\n./gen -n 30000 -k 450015000 -type prefix_max\n\n./gen -n 50000 -k 1250025000 -type max_sum\n./gen -n 50000 -k 1250025000 -type min_sum\n\n./gen -n 70000 -k 2450030000 -type random\n\n./gen -n 100000 -k 5000050000 -type all_zero\n./gen -n 100000 -k 5000050000 -type random\n\n./gen -n 100000 -k 1 -type max_sum\n./gen -n 100000 -k 1 -type min_sum\n\n./gen -n 100000 -k 50000 -type all_positive\n./gen -n 100000 -k 50000 -type all_negative\n./gen -n 100000 -k 10000000 -type alternate\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:20.988866",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "192/A",
      "title": "A. Funky Numbers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains an integer n (1 ≤ n ≤ 109).",
      "output_spec": "OutputPrint \"YES\" (without the quotes), if n can be represented as a sum of two triangular numbers, otherwise print \"NO\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy256OutputCopyYESInputCopy512OutputCopyNO",
      "description": "A. Funky Numbers\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains an integer n (1 ≤ n ≤ 109).\n\nOutputPrint \"YES\" (without the quotes), if n can be represented as a sum of two triangular numbers, otherwise print \"NO\" (without the quotes).\n\nInputCopy256OutputCopyYESInputCopy512OutputCopyNO\n\nInputCopy256\n\nOutputCopyYES\n\nInputCopy512\n\nOutputCopyNO\n\nNoteIn the first sample number .In the second sample number 512 can not be represented as a sum of two triangular numbers.",
      "solutions": [
        {
          "title": "Codeforces Round #121 - Codeforces",
          "content": "Hello, dear Codeforces community!I'm glad to present you the next Codeforces Round #121. The contest is brought to you by Ivan Smirnov (ifsmirnov) and Aleksandr Timin (AlTimin), the students of Moscow Institute of Physics and Technology. In our first round we will offer you a good time in Berland: you will hold a demonstration, prevent the demonstration, deal with the most important problems of Berland (with both of them!) and much more.We thank Gerald a lot for the invaluable help he gave as during the contest preparation. He is also the author of one task in the contest. We also thank Delinur for the English version of statements, Aksenov239 for proofreading the statements and MikeMirzayanov for an opportunity to hold a contest on this wonderful site.As usual, the contest will be held in both divisions and the problemsets will overlap. The scoring will be published later.We wish you good luck and hope that you enjoy the contest!UPD1: The scoring is classic in both divisions — 500-1000-1500-2000-2500.UPD2: The contest authors apologize to the contesters for a possibility of misunderstanding of problem B div 1 (D div 2). The statement was fixed soon enough and the incorrect understanding of the problem didn't pass pretests, so the round is rated.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4635",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1266
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces",
          "content": "Задача 192A - Модные числаКратко о решении: переборПодробно о решении: Нетрудно заметить, что это числа положительны, следовательно каждое из слагаемых меньше N. То есть всего различных возможных слагаемых порядка . Это значит то, что мы взять и одно из слагаемых перебрать. Тогда нам нужно научиться проверять, является ли какое-то число треугольным. Заметим, что если мы заранее выпишем все слагаемые в порядке увеличения то мы сможем с помощью бинарного поиска в массиве искать наше число. Это даем там решение за . Если перебирать первое слагаемое в порядке увеличения, то можно использовать два указателя, что дает нам решение за .Задача 192B - Прогулки под дождемКратко о решении: динамика.Подробно о решении: динамика d[i] — количество дней, в течении которых плитка номер i доступна. Пересчет: d[i] = min(a[i], max(d[i - 1], d[i - 2]))Асимптотика решения: O(N)Задача 191A - Династические головоломкиКратко о решении: динамикаПодробно о решении: динамика d[i][j], i — первый символ в имени династии, j — последний текущий символ. d[i][j] — максимальная текущая длина. Переход: для слова с первой буквой l, последней буквой r и длиной s для всех возможных первых букв i состояние d[i][r] может быть улучшено значением d[i][l] + s.Ответом будет являться максимальное значение d[i][i] для всех i.Асимптотика решения: O(N * alpha), где alpha — это размер алфавита.Задача 191B - МитингКратко о решении: конструктивПодробно о решении: заметим, что на последнюю площадь никогда не выгодно подавать заявку (денег мэрии не потратим, ничего не изменится, мы просто потеряем ход). Переберем площадь, на которой мы хотим провести митинг. У нас есть k - 1 ход на то, чтобы потратить деньги мэрии (один ход нам нужен на подачу заявки на искомую площадь). Тратить деньги выгоднее всего на самых дорогих площадях, за исключением последней. Осталось научиться быстро выбирать k - 1 максимум из всего массива, за исключением данного элемента. Для этого сначала отсортируем массив и получим k максимумов (последнюю площадь мы не должны рассматривать). Проверяем, лежит ли наше текущее значение в k - 1 максимальных (бинпоиск и не только). Если лежит, то искомые k - 1 максимумов — это максимальные k элементов без нашего. Если не лежит, то это просто максимальные k элементов. Теперь когда мы понимаем, сколько денег мэрии мы можем потратить, то тратим их и смотрим, остаются ли еще у мэрии деньги на проведение события на нашей текущей площадиАсимптотика решения: Задача 191C - Дураки и дорогиКратко о решении: lcaПодробно о решении: Разобьем каждый путь на два, строго идущих вверх к наименьшему общему предку. Теперь у нас есть только \"вертикальные пути\". Для каждой вершины насчитаем такую величину: количество вертикальных путей, начинающихся в ней минус количество вертикальных путей в ней заканчивающихся. Если мы насчитали эту величину, то ответ для ребра — это сумма значений в его поддереве. Насчитать такую величину довольно просто: берем для каждой пары дураков считаем lca этой пары. В города дураков прибавляем единичку, в lca значение уменьшаем на два.Асимптотика решения: Задача 191D - Схема метроКратко о решении: снова динамикаПодробно о решении: динамика d[v][rest][cycle] — количество линий, которое требуется для того, чтобы в поддереве вершины v все покрасить, в v остаются rest незамкнутым, cycle — правда ли, что нам надо обрабатывать цикл, в котором мы находимся. Если мы находимся не в вершине цикла, то обрабатываем всех детей, говоря что мы хотим, чтобы в них было по одному незакрытому пути. Пусть у нас есть s сыновей, нам надо взять и замкнуть все лишние линии, а недостающие нагенерить. То есть ответ это , если s > rest, и в противном случае.Если мы находимся в вершине цикла, то либо мы покрываем этот цикл кольцом и это стоит нам , где u — это вершина на цикле. отличная от v. Другой вариант — покрыть все участки кольца радиальными линиями. Утверждение: это всегда можно оптимально сделать ровно двумя радиальными. Пусть это не так. Тогда рассмотрим некоторую вершину, в которой радиальные линии <<подвешиваются>> к кольцу. От неё по кольцу в разные стороны уходят два тоннеля, принадлежащие этим линиям. Так как различных линий на кольце сейчас не менее трех, то мы можем перенаправить радиальные линии следующим образом: соединить куски вне кольца друг с другом, а кольцо замкнуть. На кольце останется не менее двух кусков, следовательно все линии останутся валидными, а их число не изменится. Теперь надо выбрать две станции, из поддерева которых будут выходить радиальные ветки, покрывшее кольцо. Стоимость такой станции это d[u][2][0], а обычной — d[u][0][0] (d[v][rest][0] в случае той вершины, которую мы сейчас обрабатываем) . Соответственно, нам надо выбрать две станции с максимальным значением d[u][2][0] - d[u][0][0].Асимптотика решения: O(N)Задача 191E - Разгон митинговКратко о решении: бинарный поиск по ответуПодробно о решении: Сделаем бинарный поиск по ответу. Нам надо посчитать количество отрезков, на которых сумма больше нашего некоторого значения. Как мы это будем делать: будем обрабатывать все отрезки в порядке увеличения правых концов. Отрезки с одинаковыми правыми концами будем обрабатывать пачками. Более подробно: мы будем поддерживать некоторую структуру данных в которой будут храниться суммы всех отрезков c фиксированным правым концом. Для того, чтобы быстро пересчитывать, нам нужно всего добавить в множество некоторый элемент ( 0, если точнее) и добавить ко всем элементам множества некоторое значение (a[i], если быть точнее). Еще нам нужно уметь отвечать на запрос <<количество элементов, больших данного на отрезке>>. Все это умеет быстро реализовывать, например, декартово дерево. Но нам придется дополнительно хранить некоторую величину X, означающую <<надо прибавить к элементу из декартова дерева X, чтобы получить реальное значение>>. Тогда при добавлении элемента a в нашу структуру надо будет положить в декартово дерево величину a - X, а прибавление некоторой величины ко всему множеству реализуется простым изменением X. То есть у нас есть структура данных, которая умеет все эти операции выполнять за . То есть одна итерация внешнего бинпоиска работает за , следовательно весь алгоритм работает за Асимптотика решения:",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4634",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 192\\s*A"
          },
          "content_length": 6193
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #121 - Codeforces - Code 1",
          "code": "return printf(\"%I64d\\n\",end+1), 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #121 - Codeforces - Code 2",
          "code": "return !printf(\"%I64d\\n\",end+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 1",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 2",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<long long> triangular_numbers;\n\nvoid precompute_triangular_numbers() {\n    long long max_T = 1e9;\n    for (long long k = 1;; ++k) {\n        long long T = k * (k + 1) / 2;\n        if (T > max_T) break;\n        triangular_numbers.push_back(T);\n    }\n}\n\nbool is_sum_of_two_triangular_numbers(long long n) {\n    for (long long T1 : triangular_numbers) {\n        if (T1 > n) break;\n        long long T2 = n - T1;\n        if (binary_search(triangular_numbers.begin(), triangular_numbers.end(), T2)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    precompute_triangular_numbers();\n\n    long long n = opt<long long>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random_yes\") {\n        // Generate n that is sum of two triangular numbers\n        long long maxn = opt<long long>(\"maxn\", 1e9);\n        while (true) {\n            int k1 = rnd.next(0, (int)triangular_numbers.size() - 1);\n            int k2 = rnd.next(0, (int)triangular_numbers.size() - 1);\n            long long sum = triangular_numbers[k1] + triangular_numbers[k2];\n            if (sum <= maxn) {\n                printf(\"%lld\\n\", sum);\n                break;\n            }\n        }\n    } else if (type == \"random_no\") {\n        // Generate n that is NOT sum of two triangular numbers\n        long long maxn = opt<long long>(\"maxn\", 1e9);\n        while (true) {\n            long long n_candidate = rnd.next(1LL, maxn);\n            if (!is_sum_of_two_triangular_numbers(n_candidate)) {\n                printf(\"%lld\\n\", n_candidate);\n                break;\n            }\n        }\n    } else if (type == \"sum_same\") {\n        // Generate n that is sum of two same triangular numbers\n        long long maxn = opt<long long>(\"maxn\", 1e9);\n        while (true) {\n            int k = rnd.next(0, (int)triangular_numbers.size() - 1);\n            long long sum = triangular_numbers[k] * 2;\n            if (sum <= maxn) {\n                printf(\"%lld\\n\", sum);\n                break;\n            }\n        }\n    } else if (type == \"sum_diff\") {\n        // Generate n that is sum of two different triangular numbers\n        long long maxn = opt<long long>(\"maxn\", 1e9);\n        while (true) {\n            int k1 = rnd.next(0, (int)triangular_numbers.size() - 1);\n            int k2 = rnd.next(0, (int)triangular_numbers.size() - 1);\n            if (k1 == k2) continue;\n            long long sum = triangular_numbers[k1] + triangular_numbers[k2];\n            if (sum <= maxn) {\n                printf(\"%lld\\n\", sum);\n                break;\n            }\n        }\n    } else if (type == \"boundary\") {\n        // Output boundary values of n\n        vector<long long> boundary_ns = {1LL, 2LL, (long long)1e9};\n        for (long long n_boundary : boundary_ns) {\n            printf(\"%lld\\n\", n_boundary);\n        }\n    } else if (type == \"small\") {\n        // Generate small n\n        long long maxn = opt<long long>(\"maxn\", 100);\n        long long n_candidate = rnd.next(1LL, maxn);\n        printf(\"%lld\\n\", n_candidate);\n    } else if (type == \"large\") {\n        // Generate large n\n        long long minn = opt<long long>(\"minn\", 1e9 - 100);\n        long long maxn = opt<long long>(\"maxn\", 1e9);\n        long long n_candidate = rnd.next(minn, maxn);\n        printf(\"%lld\\n\", n_candidate);\n    } else if (type == \"specific\") {\n        // Output specific n\n        if (n == -1) {\n            n = opt<long long>(\"value\");\n        }\n        printf(\"%lld\\n\", n);\n    } else {\n        // Default: random n in [1, 1e9]\n        long long maxn = opt<long long>(\"maxn\", 1e9);\n        long long n_candidate = rnd.next(1LL, maxn);\n        printf(\"%lld\\n\", n_candidate);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<long long> triangular_numbers;\n\nvoid precompute_triangular_numbers() {\n    long long max_T = 1e9;\n    for (long long k = 1;; ++k) {\n        long long T = k * (k + 1) / 2;\n        if (T > max_T) break;\n        triangular_numbers.push_back(T);\n    }\n}\n\nbool is_sum_of_two_triangular_numbers(long long n) {\n    for (long long T1 : triangular_numbers) {\n        if (T1 > n) break;\n        long long T2 = n - T1;\n        if (binary_search(triangular_numbers.begin(), triangular_numbers.end(), T2)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    precompute_triangular_numbers();\n\n    long long n = opt<long long>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random_yes\") {\n        // Generate n that is sum of two triangular numbers\n        long long maxn = opt<long long>(\"maxn\", 1e9);\n        while (true) {\n            int k1 = rnd.next(0, (int)triangular_numbers.size() - 1);\n            int k2 = rnd.next(0, (int)triangular_numbers.size() - 1);\n            long long sum = triangular_numbers[k1] + triangular_numbers[k2];\n            if (sum <= maxn) {\n                printf(\"%lld\\n\", sum);\n                break;\n            }\n        }\n    } else if (type == \"random_no\") {\n        // Generate n that is NOT sum of two triangular numbers\n        long long maxn = opt<long long>(\"maxn\", 1e9);\n        while (true) {\n            long long n_candidate = rnd.next(1LL, maxn);\n            if (!is_sum_of_two_triangular_numbers(n_candidate)) {\n                printf(\"%lld\\n\", n_candidate);\n                break;\n            }\n        }\n    } else if (type == \"sum_same\") {\n        // Generate n that is sum of two same triangular numbers\n        long long maxn = opt<long long>(\"maxn\", 1e9);\n        while (true) {\n            int k = rnd.next(0, (int)triangular_numbers.size() - 1);\n            long long sum = triangular_numbers[k] * 2;\n            if (sum <= maxn) {\n                printf(\"%lld\\n\", sum);\n                break;\n            }\n        }\n    } else if (type == \"sum_diff\") {\n        // Generate n that is sum of two different triangular numbers\n        long long maxn = opt<long long>(\"maxn\", 1e9);\n        while (true) {\n            int k1 = rnd.next(0, (int)triangular_numbers.size() - 1);\n            int k2 = rnd.next(0, (int)triangular_numbers.size() - 1);\n            if (k1 == k2) continue;\n            long long sum = triangular_numbers[k1] + triangular_numbers[k2];\n            if (sum <= maxn) {\n                printf(\"%lld\\n\", sum);\n                break;\n            }\n        }\n    } else if (type == \"boundary\") {\n        // Output boundary values of n\n        vector<long long> boundary_ns = {1LL, 2LL, (long long)1e9};\n        for (long long n_boundary : boundary_ns) {\n            printf(\"%lld\\n\", n_boundary);\n        }\n    } else if (type == \"small\") {\n        // Generate small n\n        long long maxn = opt<long long>(\"maxn\", 100);\n        long long n_candidate = rnd.next(1LL, maxn);\n        printf(\"%lld\\n\", n_candidate);\n    } else if (type == \"large\") {\n        // Generate large n\n        long long minn = opt<long long>(\"minn\", 1e9 - 100);\n        long long maxn = opt<long long>(\"maxn\", 1e9);\n        long long n_candidate = rnd.next(minn, maxn);\n        printf(\"%lld\\n\", n_candidate);\n    } else if (type == \"specific\") {\n        // Output specific n\n        if (n == -1) {\n            n = opt<long long>(\"value\");\n        }\n        printf(\"%lld\\n\", n);\n    } else {\n        // Default: random n in [1, 1e9]\n        long long maxn = opt<long long>(\"maxn\", 1e9);\n        long long n_candidate = rnd.next(1LL, maxn);\n        printf(\"%lld\\n\", n_candidate);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small numbers, random n\n./gen -type small -maxn 10\n./gen -type small -maxn 100\n\n# Large numbers, random n\n./gen -type large -minn 999999900 -maxn 1000000000\n\n# Random n that is sum of two triangular numbers\n./gen -type random_yes\n./gen -type random_yes -maxn 1000\n./gen -type random_yes -maxn 1000000\n\n# Random n that is NOT sum of two triangular numbers\n./gen -type random_no\n./gen -type random_no -maxn 1000\n./gen -type random_no -maxn 1000000\n\n# n that is sum of two same triangular numbers\n./gen -type sum_same\n./gen -type sum_same -maxn 1000000000\n\n# n that is sum of two different triangular numbers\n./gen -type sum_diff\n./gen -type sum_diff -maxn 1000000000\n\n# Boundary values\n./gen -type boundary\n\n# Specific small values\n./gen -type specific -value 1\n./gen -type specific -value 3\n./gen -type specific -value 6\n./gen -type specific -value 28\n\n# Specific large values\n./gen -type specific -value 999999999\n./gen -type specific -value 1000000000\n\n# Specific n that is known to be sum of two triangular numbers\n./gen -type specific -value 256\n./gen -type specific -value 66\n./gen -type specific -value 5050\n\n# Specific n that is known NOT to be sum of two triangular numbers\n./gen -type specific -value 512\n./gen -type specific -value 100\n./gen -type specific -value 1023\n\n# Multiple random yes cases\n./gen -type random_yes\n./gen -type random_yes\n./gen -type random_yes\n\n# Multiple random no cases\n./gen -type random_no\n./gen -type random_no\n./gen -type random_no\n\n# Random n in full range\n./gen\n./gen\n./gen\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:22.637234",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "192/B",
      "title": "B. Walking in the Rain",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 103) — the boulevard's length in tiles.The second line contains n space-separated integers ai — the number of days after which the i-th tile gets destroyed (1 ≤ ai ≤ 103).",
      "output_spec": "OutputPrint a single number — the sought number of days.",
      "sample_tests": "ExamplesInputCopy410 3 5 10OutputCopy5InputCopy510 2 8 3 5OutputCopy5",
      "description": "B. Walking in the Rain\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 103) — the boulevard's length in tiles.The second line contains n space-separated integers ai — the number of days after which the i-th tile gets destroyed (1 ≤ ai ≤ 103).\n\nOutputPrint a single number — the sought number of days.\n\nInputCopy410 3 5 10OutputCopy5InputCopy510 2 8 3 5OutputCopy5\n\nInputCopy410 3 5 10\n\nOutputCopy5\n\nInputCopy510 2 8 3 5\n\nOutputCopy5\n\nNoteIn the first sample the second tile gets destroyed after day three, and the only path left is 1 → 3 → 4. After day five there is a two-tile gap between the first and the last tile, you can't jump over it.In the second sample path 1 → 3 → 5 is available up to day five, inclusive. On day six the last tile is destroyed and the walk is thwarted.",
      "solutions": [
        {
          "title": "Codeforces Round #121 - Codeforces",
          "content": "Hello, dear Codeforces community!I'm glad to present you the next Codeforces Round #121. The contest is brought to you by Ivan Smirnov (ifsmirnov) and Aleksandr Timin (AlTimin), the students of Moscow Institute of Physics and Technology. In our first round we will offer you a good time in Berland: you will hold a demonstration, prevent the demonstration, deal with the most important problems of Berland (with both of them!) and much more.We thank Gerald a lot for the invaluable help he gave as during the contest preparation. He is also the author of one task in the contest. We also thank Delinur for the English version of statements, Aksenov239 for proofreading the statements and MikeMirzayanov for an opportunity to hold a contest on this wonderful site.As usual, the contest will be held in both divisions and the problemsets will overlap. The scoring will be published later.We wish you good luck and hope that you enjoy the contest!UPD1: The scoring is classic in both divisions — 500-1000-1500-2000-2500.UPD2: The contest authors apologize to the contesters for a possibility of misunderstanding of problem B div 1 (D div 2). The statement was fixed soon enough and the incorrect understanding of the problem didn't pass pretests, so the round is rated.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4635",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1266
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces",
          "content": "Задача 192A - Модные числаКратко о решении: переборПодробно о решении: Нетрудно заметить, что это числа положительны, следовательно каждое из слагаемых меньше N. То есть всего различных возможных слагаемых порядка . Это значит то, что мы взять и одно из слагаемых перебрать. Тогда нам нужно научиться проверять, является ли какое-то число треугольным. Заметим, что если мы заранее выпишем все слагаемые в порядке увеличения то мы сможем с помощью бинарного поиска в массиве искать наше число. Это даем там решение за . Если перебирать первое слагаемое в порядке увеличения, то можно использовать два указателя, что дает нам решение за .Задача 192B - Прогулки под дождемКратко о решении: динамика.Подробно о решении: динамика d[i] — количество дней, в течении которых плитка номер i доступна. Пересчет: d[i] = min(a[i], max(d[i - 1], d[i - 2]))Асимптотика решения: O(N)Задача 191A - Династические головоломкиКратко о решении: динамикаПодробно о решении: динамика d[i][j], i — первый символ в имени династии, j — последний текущий символ. d[i][j] — максимальная текущая длина. Переход: для слова с первой буквой l, последней буквой r и длиной s для всех возможных первых букв i состояние d[i][r] может быть улучшено значением d[i][l] + s.Ответом будет являться максимальное значение d[i][i] для всех i.Асимптотика решения: O(N * alpha), где alpha — это размер алфавита.Задача 191B - МитингКратко о решении: конструктивПодробно о решении: заметим, что на последнюю площадь никогда не выгодно подавать заявку (денег мэрии не потратим, ничего не изменится, мы просто потеряем ход). Переберем площадь, на которой мы хотим провести митинг. У нас есть k - 1 ход на то, чтобы потратить деньги мэрии (один ход нам нужен на подачу заявки на искомую площадь). Тратить деньги выгоднее всего на самых дорогих площадях, за исключением последней. Осталось научиться быстро выбирать k - 1 максимум из всего массива, за исключением данного элемента. Для этого сначала отсортируем массив и получим k максимумов (последнюю площадь мы не должны рассматривать). Проверяем, лежит ли наше текущее значение в k - 1 максимальных (бинпоиск и не только). Если лежит, то искомые k - 1 максимумов — это максимальные k элементов без нашего. Если не лежит, то это просто максимальные k элементов. Теперь когда мы понимаем, сколько денег мэрии мы можем потратить, то тратим их и смотрим, остаются ли еще у мэрии деньги на проведение события на нашей текущей площадиАсимптотика решения: Задача 191C - Дураки и дорогиКратко о решении: lcaПодробно о решении: Разобьем каждый путь на два, строго идущих вверх к наименьшему общему предку. Теперь у нас есть только \"вертикальные пути\". Для каждой вершины насчитаем такую величину: количество вертикальных путей, начинающихся в ней минус количество вертикальных путей в ней заканчивающихся. Если мы насчитали эту величину, то ответ для ребра — это сумма значений в его поддереве. Насчитать такую величину довольно просто: берем для каждой пары дураков считаем lca этой пары. В города дураков прибавляем единичку, в lca значение уменьшаем на два.Асимптотика решения: Задача 191D - Схема метроКратко о решении: снова динамикаПодробно о решении: динамика d[v][rest][cycle] — количество линий, которое требуется для того, чтобы в поддереве вершины v все покрасить, в v остаются rest незамкнутым, cycle — правда ли, что нам надо обрабатывать цикл, в котором мы находимся. Если мы находимся не в вершине цикла, то обрабатываем всех детей, говоря что мы хотим, чтобы в них было по одному незакрытому пути. Пусть у нас есть s сыновей, нам надо взять и замкнуть все лишние линии, а недостающие нагенерить. То есть ответ это , если s > rest, и в противном случае.Если мы находимся в вершине цикла, то либо мы покрываем этот цикл кольцом и это стоит нам , где u — это вершина на цикле. отличная от v. Другой вариант — покрыть все участки кольца радиальными линиями. Утверждение: это всегда можно оптимально сделать ровно двумя радиальными. Пусть это не так. Тогда рассмотрим некоторую вершину, в которой радиальные линии <<подвешиваются>> к кольцу. От неё по кольцу в разные стороны уходят два тоннеля, принадлежащие этим линиям. Так как различных линий на кольце сейчас не менее трех, то мы можем перенаправить радиальные линии следующим образом: соединить куски вне кольца друг с другом, а кольцо замкнуть. На кольце останется не менее двух кусков, следовательно все линии останутся валидными, а их число не изменится. Теперь надо выбрать две станции, из поддерева которых будут выходить радиальные ветки, покрывшее кольцо. Стоимость такой станции это d[u][2][0], а обычной — d[u][0][0] (d[v][rest][0] в случае той вершины, которую мы сейчас обрабатываем) . Соответственно, нам надо выбрать две станции с максимальным значением d[u][2][0] - d[u][0][0].Асимптотика решения: O(N)Задача 191E - Разгон митинговКратко о решении: бинарный поиск по ответуПодробно о решении: Сделаем бинарный поиск по ответу. Нам надо посчитать количество отрезков, на которых сумма больше нашего некоторого значения. Как мы это будем делать: будем обрабатывать все отрезки в порядке увеличения правых концов. Отрезки с одинаковыми правыми концами будем обрабатывать пачками. Более подробно: мы будем поддерживать некоторую структуру данных в которой будут храниться суммы всех отрезков c фиксированным правым концом. Для того, чтобы быстро пересчитывать, нам нужно всего добавить в множество некоторый элемент ( 0, если точнее) и добавить ко всем элементам множества некоторое значение (a[i], если быть точнее). Еще нам нужно уметь отвечать на запрос <<количество элементов, больших данного на отрезке>>. Все это умеет быстро реализовывать, например, декартово дерево. Но нам придется дополнительно хранить некоторую величину X, означающую <<надо прибавить к элементу из декартова дерева X, чтобы получить реальное значение>>. Тогда при добавлении элемента a в нашу структуру надо будет положить в декартово дерево величину a - X, а прибавление некоторой величины ко всему множеству реализуется простым изменением X. То есть у нас есть структура данных, которая умеет все эти операции выполнять за . То есть одна итерация внешнего бинпоиска работает за , следовательно весь алгоритм работает за Асимптотика решения:",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4634",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 192\\s*B"
          },
          "content_length": 6193
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #121 - Codeforces - Code 1",
          "code": "return printf(\"%I64d\\n\",end+1), 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #121 - Codeforces - Code 2",
          "code": "return !printf(\"%I64d\\n\",end+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 1",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 2",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000);\n    inf.readEoln();\n    inf.readInts(n, 1, 1000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000);\n    inf.readEoln();\n    inf.readInts(n, 1, 1000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000);\n    inf.readEoln();\n    inf.readInts(n, 1, 1000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n + 1); // 1-based indexing\n\n    if (type == \"random\") {\n        // Random ai between 1 and 1000\n        for (int i = 1; i <= n; ++i) {\n            ai[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"early_destruction\") {\n        // ai between 1 and 10 (tiles are destroyed early)\n        for (int i = 1; i <= n; ++i) {\n            ai[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"late_destruction\") {\n        // All tiles have maximal ai (tiles are destroyed late)\n        for (int i = 1; i <= n; ++i) {\n            ai[i] = 1000;\n        }\n    } else if (type == \"tile1_early\") {\n        // Tile 1 is destroyed early\n        ai[1] = 1;\n        for (int i = 2; i <= n; ++i) {\n            ai[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"tilen_early\") {\n        // Tile n is destroyed early\n        ai[n] = 1;\n        for (int i = 1; i <= n - 1; ++i) {\n            ai[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"intermediate_block\") {\n        // Destroy tiles in the middle to block the path\n        int mid = n / 2;\n        ai[mid] = ai[mid + 1] = 1; // Tiles are destroyed early\n        for (int i = 1; i <= n; ++i) {\n            if (i != mid && i != mid + 1)\n                ai[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"path_always_possible\") {\n        // Tiles 1 and n are destroyed late\n        ai[1] = ai[n] = 1000;\n        for (int i = 2; i <= n - 1; ++i) {\n            ai[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"path_thwarted_immediately\") {\n        // Walk is thwarted immediately\n        int which = rnd.next(1, 2);\n        if (which == 1) {\n            // Destroy tile 1\n            ai[1] = 1;\n            for (int i = 2; i <= n; ++i) {\n                ai[i] = rnd.next(1, 1000);\n            }\n        } else {\n            // Destroy tile n\n            ai[n] = 1;\n            for (int i = 1; i <= n - 1; ++i) {\n                ai[i] = rnd.next(1, 1000);\n            }\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output ai\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n + 1); // 1-based indexing\n\n    if (type == \"random\") {\n        // Random ai between 1 and 1000\n        for (int i = 1; i <= n; ++i) {\n            ai[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"early_destruction\") {\n        // ai between 1 and 10 (tiles are destroyed early)\n        for (int i = 1; i <= n; ++i) {\n            ai[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"late_destruction\") {\n        // All tiles have maximal ai (tiles are destroyed late)\n        for (int i = 1; i <= n; ++i) {\n            ai[i] = 1000;\n        }\n    } else if (type == \"tile1_early\") {\n        // Tile 1 is destroyed early\n        ai[1] = 1;\n        for (int i = 2; i <= n; ++i) {\n            ai[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"tilen_early\") {\n        // Tile n is destroyed early\n        ai[n] = 1;\n        for (int i = 1; i <= n - 1; ++i) {\n            ai[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"intermediate_block\") {\n        // Destroy tiles in the middle to block the path\n        int mid = n / 2;\n        ai[mid] = ai[mid + 1] = 1; // Tiles are destroyed early\n        for (int i = 1; i <= n; ++i) {\n            if (i != mid && i != mid + 1)\n                ai[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"path_always_possible\") {\n        // Tiles 1 and n are destroyed late\n        ai[1] = ai[n] = 1000;\n        for (int i = 2; i <= n - 1; ++i) {\n            ai[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"path_thwarted_immediately\") {\n        // Walk is thwarted immediately\n        int which = rnd.next(1, 2);\n        if (which == 1) {\n            // Destroy tile 1\n            ai[1] = 1;\n            for (int i = 2; i <= n; ++i) {\n                ai[i] = rnd.next(1, 1000);\n            }\n        } else {\n            // Destroy tile n\n            ai[n] = 1;\n            for (int i = 1; i <= n - 1; ++i) {\n                ai[i] = rnd.next(1, 1000);\n            }\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output ai\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random small n\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 50 -type random\n\n# Random medium n\n./gen -n 100 -type random\n./gen -n 500 -type random\n\n# Random max n\n./gen -n 1000 -type random\n\n# Early destruction (tiles are destroyed early)\n./gen -n 10 -type early_destruction\n./gen -n 50 -type early_destruction\n./gen -n 100 -type early_destruction\n./gen -n 500 -type early_destruction\n\n# Late destruction (tiles last for a long time)\n./gen -n 10 -type late_destruction\n./gen -n 50 -type late_destruction\n./gen -n 100 -type late_destruction\n./gen -n 1000 -type late_destruction\n\n# Tile 1 destroyed early\n./gen -n 10 -type tile1_early\n./gen -n 100 -type tile1_early\n./gen -n 1000 -type tile1_early\n\n# Tile n destroyed early\n./gen -n 10 -type tilen_early\n./gen -n 100 -type tilen_early\n./gen -n 1000 -type tilen_early\n\n# Intermediate block (path is blocked in the middle)\n./gen -n 10 -type intermediate_block\n./gen -n 100 -type intermediate_block\n./gen -n 1000 -type intermediate_block\n\n# Path always possible (tiles 1 and n are lasting)\n./gen -n 10 -type path_always_possible\n./gen -n 100 -type path_always_possible\n./gen -n 1000 -type path_always_possible\n\n# Path thwarted immediately (tile 1 or n destroyed immediately)\n./gen -n 10 -type path_thwarted_immediately\n./gen -n 100 -type path_thwarted_immediately\n./gen -n 1000 -type path_thwarted_immediately\n\n# Minimal n (edge cases)\n./gen -n 1 -type random\n./gen -n 2 -type random\n\n# Max n with random ai\n./gen -n 1000 -type random\n\n# Random ai with early destruction\n./gen -n 1000 -type early_destruction\n\n# Random ai with potential blockage\n./gen -n 1000 -type intermediate_block\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:24.751256",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "192/C",
      "title": "C. Dynasty Puzzles",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 5·105) — the number of names in Vasya's list. Next n lines contain n abbreviated names, one per line. An abbreviated name is a non-empty sequence of lowercase Latin letters. Its length does not exceed 10 characters.",
      "output_spec": "OutputPrint a single number — length of the sought dynasty's name in letters.If Vasya's list is wrong and no dynasty can be found there, print a single number 0.",
      "sample_tests": "ExamplesInputCopy3abccacbaOutputCopy6InputCopy4vvpvvpdamvvpOutputCopy0InputCopy3abcdefOutputCopy1",
      "description": "C. Dynasty Puzzles\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 5·105) — the number of names in Vasya's list. Next n lines contain n abbreviated names, one per line. An abbreviated name is a non-empty sequence of lowercase Latin letters. Its length does not exceed 10 characters.\n\nOutputPrint a single number — length of the sought dynasty's name in letters.If Vasya's list is wrong and no dynasty can be found there, print a single number 0.\n\nInputCopy3abccacbaOutputCopy6InputCopy4vvpvvpdamvvpOutputCopy0InputCopy3abcdefOutputCopy1\n\nInputCopy3abccacba\n\nOutputCopy6\n\nInputCopy4vvpvvpdamvvp\n\nOutputCopy0\n\nInputCopy3abcdef\n\nOutputCopy1\n\nNoteIn the first sample two dynasties can exist: the one called \"abcca\" (with the first and second kings) and the one called \"abccba\" (with the first and third kings). In the second sample there aren't acceptable dynasties.The only dynasty in the third sample consists of one king, his name is \"c\".",
      "solutions": [
        {
          "title": "Codeforces Round #121 - Codeforces",
          "content": "Hello, dear Codeforces community!I'm glad to present you the next Codeforces Round #121. The contest is brought to you by Ivan Smirnov (ifsmirnov) and Aleksandr Timin (AlTimin), the students of Moscow Institute of Physics and Technology. In our first round we will offer you a good time in Berland: you will hold a demonstration, prevent the demonstration, deal with the most important problems of Berland (with both of them!) and much more.We thank Gerald a lot for the invaluable help he gave as during the contest preparation. He is also the author of one task in the contest. We also thank Delinur for the English version of statements, Aksenov239 for proofreading the statements and MikeMirzayanov for an opportunity to hold a contest on this wonderful site.As usual, the contest will be held in both divisions and the problemsets will overlap. The scoring will be published later.We wish you good luck and hope that you enjoy the contest!UPD1: The scoring is classic in both divisions — 500-1000-1500-2000-2500.UPD2: The contest authors apologize to the contesters for a possibility of misunderstanding of problem B div 1 (D div 2). The statement was fixed soon enough and the incorrect understanding of the problem didn't pass pretests, so the round is rated.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4635",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1266
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces",
          "content": "Задача 192A - Модные числаКратко о решении: переборПодробно о решении: Нетрудно заметить, что это числа положительны, следовательно каждое из слагаемых меньше N. То есть всего различных возможных слагаемых порядка . Это значит то, что мы взять и одно из слагаемых перебрать. Тогда нам нужно научиться проверять, является ли какое-то число треугольным. Заметим, что если мы заранее выпишем все слагаемые в порядке увеличения то мы сможем с помощью бинарного поиска в массиве искать наше число. Это даем там решение за . Если перебирать первое слагаемое в порядке увеличения, то можно использовать два указателя, что дает нам решение за .Задача 192B - Прогулки под дождемКратко о решении: динамика.Подробно о решении: динамика d[i] — количество дней, в течении которых плитка номер i доступна. Пересчет: d[i] = min(a[i], max(d[i - 1], d[i - 2]))Асимптотика решения: O(N)Задача 191A - Династические головоломкиКратко о решении: динамикаПодробно о решении: динамика d[i][j], i — первый символ в имени династии, j — последний текущий символ. d[i][j] — максимальная текущая длина. Переход: для слова с первой буквой l, последней буквой r и длиной s для всех возможных первых букв i состояние d[i][r] может быть улучшено значением d[i][l] + s.Ответом будет являться максимальное значение d[i][i] для всех i.Асимптотика решения: O(N * alpha), где alpha — это размер алфавита.Задача 191B - МитингКратко о решении: конструктивПодробно о решении: заметим, что на последнюю площадь никогда не выгодно подавать заявку (денег мэрии не потратим, ничего не изменится, мы просто потеряем ход). Переберем площадь, на которой мы хотим провести митинг. У нас есть k - 1 ход на то, чтобы потратить деньги мэрии (один ход нам нужен на подачу заявки на искомую площадь). Тратить деньги выгоднее всего на самых дорогих площадях, за исключением последней. Осталось научиться быстро выбирать k - 1 максимум из всего массива, за исключением данного элемента. Для этого сначала отсортируем массив и получим k максимумов (последнюю площадь мы не должны рассматривать). Проверяем, лежит ли наше текущее значение в k - 1 максимальных (бинпоиск и не только). Если лежит, то искомые k - 1 максимумов — это максимальные k элементов без нашего. Если не лежит, то это просто максимальные k элементов. Теперь когда мы понимаем, сколько денег мэрии мы можем потратить, то тратим их и смотрим, остаются ли еще у мэрии деньги на проведение события на нашей текущей площадиАсимптотика решения: Задача 191C - Дураки и дорогиКратко о решении: lcaПодробно о решении: Разобьем каждый путь на два, строго идущих вверх к наименьшему общему предку. Теперь у нас есть только \"вертикальные пути\". Для каждой вершины насчитаем такую величину: количество вертикальных путей, начинающихся в ней минус количество вертикальных путей в ней заканчивающихся. Если мы насчитали эту величину, то ответ для ребра — это сумма значений в его поддереве. Насчитать такую величину довольно просто: берем для каждой пары дураков считаем lca этой пары. В города дураков прибавляем единичку, в lca значение уменьшаем на два.Асимптотика решения: Задача 191D - Схема метроКратко о решении: снова динамикаПодробно о решении: динамика d[v][rest][cycle] — количество линий, которое требуется для того, чтобы в поддереве вершины v все покрасить, в v остаются rest незамкнутым, cycle — правда ли, что нам надо обрабатывать цикл, в котором мы находимся. Если мы находимся не в вершине цикла, то обрабатываем всех детей, говоря что мы хотим, чтобы в них было по одному незакрытому пути. Пусть у нас есть s сыновей, нам надо взять и замкнуть все лишние линии, а недостающие нагенерить. То есть ответ это , если s > rest, и в противном случае.Если мы находимся в вершине цикла, то либо мы покрываем этот цикл кольцом и это стоит нам , где u — это вершина на цикле. отличная от v. Другой вариант — покрыть все участки кольца радиальными линиями. Утверждение: это всегда можно оптимально сделать ровно двумя радиальными. Пусть это не так. Тогда рассмотрим некоторую вершину, в которой радиальные линии <<подвешиваются>> к кольцу. От неё по кольцу в разные стороны уходят два тоннеля, принадлежащие этим линиям. Так как различных линий на кольце сейчас не менее трех, то мы можем перенаправить радиальные линии следующим образом: соединить куски вне кольца друг с другом, а кольцо замкнуть. На кольце останется не менее двух кусков, следовательно все линии останутся валидными, а их число не изменится. Теперь надо выбрать две станции, из поддерева которых будут выходить радиальные ветки, покрывшее кольцо. Стоимость такой станции это d[u][2][0], а обычной — d[u][0][0] (d[v][rest][0] в случае той вершины, которую мы сейчас обрабатываем) . Соответственно, нам надо выбрать две станции с максимальным значением d[u][2][0] - d[u][0][0].Асимптотика решения: O(N)Задача 191E - Разгон митинговКратко о решении: бинарный поиск по ответуПодробно о решении: Сделаем бинарный поиск по ответу. Нам надо посчитать количество отрезков, на которых сумма больше нашего некоторого значения. Как мы это будем делать: будем обрабатывать все отрезки в порядке увеличения правых концов. Отрезки с одинаковыми правыми концами будем обрабатывать пачками. Более подробно: мы будем поддерживать некоторую структуру данных в которой будут храниться суммы всех отрезков c фиксированным правым концом. Для того, чтобы быстро пересчитывать, нам нужно всего добавить в множество некоторый элемент ( 0, если точнее) и добавить ко всем элементам множества некоторое значение (a[i], если быть точнее). Еще нам нужно уметь отвечать на запрос <<количество элементов, больших данного на отрезке>>. Все это умеет быстро реализовывать, например, декартово дерево. Но нам придется дополнительно хранить некоторую величину X, означающую <<надо прибавить к элементу из декартова дерева X, чтобы получить реальное значение>>. Тогда при добавлении элемента a в нашу структуру надо будет положить в декартово дерево величину a - X, а прибавление некоторой величины ко всему множеству реализуется простым изменением X. То есть у нас есть структура данных, которая умеет все эти операции выполнять за . То есть одна итерация внешнего бинпоиска работает за , следовательно весь алгоритм работает за Асимптотика решения:",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4634",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 192 和字母"
          },
          "content_length": 6193
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #121 - Codeforces - Code 1",
          "code": "return printf(\"%I64d\\n\",end+1), 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #121 - Codeforces - Code 2",
          "code": "return !printf(\"%I64d\\n\",end+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 1",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 2",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string name = inf.readLine(\"[a-z]{1,10}\", \"name\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string name = inf.readLine(\"[a-z]{1,10}\", \"name\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string name = inf.readLine(\"[a-z]{1,10}\", \"name\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int len = opt<int>(\"len\", -1); // default -1, will set later\n\n    vector<string> names(n);\n\n    if (type == \"max_dy\") {\n        // Generate names such that all can be included in the dynasty\n        // We need to make sure that:\n        // - For each consecutive name, the first letter of successor equals the last letter of predecessor\n        // - The first letter of the first name equals the last letter of the last name\n\n        // Let's pick a letter, say 'a', and make all names start and end with 'a'\n\n        for (int i = 0; i < n; ++i) {\n            int name_len = len;\n            if (len == -1) {\n                // generate random length between 1 and 10\n                name_len = rnd.next(1, 10);\n            }\n            string name = \"a\"; // first letter is 'a'\n            for (int j = 1; j < name_len -1; ++j) {\n                name += (char)(rnd.next(0,25)+'a');\n            }\n            if (name_len > 1)\n                name += \"a\"; // last letter is 'a'\n            names[i] = name;\n        }\n    } else if (type == \"no_dy\") {\n        // Generate names such that no dynasty can be formed\n        // Need to ensure that for any selection of names in order, the conditions cannot be satisfied\n        // We can make last letters not equal to next first letters\n\n        char last_c = '\\0';\n        for (int i = 0; i < n; ++i) {\n            int name_len = len;\n            if (len == -1) {\n                // generate random length between 1 and 10\n                name_len = rnd.next(1, 10);\n            }\n            string name;\n            char first_c, current_last_c;\n            if (name_len == 1) {\n                // name is a single character\n                first_c = current_last_c = (char)(rnd.next(0,25)+'a');\n                name = string(1, first_c);\n            } else {\n                do {\n                    first_c = (char)(rnd.next(0,25)+'a');\n                } while (first_c == last_c);\n                current_last_c = (char)(((first_c - 'a' + rnd.next(1,25))%26)+'a');\n                name = first_c;\n                for (int j = 1; j < name_len -1; ++j) {\n                    name += (char)(rnd.next(0,25)+'a');\n                }\n                name += current_last_c;\n            }\n            last_c = current_last_c;\n            names[i] = name;\n        }\n    } else if (type == \"random\") {\n        // Generate random names\n        for (int i = 0; i < n; ++i) {\n            int name_len = len;\n            if (len == -1) {\n                name_len = rnd.next(1, 10);\n            }\n            string name;\n            for (int j = 0; j < name_len; ++j) {\n                name += (char)(rnd.next(0,25)+'a');\n            }\n            names[i] = name;\n        }\n    } else if (type == \"single_char\") {\n        // All names are of length 1\n        for (int i = 0; i < n; ++i) {\n            char c = (char)(rnd.next(0,25)+'a');\n            names[i] = string(1, c);\n        }\n    } else if (type == \"max_length\") {\n        // All names are of length 10\n        for (int i = 0; i < n; ++i) {\n            string name;\n            for (int j = 0; j < 10; ++j) {\n                name += (char)(rnd.next(0,25)+'a');\n            }\n            names[i] = name;\n        }\n    } else if (type == \"cycle\") {\n        // Build a cycle of names where the first and last letters match\n        // and the chain can be formed\n\n        vector<char> chars;\n        for (int i = 0; i < n; ++i) {\n            chars.push_back((char)(rnd.next(0,25)+'a'));\n        }\n        chars.push_back(chars[0]); // to complete the cycle\n\n        for (int i = 0; i < n; ++i) {\n            int name_len = len;\n            if (len == -1) name_len = rnd.next(1, 10);\n            char first_c = chars[i];\n            char last_c = chars[i+1];\n\n            string name = \"\";\n            name += first_c;\n            for (int j = 1; j < name_len -1; ++j) {\n                name += (char)(rnd.next(0,25)+'a');\n            }\n            if (name_len > 1)\n                name += last_c;\n            names[i] = name;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int name_len = len;\n            if (len == -1) {\n                name_len = rnd.next(1, 10);\n            }\n            string name;\n            for (int j = 0; j < name_len; ++j) {\n                name += (char)(rnd.next(0,25)+'a');\n            }\n            names[i] = name;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output names\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", names[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int len = opt<int>(\"len\", -1); // default -1, will set later\n\n    vector<string> names(n);\n\n    if (type == \"max_dy\") {\n        // Generate names such that all can be included in the dynasty\n        // We need to make sure that:\n        // - For each consecutive name, the first letter of successor equals the last letter of predecessor\n        // - The first letter of the first name equals the last letter of the last name\n\n        // Let's pick a letter, say 'a', and make all names start and end with 'a'\n\n        for (int i = 0; i < n; ++i) {\n            int name_len = len;\n            if (len == -1) {\n                // generate random length between 1 and 10\n                name_len = rnd.next(1, 10);\n            }\n            string name = \"a\"; // first letter is 'a'\n            for (int j = 1; j < name_len -1; ++j) {\n                name += (char)(rnd.next(0,25)+'a');\n            }\n            if (name_len > 1)\n                name += \"a\"; // last letter is 'a'\n            names[i] = name;\n        }\n    } else if (type == \"no_dy\") {\n        // Generate names such that no dynasty can be formed\n        // Need to ensure that for any selection of names in order, the conditions cannot be satisfied\n        // We can make last letters not equal to next first letters\n\n        char last_c = '\\0';\n        for (int i = 0; i < n; ++i) {\n            int name_len = len;\n            if (len == -1) {\n                // generate random length between 1 and 10\n                name_len = rnd.next(1, 10);\n            }\n            string name;\n            char first_c, current_last_c;\n            if (name_len == 1) {\n                // name is a single character\n                first_c = current_last_c = (char)(rnd.next(0,25)+'a');\n                name = string(1, first_c);\n            } else {\n                do {\n                    first_c = (char)(rnd.next(0,25)+'a');\n                } while (first_c == last_c);\n                current_last_c = (char)(((first_c - 'a' + rnd.next(1,25))%26)+'a');\n                name = first_c;\n                for (int j = 1; j < name_len -1; ++j) {\n                    name += (char)(rnd.next(0,25)+'a');\n                }\n                name += current_last_c;\n            }\n            last_c = current_last_c;\n            names[i] = name;\n        }\n    } else if (type == \"random\") {\n        // Generate random names\n        for (int i = 0; i < n; ++i) {\n            int name_len = len;\n            if (len == -1) {\n                name_len = rnd.next(1, 10);\n            }\n            string name;\n            for (int j = 0; j < name_len; ++j) {\n                name += (char)(rnd.next(0,25)+'a');\n            }\n            names[i] = name;\n        }\n    } else if (type == \"single_char\") {\n        // All names are of length 1\n        for (int i = 0; i < n; ++i) {\n            char c = (char)(rnd.next(0,25)+'a');\n            names[i] = string(1, c);\n        }\n    } else if (type == \"max_length\") {\n        // All names are of length 10\n        for (int i = 0; i < n; ++i) {\n            string name;\n            for (int j = 0; j < 10; ++j) {\n                name += (char)(rnd.next(0,25)+'a');\n            }\n            names[i] = name;\n        }\n    } else if (type == \"cycle\") {\n        // Build a cycle of names where the first and last letters match\n        // and the chain can be formed\n\n        vector<char> chars;\n        for (int i = 0; i < n; ++i) {\n            chars.push_back((char)(rnd.next(0,25)+'a'));\n        }\n        chars.push_back(chars[0]); // to complete the cycle\n\n        for (int i = 0; i < n; ++i) {\n            int name_len = len;\n            if (len == -1) name_len = rnd.next(1, 10);\n            char first_c = chars[i];\n            char last_c = chars[i+1];\n\n            string name = \"\";\n            name += first_c;\n            for (int j = 1; j < name_len -1; ++j) {\n                name += (char)(rnd.next(0,25)+'a');\n            }\n            if (name_len > 1)\n                name += last_c;\n            names[i] = name;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int name_len = len;\n            if (len == -1) {\n                name_len = rnd.next(1, 10);\n            }\n            string name;\n            for (int j = 0; j < name_len; ++j) {\n                name += (char)(rnd.next(0,25)+'a');\n            }\n            names[i] = name;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output names\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", names[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type single_char\n./gen -n 1 -type max_dy -len 1\n./gen -n 1 -type random -len 3\n\n./gen -n 2 -type max_dy -len 2\n./gen -n 2 -type no_dy -len 2\n./gen -n 3 -type max_dy -len 3\n./gen -n 3 -type no_dy -len 3\n\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 500000 -type random\n\n./gen -n 500000 -type max_dy\n./gen -n 500000 -type no_dy\n./gen -n 500000 -type single_char\n\n./gen -n 500000 -type max_length\n./gen -n 500000 -type cycle\n./gen -n 100000 -type cycle\n\n./gen -n 100000 -type no_dy -len 10\n./gen -n 100000 -type max_dy -len 10\n./gen -n 1 -type max_length\n./gen -n 2 -type max_length\n\n./gen -n 3 -type single_char\n./gen -n 5 -type max_dy -len 1\n./gen -n 1000 -type no_dy -len 1\n./gen -n 1000 -type max_dy -len 1\n\n./gen -n 500000 -type max_dy -len 1\n./gen -n 500000 -type no_dy -len 1\n./gen -n 500000 -type random -len 10\n./gen -n 500000 -type random -len 1\n\n./gen -n 100000 -type cycle -len 1\n./gen -n 100 -type cycle -len 10\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:26.831125",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "192/D",
      "title": "D. Митинг",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n и k — количество площадей и дней до митинга соответственно (1 ≤ k < n ≤ 105).Во второй строке записано целое число b — количество бурлей у мэрии (1 ≤ b ≤ 1018).В третьей строке записано n целых чисел ai, разделенных пробелами, — количество денег, необходимых для проведения мероприятия на площади i (1 ≤ ai ≤ 109).Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++, вместо него рекомендуется использовать потоки cin, cout, а также спецификатор %I64d.",
      "output_spec": "Выходные данныеВыведите одно число — минимальный номер площади, на которой сможет провести митинг оппозиция.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 282 4 5 3 1Выходные данныеСкопировать2Входные данныеСкопировать5 283 2 4 1 5Выходные данныеСкопировать5Входные данныеСкопировать5 410000000000000005 4 3 2 1Выходные данныеСкопировать5",
      "description": "ограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n и k — количество площадей и дней до митинга соответственно (1 ≤ k < n ≤ 105).Во второй строке записано целое число b — количество бурлей у мэрии (1 ≤ b ≤ 1018).В третьей строке записано n целых чисел ai, разделенных пробелами, — количество денег, необходимых для проведения мероприятия на площади i (1 ≤ ai ≤ 109).Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++, вместо него рекомендуется использовать потоки cin, cout, а также спецификатор %I64d.\n\nВходные данные\n\nВыходные данныеВыведите одно число — минимальный номер площади, на которой сможет провести митинг оппозиция.\n\nВыходные данные\n\nВходные данныеСкопировать5 282 4 5 3 1Выходные данныеСкопировать2Входные данныеСкопировать5 283 2 4 1 5Выходные данныеСкопировать5Входные данныеСкопировать5 410000000000000005 4 3 2 1Выходные данныеСкопировать5\n\nВходные данныеСкопировать5 282 4 5 3 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 283 2 4 1 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 410000000000000005 4 3 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере оппозиция может действовать следующим образом. В первый день она займет площадь номер 3. Мэрия будет вынуждена организовать там мероприятие, после чего у нее останется 3 бурля. Если на второй день оппозиция подаст заявку на вторую площадь, то у мэрии не хватит денег, чтобы ее туда не пустить.Во втором примере у оппозиции есть шансы только на последнюю площадь. Если первым ходом она занимают одну из первых четырех площадей, то у мэрии остается как минимум 4 бурля, и следующим ходом у нее хватит денег, чтобы перенести заявку с любой площади на последнюю.В третьем примере у мэрии очень много денег, так что оппозиция может занять только последнюю площадь.",
      "solutions": [
        {
          "title": "Codeforces Round #121 - Codeforces",
          "content": "Здравствуй, сообщество Codeforces!Очередной раунд Codeforces #121 для вас сделали студенты ФИВТ МФТИ Александр Тимин (AlTimin) и Иван Смирнов (ifsmirnov). В своем первом раунде мы предложим вам хорошо провести время в старой доброй Берляндии: провести митинг, разогнать митинг, разобраться с главными берляндскими проблемами (обеими!) и многое другое.За неоценимую помощь в подготовке контеста хочется сказать огромное спасибо Gerald. Он же является автором одной из задач. Кроме того, мы выражаем благодарность Delinur за перевод условий на английский язык, Aksenov239 за вычитку условий и MikeMirzayanov за возможность провести контест на замечательной платформе Codeforces.Традиционно, раунд пройдет в обоих дивизионах на частично пересекающемся наборе задач. Информация о разбалловке будет опубликована позже.Мы желаем вам успехов и надеемся, что раунд вам понравится!РазборUPD1: Разбалловка в обоих дивизионах стандартная, 500-1000-1500-2000-2500.UPD2: Авторы контеста приносят участникам свои извинения за неточности в условии задачи B div 1 (D div 2). Так как проблема с условием была решена достаточно быстро, а неправильное понимание задачи не проходило претесты, раунд объявляется рейтинговым.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4635",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1203
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces",
          "content": "Задача 192A - Модные числаКратко о решении: переборПодробно о решении: Нетрудно заметить, что это числа положительны, следовательно каждое из слагаемых меньше N. То есть всего различных возможных слагаемых порядка . Это значит то, что мы взять и одно из слагаемых перебрать. Тогда нам нужно научиться проверять, является ли какое-то число треугольным. Заметим, что если мы заранее выпишем все слагаемые в порядке увеличения то мы сможем с помощью бинарного поиска в массиве искать наше число. Это даем там решение за . Если перебирать первое слагаемое в порядке увеличения, то можно использовать два указателя, что дает нам решение за .Задача 192B - Прогулки под дождемКратко о решении: динамика.Подробно о решении: динамика d[i] — количество дней, в течении которых плитка номер i доступна. Пересчет: d[i] = min(a[i], max(d[i - 1], d[i - 2]))Асимптотика решения: O(N)Задача 191A - Династические головоломкиКратко о решении: динамикаПодробно о решении: динамика d[i][j], i — первый символ в имени династии, j — последний текущий символ. d[i][j] — максимальная текущая длина. Переход: для слова с первой буквой l, последней буквой r и длиной s для всех возможных первых букв i состояние d[i][r] может быть улучшено значением d[i][l] + s.Ответом будет являться максимальное значение d[i][i] для всех i.Асимптотика решения: O(N * alpha), где alpha — это размер алфавита.Задача 191B - МитингКратко о решении: конструктивПодробно о решении: заметим, что на последнюю площадь никогда не выгодно подавать заявку (денег мэрии не потратим, ничего не изменится, мы просто потеряем ход). Переберем площадь, на которой мы хотим провести митинг. У нас есть k - 1 ход на то, чтобы потратить деньги мэрии (один ход нам нужен на подачу заявки на искомую площадь). Тратить деньги выгоднее всего на самых дорогих площадях, за исключением последней. Осталось научиться быстро выбирать k - 1 максимум из всего массива, за исключением данного элемента. Для этого сначала отсортируем массив и получим k максимумов (последнюю площадь мы не должны рассматривать). Проверяем, лежит ли наше текущее значение в k - 1 максимальных (бинпоиск и не только). Если лежит, то искомые k - 1 максимумов — это максимальные k элементов без нашего. Если не лежит, то это просто максимальные k элементов. Теперь когда мы понимаем, сколько денег мэрии мы можем потратить, то тратим их и смотрим, остаются ли еще у мэрии деньги на проведение события на нашей текущей площадиАсимптотика решения: Задача 191C - Дураки и дорогиКратко о решении: lcaПодробно о решении: Разобьем каждый путь на два, строго идущих вверх к наименьшему общему предку. Теперь у нас есть только \"вертикальные пути\". Для каждой вершины насчитаем такую величину: количество вертикальных путей, начинающихся в ней минус количество вертикальных путей в ней заканчивающихся. Если мы насчитали эту величину, то ответ для ребра — это сумма значений в его поддереве. Насчитать такую величину довольно просто: берем для каждой пары дураков считаем lca этой пары. В города дураков прибавляем единичку, в lca значение уменьшаем на два.Асимптотика решения: Задача 191D - Схема метроКратко о решении: снова динамикаПодробно о решении: динамика d[v][rest][cycle] — количество линий, которое требуется для того, чтобы в поддереве вершины v все покрасить, в v остаются rest незамкнутым, cycle — правда ли, что нам надо обрабатывать цикл, в котором мы находимся. Если мы находимся не в вершине цикла, то обрабатываем всех детей, говоря что мы хотим, чтобы в них было по одному незакрытому пути. Пусть у нас есть s сыновей, нам надо взять и замкнуть все лишние линии, а недостающие нагенерить. То есть ответ это , если s > rest, и в противном случае.Если мы находимся в вершине цикла, то либо мы покрываем этот цикл кольцом и это стоит нам , где u — это вершина на цикле. отличная от v. Другой вариант — покрыть все участки кольца радиальными линиями. Утверждение: это всегда можно оптимально сделать ровно двумя радиальными. Пусть это не так. Тогда рассмотрим некоторую вершину, в которой радиальные линии <<подвешиваются>> к кольцу. От неё по кольцу в разные стороны уходят два тоннеля, принадлежащие этим линиям. Так как различных линий на кольце сейчас не менее трех, то мы можем перенаправить радиальные линии следующим образом: соединить куски вне кольца друг с другом, а кольцо замкнуть. На кольце останется не менее двух кусков, следовательно все линии останутся валидными, а их число не изменится. Теперь надо выбрать две станции, из поддерева которых будут выходить радиальные ветки, покрывшее кольцо. Стоимость такой станции это d[u][2][0], а обычной — d[u][0][0] (d[v][rest][0] в случае той вершины, которую мы сейчас обрабатываем) . Соответственно, нам надо выбрать две станции с максимальным значением d[u][2][0] - d[u][0][0].Асимптотика решения: O(N)Задача 191E - Разгон митинговКратко о решении: бинарный поиск по ответуПодробно о решении: Сделаем бинарный поиск по ответу. Нам надо посчитать количество отрезков, на которых сумма больше нашего некоторого значения. Как мы это будем делать: будем обрабатывать все отрезки в порядке увеличения правых концов. Отрезки с одинаковыми правыми концами будем обрабатывать пачками. Более подробно: мы будем поддерживать некоторую структуру данных в которой будут храниться суммы всех отрезков c фиксированным правым концом. Для того, чтобы быстро пересчитывать, нам нужно всего добавить в множество некоторый элемент ( 0, если точнее) и добавить ко всем элементам множества некоторое значение (a[i], если быть точнее). Еще нам нужно уметь отвечать на запрос <<количество элементов, больших данного на отрезке>>. Все это умеет быстро реализовывать, например, декартово дерево. Но нам придется дополнительно хранить некоторую величину X, означающую <<надо прибавить к элементу из декартова дерева X, чтобы получить реальное значение>>. Тогда при добавлении элемента a в нашу структуру надо будет положить в декартово дерево величину a - X, а прибавление некоторой величины ко всему множеству реализуется простым изменением X. То есть у нас есть структура данных, которая умеет все эти операции выполнять за . То есть одна итерация внешнего бинпоиска работает за , следовательно весь алгоритм работает за Асимптотика решения:",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4634",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 192 和字母"
          },
          "content_length": 6193
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #121 - Codeforces - Code 1",
          "code": "for (int i = 1; i * (i + 1) < n + n; i++)\n r[i] = i * (i + 1) / 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #121 - Codeforces - Code 2",
          "code": "for (int i = 1; i * (i + 1) < n + n; i++)\n r[i] = i * (i + 1) / 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #121 - Codeforces - Code 3",
          "code": "// fprintf(stderr, \"cnt(av=%lld) = %lld\\n\", av, cnt);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #121 - Codeforces - Code 4",
          "code": "// fprintf(stderr, \"cnt(av=%lld) = %lld\\n\", av, cnt);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #121 - Codeforces - Code 5",
          "code": "return printf(\"%I64d\\n\",end+1), 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #121 - Codeforces - Code 6",
          "code": "return !printf(\"%I64d\\n\",end+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 1",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 2",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n\n    long long b = inf.readLong(1LL, 1000000000000000000LL, \"b\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n\n    long long b = inf.readLong(1LL, 1000000000000000000LL, \"b\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n\n    long long b = inf.readLong(1LL, 1000000000000000000LL, \"b\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    long long b = opt<long long>(\"b\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"equal\") {\n        int val = opt<int>(\"val\", 1);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = val;\n        }\n    } else if (type == \"increasing\") {\n        int minVal = opt<int>(\"minVal\", 1);\n        int maxVal = opt<int>(\"maxVal\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = minVal + (long long)(maxVal - minVal) * i / (n - 1);\n        }\n    } else if (type == \"decreasing\") {\n        int minVal = opt<int>(\"minVal\", 1);\n        int maxVal = opt<int>(\"maxVal\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = maxVal - (long long)(maxVal - minVal) * i / (n - 1);\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 1000000000;\n        }\n    } else if (type == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 1;\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    /* Output the data */\n\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%lld\\n\", b);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    long long b = opt<long long>(\"b\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"equal\") {\n        int val = opt<int>(\"val\", 1);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = val;\n        }\n    } else if (type == \"increasing\") {\n        int minVal = opt<int>(\"minVal\", 1);\n        int maxVal = opt<int>(\"maxVal\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = minVal + (long long)(maxVal - minVal) * i / (n - 1);\n        }\n    } else if (type == \"decreasing\") {\n        int minVal = opt<int>(\"minVal\", 1);\n        int maxVal = opt<int>(\"maxVal\", 1000000000);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = maxVal - (long long)(maxVal - minVal) * i / (n - 1);\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 1000000000;\n        }\n    } else if (type == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 1;\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    /* Output the data */\n\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%lld\\n\", b);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -k 1 -b 1 -type min\n./gen -n 2 -k 1 -b 1 -type max\n./gen -n 10 -k 5 -b 100 -type random\n./gen -n 100 -k 50 -b 1000 -type random\n./gen -n 1000 -k 500 -b 1000000 -type random\n\n./gen -n 1000 -k 1 -b 0 -type random\n./gen -n 1000 -k 999 -b 0 -type random\n./gen -n 1000 -k 500 -b 1000000000000 -type random\n\n./gen -n 100000 -k 99999 -b 1000000000000000000 -type max\n./gen -n 100000 -k 1 -b 1000000000000000000 -type min\n\n./gen -n 100000 -k 50000 -b 1000000000000000000 -type increasing -minVal 1 -maxVal 1000000000\n./gen -n 100000 -k 50000 -b 1000000000000000000 -type decreasing -minVal 1 -maxVal 1000000000\n\n./gen -n 99999 -k 1 -b 1 -type min\n./gen -n 99999 -k 1 -b 1 -type max\n\n./gen -n 100000 -k 1 -b 12345 -type equal -val 1\n./gen -n 100000 -k 100 -b 1 -type equal -val 1000000000\n\n./gen -n 100000 -k 100000 -b 1000000000000000000 -type random\n./gen -n 100000 -k 100 -b 0 -type random\n./gen -n 100000 -k 1 -b 0 -type random\n./gen -n 100000 -k 99999 -b 0 -type random\n\n./gen -n 100000 -k 100000 -b 1 -type decreasing -minVal 1 -maxVal 1000000000\n./gen -n 100000 -k 100000 -b 1 -type increasing -minVal 1 -maxVal 1000000000\n\n./gen -n 50 -k 49 -b 500 -type increasing -minVal 1 -maxVal 10\n./gen -n 50 -k 10 -b 0 -type decreasing -minVal 1 -maxVal 10\n\n./gen -n 100000 -k 1 -b 1000000000000 -type random\n\n./gen -n 100000 -k 50000 -b 1000000000000000000 -type random\n\n./gen -n 50000 -k 25000 -b 500000000000 -type random\n\n./gen -n 100000 -k 100000 -b 1000000000000000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:28.762443",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "192/E",
      "title": "E. Fools and Roads",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (2 ≤ n ≤ 105) — the number of cities. Each of the next n - 1 lines contains two space-separated integers ui, vi (1 ≤ ui, vi ≤ n, ui ≠ vi), that means that there is a road connecting cities ui and vi. The next line contains integer k (0 ≤ k ≤ 105) — the number of pairs of fools who visit each other. Next k lines contain two space-separated numbers. The i-th line (i > 0) contains numbers ai, bi (1 ≤ ai, bi ≤ n). That means that the fool number 2i - 1 lives in city ai and visits the fool number 2i, who lives in city bi. The given pairs describe simple paths, because between every pair of cities there is only one simple path.",
      "output_spec": "OutputPrint n - 1 integer. The integers should be separated by spaces. The i-th number should equal the number of fools who can go on the i-th road. The roads are numbered starting from one in the order, in which they occur in the input.",
      "sample_tests": "ExamplesInputCopy51 21 32 42 521 43 5OutputCopy2 1 1 1 InputCopy53 44 51 42 432 31 33 5OutputCopy3 1 1 1",
      "description": "E. Fools and Roads\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (2 ≤ n ≤ 105) — the number of cities. Each of the next n - 1 lines contains two space-separated integers ui, vi (1 ≤ ui, vi ≤ n, ui ≠ vi), that means that there is a road connecting cities ui and vi. The next line contains integer k (0 ≤ k ≤ 105) — the number of pairs of fools who visit each other. Next k lines contain two space-separated numbers. The i-th line (i > 0) contains numbers ai, bi (1 ≤ ai, bi ≤ n). That means that the fool number 2i - 1 lives in city ai and visits the fool number 2i, who lives in city bi. The given pairs describe simple paths, because between every pair of cities there is only one simple path.\n\nOutputPrint n - 1 integer. The integers should be separated by spaces. The i-th number should equal the number of fools who can go on the i-th road. The roads are numbered starting from one in the order, in which they occur in the input.\n\nInputCopy51 21 32 42 521 43 5OutputCopy2 1 1 1 InputCopy53 44 51 42 432 31 33 5OutputCopy3 1 1 1\n\nInputCopy51 21 32 42 521 43 5\n\nOutputCopy2 1 1 1\n\nInputCopy53 44 51 42 432 31 33 5\n\nOutputCopy3 1 1 1\n\nNoteIn the first sample the fool number one goes on the first and third road and the fool number 3 goes on the second, first and fourth ones.In the second sample, the fools number 1, 3 and 5 go on the first road, the fool number 5 will go on the second road, on the third road goes the fool number 3, and on the fourth one goes fool number 1.",
      "solutions": [
        {
          "title": "Codeforces Round #121 - Codeforces",
          "content": "Hello, dear Codeforces community!I'm glad to present you the next Codeforces Round #121. The contest is brought to you by Ivan Smirnov (ifsmirnov) and Aleksandr Timin (AlTimin), the students of Moscow Institute of Physics and Technology. In our first round we will offer you a good time in Berland: you will hold a demonstration, prevent the demonstration, deal with the most important problems of Berland (with both of them!) and much more.We thank Gerald a lot for the invaluable help he gave as during the contest preparation. He is also the author of one task in the contest. We also thank Delinur for the English version of statements, Aksenov239 for proofreading the statements and MikeMirzayanov for an opportunity to hold a contest on this wonderful site.As usual, the contest will be held in both divisions and the problemsets will overlap. The scoring will be published later.We wish you good luck and hope that you enjoy the contest!UPD1: The scoring is classic in both divisions — 500-1000-1500-2000-2500.UPD2: The contest authors apologize to the contesters for a possibility of misunderstanding of problem B div 1 (D div 2). The statement was fixed soon enough and the incorrect understanding of the problem didn't pass pretests, so the round is rated.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4635",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1266
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces",
          "content": "Задача 192A - Модные числаКратко о решении: переборПодробно о решении: Нетрудно заметить, что это числа положительны, следовательно каждое из слагаемых меньше N. То есть всего различных возможных слагаемых порядка . Это значит то, что мы взять и одно из слагаемых перебрать. Тогда нам нужно научиться проверять, является ли какое-то число треугольным. Заметим, что если мы заранее выпишем все слагаемые в порядке увеличения то мы сможем с помощью бинарного поиска в массиве искать наше число. Это даем там решение за . Если перебирать первое слагаемое в порядке увеличения, то можно использовать два указателя, что дает нам решение за .Задача 192B - Прогулки под дождемКратко о решении: динамика.Подробно о решении: динамика d[i] — количество дней, в течении которых плитка номер i доступна. Пересчет: d[i] = min(a[i], max(d[i - 1], d[i - 2]))Асимптотика решения: O(N)Задача 191A - Династические головоломкиКратко о решении: динамикаПодробно о решении: динамика d[i][j], i — первый символ в имени династии, j — последний текущий символ. d[i][j] — максимальная текущая длина. Переход: для слова с первой буквой l, последней буквой r и длиной s для всех возможных первых букв i состояние d[i][r] может быть улучшено значением d[i][l] + s.Ответом будет являться максимальное значение d[i][i] для всех i.Асимптотика решения: O(N * alpha), где alpha — это размер алфавита.Задача 191B - МитингКратко о решении: конструктивПодробно о решении: заметим, что на последнюю площадь никогда не выгодно подавать заявку (денег мэрии не потратим, ничего не изменится, мы просто потеряем ход). Переберем площадь, на которой мы хотим провести митинг. У нас есть k - 1 ход на то, чтобы потратить деньги мэрии (один ход нам нужен на подачу заявки на искомую площадь). Тратить деньги выгоднее всего на самых дорогих площадях, за исключением последней. Осталось научиться быстро выбирать k - 1 максимум из всего массива, за исключением данного элемента. Для этого сначала отсортируем массив и получим k максимумов (последнюю площадь мы не должны рассматривать). Проверяем, лежит ли наше текущее значение в k - 1 максимальных (бинпоиск и не только). Если лежит, то искомые k - 1 максимумов — это максимальные k элементов без нашего. Если не лежит, то это просто максимальные k элементов. Теперь когда мы понимаем, сколько денег мэрии мы можем потратить, то тратим их и смотрим, остаются ли еще у мэрии деньги на проведение события на нашей текущей площадиАсимптотика решения: Задача 191C - Дураки и дорогиКратко о решении: lcaПодробно о решении: Разобьем каждый путь на два, строго идущих вверх к наименьшему общему предку. Теперь у нас есть только \"вертикальные пути\". Для каждой вершины насчитаем такую величину: количество вертикальных путей, начинающихся в ней минус количество вертикальных путей в ней заканчивающихся. Если мы насчитали эту величину, то ответ для ребра — это сумма значений в его поддереве. Насчитать такую величину довольно просто: берем для каждой пары дураков считаем lca этой пары. В города дураков прибавляем единичку, в lca значение уменьшаем на два.Асимптотика решения: Задача 191D - Схема метроКратко о решении: снова динамикаПодробно о решении: динамика d[v][rest][cycle] — количество линий, которое требуется для того, чтобы в поддереве вершины v все покрасить, в v остаются rest незамкнутым, cycle — правда ли, что нам надо обрабатывать цикл, в котором мы находимся. Если мы находимся не в вершине цикла, то обрабатываем всех детей, говоря что мы хотим, чтобы в них было по одному незакрытому пути. Пусть у нас есть s сыновей, нам надо взять и замкнуть все лишние линии, а недостающие нагенерить. То есть ответ это , если s > rest, и в противном случае.Если мы находимся в вершине цикла, то либо мы покрываем этот цикл кольцом и это стоит нам , где u — это вершина на цикле. отличная от v. Другой вариант — покрыть все участки кольца радиальными линиями. Утверждение: это всегда можно оптимально сделать ровно двумя радиальными. Пусть это не так. Тогда рассмотрим некоторую вершину, в которой радиальные линии <<подвешиваются>> к кольцу. От неё по кольцу в разные стороны уходят два тоннеля, принадлежащие этим линиям. Так как различных линий на кольце сейчас не менее трех, то мы можем перенаправить радиальные линии следующим образом: соединить куски вне кольца друг с другом, а кольцо замкнуть. На кольце останется не менее двух кусков, следовательно все линии останутся валидными, а их число не изменится. Теперь надо выбрать две станции, из поддерева которых будут выходить радиальные ветки, покрывшее кольцо. Стоимость такой станции это d[u][2][0], а обычной — d[u][0][0] (d[v][rest][0] в случае той вершины, которую мы сейчас обрабатываем) . Соответственно, нам надо выбрать две станции с максимальным значением d[u][2][0] - d[u][0][0].Асимптотика решения: O(N)Задача 191E - Разгон митинговКратко о решении: бинарный поиск по ответуПодробно о решении: Сделаем бинарный поиск по ответу. Нам надо посчитать количество отрезков, на которых сумма больше нашего некоторого значения. Как мы это будем делать: будем обрабатывать все отрезки в порядке увеличения правых концов. Отрезки с одинаковыми правыми концами будем обрабатывать пачками. Более подробно: мы будем поддерживать некоторую структуру данных в которой будут храниться суммы всех отрезков c фиксированным правым концом. Для того, чтобы быстро пересчитывать, нам нужно всего добавить в множество некоторый элемент ( 0, если точнее) и добавить ко всем элементам множества некоторое значение (a[i], если быть точнее). Еще нам нужно уметь отвечать на запрос <<количество элементов, больших данного на отрезке>>. Все это умеет быстро реализовывать, например, декартово дерево. Но нам придется дополнительно хранить некоторую величину X, означающую <<надо прибавить к элементу из декартова дерева X, чтобы получить реальное значение>>. Тогда при добавлении элемента a в нашу структуру надо будет положить в декартово дерево величину a - X, а прибавление некоторой величины ко всему множеству реализуется простым изменением X. То есть у нас есть структура данных, которая умеет все эти операции выполнять за . То есть одна итерация внешнего бинпоиска работает за , следовательно весь алгоритм работает за Асимптотика решения:",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4634",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 192 和字母"
          },
          "content_length": 6193
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #121 - Codeforces - Code 1",
          "code": "return printf(\"%I64d\\n\",end+1), 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #121 - Codeforces - Code 2",
          "code": "return !printf(\"%I64d\\n\",end+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4635",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 1",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #121 - Codeforces - Code 2",
          "code": "for i:0...n\n    Input a string. Now for this string let l=first character and r=last character.\n    Thereby dp[l][r]=max(dp[l][r],s.length())\n    for j:0...26 \n        Now the string which starts at j and ends at r can be improved to a string which, starts at j \n        then ends at l then re begins at l and finally ends at r (i.e. input string s also included \n        while the starting ending letters remain same)\n        i.e. dp[j][r]=max(dp[j][r],dp[j][l]+s.length())\n        Also take care that this improvement is possible only if there already exists a string which \n        starts at j and ends at l (i.e. dp[j][l] !=0 ).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4634",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 100000;\nconst int MAX_K = 100000;\n\nint find_set(vector<int>& parent, int v) {\n    if (v != parent[v]) parent[v] = find_set(parent, parent[v]);\n    return parent[v];\n}\n\nvoid union_sets(vector<int>& parent, vector<int>& rank, int a, int b) {\n    a = find_set(parent,a);\n    b = find_set(parent,b);\n    if (a != b) {\n        if (rank[a] < rank[b])\n            swap(a,b);\n        parent[b] = a;\n        if (rank[a] == rank[b])\n            rank[a]++;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, MAX_N, \"n\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n    vector<int> parent(n+1), rank(n+1, 0); // parent[1..n], rank[1..n]\n\n    for(int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(ui != vi, \"Edge cannot connect a node to itself: ui = vi = %d\", ui);\n        int u = min(ui, vi);\n        int v = max(ui, vi);\n        pair<int,int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between nodes %d and %d\", u, v);\n        edges.insert(edge);\n        // Union-Find to check connectivity\n        union_sets(parent, rank, ui, vi);\n    }\n\n    // After reading all edges, check that the graph is connected\n    int root = find_set(parent, 1);\n    for(int i = 2; i <= n; ++i) {\n        ensuref(find_set(parent, i) == root, \"The graph is not connected\");\n    }\n\n    int k = inf.readInt(0, MAX_K, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        // No additional constraints on ai and bi\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 100000;\nconst int MAX_K = 100000;\n\nint find_set(vector<int>& parent, int v) {\n    if (v != parent[v]) parent[v] = find_set(parent, parent[v]);\n    return parent[v];\n}\n\nvoid union_sets(vector<int>& parent, vector<int>& rank, int a, int b) {\n    a = find_set(parent,a);\n    b = find_set(parent,b);\n    if (a != b) {\n        if (rank[a] < rank[b])\n            swap(a,b);\n        parent[b] = a;\n        if (rank[a] == rank[b])\n            rank[a]++;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, MAX_N, \"n\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n    vector<int> parent(n+1), rank(n+1, 0); // parent[1..n], rank[1..n]\n\n    for(int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(ui != vi, \"Edge cannot connect a node to itself: ui = vi = %d\", ui);\n        int u = min(ui, vi);\n        int v = max(ui, vi);\n        pair<int,int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between nodes %d and %d\", u, v);\n        edges.insert(edge);\n        // Union-Find to check connectivity\n        union_sets(parent, rank, ui, vi);\n    }\n\n    // After reading all edges, check that the graph is connected\n    int root = find_set(parent, 1);\n    for(int i = 2; i <= n; ++i) {\n        ensuref(find_set(parent, i) == root, \"The graph is not connected\");\n    }\n\n    int k = inf.readInt(0, MAX_K, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        // No additional constraints on ai and bi\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 100000;\nconst int MAX_K = 100000;\n\nint find_set(vector<int>& parent, int v) {\n    if (v != parent[v]) parent[v] = find_set(parent, parent[v]);\n    return parent[v];\n}\n\nvoid union_sets(vector<int>& parent, vector<int>& rank, int a, int b) {\n    a = find_set(parent,a);\n    b = find_set(parent,b);\n    if (a != b) {\n        if (rank[a] < rank[b])\n            swap(a,b);\n        parent[b] = a;\n        if (rank[a] == rank[b])\n            rank[a]++;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, MAX_N, \"n\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n    vector<int> parent(n+1), rank(n+1, 0); // parent[1..n], rank[1..n]\n\n    for(int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(ui != vi, \"Edge cannot connect a node to itself: ui = vi = %d\", ui);\n        int u = min(ui, vi);\n        int v = max(ui, vi);\n        pair<int,int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between nodes %d and %d\", u, v);\n        edges.insert(edge);\n        // Union-Find to check connectivity\n        union_sets(parent, rank, ui, vi);\n    }\n\n    // After reading all edges, check that the graph is connected\n    int root = find_set(parent, 1);\n    for(int i = 2; i <= n; ++i) {\n        ensuref(find_set(parent, i) == root, \"The graph is not connected\");\n    }\n\n    int k = inf.readInt(0, MAX_K, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        // No additional constraints on ai and bi\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid make_chain_tree(int n, vector<pair<int, int>>& edges) {\n    for (int i = 2; i <= n; ++i) {\n        edges.emplace_back(i - 1, i);\n    }\n}\n\nvoid make_star_tree(int n, vector<pair<int, int>>& edges) {\n    for (int i = 2; i <= n; ++i) {\n        edges.emplace_back(1, i);\n    }\n}\n\nvoid make_random_tree(int n, vector<pair<int, int>>& edges) {\n    for (int i = 2; i <= n; ++i) {\n        int parent = rnd.next(1, i - 1);\n        edges.emplace_back(parent, i);\n    }\n}\n\nvoid make_balanced_tree(int n, vector<pair<int, int>>& edges) {\n    for (int i = 2; i <= n; ++i) {\n        edges.emplace_back(i / 2, i);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 0);\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string path_type = opt<string>(\"path_type\", \"random\");\n\n    // Enforce constraints\n    if (n < 2) n = 2;\n    if (n > 100000) n = 100000;\n    if (k < 0) k = 0;\n    if (k > 100000) k = 100000;\n\n    // Generate tree\n    vector<pair<int, int>> edges;\n    if (tree_type == \"chain\") {\n        make_chain_tree(n, edges);\n    } else if (tree_type == \"star\") {\n        make_star_tree(n, edges);\n    } else if (tree_type == \"balanced\") {\n        make_balanced_tree(n, edges);\n    } else {\n        make_random_tree(n, edges);\n    }\n\n    shuffle(edges.begin(), edges.end());\n\n    // Output the tree\n    printf(\"%d\\n\", n);\n    for (auto edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    // Generate k pairs\n    vector<pair<int, int>> paths;\n\n    if (path_type == \"random\") {\n        for (int i = 0; i < k; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            while (b == a) {\n                b = rnd.next(1, n);\n            }\n            paths.emplace_back(a, b);\n        }\n    } else if (path_type == \"max_distance\") {\n        // Pair nodes that are maximally apart\n        int a = 1;\n        int b = n;\n        for (int i = 0; i < k; ++i) {\n            paths.emplace_back(a, b);\n        }\n    } else if (path_type == \"adjacent\") {\n        // Pair adjacent nodes\n        for (int i = 0; i < k; ++i) {\n            int a = rnd.next(1, n - 1);\n            int b = a + 1;\n            paths.emplace_back(a, b);\n        }\n    } else if (path_type == \"self_loop\") {\n        // Pair node to itself\n        for (int i = 0; i < k; ++i) {\n            int a = rnd.next(1, n);\n            paths.emplace_back(a, a);\n        }\n    } else if (path_type == \"single_edge\") {\n        // All paths go over a specific edge\n        int u = edges[0].first;\n        int v = edges[0].second;\n        for (int i = 0; i < k; ++i) {\n            paths.emplace_back(u, v);\n        }\n    }\n\n    // Output k and the pairs\n    printf(\"%d\\n\", k);\n    for (auto p : paths) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid make_chain_tree(int n, vector<pair<int, int>>& edges) {\n    for (int i = 2; i <= n; ++i) {\n        edges.emplace_back(i - 1, i);\n    }\n}\n\nvoid make_star_tree(int n, vector<pair<int, int>>& edges) {\n    for (int i = 2; i <= n; ++i) {\n        edges.emplace_back(1, i);\n    }\n}\n\nvoid make_random_tree(int n, vector<pair<int, int>>& edges) {\n    for (int i = 2; i <= n; ++i) {\n        int parent = rnd.next(1, i - 1);\n        edges.emplace_back(parent, i);\n    }\n}\n\nvoid make_balanced_tree(int n, vector<pair<int, int>>& edges) {\n    for (int i = 2; i <= n; ++i) {\n        edges.emplace_back(i / 2, i);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 0);\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string path_type = opt<string>(\"path_type\", \"random\");\n\n    // Enforce constraints\n    if (n < 2) n = 2;\n    if (n > 100000) n = 100000;\n    if (k < 0) k = 0;\n    if (k > 100000) k = 100000;\n\n    // Generate tree\n    vector<pair<int, int>> edges;\n    if (tree_type == \"chain\") {\n        make_chain_tree(n, edges);\n    } else if (tree_type == \"star\") {\n        make_star_tree(n, edges);\n    } else if (tree_type == \"balanced\") {\n        make_balanced_tree(n, edges);\n    } else {\n        make_random_tree(n, edges);\n    }\n\n    shuffle(edges.begin(), edges.end());\n\n    // Output the tree\n    printf(\"%d\\n\", n);\n    for (auto edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    // Generate k pairs\n    vector<pair<int, int>> paths;\n\n    if (path_type == \"random\") {\n        for (int i = 0; i < k; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            while (b == a) {\n                b = rnd.next(1, n);\n            }\n            paths.emplace_back(a, b);\n        }\n    } else if (path_type == \"max_distance\") {\n        // Pair nodes that are maximally apart\n        int a = 1;\n        int b = n;\n        for (int i = 0; i < k; ++i) {\n            paths.emplace_back(a, b);\n        }\n    } else if (path_type == \"adjacent\") {\n        // Pair adjacent nodes\n        for (int i = 0; i < k; ++i) {\n            int a = rnd.next(1, n - 1);\n            int b = a + 1;\n            paths.emplace_back(a, b);\n        }\n    } else if (path_type == \"self_loop\") {\n        // Pair node to itself\n        for (int i = 0; i < k; ++i) {\n            int a = rnd.next(1, n);\n            paths.emplace_back(a, a);\n        }\n    } else if (path_type == \"single_edge\") {\n        // All paths go over a specific edge\n        int u = edges[0].first;\n        int v = edges[0].second;\n        for (int i = 0; i < k; ++i) {\n            paths.emplace_back(u, v);\n        }\n    }\n\n    // Output k and the pairs\n    printf(\"%d\\n\", k);\n    for (auto p : paths) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test 1: Smallest n and k\n./gen -n 2 -k 0 -tree_type chain -path_type random\n\n# Test 2: Small n, small k, random tree\n./gen -n 5 -k 3 -tree_type random -path_type random\n\n# Test 3: Small n, k = 0\n./gen -n 5 -k 0 -tree_type random -path_type random\n\n# Test 4: n = 100, k = 0\n./gen -n 100 -k 0 -tree_type random -path_type random\n\n# Test 5: n = 100, k = 10000\n./gen -n 100 -k 10000 -tree_type random -path_type random\n\n# Test 6: n=100000, k=0\n./gen -n 100000 -k 0 -tree_type random -path_type random\n\n# Test 7: n=100000, k=100000, chain tree\n./gen -n 100000 -k 100000 -tree_type chain -path_type random\n\n# Test 8: n=100000, k=100000, star tree\n./gen -n 100000 -k 100000 -tree_type star -path_type random\n\n# Test 9: n=100000, k=100000, balanced tree\n./gen -n 100000 -k 100000 -tree_type balanced -path_type random\n\n# Test 10: n=100000, k=100000, random tree\n./gen -n 100000 -k 100000 -tree_type random -path_type random\n\n# Test 11: Paths of maximum length in a chain tree\n./gen -n 100000 -k 100000 -tree_type chain -path_type max_distance\n\n# Test 12: Paths of maximum length in a balanced tree\n./gen -n 100000 -k 100000 -tree_type balanced -path_type max_distance\n\n# Test 13: Paths between adjacent nodes\n./gen -n 100000 -k 100000 -tree_type random -path_type adjacent\n\n# Test 14: Paths from nodes to themselves (if acceptable)\n./gen -n 100000 -k 100000 -tree_type random -path_type self_loop\n\n# Test 15: All paths go over a single edge\n./gen -n 100000 -k 100000 -tree_type star -path_type single_edge\n\n# Test 16: Paths covering all edges in a star tree\n./gen -n 100000 -k 100000 -tree_type star -path_type max_distance\n\n# Test 17: Random tree, random paths\n./gen -n 100000 -k 100000 -tree_type random -path_type random\n\n# Test 18: Small n, paths from nodes to themselves\n./gen -n 10 -k 10 -tree_type random -path_type self_loop\n\n# Test 19: All paths going over one edge in chain\n./gen -n 100000 -k 100000 -tree_type chain -path_type single_edge\n\n# Test 20: k exceeding limit, should be capped at 100000\n./gen -n 100000 -k 200000 -tree_type random -path_type random\n\n# Test 21: n small, k large (capped at 100000)\n./gen -n 10 -k 100000 -tree_type balanced -path_type random\n\n# Test 22: n = 2, k = 1\n./gen -n 2 -k 1 -tree_type chain -path_type random\n\n# Test 23: n = 2, k = 100000\n./gen -n 2 -k 100000 -tree_type chain -path_type random\n\n# Test 24: n = 100000, no paths\n./gen -n 100000 -k 0 -tree_type star -path_type random\n\n# Test 25: n = 100000, paths from leaves to root\n./gen -n 100000 -k 100000 -tree_type star -path_type max_distance\n\n# Test 26: Paths between random pairs in chain tree\n./gen -n 100000 -k 100000 -tree_type chain -path_type random\n\n# Test 27: Paths between random pairs in star tree\n./gen -n 100000 -k 100000 -tree_type star -path_type random\n\n# Test 28: n is a large prime number\n./gen -n 99991 -k 100000 -tree_type random -path_type random\n\n# Test 29: n = 99999, path_type self_loop\n./gen -n 99999 -k 100000 -tree_type random -path_type self_loop\n\n# Test 30: Random tree with k = 1\n./gen -n 100000 -k 1 -tree_type random -path_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:31.010412",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "193/A",
      "title": "A. Разрезание фигуры",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке входного файла записаны через пробел два целых числа n и m (1 ≤ n, m ≤ 50) — размеры листа бумаги. В следующих n строках содержится по m символов — описание листа бумаги: j-й символ i-й строки равен «#», если соответствующая клетка закрашена (принадлежит множеству A), или равен «.», если соответствующая клетка не закрашена (не принадлежит множеству A). Гарантируется, что множество всех закрашенных клеток A связно и не пусто.",
      "output_spec": "Выходные данныеНа первой строке выведите минимальное количество клеток, которые нужно удалить, чтобы лишить множество A связности или -1, если это невозможно.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 4#####..##..##..#####Выходные данныеСкопировать2Входные данныеСкопировать5 5######...#######...######Выходные данныеСкопировать2",
      "description": "A. Разрезание фигуры\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входного файла записаны через пробел два целых числа n и m (1 ≤ n, m ≤ 50) — размеры листа бумаги. В следующих n строках содержится по m символов — описание листа бумаги: j-й символ i-й строки равен «#», если соответствующая клетка закрашена (принадлежит множеству A), или равен «.», если соответствующая клетка не закрашена (не принадлежит множеству A). Гарантируется, что множество всех закрашенных клеток A связно и не пусто.\n\nВходные данные\n\nВыходные данныеНа первой строке выведите минимальное количество клеток, которые нужно удалить, чтобы лишить множество A связности или -1, если это невозможно.\n\nВыходные данные\n\nВходные данныеСкопировать5 4#####..##..##..#####Выходные данныеСкопировать2Входные данныеСкопировать5 5######...#######...######Выходные данныеСкопировать2\n\nВходные данныеСкопировать5 4#####..##..##..#####\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 5######...#######...######\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере можно удалить любые две клетки, не имеющие общей стороны и множество закрашенных клеток потеряет связность.Пояснение ко второму примеру изображено на рисунке. Слева изображено изначальное множество клеток. Справа — множество с удаленными клетками. Удаленные клетки помечены крестиками.",
      "solutions": [
        {
          "title": "Codeforces Round #122 - Codeforces",
          "content": "Привет всем! Я автор задач сегодняшнего раунда. Меня зовут Артур, я учусь в лицее №31 города Челябинска. Благодарю Gerald за координацию подготовки контеста, Delinur за перевод условий, MikeMirzayanov за замечательную систему, dolphinigle за прорешивание контеста, вычитывание условий и множество ценных советов, fdoer, grey_wind, Skird и alger95 за помощь в придумывании задач. Пока ничего практически полезного сказать не могу. Как вы, надеюсь, догадались, контест пройдет в каждом дивизионе отдельно. Система подсчета очков будет стандартная, разбалловка, скорее всего, нестандартная, пока не знаю, какая именно, ближе к делу напишу.Объемных фабул и историй не будет. Надеюсь, что контест и задачи вам понравятся и все пройдет гладко. UPD: Разбалловка следующая:В первом дивизионе: 500-1000-2000-2000-2500.Во втором дивизионе: 500-1000-1500-2000-3000.UPD2: появился разбор Пока частичный и на русском. скоро будет больше.Поздравляю победителей, особенно решивших задачу D.Div1: Petr tourist yeputons peter50216 aram90 Div2: lucien tomasz.kociumaka sjynoi DimaPhil",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4671",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1066
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces",
          "content": "Пожалуйста, задавайте возникающие у вас вопросы по задачам. Особенно это касается задачи D, так как она оказалась наиболее сложной.Задача <<Экзамены>> По условию 2n ≤ k ≤ 5n. Если k < 3n то некоторые экзамены мы сможем сдать только на 2. Таких будет 3n - k. Если же 3n ≤ k, то мы все экзамены сдадим как минимум на три.Задача <<Квадрат>> Пусть карандаш идет по прямой и ставит крестики через каждые (n + 1) точку. Поставим в соответствие положению на прямой положение на квадрате. А именно, точке x на прямой будет соответствовать точка, в которую придет карандаш, сдвинувшись по периметру квадрата на x. Тогда левому нижнему углу квадрата соответствуют все точки вида 4np для некоторого целого неотрицательного p. Поставленным крестиками будут соответствовать точки k(n + 1). Самая ближайшая точка совпадения двух семейств, за исключением начальной, будет в LCM(n + 1, 4n) (LCM — НОК). Тогда всего мы поставим крестиков.Задача <<Разрезание фигуры>>Основная идея: учитывая, что ответ не превышает двух, проверим существование ответа 1.Докажем, что ответ в задаче не превосходит двух. Пусть площадь фигуры не менее 4. Тогда рассмотрим самую левую из самых верхних клеток. У нее нет левого и верхнего соседей по стороне. Значит, у нее не будет более двух соседей. Тогда, удалив ее соседей мы уже разделим фигуру на две. Если площадь равна трем, то всегда можно разрезать ее, удалив одну клетку, это можно проверить, так как существует всего два принципиальных случая. Если площадь фигуры не превышает двух, то какое бы множество клеток мы не удалили, она не распадется. Проверим, существует ли ответ, величины один. Удаляемую клетку можно просто перебрать, а затем запустить dfs из любой неудаленной клетки. Если dfs посетит не все оставшиеся клетки, то, удалив нужную клетку мы разрежем фигуру. Если подходящая клетка нашлась — ответ равен 1. Если нет — 2. Еще нужно было не забыть, что иногда ответа может просто не существовать. Это бывает тогда, когда площадь фигуры меньше либо равна двум (площадь фигуры — кол-во клеток в ней)юАсимптотика решения O(n4). Еще можно было воспользоваться алгоритмом поиска точек сочленения и решить эту задачу за O(n2). Но это, наверное, требовало больших трудозатрат.Задача <>Основная идея: перебор за O(Fun). Fu — u-е число Фибоначчи.У этой задачи было довольно сложное условие. С массивом a можно было проводить операции двух типов. Нужно было провести ровно u таких операций, чтобы максимизировать сумму значений массива с заданными коэффициентами.Если просто перебрать все возможные комбинации операций, а потом промоделировать их, то получится решение за O(2u·nu). Это слишом долго. Можно было улучшить это решение, перебирая комбинации операций рекурсивно и по ходу рекурсии моделируя их. Тогда асимптотика улучшается до O(2u·n). Собственно, ничего сильно лучше этого решения не требовалось. Возникает лишь одно соображение: если у нас были две операции подряд, то они ничего не изменили и их можно переместить в любое место нашего алгоритма, не изменив его результат. Тогда можно перебирать только те алгоритмы, в которых все парные операции стоят в конце. Это тоже можно было делать рекурсивно, не идя в ветки с двумя, подряд идущими операциями и обновляя лучший ответ не только в конце рекурсии, но и тогда, когда в конце осталось четное число операций. Это работает сильно лучше. Вспомнив известную задачу \"кол-во последовательностей из нулей и единиц, без двух единиц подряд\" можно понять, что кол-во таких последовательностей, длиной k, равно Fk + 1, где Fi — i-е число Фибоначчи. Тогда кол-во допустимых алгоритмов равно сумме первых u чисел Фибоначчи. Эта сумма примерно равна (u + 2)-му чмслу Фибоначчи. Итоговая асимптотика составляет O(Fu·n). Для максимальных значений входных данных эта величина равна примерно 30 миллионам. Мне не удалось написать на эту задачу отжиг или какое-либо рандом-решение, которое проходило бы все или хотя бы большинство тестов. Задача <<Расстояние Хемминга>>Основная идея: сведение к СЛАУ и решение ее методом Гаусса.Заметим, что если мы одинаковым образом переставим символы во всех строках, то ответ не изменится. Рассмотрим <<столбцы>> ответа, то есть строки s1, i + s2, i + s3, i + s4, i для некоторого i. Всего существует 24 = 16 типов таких строк. Получается, что, если существует ответ на задачу, длины l, то существует и ответ той же длины в котором столбцы упорядочены по типу. Тогда, чтобы перебрать ответ, достаточно перебрать 16 чисел — количества столбцов каждого типа. По этим числам легко восстановить все расстояния Хемминга. Расстояние между строками si и sj будет равно сумме количеств столбцов в которых различны символы c номерами i и j. Однако перебирать все возможные количества столбцов каждого типа слишком долго. Заметим, что мы можем записать систему из 6 уравнений с 16 неизвестными (вспомнив, что расстояние между строками si и sj будет равно сумме количеств столбцов в которых различны символы c номерами i и j). Неизвестными в этой системе уравнений будут количества столбцов каждого из типов. Заметим, что некоторые варианты столбцов полностью идентичны с точки зрения вклада, вносимого в расстояния Хемминга. А именно, столбцы, получаемые друг из друга инвертированием всех букв (заменой <> на <> и наоборот) вносят идентичный вклад в расстояния Хемминга. Например, если добавить в ответ столбец <>, расстояния Хемминга между всеми парами строк изменятся тем же образом, что и при добавлении столбца <>. Получается, что мы можем рассматривать лишь 8 возможных столбцов. Кроме того, столбцы <> и <> вносят нулевой вклад во все расстояния Хемминга. Один из них мы уже исключили из рассмотрения, но можно исключить и второй. Таким образом, мы сократили количество переменных до 7. Решим СЛАУ относительно каких-нибудь шести переменных. Свободным осталось значение одной из переменных. Так как столбцы, количеству которых соответствует эта переменная, вносят ненулевой вклад хотя бы в одно расстояние Хемминга, значение этой переменной не может превосходить максимума из заданных расстояний Хемминга. Тогда можно перебрать его и выбрать наилучший из получившихся ответов.Алгоритм получается следующий: Для каждого типа столбцов определим, какой вклад один такой столбец вносит в каждое из расстояний Хемминга Запустим алгоритм Гаусса для полученной матрицы Переберем значение свободной переменной, выразим через нее остальные, проверим, что все они неотрицательны и целы, выберем наилучший из ответов. Выведем ответ. Асимптотика этого решения составляла O(max(di, j)), если пользоваться типом double и , если решать задачу в рациональных числах.Наверное, могло показаться, что при решении в рациональных числах могло быть переполнение. Но, так как мы применяем наш алгоритм к одной и той же матрице (за исключением последнего столбца), наши вычисления всегда одинаковы, то есть мы домножаем строки на одни и те же числа. Можно заметить, что в нашей матрице все числа будут единицами или двойками, тогда никакой коэффициент в итоге не превысит . Таким образом, можно решать задачу в рациональных числах или в типе double.Задача <<Два отрезка>>Основная идея: обратить перестановку и решать упрощенную задачу (см. ниже), рассмотреть функцию <<количество отрезков в перестановке, которые образуют данный отрезок натурального ряда>>.Чтобы решить эту задачу, можно решить обратную: <<дана перестановка pn, нужно посчитать в них количество отрезков, элементы которых образуют 1 или 2 отрезка натурального ряда>>. Если мы решим эту задачу для некоторой перестановки qn, такой, что , то мы получим ответ для исходной задачи и перестановки.Первое решение, которое приходит в голову: переберем отрезок перестановки и в булевом массиве отметим элементы, принадлежащие ему. Проверим, что в булевском массиве получилось два отрезка. Такое решение будет иметь асимптотику O(n3). После некоторых размышлений можно понять, что при переходе от отрезка пере [l, r] к [l, r + 1] количество отрезков изменится некоторым предсказуемым образом. Обозначим s([a, b]) количество отрезков, которые образуют элементы отрезка [a, b] перестановки. Если новый элемент pr + 1 будет находиться между уже поставленными элементами (то есть, элементы со значениями pr + 1 - 1 и pr + 1 + 1 будут принадлежать отрезку [l, r]), то s([l, r + 1]) = s([l, r]) - 1. Новый элемент <<склеит>> два отрезка между которыми появится. Если у элемента pr + 1 будет один сосед, принадлежащий отрезку [l, r], то s([l, r]) = s([l, r + 1]) (один из существующих отрезков удлинится). Если же у элемента pr + 1 не будет соседей на отрезке [l, r], то новый элемент образует новый отрезок и s([l, r + 1]) = s([l, r]) + 1. Это иллюстрирует рисунок ниже:Новый элемент помечен красным, уже поставленные — черным. Из этих соображений можно получить следующее решение: переберем левую границу и, перебирая правую слева направо, будем пересчитывать количество отрезков, которые образует текущий отрезок перестановки. Если это число равно 1 или 2, прибавим к ответу единицу. Получаем асимптотику O(n2). Это решение работало достаточно быстро даже на n = 20000. Но, разумеется, этого было недостаточно, чтобы решить задачу. Перейдем к полному решению. Оно основывается на предыдущем. Мы уже умеем пересчитывать число отрезков при движении правой границы. Теперь нужно понять, как найти s([l - 1, r]) для любых r, используя s([l, r]). Будем перебирать позицию левой границы отрезков справа налево и поддерживать структуру данных, которая позволит нам хранить s([l, r]) для всех r и сможет считать в себе количество чисел 1 и 2. Обозначим за Δi s([l - 1, i]) - s([l, i]). Δl = 1 так как один элемент образует ровно 1 отрезок. Далее, если мы будем увеличивать i, Δi будет зависеть от количества соседей элемента l на отрезке [l - 1, i]. Если на отрезке нет соседей l, то количество отрезков, которым он соответствует увеличится на 1 при добавлении элемента l (так как l не присоединится ни к какому существующему отрезку). Если на отрезке ровно один сосед l, то количество отрезков, которым он соответствует не изменится при его добавлении (так как l просто присоединится к отрезку своего соседа). Если на отрезке два соседа l, то при его добавлении, количество образуемых отрезков уменьшится на 1. Найдем соседей l, лежащих после него. Обозначим их за a и b. (если после l лежит только один его сосед, b = inf) тогда для всех i, таких что l ≤ i < a Δi = 1. Для всех i, таких что a ≤ i < b Δi = 0 и для всех i удовлетворяющих b ≤ i ≤ n Δi =  - 1. Тогда, чтобы обновить нашу структуру достаточно сделать два прибавления на отрезке. На картинке выше видно, что у элемента 5 оба соседа лежат правее его. Поэтому получается три отрезка эквивалентности Δi (первый из них находится в самом элементе 5). После первого встреченного соседа (4) Δi принимает значение 0 и, наконец, начиная с соседа 6, Δi принимают значение  - 1.Остается только придумать структуру, позволяющую прибавлять на отрезке +1 и -1 и искать в семе числа 1 и 2. Во-первых, заметим, что неположительных чисел структура хранить не будет. Тогда числа 1 и 2 будут являться первым или вторым минимумом в структуре. Тогда структуре достаточно уметь искать два минимума в себе и уметь прибавлять +1 и -1 на отрезке. Два минимума ищутся почти так же, как и один, поэтому можно адаптировать дерево отрезков или sqrt-декомпозицию под эти цели. Сумма ответов структуры на каждой итерации будет ответом на задачу. Авторская sqrt-декомпозиция работала 1.3 секунды, авторское дерево отрезков — 1.1 секунды. sqrt-декомпозиция на Java — 3.6 секунд.Задача <<Число Фибоначчи>>Решение: baby-step-giant-stepВ этой задаче было дано некоторое число Фибоначчи f по модулю 1013, требовалось определить его первое вхождение в последовательность (позицию). Рассмотрим два взаимно простых модуля, делящих 1013. Пометим их как a и b. Остаток от деления f на a будет равен остатку от деления настоящего числа Фибоначчи F, такого, что . (). Найдем вхождения в период последовательности Фибоначчи по модулю a. Найдем вхождения в период последовательности Фибоначчи по модулю b. Зафиксируем пару этих вхождений. Пусть вхождение в последовательность Фибоначчи по модулю a будет в позиции i, а по модулю b — в позиции j. Обозначим за t(m) период последовательности Фибоначчи по модулю m. Из Китайской Теоремы об Остатках следует, что t(ab) = LCM(t(a), t(b)) (так как a и b выбраны взаимно простыми). Тогда по зафиксированным вхождениям f по модулям a и b можно восстановить вхождение f в последовательность по модулю ab. Это можно сделать, решив Диофантово уравнение i + t(a)·x = j + t(b)·y. Это уравнение можно решить перебором одного из корней. Если найденное вхождение в последовательность по модулю ab обозначить за u, то все вхождения f в последовательность по модулю 1013 будут представимы в виде t(ab)·k + u. Тогда переберем k и найдем все вхождения f в последовательность Фибоначчи по модулю 1013. Чтобы получить из числа Фибоначчи на позиции α, чиcло Фибоначчи на позиции α + t(ab) нужно домножить вектор из Fα и Fα + 1 на некоторую матрицу. Выберем a = 59 и b = 213. Заметим, что никакое число не входит в период последовательности Фибоначчи по каждому из этих модулей более 8 раз. Тогда пар вхождений будет не более 64. Для каждого вхождения мы переберем до чисел. Еще можно было более эффективно воспользоваться тем, что число вхождений любого числа в период последовательности Фибоначчи по модулям вроде 10k невелико. Можно было получать из вхождений числа f в последовательность по модулю 10i получить вхождения по модулю 10(i + 1) подобно тому, как в авторском решении осуществляется переход от модуля ab к модулю 1013.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4673",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 13504
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #122 - Codeforces - Code 1",
          "code": ".##\n###\n##.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 2",
          "code": ".##\n###\n##.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 3",
          "code": "####\n##.#\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 4",
          "code": "####\n##.#\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 5",
          "code": "<--p--><-q-><---r---><--t-->\naaaaaaaaaaaaaaaaaaaaaaaaaaaa\nbbbbbbbbbbbbaaaaaaaaaaaaaaaa\naaaaaaabbbbbbbbbbbbbbaaaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 6",
          "code": "<--p--><-q-><---r---><--t-->\naaaaaaaaaaaaaaaaaaaaaaaaaaaa\nbbbbbbbbbbbbaaaaaaaaaaaaaaaa\naaaaaaabbbbbbbbbbbbbbaaaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 7",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 8",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 9",
          "code": "3 3\n...\n.#.\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 10",
          "code": "3 3\n...\n.#.\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces - Code 1",
          "code": "if ((a + 1) mod 4 = 0) then\n        writeln(a + 1)\n      else\n        if ((a + 1) mod 2 = 0) then\n          writeln(2 * a + 1)\n        else\n          writeln(4 * a + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4673",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces - Code 2",
          "code": "if ((a + 1) mod 4 = 0) then\n        writeln(a + 1)\n      else\n        if ((a + 1) mod 2 = 0) then\n          writeln(2 * a + 1)\n        else\n          writeln(4 * a + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4673",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces - Code 3",
          "code": "![ ](<тот самый URL>)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4673",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50, \"m\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    int num_sharps = 0;\n    for (int i = 0; i < n; ++i) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].length()) == m, \"Line %d should be length %d, but length is %d\", i + 1, m, int(grid[i].length()));\n        for (int j = 0; j < m; ++j) {\n            ensuref(grid[i][j] == '#' || grid[i][j] == '.', \"Invalid character '%c' at row %d, column %d\", grid[i][j], i + 1, j + 1);\n            if (grid[i][j] == '#') num_sharps++;\n        }\n    }\n    ensuref(num_sharps > 0, \"There must be at least one '#' cell\");\n\n    // Check connectivity\n    int start_x = -1, start_y = -1;\n    for (int i = 0; i < n && start_x == -1; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == '#') {\n                start_x = i;\n                start_y = j;\n                break;\n            }\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    queue<pair<int, int>> q;\n    q.push({start_x, start_y});\n    visited[start_x][start_y] = true;\n\n    int dx[4] = { -1, 1, 0, 0 };\n    int dy[4] = { 0, 0, -1, 1 };\n\n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n        for (int dir = 0; dir < 4; ++dir) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m) {\n                if (grid[nx][ny] == '#' && !visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    q.push({ nx, ny });\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == '#' && !visited[i][j]) {\n                ensuref(false, \"The set of '#' cells is not connected\");\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50, \"m\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    int num_sharps = 0;\n    for (int i = 0; i < n; ++i) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].length()) == m, \"Line %d should be length %d, but length is %d\", i + 1, m, int(grid[i].length()));\n        for (int j = 0; j < m; ++j) {\n            ensuref(grid[i][j] == '#' || grid[i][j] == '.', \"Invalid character '%c' at row %d, column %d\", grid[i][j], i + 1, j + 1);\n            if (grid[i][j] == '#') num_sharps++;\n        }\n    }\n    ensuref(num_sharps > 0, \"There must be at least one '#' cell\");\n\n    // Check connectivity\n    int start_x = -1, start_y = -1;\n    for (int i = 0; i < n && start_x == -1; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == '#') {\n                start_x = i;\n                start_y = j;\n                break;\n            }\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    queue<pair<int, int>> q;\n    q.push({start_x, start_y});\n    visited[start_x][start_y] = true;\n\n    int dx[4] = { -1, 1, 0, 0 };\n    int dy[4] = { 0, 0, -1, 1 };\n\n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n        for (int dir = 0; dir < 4; ++dir) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m) {\n                if (grid[nx][ny] == '#' && !visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    q.push({ nx, ny });\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == '#' && !visited[i][j]) {\n                ensuref(false, \"The set of '#' cells is not connected\");\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50, \"m\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    int num_sharps = 0;\n    for (int i = 0; i < n; ++i) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].length()) == m, \"Line %d should be length %d, but length is %d\", i + 1, m, int(grid[i].length()));\n        for (int j = 0; j < m; ++j) {\n            ensuref(grid[i][j] == '#' || grid[i][j] == '.', \"Invalid character '%c' at row %d, column %d\", grid[i][j], i + 1, j + 1);\n            if (grid[i][j] == '#') num_sharps++;\n        }\n    }\n    ensuref(num_sharps > 0, \"There must be at least one '#' cell\");\n\n    // Check connectivity\n    int start_x = -1, start_y = -1;\n    for (int i = 0; i < n && start_x == -1; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == '#') {\n                start_x = i;\n                start_y = j;\n                break;\n            }\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    queue<pair<int, int>> q;\n    q.push({start_x, start_y});\n    visited[start_x][start_y] = true;\n\n    int dx[4] = { -1, 1, 0, 0 };\n    int dy[4] = { 0, 0, -1, 1 };\n\n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n        for (int dir = 0; dir < 4; ++dir) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m) {\n                if (grid[nx][ny] == '#' && !visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    q.push({ nx, ny });\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == '#' && !visited[i][j]) {\n                ensuref(false, \"The set of '#' cells is not connected\");\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\");\n    int cells = opt<int>(\"cells\", n * m / 2);\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"singleton\") {\n        // Set grid to all '.'s\n        // Choose a random position (i, j)\n        int i = rnd.next(0, n - 1);\n        int j = rnd.next(0, m - 1);\n        grid[i][j] = '#';\n    }\n    else if (type == \"impossible\") {\n        // Create A consisting of two adjacent cells\n        // Initialize grid with '.'\n        int i1 = rnd.next(0, n - 1);\n        int j1 = rnd.next(0, m - 1);\n        int di[] = {0, 1, 0, -1};\n        int dj[] = {1, 0, -1, 0};\n        vector<int> dirs = {0, 1, 2, 3};\n        shuffle(dirs.begin(), dirs.end());\n        bool placed = false;\n        for (int d : dirs) {\n            int i2 = i1 + di[d];\n            int j2 = j1 + dj[d];\n            if (i2 >= 0 && i2 < n && j2 >= 0 && j2 < m) {\n                grid[i1][j1] = '#';\n                grid[i2][j2] = '#';\n                placed = true;\n                break;\n            }\n        }\n        if (!placed) {\n            grid[i1][j1] = '#';\n        }\n    }\n    else if (type == \"full\") {\n        // Set grid to all '#'s\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '#');\n        }\n    }\n    else if (type == \"line\") {\n        bool horizontal = rnd.next(0, 1);  // 0 or 1\n        if (horizontal) {\n            // Pick a random row\n            int row = rnd.next(0, n - 1);\n            for (int j = 0; j < m; ++j) {\n                grid[row][j] = '#';\n            }\n        } else {\n            // Pick a random column\n            int col = rnd.next(0, m - 1);\n            for (int i = 0; i < n; ++i) {\n                grid[i][col] = '#';\n            }\n        }\n    }\n    else if (type == \"bridge\") {\n        // Ensure that n and m are at least 3\n        if (n < 3) n = 3;\n        if (m < 3) m = 3;\n        grid.resize(n, string(m, '.'));\n\n        // Create first block at top left\n        for (int i = 0; i < n / 2; ++i) {\n            for (int j = 0; j < m / 2; ++j) {\n                grid[i][j] = '#';\n            }\n        }\n        // Create second block at bottom right\n        for (int i = n / 2 + 1; i < n; ++i) {\n            for (int j = m / 2 + 1; j < m; ++j) {\n                grid[i][j] = '#';\n            }\n        }\n        // Connect the two blocks with a bridge at position (n/2, m/2)\n        grid[n / 2][m / 2] = '#';\n    }\n    else if (type == \"biconnected\") {\n        // Fill the grid with '#'s\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '#');\n    }\n    else if (type == \"random\") {\n        // Initialize grid with '.'\n        // BFS to fill 'cells' number of cells\n        vector<pair<int, int>> painted;\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        queue<pair<int, int>> q;\n        int i = rnd.next(0, n - 1);\n        int j = rnd.next(0, m - 1);\n        q.push({i, j});\n        visited[i][j] = true;\n        grid[i][j] = '#';\n        painted.push_back({i, j});\n        int dirs[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};\n        while ((int)painted.size() < cells && !q.empty()) {\n            auto [ci, cj] = q.front();\n            q.pop();\n            vector<int> perm = {0,1,2,3};\n            shuffle(perm.begin(), perm.end());\n            for (int d : perm) {\n                int ni = ci + dirs[d][0];\n                int nj = cj + dirs[d][1];\n                if (ni >= 0 && ni < n && nj >= 0 && nj < m && !visited[ni][nj]) {\n                    visited[ni][nj] = true;\n                    grid[ni][nj] = '#';\n                    painted.push_back({ni, nj});\n                    q.push({ni, nj});\n                    if ((int)painted.size() >= cells)\n                        break;\n                }\n            }\n        }\n    }\n    else {\n        // Default: output an empty grid\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\");\n    int cells = opt<int>(\"cells\", n * m / 2);\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"singleton\") {\n        // Set grid to all '.'s\n        // Choose a random position (i, j)\n        int i = rnd.next(0, n - 1);\n        int j = rnd.next(0, m - 1);\n        grid[i][j] = '#';\n    }\n    else if (type == \"impossible\") {\n        // Create A consisting of two adjacent cells\n        // Initialize grid with '.'\n        int i1 = rnd.next(0, n - 1);\n        int j1 = rnd.next(0, m - 1);\n        int di[] = {0, 1, 0, -1};\n        int dj[] = {1, 0, -1, 0};\n        vector<int> dirs = {0, 1, 2, 3};\n        shuffle(dirs.begin(), dirs.end());\n        bool placed = false;\n        for (int d : dirs) {\n            int i2 = i1 + di[d];\n            int j2 = j1 + dj[d];\n            if (i2 >= 0 && i2 < n && j2 >= 0 && j2 < m) {\n                grid[i1][j1] = '#';\n                grid[i2][j2] = '#';\n                placed = true;\n                break;\n            }\n        }\n        if (!placed) {\n            grid[i1][j1] = '#';\n        }\n    }\n    else if (type == \"full\") {\n        // Set grid to all '#'s\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '#');\n        }\n    }\n    else if (type == \"line\") {\n        bool horizontal = rnd.next(0, 1);  // 0 or 1\n        if (horizontal) {\n            // Pick a random row\n            int row = rnd.next(0, n - 1);\n            for (int j = 0; j < m; ++j) {\n                grid[row][j] = '#';\n            }\n        } else {\n            // Pick a random column\n            int col = rnd.next(0, m - 1);\n            for (int i = 0; i < n; ++i) {\n                grid[i][col] = '#';\n            }\n        }\n    }\n    else if (type == \"bridge\") {\n        // Ensure that n and m are at least 3\n        if (n < 3) n = 3;\n        if (m < 3) m = 3;\n        grid.resize(n, string(m, '.'));\n\n        // Create first block at top left\n        for (int i = 0; i < n / 2; ++i) {\n            for (int j = 0; j < m / 2; ++j) {\n                grid[i][j] = '#';\n            }\n        }\n        // Create second block at bottom right\n        for (int i = n / 2 + 1; i < n; ++i) {\n            for (int j = m / 2 + 1; j < m; ++j) {\n                grid[i][j] = '#';\n            }\n        }\n        // Connect the two blocks with a bridge at position (n/2, m/2)\n        grid[n / 2][m / 2] = '#';\n    }\n    else if (type == \"biconnected\") {\n        // Fill the grid with '#'s\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '#');\n    }\n    else if (type == \"random\") {\n        // Initialize grid with '.'\n        // BFS to fill 'cells' number of cells\n        vector<pair<int, int>> painted;\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        queue<pair<int, int>> q;\n        int i = rnd.next(0, n - 1);\n        int j = rnd.next(0, m - 1);\n        q.push({i, j});\n        visited[i][j] = true;\n        grid[i][j] = '#';\n        painted.push_back({i, j});\n        int dirs[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};\n        while ((int)painted.size() < cells && !q.empty()) {\n            auto [ci, cj] = q.front();\n            q.pop();\n            vector<int> perm = {0,1,2,3};\n            shuffle(perm.begin(), perm.end());\n            for (int d : perm) {\n                int ni = ci + dirs[d][0];\n                int nj = cj + dirs[d][1];\n                if (ni >= 0 && ni < n && nj >= 0 && nj < m && !visited[ni][nj]) {\n                    visited[ni][nj] = true;\n                    grid[ni][nj] = '#';\n                    painted.push_back({ni, nj});\n                    q.push({ni, nj});\n                    if ((int)painted.size() >= cells)\n                        break;\n                }\n            }\n        }\n    }\n    else {\n        // Default: output an empty grid\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type singleton\n./gen -n 2 -m 2 -type impossible\n\n./gen -n 3 -m 3 -type line\n./gen -n 3 -m 3 -type bridge\n./gen -n 3 -m 3 -type biconnected\n\n./gen -n 4 -m 4 -type full\n\n./gen -n 4 -m 4 -type random -cells 8\n\n./gen -n 5 -m 5 -type random -cells 12\n\n./gen -n 10 -m 10 -type full\n\n./gen -n 10 -m 10 -type bridge\n\n./gen -n 10 -m 10 -type random -cells 50\n\n./gen -n 20 -m 20 -type random -cells 100\n\n./gen -n 50 -m 50 -type full\n\n./gen -n 50 -m 50 -type bridge\n\n./gen -n 50 -m 50 -type biconnected\n\n./gen -n 50 -m 50 -type random -cells 500\n\n./gen -n 50 -m 50 -type line\n\n./gen -n 49 -m 49 -type singleton\n\n./gen -n 49 -m 49 -type impossible\n\n./gen -n 40 -m 50 -type random -cells 1000\n\n./gen -n 50 -m 1 -type line\n\n./gen -n 1 -m 50 -type line\n\n./gen -n 7 -m 7 -type line\n\n./gen -n 7 -m 7 -type bridge\n\n./gen -n 7 -m 7 -type biconnected\n\n./gen -n 10 -m 10 -type impossible\n\n./gen -n 5 -m 5 -type singleton\n\n./gen -n 5 -m 5 -type biconnected\n\n./gen -n 5 -m 5 -type random -cells 15\n\n./gen -n 5 -m 5 -type bridge\n\n./gen -n 5 -m 5 -type line\n\n./gen -n 50 -m 50 -type random -cells 2000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:32.611624",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "193/B",
      "title": "B. Xor",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны разделенные пробелом целые числа n, u и r (1 ≤ n, u ≤ 30, 0 ≤ r ≤ 100) — количество элементов в каждом массиве, количество операций и число, описывающее одну из операций. В следующих четырех строках через пробел записаны по n целых чисел — массивы a, b, k, p. В первой строке — массив a, во второй — массив b, в третьей — k и в четвертой — p. Гарантируется, что элементы массивов a и b положительны и не превышают 104 (1 ≤ ai, bi ≤ 104), элементы массива k не превышают 104 по модулю (|ki| ≤ 104) и p является перестановкой чисел от 1 до n.",
      "output_spec": "Выходные данныеВыведите в единственной строке число s — максимальное количество очков, которое можно получить в игре Джона.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 2 17 7 78 8 81 2 31 3 2Выходные данныеСкопировать96Входные данныеСкопировать2 1 01 11 11 -11 2Выходные данныеСкопировать0",
      "description": "ограничение по времени на тест4 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны разделенные пробелом целые числа n, u и r (1 ≤ n, u ≤ 30, 0 ≤ r ≤ 100) — количество элементов в каждом массиве, количество операций и число, описывающее одну из операций. В следующих четырех строках через пробел записаны по n целых чисел — массивы a, b, k, p. В первой строке — массив a, во второй — массив b, в третьей — k и в четвертой — p. Гарантируется, что элементы массивов a и b положительны и не превышают 104 (1 ≤ ai, bi ≤ 104), элементы массива k не превышают 104 по модулю (|ki| ≤ 104) и p является перестановкой чисел от 1 до n.\n\nВходные данные\n\nВыходные данныеВыведите в единственной строке число s — максимальное количество очков, которое можно получить в игре Джона.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать3 2 17 7 78 8 81 2 31 3 2Выходные данныеСкопировать96Входные данныеСкопировать2 1 01 11 11 -11 2Выходные данныеСкопировать0\n\nВходные данныеСкопировать3 2 17 7 78 8 81 2 31 3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать96\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 1 01 11 11 -11 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере нужно применить сначала операцию первого типа, а затем операцию второго типа.",
      "solutions": [
        {
          "title": "Codeforces Round #122 - Codeforces",
          "content": "Привет всем! Я автор задач сегодняшнего раунда. Меня зовут Артур, я учусь в лицее №31 города Челябинска. Благодарю Gerald за координацию подготовки контеста, Delinur за перевод условий, MikeMirzayanov за замечательную систему, dolphinigle за прорешивание контеста, вычитывание условий и множество ценных советов, fdoer, grey_wind, Skird и alger95 за помощь в придумывании задач. Пока ничего практически полезного сказать не могу. Как вы, надеюсь, догадались, контест пройдет в каждом дивизионе отдельно. Система подсчета очков будет стандартная, разбалловка, скорее всего, нестандартная, пока не знаю, какая именно, ближе к делу напишу.Объемных фабул и историй не будет. Надеюсь, что контест и задачи вам понравятся и все пройдет гладко. UPD: Разбалловка следующая:В первом дивизионе: 500-1000-2000-2000-2500.Во втором дивизионе: 500-1000-1500-2000-3000.UPD2: появился разбор Пока частичный и на русском. скоро будет больше.Поздравляю победителей, особенно решивших задачу D.Div1: Petr tourist yeputons peter50216 aram90 Div2: lucien tomasz.kociumaka sjynoi DimaPhil",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4671",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1066
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces",
          "content": "Пожалуйста, задавайте возникающие у вас вопросы по задачам. Особенно это касается задачи D, так как она оказалась наиболее сложной.Задача <<Экзамены>> По условию 2n ≤ k ≤ 5n. Если k < 3n то некоторые экзамены мы сможем сдать только на 2. Таких будет 3n - k. Если же 3n ≤ k, то мы все экзамены сдадим как минимум на три.Задача <<Квадрат>> Пусть карандаш идет по прямой и ставит крестики через каждые (n + 1) точку. Поставим в соответствие положению на прямой положение на квадрате. А именно, точке x на прямой будет соответствовать точка, в которую придет карандаш, сдвинувшись по периметру квадрата на x. Тогда левому нижнему углу квадрата соответствуют все точки вида 4np для некоторого целого неотрицательного p. Поставленным крестиками будут соответствовать точки k(n + 1). Самая ближайшая точка совпадения двух семейств, за исключением начальной, будет в LCM(n + 1, 4n) (LCM — НОК). Тогда всего мы поставим крестиков.Задача <<Разрезание фигуры>>Основная идея: учитывая, что ответ не превышает двух, проверим существование ответа 1.Докажем, что ответ в задаче не превосходит двух. Пусть площадь фигуры не менее 4. Тогда рассмотрим самую левую из самых верхних клеток. У нее нет левого и верхнего соседей по стороне. Значит, у нее не будет более двух соседей. Тогда, удалив ее соседей мы уже разделим фигуру на две. Если площадь равна трем, то всегда можно разрезать ее, удалив одну клетку, это можно проверить, так как существует всего два принципиальных случая. Если площадь фигуры не превышает двух, то какое бы множество клеток мы не удалили, она не распадется. Проверим, существует ли ответ, величины один. Удаляемую клетку можно просто перебрать, а затем запустить dfs из любой неудаленной клетки. Если dfs посетит не все оставшиеся клетки, то, удалив нужную клетку мы разрежем фигуру. Если подходящая клетка нашлась — ответ равен 1. Если нет — 2. Еще нужно было не забыть, что иногда ответа может просто не существовать. Это бывает тогда, когда площадь фигуры меньше либо равна двум (площадь фигуры — кол-во клеток в ней)юАсимптотика решения O(n4). Еще можно было воспользоваться алгоритмом поиска точек сочленения и решить эту задачу за O(n2). Но это, наверное, требовало больших трудозатрат.Задача <>Основная идея: перебор за O(Fun). Fu — u-е число Фибоначчи.У этой задачи было довольно сложное условие. С массивом a можно было проводить операции двух типов. Нужно было провести ровно u таких операций, чтобы максимизировать сумму значений массива с заданными коэффициентами.Если просто перебрать все возможные комбинации операций, а потом промоделировать их, то получится решение за O(2u·nu). Это слишом долго. Можно было улучшить это решение, перебирая комбинации операций рекурсивно и по ходу рекурсии моделируя их. Тогда асимптотика улучшается до O(2u·n). Собственно, ничего сильно лучше этого решения не требовалось. Возникает лишь одно соображение: если у нас были две операции подряд, то они ничего не изменили и их можно переместить в любое место нашего алгоритма, не изменив его результат. Тогда можно перебирать только те алгоритмы, в которых все парные операции стоят в конце. Это тоже можно было делать рекурсивно, не идя в ветки с двумя, подряд идущими операциями и обновляя лучший ответ не только в конце рекурсии, но и тогда, когда в конце осталось четное число операций. Это работает сильно лучше. Вспомнив известную задачу \"кол-во последовательностей из нулей и единиц, без двух единиц подряд\" можно понять, что кол-во таких последовательностей, длиной k, равно Fk + 1, где Fi — i-е число Фибоначчи. Тогда кол-во допустимых алгоритмов равно сумме первых u чисел Фибоначчи. Эта сумма примерно равна (u + 2)-му чмслу Фибоначчи. Итоговая асимптотика составляет O(Fu·n). Для максимальных значений входных данных эта величина равна примерно 30 миллионам. Мне не удалось написать на эту задачу отжиг или какое-либо рандом-решение, которое проходило бы все или хотя бы большинство тестов. Задача <<Расстояние Хемминга>>Основная идея: сведение к СЛАУ и решение ее методом Гаусса.Заметим, что если мы одинаковым образом переставим символы во всех строках, то ответ не изменится. Рассмотрим <<столбцы>> ответа, то есть строки s1, i + s2, i + s3, i + s4, i для некоторого i. Всего существует 24 = 16 типов таких строк. Получается, что, если существует ответ на задачу, длины l, то существует и ответ той же длины в котором столбцы упорядочены по типу. Тогда, чтобы перебрать ответ, достаточно перебрать 16 чисел — количества столбцов каждого типа. По этим числам легко восстановить все расстояния Хемминга. Расстояние между строками si и sj будет равно сумме количеств столбцов в которых различны символы c номерами i и j. Однако перебирать все возможные количества столбцов каждого типа слишком долго. Заметим, что мы можем записать систему из 6 уравнений с 16 неизвестными (вспомнив, что расстояние между строками si и sj будет равно сумме количеств столбцов в которых различны символы c номерами i и j). Неизвестными в этой системе уравнений будут количества столбцов каждого из типов. Заметим, что некоторые варианты столбцов полностью идентичны с точки зрения вклада, вносимого в расстояния Хемминга. А именно, столбцы, получаемые друг из друга инвертированием всех букв (заменой <> на <> и наоборот) вносят идентичный вклад в расстояния Хемминга. Например, если добавить в ответ столбец <>, расстояния Хемминга между всеми парами строк изменятся тем же образом, что и при добавлении столбца <>. Получается, что мы можем рассматривать лишь 8 возможных столбцов. Кроме того, столбцы <> и <> вносят нулевой вклад во все расстояния Хемминга. Один из них мы уже исключили из рассмотрения, но можно исключить и второй. Таким образом, мы сократили количество переменных до 7. Решим СЛАУ относительно каких-нибудь шести переменных. Свободным осталось значение одной из переменных. Так как столбцы, количеству которых соответствует эта переменная, вносят ненулевой вклад хотя бы в одно расстояние Хемминга, значение этой переменной не может превосходить максимума из заданных расстояний Хемминга. Тогда можно перебрать его и выбрать наилучший из получившихся ответов.Алгоритм получается следующий: Для каждого типа столбцов определим, какой вклад один такой столбец вносит в каждое из расстояний Хемминга Запустим алгоритм Гаусса для полученной матрицы Переберем значение свободной переменной, выразим через нее остальные, проверим, что все они неотрицательны и целы, выберем наилучший из ответов. Выведем ответ. Асимптотика этого решения составляла O(max(di, j)), если пользоваться типом double и , если решать задачу в рациональных числах.Наверное, могло показаться, что при решении в рациональных числах могло быть переполнение. Но, так как мы применяем наш алгоритм к одной и той же матрице (за исключением последнего столбца), наши вычисления всегда одинаковы, то есть мы домножаем строки на одни и те же числа. Можно заметить, что в нашей матрице все числа будут единицами или двойками, тогда никакой коэффициент в итоге не превысит . Таким образом, можно решать задачу в рациональных числах или в типе double.Задача <<Два отрезка>>Основная идея: обратить перестановку и решать упрощенную задачу (см. ниже), рассмотреть функцию <<количество отрезков в перестановке, которые образуют данный отрезок натурального ряда>>.Чтобы решить эту задачу, можно решить обратную: <<дана перестановка pn, нужно посчитать в них количество отрезков, элементы которых образуют 1 или 2 отрезка натурального ряда>>. Если мы решим эту задачу для некоторой перестановки qn, такой, что , то мы получим ответ для исходной задачи и перестановки.Первое решение, которое приходит в голову: переберем отрезок перестановки и в булевом массиве отметим элементы, принадлежащие ему. Проверим, что в булевском массиве получилось два отрезка. Такое решение будет иметь асимптотику O(n3). После некоторых размышлений можно понять, что при переходе от отрезка пере [l, r] к [l, r + 1] количество отрезков изменится некоторым предсказуемым образом. Обозначим s([a, b]) количество отрезков, которые образуют элементы отрезка [a, b] перестановки. Если новый элемент pr + 1 будет находиться между уже поставленными элементами (то есть, элементы со значениями pr + 1 - 1 и pr + 1 + 1 будут принадлежать отрезку [l, r]), то s([l, r + 1]) = s([l, r]) - 1. Новый элемент <<склеит>> два отрезка между которыми появится. Если у элемента pr + 1 будет один сосед, принадлежащий отрезку [l, r], то s([l, r]) = s([l, r + 1]) (один из существующих отрезков удлинится). Если же у элемента pr + 1 не будет соседей на отрезке [l, r], то новый элемент образует новый отрезок и s([l, r + 1]) = s([l, r]) + 1. Это иллюстрирует рисунок ниже:Новый элемент помечен красным, уже поставленные — черным. Из этих соображений можно получить следующее решение: переберем левую границу и, перебирая правую слева направо, будем пересчитывать количество отрезков, которые образует текущий отрезок перестановки. Если это число равно 1 или 2, прибавим к ответу единицу. Получаем асимптотику O(n2). Это решение работало достаточно быстро даже на n = 20000. Но, разумеется, этого было недостаточно, чтобы решить задачу. Перейдем к полному решению. Оно основывается на предыдущем. Мы уже умеем пересчитывать число отрезков при движении правой границы. Теперь нужно понять, как найти s([l - 1, r]) для любых r, используя s([l, r]). Будем перебирать позицию левой границы отрезков справа налево и поддерживать структуру данных, которая позволит нам хранить s([l, r]) для всех r и сможет считать в себе количество чисел 1 и 2. Обозначим за Δi s([l - 1, i]) - s([l, i]). Δl = 1 так как один элемент образует ровно 1 отрезок. Далее, если мы будем увеличивать i, Δi будет зависеть от количества соседей элемента l на отрезке [l - 1, i]. Если на отрезке нет соседей l, то количество отрезков, которым он соответствует увеличится на 1 при добавлении элемента l (так как l не присоединится ни к какому существующему отрезку). Если на отрезке ровно один сосед l, то количество отрезков, которым он соответствует не изменится при его добавлении (так как l просто присоединится к отрезку своего соседа). Если на отрезке два соседа l, то при его добавлении, количество образуемых отрезков уменьшится на 1. Найдем соседей l, лежащих после него. Обозначим их за a и b. (если после l лежит только один его сосед, b = inf) тогда для всех i, таких что l ≤ i < a Δi = 1. Для всех i, таких что a ≤ i < b Δi = 0 и для всех i удовлетворяющих b ≤ i ≤ n Δi =  - 1. Тогда, чтобы обновить нашу структуру достаточно сделать два прибавления на отрезке. На картинке выше видно, что у элемента 5 оба соседа лежат правее его. Поэтому получается три отрезка эквивалентности Δi (первый из них находится в самом элементе 5). После первого встреченного соседа (4) Δi принимает значение 0 и, наконец, начиная с соседа 6, Δi принимают значение  - 1.Остается только придумать структуру, позволяющую прибавлять на отрезке +1 и -1 и искать в семе числа 1 и 2. Во-первых, заметим, что неположительных чисел структура хранить не будет. Тогда числа 1 и 2 будут являться первым или вторым минимумом в структуре. Тогда структуре достаточно уметь искать два минимума в себе и уметь прибавлять +1 и -1 на отрезке. Два минимума ищутся почти так же, как и один, поэтому можно адаптировать дерево отрезков или sqrt-декомпозицию под эти цели. Сумма ответов структуры на каждой итерации будет ответом на задачу. Авторская sqrt-декомпозиция работала 1.3 секунды, авторское дерево отрезков — 1.1 секунды. sqrt-декомпозиция на Java — 3.6 секунд.Задача <<Число Фибоначчи>>Решение: baby-step-giant-stepВ этой задаче было дано некоторое число Фибоначчи f по модулю 1013, требовалось определить его первое вхождение в последовательность (позицию). Рассмотрим два взаимно простых модуля, делящих 1013. Пометим их как a и b. Остаток от деления f на a будет равен остатку от деления настоящего числа Фибоначчи F, такого, что . (). Найдем вхождения в период последовательности Фибоначчи по модулю a. Найдем вхождения в период последовательности Фибоначчи по модулю b. Зафиксируем пару этих вхождений. Пусть вхождение в последовательность Фибоначчи по модулю a будет в позиции i, а по модулю b — в позиции j. Обозначим за t(m) период последовательности Фибоначчи по модулю m. Из Китайской Теоремы об Остатках следует, что t(ab) = LCM(t(a), t(b)) (так как a и b выбраны взаимно простыми). Тогда по зафиксированным вхождениям f по модулям a и b можно восстановить вхождение f в последовательность по модулю ab. Это можно сделать, решив Диофантово уравнение i + t(a)·x = j + t(b)·y. Это уравнение можно решить перебором одного из корней. Если найденное вхождение в последовательность по модулю ab обозначить за u, то все вхождения f в последовательность по модулю 1013 будут представимы в виде t(ab)·k + u. Тогда переберем k и найдем все вхождения f в последовательность Фибоначчи по модулю 1013. Чтобы получить из числа Фибоначчи на позиции α, чиcло Фибоначчи на позиции α + t(ab) нужно домножить вектор из Fα и Fα + 1 на некоторую матрицу. Выберем a = 59 и b = 213. Заметим, что никакое число не входит в период последовательности Фибоначчи по каждому из этих модулей более 8 раз. Тогда пар вхождений будет не более 64. Для каждого вхождения мы переберем до чисел. Еще можно было более эффективно воспользоваться тем, что число вхождений любого числа в период последовательности Фибоначчи по модулям вроде 10k невелико. Можно было получать из вхождений числа f в последовательность по модулю 10i получить вхождения по модулю 10(i + 1) подобно тому, как в авторском решении осуществляется переход от модуля ab к модулю 1013.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4673",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 13504
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #122 - Codeforces - Code 1",
          "code": ".##\n###\n##.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 2",
          "code": ".##\n###\n##.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 3",
          "code": "####\n##.#\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 4",
          "code": "####\n##.#\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 5",
          "code": "<--p--><-q-><---r---><--t-->\naaaaaaaaaaaaaaaaaaaaaaaaaaaa\nbbbbbbbbbbbbaaaaaaaaaaaaaaaa\naaaaaaabbbbbbbbbbbbbbaaaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 6",
          "code": "<--p--><-q-><---r---><--t-->\naaaaaaaaaaaaaaaaaaaaaaaaaaaa\nbbbbbbbbbbbbaaaaaaaaaaaaaaaa\naaaaaaabbbbbbbbbbbbbbaaaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 7",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 8",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 9",
          "code": "3 3\n...\n.#.\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 10",
          "code": "3 3\n...\n.#.\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces - Code 1",
          "code": "if ((a + 1) mod 4 = 0) then\n        writeln(a + 1)\n      else\n        if ((a + 1) mod 2 = 0) then\n          writeln(2 * a + 1)\n        else\n          writeln(4 * a + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4673",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces - Code 2",
          "code": "if ((a + 1) mod 4 = 0) then\n        writeln(a + 1)\n      else\n        if ((a + 1) mod 2 = 0) then\n          writeln(2 * a + 1)\n        else\n          writeln(4 * a + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4673",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces - Code 3",
          "code": "![ ](<тот самый URL>)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4673",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 30, \"n\");\n    inf.readSpace();\n    int u = inf.readInt(1, 30, \"u\");\n    inf.readSpace();\n    int r = inf.readInt(0, 100, \"r\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 10000, \"a\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 10000, \"b\");\n    inf.readEoln();\n\n    vector<int> k = inf.readInts(n, -10000, 10000, \"k\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    // Check that p is a permutation of numbers from 1 to n\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == n, \"Array p must be a permutation of numbers from 1 to n\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 30, \"n\");\n    inf.readSpace();\n    int u = inf.readInt(1, 30, \"u\");\n    inf.readSpace();\n    int r = inf.readInt(0, 100, \"r\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 10000, \"a\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 10000, \"b\");\n    inf.readEoln();\n\n    vector<int> k = inf.readInts(n, -10000, 10000, \"k\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    // Check that p is a permutation of numbers from 1 to n\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == n, \"Array p must be a permutation of numbers from 1 to n\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 30, \"n\");\n    inf.readSpace();\n    int u = inf.readInt(1, 30, \"u\");\n    inf.readSpace();\n    int r = inf.readInt(0, 100, \"r\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 10000, \"a\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 10000, \"b\");\n    inf.readEoln();\n\n    vector<int> k = inf.readInts(n, -10000, 10000, \"k\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n\n    // Check that p is a permutation of numbers from 1 to n\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == n, \"Array p must be a permutation of numbers from 1 to n\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    if (n < 1 || n > 30) {\n        fprintf(stderr, \"Error: n must be between 1 and 30\\n\");\n        return 1;\n    }\n    int u = opt<int>(\"u\", 1);\n    if (u < 1 || u > 30) {\n        fprintf(stderr, \"Error: u must be between 1 and 30\\n\");\n        return 1;\n    }\n    int r = opt<int>(\"r\", -1);\n    if (r == -1) {\n        // Use default value\n        r = rnd.next(0, 100);\n    } else if (r < 0 || r > 100) {\n        fprintf(stderr, \"Error: r must be between 0 and 100\\n\");\n        return 1;\n    }\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n), b(n), k(n), p(n);\n\n    if (type == \"random\") {\n        // Generate random arrays within the constraints\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"max_values\") {\n        // Maximize all values\n        for (int i = 0; i < n; ++i) {\n            a[i] = 10000;\n            b[i] = 10000;\n            k[i] = 10000;\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"min_values\") {\n        // Minimize all values\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n            b[i] = 1;\n            k[i] = -10000;\n            p[i] = i + 1;\n        }\n    } else if (type == \"negative_k\") {\n        // k_i is -10000\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = -10000;\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"positive_k\") {\n        // k_i is 10000\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = 10000;\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"zero_k\") {\n        // k_i is zero\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = 0;\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"same_a\") {\n        // All a_i are the same\n        int val = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"same_b\") {\n        // All b_i are the same\n        int val = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = val;\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"same_k\") {\n        // All k_i are the same\n        int val = rnd.next(-10000, 10000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = val;\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"increasing_p\") {\n        // p_i in order 1..n\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = i + 1;\n        }\n    } else if (type == \"decreasing_p\") {\n        // p_i in order n..1\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = n - i;\n        }\n    } else if (type == \"max_a_b\") {\n        // Maximize a_i and b_i\n        for (int i = 0; i < n; ++i) {\n            a[i] = 10000;\n            b[i] = 10000;\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"min_a_b\") {\n        // Minimize a_i and b_i\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n            b[i] = 1;\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"max_r\") {\n        // r = 100\n        r = 100;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"zero_r\") {\n        // r = 0\n        r = 0;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, u, r);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", b[i], i + 1 == n ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", k[i], i + 1 == n ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    if (n < 1 || n > 30) {\n        fprintf(stderr, \"Error: n must be between 1 and 30\\n\");\n        return 1;\n    }\n    int u = opt<int>(\"u\", 1);\n    if (u < 1 || u > 30) {\n        fprintf(stderr, \"Error: u must be between 1 and 30\\n\");\n        return 1;\n    }\n    int r = opt<int>(\"r\", -1);\n    if (r == -1) {\n        // Use default value\n        r = rnd.next(0, 100);\n    } else if (r < 0 || r > 100) {\n        fprintf(stderr, \"Error: r must be between 0 and 100\\n\");\n        return 1;\n    }\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n), b(n), k(n), p(n);\n\n    if (type == \"random\") {\n        // Generate random arrays within the constraints\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"max_values\") {\n        // Maximize all values\n        for (int i = 0; i < n; ++i) {\n            a[i] = 10000;\n            b[i] = 10000;\n            k[i] = 10000;\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"min_values\") {\n        // Minimize all values\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n            b[i] = 1;\n            k[i] = -10000;\n            p[i] = i + 1;\n        }\n    } else if (type == \"negative_k\") {\n        // k_i is -10000\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = -10000;\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"positive_k\") {\n        // k_i is 10000\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = 10000;\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"zero_k\") {\n        // k_i is zero\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = 0;\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"same_a\") {\n        // All a_i are the same\n        int val = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"same_b\") {\n        // All b_i are the same\n        int val = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = val;\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"same_k\") {\n        // All k_i are the same\n        int val = rnd.next(-10000, 10000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = val;\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"increasing_p\") {\n        // p_i in order 1..n\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = i + 1;\n        }\n    } else if (type == \"decreasing_p\") {\n        // p_i in order n..1\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = n - i;\n        }\n    } else if (type == \"max_a_b\") {\n        // Maximize a_i and b_i\n        for (int i = 0; i < n; ++i) {\n            a[i] = 10000;\n            b[i] = 10000;\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"min_a_b\") {\n        // Minimize a_i and b_i\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n            b[i] = 1;\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"max_r\") {\n        // r = 100\n        r = 100;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"zero_r\") {\n        // r = 0\n        r = 0;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, u, r);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", b[i], i + 1 == n ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", k[i], i + 1 == n ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", p[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -u 1 -type min_n\n./gen -n 30 -u 30 -type max_n\n./gen -n 30 -u 30 -type max_values\n./gen -n 30 -u 30 -r 0 -type zero_r\n./gen -n 30 -u 30 -r 100 -type max_r\n./gen -n 30 -u 1 -r 50 -type min_u\n./gen -n 1 -u 30 -r 50 -type min_n_max_u\n./gen -n 30 -u 30 -type negative_k\n./gen -n 30 -u 30 -type positive_k\n./gen -n 30 -u 30 -type zero_k\n./gen -n 30 -u 30 -type same_a\n./gen -n 30 -u 30 -type same_b\n./gen -n 30 -u 30 -type same_k\n./gen -n 30 -u 30 -type increasing_p\n./gen -n 30 -u 30 -type decreasing_p\n./gen -n 30 -u 30 -type max_a_b\n./gen -n 30 -u 30 -type min_a_b\n./gen -n 15 -u 15 -type random\n./gen -n 1 -u 1 -type random\n./gen -n 30 -u 30 -type random\n./gen -n 10 -u 5 -type random\n./gen -n 20 -u 10 -type random\n./gen -n 25 -u 25 -type random -r 100\n./gen -n 25 -u 25 -type random -r 0\n./gen -n 30 -u 15 -type zero_r\n./gen -n 30 -u 30 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:34.386801",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "193/C",
      "title": "C. Hamming Distance",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains space-separated integers h(s1, s2), h(s1, s3), h(s1, s4). The second line contains space-separated integers h(s2, s3) and h(s2, s4). The third line contains the single integer h(s3, s4).All given integers h(si, sj) are non-negative and do not exceed 105. It is guaranteed that at least one number h(si, sj) is positive.",
      "output_spec": "OutputPrint -1 if there's no suitable set of strings.Otherwise print on the first line number len — the length of each string. On the i-th of the next four lines print string s'i. If there are multiple sets with the minimum length of the strings, print any of them.",
      "sample_tests": "ExamplesInputCopy4 4 44 44OutputCopy6aaaabbaabbaabbaaaabbbbbb",
      "description": "C. Hamming Distance\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains space-separated integers h(s1, s2), h(s1, s3), h(s1, s4). The second line contains space-separated integers h(s2, s3) and h(s2, s4). The third line contains the single integer h(s3, s4).All given integers h(si, sj) are non-negative and do not exceed 105. It is guaranteed that at least one number h(si, sj) is positive.\n\nOutputPrint -1 if there's no suitable set of strings.Otherwise print on the first line number len — the length of each string. On the i-th of the next four lines print string s'i. If there are multiple sets with the minimum length of the strings, print any of them.\n\nInputCopy4 4 44 44OutputCopy6aaaabbaabbaabbaaaabbbbbb\n\nInputCopy4 4 44 44\n\nOutputCopy6aaaabbaabbaabbaaaabbbbbb",
      "solutions": [
        {
          "title": "Codeforces Round #122 - Codeforces",
          "content": "The upcoming contest is brought to you by me. My name is Arthur, I'm a student of Chelyabinsk lyceum 31.I am glad to thank Gerald for contest preparation management, Delinur for translation of statements, MikeMirzayanov for a really excellent system, dolphinigle for test-solving, proof-reading and much valuable advice, fdoer, grey_wind, Skird and alger95 for help in problem development.There is nothing more to say yet. As you can see, contest will be held in two divisions separately. The scoring system will be standard (not dynamic), but scores for tasks may be unusual (see update of this post).There won't be volume stories. I hope you will like the contest and its problemset and everything will be OK.UPD: Scores for tasks:Division 1: 500-1000-2000-2000-2500Division 2: 500-1000-1500-2000-3000UPD2: Congrats to winners =)Div1: Petr tourist yeputons peter50216 aram90 Div2: lucien tomasz.kociumaka sjynoi UPD3 some part of English editoral posted. You will find the remaining part of the editorial laterUPD4 English editoral was completed.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4671",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1048
        },
        {
          "title": "Editoral Codeforces Round #122 - Codeforces",
          "content": "Please, report me about every grammar mistake, you see. Thank you.Problem <>Let's notice that 2n ≤ k ≤ 5n. If k < 3n author has to get 2 on some exams. There are 3n - k such exams and that's the answer). If 3n ≤ k author will pass all exams (answer is 0).Problem <>Let the pencil move by the line and put crosses through every (n + 1) point. Lets associate every point on the line with point on square perimeter. Namely, point x on the line will be associated with point on square perimeter that we will reach if we move pencil around square to x clockwise. Then lower left corner will be associated with all points 4np for every non-negative integer p. Crosses will be associated with points k(n + 1) for some non-negative k. Nearest point of overlap of two families of points will be in point LCM(n + 1, 4n). Then we will put crosses.Problem \"Cutting Figure\"Translation by fdoerMain idea: using the fact that the answer cannot be greater than 2, check answer 1.Let's proof that the answer is not greater than 2. Let area of the figure be greater than 3. Let's examine the leftmost of all topmost squares. There is no neighbors left or up to it. So, number of its neighbors is not more than 2. Thus, if we delete its neighbors, we shall disconnect the figure. If the area is equal to 3, we always can disconnect the figure by deletion of one square. It can be proofed by considering all two primary cases. If the area is not greater than 2, there is no way to disconnect the figure.The algorithm: Check answer 1. We can simply brute-force the square to delete, and for each instance start dfs from any existing square. If during the dfs we visited not all of the remaining squares, we have found the square to delete. The answer is 1 if our bruteforce succeeded, and 2 otherwise.That was necessary to consider the case when there is no answer.The complexity of the described algorithm is O(n4). That was possible to search for articulation points and solve the problem in complexity O(n2), but in my opinion that required more time and effort.Problem <>Translation by fdoerMain idea: bruteforce in complexity O(Fun) where Fu if fibonacci number at position u.This problem had complex statements. We have an array a, and we can transform it in two ways. The goal was to maximize the sum of all its elements with given multipliers after exactly u operations. A simple bruteforce of all combinations of operations with subsequent modeling leads to complexity O(2u * nu), what is not fast enough. That was possible to optimize it by modeling parallel to recursive bruteforce. Now we have complexity O(2un). Actually, the correct solution is not too far from this algorithm.There is just one conjecture: every two successive xor operations change nothing, and we can move them to any place of the combination. Thus, it will be enough to bruteforce only combinations in which every pair of successive xor operations is at the end.It could be done using recoursive bruteforce. We must change in previous solution two things. First, we must n't put xor after xor. Besides that, we should update answer if number u - l is even, where l is current level of recoursion (all remaining operations in the end separates to pairs of xors).Let's calculate complexity of this algo. There are Fi sequences of length i without two consecutive xors. It's easy to proof, you can calculate some dp to see it. That's why, complexity of our algo is O(Fun). Problem \"Hamming distance\"Main idea: reduction to system of linear equations and solving it using Gauss algorithm.Let's notice that order of columns in answer doesn't matter. That's why there is only one important thing — quantity of every type of column. There is only 24 = 16 different columns. Let's represent Hamming distance between every pair of strings as sum of quantities of types of columns. It's possible because every column adds to every distance between pairs 0 or 1. Now we have system of 6 linear equations with 16 variables. It's not good, let's decrease number of variables. First, some columns adds same values to every Hamming distance. For example strings \"abbb\" and \"baaa\". For every column q we can replace all letters \"a\" by letters \"b\" and all letters \"b\" by letters \"a\" and reach column that adds same values to every distance. We reduced number of variables to 8. We also can notice that columns \"aaaa\" and \"bbbb\" is useless and reduce number of variables to 7.This system can be solved using Gauss algorithm. One variable steel be free. Let's fix it. It's value can't be more than maximum of h(si, sj) because column adds positive value to one or more Hamming distance. For every fixed value we should check if all variables take non-negative integer value and choose the best answer.We can solve system of equations in integers because coefficients of equation is little.Complexity of this solution if O(max(h(si, sj))). If we solve it in rational numbers complexity will change to .Problem \"Two segments\"Main idea: inverse the permutation and solve simplified problem (see below), consider function \"quantity of segments of permutation that form the given segment of natural series\".In order to solve this problem, we suggest solve another: <<we have a permutation pn, we have to calculate the count of segments such that their elements form one or two segments of natural series>>.If we solve the inverse problem for some permutation qn such that , we shall get the answer for the initial problem and initial permutation pi. Straight-forward algo: let's bruteforce the segment of permutation and mark its elements in a boolean array. Check that in that array there is not more than two marked segments. This algo has complexity O(n3).Let's notice that during the changeover from [l, r] to [l, r + 1] the quantity of segments changes in some predictable way. Let s([a, b]) be quantity of segments that form segment [a, b] of permutation. There are three cases (see picture below): If the new element pr + 1 is between two marked elements (that is, both elements with values pr + 1 - 1 and pr + 1 + 1 belong to segment [l, r]), then s([l, r + 1]) = s([l, r]) - 1. The new element will <> the segments near it. If the new element pr + 1 has only one neighbor with value belonging to [l, r], then s([l, r + 1]) = s([l, r]). The new element will lengthen one of existing segments. If there are no marked elements near pr + 1 the new element forms a new segment, s([l, r + 1]) = s([l, r]) + 1. The new element is red, elements that are marked to this moment are black.Improved algo: Let's bruteforce position of the left border and for each instance move the right border from left to right. During each move we shall recount the actual quantity of segments forming the current segment of permutation (s([l, r])). Now we have a solution in complexity O(n2). It works fast enough even when n = 20000. Obviously, that is not enough to get AC.Move on full solution. It is based on previous. Now we can calc s([l, r]) using s([l, r - 1]). Now we should look at way of changing s([l - 1, r]) as compared with s([l, r]). Let's move left border of segment from the right to left and support some data structure with s([l, i]) for every i satisfying l < i ≤ n and current l. This structure should answer queries \"count numbers 1 and 2 in structure\", that is count segments [l, i] that generates one or two segments in the original permutaton.Let Δi be s([l - 1, i]) - s([l, i]). Δl will be equal to 1 because one element form one segment in permutation (notice that in final answer we must not consider 1-element segments, that's why we must subtract n from answer in the end of solution). Δi determined by the number of neighbors of element l - 1 in the segment [l - 1, i]. Neighbors of l - 1 is elements pl - 1 + 1 and pl - 1 - 1 if they're exist. If l - 1 hasn't neighbors in this segment, Δi = 1, because l - 1 froms new 1-element segment. If l - 1 has one neighbor in this segment Δi = 0, because l - 1 join to existing segment of its neighbor. If l - 1 has two neighbors in this segment Δi =  - 1, because l - 1 connect segments of its neighbors. Number of neighbors in segment [l - 1, i] non-decreasing with increasing i. That's why Δi non-decreasing with increasing i. That means that there are only three segments of equivalence of Δi. We are interested only in neighbors of l - 1 which positions are right than l - 1. Let a is position of first neighbor, b is position of second neighbor, without loss of generality a < b. Then , , . (elements of permutation are numbered from 0). If a and b aren't exist, for all Δi = 1. If only b isn't exist for , for . Look at example to clear your understanding. (Δi is in top right corners, l = 3, pl = 5)Using this facts we can code data structure support following operations: Add +1 or -1 on segment Calc number of 1 and 2 in the structure. Sum of answers of structure in every iteration (for every l) is answer to problem.Let's notice that all numbers in structure will be positive. That's why elements 1 and 2 will be minimal of pre-minimal in the structure. Using this fact we can code segment tree, supports these operations.Complexity of this solution is .We also can code sqrt-decomposition and obtain complexity .Problem <>Translation by fdoerMain idea: baby-step-giant-step.In this problem we had some Fibonacci number modulo 1013 f, and we had to determine the position of its first occurence in Fibonacci sequence modulo 1013. Let a and b be two different coprime modula — divisors of 1013. Let F be the actual Fibonacci number such that . Then and . Find all occurences of number in Fibonacci sequence modulo a period. Find all occurences of number in Fibonacci sequence modulo b period. Let's fix a pair of such occurences. Let the occurence modulo a be in position i, and the occurence modulo b be in position j. Let t(m) be Fibonacci sequence modulo m period. From the Chinese Remainder Theorem, it follows that t(ab) = LCM(t(a), t(b)) (remember that a and b are coprime). Then from fixed occurences of f in periods of sequences modulo a and b we can recover the position of occurence of f in period of sequence modulo ab. It could be done by solving the following Diophantine equation: i + t(a) * x = j + t(b) * y. We can solve it using a simple bruteforce of one of the roots. If the occurence in sequence modulo ab period ( we have just found it) is u, then every occurence f in Fibonacci sequence modulo 1013 period can be represented as t(ab) * k + u. Then let's bruteforce k and find all occurences in sequence modulo 1013 period. To determine Fibonacci number on position α + t(ab) from known Fibonacci number on position α, we need to multiply the vector (Fα, Fα + 1) and some matrix. Let's choose a = 59 and b = 213. Note that there is no number that occur Fibonacci sequence modulo a or b period more than 8 times. That means that total count of pairs will never be greater than 64. For each occurence we'll bruteforce not more than numbers. That was the author's solution. Also that was possible to use the fact that for any number the count of its occurences in period of sequence modulo 10p (for any natural p) is not big more efficiently. From occurences in sequence modulo 10i period we could get occurences in sequence modulo 10i + 1 period using the method we use to jump from modulus ab to modulus 1013.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4673",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11337
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #122 - Codeforces - Code 1",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 2",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> h;\n\n    // Read first line: 3 integers\n    vector<int> line1 = inf.readInts(3, 0, 100000, \"h1\");\n    inf.readEoln();\n    h.insert(h.end(), line1.begin(), line1.end());\n\n    // Read second line: 2 integers\n    vector<int> line2 = inf.readInts(2, 0, 100000, \"h2\");\n    inf.readEoln();\n    h.insert(h.end(), line2.begin(), line2.end());\n\n    // Read third line: 1 integer\n    int h3 = inf.readInt(0, 100000, \"h3\");\n    inf.readEoln();\n    h.push_back(h3);\n\n    // Ensure at least one h(si, sj) > 0\n    bool at_least_one_positive = false;\n    for (int x : h) {\n        if (x > 0) {\n            at_least_one_positive = true;\n            break;\n        }\n    }\n    ensuref(at_least_one_positive, \"At least one h(si, sj) must be positive\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> h;\n\n    // Read first line: 3 integers\n    vector<int> line1 = inf.readInts(3, 0, 100000, \"h1\");\n    inf.readEoln();\n    h.insert(h.end(), line1.begin(), line1.end());\n\n    // Read second line: 2 integers\n    vector<int> line2 = inf.readInts(2, 0, 100000, \"h2\");\n    inf.readEoln();\n    h.insert(h.end(), line2.begin(), line2.end());\n\n    // Read third line: 1 integer\n    int h3 = inf.readInt(0, 100000, \"h3\");\n    inf.readEoln();\n    h.push_back(h3);\n\n    // Ensure at least one h(si, sj) > 0\n    bool at_least_one_positive = false;\n    for (int x : h) {\n        if (x > 0) {\n            at_least_one_positive = true;\n            break;\n        }\n    }\n    ensuref(at_least_one_positive, \"At least one h(si, sj) must be positive\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> h;\n\n    // Read first line: 3 integers\n    vector<int> line1 = inf.readInts(3, 0, 100000, \"h1\");\n    inf.readEoln();\n    h.insert(h.end(), line1.begin(), line1.end());\n\n    // Read second line: 2 integers\n    vector<int> line2 = inf.readInts(2, 0, 100000, \"h2\");\n    inf.readEoln();\n    h.insert(h.end(), line2.begin(), line2.end());\n\n    // Read third line: 1 integer\n    int h3 = inf.readInt(0, 100000, \"h3\");\n    inf.readEoln();\n    h.push_back(h3);\n\n    // Ensure at least one h(si, sj) > 0\n    bool at_least_one_positive = false;\n    for (int x : h) {\n        if (x > 0) {\n            at_least_one_positive = true;\n            break;\n        }\n    }\n    ensuref(at_least_one_positive, \"At least one h(si, sj) must be positive\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// We'll store the six input distances in the global array dist:\n// dist[0] = h(s1, s2), dist[1] = h(s1, s3), dist[2] = h(s1, s4)\n// dist[3] = h(s2, s3), dist[4] = h(s2, s4), dist[5] = h(s3, s4)\nstatic long long dist[6];\n\n// Reads one answer (either the jury's or the participant's) from 'stream'.\n// If the answer is \"-1\", we return a length of -1 and do not read any strings.\n// Otherwise, we read the declared length L, then read 4 strings of length L\n// containing only 'a' or 'b'. We compute their 6 pairwise Hamming distances\n// and store them in the vector 'answerDist' in the same order as dist[] above.\n// If something is invalid, we quit with _fail (for jury) or _wa (for participant).\n// Return: (length, vector of computed distances) if length != -1\n//         ( -1, empty vector ) if answer is just \"-1\"\npair<long long, vector<long long>> readAnswer(InStream &stream, bool isJury) {\n    // Read next token to check if it is \"-1\" or an integer\n    string maybeLen = stream.readToken();\n\n    // If the token is exactly \"-1\", then we treat it as no solution\n    if (maybeLen == \"-1\") {\n        return make_pair(-1LL, vector<long long>());\n    }\n\n    // Otherwise, parse that token as length L\n    long long L = 0;\n    try {\n        L = stoll(maybeLen);\n    } catch(...) {\n        stream.quitf(isJury ? _fail : _wa, \n            \"Cannot parse the string \\\"%s\\\" as a valid integer length\", maybeLen.c_str());\n    }\n    if (L < 0 || L > 100000) {\n        stream.quitf(isJury ? _fail : _wa, \n            \"Length %lld is out of the expected range [0..100000]\", L);\n    }\n\n    // Now read 4 strings of length L containing only 'a' or 'b'\n    vector<string> S(4);\n    for (int i = 0; i < 4; i++) {\n        S[i] = stream.readToken();\n        if ((long long)S[i].size() != L) {\n            stream.quitf(isJury ? _fail : _wa,\n                         \"string #%d has length %d != declared length %lld\",\n                         i + 1, (int)S[i].size(), L);\n        }\n        // Check only 'a' or 'b'\n        for (char c : S[i]) {\n            if (c != 'a' && c != 'b') {\n                stream.quitf(isJury ? _fail : _wa,\n                             \"string #%d contains invalid character '%c'\",\n                             i + 1, c);\n            }\n        }\n    }\n\n    // Compute the 6 pairwise Hamming distances\n    // We'll store them in the order: (s1,s2), (s1,s3), (s1,s4),\n    //                                (s2,s3), (s2,s4), (s3,s4)\n    vector<long long> answerDist(6, 0LL);\n\n    auto computeHamming = [&](const string &A, const string &B) {\n        long long h = 0;\n        for (int i = 0; i < (int)A.size(); i++) {\n            if (A[i] != B[i]) h++;\n        }\n        return h;\n    };\n\n    answerDist[0] = computeHamming(S[0], S[1]);\n    answerDist[1] = computeHamming(S[0], S[2]);\n    answerDist[2] = computeHamming(S[0], S[3]);\n    answerDist[3] = computeHamming(S[1], S[2]);\n    answerDist[4] = computeHamming(S[1], S[3]);\n    answerDist[5] = computeHamming(S[2], S[3]);\n\n    return make_pair(L, answerDist);\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read the 6 required distances from the input file\n    dist[0] = inf.readLong(0, 100000, \"h(s1, s2)\");\n    dist[1] = inf.readLong(0, 100000, \"h(s1, s3)\");\n    dist[2] = inf.readLong(0, 100000, \"h(s1, s4)\");\n    dist[3] = inf.readLong(0, 100000, \"h(s2, s3)\");\n    dist[4] = inf.readLong(0, 100000, \"h(s2, s4)\");\n    dist[5] = inf.readLong(0, 100000, \"h(s3, s4)\");\n\n    // Read the jury's (correct) answer\n    pair<long long, vector<long long>> jury = readAnswer(ans, /*isJury=*/true);\n    long long jLen = jury.first;\n    vector<long long> jDist = jury.second;\n\n    // If jLen != -1, verify official solution's distances match 'dist'\n    if (jLen != -1) {\n        for (int i = 0; i < 6; i++) {\n            if (jDist[i] != dist[i]) {\n                quitf(_fail,\n                      \"jury's solution mismatch: distance #%d, expected=%lld, found=%lld\",\n                      i, dist[i], jDist[i]);\n            }\n        }\n    }\n\n    // Read participant's answer\n    pair<long long, vector<long long>> part = readAnswer(ouf, /*isJury=*/false);\n    long long pLen = part.first;\n    vector<long long> pDist = part.second;\n\n    // Case 1: If jury said \"-1\", participant must say \"-1\"\n    if (jLen == -1) {\n        if (pLen == -1) {\n            quitf(_ok, \"both answered -1, no solution\");\n        } else {\n            quitf(_wa, \"jury says no solution, but participant provided one\");\n        }\n    }\n\n    // Case 2: If participant says \"-1\", but jury has a solution, it's WA\n    if (pLen == -1) {\n        quitf(_wa, \"participant claims no solution, but jury has one\");\n    }\n\n    // Now both have solutions, compare\n    // Verify participant's distances\n    for (int i = 0; i < 6; i++) {\n        if (pDist[i] != dist[i]) {\n            quitf(_wa,\n                  \"distance mismatch at index #%d: expected=%lld, found=%lld\",\n                  i, dist[i], pDist[i]);\n        }\n    }\n\n    // Minimal length check\n    if (pLen > jLen) {\n        quitf(_wa,\n              \"participant's strings length %lld is larger than jury's minimal length %lld\",\n              pLen, jLen);\n    } else if (pLen < jLen) {\n        quitf(_fail,\n              \"participant found a shorter solution (%lld) than jury's (%lld)\",\n              pLen, jLen);\n    }\n\n    // If same length, all good\n    quitf(_ok, \"correct solution with length %lld\", pLen);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid outputDistances(int h12, int h13, int h14, int h23, int h24, int h34) {\n    printf(\"%d %d %d\\n\", h12, h13, h14);\n    printf(\"%d %d\\n\", h23, h24);\n    printf(\"%d\\n\", h34);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n    int len = opt<int>(\"len\", -1); // Length of the strings\n\n    if (type == \"valid_random\") {\n        // Generate valid random strings\n        if (len == -1) {\n            len = rnd.next(1, 100000); // Random length between 1 and 1e5\n        }\n        vector<string> s(4);\n        for (int i = 0; i < 4; ++i) {\n            s[i].resize(len);\n            for (int j = 0; j < len; ++j) {\n                s[i][j] = rnd.next(0, 1) ? 'a' : 'b';\n            }\n        }\n        // Compute Hamming distances\n        int h12 = 0, h13 = 0, h14 = 0, h23 = 0, h24 = 0, h34 = 0;\n        for (int k = 0; k < len; ++k) {\n            if (s[0][k] != s[1][k]) h12++;\n            if (s[0][k] != s[2][k]) h13++;\n            if (s[0][k] != s[3][k]) h14++;\n            if (s[1][k] != s[2][k]) h23++;\n            if (s[1][k] != s[3][k]) h24++;\n            if (s[2][k] != s[3][k]) h34++;\n        }\n        outputDistances(h12, h13, h14, h23, h24, h34);\n\n    } else if (type == \"no_solution\") {\n        // Generate distances that cannot be realized\n        int h12 = 0, h13 = 1, h14 = 2, h23 = 3, h24 = 4, h34 = 5;\n        outputDistances(h12, h13, h14, h23, h24, h34);\n\n    } else if (type == \"identical_strings\") {\n        // Generate distances where most pairs are identical\n        if (len == -1) {\n            len = rnd.next(1, 10); // Random length between 1 and 10\n        }\n        int h12 = 0, h13 = 0, h14 = 0, h23 = 0, h24 = 0, h34 = 1; // At least one distance > 0\n        outputDistances(h12, h13, h14, h23, h24, h34);\n\n    } else if (type == \"max_distances\") {\n        // All distances equal to the length of the strings\n        if (len == -1) {\n            len = rnd.next(1, 100000);\n        }\n        int h12 = len, h13 = len, h14 = len, h23 = len, h24 = len, h34 = len;\n        outputDistances(h12, h13, h14, h23, h24, h34);\n\n    } else if (type == \"edge_case1\") {\n        // Maximum Hamming distance between two strings, others are zero\n        if (len == -1) {\n            len = rnd.next(1, 100000);\n        }\n        int h12 = len, h13 = 0, h14 = 0, h23 = 0, h24 = 0, h34 = 0;\n        outputDistances(h12, h13, h14, h23, h24, h34);\n\n    } else if (type == \"edge_case2\") {\n        // Random distances, possibly inconsistent\n        int h12 = rnd.next(0, 100000);\n        int h13 = rnd.next(0, 100000);\n        int h14 = rnd.next(0, 100000);\n        int h23 = rnd.next(0, 100000);\n        int h24 = rnd.next(0, 100000);\n        int h34 = rnd.next(0, 100000);\n        if (h12 == 0 && h13 == 0 && h14 == 0 && h23 == 0 && h24 == 0 && h34 == 0) {\n            h12 = 1; // Ensure at least one positive value\n        }\n        outputDistances(h12, h13, h14, h23, h24, h34);\n\n    } else {\n        // Default: Generate valid random test case\n        if (len == -1) {\n            len = rnd.next(1, 100000); // Random length between 1 and 1e5\n        }\n        vector<string> s(4);\n        for (int i = 0; i < 4; ++i) {\n            s[i].resize(len);\n            for (int j = 0; j < len; ++j) {\n                s[i][j] = rnd.next(0, 1) ? 'a' : 'b';\n            }\n        }\n        // Compute Hamming distances\n        int h12 = 0, h13 = 0, h14 = 0, h23 = 0, h24 = 0, h34 = 0;\n        for (int k = 0; k < len; ++k) {\n            if (s[0][k] != s[1][k]) h12++;\n            if (s[0][k] != s[2][k]) h13++;\n            if (s[0][k] != s[3][k]) h14++;\n            if (s[1][k] != s[2][k]) h23++;\n            if (s[1][k] != s[3][k]) h24++;\n            if (s[2][k] != s[3][k]) h34++;\n        }\n        outputDistances(h12, h13, h14, h23, h24, h34);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid outputDistances(int h12, int h13, int h14, int h23, int h24, int h34) {\n    printf(\"%d %d %d\\n\", h12, h13, h14);\n    printf(\"%d %d\\n\", h23, h24);\n    printf(\"%d\\n\", h34);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n    int len = opt<int>(\"len\", -1); // Length of the strings\n\n    if (type == \"valid_random\") {\n        // Generate valid random strings\n        if (len == -1) {\n            len = rnd.next(1, 100000); // Random length between 1 and 1e5\n        }\n        vector<string> s(4);\n        for (int i = 0; i < 4; ++i) {\n            s[i].resize(len);\n            for (int j = 0; j < len; ++j) {\n                s[i][j] = rnd.next(0, 1) ? 'a' : 'b';\n            }\n        }\n        // Compute Hamming distances\n        int h12 = 0, h13 = 0, h14 = 0, h23 = 0, h24 = 0, h34 = 0;\n        for (int k = 0; k < len; ++k) {\n            if (s[0][k] != s[1][k]) h12++;\n            if (s[0][k] != s[2][k]) h13++;\n            if (s[0][k] != s[3][k]) h14++;\n            if (s[1][k] != s[2][k]) h23++;\n            if (s[1][k] != s[3][k]) h24++;\n            if (s[2][k] != s[3][k]) h34++;\n        }\n        outputDistances(h12, h13, h14, h23, h24, h34);\n\n    } else if (type == \"no_solution\") {\n        // Generate distances that cannot be realized\n        int h12 = 0, h13 = 1, h14 = 2, h23 = 3, h24 = 4, h34 = 5;\n        outputDistances(h12, h13, h14, h23, h24, h34);\n\n    } else if (type == \"identical_strings\") {\n        // Generate distances where most pairs are identical\n        if (len == -1) {\n            len = rnd.next(1, 10); // Random length between 1 and 10\n        }\n        int h12 = 0, h13 = 0, h14 = 0, h23 = 0, h24 = 0, h34 = 1; // At least one distance > 0\n        outputDistances(h12, h13, h14, h23, h24, h34);\n\n    } else if (type == \"max_distances\") {\n        // All distances equal to the length of the strings\n        if (len == -1) {\n            len = rnd.next(1, 100000);\n        }\n        int h12 = len, h13 = len, h14 = len, h23 = len, h24 = len, h34 = len;\n        outputDistances(h12, h13, h14, h23, h24, h34);\n\n    } else if (type == \"edge_case1\") {\n        // Maximum Hamming distance between two strings, others are zero\n        if (len == -1) {\n            len = rnd.next(1, 100000);\n        }\n        int h12 = len, h13 = 0, h14 = 0, h23 = 0, h24 = 0, h34 = 0;\n        outputDistances(h12, h13, h14, h23, h24, h34);\n\n    } else if (type == \"edge_case2\") {\n        // Random distances, possibly inconsistent\n        int h12 = rnd.next(0, 100000);\n        int h13 = rnd.next(0, 100000);\n        int h14 = rnd.next(0, 100000);\n        int h23 = rnd.next(0, 100000);\n        int h24 = rnd.next(0, 100000);\n        int h34 = rnd.next(0, 100000);\n        if (h12 == 0 && h13 == 0 && h14 == 0 && h23 == 0 && h24 == 0 && h34 == 0) {\n            h12 = 1; // Ensure at least one positive value\n        }\n        outputDistances(h12, h13, h14, h23, h24, h34);\n\n    } else {\n        // Default: Generate valid random test case\n        if (len == -1) {\n            len = rnd.next(1, 100000); // Random length between 1 and 1e5\n        }\n        vector<string> s(4);\n        for (int i = 0; i < 4; ++i) {\n            s[i].resize(len);\n            for (int j = 0; j < len; ++j) {\n                s[i][j] = rnd.next(0, 1) ? 'a' : 'b';\n            }\n        }\n        // Compute Hamming distances\n        int h12 = 0, h13 = 0, h14 = 0, h23 = 0, h24 = 0, h34 = 0;\n        for (int k = 0; k < len; ++k) {\n            if (s[0][k] != s[1][k]) h12++;\n            if (s[0][k] != s[2][k]) h13++;\n            if (s[0][k] != s[3][k]) h14++;\n            if (s[1][k] != s[2][k]) h23++;\n            if (s[1][k] != s[3][k]) h24++;\n            if (s[2][k] != s[3][k]) h34++;\n        }\n        outputDistances(h12, h13, h14, h23, h24, h34);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type valid_random -len 10\n./gen -type valid_random -len 1000\n./gen -type valid_random -len 100000\n\n./gen -type valid_random\n\n./gen -type no_solution\n\n./gen -type identical_strings -len 1\n./gen -type identical_strings -len 2\n\n./gen -type max_distances -len 5\n./gen -type max_distances -len 100000\n\n./gen -type edge_case1 -len 10\n./gen -type edge_case1 -len 1000\n\n./gen -type edge_case2\n\n# Generate random test cases with random lengths\n./gen -type valid_random\n./gen -type valid_random\n./gen -type valid_random\n\n# Generate no solution cases\n./gen -type no_solution\n./gen -type no_solution\n./gen -type no_solution\n\n# Generate edge cases\n./gen -type edge_case1 -len 1\n./gen -type edge_case1 -len 100000\n\n./gen -type edge_case2\n./gen -type edge_case2\n\n# Generate maximum length test cases\n./gen -type valid_random -len 100000\n./gen -type max_distances -len 100000\n\n# Generate minimal length test cases\n./gen -type valid_random -len 1\n./gen -type valid_random -len 2\n\n# Generate test cases of medium size\n./gen -type valid_random -len 100\n./gen -type valid_random -len 5000\n./gen -type valid_random -len 20000\n\n# Generate more 'no_solution' cases\n./gen -type no_solution\n./gen -type no_solution\n\n# Generate more 'identical_strings' cases\n./gen -type identical_strings\n./gen -type identical_strings -len 5\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:35.993485",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "193/D",
      "title": "D. Два отрезка",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест5 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 3·105) — размер перестановки. Во второй строке через пробел записано n различных целых чисел pi, (1 ≤ pi ≤ n).",
      "output_spec": "Выходные данныеВыведите единственное число — количество хороших пар отрезков перестановки p.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать31 2 3Выходные данныеСкопировать3Входные данныеСкопировать51 4 5 3 2Выходные данныеСкопировать10Входные данныеСкопировать55 4 3 1 2Выходные данныеСкопировать10",
      "description": "D. Два отрезка\n\nограничение по времени на тест5 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 3·105) — размер перестановки. Во второй строке через пробел записано n различных целых чисел pi, (1 ≤ pi ≤ n).\n\nВходные данные\n\nВыходные данныеВыведите единственное число — количество хороших пар отрезков перестановки p.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать31 2 3Выходные данныеСкопировать3Входные данныеСкопировать51 4 5 3 2Выходные данныеСкопировать10Входные данныеСкопировать55 4 3 1 2Выходные данныеСкопировать10\n\nВходные данныеСкопировать31 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать51 4 5 3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать55 4 3 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечание В первом примере подходят следующие пары отрезков: ([1, 1], [2, 2]); ([2, 2], [3, 3]); ([1, 2], [3, 3]). Пара отрезков ([1, 1], [2, 3]), по определению, эквивалентна паре ([1, 2], [3, 3]), так как обе эти пары соответствуют множеству элементов {1, 2, 3}.В третьем примере подходят следующие пары отрезков: ([4, 4], [5, 5]); ([3, 3],[4, 5]); ([2, 2],[3, 5]); ([1, 1],[2, 5]); ([3, 3],[5, 5]); ([2, 3],[5, 5]); ([1, 3],[5, 5]); ([2, 2],[3, 3]); ([1, 1],[2, 3]); ([1, 1],[2, 2]).",
      "solutions": [
        {
          "title": "Codeforces Round #122 - Codeforces",
          "content": "Привет всем! Я автор задач сегодняшнего раунда. Меня зовут Артур, я учусь в лицее №31 города Челябинска. Благодарю Gerald за координацию подготовки контеста, Delinur за перевод условий, MikeMirzayanov за замечательную систему, dolphinigle за прорешивание контеста, вычитывание условий и множество ценных советов, fdoer, grey_wind, Skird и alger95 за помощь в придумывании задач. Пока ничего практически полезного сказать не могу. Как вы, надеюсь, догадались, контест пройдет в каждом дивизионе отдельно. Система подсчета очков будет стандартная, разбалловка, скорее всего, нестандартная, пока не знаю, какая именно, ближе к делу напишу.Объемных фабул и историй не будет. Надеюсь, что контест и задачи вам понравятся и все пройдет гладко. UPD: Разбалловка следующая:В первом дивизионе: 500-1000-2000-2000-2500.Во втором дивизионе: 500-1000-1500-2000-3000.UPD2: появился разбор Пока частичный и на русском. скоро будет больше.Поздравляю победителей, особенно решивших задачу D.Div1: Petr tourist yeputons peter50216 aram90 Div2: lucien tomasz.kociumaka sjynoi DimaPhil",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4671",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1066
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces",
          "content": "Пожалуйста, задавайте возникающие у вас вопросы по задачам. Особенно это касается задачи D, так как она оказалась наиболее сложной.Задача <<Экзамены>> По условию 2n ≤ k ≤ 5n. Если k < 3n то некоторые экзамены мы сможем сдать только на 2. Таких будет 3n - k. Если же 3n ≤ k, то мы все экзамены сдадим как минимум на три.Задача <<Квадрат>> Пусть карандаш идет по прямой и ставит крестики через каждые (n + 1) точку. Поставим в соответствие положению на прямой положение на квадрате. А именно, точке x на прямой будет соответствовать точка, в которую придет карандаш, сдвинувшись по периметру квадрата на x. Тогда левому нижнему углу квадрата соответствуют все точки вида 4np для некоторого целого неотрицательного p. Поставленным крестиками будут соответствовать точки k(n + 1). Самая ближайшая точка совпадения двух семейств, за исключением начальной, будет в LCM(n + 1, 4n) (LCM — НОК). Тогда всего мы поставим крестиков.Задача <<Разрезание фигуры>>Основная идея: учитывая, что ответ не превышает двух, проверим существование ответа 1.Докажем, что ответ в задаче не превосходит двух. Пусть площадь фигуры не менее 4. Тогда рассмотрим самую левую из самых верхних клеток. У нее нет левого и верхнего соседей по стороне. Значит, у нее не будет более двух соседей. Тогда, удалив ее соседей мы уже разделим фигуру на две. Если площадь равна трем, то всегда можно разрезать ее, удалив одну клетку, это можно проверить, так как существует всего два принципиальных случая. Если площадь фигуры не превышает двух, то какое бы множество клеток мы не удалили, она не распадется. Проверим, существует ли ответ, величины один. Удаляемую клетку можно просто перебрать, а затем запустить dfs из любой неудаленной клетки. Если dfs посетит не все оставшиеся клетки, то, удалив нужную клетку мы разрежем фигуру. Если подходящая клетка нашлась — ответ равен 1. Если нет — 2. Еще нужно было не забыть, что иногда ответа может просто не существовать. Это бывает тогда, когда площадь фигуры меньше либо равна двум (площадь фигуры — кол-во клеток в ней)юАсимптотика решения O(n4). Еще можно было воспользоваться алгоритмом поиска точек сочленения и решить эту задачу за O(n2). Но это, наверное, требовало больших трудозатрат.Задача <>Основная идея: перебор за O(Fun). Fu — u-е число Фибоначчи.У этой задачи было довольно сложное условие. С массивом a можно было проводить операции двух типов. Нужно было провести ровно u таких операций, чтобы максимизировать сумму значений массива с заданными коэффициентами.Если просто перебрать все возможные комбинации операций, а потом промоделировать их, то получится решение за O(2u·nu). Это слишом долго. Можно было улучшить это решение, перебирая комбинации операций рекурсивно и по ходу рекурсии моделируя их. Тогда асимптотика улучшается до O(2u·n). Собственно, ничего сильно лучше этого решения не требовалось. Возникает лишь одно соображение: если у нас были две операции подряд, то они ничего не изменили и их можно переместить в любое место нашего алгоритма, не изменив его результат. Тогда можно перебирать только те алгоритмы, в которых все парные операции стоят в конце. Это тоже можно было делать рекурсивно, не идя в ветки с двумя, подряд идущими операциями и обновляя лучший ответ не только в конце рекурсии, но и тогда, когда в конце осталось четное число операций. Это работает сильно лучше. Вспомнив известную задачу \"кол-во последовательностей из нулей и единиц, без двух единиц подряд\" можно понять, что кол-во таких последовательностей, длиной k, равно Fk + 1, где Fi — i-е число Фибоначчи. Тогда кол-во допустимых алгоритмов равно сумме первых u чисел Фибоначчи. Эта сумма примерно равна (u + 2)-му чмслу Фибоначчи. Итоговая асимптотика составляет O(Fu·n). Для максимальных значений входных данных эта величина равна примерно 30 миллионам. Мне не удалось написать на эту задачу отжиг или какое-либо рандом-решение, которое проходило бы все или хотя бы большинство тестов. Задача <<Расстояние Хемминга>>Основная идея: сведение к СЛАУ и решение ее методом Гаусса.Заметим, что если мы одинаковым образом переставим символы во всех строках, то ответ не изменится. Рассмотрим <<столбцы>> ответа, то есть строки s1, i + s2, i + s3, i + s4, i для некоторого i. Всего существует 24 = 16 типов таких строк. Получается, что, если существует ответ на задачу, длины l, то существует и ответ той же длины в котором столбцы упорядочены по типу. Тогда, чтобы перебрать ответ, достаточно перебрать 16 чисел — количества столбцов каждого типа. По этим числам легко восстановить все расстояния Хемминга. Расстояние между строками si и sj будет равно сумме количеств столбцов в которых различны символы c номерами i и j. Однако перебирать все возможные количества столбцов каждого типа слишком долго. Заметим, что мы можем записать систему из 6 уравнений с 16 неизвестными (вспомнив, что расстояние между строками si и sj будет равно сумме количеств столбцов в которых различны символы c номерами i и j). Неизвестными в этой системе уравнений будут количества столбцов каждого из типов. Заметим, что некоторые варианты столбцов полностью идентичны с точки зрения вклада, вносимого в расстояния Хемминга. А именно, столбцы, получаемые друг из друга инвертированием всех букв (заменой <> на <> и наоборот) вносят идентичный вклад в расстояния Хемминга. Например, если добавить в ответ столбец <>, расстояния Хемминга между всеми парами строк изменятся тем же образом, что и при добавлении столбца <>. Получается, что мы можем рассматривать лишь 8 возможных столбцов. Кроме того, столбцы <> и <> вносят нулевой вклад во все расстояния Хемминга. Один из них мы уже исключили из рассмотрения, но можно исключить и второй. Таким образом, мы сократили количество переменных до 7. Решим СЛАУ относительно каких-нибудь шести переменных. Свободным осталось значение одной из переменных. Так как столбцы, количеству которых соответствует эта переменная, вносят ненулевой вклад хотя бы в одно расстояние Хемминга, значение этой переменной не может превосходить максимума из заданных расстояний Хемминга. Тогда можно перебрать его и выбрать наилучший из получившихся ответов.Алгоритм получается следующий: Для каждого типа столбцов определим, какой вклад один такой столбец вносит в каждое из расстояний Хемминга Запустим алгоритм Гаусса для полученной матрицы Переберем значение свободной переменной, выразим через нее остальные, проверим, что все они неотрицательны и целы, выберем наилучший из ответов. Выведем ответ. Асимптотика этого решения составляла O(max(di, j)), если пользоваться типом double и , если решать задачу в рациональных числах.Наверное, могло показаться, что при решении в рациональных числах могло быть переполнение. Но, так как мы применяем наш алгоритм к одной и той же матрице (за исключением последнего столбца), наши вычисления всегда одинаковы, то есть мы домножаем строки на одни и те же числа. Можно заметить, что в нашей матрице все числа будут единицами или двойками, тогда никакой коэффициент в итоге не превысит . Таким образом, можно решать задачу в рациональных числах или в типе double.Задача <<Два отрезка>>Основная идея: обратить перестановку и решать упрощенную задачу (см. ниже), рассмотреть функцию <<количество отрезков в перестановке, которые образуют данный отрезок натурального ряда>>.Чтобы решить эту задачу, можно решить обратную: <<дана перестановка pn, нужно посчитать в них количество отрезков, элементы которых образуют 1 или 2 отрезка натурального ряда>>. Если мы решим эту задачу для некоторой перестановки qn, такой, что , то мы получим ответ для исходной задачи и перестановки.Первое решение, которое приходит в голову: переберем отрезок перестановки и в булевом массиве отметим элементы, принадлежащие ему. Проверим, что в булевском массиве получилось два отрезка. Такое решение будет иметь асимптотику O(n3). После некоторых размышлений можно понять, что при переходе от отрезка пере [l, r] к [l, r + 1] количество отрезков изменится некоторым предсказуемым образом. Обозначим s([a, b]) количество отрезков, которые образуют элементы отрезка [a, b] перестановки. Если новый элемент pr + 1 будет находиться между уже поставленными элементами (то есть, элементы со значениями pr + 1 - 1 и pr + 1 + 1 будут принадлежать отрезку [l, r]), то s([l, r + 1]) = s([l, r]) - 1. Новый элемент <<склеит>> два отрезка между которыми появится. Если у элемента pr + 1 будет один сосед, принадлежащий отрезку [l, r], то s([l, r]) = s([l, r + 1]) (один из существующих отрезков удлинится). Если же у элемента pr + 1 не будет соседей на отрезке [l, r], то новый элемент образует новый отрезок и s([l, r + 1]) = s([l, r]) + 1. Это иллюстрирует рисунок ниже:Новый элемент помечен красным, уже поставленные — черным. Из этих соображений можно получить следующее решение: переберем левую границу и, перебирая правую слева направо, будем пересчитывать количество отрезков, которые образует текущий отрезок перестановки. Если это число равно 1 или 2, прибавим к ответу единицу. Получаем асимптотику O(n2). Это решение работало достаточно быстро даже на n = 20000. Но, разумеется, этого было недостаточно, чтобы решить задачу. Перейдем к полному решению. Оно основывается на предыдущем. Мы уже умеем пересчитывать число отрезков при движении правой границы. Теперь нужно понять, как найти s([l - 1, r]) для любых r, используя s([l, r]). Будем перебирать позицию левой границы отрезков справа налево и поддерживать структуру данных, которая позволит нам хранить s([l, r]) для всех r и сможет считать в себе количество чисел 1 и 2. Обозначим за Δi s([l - 1, i]) - s([l, i]). Δl = 1 так как один элемент образует ровно 1 отрезок. Далее, если мы будем увеличивать i, Δi будет зависеть от количества соседей элемента l на отрезке [l - 1, i]. Если на отрезке нет соседей l, то количество отрезков, которым он соответствует увеличится на 1 при добавлении элемента l (так как l не присоединится ни к какому существующему отрезку). Если на отрезке ровно один сосед l, то количество отрезков, которым он соответствует не изменится при его добавлении (так как l просто присоединится к отрезку своего соседа). Если на отрезке два соседа l, то при его добавлении, количество образуемых отрезков уменьшится на 1. Найдем соседей l, лежащих после него. Обозначим их за a и b. (если после l лежит только один его сосед, b = inf) тогда для всех i, таких что l ≤ i < a Δi = 1. Для всех i, таких что a ≤ i < b Δi = 0 и для всех i удовлетворяющих b ≤ i ≤ n Δi =  - 1. Тогда, чтобы обновить нашу структуру достаточно сделать два прибавления на отрезке. На картинке выше видно, что у элемента 5 оба соседа лежат правее его. Поэтому получается три отрезка эквивалентности Δi (первый из них находится в самом элементе 5). После первого встреченного соседа (4) Δi принимает значение 0 и, наконец, начиная с соседа 6, Δi принимают значение  - 1.Остается только придумать структуру, позволяющую прибавлять на отрезке +1 и -1 и искать в семе числа 1 и 2. Во-первых, заметим, что неположительных чисел структура хранить не будет. Тогда числа 1 и 2 будут являться первым или вторым минимумом в структуре. Тогда структуре достаточно уметь искать два минимума в себе и уметь прибавлять +1 и -1 на отрезке. Два минимума ищутся почти так же, как и один, поэтому можно адаптировать дерево отрезков или sqrt-декомпозицию под эти цели. Сумма ответов структуры на каждой итерации будет ответом на задачу. Авторская sqrt-декомпозиция работала 1.3 секунды, авторское дерево отрезков — 1.1 секунды. sqrt-декомпозиция на Java — 3.6 секунд.Задача <<Число Фибоначчи>>Решение: baby-step-giant-stepВ этой задаче было дано некоторое число Фибоначчи f по модулю 1013, требовалось определить его первое вхождение в последовательность (позицию). Рассмотрим два взаимно простых модуля, делящих 1013. Пометим их как a и b. Остаток от деления f на a будет равен остатку от деления настоящего числа Фибоначчи F, такого, что . (). Найдем вхождения в период последовательности Фибоначчи по модулю a. Найдем вхождения в период последовательности Фибоначчи по модулю b. Зафиксируем пару этих вхождений. Пусть вхождение в последовательность Фибоначчи по модулю a будет в позиции i, а по модулю b — в позиции j. Обозначим за t(m) период последовательности Фибоначчи по модулю m. Из Китайской Теоремы об Остатках следует, что t(ab) = LCM(t(a), t(b)) (так как a и b выбраны взаимно простыми). Тогда по зафиксированным вхождениям f по модулям a и b можно восстановить вхождение f в последовательность по модулю ab. Это можно сделать, решив Диофантово уравнение i + t(a)·x = j + t(b)·y. Это уравнение можно решить перебором одного из корней. Если найденное вхождение в последовательность по модулю ab обозначить за u, то все вхождения f в последовательность по модулю 1013 будут представимы в виде t(ab)·k + u. Тогда переберем k и найдем все вхождения f в последовательность Фибоначчи по модулю 1013. Чтобы получить из числа Фибоначчи на позиции α, чиcло Фибоначчи на позиции α + t(ab) нужно домножить вектор из Fα и Fα + 1 на некоторую матрицу. Выберем a = 59 и b = 213. Заметим, что никакое число не входит в период последовательности Фибоначчи по каждому из этих модулей более 8 раз. Тогда пар вхождений будет не более 64. Для каждого вхождения мы переберем до чисел. Еще можно было более эффективно воспользоваться тем, что число вхождений любого числа в период последовательности Фибоначчи по модулям вроде 10k невелико. Можно было получать из вхождений числа f в последовательность по модулю 10i получить вхождения по модулю 10(i + 1) подобно тому, как в авторском решении осуществляется переход от модуля ab к модулю 1013.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4673",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 13504
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #122 - Codeforces - Code 1",
          "code": ".##\n###\n##.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 2",
          "code": ".##\n###\n##.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 3",
          "code": "####\n##.#\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 4",
          "code": "####\n##.#\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 5",
          "code": "<--p--><-q-><---r---><--t-->\naaaaaaaaaaaaaaaaaaaaaaaaaaaa\nbbbbbbbbbbbbaaaaaaaaaaaaaaaa\naaaaaaabbbbbbbbbbbbbbaaaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 6",
          "code": "<--p--><-q-><---r---><--t-->\naaaaaaaaaaaaaaaaaaaaaaaaaaaa\nbbbbbbbbbbbbaaaaaaaaaaaaaaaa\naaaaaaabbbbbbbbbbbbbbaaaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 7",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 8",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 9",
          "code": "3 3\n...\n.#.\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 10",
          "code": "3 3\n...\n.#.\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces - Code 1",
          "code": "if ((a + 1) mod 4 = 0) then\n        writeln(a + 1)\n      else\n        if ((a + 1) mod 2 = 0) then\n          writeln(2 * a + 1)\n        else\n          writeln(4 * a + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4673",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces - Code 2",
          "code": "if ((a + 1) mod 4 = 0) then\n        writeln(a + 1)\n      else\n        if ((a + 1) mod 2 = 0) then\n          writeln(2 * a + 1)\n        else\n          writeln(4 * a + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4673",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces - Code 3",
          "code": "![ ](<тот самый URL>)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4673",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and ensure it is within [1, 300000]\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n\n    // Read n integers p_i, each within [1, n]\n    vector<int> p = inf.readInts(n, 1, n, \"p_i\");\n    inf.readEoln();\n\n    // Ensure that all p_i are distinct\n    set<int> s(p.begin(), p.end());\n    ensuref((int)s.size() == n, \"All p_i must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and ensure it is within [1, 300000]\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n\n    // Read n integers p_i, each within [1, n]\n    vector<int> p = inf.readInts(n, 1, n, \"p_i\");\n    inf.readEoln();\n\n    // Ensure that all p_i are distinct\n    set<int> s(p.begin(), p.end());\n    ensuref((int)s.size() == n, \"All p_i must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and ensure it is within [1, 300000]\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n\n    // Read n integers p_i, each within [1, n]\n    vector<int> p = inf.readInts(n, 1, n, \"p_i\");\n    inf.readEoln();\n\n    // Ensure that all p_i are distinct\n    set<int> s(p.begin(), p.end());\n    ensuref((int)s.size() == n, \"All p_i must be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 0);\n\n    vector<int> p(n);\n    for(int i = 0; i < n; ++i)\n        p[i] = i + 1;\n\n    if (type == \"sorted\") {\n        // Do nothing, p is already sorted\n    } else if (type == \"reversed\") {\n        reverse(p.begin(), p.end());\n    } else if (type == \"random\") {\n        shuffle(p.begin(), p.end());\n    } else if (type == \"almost_sorted\") {\n        int swaps = max(1, n / 10);\n        for(int i = 0; i < swaps; ++i) {\n            int a = rnd.next(0, n-1);\n            int b = rnd.next(0, n-1);\n            swap(p[a], p[b]);\n        }\n    } else if (type == \"blocks\") {\n        if (k == 0) k = max(1, n / 100); // default block size\n        int num_blocks = (n + k -1) / k;\n        vector<vector<int>> blocks(num_blocks);\n        int idx = 0;\n        for(int i = 0; i < num_blocks; ++i) {\n            int block_size = min(k, n - idx);\n            blocks[i].resize(block_size);\n            for(int j = 0; j < block_size; ++j)\n                blocks[i][j] = idx + 1 + j;\n            idx += block_size;\n        }\n        shuffle(blocks.begin(), blocks.end());\n        idx = 0;\n        for(auto& block : blocks) {\n            for(auto val : block) {\n                p[idx++] = val;\n            }\n        }\n    } else {\n        // default to random\n        shuffle(p.begin(), p.end());\n    }\n\n    // output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", p[i], \" \\n\"[i+1==n]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 0);\n\n    vector<int> p(n);\n    for(int i = 0; i < n; ++i)\n        p[i] = i + 1;\n\n    if (type == \"sorted\") {\n        // Do nothing, p is already sorted\n    } else if (type == \"reversed\") {\n        reverse(p.begin(), p.end());\n    } else if (type == \"random\") {\n        shuffle(p.begin(), p.end());\n    } else if (type == \"almost_sorted\") {\n        int swaps = max(1, n / 10);\n        for(int i = 0; i < swaps; ++i) {\n            int a = rnd.next(0, n-1);\n            int b = rnd.next(0, n-1);\n            swap(p[a], p[b]);\n        }\n    } else if (type == \"blocks\") {\n        if (k == 0) k = max(1, n / 100); // default block size\n        int num_blocks = (n + k -1) / k;\n        vector<vector<int>> blocks(num_blocks);\n        int idx = 0;\n        for(int i = 0; i < num_blocks; ++i) {\n            int block_size = min(k, n - idx);\n            blocks[i].resize(block_size);\n            for(int j = 0; j < block_size; ++j)\n                blocks[i][j] = idx + 1 + j;\n            idx += block_size;\n        }\n        shuffle(blocks.begin(), blocks.end());\n        idx = 0;\n        for(auto& block : blocks) {\n            for(auto val : block) {\n                p[idx++] = val;\n            }\n        }\n    } else {\n        // default to random\n        shuffle(p.begin(), p.end());\n    }\n\n    // output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", p[i], \" \\n\"[i+1==n]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type sorted\n./gen -n 1 -type reversed\n./gen -n 1 -type random\n\n./gen -n 2 -type sorted\n./gen -n 2 -type reversed\n./gen -n 2 -type random\n\n./gen -n 10 -type sorted\n./gen -n 10 -type reversed\n./gen -n 10 -type random\n./gen -n 10 -type almost_sorted\n./gen -n 10 -type blocks -k 2\n\n./gen -n 50 -type sorted\n./gen -n 50 -type reversed\n./gen -n 50 -type random\n./gen -n 50 -type almost_sorted\n./gen -n 50 -type blocks -k 5\n\n./gen -n 1000 -type sorted\n./gen -n 1000 -type reversed\n./gen -n 1000 -type random\n./gen -n 1000 -type almost_sorted\n./gen -n 1000 -type blocks -k 50\n\n./gen -n 10000 -type sorted\n./gen -n 10000 -type reversed\n./gen -n 10000 -type random\n./gen -n 10000 -type almost_sorted\n./gen -n 10000 -type blocks -k 200\n\n./gen -n 100000 -type sorted\n./gen -n 100000 -type reversed\n./gen -n 100000 -type random\n./gen -n 100000 -type almost_sorted\n./gen -n 100000 -type blocks -k 5000\n\n./gen -n 300000 -type sorted\n./gen -n 300000 -type reversed\n./gen -n 300000 -type random\n./gen -n 300000 -type almost_sorted\n./gen -n 300000 -type blocks -k 10000\n\n./gen -n 300000 -type blocks -k 1\n./gen -n 300000 -type blocks -k 2\n./gen -n 300000 -type blocks -k 5\n./gen -n 300000 -type blocks -k 10\n./gen -n 300000 -type blocks -k 100\n./gen -n 300000 -type blocks -k 1000\n./gen -n 300000 -type blocks -k 10000\n./gen -n 300000 -type blocks -k 100000\n./gen -n 300000 -type blocks -k 200000\n./gen -n 300000 -type blocks -k 300000\n\n./gen -n 299999 -type blocks -k 2\n\n./gen -n 299999 -type blocks -k 3\n\n./gen -n 300000 -type almost_sorted\n./gen -n 300000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:38.245977",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "193/E",
      "title": "E. Число Фибоначчи",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано единственное целое число f (0 ≤ f < 1013) — число, позицию которого в списке нужно найти.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "output_spec": "Выходные данныеВыведите единственное число — номер первого вхождения заданного числа в список Джона или -1, если это число не входит в список Джона.",
      "sample_tests": "ПримерыВходные данныеСкопировать13Выходные данныеСкопировать7Входные данныеСкопировать377Выходные данныеСкопировать14",
      "description": "E. Число Фибоначчи\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано единственное целое число f (0 ≤ f < 1013) — число, позицию которого в списке нужно найти.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — номер первого вхождения заданного числа в список Джона или -1, если это число не входит в список Джона.\n\nВыходные данные\n\nВходные данныеСкопировать13Выходные данныеСкопировать7Входные данныеСкопировать377Выходные данныеСкопировать14\n\nВходные данныеСкопировать13\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать7\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать377\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать14\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #122 - Codeforces",
          "content": "Привет всем! Я автор задач сегодняшнего раунда. Меня зовут Артур, я учусь в лицее №31 города Челябинска. Благодарю Gerald за координацию подготовки контеста, Delinur за перевод условий, MikeMirzayanov за замечательную систему, dolphinigle за прорешивание контеста, вычитывание условий и множество ценных советов, fdoer, grey_wind, Skird и alger95 за помощь в придумывании задач. Пока ничего практически полезного сказать не могу. Как вы, надеюсь, догадались, контест пройдет в каждом дивизионе отдельно. Система подсчета очков будет стандартная, разбалловка, скорее всего, нестандартная, пока не знаю, какая именно, ближе к делу напишу.Объемных фабул и историй не будет. Надеюсь, что контест и задачи вам понравятся и все пройдет гладко. UPD: Разбалловка следующая:В первом дивизионе: 500-1000-2000-2000-2500.Во втором дивизионе: 500-1000-1500-2000-3000.UPD2: появился разбор Пока частичный и на русском. скоро будет больше.Поздравляю победителей, особенно решивших задачу D.Div1: Petr tourist yeputons peter50216 aram90 Div2: lucien tomasz.kociumaka sjynoi DimaPhil",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4671",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1066
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces",
          "content": "Пожалуйста, задавайте возникающие у вас вопросы по задачам. Особенно это касается задачи D, так как она оказалась наиболее сложной.Задача <<Экзамены>> По условию 2n ≤ k ≤ 5n. Если k < 3n то некоторые экзамены мы сможем сдать только на 2. Таких будет 3n - k. Если же 3n ≤ k, то мы все экзамены сдадим как минимум на три.Задача <<Квадрат>> Пусть карандаш идет по прямой и ставит крестики через каждые (n + 1) точку. Поставим в соответствие положению на прямой положение на квадрате. А именно, точке x на прямой будет соответствовать точка, в которую придет карандаш, сдвинувшись по периметру квадрата на x. Тогда левому нижнему углу квадрата соответствуют все точки вида 4np для некоторого целого неотрицательного p. Поставленным крестиками будут соответствовать точки k(n + 1). Самая ближайшая точка совпадения двух семейств, за исключением начальной, будет в LCM(n + 1, 4n) (LCM — НОК). Тогда всего мы поставим крестиков.Задача <<Разрезание фигуры>>Основная идея: учитывая, что ответ не превышает двух, проверим существование ответа 1.Докажем, что ответ в задаче не превосходит двух. Пусть площадь фигуры не менее 4. Тогда рассмотрим самую левую из самых верхних клеток. У нее нет левого и верхнего соседей по стороне. Значит, у нее не будет более двух соседей. Тогда, удалив ее соседей мы уже разделим фигуру на две. Если площадь равна трем, то всегда можно разрезать ее, удалив одну клетку, это можно проверить, так как существует всего два принципиальных случая. Если площадь фигуры не превышает двух, то какое бы множество клеток мы не удалили, она не распадется. Проверим, существует ли ответ, величины один. Удаляемую клетку можно просто перебрать, а затем запустить dfs из любой неудаленной клетки. Если dfs посетит не все оставшиеся клетки, то, удалив нужную клетку мы разрежем фигуру. Если подходящая клетка нашлась — ответ равен 1. Если нет — 2. Еще нужно было не забыть, что иногда ответа может просто не существовать. Это бывает тогда, когда площадь фигуры меньше либо равна двум (площадь фигуры — кол-во клеток в ней)юАсимптотика решения O(n4). Еще можно было воспользоваться алгоритмом поиска точек сочленения и решить эту задачу за O(n2). Но это, наверное, требовало больших трудозатрат.Задача <>Основная идея: перебор за O(Fun). Fu — u-е число Фибоначчи.У этой задачи было довольно сложное условие. С массивом a можно было проводить операции двух типов. Нужно было провести ровно u таких операций, чтобы максимизировать сумму значений массива с заданными коэффициентами.Если просто перебрать все возможные комбинации операций, а потом промоделировать их, то получится решение за O(2u·nu). Это слишом долго. Можно было улучшить это решение, перебирая комбинации операций рекурсивно и по ходу рекурсии моделируя их. Тогда асимптотика улучшается до O(2u·n). Собственно, ничего сильно лучше этого решения не требовалось. Возникает лишь одно соображение: если у нас были две операции подряд, то они ничего не изменили и их можно переместить в любое место нашего алгоритма, не изменив его результат. Тогда можно перебирать только те алгоритмы, в которых все парные операции стоят в конце. Это тоже можно было делать рекурсивно, не идя в ветки с двумя, подряд идущими операциями и обновляя лучший ответ не только в конце рекурсии, но и тогда, когда в конце осталось четное число операций. Это работает сильно лучше. Вспомнив известную задачу \"кол-во последовательностей из нулей и единиц, без двух единиц подряд\" можно понять, что кол-во таких последовательностей, длиной k, равно Fk + 1, где Fi — i-е число Фибоначчи. Тогда кол-во допустимых алгоритмов равно сумме первых u чисел Фибоначчи. Эта сумма примерно равна (u + 2)-му чмслу Фибоначчи. Итоговая асимптотика составляет O(Fu·n). Для максимальных значений входных данных эта величина равна примерно 30 миллионам. Мне не удалось написать на эту задачу отжиг или какое-либо рандом-решение, которое проходило бы все или хотя бы большинство тестов. Задача <<Расстояние Хемминга>>Основная идея: сведение к СЛАУ и решение ее методом Гаусса.Заметим, что если мы одинаковым образом переставим символы во всех строках, то ответ не изменится. Рассмотрим <<столбцы>> ответа, то есть строки s1, i + s2, i + s3, i + s4, i для некоторого i. Всего существует 24 = 16 типов таких строк. Получается, что, если существует ответ на задачу, длины l, то существует и ответ той же длины в котором столбцы упорядочены по типу. Тогда, чтобы перебрать ответ, достаточно перебрать 16 чисел — количества столбцов каждого типа. По этим числам легко восстановить все расстояния Хемминга. Расстояние между строками si и sj будет равно сумме количеств столбцов в которых различны символы c номерами i и j. Однако перебирать все возможные количества столбцов каждого типа слишком долго. Заметим, что мы можем записать систему из 6 уравнений с 16 неизвестными (вспомнив, что расстояние между строками si и sj будет равно сумме количеств столбцов в которых различны символы c номерами i и j). Неизвестными в этой системе уравнений будут количества столбцов каждого из типов. Заметим, что некоторые варианты столбцов полностью идентичны с точки зрения вклада, вносимого в расстояния Хемминга. А именно, столбцы, получаемые друг из друга инвертированием всех букв (заменой <> на <> и наоборот) вносят идентичный вклад в расстояния Хемминга. Например, если добавить в ответ столбец <>, расстояния Хемминга между всеми парами строк изменятся тем же образом, что и при добавлении столбца <>. Получается, что мы можем рассматривать лишь 8 возможных столбцов. Кроме того, столбцы <> и <> вносят нулевой вклад во все расстояния Хемминга. Один из них мы уже исключили из рассмотрения, но можно исключить и второй. Таким образом, мы сократили количество переменных до 7. Решим СЛАУ относительно каких-нибудь шести переменных. Свободным осталось значение одной из переменных. Так как столбцы, количеству которых соответствует эта переменная, вносят ненулевой вклад хотя бы в одно расстояние Хемминга, значение этой переменной не может превосходить максимума из заданных расстояний Хемминга. Тогда можно перебрать его и выбрать наилучший из получившихся ответов.Алгоритм получается следующий: Для каждого типа столбцов определим, какой вклад один такой столбец вносит в каждое из расстояний Хемминга Запустим алгоритм Гаусса для полученной матрицы Переберем значение свободной переменной, выразим через нее остальные, проверим, что все они неотрицательны и целы, выберем наилучший из ответов. Выведем ответ. Асимптотика этого решения составляла O(max(di, j)), если пользоваться типом double и , если решать задачу в рациональных числах.Наверное, могло показаться, что при решении в рациональных числах могло быть переполнение. Но, так как мы применяем наш алгоритм к одной и той же матрице (за исключением последнего столбца), наши вычисления всегда одинаковы, то есть мы домножаем строки на одни и те же числа. Можно заметить, что в нашей матрице все числа будут единицами или двойками, тогда никакой коэффициент в итоге не превысит . Таким образом, можно решать задачу в рациональных числах или в типе double.Задача <<Два отрезка>>Основная идея: обратить перестановку и решать упрощенную задачу (см. ниже), рассмотреть функцию <<количество отрезков в перестановке, которые образуют данный отрезок натурального ряда>>.Чтобы решить эту задачу, можно решить обратную: <<дана перестановка pn, нужно посчитать в них количество отрезков, элементы которых образуют 1 или 2 отрезка натурального ряда>>. Если мы решим эту задачу для некоторой перестановки qn, такой, что , то мы получим ответ для исходной задачи и перестановки.Первое решение, которое приходит в голову: переберем отрезок перестановки и в булевом массиве отметим элементы, принадлежащие ему. Проверим, что в булевском массиве получилось два отрезка. Такое решение будет иметь асимптотику O(n3). После некоторых размышлений можно понять, что при переходе от отрезка пере [l, r] к [l, r + 1] количество отрезков изменится некоторым предсказуемым образом. Обозначим s([a, b]) количество отрезков, которые образуют элементы отрезка [a, b] перестановки. Если новый элемент pr + 1 будет находиться между уже поставленными элементами (то есть, элементы со значениями pr + 1 - 1 и pr + 1 + 1 будут принадлежать отрезку [l, r]), то s([l, r + 1]) = s([l, r]) - 1. Новый элемент <<склеит>> два отрезка между которыми появится. Если у элемента pr + 1 будет один сосед, принадлежащий отрезку [l, r], то s([l, r]) = s([l, r + 1]) (один из существующих отрезков удлинится). Если же у элемента pr + 1 не будет соседей на отрезке [l, r], то новый элемент образует новый отрезок и s([l, r + 1]) = s([l, r]) + 1. Это иллюстрирует рисунок ниже:Новый элемент помечен красным, уже поставленные — черным. Из этих соображений можно получить следующее решение: переберем левую границу и, перебирая правую слева направо, будем пересчитывать количество отрезков, которые образует текущий отрезок перестановки. Если это число равно 1 или 2, прибавим к ответу единицу. Получаем асимптотику O(n2). Это решение работало достаточно быстро даже на n = 20000. Но, разумеется, этого было недостаточно, чтобы решить задачу. Перейдем к полному решению. Оно основывается на предыдущем. Мы уже умеем пересчитывать число отрезков при движении правой границы. Теперь нужно понять, как найти s([l - 1, r]) для любых r, используя s([l, r]). Будем перебирать позицию левой границы отрезков справа налево и поддерживать структуру данных, которая позволит нам хранить s([l, r]) для всех r и сможет считать в себе количество чисел 1 и 2. Обозначим за Δi s([l - 1, i]) - s([l, i]). Δl = 1 так как один элемент образует ровно 1 отрезок. Далее, если мы будем увеличивать i, Δi будет зависеть от количества соседей элемента l на отрезке [l - 1, i]. Если на отрезке нет соседей l, то количество отрезков, которым он соответствует увеличится на 1 при добавлении элемента l (так как l не присоединится ни к какому существующему отрезку). Если на отрезке ровно один сосед l, то количество отрезков, которым он соответствует не изменится при его добавлении (так как l просто присоединится к отрезку своего соседа). Если на отрезке два соседа l, то при его добавлении, количество образуемых отрезков уменьшится на 1. Найдем соседей l, лежащих после него. Обозначим их за a и b. (если после l лежит только один его сосед, b = inf) тогда для всех i, таких что l ≤ i < a Δi = 1. Для всех i, таких что a ≤ i < b Δi = 0 и для всех i удовлетворяющих b ≤ i ≤ n Δi =  - 1. Тогда, чтобы обновить нашу структуру достаточно сделать два прибавления на отрезке. На картинке выше видно, что у элемента 5 оба соседа лежат правее его. Поэтому получается три отрезка эквивалентности Δi (первый из них находится в самом элементе 5). После первого встреченного соседа (4) Δi принимает значение 0 и, наконец, начиная с соседа 6, Δi принимают значение  - 1.Остается только придумать структуру, позволяющую прибавлять на отрезке +1 и -1 и искать в семе числа 1 и 2. Во-первых, заметим, что неположительных чисел структура хранить не будет. Тогда числа 1 и 2 будут являться первым или вторым минимумом в структуре. Тогда структуре достаточно уметь искать два минимума в себе и уметь прибавлять +1 и -1 на отрезке. Два минимума ищутся почти так же, как и один, поэтому можно адаптировать дерево отрезков или sqrt-декомпозицию под эти цели. Сумма ответов структуры на каждой итерации будет ответом на задачу. Авторская sqrt-декомпозиция работала 1.3 секунды, авторское дерево отрезков — 1.1 секунды. sqrt-декомпозиция на Java — 3.6 секунд.Задача <<Число Фибоначчи>>Решение: baby-step-giant-stepВ этой задаче было дано некоторое число Фибоначчи f по модулю 1013, требовалось определить его первое вхождение в последовательность (позицию). Рассмотрим два взаимно простых модуля, делящих 1013. Пометим их как a и b. Остаток от деления f на a будет равен остатку от деления настоящего числа Фибоначчи F, такого, что . (). Найдем вхождения в период последовательности Фибоначчи по модулю a. Найдем вхождения в период последовательности Фибоначчи по модулю b. Зафиксируем пару этих вхождений. Пусть вхождение в последовательность Фибоначчи по модулю a будет в позиции i, а по модулю b — в позиции j. Обозначим за t(m) период последовательности Фибоначчи по модулю m. Из Китайской Теоремы об Остатках следует, что t(ab) = LCM(t(a), t(b)) (так как a и b выбраны взаимно простыми). Тогда по зафиксированным вхождениям f по модулям a и b можно восстановить вхождение f в последовательность по модулю ab. Это можно сделать, решив Диофантово уравнение i + t(a)·x = j + t(b)·y. Это уравнение можно решить перебором одного из корней. Если найденное вхождение в последовательность по модулю ab обозначить за u, то все вхождения f в последовательность по модулю 1013 будут представимы в виде t(ab)·k + u. Тогда переберем k и найдем все вхождения f в последовательность Фибоначчи по модулю 1013. Чтобы получить из числа Фибоначчи на позиции α, чиcло Фибоначчи на позиции α + t(ab) нужно домножить вектор из Fα и Fα + 1 на некоторую матрицу. Выберем a = 59 и b = 213. Заметим, что никакое число не входит в период последовательности Фибоначчи по каждому из этих модулей более 8 раз. Тогда пар вхождений будет не более 64. Для каждого вхождения мы переберем до чисел. Еще можно было более эффективно воспользоваться тем, что число вхождений любого числа в период последовательности Фибоначчи по модулям вроде 10k невелико. Можно было получать из вхождений числа f в последовательность по модулю 10i получить вхождения по модулю 10(i + 1) подобно тому, как в авторском решении осуществляется переход от модуля ab к модулю 1013.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4673",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 13504
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #122 - Codeforces - Code 1",
          "code": ".##\n###\n##.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 2",
          "code": ".##\n###\n##.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 3",
          "code": "####\n##.#\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 4",
          "code": "####\n##.#\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 5",
          "code": "<--p--><-q-><---r---><--t-->\naaaaaaaaaaaaaaaaaaaaaaaaaaaa\nbbbbbbbbbbbbaaaaaaaaaaaaaaaa\naaaaaaabbbbbbbbbbbbbbaaaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 6",
          "code": "<--p--><-q-><---r---><--t-->\naaaaaaaaaaaaaaaaaaaaaaaaaaaa\nbbbbbbbbbbbbaaaaaaaaaaaaaaaa\naaaaaaabbbbbbbbbbbbbbaaaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 7",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 8",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 9",
          "code": "3 3\n...\n.#.\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 10",
          "code": "3 3\n...\n.#.\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces - Code 1",
          "code": "if ((a + 1) mod 4 = 0) then\n        writeln(a + 1)\n      else\n        if ((a + 1) mod 2 = 0) then\n          writeln(2 * a + 1)\n        else\n          writeln(4 * a + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4673",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces - Code 2",
          "code": "if ((a + 1) mod 4 = 0) then\n        writeln(a + 1)\n      else\n        if ((a + 1) mod 2 = 0) then\n          writeln(2 * a + 1)\n        else\n          writeln(4 * a + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4673",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces - Code 3",
          "code": "![ ](<тот самый URL>)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4673",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long f = inf.readLong(0LL, 9999999999999LL, \"f\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long f = inf.readLong(0LL, 9999999999999LL, \"f\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long f = inf.readLong(0LL, 9999999999999LL, \"f\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\n// Function to compute nth Fibonacci number modulo mod using fast doubling\nll fib(ll n, ll mod) {\n    ll a = 0, b = 1;\n    for (ll i = 62; i >= 0; i--) {\n        ll c = (a * ((b * 2 % mod) - a + mod)) % mod;\n        ll d = (a * a % mod + b * b % mod) % mod;\n        a = c;\n        b = d;\n        if ((n >> i) & 1) {\n            ll temp = (a + b) % mod;\n            a = b;\n            b = temp;\n        }\n    }\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    ll mod = 1013;\n\n    if (type == \"random\") {\n        // Generate a random f in range [0, mod - 1]\n        ll f = rnd.next(0LL, mod - 1);\n        printf(\"%lld\\n\", f);\n    } else if (type == \"early\") {\n        // Output an f that occurs early in the sequence\n        vector<ll> early_f = {0, 1, 1, 2, 3, 5, 8, 13, 21};\n        ll idx = rnd.next(0, (int)early_f.size() -1);\n        ll f = early_f[idx];\n        printf(\"%lld\\n\", f);\n    } else if (type == \"large_position\") {\n        // Generate a Fibonacci number at a large position\n        // Read n from command line, default to a large value if not provided\n        ll n = opt<ll>(\"n\", 1000000000LL);\n        ensuref(n >= 0, \"n must be non-negative\");\n        ll f = fib(n, mod);\n        printf(\"%lld\\n\", f);\n    } else if (type == \"specific\") {\n        // Use specific f values that may cause problems\n        vector<ll> specific_f = {0LL, mod -1, mod / 2, mod / 3, mod / 4, mod / 5};\n        ll f = specific_f[rnd.next(0, (int)specific_f.size() -1)];\n        printf(\"%lld\\n\", f);\n    } else {\n        // Default to random if unknown type\n        ll f = rnd.next(0LL, mod - 1);\n        printf(\"%lld\\n\", f);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\n// Function to compute nth Fibonacci number modulo mod using fast doubling\nll fib(ll n, ll mod) {\n    ll a = 0, b = 1;\n    for (ll i = 62; i >= 0; i--) {\n        ll c = (a * ((b * 2 % mod) - a + mod)) % mod;\n        ll d = (a * a % mod + b * b % mod) % mod;\n        a = c;\n        b = d;\n        if ((n >> i) & 1) {\n            ll temp = (a + b) % mod;\n            a = b;\n            b = temp;\n        }\n    }\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    ll mod = 1013;\n\n    if (type == \"random\") {\n        // Generate a random f in range [0, mod - 1]\n        ll f = rnd.next(0LL, mod - 1);\n        printf(\"%lld\\n\", f);\n    } else if (type == \"early\") {\n        // Output an f that occurs early in the sequence\n        vector<ll> early_f = {0, 1, 1, 2, 3, 5, 8, 13, 21};\n        ll idx = rnd.next(0, (int)early_f.size() -1);\n        ll f = early_f[idx];\n        printf(\"%lld\\n\", f);\n    } else if (type == \"large_position\") {\n        // Generate a Fibonacci number at a large position\n        // Read n from command line, default to a large value if not provided\n        ll n = opt<ll>(\"n\", 1000000000LL);\n        ensuref(n >= 0, \"n must be non-negative\");\n        ll f = fib(n, mod);\n        printf(\"%lld\\n\", f);\n    } else if (type == \"specific\") {\n        // Use specific f values that may cause problems\n        vector<ll> specific_f = {0LL, mod -1, mod / 2, mod / 3, mod / 4, mod / 5};\n        ll f = specific_f[rnd.next(0, (int)specific_f.size() -1)];\n        printf(\"%lld\\n\", f);\n    } else {\n        // Default to random if unknown type\n        ll f = rnd.next(0LL, mod - 1);\n        printf(\"%lld\\n\", f);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type early\n./gen -type early\n./gen -type early\n./gen -type early\n./gen -type early\n\n./gen -type specific\n./gen -type specific\n./gen -type specific\n./gen -type specific\n./gen -type specific\n\n./gen -type large_position -n 100000000\n./gen -type large_position -n 200000000\n./gen -type large_position -n 500000000\n./gen -type large_position -n 1000000000\n./gen -type large_position -n 2000000000\n./gen -type large_position -n 3000000000\n./gen -type large_position -n 5000000000\n./gen -type large_position -n 10000000000\n./gen -type large_position -n 20000000000\n./gen -type large_position -n 50000000000\n\n# Additional random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Edge cases with n = 0 and n = 1\n./gen -type large_position -n 0\n./gen -type large_position -n 1\n\n# Very large n\n./gen -type large_position -n 9223372036854775807\n\n# More specific f values\n./gen -type specific\n./gen -type specific\n./gen -type specific\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:40.413962",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "194/A",
      "title": "A. Exams",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single input line contains space-separated integers n and k (1 ≤ n ≤ 50, 1 ≤ k ≤ 250) — the number of exams and the required sum of marks.It is guaranteed that there exists a way to pass n exams in the way that makes the sum of marks equal exactly k.",
      "output_spec": "OutputPrint the single number — the minimum number of exams that the author will get a 2 for, considering that the sum of marks for all exams must equal k.",
      "sample_tests": "ExamplesInputCopy4 8OutputCopy4InputCopy4 10OutputCopy2InputCopy1 3OutputCopy0",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single input line contains space-separated integers n and k (1 ≤ n ≤ 50, 1 ≤ k ≤ 250) — the number of exams and the required sum of marks.It is guaranteed that there exists a way to pass n exams in the way that makes the sum of marks equal exactly k.\n\nOutputPrint the single number — the minimum number of exams that the author will get a 2 for, considering that the sum of marks for all exams must equal k.\n\nInputCopy4 8OutputCopy4InputCopy4 10OutputCopy2InputCopy1 3OutputCopy0\n\nInputCopy4 8\n\nOutputCopy4\n\nInputCopy4 10\n\nOutputCopy2\n\nInputCopy1 3\n\nOutputCopy0\n\nNoteIn the first sample the author has to get a 2 for all his exams.In the second sample he should get a 3 for two exams and a 2 for two more.In the third sample he should get a 3 for one exam.",
      "solutions": [
        {
          "title": "Codeforces Round #122 - Codeforces",
          "content": "The upcoming contest is brought to you by me. My name is Arthur, I'm a student of Chelyabinsk lyceum 31.I am glad to thank Gerald for contest preparation management, Delinur for translation of statements, MikeMirzayanov for a really excellent system, dolphinigle for test-solving, proof-reading and much valuable advice, fdoer, grey_wind, Skird and alger95 for help in problem development.There is nothing more to say yet. As you can see, contest will be held in two divisions separately. The scoring system will be standard (not dynamic), but scores for tasks may be unusual (see update of this post).There won't be volume stories. I hope you will like the contest and its problemset and everything will be OK.UPD: Scores for tasks:Division 1: 500-1000-2000-2000-2500Division 2: 500-1000-1500-2000-3000UPD2: Congrats to winners =)Div1: Petr tourist yeputons peter50216 aram90 Div2: lucien tomasz.kociumaka sjynoi UPD3 some part of English editoral posted. You will find the remaining part of the editorial laterUPD4 English editoral was completed.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4671",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1048
        },
        {
          "title": "Editoral Codeforces Round #122 - Codeforces",
          "content": "Please, report me about every grammar mistake, you see. Thank you.Problem <>Let's notice that 2n ≤ k ≤ 5n. If k < 3n author has to get 2 on some exams. There are 3n - k such exams and that's the answer). If 3n ≤ k author will pass all exams (answer is 0).Problem <>Let the pencil move by the line and put crosses through every (n + 1) point. Lets associate every point on the line with point on square perimeter. Namely, point x on the line will be associated with point on square perimeter that we will reach if we move pencil around square to x clockwise. Then lower left corner will be associated with all points 4np for every non-negative integer p. Crosses will be associated with points k(n + 1) for some non-negative k. Nearest point of overlap of two families of points will be in point LCM(n + 1, 4n). Then we will put crosses.Problem \"Cutting Figure\"Translation by fdoerMain idea: using the fact that the answer cannot be greater than 2, check answer 1.Let's proof that the answer is not greater than 2. Let area of the figure be greater than 3. Let's examine the leftmost of all topmost squares. There is no neighbors left or up to it. So, number of its neighbors is not more than 2. Thus, if we delete its neighbors, we shall disconnect the figure. If the area is equal to 3, we always can disconnect the figure by deletion of one square. It can be proofed by considering all two primary cases. If the area is not greater than 2, there is no way to disconnect the figure.The algorithm: Check answer 1. We can simply brute-force the square to delete, and for each instance start dfs from any existing square. If during the dfs we visited not all of the remaining squares, we have found the square to delete. The answer is 1 if our bruteforce succeeded, and 2 otherwise.That was necessary to consider the case when there is no answer.The complexity of the described algorithm is O(n4). That was possible to search for articulation points and solve the problem in complexity O(n2), but in my opinion that required more time and effort.Problem <>Translation by fdoerMain idea: bruteforce in complexity O(Fun) where Fu if fibonacci number at position u.This problem had complex statements. We have an array a, and we can transform it in two ways. The goal was to maximize the sum of all its elements with given multipliers after exactly u operations. A simple bruteforce of all combinations of operations with subsequent modeling leads to complexity O(2u * nu), what is not fast enough. That was possible to optimize it by modeling parallel to recursive bruteforce. Now we have complexity O(2un). Actually, the correct solution is not too far from this algorithm.There is just one conjecture: every two successive xor operations change nothing, and we can move them to any place of the combination. Thus, it will be enough to bruteforce only combinations in which every pair of successive xor operations is at the end.It could be done using recoursive bruteforce. We must change in previous solution two things. First, we must n't put xor after xor. Besides that, we should update answer if number u - l is even, where l is current level of recoursion (all remaining operations in the end separates to pairs of xors).Let's calculate complexity of this algo. There are Fi sequences of length i without two consecutive xors. It's easy to proof, you can calculate some dp to see it. That's why, complexity of our algo is O(Fun). Problem \"Hamming distance\"Main idea: reduction to system of linear equations and solving it using Gauss algorithm.Let's notice that order of columns in answer doesn't matter. That's why there is only one important thing — quantity of every type of column. There is only 24 = 16 different columns. Let's represent Hamming distance between every pair of strings as sum of quantities of types of columns. It's possible because every column adds to every distance between pairs 0 or 1. Now we have system of 6 linear equations with 16 variables. It's not good, let's decrease number of variables. First, some columns adds same values to every Hamming distance. For example strings \"abbb\" and \"baaa\". For every column q we can replace all letters \"a\" by letters \"b\" and all letters \"b\" by letters \"a\" and reach column that adds same values to every distance. We reduced number of variables to 8. We also can notice that columns \"aaaa\" and \"bbbb\" is useless and reduce number of variables to 7.This system can be solved using Gauss algorithm. One variable steel be free. Let's fix it. It's value can't be more than maximum of h(si, sj) because column adds positive value to one or more Hamming distance. For every fixed value we should check if all variables take non-negative integer value and choose the best answer.We can solve system of equations in integers because coefficients of equation is little.Complexity of this solution if O(max(h(si, sj))). If we solve it in rational numbers complexity will change to .Problem \"Two segments\"Main idea: inverse the permutation and solve simplified problem (see below), consider function \"quantity of segments of permutation that form the given segment of natural series\".In order to solve this problem, we suggest solve another: <<we have a permutation pn, we have to calculate the count of segments such that their elements form one or two segments of natural series>>.If we solve the inverse problem for some permutation qn such that , we shall get the answer for the initial problem and initial permutation pi. Straight-forward algo: let's bruteforce the segment of permutation and mark its elements in a boolean array. Check that in that array there is not more than two marked segments. This algo has complexity O(n3).Let's notice that during the changeover from [l, r] to [l, r + 1] the quantity of segments changes in some predictable way. Let s([a, b]) be quantity of segments that form segment [a, b] of permutation. There are three cases (see picture below): If the new element pr + 1 is between two marked elements (that is, both elements with values pr + 1 - 1 and pr + 1 + 1 belong to segment [l, r]), then s([l, r + 1]) = s([l, r]) - 1. The new element will <> the segments near it. If the new element pr + 1 has only one neighbor with value belonging to [l, r], then s([l, r + 1]) = s([l, r]). The new element will lengthen one of existing segments. If there are no marked elements near pr + 1 the new element forms a new segment, s([l, r + 1]) = s([l, r]) + 1. The new element is red, elements that are marked to this moment are black.Improved algo: Let's bruteforce position of the left border and for each instance move the right border from left to right. During each move we shall recount the actual quantity of segments forming the current segment of permutation (s([l, r])). Now we have a solution in complexity O(n2). It works fast enough even when n = 20000. Obviously, that is not enough to get AC.Move on full solution. It is based on previous. Now we can calc s([l, r]) using s([l, r - 1]). Now we should look at way of changing s([l - 1, r]) as compared with s([l, r]). Let's move left border of segment from the right to left and support some data structure with s([l, i]) for every i satisfying l < i ≤ n and current l. This structure should answer queries \"count numbers 1 and 2 in structure\", that is count segments [l, i] that generates one or two segments in the original permutaton.Let Δi be s([l - 1, i]) - s([l, i]). Δl will be equal to 1 because one element form one segment in permutation (notice that in final answer we must not consider 1-element segments, that's why we must subtract n from answer in the end of solution). Δi determined by the number of neighbors of element l - 1 in the segment [l - 1, i]. Neighbors of l - 1 is elements pl - 1 + 1 and pl - 1 - 1 if they're exist. If l - 1 hasn't neighbors in this segment, Δi = 1, because l - 1 froms new 1-element segment. If l - 1 has one neighbor in this segment Δi = 0, because l - 1 join to existing segment of its neighbor. If l - 1 has two neighbors in this segment Δi =  - 1, because l - 1 connect segments of its neighbors. Number of neighbors in segment [l - 1, i] non-decreasing with increasing i. That's why Δi non-decreasing with increasing i. That means that there are only three segments of equivalence of Δi. We are interested only in neighbors of l - 1 which positions are right than l - 1. Let a is position of first neighbor, b is position of second neighbor, without loss of generality a < b. Then , , . (elements of permutation are numbered from 0). If a and b aren't exist, for all Δi = 1. If only b isn't exist for , for . Look at example to clear your understanding. (Δi is in top right corners, l = 3, pl = 5)Using this facts we can code data structure support following operations: Add +1 or -1 on segment Calc number of 1 and 2 in the structure. Sum of answers of structure in every iteration (for every l) is answer to problem.Let's notice that all numbers in structure will be positive. That's why elements 1 and 2 will be minimal of pre-minimal in the structure. Using this fact we can code segment tree, supports these operations.Complexity of this solution is .We also can code sqrt-decomposition and obtain complexity .Problem <>Translation by fdoerMain idea: baby-step-giant-step.In this problem we had some Fibonacci number modulo 1013 f, and we had to determine the position of its first occurence in Fibonacci sequence modulo 1013. Let a and b be two different coprime modula — divisors of 1013. Let F be the actual Fibonacci number such that . Then and . Find all occurences of number in Fibonacci sequence modulo a period. Find all occurences of number in Fibonacci sequence modulo b period. Let's fix a pair of such occurences. Let the occurence modulo a be in position i, and the occurence modulo b be in position j. Let t(m) be Fibonacci sequence modulo m period. From the Chinese Remainder Theorem, it follows that t(ab) = LCM(t(a), t(b)) (remember that a and b are coprime). Then from fixed occurences of f in periods of sequences modulo a and b we can recover the position of occurence of f in period of sequence modulo ab. It could be done by solving the following Diophantine equation: i + t(a) * x = j + t(b) * y. We can solve it using a simple bruteforce of one of the roots. If the occurence in sequence modulo ab period ( we have just found it) is u, then every occurence f in Fibonacci sequence modulo 1013 period can be represented as t(ab) * k + u. Then let's bruteforce k and find all occurences in sequence modulo 1013 period. To determine Fibonacci number on position α + t(ab) from known Fibonacci number on position α, we need to multiply the vector (Fα, Fα + 1) and some matrix. Let's choose a = 59 and b = 213. Note that there is no number that occur Fibonacci sequence modulo a or b period more than 8 times. That means that total count of pairs will never be greater than 64. For each occurence we'll bruteforce not more than numbers. That was the author's solution. Also that was possible to use the fact that for any number the count of its occurences in period of sequence modulo 10p (for any natural p) is not big more efficiently. From occurences in sequence modulo 10i period we could get occurences in sequence modulo 10i + 1 period using the method we use to jump from modulus ab to modulus 1013.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4673",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11337
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #122 - Codeforces - Code 1",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 2",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 250, \"k\");\n    inf.readEoln();\n\n    int minSum = 2 * n;\n    int maxSum = 5 * n;\n\n    ensuref(k >= minSum && k <= maxSum, \"k must be between %d and %d inclusive\", minSum, maxSum);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 250, \"k\");\n    inf.readEoln();\n\n    int minSum = 2 * n;\n    int maxSum = 5 * n;\n\n    ensuref(k >= minSum && k <= maxSum, \"k must be between %d and %d inclusive\", minSum, maxSum);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 250, \"k\");\n    inf.readEoln();\n\n    int minSum = 2 * n;\n    int maxSum = 5 * n;\n\n    ensuref(k >= minSum && k <= maxSum, \"k must be between %d and %d inclusive\", minSum, maxSum);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int min_k = 2 * n;\n    int max_k = 5 * n;\n    int k;\n\n    if (type == \"min2\") {\n        // Generate k randomly between min_k and max_k\n        k = rnd.next(min_k, max_k);\n    } else if (type == \"no2\") {\n        // Need to set k such that it's possible to get the sum without any 2's\n        int min_sum_no2 = 3 * n;\n        if (min_sum_no2 > max_k) {\n            // Not possible, adjust k to max_k\n            k = max_k;\n        } else {\n            k = rnd.next(min_sum_no2, max_k);\n        }\n    } else if (type == \"max2\") {\n        // Set k = 2n (minimum possible sum)\n        k = min_k;\n    } else if (type == \"random\") {\n        // Random k between min_k and max_k\n        k = rnd.next(min_k, max_k);\n    } else if (type == \"maxk\") {\n        // Set k = max_k (maximum possible sum)\n        k = max_k;\n    } else if (type == \"mink\") {\n        // Set k = min_k (minimum possible sum)\n        k = min_k;\n    } else {\n        // Default to random k\n        k = rnd.next(min_k, max_k);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int min_k = 2 * n;\n    int max_k = 5 * n;\n    int k;\n\n    if (type == \"min2\") {\n        // Generate k randomly between min_k and max_k\n        k = rnd.next(min_k, max_k);\n    } else if (type == \"no2\") {\n        // Need to set k such that it's possible to get the sum without any 2's\n        int min_sum_no2 = 3 * n;\n        if (min_sum_no2 > max_k) {\n            // Not possible, adjust k to max_k\n            k = max_k;\n        } else {\n            k = rnd.next(min_sum_no2, max_k);\n        }\n    } else if (type == \"max2\") {\n        // Set k = 2n (minimum possible sum)\n        k = min_k;\n    } else if (type == \"random\") {\n        // Random k between min_k and max_k\n        k = rnd.next(min_k, max_k);\n    } else if (type == \"maxk\") {\n        // Set k = max_k (maximum possible sum)\n        k = max_k;\n    } else if (type == \"mink\") {\n        // Set k = min_k (minimum possible sum)\n        k = min_k;\n    } else {\n        // Default to random k\n        k = rnd.next(min_k, max_k);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 4 -type max2  # Sample input where answer is maximum number of 2's\n./gen -n 4 -type random\n./gen -n 4 -type min2\n\n./gen -n 1 -type random  # Sample input with n=1\n\n./gen -n 1 -type mink\n./gen -n 1 -type maxk\n./gen -n 1 -type no2\n\n./gen -n 50 -type mink\n./gen -n 50 -type maxk\n\n./gen -n 50 -type random\n\n./gen -n 50 -type no2\n\n./gen -n 50 -type min2\n\n./gen -n 50 -type max2\n\n./gen -n 25 -type mink\n./gen -n 25 -type maxk\n./gen -n 25 -type random\n./gen -n 25 -type no2\n./gen -n 25 -type min2\n./gen -n 25 -type max2\n\n./gen -n 10 -type mink\n./gen -n 10 -type maxk\n./gen -n 10 -type random\n./gen -n 10 -type no2\n./gen -n 10 -type min2\n./gen -n 10 -type max2\n\n./gen -n 13 -type random\n./gen -n 17 -type no2\n./gen -n 23 -type min2\n./gen -n 31 -type max2\n./gen -n 37 -type random\n./gen -n 42 -type min2\n\n./gen -n 1 -type mink\n./gen -n 1 -type maxk\n\n./gen -n 50 -type random\n./gen -n 50 -type mink\n./gen -n 50 -type maxk\n./gen -n 50 -type no2\n./gen -n 50 -type max2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:42.092977",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "194/B",
      "title": "B. Квадрат",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записано целое число t (1 ≤ t ≤ 104) — количество тестовых примеров. Во второй строке находится t целых чисел ni (1 ≤ ni ≤ 109), разделенных пробелами, — стороны квадрата для каждого тестового примера.",
      "output_spec": "Выходные данныеДля каждого тестового примера выведите в отдельной строке ответ для него, то есть, количество крестиков, которые поставит Джон, двигаясь по квадрату соответствующего размера. Ответы для примеров выводите в том порядке, в котором примеры заданы во входных данных.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать34 8 100Выходные данныеСкопировать1733401",
      "description": "ограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число t (1 ≤ t ≤ 104) — количество тестовых примеров. Во второй строке находится t целых чисел ni (1 ≤ ni ≤ 109), разделенных пробелами, — стороны квадрата для каждого тестового примера.\n\nВходные данные\n\nВыходные данныеДля каждого тестового примера выведите в отдельной строке ответ для него, то есть, количество крестиков, которые поставит Джон, двигаясь по квадрату соответствующего размера. Ответы для примеров выводите в том порядке, в котором примеры заданы во входных данных.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-х битовых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать34 8 100Выходные данныеСкопировать1733401\n\nВходные данныеСкопировать34 8 100\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1733401\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #122 - Codeforces",
          "content": "Привет всем! Я автор задач сегодняшнего раунда. Меня зовут Артур, я учусь в лицее №31 города Челябинска. Благодарю Gerald за координацию подготовки контеста, Delinur за перевод условий, MikeMirzayanov за замечательную систему, dolphinigle за прорешивание контеста, вычитывание условий и множество ценных советов, fdoer, grey_wind, Skird и alger95 за помощь в придумывании задач. Пока ничего практически полезного сказать не могу. Как вы, надеюсь, догадались, контест пройдет в каждом дивизионе отдельно. Система подсчета очков будет стандартная, разбалловка, скорее всего, нестандартная, пока не знаю, какая именно, ближе к делу напишу.Объемных фабул и историй не будет. Надеюсь, что контест и задачи вам понравятся и все пройдет гладко. UPD: Разбалловка следующая:В первом дивизионе: 500-1000-2000-2000-2500.Во втором дивизионе: 500-1000-1500-2000-3000.UPD2: появился разбор Пока частичный и на русском. скоро будет больше.Поздравляю победителей, особенно решивших задачу D.Div1: Petr tourist yeputons peter50216 aram90 Div2: lucien tomasz.kociumaka sjynoi DimaPhil",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4671",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1066
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces",
          "content": "Пожалуйста, задавайте возникающие у вас вопросы по задачам. Особенно это касается задачи D, так как она оказалась наиболее сложной.Задача <<Экзамены>> По условию 2n ≤ k ≤ 5n. Если k < 3n то некоторые экзамены мы сможем сдать только на 2. Таких будет 3n - k. Если же 3n ≤ k, то мы все экзамены сдадим как минимум на три.Задача <<Квадрат>> Пусть карандаш идет по прямой и ставит крестики через каждые (n + 1) точку. Поставим в соответствие положению на прямой положение на квадрате. А именно, точке x на прямой будет соответствовать точка, в которую придет карандаш, сдвинувшись по периметру квадрата на x. Тогда левому нижнему углу квадрата соответствуют все точки вида 4np для некоторого целого неотрицательного p. Поставленным крестиками будут соответствовать точки k(n + 1). Самая ближайшая точка совпадения двух семейств, за исключением начальной, будет в LCM(n + 1, 4n) (LCM — НОК). Тогда всего мы поставим крестиков.Задача <<Разрезание фигуры>>Основная идея: учитывая, что ответ не превышает двух, проверим существование ответа 1.Докажем, что ответ в задаче не превосходит двух. Пусть площадь фигуры не менее 4. Тогда рассмотрим самую левую из самых верхних клеток. У нее нет левого и верхнего соседей по стороне. Значит, у нее не будет более двух соседей. Тогда, удалив ее соседей мы уже разделим фигуру на две. Если площадь равна трем, то всегда можно разрезать ее, удалив одну клетку, это можно проверить, так как существует всего два принципиальных случая. Если площадь фигуры не превышает двух, то какое бы множество клеток мы не удалили, она не распадется. Проверим, существует ли ответ, величины один. Удаляемую клетку можно просто перебрать, а затем запустить dfs из любой неудаленной клетки. Если dfs посетит не все оставшиеся клетки, то, удалив нужную клетку мы разрежем фигуру. Если подходящая клетка нашлась — ответ равен 1. Если нет — 2. Еще нужно было не забыть, что иногда ответа может просто не существовать. Это бывает тогда, когда площадь фигуры меньше либо равна двум (площадь фигуры — кол-во клеток в ней)юАсимптотика решения O(n4). Еще можно было воспользоваться алгоритмом поиска точек сочленения и решить эту задачу за O(n2). Но это, наверное, требовало больших трудозатрат.Задача <>Основная идея: перебор за O(Fun). Fu — u-е число Фибоначчи.У этой задачи было довольно сложное условие. С массивом a можно было проводить операции двух типов. Нужно было провести ровно u таких операций, чтобы максимизировать сумму значений массива с заданными коэффициентами.Если просто перебрать все возможные комбинации операций, а потом промоделировать их, то получится решение за O(2u·nu). Это слишом долго. Можно было улучшить это решение, перебирая комбинации операций рекурсивно и по ходу рекурсии моделируя их. Тогда асимптотика улучшается до O(2u·n). Собственно, ничего сильно лучше этого решения не требовалось. Возникает лишь одно соображение: если у нас были две операции подряд, то они ничего не изменили и их можно переместить в любое место нашего алгоритма, не изменив его результат. Тогда можно перебирать только те алгоритмы, в которых все парные операции стоят в конце. Это тоже можно было делать рекурсивно, не идя в ветки с двумя, подряд идущими операциями и обновляя лучший ответ не только в конце рекурсии, но и тогда, когда в конце осталось четное число операций. Это работает сильно лучше. Вспомнив известную задачу \"кол-во последовательностей из нулей и единиц, без двух единиц подряд\" можно понять, что кол-во таких последовательностей, длиной k, равно Fk + 1, где Fi — i-е число Фибоначчи. Тогда кол-во допустимых алгоритмов равно сумме первых u чисел Фибоначчи. Эта сумма примерно равна (u + 2)-му чмслу Фибоначчи. Итоговая асимптотика составляет O(Fu·n). Для максимальных значений входных данных эта величина равна примерно 30 миллионам. Мне не удалось написать на эту задачу отжиг или какое-либо рандом-решение, которое проходило бы все или хотя бы большинство тестов. Задача <<Расстояние Хемминга>>Основная идея: сведение к СЛАУ и решение ее методом Гаусса.Заметим, что если мы одинаковым образом переставим символы во всех строках, то ответ не изменится. Рассмотрим <<столбцы>> ответа, то есть строки s1, i + s2, i + s3, i + s4, i для некоторого i. Всего существует 24 = 16 типов таких строк. Получается, что, если существует ответ на задачу, длины l, то существует и ответ той же длины в котором столбцы упорядочены по типу. Тогда, чтобы перебрать ответ, достаточно перебрать 16 чисел — количества столбцов каждого типа. По этим числам легко восстановить все расстояния Хемминга. Расстояние между строками si и sj будет равно сумме количеств столбцов в которых различны символы c номерами i и j. Однако перебирать все возможные количества столбцов каждого типа слишком долго. Заметим, что мы можем записать систему из 6 уравнений с 16 неизвестными (вспомнив, что расстояние между строками si и sj будет равно сумме количеств столбцов в которых различны символы c номерами i и j). Неизвестными в этой системе уравнений будут количества столбцов каждого из типов. Заметим, что некоторые варианты столбцов полностью идентичны с точки зрения вклада, вносимого в расстояния Хемминга. А именно, столбцы, получаемые друг из друга инвертированием всех букв (заменой <> на <> и наоборот) вносят идентичный вклад в расстояния Хемминга. Например, если добавить в ответ столбец <>, расстояния Хемминга между всеми парами строк изменятся тем же образом, что и при добавлении столбца <>. Получается, что мы можем рассматривать лишь 8 возможных столбцов. Кроме того, столбцы <> и <> вносят нулевой вклад во все расстояния Хемминга. Один из них мы уже исключили из рассмотрения, но можно исключить и второй. Таким образом, мы сократили количество переменных до 7. Решим СЛАУ относительно каких-нибудь шести переменных. Свободным осталось значение одной из переменных. Так как столбцы, количеству которых соответствует эта переменная, вносят ненулевой вклад хотя бы в одно расстояние Хемминга, значение этой переменной не может превосходить максимума из заданных расстояний Хемминга. Тогда можно перебрать его и выбрать наилучший из получившихся ответов.Алгоритм получается следующий: Для каждого типа столбцов определим, какой вклад один такой столбец вносит в каждое из расстояний Хемминга Запустим алгоритм Гаусса для полученной матрицы Переберем значение свободной переменной, выразим через нее остальные, проверим, что все они неотрицательны и целы, выберем наилучший из ответов. Выведем ответ. Асимптотика этого решения составляла O(max(di, j)), если пользоваться типом double и , если решать задачу в рациональных числах.Наверное, могло показаться, что при решении в рациональных числах могло быть переполнение. Но, так как мы применяем наш алгоритм к одной и той же матрице (за исключением последнего столбца), наши вычисления всегда одинаковы, то есть мы домножаем строки на одни и те же числа. Можно заметить, что в нашей матрице все числа будут единицами или двойками, тогда никакой коэффициент в итоге не превысит . Таким образом, можно решать задачу в рациональных числах или в типе double.Задача <<Два отрезка>>Основная идея: обратить перестановку и решать упрощенную задачу (см. ниже), рассмотреть функцию <<количество отрезков в перестановке, которые образуют данный отрезок натурального ряда>>.Чтобы решить эту задачу, можно решить обратную: <<дана перестановка pn, нужно посчитать в них количество отрезков, элементы которых образуют 1 или 2 отрезка натурального ряда>>. Если мы решим эту задачу для некоторой перестановки qn, такой, что , то мы получим ответ для исходной задачи и перестановки.Первое решение, которое приходит в голову: переберем отрезок перестановки и в булевом массиве отметим элементы, принадлежащие ему. Проверим, что в булевском массиве получилось два отрезка. Такое решение будет иметь асимптотику O(n3). После некоторых размышлений можно понять, что при переходе от отрезка пере [l, r] к [l, r + 1] количество отрезков изменится некоторым предсказуемым образом. Обозначим s([a, b]) количество отрезков, которые образуют элементы отрезка [a, b] перестановки. Если новый элемент pr + 1 будет находиться между уже поставленными элементами (то есть, элементы со значениями pr + 1 - 1 и pr + 1 + 1 будут принадлежать отрезку [l, r]), то s([l, r + 1]) = s([l, r]) - 1. Новый элемент <<склеит>> два отрезка между которыми появится. Если у элемента pr + 1 будет один сосед, принадлежащий отрезку [l, r], то s([l, r]) = s([l, r + 1]) (один из существующих отрезков удлинится). Если же у элемента pr + 1 не будет соседей на отрезке [l, r], то новый элемент образует новый отрезок и s([l, r + 1]) = s([l, r]) + 1. Это иллюстрирует рисунок ниже:Новый элемент помечен красным, уже поставленные — черным. Из этих соображений можно получить следующее решение: переберем левую границу и, перебирая правую слева направо, будем пересчитывать количество отрезков, которые образует текущий отрезок перестановки. Если это число равно 1 или 2, прибавим к ответу единицу. Получаем асимптотику O(n2). Это решение работало достаточно быстро даже на n = 20000. Но, разумеется, этого было недостаточно, чтобы решить задачу. Перейдем к полному решению. Оно основывается на предыдущем. Мы уже умеем пересчитывать число отрезков при движении правой границы. Теперь нужно понять, как найти s([l - 1, r]) для любых r, используя s([l, r]). Будем перебирать позицию левой границы отрезков справа налево и поддерживать структуру данных, которая позволит нам хранить s([l, r]) для всех r и сможет считать в себе количество чисел 1 и 2. Обозначим за Δi s([l - 1, i]) - s([l, i]). Δl = 1 так как один элемент образует ровно 1 отрезок. Далее, если мы будем увеличивать i, Δi будет зависеть от количества соседей элемента l на отрезке [l - 1, i]. Если на отрезке нет соседей l, то количество отрезков, которым он соответствует увеличится на 1 при добавлении элемента l (так как l не присоединится ни к какому существующему отрезку). Если на отрезке ровно один сосед l, то количество отрезков, которым он соответствует не изменится при его добавлении (так как l просто присоединится к отрезку своего соседа). Если на отрезке два соседа l, то при его добавлении, количество образуемых отрезков уменьшится на 1. Найдем соседей l, лежащих после него. Обозначим их за a и b. (если после l лежит только один его сосед, b = inf) тогда для всех i, таких что l ≤ i < a Δi = 1. Для всех i, таких что a ≤ i < b Δi = 0 и для всех i удовлетворяющих b ≤ i ≤ n Δi =  - 1. Тогда, чтобы обновить нашу структуру достаточно сделать два прибавления на отрезке. На картинке выше видно, что у элемента 5 оба соседа лежат правее его. Поэтому получается три отрезка эквивалентности Δi (первый из них находится в самом элементе 5). После первого встреченного соседа (4) Δi принимает значение 0 и, наконец, начиная с соседа 6, Δi принимают значение  - 1.Остается только придумать структуру, позволяющую прибавлять на отрезке +1 и -1 и искать в семе числа 1 и 2. Во-первых, заметим, что неположительных чисел структура хранить не будет. Тогда числа 1 и 2 будут являться первым или вторым минимумом в структуре. Тогда структуре достаточно уметь искать два минимума в себе и уметь прибавлять +1 и -1 на отрезке. Два минимума ищутся почти так же, как и один, поэтому можно адаптировать дерево отрезков или sqrt-декомпозицию под эти цели. Сумма ответов структуры на каждой итерации будет ответом на задачу. Авторская sqrt-декомпозиция работала 1.3 секунды, авторское дерево отрезков — 1.1 секунды. sqrt-декомпозиция на Java — 3.6 секунд.Задача <<Число Фибоначчи>>Решение: baby-step-giant-stepВ этой задаче было дано некоторое число Фибоначчи f по модулю 1013, требовалось определить его первое вхождение в последовательность (позицию). Рассмотрим два взаимно простых модуля, делящих 1013. Пометим их как a и b. Остаток от деления f на a будет равен остатку от деления настоящего числа Фибоначчи F, такого, что . (). Найдем вхождения в период последовательности Фибоначчи по модулю a. Найдем вхождения в период последовательности Фибоначчи по модулю b. Зафиксируем пару этих вхождений. Пусть вхождение в последовательность Фибоначчи по модулю a будет в позиции i, а по модулю b — в позиции j. Обозначим за t(m) период последовательности Фибоначчи по модулю m. Из Китайской Теоремы об Остатках следует, что t(ab) = LCM(t(a), t(b)) (так как a и b выбраны взаимно простыми). Тогда по зафиксированным вхождениям f по модулям a и b можно восстановить вхождение f в последовательность по модулю ab. Это можно сделать, решив Диофантово уравнение i + t(a)·x = j + t(b)·y. Это уравнение можно решить перебором одного из корней. Если найденное вхождение в последовательность по модулю ab обозначить за u, то все вхождения f в последовательность по модулю 1013 будут представимы в виде t(ab)·k + u. Тогда переберем k и найдем все вхождения f в последовательность Фибоначчи по модулю 1013. Чтобы получить из числа Фибоначчи на позиции α, чиcло Фибоначчи на позиции α + t(ab) нужно домножить вектор из Fα и Fα + 1 на некоторую матрицу. Выберем a = 59 и b = 213. Заметим, что никакое число не входит в период последовательности Фибоначчи по каждому из этих модулей более 8 раз. Тогда пар вхождений будет не более 64. Для каждого вхождения мы переберем до чисел. Еще можно было более эффективно воспользоваться тем, что число вхождений любого числа в период последовательности Фибоначчи по модулям вроде 10k невелико. Можно было получать из вхождений числа f в последовательность по модулю 10i получить вхождения по модулю 10(i + 1) подобно тому, как в авторском решении осуществляется переход от модуля ab к модулю 1013.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4673",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 13504
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #122 - Codeforces - Code 1",
          "code": ".##\n###\n##.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 2",
          "code": ".##\n###\n##.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 3",
          "code": "####\n##.#\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 4",
          "code": "####\n##.#\n..##\n..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 5",
          "code": "<--p--><-q-><---r---><--t-->\naaaaaaaaaaaaaaaaaaaaaaaaaaaa\nbbbbbbbbbbbbaaaaaaaaaaaaaaaa\naaaaaaabbbbbbbbbbbbbbaaaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 6",
          "code": "<--p--><-q-><---r---><--t-->\naaaaaaaaaaaaaaaaaaaaaaaaaaaa\nbbbbbbbbbbbbaaaaaaaaaaaaaaaa\naaaaaaabbbbbbbbbbbbbbaaaaaaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 7",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 8",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 9",
          "code": "3 3\n...\n.#.\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 10",
          "code": "3 3\n...\n.#.\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces - Code 1",
          "code": "if ((a + 1) mod 4 = 0) then\n        writeln(a + 1)\n      else\n        if ((a + 1) mod 2 = 0) then\n          writeln(2 * a + 1)\n        else\n          writeln(4 * a + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4673",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces - Code 2",
          "code": "if ((a + 1) mod 4 = 0) then\n        writeln(a + 1)\n      else\n        if ((a + 1) mod 2 = 0) then\n          writeln(2 * a + 1)\n        else\n          writeln(4 * a + 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4673",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #122 - Codeforces - Code 3",
          "code": "![ ](<тот самый URL>)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4673",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 10000, \"t\");\n    inf.readEoln();\n\n    vector<int> n = inf.readInts(t, 1, 1000000000, \"n_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 10000, \"t\");\n    inf.readEoln();\n\n    vector<int> n = inf.readInts(t, 1, 1000000000, \"n_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 10000, \"t\");\n    inf.readEoln();\n\n    vector<int> n = inf.readInts(t, 1, 1000000000, \"n_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n    long long n_min = opt<long long>(\"nmin\", 1);\n    long long n_max = opt<long long>(\"nmax\", 1e9);\n    long long n_constant = opt<long long>(\"n\", 1);\n\n    vector<long long> ns(t);\n\n    if (type == \"random\") {\n        for (int i = 0; i < t; ++i) {\n            ns[i] = rnd.next(n_min, n_max);\n        }\n    } else if (type == \"small\") {\n        for (int i = 0; i < t; ++i) {\n            ns[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < t; ++i) {\n            ns[i] = n_max;\n        }\n    } else if (type == \"ones\") {\n        for (int i = 0; i < t; ++i) {\n            ns[i] = 1;\n        }\n    } else if (type == \"same\") {\n        for (int i = 0; i < t; ++i) {\n            ns[i] = n_constant;\n        }\n    } else if (type == \"increment\") {\n        long long n = n_min;\n        for (int i = 0; i < t; ++i) {\n            ns[i] = n++;\n            if (n > n_max) n = n_min;\n        }\n    } else if (type == \"decrement\") {\n        long long n = n_max;\n        for (int i = 0; i < t; ++i) {\n            ns[i] = n--;\n            if (n < n_min) n = n_max;\n        }\n    } else if (type == \"special\") {\n        int idx = 0;\n        for (long long k = 1; idx < t; ++k) {\n            long long n = 4 * k - 1;\n            if (n >= n_min && n <= n_max) {\n                ns[idx++] = n;\n            }\n            if (n > n_max) {\n                break;\n            }\n        }\n        while (idx < t) {\n            ns[idx++] = rnd.next(n_min, n_max);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < t; ++i) {\n            ns[i] = rnd.next(n_min, n_max);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", t);\n    for (int i = 0; i < t; ++i) {\n        printf(\"%lld%c\", ns[i], i + 1 == t ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n    long long n_min = opt<long long>(\"nmin\", 1);\n    long long n_max = opt<long long>(\"nmax\", 1e9);\n    long long n_constant = opt<long long>(\"n\", 1);\n\n    vector<long long> ns(t);\n\n    if (type == \"random\") {\n        for (int i = 0; i < t; ++i) {\n            ns[i] = rnd.next(n_min, n_max);\n        }\n    } else if (type == \"small\") {\n        for (int i = 0; i < t; ++i) {\n            ns[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < t; ++i) {\n            ns[i] = n_max;\n        }\n    } else if (type == \"ones\") {\n        for (int i = 0; i < t; ++i) {\n            ns[i] = 1;\n        }\n    } else if (type == \"same\") {\n        for (int i = 0; i < t; ++i) {\n            ns[i] = n_constant;\n        }\n    } else if (type == \"increment\") {\n        long long n = n_min;\n        for (int i = 0; i < t; ++i) {\n            ns[i] = n++;\n            if (n > n_max) n = n_min;\n        }\n    } else if (type == \"decrement\") {\n        long long n = n_max;\n        for (int i = 0; i < t; ++i) {\n            ns[i] = n--;\n            if (n < n_min) n = n_max;\n        }\n    } else if (type == \"special\") {\n        int idx = 0;\n        for (long long k = 1; idx < t; ++k) {\n            long long n = 4 * k - 1;\n            if (n >= n_min && n <= n_max) {\n                ns[idx++] = n;\n            }\n            if (n > n_max) {\n                break;\n            }\n        }\n        while (idx < t) {\n            ns[idx++] = rnd.next(n_min, n_max);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < t; ++i) {\n            ns[i] = rnd.next(n_min, n_max);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", t);\n    for (int i = 0; i < t; ++i) {\n        printf(\"%lld%c\", ns[i], i + 1 == t ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -type small\n./gen -t 10 -type small\n./gen -t 10000 -type small\n\n./gen -t 1 -type max\n./gen -t 10000 -type max\n\n./gen -t 1 -type ones\n./gen -t 10000 -type ones\n\n./gen -t 1 -type same -n 123456789\n./gen -t 10000 -type same -n 123456789\n\n./gen -t 1 -type increment -nmin 1\n./gen -t 10000 -type increment -nmin 1 -nmax 1000000000\n\n./gen -t 1 -type decrement -nmax 1000000000\n./gen -t 10000 -type decrement -nmin 1 -nmax 1000000000\n\n./gen -t 1 -type special\n./gen -t 10 -type special\n./gen -t 10000 -type special\n\n./gen -t 10000 -type random -nmin 1 -nmax 100\n./gen -t 10000 -type random -nmin 1000000000 -nmax 1000000000\n\n./gen -t 10000 -type random -nmin 1 -nmax 1000000000\n\n./gen -t 5000 -type random -nmin 1 -nmax 1000000000\n./gen -t 5000 -type small\n./gen -t 5000 -type special\n\n./gen -t 1 -n 1\n./gen -t 1 -n 2\n./gen -t 1 -n 3\n./gen -t 1 -n 4\n./gen -t 1 -n 7\n./gen -t 1 -n 1000000000\n\n./gen -t 10000 -type random -nmin 999999000 -nmax 1000000000\n\n./gen -t 10000 -type random -nmin 1 -nmax 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:44.386944",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "194/C",
      "title": "C. Cutting Figure",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line contains two space-separated integers n and m (1 ≤ n, m ≤ 50) — the sizes of the sheet of paper. Each of the next n lines contains m characters — the description of the sheet of paper: the j-th character of the i-th line equals either \"#\", if the corresponding square is painted (belongs to set A), or equals \".\" if the corresponding square is not painted (does not belong to set A). It is guaranteed that the set of all painted squares A is connected and isn't empty.",
      "output_spec": "OutputOn the first line print the minimum number of squares that need to be deleted to make set A not connected. If it is impossible, print -1.",
      "sample_tests": "ExamplesInputCopy5 4#####..##..##..#####OutputCopy2InputCopy5 5######...#######...######OutputCopy2",
      "description": "C. Cutting Figure\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first input line contains two space-separated integers n and m (1 ≤ n, m ≤ 50) — the sizes of the sheet of paper. Each of the next n lines contains m characters — the description of the sheet of paper: the j-th character of the i-th line equals either \"#\", if the corresponding square is painted (belongs to set A), or equals \".\" if the corresponding square is not painted (does not belong to set A). It is guaranteed that the set of all painted squares A is connected and isn't empty.\n\nOutputOn the first line print the minimum number of squares that need to be deleted to make set A not connected. If it is impossible, print -1.\n\nInputCopy5 4#####..##..##..#####OutputCopy2InputCopy5 5######...#######...######OutputCopy2\n\nInputCopy5 4#####..##..##..#####\n\nOutputCopy2\n\nInputCopy5 5######...#######...######\n\nOutputCopy2\n\nNoteIn the first sample you can delete any two squares that do not share a side. After that the set of painted squares is not connected anymore.The note to the second sample is shown on the figure below. To the left there is a picture of the initial set of squares. To the right there is a set with deleted squares. The deleted squares are marked with crosses.",
      "solutions": [
        {
          "title": "Codeforces Round #122 - Codeforces",
          "content": "The upcoming contest is brought to you by me. My name is Arthur, I'm a student of Chelyabinsk lyceum 31.I am glad to thank Gerald for contest preparation management, Delinur for translation of statements, MikeMirzayanov for a really excellent system, dolphinigle for test-solving, proof-reading and much valuable advice, fdoer, grey_wind, Skird and alger95 for help in problem development.There is nothing more to say yet. As you can see, contest will be held in two divisions separately. The scoring system will be standard (not dynamic), but scores for tasks may be unusual (see update of this post).There won't be volume stories. I hope you will like the contest and its problemset and everything will be OK.UPD: Scores for tasks:Division 1: 500-1000-2000-2000-2500Division 2: 500-1000-1500-2000-3000UPD2: Congrats to winners =)Div1: Petr tourist yeputons peter50216 aram90 Div2: lucien tomasz.kociumaka sjynoi UPD3 some part of English editoral posted. You will find the remaining part of the editorial laterUPD4 English editoral was completed.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4671",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1048
        },
        {
          "title": "Editoral Codeforces Round #122 - Codeforces",
          "content": "Please, report me about every grammar mistake, you see. Thank you.Problem <>Let's notice that 2n ≤ k ≤ 5n. If k < 3n author has to get 2 on some exams. There are 3n - k such exams and that's the answer). If 3n ≤ k author will pass all exams (answer is 0).Problem <>Let the pencil move by the line and put crosses through every (n + 1) point. Lets associate every point on the line with point on square perimeter. Namely, point x on the line will be associated with point on square perimeter that we will reach if we move pencil around square to x clockwise. Then lower left corner will be associated with all points 4np for every non-negative integer p. Crosses will be associated with points k(n + 1) for some non-negative k. Nearest point of overlap of two families of points will be in point LCM(n + 1, 4n). Then we will put crosses.Problem \"Cutting Figure\"Translation by fdoerMain idea: using the fact that the answer cannot be greater than 2, check answer 1.Let's proof that the answer is not greater than 2. Let area of the figure be greater than 3. Let's examine the leftmost of all topmost squares. There is no neighbors left or up to it. So, number of its neighbors is not more than 2. Thus, if we delete its neighbors, we shall disconnect the figure. If the area is equal to 3, we always can disconnect the figure by deletion of one square. It can be proofed by considering all two primary cases. If the area is not greater than 2, there is no way to disconnect the figure.The algorithm: Check answer 1. We can simply brute-force the square to delete, and for each instance start dfs from any existing square. If during the dfs we visited not all of the remaining squares, we have found the square to delete. The answer is 1 if our bruteforce succeeded, and 2 otherwise.That was necessary to consider the case when there is no answer.The complexity of the described algorithm is O(n4). That was possible to search for articulation points and solve the problem in complexity O(n2), but in my opinion that required more time and effort.Problem <>Translation by fdoerMain idea: bruteforce in complexity O(Fun) where Fu if fibonacci number at position u.This problem had complex statements. We have an array a, and we can transform it in two ways. The goal was to maximize the sum of all its elements with given multipliers after exactly u operations. A simple bruteforce of all combinations of operations with subsequent modeling leads to complexity O(2u * nu), what is not fast enough. That was possible to optimize it by modeling parallel to recursive bruteforce. Now we have complexity O(2un). Actually, the correct solution is not too far from this algorithm.There is just one conjecture: every two successive xor operations change nothing, and we can move them to any place of the combination. Thus, it will be enough to bruteforce only combinations in which every pair of successive xor operations is at the end.It could be done using recoursive bruteforce. We must change in previous solution two things. First, we must n't put xor after xor. Besides that, we should update answer if number u - l is even, where l is current level of recoursion (all remaining operations in the end separates to pairs of xors).Let's calculate complexity of this algo. There are Fi sequences of length i without two consecutive xors. It's easy to proof, you can calculate some dp to see it. That's why, complexity of our algo is O(Fun). Problem \"Hamming distance\"Main idea: reduction to system of linear equations and solving it using Gauss algorithm.Let's notice that order of columns in answer doesn't matter. That's why there is only one important thing — quantity of every type of column. There is only 24 = 16 different columns. Let's represent Hamming distance between every pair of strings as sum of quantities of types of columns. It's possible because every column adds to every distance between pairs 0 or 1. Now we have system of 6 linear equations with 16 variables. It's not good, let's decrease number of variables. First, some columns adds same values to every Hamming distance. For example strings \"abbb\" and \"baaa\". For every column q we can replace all letters \"a\" by letters \"b\" and all letters \"b\" by letters \"a\" and reach column that adds same values to every distance. We reduced number of variables to 8. We also can notice that columns \"aaaa\" and \"bbbb\" is useless and reduce number of variables to 7.This system can be solved using Gauss algorithm. One variable steel be free. Let's fix it. It's value can't be more than maximum of h(si, sj) because column adds positive value to one or more Hamming distance. For every fixed value we should check if all variables take non-negative integer value and choose the best answer.We can solve system of equations in integers because coefficients of equation is little.Complexity of this solution if O(max(h(si, sj))). If we solve it in rational numbers complexity will change to .Problem \"Two segments\"Main idea: inverse the permutation and solve simplified problem (see below), consider function \"quantity of segments of permutation that form the given segment of natural series\".In order to solve this problem, we suggest solve another: <<we have a permutation pn, we have to calculate the count of segments such that their elements form one or two segments of natural series>>.If we solve the inverse problem for some permutation qn such that , we shall get the answer for the initial problem and initial permutation pi. Straight-forward algo: let's bruteforce the segment of permutation and mark its elements in a boolean array. Check that in that array there is not more than two marked segments. This algo has complexity O(n3).Let's notice that during the changeover from [l, r] to [l, r + 1] the quantity of segments changes in some predictable way. Let s([a, b]) be quantity of segments that form segment [a, b] of permutation. There are three cases (see picture below): If the new element pr + 1 is between two marked elements (that is, both elements with values pr + 1 - 1 and pr + 1 + 1 belong to segment [l, r]), then s([l, r + 1]) = s([l, r]) - 1. The new element will <> the segments near it. If the new element pr + 1 has only one neighbor with value belonging to [l, r], then s([l, r + 1]) = s([l, r]). The new element will lengthen one of existing segments. If there are no marked elements near pr + 1 the new element forms a new segment, s([l, r + 1]) = s([l, r]) + 1. The new element is red, elements that are marked to this moment are black.Improved algo: Let's bruteforce position of the left border and for each instance move the right border from left to right. During each move we shall recount the actual quantity of segments forming the current segment of permutation (s([l, r])). Now we have a solution in complexity O(n2). It works fast enough even when n = 20000. Obviously, that is not enough to get AC.Move on full solution. It is based on previous. Now we can calc s([l, r]) using s([l, r - 1]). Now we should look at way of changing s([l - 1, r]) as compared with s([l, r]). Let's move left border of segment from the right to left and support some data structure with s([l, i]) for every i satisfying l < i ≤ n and current l. This structure should answer queries \"count numbers 1 and 2 in structure\", that is count segments [l, i] that generates one or two segments in the original permutaton.Let Δi be s([l - 1, i]) - s([l, i]). Δl will be equal to 1 because one element form one segment in permutation (notice that in final answer we must not consider 1-element segments, that's why we must subtract n from answer in the end of solution). Δi determined by the number of neighbors of element l - 1 in the segment [l - 1, i]. Neighbors of l - 1 is elements pl - 1 + 1 and pl - 1 - 1 if they're exist. If l - 1 hasn't neighbors in this segment, Δi = 1, because l - 1 froms new 1-element segment. If l - 1 has one neighbor in this segment Δi = 0, because l - 1 join to existing segment of its neighbor. If l - 1 has two neighbors in this segment Δi =  - 1, because l - 1 connect segments of its neighbors. Number of neighbors in segment [l - 1, i] non-decreasing with increasing i. That's why Δi non-decreasing with increasing i. That means that there are only three segments of equivalence of Δi. We are interested only in neighbors of l - 1 which positions are right than l - 1. Let a is position of first neighbor, b is position of second neighbor, without loss of generality a < b. Then , , . (elements of permutation are numbered from 0). If a and b aren't exist, for all Δi = 1. If only b isn't exist for , for . Look at example to clear your understanding. (Δi is in top right corners, l = 3, pl = 5)Using this facts we can code data structure support following operations: Add +1 or -1 on segment Calc number of 1 and 2 in the structure. Sum of answers of structure in every iteration (for every l) is answer to problem.Let's notice that all numbers in structure will be positive. That's why elements 1 and 2 will be minimal of pre-minimal in the structure. Using this fact we can code segment tree, supports these operations.Complexity of this solution is .We also can code sqrt-decomposition and obtain complexity .Problem <>Translation by fdoerMain idea: baby-step-giant-step.In this problem we had some Fibonacci number modulo 1013 f, and we had to determine the position of its first occurence in Fibonacci sequence modulo 1013. Let a and b be two different coprime modula — divisors of 1013. Let F be the actual Fibonacci number such that . Then and . Find all occurences of number in Fibonacci sequence modulo a period. Find all occurences of number in Fibonacci sequence modulo b period. Let's fix a pair of such occurences. Let the occurence modulo a be in position i, and the occurence modulo b be in position j. Let t(m) be Fibonacci sequence modulo m period. From the Chinese Remainder Theorem, it follows that t(ab) = LCM(t(a), t(b)) (remember that a and b are coprime). Then from fixed occurences of f in periods of sequences modulo a and b we can recover the position of occurence of f in period of sequence modulo ab. It could be done by solving the following Diophantine equation: i + t(a) * x = j + t(b) * y. We can solve it using a simple bruteforce of one of the roots. If the occurence in sequence modulo ab period ( we have just found it) is u, then every occurence f in Fibonacci sequence modulo 1013 period can be represented as t(ab) * k + u. Then let's bruteforce k and find all occurences in sequence modulo 1013 period. To determine Fibonacci number on position α + t(ab) from known Fibonacci number on position α, we need to multiply the vector (Fα, Fα + 1) and some matrix. Let's choose a = 59 and b = 213. Note that there is no number that occur Fibonacci sequence modulo a or b period more than 8 times. That means that total count of pairs will never be greater than 64. For each occurence we'll bruteforce not more than numbers. That was the author's solution. Also that was possible to use the fact that for any number the count of its occurences in period of sequence modulo 10p (for any natural p) is not big more efficiently. From occurences in sequence modulo 10i period we could get occurences in sequence modulo 10i + 1 period using the method we use to jump from modulus ab to modulus 1013.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4673",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11337
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #122 - Codeforces - Code 1",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 2",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<string> grid;\nvector<vector<bool>> visited;\n\nvoid dfs(int i, int j) {\n    visited[i][j] = true;\n    int dx[4] = { -1, 0, 1, 0 };\n    int dy[4] = { 0, 1, 0, -1 };\n    for (int dir = 0; dir < 4; ++dir) {\n        int ni = i + dx[dir];\n        int nj = j + dy[dir];\n        if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n            if (!visited[ni][nj] && grid[ni][nj] == '#') {\n                dfs(ni, nj);\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    m = inf.readInt(1, 50, \"m\");\n    inf.readEoln();\n    grid.resize(n);\n    for (int i = 0; i < n; ++i) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].size()) == m, \"Length of line %d is not equal to m=%d\", i+1, m);\n        for (int j = 0; j < m; ++j) {\n            char c = grid[i][j];\n            ensuref(c == '#' || c == '.', \"Invalid character '%c' at position (%d,%d)\", c, i+1, j+1);\n        }\n    }\n    int painted_cells = 0;\n    int start_i = -1, start_j = -1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == '#') {\n                ++painted_cells;\n                if (start_i == -1) {\n                    start_i = i;\n                    start_j = j;\n                }\n            }\n        }\n    }\n    ensuref(painted_cells >= 1, \"Set A must not be empty\");\n    visited.assign(n, vector<bool>(m, false));\n    dfs(start_i, start_j);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == '#' && !visited[i][j]) {\n                quitf(_fail, \"Set A is not connected\");\n            }\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<string> grid;\nvector<vector<bool>> visited;\n\nvoid dfs(int i, int j) {\n    visited[i][j] = true;\n    int dx[4] = { -1, 0, 1, 0 };\n    int dy[4] = { 0, 1, 0, -1 };\n    for (int dir = 0; dir < 4; ++dir) {\n        int ni = i + dx[dir];\n        int nj = j + dy[dir];\n        if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n            if (!visited[ni][nj] && grid[ni][nj] == '#') {\n                dfs(ni, nj);\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    m = inf.readInt(1, 50, \"m\");\n    inf.readEoln();\n    grid.resize(n);\n    for (int i = 0; i < n; ++i) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].size()) == m, \"Length of line %d is not equal to m=%d\", i+1, m);\n        for (int j = 0; j < m; ++j) {\n            char c = grid[i][j];\n            ensuref(c == '#' || c == '.', \"Invalid character '%c' at position (%d,%d)\", c, i+1, j+1);\n        }\n    }\n    int painted_cells = 0;\n    int start_i = -1, start_j = -1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == '#') {\n                ++painted_cells;\n                if (start_i == -1) {\n                    start_i = i;\n                    start_j = j;\n                }\n            }\n        }\n    }\n    ensuref(painted_cells >= 1, \"Set A must not be empty\");\n    visited.assign(n, vector<bool>(m, false));\n    dfs(start_i, start_j);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == '#' && !visited[i][j]) {\n                quitf(_fail, \"Set A is not connected\");\n            }\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<string> grid;\nvector<vector<bool>> visited;\n\nvoid dfs(int i, int j) {\n    visited[i][j] = true;\n    int dx[4] = { -1, 0, 1, 0 };\n    int dy[4] = { 0, 1, 0, -1 };\n    for (int dir = 0; dir < 4; ++dir) {\n        int ni = i + dx[dir];\n        int nj = j + dy[dir];\n        if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n            if (!visited[ni][nj] && grid[ni][nj] == '#') {\n                dfs(ni, nj);\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    m = inf.readInt(1, 50, \"m\");\n    inf.readEoln();\n    grid.resize(n);\n    for (int i = 0; i < n; ++i) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].size()) == m, \"Length of line %d is not equal to m=%d\", i+1, m);\n        for (int j = 0; j < m; ++j) {\n            char c = grid[i][j];\n            ensuref(c == '#' || c == '.', \"Invalid character '%c' at position (%d,%d)\", c, i+1, j+1);\n        }\n    }\n    int painted_cells = 0;\n    int start_i = -1, start_j = -1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == '#') {\n                ++painted_cells;\n                if (start_i == -1) {\n                    start_i = i;\n                    start_j = j;\n                }\n            }\n        }\n    }\n    ensuref(painted_cells >= 1, \"Set A must not be empty\");\n    visited.assign(n, vector<bool>(m, false));\n    dfs(start_i, start_j);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == '#' && !visited[i][j]) {\n                quitf(_fail, \"Set A is not connected\");\n            }\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"full\") {\n        // Grid filled with '#'\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '#');\n        }\n    } else if (type == \"line\") {\n        // Draw a line\n        int x = rnd.next(n);\n        int y = rnd.next(m);\n        int dir = rnd.next(2); // 0: horizontal, 1: vertical\n\n        if (dir == 0) {\n            int len = rnd.next(1, m - y);\n            for (int i = 0; i < len; ++i) {\n                grid[x][y + i] = '#';\n            }\n        } else {\n            int len = rnd.next(1, n - x);\n            for (int i = 0; i < len; ++i) {\n                grid[x + i][y] = '#';\n            }\n        }\n\n    } else if (type == \"snake\") {\n        // Create a snake-like pattern\n        bool moveRight = true;\n        for (int i = 0; i < n; ++i) {\n            if (moveRight) {\n                for (int j = 0; j < m; ++j) {\n                    grid[i][j] = '#';\n                }\n            } else {\n                for (int j = m - 1; j >= 0; --j) {\n                    grid[i][j] = '#';\n                }\n            }\n            moveRight = !moveRight;\n        }\n    } else if (type == \"bridge\") {\n        // Create two blocks connected by one cell\n        int splitRow = rnd.next(1, n - 2);\n        for (int i = 0; i < splitRow; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '#');\n        }\n        for (int i = splitRow + 1; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '#');\n        }\n        // Connect the two blocks by one cell\n        grid[splitRow][rnd.next(m)] = '#';\n    } else if (type == \"impossible\") {\n        // Generate grid where it's impossible to disconnect A\n        // For example, grid with one or two adjacent squares\n        int x = rnd.next(n);\n        int y = rnd.next(m);\n        grid[x][y] = '#';\n        int adj = rnd.next(2);\n        if (adj == 1) { // Add an adjacent cell\n            int dx[] = {-1,0,1,0};\n            int dy[] = {0,1,0,-1};\n            vector<pair<int,int>> adj_cells;\n            for (int d = 0; d < 4; ++d) {\n                int nx = x + dx[d];\n                int ny = y + dy[d];\n                if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n                    adj_cells.push_back({nx, ny});\n                }\n            }\n            if (!adj_cells.empty()) {\n                pair<int,int> p = adj_cells[rnd.next(adj_cells.size())];\n                grid[p.first][p.second] = '#';\n            }\n        }\n    } else { // \"random\"\n        // Generate random connected grid\n        // Use BFS to expand randomly\n        queue<pair<int,int>> q;\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        int total_cells = rnd.next(1, n * m);\n\n        int x = rnd.next(n);\n        int y = rnd.next(m);\n\n        q.push({x, y});\n        visited[x][y] = true;\n        grid[x][y] = '#';\n        int painted_cells = 1;\n\n        int dx[] = {-1,0,1,0};\n        int dy[] = {0,1,0,-1};\n        while (!q.empty() && painted_cells < total_cells) {\n            auto [cx, cy] = q.front();\n            q.pop();\n            int dirs[] = {0,1,2,3};\n            shuffle(dirs, dirs + 4);\n            for (int i = 0; i < 4; ++i) {\n                int d = dirs[i];\n                int nx = cx + dx[d];\n                int ny = cy + dy[d];\n                if (0 <= nx && nx < n && 0 <= ny && ny < m && !visited[nx][ny]) {\n                    if (rnd.next(2) == 0) continue; // Randomly decide to paint or not\n                    visited[nx][ny] = true;\n                    grid[nx][ny] = '#';\n                    q.push({nx, ny});\n                    ++painted_cells;\n                    if (painted_cells >= total_cells) break;\n                }\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"full\") {\n        // Grid filled with '#'\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '#');\n        }\n    } else if (type == \"line\") {\n        // Draw a line\n        int x = rnd.next(n);\n        int y = rnd.next(m);\n        int dir = rnd.next(2); // 0: horizontal, 1: vertical\n\n        if (dir == 0) {\n            int len = rnd.next(1, m - y);\n            for (int i = 0; i < len; ++i) {\n                grid[x][y + i] = '#';\n            }\n        } else {\n            int len = rnd.next(1, n - x);\n            for (int i = 0; i < len; ++i) {\n                grid[x + i][y] = '#';\n            }\n        }\n\n    } else if (type == \"snake\") {\n        // Create a snake-like pattern\n        bool moveRight = true;\n        for (int i = 0; i < n; ++i) {\n            if (moveRight) {\n                for (int j = 0; j < m; ++j) {\n                    grid[i][j] = '#';\n                }\n            } else {\n                for (int j = m - 1; j >= 0; --j) {\n                    grid[i][j] = '#';\n                }\n            }\n            moveRight = !moveRight;\n        }\n    } else if (type == \"bridge\") {\n        // Create two blocks connected by one cell\n        int splitRow = rnd.next(1, n - 2);\n        for (int i = 0; i < splitRow; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '#');\n        }\n        for (int i = splitRow + 1; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '#');\n        }\n        // Connect the two blocks by one cell\n        grid[splitRow][rnd.next(m)] = '#';\n    } else if (type == \"impossible\") {\n        // Generate grid where it's impossible to disconnect A\n        // For example, grid with one or two adjacent squares\n        int x = rnd.next(n);\n        int y = rnd.next(m);\n        grid[x][y] = '#';\n        int adj = rnd.next(2);\n        if (adj == 1) { // Add an adjacent cell\n            int dx[] = {-1,0,1,0};\n            int dy[] = {0,1,0,-1};\n            vector<pair<int,int>> adj_cells;\n            for (int d = 0; d < 4; ++d) {\n                int nx = x + dx[d];\n                int ny = y + dy[d];\n                if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n                    adj_cells.push_back({nx, ny});\n                }\n            }\n            if (!adj_cells.empty()) {\n                pair<int,int> p = adj_cells[rnd.next(adj_cells.size())];\n                grid[p.first][p.second] = '#';\n            }\n        }\n    } else { // \"random\"\n        // Generate random connected grid\n        // Use BFS to expand randomly\n        queue<pair<int,int>> q;\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        int total_cells = rnd.next(1, n * m);\n\n        int x = rnd.next(n);\n        int y = rnd.next(m);\n\n        q.push({x, y});\n        visited[x][y] = true;\n        grid[x][y] = '#';\n        int painted_cells = 1;\n\n        int dx[] = {-1,0,1,0};\n        int dy[] = {0,1,0,-1};\n        while (!q.empty() && painted_cells < total_cells) {\n            auto [cx, cy] = q.front();\n            q.pop();\n            int dirs[] = {0,1,2,3};\n            shuffle(dirs, dirs + 4);\n            for (int i = 0; i < 4; ++i) {\n                int d = dirs[i];\n                int nx = cx + dx[d];\n                int ny = cy + dy[d];\n                if (0 <= nx && nx < n && 0 <= ny && ny < m && !visited[nx][ny]) {\n                    if (rnd.next(2) == 0) continue; // Randomly decide to paint or not\n                    visited[nx][ny] = true;\n                    grid[nx][ny] = '#';\n                    q.push({nx, ny});\n                    ++painted_cells;\n                    if (painted_cells >= total_cells) break;\n                }\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type impossible\n./gen -n 2 -m 2 -type impossible\n./gen -n 3 -m 3 -type line\n./gen -n 5 -m 5 -type full\n./gen -n 5 -m 5 -type line\n./gen -n 5 -m 5 -type bridge\n./gen -n 5 -m 5 -type snake\n./gen -n 5 -m 5 -type random\n\n./gen -n 10 -m 10 -type full\n./gen -n 10 -m 10 -type line\n./gen -n 10 -m 10 -type bridge\n./gen -n 10 -m 10 -type snake\n./gen -n 10 -m 10 -type random\n\n./gen -n 20 -m 20 -type full\n./gen -n 20 -m 20 -type line\n./gen -n 20 -m 20 -type bridge\n./gen -n 20 -m 20 -type snake\n./gen -n 20 -m 20 -type random\n\n./gen -n 30 -m 40 -type full\n./gen -n 30 -m 40 -type line\n./gen -n 30 -m 40 -type bridge\n./gen -n 30 -m 40 -type snake\n./gen -n 30 -m 40 -type random\n\n./gen -n 50 -m 50 -type full\n./gen -n 50 -m 50 -type line\n./gen -n 50 -m 50 -type bridge\n./gen -n 50 -m 50 -type snake\n./gen -n 50 -m 50 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:46.508643",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "194/D",
      "title": "D. Xor",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains space-separated integers n, u and r (1 ≤ n, u ≤ 30, 0 ≤ r ≤ 100) — the number of elements in each array, the number of operations and the number that describes one of the operations. Each of the next four lines contains n space-separated integers — arrays a, b, k, p. The first line has array a, the second line has array b, the third line has array k and the fourth one has array p. It is guaranteed that elements of arrays a and b are positive and do not exceed 104 (1 ≤ ai, bi ≤ 104), elements of array k do not exceed 104 in the absolute value (|k| ≤ 104) and p is a permutation of numbers from 1 to n.",
      "output_spec": "OutputOn a single line print number s — the maximum number of points that a player can win in John's game.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy3 2 17 7 78 8 81 2 31 3 2OutputCopy96InputCopy2 1 01 11 11 -11 2OutputCopy0",
      "description": "time limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains space-separated integers n, u and r (1 ≤ n, u ≤ 30, 0 ≤ r ≤ 100) — the number of elements in each array, the number of operations and the number that describes one of the operations. Each of the next four lines contains n space-separated integers — arrays a, b, k, p. The first line has array a, the second line has array b, the third line has array k and the fourth one has array p. It is guaranteed that elements of arrays a and b are positive and do not exceed 104 (1 ≤ ai, bi ≤ 104), elements of array k do not exceed 104 in the absolute value (|k| ≤ 104) and p is a permutation of numbers from 1 to n.\n\nOutputOn a single line print number s — the maximum number of points that a player can win in John's game.Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy3 2 17 7 78 8 81 2 31 3 2OutputCopy96InputCopy2 1 01 11 11 -11 2OutputCopy0\n\nInputCopy3 2 17 7 78 8 81 2 31 3 2\n\nOutputCopy96\n\nInputCopy2 1 01 11 11 -11 2\n\nOutputCopy0\n\nNoteIn the first sample you should first apply the operation of the first type, then the operation of the second type.",
      "solutions": [
        {
          "title": "Codeforces Round #122 - Codeforces",
          "content": "The upcoming contest is brought to you by me. My name is Arthur, I'm a student of Chelyabinsk lyceum 31.I am glad to thank Gerald for contest preparation management, Delinur for translation of statements, MikeMirzayanov for a really excellent system, dolphinigle for test-solving, proof-reading and much valuable advice, fdoer, grey_wind, Skird and alger95 for help in problem development.There is nothing more to say yet. As you can see, contest will be held in two divisions separately. The scoring system will be standard (not dynamic), but scores for tasks may be unusual (see update of this post).There won't be volume stories. I hope you will like the contest and its problemset and everything will be OK.UPD: Scores for tasks:Division 1: 500-1000-2000-2000-2500Division 2: 500-1000-1500-2000-3000UPD2: Congrats to winners =)Div1: Petr tourist yeputons peter50216 aram90 Div2: lucien tomasz.kociumaka sjynoi UPD3 some part of English editoral posted. You will find the remaining part of the editorial laterUPD4 English editoral was completed.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4671",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1048
        },
        {
          "title": "Editoral Codeforces Round #122 - Codeforces",
          "content": "Please, report me about every grammar mistake, you see. Thank you.Problem <>Let's notice that 2n ≤ k ≤ 5n. If k < 3n author has to get 2 on some exams. There are 3n - k such exams and that's the answer). If 3n ≤ k author will pass all exams (answer is 0).Problem <>Let the pencil move by the line and put crosses through every (n + 1) point. Lets associate every point on the line with point on square perimeter. Namely, point x on the line will be associated with point on square perimeter that we will reach if we move pencil around square to x clockwise. Then lower left corner will be associated with all points 4np for every non-negative integer p. Crosses will be associated with points k(n + 1) for some non-negative k. Nearest point of overlap of two families of points will be in point LCM(n + 1, 4n). Then we will put crosses.Problem \"Cutting Figure\"Translation by fdoerMain idea: using the fact that the answer cannot be greater than 2, check answer 1.Let's proof that the answer is not greater than 2. Let area of the figure be greater than 3. Let's examine the leftmost of all topmost squares. There is no neighbors left or up to it. So, number of its neighbors is not more than 2. Thus, if we delete its neighbors, we shall disconnect the figure. If the area is equal to 3, we always can disconnect the figure by deletion of one square. It can be proofed by considering all two primary cases. If the area is not greater than 2, there is no way to disconnect the figure.The algorithm: Check answer 1. We can simply brute-force the square to delete, and for each instance start dfs from any existing square. If during the dfs we visited not all of the remaining squares, we have found the square to delete. The answer is 1 if our bruteforce succeeded, and 2 otherwise.That was necessary to consider the case when there is no answer.The complexity of the described algorithm is O(n4). That was possible to search for articulation points and solve the problem in complexity O(n2), but in my opinion that required more time and effort.Problem <>Translation by fdoerMain idea: bruteforce in complexity O(Fun) where Fu if fibonacci number at position u.This problem had complex statements. We have an array a, and we can transform it in two ways. The goal was to maximize the sum of all its elements with given multipliers after exactly u operations. A simple bruteforce of all combinations of operations with subsequent modeling leads to complexity O(2u * nu), what is not fast enough. That was possible to optimize it by modeling parallel to recursive bruteforce. Now we have complexity O(2un). Actually, the correct solution is not too far from this algorithm.There is just one conjecture: every two successive xor operations change nothing, and we can move them to any place of the combination. Thus, it will be enough to bruteforce only combinations in which every pair of successive xor operations is at the end.It could be done using recoursive bruteforce. We must change in previous solution two things. First, we must n't put xor after xor. Besides that, we should update answer if number u - l is even, where l is current level of recoursion (all remaining operations in the end separates to pairs of xors).Let's calculate complexity of this algo. There are Fi sequences of length i without two consecutive xors. It's easy to proof, you can calculate some dp to see it. That's why, complexity of our algo is O(Fun). Problem \"Hamming distance\"Main idea: reduction to system of linear equations and solving it using Gauss algorithm.Let's notice that order of columns in answer doesn't matter. That's why there is only one important thing — quantity of every type of column. There is only 24 = 16 different columns. Let's represent Hamming distance between every pair of strings as sum of quantities of types of columns. It's possible because every column adds to every distance between pairs 0 or 1. Now we have system of 6 linear equations with 16 variables. It's not good, let's decrease number of variables. First, some columns adds same values to every Hamming distance. For example strings \"abbb\" and \"baaa\". For every column q we can replace all letters \"a\" by letters \"b\" and all letters \"b\" by letters \"a\" and reach column that adds same values to every distance. We reduced number of variables to 8. We also can notice that columns \"aaaa\" and \"bbbb\" is useless and reduce number of variables to 7.This system can be solved using Gauss algorithm. One variable steel be free. Let's fix it. It's value can't be more than maximum of h(si, sj) because column adds positive value to one or more Hamming distance. For every fixed value we should check if all variables take non-negative integer value and choose the best answer.We can solve system of equations in integers because coefficients of equation is little.Complexity of this solution if O(max(h(si, sj))). If we solve it in rational numbers complexity will change to .Problem \"Two segments\"Main idea: inverse the permutation and solve simplified problem (see below), consider function \"quantity of segments of permutation that form the given segment of natural series\".In order to solve this problem, we suggest solve another: <<we have a permutation pn, we have to calculate the count of segments such that their elements form one or two segments of natural series>>.If we solve the inverse problem for some permutation qn such that , we shall get the answer for the initial problem and initial permutation pi. Straight-forward algo: let's bruteforce the segment of permutation and mark its elements in a boolean array. Check that in that array there is not more than two marked segments. This algo has complexity O(n3).Let's notice that during the changeover from [l, r] to [l, r + 1] the quantity of segments changes in some predictable way. Let s([a, b]) be quantity of segments that form segment [a, b] of permutation. There are three cases (see picture below): If the new element pr + 1 is between two marked elements (that is, both elements with values pr + 1 - 1 and pr + 1 + 1 belong to segment [l, r]), then s([l, r + 1]) = s([l, r]) - 1. The new element will <> the segments near it. If the new element pr + 1 has only one neighbor with value belonging to [l, r], then s([l, r + 1]) = s([l, r]). The new element will lengthen one of existing segments. If there are no marked elements near pr + 1 the new element forms a new segment, s([l, r + 1]) = s([l, r]) + 1. The new element is red, elements that are marked to this moment are black.Improved algo: Let's bruteforce position of the left border and for each instance move the right border from left to right. During each move we shall recount the actual quantity of segments forming the current segment of permutation (s([l, r])). Now we have a solution in complexity O(n2). It works fast enough even when n = 20000. Obviously, that is not enough to get AC.Move on full solution. It is based on previous. Now we can calc s([l, r]) using s([l, r - 1]). Now we should look at way of changing s([l - 1, r]) as compared with s([l, r]). Let's move left border of segment from the right to left and support some data structure with s([l, i]) for every i satisfying l < i ≤ n and current l. This structure should answer queries \"count numbers 1 and 2 in structure\", that is count segments [l, i] that generates one or two segments in the original permutaton.Let Δi be s([l - 1, i]) - s([l, i]). Δl will be equal to 1 because one element form one segment in permutation (notice that in final answer we must not consider 1-element segments, that's why we must subtract n from answer in the end of solution). Δi determined by the number of neighbors of element l - 1 in the segment [l - 1, i]. Neighbors of l - 1 is elements pl - 1 + 1 and pl - 1 - 1 if they're exist. If l - 1 hasn't neighbors in this segment, Δi = 1, because l - 1 froms new 1-element segment. If l - 1 has one neighbor in this segment Δi = 0, because l - 1 join to existing segment of its neighbor. If l - 1 has two neighbors in this segment Δi =  - 1, because l - 1 connect segments of its neighbors. Number of neighbors in segment [l - 1, i] non-decreasing with increasing i. That's why Δi non-decreasing with increasing i. That means that there are only three segments of equivalence of Δi. We are interested only in neighbors of l - 1 which positions are right than l - 1. Let a is position of first neighbor, b is position of second neighbor, without loss of generality a < b. Then , , . (elements of permutation are numbered from 0). If a and b aren't exist, for all Δi = 1. If only b isn't exist for , for . Look at example to clear your understanding. (Δi is in top right corners, l = 3, pl = 5)Using this facts we can code data structure support following operations: Add +1 or -1 on segment Calc number of 1 and 2 in the structure. Sum of answers of structure in every iteration (for every l) is answer to problem.Let's notice that all numbers in structure will be positive. That's why elements 1 and 2 will be minimal of pre-minimal in the structure. Using this fact we can code segment tree, supports these operations.Complexity of this solution is .We also can code sqrt-decomposition and obtain complexity .Problem <>Translation by fdoerMain idea: baby-step-giant-step.In this problem we had some Fibonacci number modulo 1013 f, and we had to determine the position of its first occurence in Fibonacci sequence modulo 1013. Let a and b be two different coprime modula — divisors of 1013. Let F be the actual Fibonacci number such that . Then and . Find all occurences of number in Fibonacci sequence modulo a period. Find all occurences of number in Fibonacci sequence modulo b period. Let's fix a pair of such occurences. Let the occurence modulo a be in position i, and the occurence modulo b be in position j. Let t(m) be Fibonacci sequence modulo m period. From the Chinese Remainder Theorem, it follows that t(ab) = LCM(t(a), t(b)) (remember that a and b are coprime). Then from fixed occurences of f in periods of sequences modulo a and b we can recover the position of occurence of f in period of sequence modulo ab. It could be done by solving the following Diophantine equation: i + t(a) * x = j + t(b) * y. We can solve it using a simple bruteforce of one of the roots. If the occurence in sequence modulo ab period ( we have just found it) is u, then every occurence f in Fibonacci sequence modulo 1013 period can be represented as t(ab) * k + u. Then let's bruteforce k and find all occurences in sequence modulo 1013 period. To determine Fibonacci number on position α + t(ab) from known Fibonacci number on position α, we need to multiply the vector (Fα, Fα + 1) and some matrix. Let's choose a = 59 and b = 213. Note that there is no number that occur Fibonacci sequence modulo a or b period more than 8 times. That means that total count of pairs will never be greater than 64. For each occurence we'll bruteforce not more than numbers. That was the author's solution. Also that was possible to use the fact that for any number the count of its occurences in period of sequence modulo 10p (for any natural p) is not big more efficiently. From occurences in sequence modulo 10i period we could get occurences in sequence modulo 10i + 1 period using the method we use to jump from modulus ab to modulus 1013.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4673",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11337
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #122 - Codeforces - Code 1",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 2",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 30, \"n\");\n    inf.readSpace();\n    int u = inf.readInt(1, 30, \"u\");\n    inf.readSpace();\n    int r = inf.readInt(0, 100, \"r\");\n    inf.readEoln();\n    \n    // Read array a\n    vector<int> a = inf.readInts(n, 1, 10000, \"a\");\n    inf.readEoln();\n    \n    // Read array b\n    vector<int> b = inf.readInts(n, 1, 10000, \"b\");\n    inf.readEoln();\n    \n    // Read array k\n    vector<int> k = inf.readInts(n, -10000, 10000, \"k\");\n    inf.readEoln();\n    \n    // Read array p\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n    \n    // Check that p is a permutation of numbers from 1 to n\n    vector<bool> used(n + 1, false); // indexing from 1 to n\n    for (int i = 0; i < n; i++) {\n        int val = p[i];\n        if (used[val]) {\n            quitf(_fail, \"p is not a permutation, value %d appears more than once\", val);\n        }\n        used[val] = true;\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 30, \"n\");\n    inf.readSpace();\n    int u = inf.readInt(1, 30, \"u\");\n    inf.readSpace();\n    int r = inf.readInt(0, 100, \"r\");\n    inf.readEoln();\n    \n    // Read array a\n    vector<int> a = inf.readInts(n, 1, 10000, \"a\");\n    inf.readEoln();\n    \n    // Read array b\n    vector<int> b = inf.readInts(n, 1, 10000, \"b\");\n    inf.readEoln();\n    \n    // Read array k\n    vector<int> k = inf.readInts(n, -10000, 10000, \"k\");\n    inf.readEoln();\n    \n    // Read array p\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n    \n    // Check that p is a permutation of numbers from 1 to n\n    vector<bool> used(n + 1, false); // indexing from 1 to n\n    for (int i = 0; i < n; i++) {\n        int val = p[i];\n        if (used[val]) {\n            quitf(_fail, \"p is not a permutation, value %d appears more than once\", val);\n        }\n        used[val] = true;\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 30, \"n\");\n    inf.readSpace();\n    int u = inf.readInt(1, 30, \"u\");\n    inf.readSpace();\n    int r = inf.readInt(0, 100, \"r\");\n    inf.readEoln();\n    \n    // Read array a\n    vector<int> a = inf.readInts(n, 1, 10000, \"a\");\n    inf.readEoln();\n    \n    // Read array b\n    vector<int> b = inf.readInts(n, 1, 10000, \"b\");\n    inf.readEoln();\n    \n    // Read array k\n    vector<int> k = inf.readInts(n, -10000, 10000, \"k\");\n    inf.readEoln();\n    \n    // Read array p\n    vector<int> p = inf.readInts(n, 1, n, \"p\");\n    inf.readEoln();\n    \n    // Check that p is a permutation of numbers from 1 to n\n    vector<bool> used(n + 1, false); // indexing from 1 to n\n    for (int i = 0; i < n; i++) {\n        int val = p[i];\n        if (used[val]) {\n            quitf(_fail, \"p is not a permutation, value %d appears more than once\", val);\n        }\n        used[val] = true;\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int u = opt<int>(\"u\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a, b, k, p;\n\n    if (type == \"minimal\") {\n        n = 1; // Force n to be 1\n        u = opt<int>(\"u\", 0);\n        r = opt<int>(\"r\", 0);\n    } else if (type == \"maximal\") {\n        n = 30; // Force n to be 30\n        u = opt<int>(\"u\", 30);\n        r = opt<int>(\"r\", 100);\n    }\n\n    a.resize(n);\n    b.resize(n);\n    k.resize(n);\n    p.resize(n);\n\n    if (type == \"random\" || type == \"maximal\" || type == \"minimal\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            if (k[i] == 0) k[i] = 1; // Avoid zero\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"all_same_a_b\") {\n        int val = 10000;\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            b[i] = val;\n            k[i] = rnd.next(-10000, 10000);\n            if (k[i] == 0) k[i] = 1;\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"k_negative\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = -rnd.next(1, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"k_positive\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(1, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"k_mixed\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            if (k[i] == 0) k[i] = 1;\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"p_identity\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            if (k[i] == 0) k[i] = 1;\n            p[i] = i + 1;\n        }\n    } else if (type == \"p_reverse\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            if (k[i] == 0) k[i] = 1;\n            p[i] = n - i;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            if (k[i] == 0) k[i] = 1;\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    }\n\n    // Output n, u, r\n    printf(\"%d %d %d\\n\", n, u, r);\n\n    // Output array a\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], \" \\n\"[i + 1 == n]);\n\n    // Output array b\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", b[i], \" \\n\"[i + 1 == n]);\n\n    // Output array k\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", k[i], \" \\n\"[i + 1 == n]);\n\n    // Output array p\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", p[i], \" \\n\"[i + 1 == n]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int u = opt<int>(\"u\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a, b, k, p;\n\n    if (type == \"minimal\") {\n        n = 1; // Force n to be 1\n        u = opt<int>(\"u\", 0);\n        r = opt<int>(\"r\", 0);\n    } else if (type == \"maximal\") {\n        n = 30; // Force n to be 30\n        u = opt<int>(\"u\", 30);\n        r = opt<int>(\"r\", 100);\n    }\n\n    a.resize(n);\n    b.resize(n);\n    k.resize(n);\n    p.resize(n);\n\n    if (type == \"random\" || type == \"maximal\" || type == \"minimal\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            if (k[i] == 0) k[i] = 1; // Avoid zero\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"all_same_a_b\") {\n        int val = 10000;\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n            b[i] = val;\n            k[i] = rnd.next(-10000, 10000);\n            if (k[i] == 0) k[i] = 1;\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"k_negative\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = -rnd.next(1, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"k_positive\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(1, 10000);\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"k_mixed\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            if (k[i] == 0) k[i] = 1;\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    } else if (type == \"p_identity\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            if (k[i] == 0) k[i] = 1;\n            p[i] = i + 1;\n        }\n    } else if (type == \"p_reverse\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            if (k[i] == 0) k[i] = 1;\n            p[i] = n - i;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10000);\n            b[i] = rnd.next(1, 10000);\n            k[i] = rnd.next(-10000, 10000);\n            if (k[i] == 0) k[i] = 1;\n            p[i] = i + 1;\n        }\n        shuffle(p.begin(), p.end());\n    }\n\n    // Output n, u, r\n    printf(\"%d %d %d\\n\", n, u, r);\n\n    // Output array a\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], \" \\n\"[i + 1 == n]);\n\n    // Output array b\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", b[i], \" \\n\"[i + 1 == n]);\n\n    // Output array k\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", k[i], \" \\n\"[i + 1 == n]);\n\n    // Output array p\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", p[i], \" \\n\"[i + 1 == n]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -u 0 -r 0 -type minimal\n./gen -n 1 -u 30 -r 100 -type minimal\n./gen -n 1 -u 15 -r 50 -type minimal\n./gen -n 2 -u 1 -r 0 -type random\n./gen -n 3 -u 2 -r 1 -type random\n./gen -n 5 -u 5 -r 5 -type random\n./gen -n 10 -u 10 -r 10 -type random\n./gen -n 15 -u 15 -r 50 -type random\n./gen -n 20 -u 20 -r 0 -type random\n./gen -n 25 -u 15 -r 50 -type random\n./gen -n 30 -u 0 -r 0 -type random\n./gen -n 30 -u 1 -r 100 -type random\n./gen -n 30 -u 15 -r 50 -type random\n./gen -n 30 -u 29 -r 99 -type random\n./gen -n 30 -u 30 -r 0 -type random\n./gen -n 30 -u 30 -r 0 -type k_negative\n./gen -n 30 -u 30 -r 0 -type k_positive\n./gen -n 30 -u 30 -r 0 -type k_mixed\n./gen -n 30 -u 30 -r 0 -type p_identity\n./gen -n 30 -u 30 -r 0 -type p_reverse\n./gen -n 30 -u 30 -r 0 -type all_same_a_b\n./gen -n 30 -u 30 -r 0 -type maximal\n./gen -n 30 -u 30 -r 100 -type maximal\n./gen -n 30 -u 15 -r 50 -type maximal\n./gen -n 30 -u 0 -r 50 -type random\n./gen -n 30 -u 15 -r 50 -type random\n./gen -n 30 -u 30 -r 50 -type random\n./gen -n 30 -u 30 -r 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:48.539265",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "194/E",
      "title": "E. Hamming Distance",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains space-separated integers h(s1, s2), h(s1, s3), h(s1, s4). The second line contains space-separated integers h(s2, s3) and h(s2, s4). The third line contains the single integer h(s3, s4).All given integers h(si, sj) are non-negative and do not exceed 105. It is guaranteed that at least one number h(si, sj) is positive.",
      "output_spec": "OutputPrint -1 if there's no suitable set of strings.Otherwise print on the first line number len — the length of each string. On the i-th of the next four lines print string s'i. If there are multiple sets with the minimum length of the strings, print any of them.",
      "sample_tests": "ExamplesInputCopy4 4 44 44OutputCopy6aaaabbaabbaabbaaaabbbbbb",
      "description": "E. Hamming Distance\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains space-separated integers h(s1, s2), h(s1, s3), h(s1, s4). The second line contains space-separated integers h(s2, s3) and h(s2, s4). The third line contains the single integer h(s3, s4).All given integers h(si, sj) are non-negative and do not exceed 105. It is guaranteed that at least one number h(si, sj) is positive.\n\nOutputPrint -1 if there's no suitable set of strings.Otherwise print on the first line number len — the length of each string. On the i-th of the next four lines print string s'i. If there are multiple sets with the minimum length of the strings, print any of them.\n\nInputCopy4 4 44 44OutputCopy6aaaabbaabbaabbaaaabbbbbb\n\nInputCopy4 4 44 44\n\nOutputCopy6aaaabbaabbaabbaaaabbbbbb",
      "solutions": [
        {
          "title": "Codeforces Round #122 - Codeforces",
          "content": "The upcoming contest is brought to you by me. My name is Arthur, I'm a student of Chelyabinsk lyceum 31.I am glad to thank Gerald for contest preparation management, Delinur for translation of statements, MikeMirzayanov for a really excellent system, dolphinigle for test-solving, proof-reading and much valuable advice, fdoer, grey_wind, Skird and alger95 for help in problem development.There is nothing more to say yet. As you can see, contest will be held in two divisions separately. The scoring system will be standard (not dynamic), but scores for tasks may be unusual (see update of this post).There won't be volume stories. I hope you will like the contest and its problemset and everything will be OK.UPD: Scores for tasks:Division 1: 500-1000-2000-2000-2500Division 2: 500-1000-1500-2000-3000UPD2: Congrats to winners =)Div1: Petr tourist yeputons peter50216 aram90 Div2: lucien tomasz.kociumaka sjynoi UPD3 some part of English editoral posted. You will find the remaining part of the editorial laterUPD4 English editoral was completed.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4671",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1048
        },
        {
          "title": "Editoral Codeforces Round #122 - Codeforces",
          "content": "Please, report me about every grammar mistake, you see. Thank you.Problem <>Let's notice that 2n ≤ k ≤ 5n. If k < 3n author has to get 2 on some exams. There are 3n - k such exams and that's the answer). If 3n ≤ k author will pass all exams (answer is 0).Problem <>Let the pencil move by the line and put crosses through every (n + 1) point. Lets associate every point on the line with point on square perimeter. Namely, point x on the line will be associated with point on square perimeter that we will reach if we move pencil around square to x clockwise. Then lower left corner will be associated with all points 4np for every non-negative integer p. Crosses will be associated with points k(n + 1) for some non-negative k. Nearest point of overlap of two families of points will be in point LCM(n + 1, 4n). Then we will put crosses.Problem \"Cutting Figure\"Translation by fdoerMain idea: using the fact that the answer cannot be greater than 2, check answer 1.Let's proof that the answer is not greater than 2. Let area of the figure be greater than 3. Let's examine the leftmost of all topmost squares. There is no neighbors left or up to it. So, number of its neighbors is not more than 2. Thus, if we delete its neighbors, we shall disconnect the figure. If the area is equal to 3, we always can disconnect the figure by deletion of one square. It can be proofed by considering all two primary cases. If the area is not greater than 2, there is no way to disconnect the figure.The algorithm: Check answer 1. We can simply brute-force the square to delete, and for each instance start dfs from any existing square. If during the dfs we visited not all of the remaining squares, we have found the square to delete. The answer is 1 if our bruteforce succeeded, and 2 otherwise.That was necessary to consider the case when there is no answer.The complexity of the described algorithm is O(n4). That was possible to search for articulation points and solve the problem in complexity O(n2), but in my opinion that required more time and effort.Problem <>Translation by fdoerMain idea: bruteforce in complexity O(Fun) where Fu if fibonacci number at position u.This problem had complex statements. We have an array a, and we can transform it in two ways. The goal was to maximize the sum of all its elements with given multipliers after exactly u operations. A simple bruteforce of all combinations of operations with subsequent modeling leads to complexity O(2u * nu), what is not fast enough. That was possible to optimize it by modeling parallel to recursive bruteforce. Now we have complexity O(2un). Actually, the correct solution is not too far from this algorithm.There is just one conjecture: every two successive xor operations change nothing, and we can move them to any place of the combination. Thus, it will be enough to bruteforce only combinations in which every pair of successive xor operations is at the end.It could be done using recoursive bruteforce. We must change in previous solution two things. First, we must n't put xor after xor. Besides that, we should update answer if number u - l is even, where l is current level of recoursion (all remaining operations in the end separates to pairs of xors).Let's calculate complexity of this algo. There are Fi sequences of length i without two consecutive xors. It's easy to proof, you can calculate some dp to see it. That's why, complexity of our algo is O(Fun). Problem \"Hamming distance\"Main idea: reduction to system of linear equations and solving it using Gauss algorithm.Let's notice that order of columns in answer doesn't matter. That's why there is only one important thing — quantity of every type of column. There is only 24 = 16 different columns. Let's represent Hamming distance between every pair of strings as sum of quantities of types of columns. It's possible because every column adds to every distance between pairs 0 or 1. Now we have system of 6 linear equations with 16 variables. It's not good, let's decrease number of variables. First, some columns adds same values to every Hamming distance. For example strings \"abbb\" and \"baaa\". For every column q we can replace all letters \"a\" by letters \"b\" and all letters \"b\" by letters \"a\" and reach column that adds same values to every distance. We reduced number of variables to 8. We also can notice that columns \"aaaa\" and \"bbbb\" is useless and reduce number of variables to 7.This system can be solved using Gauss algorithm. One variable steel be free. Let's fix it. It's value can't be more than maximum of h(si, sj) because column adds positive value to one or more Hamming distance. For every fixed value we should check if all variables take non-negative integer value and choose the best answer.We can solve system of equations in integers because coefficients of equation is little.Complexity of this solution if O(max(h(si, sj))). If we solve it in rational numbers complexity will change to .Problem \"Two segments\"Main idea: inverse the permutation and solve simplified problem (see below), consider function \"quantity of segments of permutation that form the given segment of natural series\".In order to solve this problem, we suggest solve another: <<we have a permutation pn, we have to calculate the count of segments such that their elements form one or two segments of natural series>>.If we solve the inverse problem for some permutation qn such that , we shall get the answer for the initial problem and initial permutation pi. Straight-forward algo: let's bruteforce the segment of permutation and mark its elements in a boolean array. Check that in that array there is not more than two marked segments. This algo has complexity O(n3).Let's notice that during the changeover from [l, r] to [l, r + 1] the quantity of segments changes in some predictable way. Let s([a, b]) be quantity of segments that form segment [a, b] of permutation. There are three cases (see picture below): If the new element pr + 1 is between two marked elements (that is, both elements with values pr + 1 - 1 and pr + 1 + 1 belong to segment [l, r]), then s([l, r + 1]) = s([l, r]) - 1. The new element will <> the segments near it. If the new element pr + 1 has only one neighbor with value belonging to [l, r], then s([l, r + 1]) = s([l, r]). The new element will lengthen one of existing segments. If there are no marked elements near pr + 1 the new element forms a new segment, s([l, r + 1]) = s([l, r]) + 1. The new element is red, elements that are marked to this moment are black.Improved algo: Let's bruteforce position of the left border and for each instance move the right border from left to right. During each move we shall recount the actual quantity of segments forming the current segment of permutation (s([l, r])). Now we have a solution in complexity O(n2). It works fast enough even when n = 20000. Obviously, that is not enough to get AC.Move on full solution. It is based on previous. Now we can calc s([l, r]) using s([l, r - 1]). Now we should look at way of changing s([l - 1, r]) as compared with s([l, r]). Let's move left border of segment from the right to left and support some data structure with s([l, i]) for every i satisfying l < i ≤ n and current l. This structure should answer queries \"count numbers 1 and 2 in structure\", that is count segments [l, i] that generates one or two segments in the original permutaton.Let Δi be s([l - 1, i]) - s([l, i]). Δl will be equal to 1 because one element form one segment in permutation (notice that in final answer we must not consider 1-element segments, that's why we must subtract n from answer in the end of solution). Δi determined by the number of neighbors of element l - 1 in the segment [l - 1, i]. Neighbors of l - 1 is elements pl - 1 + 1 and pl - 1 - 1 if they're exist. If l - 1 hasn't neighbors in this segment, Δi = 1, because l - 1 froms new 1-element segment. If l - 1 has one neighbor in this segment Δi = 0, because l - 1 join to existing segment of its neighbor. If l - 1 has two neighbors in this segment Δi =  - 1, because l - 1 connect segments of its neighbors. Number of neighbors in segment [l - 1, i] non-decreasing with increasing i. That's why Δi non-decreasing with increasing i. That means that there are only three segments of equivalence of Δi. We are interested only in neighbors of l - 1 which positions are right than l - 1. Let a is position of first neighbor, b is position of second neighbor, without loss of generality a < b. Then , , . (elements of permutation are numbered from 0). If a and b aren't exist, for all Δi = 1. If only b isn't exist for , for . Look at example to clear your understanding. (Δi is in top right corners, l = 3, pl = 5)Using this facts we can code data structure support following operations: Add +1 or -1 on segment Calc number of 1 and 2 in the structure. Sum of answers of structure in every iteration (for every l) is answer to problem.Let's notice that all numbers in structure will be positive. That's why elements 1 and 2 will be minimal of pre-minimal in the structure. Using this fact we can code segment tree, supports these operations.Complexity of this solution is .We also can code sqrt-decomposition and obtain complexity .Problem <>Translation by fdoerMain idea: baby-step-giant-step.In this problem we had some Fibonacci number modulo 1013 f, and we had to determine the position of its first occurence in Fibonacci sequence modulo 1013. Let a and b be two different coprime modula — divisors of 1013. Let F be the actual Fibonacci number such that . Then and . Find all occurences of number in Fibonacci sequence modulo a period. Find all occurences of number in Fibonacci sequence modulo b period. Let's fix a pair of such occurences. Let the occurence modulo a be in position i, and the occurence modulo b be in position j. Let t(m) be Fibonacci sequence modulo m period. From the Chinese Remainder Theorem, it follows that t(ab) = LCM(t(a), t(b)) (remember that a and b are coprime). Then from fixed occurences of f in periods of sequences modulo a and b we can recover the position of occurence of f in period of sequence modulo ab. It could be done by solving the following Diophantine equation: i + t(a) * x = j + t(b) * y. We can solve it using a simple bruteforce of one of the roots. If the occurence in sequence modulo ab period ( we have just found it) is u, then every occurence f in Fibonacci sequence modulo 1013 period can be represented as t(ab) * k + u. Then let's bruteforce k and find all occurences in sequence modulo 1013 period. To determine Fibonacci number on position α + t(ab) from known Fibonacci number on position α, we need to multiply the vector (Fα, Fα + 1) and some matrix. Let's choose a = 59 and b = 213. Note that there is no number that occur Fibonacci sequence modulo a or b period more than 8 times. That means that total count of pairs will never be greater than 64. For each occurence we'll bruteforce not more than numbers. That was the author's solution. Also that was possible to use the fact that for any number the count of its occurences in period of sequence modulo 10p (for any natural p) is not big more efficiently. From occurences in sequence modulo 10i period we could get occurences in sequence modulo 10i + 1 period using the method we use to jump from modulus ab to modulus 1013.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4673",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 11337
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #122 - Codeforces - Code 1",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #122 - Codeforces - Code 2",
          "code": "k1 * [ 0; 0; 1; 0; 1; 1 ]\n+ k2 * [ 0; 1; 0; 1; 0; 1 ]\n+ k3 * [ 0; 1; 1; 1; 1; 0 ]\n+ k4 * [ 1; 0; 0; 1; 1; 1 ]\n+ k5 * [ 1; 0; 1; 1; 0; 1 ]\n+ k6 * [ 1; 1; 0; 0; 1; 1 ]\n+ k7 * [ 1; 1; 1; 0; 0; 0 ]\n===========================\n       [ a; b; c; d; e; f ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4671",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read first line: h(s1, s2), h(s1, s3), h(s1, s4)\n    int h12 = inf.readInt(0, 100000, \"h(s1,s2)\");\n    inf.readSpace();\n    int h13 = inf.readInt(0, 100000, \"h(s1,s3)\");\n    inf.readSpace();\n    int h14 = inf.readInt(0, 100000, \"h(s1,s4)\");\n    inf.readEoln();\n\n    // Read second line: h(s2, s3), h(s2, s4)\n    int h23 = inf.readInt(0, 100000, \"h(s2,s3)\");\n    inf.readSpace();\n    int h24 = inf.readInt(0, 100000, \"h(s2,s4)\");\n    inf.readEoln();\n\n    // Read third line: h(s3, s4)\n    int h34 = inf.readInt(0, 100000, \"h(s3,s4)\");\n    inf.readEoln();\n\n    // Ensure at least one h(si, sj) is positive\n    bool atLeastOnePositive = (h12 > 0 || h13 > 0 || h14 > 0 || h23 > 0 || h24 > 0 || h34 > 0);\n    ensuref(atLeastOnePositive, \"At least one h(si, sj) must be positive\");\n\n    // Ensure EOF is reached\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read first line: h(s1, s2), h(s1, s3), h(s1, s4)\n    int h12 = inf.readInt(0, 100000, \"h(s1,s2)\");\n    inf.readSpace();\n    int h13 = inf.readInt(0, 100000, \"h(s1,s3)\");\n    inf.readSpace();\n    int h14 = inf.readInt(0, 100000, \"h(s1,s4)\");\n    inf.readEoln();\n\n    // Read second line: h(s2, s3), h(s2, s4)\n    int h23 = inf.readInt(0, 100000, \"h(s2,s3)\");\n    inf.readSpace();\n    int h24 = inf.readInt(0, 100000, \"h(s2,s4)\");\n    inf.readEoln();\n\n    // Read third line: h(s3, s4)\n    int h34 = inf.readInt(0, 100000, \"h(s3,s4)\");\n    inf.readEoln();\n\n    // Ensure at least one h(si, sj) is positive\n    bool atLeastOnePositive = (h12 > 0 || h13 > 0 || h14 > 0 || h23 > 0 || h24 > 0 || h34 > 0);\n    ensuref(atLeastOnePositive, \"At least one h(si, sj) must be positive\");\n\n    // Ensure EOF is reached\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read first line: h(s1, s2), h(s1, s3), h(s1, s4)\n    int h12 = inf.readInt(0, 100000, \"h(s1,s2)\");\n    inf.readSpace();\n    int h13 = inf.readInt(0, 100000, \"h(s1,s3)\");\n    inf.readSpace();\n    int h14 = inf.readInt(0, 100000, \"h(s1,s4)\");\n    inf.readEoln();\n\n    // Read second line: h(s2, s3), h(s2, s4)\n    int h23 = inf.readInt(0, 100000, \"h(s2,s3)\");\n    inf.readSpace();\n    int h24 = inf.readInt(0, 100000, \"h(s2,s4)\");\n    inf.readEoln();\n\n    // Read third line: h(s3, s4)\n    int h34 = inf.readInt(0, 100000, \"h(s3,s4)\");\n    inf.readEoln();\n\n    // Ensure at least one h(si, sj) is positive\n    bool atLeastOnePositive = (h12 > 0 || h13 > 0 || h14 > 0 || h23 > 0 || h24 > 0 || h34 > 0);\n    ensuref(atLeastOnePositive, \"At least one h(si, sj) must be positive\");\n\n    // Ensure EOF is reached\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[])\n{\n    registerTestlibCmd(argc, argv);\n    \n    // Read the input Hamming distances\n    int h12 = inf.readInt();\n    int h13 = inf.readInt();\n    int h14 = inf.readInt();\n    int h23 = inf.readInt();\n    int h24 = inf.readInt();\n    int h34 = inf.readInt();\n\n    // Read participant's output\n    string firstToken = ouf.readToken();\n    if (firstToken == \"-1\") {\n        // Participant claims no solution exists\n        quitf(_ok, \"Participant reports no solution exists.\");\n    } else {\n        // Participant provides len and strings\n        int len = stoi(firstToken);\n        if (len <= 0 || len > 100000) {\n            quitf(_wa, \"Invalid length: %d\", len);\n        }\n\n        // Read 4 strings\n        vector<string> s(4);\n        s[0] = ouf.readToken();\n        s[1] = ouf.readToken();\n        s[2] = ouf.readToken();\n        s[3] = ouf.readToken();\n\n        // Check lengths and characters\n        for (int i = 0; i < 4; i++) {\n            if ((int)s[i].length() != len) {\n                quitf(_wa, \"String %d has incorrect length: expected %d, found %d\", i + 1, len, s[i].length());\n            }\n            for (char c : s[i]) {\n                if (c != 'a' && c != 'b') {\n                    quitf(_wa, \"String %d contains invalid character '%c'\", i + 1, c);\n                }\n            }\n        }\n\n        // Compute Hamming distances\n        int computed_h[4][4];\n        memset(computed_h, 0, sizeof(computed_h));\n        for (int i = 0; i < 4; i++) {\n            for (int j = i + 1; j < 4; j++) {\n                for (int k = 0; k < len; k++) {\n                    if (s[i][k] != s[j][k]) {\n                        computed_h[i][j]++;\n                    }\n                }\n            }\n        }\n\n        // Check Hamming distances\n        if (computed_h[0][1] != h12) {\n            quitf(_wa, \"Hamming distance between string 1 and 2 is %d, expected %d\", computed_h[0][1], h12);\n        }\n        if (computed_h[0][2] != h13) {\n            quitf(_wa, \"Hamming distance between string 1 and 3 is %d, expected %d\", computed_h[0][2], h13);\n        }\n        if (computed_h[0][3] != h14) {\n            quitf(_wa, \"Hamming distance between string 1 and 4 is %d, expected %d\", computed_h[0][3], h14);\n        }\n        if (computed_h[1][2] != h23) {\n            quitf(_wa, \"Hamming distance between string 2 and 3 is %d, expected %d\", computed_h[1][2], h23);\n        }\n        if (computed_h[1][3] != h24) {\n            quitf(_wa, \"Hamming distance between string 2 and 4 is %d, expected %d\", computed_h[1][3], h24);\n        }\n        if (computed_h[2][3] != h34) {\n            quitf(_wa, \"Hamming distance between string 3 and 4 is %d, expected %d\", computed_h[2][3], h34);\n        }\n\n        quitf(_ok, \"Correct answer with length %d.\", len);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"valid\");\n    int maxlen = opt<int>(\"maxlen\", 100000);\n\n    int len = opt<int>(\"len\", 0);\n    if (len == 0) {\n        len = rnd.next(1, maxlen);\n    } else {\n        ensure(1 <= len && len <= maxlen);\n    }\n\n    int h12 = opt<int>(\"h12\", -1);\n    int h13 = opt<int>(\"h13\", -1);\n    int h14 = opt<int>(\"h14\", -1);\n\n    if (h12 == -1) h12 = rnd.next(0, len);\n    if (h13 == -1) h13 = rnd.next(0, len);\n    if (h14 == -1) h14 = rnd.next(0, len);\n\n    if (h12 == 0 && h13 == 0 && h14 == 0) {\n        // At least one hamming distance must be positive\n        h12 = rnd.next(1, len);\n    }\n\n    int h23, h24, h34;\n\n    if (type == \"valid\") {\n        // Function to compute valid hamming distance between s2 and s3\n        auto compute_hamming_distance = [&](int h1, int h2) {\n            int h_min = abs(h1 - h2);\n            int h_max = min(h1 + h2, 2 * len);\n\n            vector<int> possible_hamming;\n            for(int h = h_min; h <= h_max; h++) {\n                if ((h1 + h2 + h) % 2 == 0 && h <= len) {\n                    possible_hamming.push_back(h);\n                }\n            }\n            ensure(!possible_hamming.empty());\n            return possible_hamming[rnd.next(0, (int)possible_hamming.size() - 1)];\n        };\n\n        // Compute h23\n        h23 = compute_hamming_distance(h12, h13);\n\n        // Compute h24\n        h24 = compute_hamming_distance(h12, h14);\n\n        // Compute h34\n        h34 = compute_hamming_distance(h13, h14);\n\n        // Now output the hamming distances in the required format\n        printf(\"%d %d %d\\n\", h12, h13, h14);\n        printf(\"%d %d\\n\", h23, h24);\n        printf(\"%d\\n\", h34);\n\n    } else if (type == \"invalid\") {\n        // Generate invalid hamming distances by violating constraints\n\n        // First, compute valid h23, h24, h34\n        auto compute_hamming_distance = [&](int h1, int h2) {\n            int h_min = abs(h1 - h2);\n            int h_max = min(h1 + h2, 2 * len);\n\n            vector<int> possible_hamming;\n            for(int h = h_min; h <= h_max; h++) {\n                if ((h1 + h2 + h) % 2 == 0 && h <= len) {\n                    possible_hamming.push_back(h);\n                }\n            }\n            ensure(!possible_hamming.empty());\n            return possible_hamming[rnd.next(0, (int)possible_hamming.size() - 1)];\n        };\n\n        h23 = compute_hamming_distance(h12, h13);\n        h24 = compute_hamming_distance(h12, h14);\n        h34 = compute_hamming_distance(h13, h14);\n\n        // Introduce inconsistency: Modify h23 to an invalid value\n        int invalid_h23 = h23;\n        while (invalid_h23 == h23) {\n            invalid_h23 = rnd.next(0, len);\n            if ((h12 + h13 + invalid_h23) % 2 == 0 && invalid_h23 >= abs(h12 - h13) && invalid_h23 <= h12 + h13) {\n                // Valid h23, try to find invalid\n                continue;\n            } else {\n                break;\n            }\n        }\n        h23 = invalid_h23;\n\n        // Now output the hamming distances in the required format\n        printf(\"%d %d %d\\n\", h12, h13, h14);\n        printf(\"%d %d\\n\", h23, h24);\n        printf(\"%d\\n\", h34);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"valid\");\n    int maxlen = opt<int>(\"maxlen\", 100000);\n\n    int len = opt<int>(\"len\", 0);\n    if (len == 0) {\n        len = rnd.next(1, maxlen);\n    } else {\n        ensure(1 <= len && len <= maxlen);\n    }\n\n    int h12 = opt<int>(\"h12\", -1);\n    int h13 = opt<int>(\"h13\", -1);\n    int h14 = opt<int>(\"h14\", -1);\n\n    if (h12 == -1) h12 = rnd.next(0, len);\n    if (h13 == -1) h13 = rnd.next(0, len);\n    if (h14 == -1) h14 = rnd.next(0, len);\n\n    if (h12 == 0 && h13 == 0 && h14 == 0) {\n        // At least one hamming distance must be positive\n        h12 = rnd.next(1, len);\n    }\n\n    int h23, h24, h34;\n\n    if (type == \"valid\") {\n        // Function to compute valid hamming distance between s2 and s3\n        auto compute_hamming_distance = [&](int h1, int h2) {\n            int h_min = abs(h1 - h2);\n            int h_max = min(h1 + h2, 2 * len);\n\n            vector<int> possible_hamming;\n            for(int h = h_min; h <= h_max; h++) {\n                if ((h1 + h2 + h) % 2 == 0 && h <= len) {\n                    possible_hamming.push_back(h);\n                }\n            }\n            ensure(!possible_hamming.empty());\n            return possible_hamming[rnd.next(0, (int)possible_hamming.size() - 1)];\n        };\n\n        // Compute h23\n        h23 = compute_hamming_distance(h12, h13);\n\n        // Compute h24\n        h24 = compute_hamming_distance(h12, h14);\n\n        // Compute h34\n        h34 = compute_hamming_distance(h13, h14);\n\n        // Now output the hamming distances in the required format\n        printf(\"%d %d %d\\n\", h12, h13, h14);\n        printf(\"%d %d\\n\", h23, h24);\n        printf(\"%d\\n\", h34);\n\n    } else if (type == \"invalid\") {\n        // Generate invalid hamming distances by violating constraints\n\n        // First, compute valid h23, h24, h34\n        auto compute_hamming_distance = [&](int h1, int h2) {\n            int h_min = abs(h1 - h2);\n            int h_max = min(h1 + h2, 2 * len);\n\n            vector<int> possible_hamming;\n            for(int h = h_min; h <= h_max; h++) {\n                if ((h1 + h2 + h) % 2 == 0 && h <= len) {\n                    possible_hamming.push_back(h);\n                }\n            }\n            ensure(!possible_hamming.empty());\n            return possible_hamming[rnd.next(0, (int)possible_hamming.size() - 1)];\n        };\n\n        h23 = compute_hamming_distance(h12, h13);\n        h24 = compute_hamming_distance(h12, h14);\n        h34 = compute_hamming_distance(h13, h14);\n\n        // Introduce inconsistency: Modify h23 to an invalid value\n        int invalid_h23 = h23;\n        while (invalid_h23 == h23) {\n            invalid_h23 = rnd.next(0, len);\n            if ((h12 + h13 + invalid_h23) % 2 == 0 && invalid_h23 >= abs(h12 - h13) && invalid_h23 <= h12 + h13) {\n                // Valid h23, try to find invalid\n                continue;\n            } else {\n                break;\n            }\n        }\n        h23 = invalid_h23;\n\n        // Now output the hamming distances in the required format\n        printf(\"%d %d %d\\n\", h12, h13, h14);\n        printf(\"%d %d\\n\", h23, h24);\n        printf(\"%d\\n\", h34);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type valid -len 1\n./gen -type valid -len 2\n./gen -type valid -len 5\n./gen -type valid -len 10\n\n./gen -type valid -maxlen 100\n./gen -type valid -maxlen 100\n./gen -type valid -maxlen 100\n\n./gen -type valid -len 100000\n./gen -type valid -len 100000\n\n./gen -type valid -len 50000\n\n./gen -type invalid -len 1\n./gen -type invalid -len 2\n./gen -type invalid -len 5\n\n./gen -type invalid -maxlen 100\n./gen -type invalid -maxlen 100\n./gen -type invalid -maxlen 100\n\n./gen -type invalid -len 100000\n./gen -type invalid -len 100000\n\n./gen -type valid -len 1000 -h12 1000 -h13 1000 -h14 1000\n\n./gen -type valid -len 1000 -h12 0 -h13 0 -h14 1\n\n./gen -type invalid -len 50 -h12 10 -h13 20\n\n./gen -type invalid -len 10 -h12 9 -h13 0\n\n./gen -type valid -len 1000 -h12 500 -h13 1000 -h14 750\n\n./gen -type valid -len 10 -h12 7 -h13 8 -h14 10\n\n./gen -type invalid -len 100 -h12 40 -h13 50\n\n./gen -type valid -len 1 -h12 1 -h13 1 -h14 1\n\n./gen -type invalid -len 1 -h12 1 -h13 1 -h14 1\n\n./gen -type valid -maxlen 100000\n./gen -type valid -maxlen 100000\n./gen -type valid -maxlen 100000\n\n./gen -type invalid -maxlen 100000\n./gen -type invalid -maxlen 100000\n./gen -type invalid -maxlen 100000\n\n./gen -type valid -len 100 -h12 30 -h13 40 -h14 50\n\n./gen -type valid -len 1000 -h12 100 -h13 300 -h14 500\n\n./gen -type invalid -len 1000 -h12 1000 -h13 1000 -h14 1000\n\n./gen -type valid -len 10 -h12 2 -h13 2 -h14 2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:50.737302",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "195/A",
      "title": "A. Let's Watch Football",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers a, b and c (1 ≤ a, b, c ≤ 1000, a > b). The first number (a) denotes the size of data needed to watch one second of the video. The second number (b) denotes the size of data Valeric and Valerko can download from the Net per second. The third number (c) denotes the video's length in seconds.",
      "output_spec": "OutputPrint a single number — the minimum integer number of seconds that Valeric and Valerko must wait to watch football without pauses.",
      "sample_tests": "ExamplesInputCopy4 1 1OutputCopy3InputCopy10 3 2OutputCopy5InputCopy13 12 1OutputCopy1",
      "description": "A. Let's Watch Football\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers a, b and c (1 ≤ a, b, c ≤ 1000, a > b). The first number (a) denotes the size of data needed to watch one second of the video. The second number (b) denotes the size of data Valeric and Valerko can download from the Net per second. The third number (c) denotes the video's length in seconds.\n\nOutputPrint a single number — the minimum integer number of seconds that Valeric and Valerko must wait to watch football without pauses.\n\nInputCopy4 1 1OutputCopy3InputCopy10 3 2OutputCopy5InputCopy13 12 1OutputCopy1\n\nInputCopy4 1 1\n\nOutputCopy3\n\nInputCopy10 3 2\n\nOutputCopy5\n\nInputCopy13 12 1\n\nOutputCopy1\n\nNoteIn the first sample video's length is 1 second and it is necessary 4 units of data for watching 1 second of video, so guys should download 4 · 1 = 4 units of data to watch the whole video. The most optimal way is to wait 3 seconds till 3 units of data will be downloaded and then start watching. While guys will be watching video 1 second, one unit of data will be downloaded and Valerik and Valerko will have 4 units of data by the end of watching. Also every moment till the end of video guys will have more data then necessary for watching.In the second sample guys need 2 · 10 = 20 units of data, so they have to wait 5 seconds and after that they will have 20 units before the second second ends. However, if guys wait 4 seconds, they will be able to watch first second of video without pauses, but they will download 18 units of data by the end of second second and it is less then necessary.",
      "solutions": [
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces",
          "content": "Welcome, friends)We are glad to introduce you regular Codeforces round #123 for Div.2 participants. Everyone can traditionally participate in it.Problems are prepared by command of authors: Ivan Fefer (Fefer_Ivan), Igor Kudryashov (Igor_Kudryashov), Pavel Kholkin (HolkinPV) and Gerald Agapov (Gerald). Also thanks to Pavel Kunyavskiy (PavelKunyavskiy) and Alexander Kouprin (Alex_KPR) for their help. And traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces system and Mary Belova (Delinur) for translating problems.Score distribution is standard: 500, 1000, 1500, 2000, 2500.We wish you success and high rating!Congratulations to winners: bmerry adrian.jaskolka cheshire_cat alexej psw UPD: the tutorial is here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 735
        },
        {
          "title": "403 Forbidden",
          "content": "403 Forbidden\nnginx/1.27.4",
          "author": "Unknown",
          "url": "http://www.codeforces.com/blog/entry/4696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 26
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Tutorial - Codeforces",
          "content": "195A - Let's Watch FootballThe whole video will be downloaded in all = (c·a + b - 1) / b seconds. In this problem you can choose every 1 <  = t <  = all as an answer. To fulfill coditions of the problem it is enough to check the condition t0·b >  = (t0 - t)·a at the moment of time t0 = all.195B - After TrainingIn this problem you should carefully implement the given process. Firstly note that ball number i > m will be in the same basket as ball number i - m. Therefore it is enough to distribute first m balls. It can be done using two pointers lf, rg from the middle. Alternately put one ball to the left and to the right and shift pointers. In only case you should shift left pointer twice in the first moment of time if m is odd.195C - Try and CatchIn this problem you was to implement what was writen in the statement. In my solution I did the following. Erase all spaces from the text except spaces in messages in try-catch blocks. Then when we get word \"try\" we put number of the new try-catch block in stack. When we get word \"throw\" we remember it's type and current state of stack (that is what try-catch blocks are opened). For example, put these number in set. When we get word \"catch\" if it's type equals to type of operator \"throw\" and the number of current try-catch block is in your set then write the answer now else erase this try-catch block from stack. If there was no suitable try-catch block write \"Unhandled Exception\".195D - Analyzing PolylineTutorial by author Igor_KudryashovIn fact in this problem we were given lines yi = ki * x + bi but negative values were replaced by zero. Your task was to find the number of angles that do not equal 180 degrees in the graph s(x), that is the sum of the given functions.Firstly note that sum of two lines is also line. Indeed y = y1 + y2 is y = k1 * x + b1 + k2 * x + b2 = (k1 + k2) * x + (b1 + b2).Consider points where yi = 0, that is xi =  - bi / ki. While we assume that ki doesn't equal to 0. Then line number i is divided in two lines one of which identically equals to 0. Consider all different points xi and sort them. Then, obviously, the sum of the given functions between two consecutive points is line. Find the equation of the line. Assume that we consider point i from the left. Then equation of the line between points i and i + 1 will not be equal to equation of the line between points i and i - 1. That is in point i is formed an angle that doesn't equal 180 degrees.So we should find equations of lines between every pair of points i and i + 1. It can be easily done using two arrays with queries of increasing value on the interval offline.195E - Building ForestTutorial by author Fefer_IvanThe longest operation in this problem is to find the root of some vertex and the sum of the path to this root. To find these values fast we will use compression ways heuristics which is used in data structure \"disjoint-set-union\".For every vertex v we keep two values : c[v] and sum[v]. c[v] = v, if v — root, else c[v] — next vertex on path from v to root. sum[v] = sum of lengths of edges on path from v to c[v].To add new edge from u to v of length w it is enough to do c[u] = v and sum[u] = w.Note that we only add new edges (we don't erase edges).That is, if we find root(v) and depth(v) for some vertex v we can assign c[v] = root(v), Unable to parse markup [type=CF_TEX] time. The approximate implementation is shown below. int root(int v){ \n if(c[v] == v){ \n return v; \n }else{ \n int u = root(c[v]); \n sum[v] = (sum[c[v]] + sum[v]) % M; \n c[v] = u; \n return u; \n } \n} It can proved that such implementation works using O(log(n)) time for every query. The complexity of the solution is O(n * log(n)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4699",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 195\\s*A"
          },
          "content_length": 3687
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 1",
          "code": "abs((M + 1) - 2 * a.second)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 2",
          "code": "t.cha[len] = '\\0';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 3",
          "code": "t.msg[len] = '\\0';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 4",
          "code": "cin.getline(s,55,'\\n');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 5",
          "code": "down_time = (c*a + b - 1) / b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Tutorial - Codeforces - Code 1",
          "code": "int root(int v){  \n   if(c[v] == v){  \n       return v;  \n   }else{  \n       int u = root(c[v]);  \n       sum[v] = (sum[c[v]] + sum[v]) % M;  \n       c[v] = u;  \n       return u;  \n   }  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Tutorial - Codeforces - Code 2",
          "code": "int root(int v){  \n   if(c[v] == v){  \n       return v;  \n   }else{  \n       int u = root(c[v]);  \n       sum[v] = (sum[c[v]] + sum[v]) % M;  \n       c[v] = u;  \n       return u;  \n   }  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4699",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000, \"c\");\n    inf.readEoln();\n\n    ensuref(a > b, \"a (%d) must be greater than b (%d)\", a, b);\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000, \"c\");\n    inf.readEoln();\n\n    ensuref(a > b, \"a (%d) must be greater than b (%d)\", a, b);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000, \"c\");\n    inf.readEoln();\n\n    ensuref(a > b, \"a (%d) must be greater than b (%d)\", a, b);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int c = opt<int>(\"c\", -1);\n\n    // Check if a, b, c are provided\n    if (a != -1 && b != -1 && c != -1) {\n        // Use provided a, b, c\n        if (!(1 <= a && a <= 1000 && 1 <= b && b <= 1000 && 1 <= c && c <= 1000 && a > b)) {\n            fprintf(stderr, \"Invalid input parameters: a=%d, b=%d, c=%d\\n\", a, b, c);\n            return 1;\n        }\n    } else {\n\n        if (type == \"min_values\") {\n            b = 1;\n            a = b + 1; // since a > b\n            c = 1;\n        } else if (type == \"max_values\") {\n            b = 999; // since a > b and a ≤ 1000\n            a = 1000;\n            c = 1000;\n        } else if (type == \"a_close_to_b\") {\n            b = rnd.next(1, 999);\n            a = b + 1; // a is just greater than b\n            c = rnd.next(1, 1000);\n        } else if (type == \"a_far_from_b\") {\n            b = rnd.next(1, 500);\n            a = rnd.next(b + 500, 1000); // Ensure a > b\n            c = rnd.next(1, 1000);\n        } else if (type == \"large_c\") {\n            b = rnd.next(1, 999);\n            a = rnd.next(b + 1, 1000);\n            c = 1000;\n        } else if (type == \"small_c\") {\n            b = rnd.next(1, 999);\n            a = rnd.next(b + 1, 1000);\n            c = 1;\n        } else {\n            // Random values\n            b = rnd.next(1, 999);\n            a = rnd.next(b + 1, 1000);\n            c = rnd.next(1, 1000);\n        }\n    }\n\n    // Output a, b, c\n    printf(\"%d %d %d\\n\", a, b, c);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int c = opt<int>(\"c\", -1);\n\n    // Check if a, b, c are provided\n    if (a != -1 && b != -1 && c != -1) {\n        // Use provided a, b, c\n        if (!(1 <= a && a <= 1000 && 1 <= b && b <= 1000 && 1 <= c && c <= 1000 && a > b)) {\n            fprintf(stderr, \"Invalid input parameters: a=%d, b=%d, c=%d\\n\", a, b, c);\n            return 1;\n        }\n    } else {\n\n        if (type == \"min_values\") {\n            b = 1;\n            a = b + 1; // since a > b\n            c = 1;\n        } else if (type == \"max_values\") {\n            b = 999; // since a > b and a ≤ 1000\n            a = 1000;\n            c = 1000;\n        } else if (type == \"a_close_to_b\") {\n            b = rnd.next(1, 999);\n            a = b + 1; // a is just greater than b\n            c = rnd.next(1, 1000);\n        } else if (type == \"a_far_from_b\") {\n            b = rnd.next(1, 500);\n            a = rnd.next(b + 500, 1000); // Ensure a > b\n            c = rnd.next(1, 1000);\n        } else if (type == \"large_c\") {\n            b = rnd.next(1, 999);\n            a = rnd.next(b + 1, 1000);\n            c = 1000;\n        } else if (type == \"small_c\") {\n            b = rnd.next(1, 999);\n            a = rnd.next(b + 1, 1000);\n            c = 1;\n        } else {\n            // Random values\n            b = rnd.next(1, 999);\n            a = rnd.next(b + 1, 1000);\n            c = rnd.next(1, 1000);\n        }\n    }\n\n    // Output a, b, c\n    printf(\"%d %d %d\\n\", a, b, c);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Sample inputs from the problem statement\n./gen -a 4 -b 1 -c 1\n./gen -a 10 -b 3 -c 2\n./gen -a 13 -b 12 -c 1\n\n# Edge cases: min_values\n./gen -type min_values\n\n# Edge case: max_values\n./gen -type max_values\n\n# Close values of a and b\n./gen -type a_close_to_b\n./gen -type a_close_to_b\n./gen -type a_close_to_b\n\n# Far apart values of a and b\n./gen -type a_far_from_b\n./gen -type a_far_from_b\n./gen -type a_far_from_b\n\n# Large c\n./gen -type large_c\n\n# Small c\n./gen -type small_c\n\n# Cases where c = 1\n./gen -a 1000 -b 500 -c 1\n./gen -a 1000 -b 999 -c 1\n./gen -a 1000 -b 1 -c 1\n\n# Cases where c = 1000\n./gen -a 1000 -b 1 -c 1000\n./gen -a 1000 -b 999 -c 1000\n./gen -a 1000 -b 500 -c 1000\n\n# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Specific test cases near integer boundaries\n./gen -a 999 -b 998 -c 999\n./gen -a 999 -b 500 -c 500\n./gen -a 2 -b 1 -c 1000\n./gen -a 1000 -b 999 -c 1000\n\n# Edge cases with varying c and a - b\n./gen -a 100 -b 99 -c 99\n./gen -a 100 -b 1 -c 100\n./gen -a 500 -b 1 -c 1000\n./gen -a 500 -b 499 -c 1000\n./gen -a 1000 -b 2 -c 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:52.404890",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "195/B",
      "title": "B. After Training",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n, m (1 ≤ n, m ≤ 105) — the number of balls and baskets, correspondingly.",
      "output_spec": "OutputPrint n numbers, one per line. The i-th line must contain the number of the basket for the i-th ball.",
      "sample_tests": "ExamplesInputCopy4 3OutputCopy2132InputCopy3 1OutputCopy111",
      "description": "B. After Training\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n, m (1 ≤ n, m ≤ 105) — the number of balls and baskets, correspondingly.\n\nOutputPrint n numbers, one per line. The i-th line must contain the number of the basket for the i-th ball.\n\nInputCopy4 3OutputCopy2132InputCopy3 1OutputCopy111\n\nInputCopy4 3\n\nOutputCopy2132\n\nInputCopy3 1\n\nOutputCopy111",
      "solutions": [
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces",
          "content": "Welcome, friends)We are glad to introduce you regular Codeforces round #123 for Div.2 participants. Everyone can traditionally participate in it.Problems are prepared by command of authors: Ivan Fefer (Fefer_Ivan), Igor Kudryashov (Igor_Kudryashov), Pavel Kholkin (HolkinPV) and Gerald Agapov (Gerald). Also thanks to Pavel Kunyavskiy (PavelKunyavskiy) and Alexander Kouprin (Alex_KPR) for their help. And traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces system and Mary Belova (Delinur) for translating problems.Score distribution is standard: 500, 1000, 1500, 2000, 2500.We wish you success and high rating!Congratulations to winners: bmerry adrian.jaskolka cheshire_cat alexej psw UPD: the tutorial is here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 735
        },
        {
          "title": "403 Forbidden",
          "content": "403 Forbidden\nnginx/1.27.4",
          "author": "Unknown",
          "url": "http://www.codeforces.com/blog/entry/4696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 26
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Tutorial - Codeforces",
          "content": "195A - Let's Watch FootballThe whole video will be downloaded in all = (c·a + b - 1) / b seconds. In this problem you can choose every 1 <  = t <  = all as an answer. To fulfill coditions of the problem it is enough to check the condition t0·b >  = (t0 - t)·a at the moment of time t0 = all.195B - After TrainingIn this problem you should carefully implement the given process. Firstly note that ball number i > m will be in the same basket as ball number i - m. Therefore it is enough to distribute first m balls. It can be done using two pointers lf, rg from the middle. Alternately put one ball to the left and to the right and shift pointers. In only case you should shift left pointer twice in the first moment of time if m is odd.195C - Try and CatchIn this problem you was to implement what was writen in the statement. In my solution I did the following. Erase all spaces from the text except spaces in messages in try-catch blocks. Then when we get word \"try\" we put number of the new try-catch block in stack. When we get word \"throw\" we remember it's type and current state of stack (that is what try-catch blocks are opened). For example, put these number in set. When we get word \"catch\" if it's type equals to type of operator \"throw\" and the number of current try-catch block is in your set then write the answer now else erase this try-catch block from stack. If there was no suitable try-catch block write \"Unhandled Exception\".195D - Analyzing PolylineTutorial by author Igor_KudryashovIn fact in this problem we were given lines yi = ki * x + bi but negative values were replaced by zero. Your task was to find the number of angles that do not equal 180 degrees in the graph s(x), that is the sum of the given functions.Firstly note that sum of two lines is also line. Indeed y = y1 + y2 is y = k1 * x + b1 + k2 * x + b2 = (k1 + k2) * x + (b1 + b2).Consider points where yi = 0, that is xi =  - bi / ki. While we assume that ki doesn't equal to 0. Then line number i is divided in two lines one of which identically equals to 0. Consider all different points xi and sort them. Then, obviously, the sum of the given functions between two consecutive points is line. Find the equation of the line. Assume that we consider point i from the left. Then equation of the line between points i and i + 1 will not be equal to equation of the line between points i and i - 1. That is in point i is formed an angle that doesn't equal 180 degrees.So we should find equations of lines between every pair of points i and i + 1. It can be easily done using two arrays with queries of increasing value on the interval offline.195E - Building ForestTutorial by author Fefer_IvanThe longest operation in this problem is to find the root of some vertex and the sum of the path to this root. To find these values fast we will use compression ways heuristics which is used in data structure \"disjoint-set-union\".For every vertex v we keep two values : c[v] and sum[v]. c[v] = v, if v — root, else c[v] — next vertex on path from v to root. sum[v] = sum of lengths of edges on path from v to c[v].To add new edge from u to v of length w it is enough to do c[u] = v and sum[u] = w.Note that we only add new edges (we don't erase edges).That is, if we find root(v) and depth(v) for some vertex v we can assign c[v] = root(v), Unable to parse markup [type=CF_TEX] time. The approximate implementation is shown below. int root(int v){ \n if(c[v] == v){ \n return v; \n }else{ \n int u = root(c[v]); \n sum[v] = (sum[c[v]] + sum[v]) % M; \n c[v] = u; \n return u; \n } \n} It can proved that such implementation works using O(log(n)) time for every query. The complexity of the solution is O(n * log(n)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4699",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 195\\s*B"
          },
          "content_length": 3687
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 1",
          "code": "abs((M + 1) - 2 * a.second)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 2",
          "code": "t.cha[len] = '\\0';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 3",
          "code": "t.msg[len] = '\\0';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 4",
          "code": "cin.getline(s,55,'\\n');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 5",
          "code": "down_time = (c*a + b - 1) / b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Tutorial - Codeforces - Code 1",
          "code": "int root(int v){  \n   if(c[v] == v){  \n       return v;  \n   }else{  \n       int u = root(c[v]);  \n       sum[v] = (sum[c[v]] + sum[v]) % M;  \n       c[v] = u;  \n       return u;  \n   }  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Tutorial - Codeforces - Code 2",
          "code": "int root(int v){  \n   if(c[v] == v){  \n       return v;  \n   }else{  \n       int u = root(c[v]);  \n       sum[v] = (sum[c[v]] + sum[v]) % M;  \n       c[v] = u;  \n       return u;  \n   }  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4699",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n\n    /* Output n and m */\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n\n    /* Output n and m */\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1\n./gen -n 1 -m 2\n./gen -n 2 -m 1\n./gen -n 2 -m 2\n./gen -n 3 -m 2\n./gen -n 2 -m 3\n./gen -n 4 -m 3\n./gen -n 4 -m 4\n./gen -n 5 -m 4\n./gen -n 100 -m 100\n./gen -n 99 -m 100\n./gen -n 100 -m 99\n./gen -n 1000 -m 500\n./gen -n 500 -m 1000\n./gen -n 99999 -m 99999\n./gen -n 100000 -m 100000\n./gen -n 100000 -m 99999\n./gen -n 99999 -m 100000\n./gen -n 100000 -m 1\n./gen -n 1 -m 100000\n./gen -n 50000 -m 50000\n./gen -n 50000 -m 100000\n./gen -n 100000 -m 50000\n./gen -n 1 -m 50000\n./gen -n 50000 -m 1\n./gen -n 99998 -m 99999\n./gen -n 99999 -m 99998\n./gen -n 100000 -m 2\n./gen -n 2 -m 100000\n./gen -n 1000 -m 2\n./gen -n 2 -m 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:54.273833",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "195/C",
      "title": "C. Попробуй поймай",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано одно целое число: n (1 ≤ n ≤ 105) — количество строк в программе. В следующих n строках записана программа на языке VPL. В каждой строке содержится не более одного оператора. Это означает, что во входных данных могут встречаться пустые строки или строки, состоящие только из пробелов.В программе присутствуют только операторы try, catch и throw. Гарантируется, что программа корректна. Это означает, что каждый начатый try-catch-блок был закрыт, операторы catch не используются, если нет открытого try-catch-блока. В программе присутствует ровно один оператор throw. В программе могут присутствовать пробелы в начале строки, в конце строки, перед и после скобок, запятых и кавычек.Тип исключения — это непустая строка, состоящая только из прописных и строчных букв латинского алфавита. Длина типа исключения не превосходит 20 символов. Сообщение — это непустая строка, состоящая только из прописных и строчных букв латинского алфавита, цифр и пробелов, заключенная в кавычки. Кавычки выводить не надо. Длина сообщения не превосходит 20 символов. Длина любой строки входного файла не превосходит 50 символов.",
      "output_spec": "Выходные данныеВыведите сообщение, которое будет написано на экране после выполнения заданной программы.",
      "sample_tests": "ПримерыВходные данныеСкопировать8try    try        throw ( AE )     catch ( BE, \"BE in line 3\")    try    catch(AE, \"AE in line 5\") catch(AE,\"AE somewhere\")Выходные данныеСкопироватьAE somewhereВходные данныеСкопировать8try    try        throw ( AE )     catch ( AE, \"AE in line 3\")    try    catch(BE, \"BE in line 5\") catch(AE,\"AE somewhere\")Выходные данныеСкопироватьAE in line 3Входные данныеСкопировать8try    try        throw ( CE )     catch ( BE, \"BE in line 3\")    try    catch(AE, \"AE in line 5\") catch(AE,\"AE somewhere\")Выходные данныеСкопироватьUnhandled Exception",
      "description": "C. Попробуй поймай\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано одно целое число: n (1 ≤ n ≤ 105) — количество строк в программе. В следующих n строках записана программа на языке VPL. В каждой строке содержится не более одного оператора. Это означает, что во входных данных могут встречаться пустые строки или строки, состоящие только из пробелов.В программе присутствуют только операторы try, catch и throw. Гарантируется, что программа корректна. Это означает, что каждый начатый try-catch-блок был закрыт, операторы catch не используются, если нет открытого try-catch-блока. В программе присутствует ровно один оператор throw. В программе могут присутствовать пробелы в начале строки, в конце строки, перед и после скобок, запятых и кавычек.Тип исключения — это непустая строка, состоящая только из прописных и строчных букв латинского алфавита. Длина типа исключения не превосходит 20 символов. Сообщение — это непустая строка, состоящая только из прописных и строчных букв латинского алфавита, цифр и пробелов, заключенная в кавычки. Кавычки выводить не надо. Длина сообщения не превосходит 20 символов. Длина любой строки входного файла не превосходит 50 символов.\n\nВходные данные\n\nВыходные данныеВыведите сообщение, которое будет написано на экране после выполнения заданной программы.\n\nВыходные данные\n\nВходные данныеСкопировать8try    try        throw ( AE )     catch ( BE, \"BE in line 3\")    try    catch(AE, \"AE in line 5\") catch(AE,\"AE somewhere\")Выходные данныеСкопироватьAE somewhereВходные данныеСкопировать8try    try        throw ( AE )     catch ( AE, \"AE in line 3\")    try    catch(BE, \"BE in line 5\") catch(AE,\"AE somewhere\")Выходные данныеСкопироватьAE in line 3Входные данныеСкопировать8try    try        throw ( CE )     catch ( BE, \"BE in line 3\")    try    catch(AE, \"AE in line 5\") catch(AE,\"AE somewhere\")Выходные данныеСкопироватьUnhandled Exception\n\nВходные данныеСкопировать8try    try        throw ( AE )     catch ( BE, \"BE in line 3\")    try    catch(AE, \"AE in line 5\") catch(AE,\"AE somewhere\")\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьAE somewhere\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать8try    try        throw ( AE )     catch ( AE, \"AE in line 3\")    try    catch(BE, \"BE in line 5\") catch(AE,\"AE somewhere\")\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьAE in line 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать8try    try        throw ( CE )     catch ( BE, \"BE in line 3\")    try    catch(AE, \"AE in line 5\") catch(AE,\"AE somewhere\")\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьUnhandled Exception\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере существует 2 try-catch блока, для которых оператор try описан раньше оператора throw, а оператор catch описан позже оператора throw: try-catch(BE,\"BE in line 3\") и try-catch(AE,\"AE somewhere\"). Тип исключения AE, а значит будет активирован второй блок, так как в операторе catch(AE,\"AE somewhere\") указан тип исключения AE, а в операторе catch(BE,\"BE in line 3\") указан тип BE.Во втором примере существует 2 try-catch блока, для которых оператор try описан раньше оператора throw, а оператор catch описан позже оператора throw: try-catch(AE,\"AE in line 3\") и try-catch(AE,\"AE somewhere\"). В данном случае оба блока могут быть активированы исключением типа AE, но будет активирован только блок try-catch(AE,\"AE in line 3\"), так как оператор catch(AE,\"AE in line 3\") описан раньше, чем catch(AE,\"AE somewhere\").В третьем примере не существует блоков, способных обработать исключение типа CE.",
      "solutions": [
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces",
          "content": "Здравствуйте, друзья)Рады приветствовать вас на очередном раунде Codeforces #123 для участников Div. 2. Традиционно, остальные могут поучаствовать в нем вне конкурса.Задачи для вас были подготовлены группой авторов в составе: Иван Фефер (Fefer_Ivan), Игорь Кудряшов (Igor_Kudryashov), Павел Холкин (HolkinPV), а также Геральд Агапов (Gerald). Также говорим спасибо Кунявскому Павлу (PavelKunyavskiy) и Александру Куприну (Alex_KPR) за помощь в подготовке раунда. Традиционно хотим поблагодарить Михаила Мирзаянова (MikeMirzayanov) за систему Codeforces и Марию Белову (Delinur) за перевод условий.Распределение баллов по задачам стандартное: 500, 1000, 1500, 2000, 2500.Всем участникам желаем успехов и высокого рейтинга!UPD: контест завершен, разбор задач появился здесьПоздравляем победителей: bmerry adrian.jaskolka cheshire_cat alexej psw",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 842
        },
        {
          "title": "403 Forbidden",
          "content": "403 Forbidden\nnginx/1.27.4",
          "author": "Unknown",
          "url": "http://www.codeforces.com/blog/entry/4696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 26
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Разбор Задач - Codeforces",
          "content": "195A - Посмотрим футболПолное видео скачается через all = (c·a + b - 1) / b секунд. В этой задаче можно было перебрать величину ответа 1 <  = t <  = all. Чтобы удовлетворить условию задачи, достаточно проверить, что в последний момент времени t0 = all выполняется условие, написанное в тексте задачи, а именно t0·b >  = (t0 - t)·a.195B - После тренировкиВ этой задаче нужно было аккуратно реализовать описанный в условии процесс. Вначале заметим, что мяч с номером i > m попадет в одну корзину с мячом под номером i - m. Поэтому достаточно распределить первые m мячей. Это удобно сделать при помощи двух указателей lf, rg, начиная с середины. Поочередно кладем мяч сначала слева, затем справа и двигаем указатели. Единственный раз, когда нужно дважды подвинуть левый указателей, возникает в самый первый момент, если m нечетно.195C - Попробуй поймайДанная задача носила реализационный характер. В своем решении я поступал следующим образом. Удалим из текста все пробелы, кроме пробелов в сообщениях try-catch блоков. Затем при появлении слова try, кладем номер нового try-catch блока в стек. При появлени слова throw, запомним его тип, а также текущее состояние стека (то есть какие try-catch блоки открыты). Для этого, например, положим номера открытых блоков в set. При появлении слова catch, если тип блока совпадает с типом оператора throw, а также номер текущего блока находился в стеке при появлении оператора throw (то есть он есть в нашем set-е), то сразу выводим ответ. Иначе удаляем текущий try-catch блок из стека. Если подходящего try-catch блока так и не найдется, в конце выводим фразу \"Unhandled Exception\". 195D - Исследование ломанойРазбор от автора Igor_KudryashovВ данной задаче были заданы по сути прямые в виде yi = ki * x + bi, но в тех точках, где y принимает отрицательное значение, оно заменено нулем. Необходимо было найти количество углов, не равных 180 градусам, в графике функции, равной сумме функций указанного вида.Во-первых, несложно показать, что сумма прямых является прямой. В самом деле, если y = y1 + y2, то y = k1 * x + b1 + k2 * x + b2 = (k1 + k2) * x + (b1 + b2). Рассмотрим точки, в которых yi = 0, т.е. xi =  - bi / ki. Пока предположим, что ki не равно 0. Тогда i-ая функция разбивается на две прямые, одна из которых тождественно равна 0. Оставим среди xi различные точки и упорядочим их по возрастанию значения. Тогда, очевидно, между двумя соседними точками суммой заданных функций является прямая. Найдем уравнение этой прямой. Предположим, мы рассматриваем i-ую слева точку. Тогда если уравнение прямой между i-ой и (i + 1)-ой точками, отлично от уравнения прямой между (i - 1)-ой и i-ой точками, тогда в i-ой точке образуется угол, не равный 180 градусам.Таким образом, нам необходимо найти уравнение прямых на отрезках между соседними точками x, т.е. найти коэффициенты k и b. Это можно легко сделать с использованием 2 массивов запросами увеличения на отрезке в оффлайне.Когда мы обрабатываем очередную функцию, мы смотрим, если ki равно 0, то нужно ко всем отрезкам прибавить одну и ту же величину, но т.к. данное изменение не повлияет на ответ, то можно не обрабатывать функции такого вида. Если ki не равно 0, то найдем индекс j точки xi в упорядоченном списке x. Теперь если ki больше 0, то нужно сделать увеличение на суффиксе, начиная с позиции j, иначе нужно сделать увеличение на префиксе до позиции j (при этом увеличение на префиксе коэффициента k будет производиться на отрицательную величину).195E - Построение лесаРазбор от автора Fefer_IvanВ этой задаче самой долгой операцией является поиск корня вершины и длина пути до него. Эту операцию можно выполнять быстро используя эвристику сжатия путей. Такой же метод применяется в структуре данных Disjoint Set Union.Для каждой вершины v мы будем хранить два числа: c[v] и sum[v]. c[v] = v, если v — корень, иначе c[v] — следующая вершина на пути от v к корню. sum[v] = сумме длин ребер на пути от v до c[v].Таким образом для того, чтобы добавить ребро из u в v веса w, достаточно c[u] = v, а sum[u] = w. Теперь мы можем за O(n) находить по вершине нужные нам в задаче root(v) и depth(v) просто переходя каждый раз из v в c[v] и суммируя все sum[v] по пути.Заметим, что мы только добавляем ребра, но не удаляем. Это значит, что если мы для вершины v нашли root(v) и depth(v), то можно присвоить c[v] = root(v), sum[v] = depth(v). Таким образом в следующий раз мы найдем предка вершины v за О(1). В общем реализация этого подхода выглядит следующим образом: int root(int v){ \n if(c[v] == v){ \n return v; \n }else{ \n int u = root(c[v]); \n sum[v] = (sum[c[v]] + sum[v]) % M; \n c[v] = u; \n return u; \n } \n} Доказывается, что такая реализация работает в сумме за время, пропроциональное обратной фунции Аккермана http://en.wikipedia.org/wiki/Ackermann_function#Inverse) на запрос при применении ранговой эвристики. Поскольку в этом случае нельзя её применить, то такой запрос обрабатывается за log(n). Итого получаем решение за время O(n * log * (n)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4699",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 195\\s*C"
          },
          "content_length": 4957
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 1",
          "code": "set<long double>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 2",
          "code": "int root(int v){\n    if(c[v] == v){\n        return v;\n    }else{\n        int u = root(c[v]);\n        sum[v] = (sum[c[v]] + sum[v]) % M;\n        c[v] = u;\n        return u;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 3",
          "code": "int root(int v){\n    if(c[v] == v){\n        return v;\n    }else{\n        int u = root(c[v]);\n        sum[v] = (sum[c[v]] + sum[v]) % M;\n        c[v] = u;\n        return u;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 4",
          "code": "FAIL Expected EOLN (stdin)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 5",
          "code": "abs((M + 1) - 2 * a.second)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 6",
          "code": "t.cha[len] = '\\0';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 7",
          "code": "t.msg[len] = '\\0';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 8",
          "code": "cin.getline(s,55,'\\n');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 9",
          "code": "down_time = (c*a + b - 1) / b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Разбор Задач - Codeforces - Code 1",
          "code": "int root(int v){  \n   if(c[v] == v){  \n       return v;  \n   }else{  \n       int u = root(c[v]);  \n       sum[v] = (sum[c[v]] + sum[v]) % M;  \n       c[v] = u;  \n       return u;  \n   }  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Разбор Задач - Codeforces - Code 2",
          "code": "int root(int v){  \n   if(c[v] == v){  \n       return v;  \n   }else{  \n       int u = root(c[v]);  \n       sum[v] = (sum[c[v]] + sum[v]) % M;  \n       c[v] = u;  \n       return u;  \n   }  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Разбор Задач - Codeforces - Code 3",
          "code": "for(int i = 0; i < n; ++i)\n    printf(\"%d\", a[i % m]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Разбор Задач - Codeforces - Code 4",
          "code": "for(int i = 0; i < n; ++i)\n    printf(\"%d\", a[i % m]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Разбор Задач - Codeforces - Code 5",
          "code": "Точки изломов не пропадают, т.к. производная будет кусочно - постоянной неубывающей функцией с точками разрыва = -b/k. (с точки зрения математика)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4699",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string spaces = \"[ \\\\t]*\";\n    string exception_type = \"[A-Za-z]{1,20}\";\n    string message_content = \"[A-Za-z0-9 ]{1,20}\";\n\n    string try_pattern = \"^\" + spaces + \"try\" + spaces + \"$\";\n    string throw_pattern = \"^\" + spaces + \"throw\" + spaces + \"\\\\(\" + spaces + \"(\" + exception_type + \")\" + spaces + \"\\\\)\" + spaces + \"$\";\n    string catch_pattern = \"^\" + spaces + \"catch\" + spaces + \"\\\\(\" + spaces + \"(\" + exception_type + \")\" + spaces + \",\" + spaces + \"\\\"\" + spaces + \"(\" + message_content + \")\" + spaces + \"\\\"\" + spaces + \"\\\\)\" + spaces + \"$\";\n\n    regex empty_line_regex(\"^\" + spaces + \"$\");\n    regex try_regex(try_pattern);\n    regex throw_regex(throw_pattern);\n    regex catch_regex(catch_pattern);\n\n    int open_try_blocks = 0;\n    int total_throw_operators = 0;\n\n    int line_number = 2; // Line numbers start after the first line with n\n\n    for (int i = 0; i < n; ++i, ++line_number) {\n        string line = inf.readLine();\n\n        ensuref(line.length() <= 50, \"Line %d is longer than 50 characters\", line_number);\n\n        // If line is empty or consists only of spaces, skip\n        if (regex_match(line, empty_line_regex)) {\n            continue;\n        }\n\n        smatch sm;\n        if (regex_match(line, try_regex)) {\n            open_try_blocks++;\n        } else if (regex_match(line, sm, throw_regex)) {\n            total_throw_operators++;\n            ensuref(total_throw_operators <= 1, \"More than one throw operator\");\n            // Exception type is sm[1], already validated by regex\n        } else if (regex_match(line, sm, catch_regex)) {\n            ensuref(open_try_blocks > 0, \"Line %d: catch operator without matching try\", line_number);\n            open_try_blocks--;\n            // Exception type is sm[1], message is sm[2], already validated by regex\n        } else {\n            ensuref(false, \"Line %d did not match any valid operator\", line_number);\n        }\n    }\n\n    ensuref(open_try_blocks == 0, \"There are %d unmatched try blocks\", open_try_blocks);\n    ensuref(total_throw_operators == 1, \"There must be exactly one throw operator, found %d\", total_throw_operators);\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string spaces = \"[ \\\\t]*\";\n    string exception_type = \"[A-Za-z]{1,20}\";\n    string message_content = \"[A-Za-z0-9 ]{1,20}\";\n\n    string try_pattern = \"^\" + spaces + \"try\" + spaces + \"$\";\n    string throw_pattern = \"^\" + spaces + \"throw\" + spaces + \"\\\\(\" + spaces + \"(\" + exception_type + \")\" + spaces + \"\\\\)\" + spaces + \"$\";\n    string catch_pattern = \"^\" + spaces + \"catch\" + spaces + \"\\\\(\" + spaces + \"(\" + exception_type + \")\" + spaces + \",\" + spaces + \"\\\"\" + spaces + \"(\" + message_content + \")\" + spaces + \"\\\"\" + spaces + \"\\\\)\" + spaces + \"$\";\n\n    regex empty_line_regex(\"^\" + spaces + \"$\");\n    regex try_regex(try_pattern);\n    regex throw_regex(throw_pattern);\n    regex catch_regex(catch_pattern);\n\n    int open_try_blocks = 0;\n    int total_throw_operators = 0;\n\n    int line_number = 2; // Line numbers start after the first line with n\n\n    for (int i = 0; i < n; ++i, ++line_number) {\n        string line = inf.readLine();\n\n        ensuref(line.length() <= 50, \"Line %d is longer than 50 characters\", line_number);\n\n        // If line is empty or consists only of spaces, skip\n        if (regex_match(line, empty_line_regex)) {\n            continue;\n        }\n\n        smatch sm;\n        if (regex_match(line, try_regex)) {\n            open_try_blocks++;\n        } else if (regex_match(line, sm, throw_regex)) {\n            total_throw_operators++;\n            ensuref(total_throw_operators <= 1, \"More than one throw operator\");\n            // Exception type is sm[1], already validated by regex\n        } else if (regex_match(line, sm, catch_regex)) {\n            ensuref(open_try_blocks > 0, \"Line %d: catch operator without matching try\", line_number);\n            open_try_blocks--;\n            // Exception type is sm[1], message is sm[2], already validated by regex\n        } else {\n            ensuref(false, \"Line %d did not match any valid operator\", line_number);\n        }\n    }\n\n    ensuref(open_try_blocks == 0, \"There are %d unmatched try blocks\", open_try_blocks);\n    ensuref(total_throw_operators == 1, \"There must be exactly one throw operator, found %d\", total_throw_operators);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string spaces = \"[ \\\\t]*\";\n    string exception_type = \"[A-Za-z]{1,20}\";\n    string message_content = \"[A-Za-z0-9 ]{1,20}\";\n\n    string try_pattern = \"^\" + spaces + \"try\" + spaces + \"$\";\n    string throw_pattern = \"^\" + spaces + \"throw\" + spaces + \"\\\\(\" + spaces + \"(\" + exception_type + \")\" + spaces + \"\\\\)\" + spaces + \"$\";\n    string catch_pattern = \"^\" + spaces + \"catch\" + spaces + \"\\\\(\" + spaces + \"(\" + exception_type + \")\" + spaces + \",\" + spaces + \"\\\"\" + spaces + \"(\" + message_content + \")\" + spaces + \"\\\"\" + spaces + \"\\\\)\" + spaces + \"$\";\n\n    regex empty_line_regex(\"^\" + spaces + \"$\");\n    regex try_regex(try_pattern);\n    regex throw_regex(throw_pattern);\n    regex catch_regex(catch_pattern);\n\n    int open_try_blocks = 0;\n    int total_throw_operators = 0;\n\n    int line_number = 2; // Line numbers start after the first line with n\n\n    for (int i = 0; i < n; ++i, ++line_number) {\n        string line = inf.readLine();\n\n        ensuref(line.length() <= 50, \"Line %d is longer than 50 characters\", line_number);\n\n        // If line is empty or consists only of spaces, skip\n        if (regex_match(line, empty_line_regex)) {\n            continue;\n        }\n\n        smatch sm;\n        if (regex_match(line, try_regex)) {\n            open_try_blocks++;\n        } else if (regex_match(line, sm, throw_regex)) {\n            total_throw_operators++;\n            ensuref(total_throw_operators <= 1, \"More than one throw operator\");\n            // Exception type is sm[1], already validated by regex\n        } else if (regex_match(line, sm, catch_regex)) {\n            ensuref(open_try_blocks > 0, \"Line %d: catch operator without matching try\", line_number);\n            open_try_blocks--;\n            // Exception type is sm[1], message is sm[2], already validated by regex\n        } else {\n            ensuref(false, \"Line %d did not match any valid operator\", line_number);\n        }\n    }\n\n    ensuref(open_try_blocks == 0, \"There are %d unmatched try blocks\", open_try_blocks);\n    ensuref(total_throw_operators == 1, \"There must be exactly one throw operator, found %d\", total_throw_operators);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring random_exception_type() {\n    int len = rnd.next(1, 20);\n    string s;\n    for (int i = 0; i < len; ++i) {\n        int t = rnd.next(2);\n        if (t == 0) {\n            s += (char)rnd.next('A', 'Z');\n        } else {\n            s += (char)rnd.next('a', 'z');\n        }\n    }\n    return s;\n}\n\nstring random_message() {\n    int len = rnd.next(1, 20);\n    string s;\n    for (int i = 0; i < len; ++i) {\n        int t = rnd.next(4);\n        if (t == 0) {\n            s += (char)rnd.next('A', 'Z');\n        } else if (t == 1) {\n            s += (char)rnd.next('a', 'z');\n        } else if (t == 2) {\n            s += (char)rnd.next('0', '9');\n        } else {\n            s += ' ';\n        }\n    }\n    // Trim leading and trailing spaces to ensure non-empty\n    s = s.erase(s.find_last_not_of(' ') + 1);\n    s = s.erase(0, s.find_first_not_of(' '));\n    if (s.empty()) s = \"message\";\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        vector<string> program;\n        int total_lines = 0;\n        int open_try_blocks = 0;\n        bool throw_inserted = false;\n\n        while (total_lines < n) {\n            int action = rnd.next(4);\n\n            if (throw_inserted == false && open_try_blocks > 0 && rnd.next(0, 10) < 2) {\n                // Insert throw operator\n                string exception_type = random_exception_type();\n                string line = \"    throw (\" + exception_type + \")\";\n                if (line.length() > 50) line = \"throw (\" + exception_type + \")\";\n                program.push_back(line);\n                throw_inserted = true;\n                total_lines++;\n                continue;\n            }\n\n            if (action == 0 && total_lines + 1 <= n) {\n                // Open a try block\n                string line = \"try\";\n                program.push_back(line);\n                open_try_blocks++;\n                total_lines++;\n            } else if (action == 1 && open_try_blocks > 0 && total_lines + 1 <= n) {\n                // Close a try block with catch\n                string exception_type = random_exception_type();\n                string message = random_message();\n                string line = \"catch(\" + exception_type + \", \\\"\" + message + \"\\\")\";\n                if (line.length() > 50) {\n                    exception_type = \"Exc\";\n                    message = \"Msg\";\n                    line = \"catch(\" + exception_type + \", \\\"\" + message + \"\\\")\";\n                }\n                program.push_back(line);\n                open_try_blocks--;\n                total_lines++;\n            } else {\n                // Insert empty line or line with spaces\n                if (rnd.next(0, 1) == 0) {\n                    program.push_back(\"\");\n                } else {\n                    int spaces = rnd.next(1, 5);\n                    string line(spaces, ' ');\n                    program.push_back(line);\n                }\n                total_lines++;\n            }\n\n            if (total_lines >= n - open_try_blocks) {\n                // Need to make room to close all try blocks\n                while (open_try_blocks > 0) {\n                    string exception_type = random_exception_type();\n                    string message = random_message();\n                    string line = \"catch(\" + exception_type + \", \\\"\" + message + \"\\\")\";\n                    program.push_back(line);\n                    open_try_blocks--;\n                    total_lines++;\n                    if (total_lines == n) break;\n                }\n                break;\n            }\n        }\n\n        // Ensure that all open try blocks are closed\n        while (open_try_blocks > 0 && total_lines < n) {\n            string exception_type = random_exception_type();\n            string message = random_message();\n            string line = \"catch(\" + exception_type + \", \\\"\" + message + \"\\\")\";\n            program.push_back(line);\n            open_try_blocks--;\n            total_lines++;\n        }\n\n        // If throw was not inserted, insert it somewhere\n        if (!throw_inserted) {\n            int pos = rnd.next(0, (int)program.size() - 1);\n            string exception_type = random_exception_type();\n            string line = \"throw (\" + exception_type + \")\";\n            program.insert(program.begin() + pos, line);\n        }\n\n        printf(\"%d\\n\", (int)program.size());\n        for (const string& line : program) {\n            printf(\"%s\\n\", line.c_str());\n        }\n    } else if (type == \"unhandled\") {\n        vector<string> program;\n        int open_try_blocks = 0;\n\n        // Generate a set of exception types for catch blocks\n        vector<string> catch_exception_types;\n        int num_catches = rnd.next(1, min(10, n / 2));\n        for (int i = 0; i < num_catches; ++i) {\n            string exception_type = random_exception_type();\n            catch_exception_types.push_back(exception_type);\n        }\n\n        // Generate a throw with an exception type that does not match\n        string throw_exception_type = \"UnhandledException\";\n        // Ensure it's different from any exception type in catches\n        for (const string& et : catch_exception_types) {\n            if (et == throw_exception_type) {\n                throw_exception_type += \"X\";\n                break;\n            }\n        }\n\n        // Open try blocks\n        for (int i = 0; i < num_catches; ++i) {\n            program.push_back(\"try\");\n            open_try_blocks++;\n        }\n\n        // Insert throw operator\n        program.push_back(\"throw (\" + throw_exception_type + \")\");\n\n        // Close try blocks with catches\n        for (int i = 0; i < num_catches; ++i) {\n            string line = \"catch(\" + catch_exception_types[i] + \", \\\"\" + random_message() + \"\\\")\";\n            program.push_back(line);\n            open_try_blocks--;\n        }\n\n        printf(\"%d\\n\", (int)program.size());\n        for (const string& line : program) {\n            printf(\"%s\\n\", line.c_str());\n        }\n    } else if (type == \"multiple_catches\") {\n        vector<string> program;\n\n        string exception_type = random_exception_type();\n\n        // Open first try\n        program.push_back(\"try\");\n\n        // Open second try\n        program.push_back(\"try\");\n\n        // Insert throw inside second try block\n        program.push_back(\"throw (\" + exception_type + \")\");\n\n        // Close second try with catch that matches the exception\n        program.push_back(\"catch(\" + exception_type + \", \\\"Second catch\\\")\");\n\n        // Close first try with catch that matches the exception\n        program.push_back(\"catch(\" + exception_type + \", \\\"First catch\\\")\");\n\n        printf(\"%d\\n\", (int)program.size());\n        for (const string& line : program) {\n            printf(\"%s\\n\", line.c_str());\n        }\n    } else if (type == \"nested\") {\n        vector<string> program;\n\n        int depth = rnd.next(1, min(10000, n / 2));\n\n        string exception_type = random_exception_type();\n\n        // Open try blocks\n        for (int i = 0; i < depth && (int)program.size() < n - 2; ++i) {\n            program.push_back(\"try\");\n        }\n\n        // Insert throw at a position\n        int throw_pos = rnd.next(depth / 2, depth - 1);\n        if (throw_pos >= (int)program.size()) throw_pos = (int)program.size() - 1;\n        program.insert(program.begin() + throw_pos, \"throw (\" + exception_type + \")\");\n\n        // Close try blocks\n        for (int i = 0; i < depth && (int)program.size() < n; ++i) {\n            string line = \"catch(\" + exception_type + \", \\\"Nested catch \" + to_string(i) + \"\\\")\";\n            program.push_back(line);\n        }\n\n        // Fill remaining lines\n        while ((int)program.size() < n) {\n            program.push_back(\"\");\n        }\n\n        printf(\"%d\\n\", (int)program.size());\n        for (const string& line : program) {\n            printf(\"%s\\n\", line.c_str());\n        }\n\n    } else if (type == \"max_spaces\") {\n        vector<string> program;\n\n        // Open try block with spaces\n        string line = \"\";\n        line += string(5, ' ');\n        line += \"try\";\n        line += string(5, ' ');\n        if (line.length() > 50) line = \"try\";\n        program.push_back(line);\n\n        // Insert empty lines with spaces\n        while ((int)program.size() < n - 2) {\n            program.push_back(string(40, ' '));\n        }\n\n        // Insert throw operator\n        string exception_type = random_exception_type();\n        line = string(5, ' ');\n        line += \"throw\";\n        line += string(5, ' ');\n        line += \"(\";\n        line += exception_type;\n        line += \")\";\n        if (line.length() > 50) line = \"throw(\" + exception_type + \")\";\n        program.push_back(line);\n\n        // Close try block with catch\n        string message = random_message();\n        line = string(5, ' ');\n        line += \"catch\";\n        line += \"(\";\n        line += exception_type;\n        line += \", \";\n        line += \"\\\"\" + message + \"\\\"\";\n        line += \")\";\n        if (line.length() > 50) line = \"catch(\" + exception_type + \", \\\"\" + message + \"\\\")\";\n        program.push_back(line);\n\n        printf(\"%d\\n\", (int)program.size());\n        for (const string& line : program) {\n            printf(\"%s\\n\", line.c_str());\n        }\n    } else {\n        // Default to random\n        // You can add code here to handle other types or default behavior\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring random_exception_type() {\n    int len = rnd.next(1, 20);\n    string s;\n    for (int i = 0; i < len; ++i) {\n        int t = rnd.next(2);\n        if (t == 0) {\n            s += (char)rnd.next('A', 'Z');\n        } else {\n            s += (char)rnd.next('a', 'z');\n        }\n    }\n    return s;\n}\n\nstring random_message() {\n    int len = rnd.next(1, 20);\n    string s;\n    for (int i = 0; i < len; ++i) {\n        int t = rnd.next(4);\n        if (t == 0) {\n            s += (char)rnd.next('A', 'Z');\n        } else if (t == 1) {\n            s += (char)rnd.next('a', 'z');\n        } else if (t == 2) {\n            s += (char)rnd.next('0', '9');\n        } else {\n            s += ' ';\n        }\n    }\n    // Trim leading and trailing spaces to ensure non-empty\n    s = s.erase(s.find_last_not_of(' ') + 1);\n    s = s.erase(0, s.find_first_not_of(' '));\n    if (s.empty()) s = \"message\";\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        vector<string> program;\n        int total_lines = 0;\n        int open_try_blocks = 0;\n        bool throw_inserted = false;\n\n        while (total_lines < n) {\n            int action = rnd.next(4);\n\n            if (throw_inserted == false && open_try_blocks > 0 && rnd.next(0, 10) < 2) {\n                // Insert throw operator\n                string exception_type = random_exception_type();\n                string line = \"    throw (\" + exception_type + \")\";\n                if (line.length() > 50) line = \"throw (\" + exception_type + \")\";\n                program.push_back(line);\n                throw_inserted = true;\n                total_lines++;\n                continue;\n            }\n\n            if (action == 0 && total_lines + 1 <= n) {\n                // Open a try block\n                string line = \"try\";\n                program.push_back(line);\n                open_try_blocks++;\n                total_lines++;\n            } else if (action == 1 && open_try_blocks > 0 && total_lines + 1 <= n) {\n                // Close a try block with catch\n                string exception_type = random_exception_type();\n                string message = random_message();\n                string line = \"catch(\" + exception_type + \", \\\"\" + message + \"\\\")\";\n                if (line.length() > 50) {\n                    exception_type = \"Exc\";\n                    message = \"Msg\";\n                    line = \"catch(\" + exception_type + \", \\\"\" + message + \"\\\")\";\n                }\n                program.push_back(line);\n                open_try_blocks--;\n                total_lines++;\n            } else {\n                // Insert empty line or line with spaces\n                if (rnd.next(0, 1) == 0) {\n                    program.push_back(\"\");\n                } else {\n                    int spaces = rnd.next(1, 5);\n                    string line(spaces, ' ');\n                    program.push_back(line);\n                }\n                total_lines++;\n            }\n\n            if (total_lines >= n - open_try_blocks) {\n                // Need to make room to close all try blocks\n                while (open_try_blocks > 0) {\n                    string exception_type = random_exception_type();\n                    string message = random_message();\n                    string line = \"catch(\" + exception_type + \", \\\"\" + message + \"\\\")\";\n                    program.push_back(line);\n                    open_try_blocks--;\n                    total_lines++;\n                    if (total_lines == n) break;\n                }\n                break;\n            }\n        }\n\n        // Ensure that all open try blocks are closed\n        while (open_try_blocks > 0 && total_lines < n) {\n            string exception_type = random_exception_type();\n            string message = random_message();\n            string line = \"catch(\" + exception_type + \", \\\"\" + message + \"\\\")\";\n            program.push_back(line);\n            open_try_blocks--;\n            total_lines++;\n        }\n\n        // If throw was not inserted, insert it somewhere\n        if (!throw_inserted) {\n            int pos = rnd.next(0, (int)program.size() - 1);\n            string exception_type = random_exception_type();\n            string line = \"throw (\" + exception_type + \")\";\n            program.insert(program.begin() + pos, line);\n        }\n\n        printf(\"%d\\n\", (int)program.size());\n        for (const string& line : program) {\n            printf(\"%s\\n\", line.c_str());\n        }\n    } else if (type == \"unhandled\") {\n        vector<string> program;\n        int open_try_blocks = 0;\n\n        // Generate a set of exception types for catch blocks\n        vector<string> catch_exception_types;\n        int num_catches = rnd.next(1, min(10, n / 2));\n        for (int i = 0; i < num_catches; ++i) {\n            string exception_type = random_exception_type();\n            catch_exception_types.push_back(exception_type);\n        }\n\n        // Generate a throw with an exception type that does not match\n        string throw_exception_type = \"UnhandledException\";\n        // Ensure it's different from any exception type in catches\n        for (const string& et : catch_exception_types) {\n            if (et == throw_exception_type) {\n                throw_exception_type += \"X\";\n                break;\n            }\n        }\n\n        // Open try blocks\n        for (int i = 0; i < num_catches; ++i) {\n            program.push_back(\"try\");\n            open_try_blocks++;\n        }\n\n        // Insert throw operator\n        program.push_back(\"throw (\" + throw_exception_type + \")\");\n\n        // Close try blocks with catches\n        for (int i = 0; i < num_catches; ++i) {\n            string line = \"catch(\" + catch_exception_types[i] + \", \\\"\" + random_message() + \"\\\")\";\n            program.push_back(line);\n            open_try_blocks--;\n        }\n\n        printf(\"%d\\n\", (int)program.size());\n        for (const string& line : program) {\n            printf(\"%s\\n\", line.c_str());\n        }\n    } else if (type == \"multiple_catches\") {\n        vector<string> program;\n\n        string exception_type = random_exception_type();\n\n        // Open first try\n        program.push_back(\"try\");\n\n        // Open second try\n        program.push_back(\"try\");\n\n        // Insert throw inside second try block\n        program.push_back(\"throw (\" + exception_type + \")\");\n\n        // Close second try with catch that matches the exception\n        program.push_back(\"catch(\" + exception_type + \", \\\"Second catch\\\")\");\n\n        // Close first try with catch that matches the exception\n        program.push_back(\"catch(\" + exception_type + \", \\\"First catch\\\")\");\n\n        printf(\"%d\\n\", (int)program.size());\n        for (const string& line : program) {\n            printf(\"%s\\n\", line.c_str());\n        }\n    } else if (type == \"nested\") {\n        vector<string> program;\n\n        int depth = rnd.next(1, min(10000, n / 2));\n\n        string exception_type = random_exception_type();\n\n        // Open try blocks\n        for (int i = 0; i < depth && (int)program.size() < n - 2; ++i) {\n            program.push_back(\"try\");\n        }\n\n        // Insert throw at a position\n        int throw_pos = rnd.next(depth / 2, depth - 1);\n        if (throw_pos >= (int)program.size()) throw_pos = (int)program.size() - 1;\n        program.insert(program.begin() + throw_pos, \"throw (\" + exception_type + \")\");\n\n        // Close try blocks\n        for (int i = 0; i < depth && (int)program.size() < n; ++i) {\n            string line = \"catch(\" + exception_type + \", \\\"Nested catch \" + to_string(i) + \"\\\")\";\n            program.push_back(line);\n        }\n\n        // Fill remaining lines\n        while ((int)program.size() < n) {\n            program.push_back(\"\");\n        }\n\n        printf(\"%d\\n\", (int)program.size());\n        for (const string& line : program) {\n            printf(\"%s\\n\", line.c_str());\n        }\n\n    } else if (type == \"max_spaces\") {\n        vector<string> program;\n\n        // Open try block with spaces\n        string line = \"\";\n        line += string(5, ' ');\n        line += \"try\";\n        line += string(5, ' ');\n        if (line.length() > 50) line = \"try\";\n        program.push_back(line);\n\n        // Insert empty lines with spaces\n        while ((int)program.size() < n - 2) {\n            program.push_back(string(40, ' '));\n        }\n\n        // Insert throw operator\n        string exception_type = random_exception_type();\n        line = string(5, ' ');\n        line += \"throw\";\n        line += string(5, ' ');\n        line += \"(\";\n        line += exception_type;\n        line += \")\";\n        if (line.length() > 50) line = \"throw(\" + exception_type + \")\";\n        program.push_back(line);\n\n        // Close try block with catch\n        string message = random_message();\n        line = string(5, ' ');\n        line += \"catch\";\n        line += \"(\";\n        line += exception_type;\n        line += \", \";\n        line += \"\\\"\" + message + \"\\\"\";\n        line += \")\";\n        if (line.length() > 50) line = \"catch(\" + exception_type + \", \\\"\" + message + \"\\\")\";\n        program.push_back(line);\n\n        printf(\"%d\\n\", (int)program.size());\n        for (const string& line : program) {\n            printf(\"%s\\n\", line.c_str());\n        }\n    } else {\n        // Default to random\n        // You can add code here to handle other types or default behavior\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type random\n./gen -n 10 -type unhandled\n./gen -n 10 -type multiple_catches\n./gen -n 10 -type nested\n./gen -n 10 -type max_spaces\n\n./gen -n 100 -type random\n./gen -n 100 -type unhandled\n./gen -n 100 -type multiple_catches\n./gen -n 100 -type nested\n./gen -n 100 -type max_spaces\n\n./gen -n 1000 -type random\n./gen -n 1000 -type unhandled\n./gen -n 1000 -type multiple_catches\n./gen -n 1000 -type nested\n./gen -n 1000 -type max_spaces\n\n./gen -n 10000 -type random\n./gen -n 10000 -type nested\n\n./gen -n 20000 -type random\n./gen -n 50000 -type nested\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:56.480187",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "195/D",
      "title": "D. Исследование ломаной",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 105) — количество функций. Далее в n строках через пробел записано по два целых числа ki, bi ( - 109 ≤ ki, bi ≤ 109), определяющих i-ую функцию.",
      "output_spec": "Выходные данныеВыведите одно число — количество углов, не равных 180 градусам, в графике ломаной, равной сумме заданных функций.",
      "sample_tests": "ПримерыВходные данныеСкопировать11 0Выходные данныеСкопировать1Входные данныеСкопировать31 00 2-1 1Выходные данныеСкопировать2Входные данныеСкопировать3-2 -41 7-5 1Выходные данныеСкопировать3",
      "description": "D. Исследование ломаной\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 105) — количество функций. Далее в n строках через пробел записано по два целых числа ki, bi ( - 109 ≤ ki, bi ≤ 109), определяющих i-ую функцию.\n\nВходные данные\n\nВыходные данныеВыведите одно число — количество углов, не равных 180 градусам, в графике ломаной, равной сумме заданных функций.\n\nВыходные данные\n\nВходные данныеСкопировать11 0Выходные данныеСкопировать1Входные данныеСкопировать31 00 2-1 1Выходные данныеСкопировать2Входные данныеСкопировать3-2 -41 7-5 1Выходные данныеСкопировать3\n\nВходные данныеСкопировать11 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать31 00 2-1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3-2 -41 7-5 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces",
          "content": "Здравствуйте, друзья)Рады приветствовать вас на очередном раунде Codeforces #123 для участников Div. 2. Традиционно, остальные могут поучаствовать в нем вне конкурса.Задачи для вас были подготовлены группой авторов в составе: Иван Фефер (Fefer_Ivan), Игорь Кудряшов (Igor_Kudryashov), Павел Холкин (HolkinPV), а также Геральд Агапов (Gerald). Также говорим спасибо Кунявскому Павлу (PavelKunyavskiy) и Александру Куприну (Alex_KPR) за помощь в подготовке раунда. Традиционно хотим поблагодарить Михаила Мирзаянова (MikeMirzayanov) за систему Codeforces и Марию Белову (Delinur) за перевод условий.Распределение баллов по задачам стандартное: 500, 1000, 1500, 2000, 2500.Всем участникам желаем успехов и высокого рейтинга!UPD: контест завершен, разбор задач появился здесьПоздравляем победителей: bmerry adrian.jaskolka cheshire_cat alexej psw",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 842
        },
        {
          "title": "403 Forbidden",
          "content": "403 Forbidden\nnginx/1.27.4",
          "author": "Unknown",
          "url": "http://www.codeforces.com/blog/entry/4696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 26
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Разбор Задач - Codeforces",
          "content": "195A - Посмотрим футболПолное видео скачается через all = (c·a + b - 1) / b секунд. В этой задаче можно было перебрать величину ответа 1 <  = t <  = all. Чтобы удовлетворить условию задачи, достаточно проверить, что в последний момент времени t0 = all выполняется условие, написанное в тексте задачи, а именно t0·b >  = (t0 - t)·a.195B - После тренировкиВ этой задаче нужно было аккуратно реализовать описанный в условии процесс. Вначале заметим, что мяч с номером i > m попадет в одну корзину с мячом под номером i - m. Поэтому достаточно распределить первые m мячей. Это удобно сделать при помощи двух указателей lf, rg, начиная с середины. Поочередно кладем мяч сначала слева, затем справа и двигаем указатели. Единственный раз, когда нужно дважды подвинуть левый указателей, возникает в самый первый момент, если m нечетно.195C - Попробуй поймайДанная задача носила реализационный характер. В своем решении я поступал следующим образом. Удалим из текста все пробелы, кроме пробелов в сообщениях try-catch блоков. Затем при появлении слова try, кладем номер нового try-catch блока в стек. При появлени слова throw, запомним его тип, а также текущее состояние стека (то есть какие try-catch блоки открыты). Для этого, например, положим номера открытых блоков в set. При появлении слова catch, если тип блока совпадает с типом оператора throw, а также номер текущего блока находился в стеке при появлении оператора throw (то есть он есть в нашем set-е), то сразу выводим ответ. Иначе удаляем текущий try-catch блок из стека. Если подходящего try-catch блока так и не найдется, в конце выводим фразу \"Unhandled Exception\". 195D - Исследование ломанойРазбор от автора Igor_KudryashovВ данной задаче были заданы по сути прямые в виде yi = ki * x + bi, но в тех точках, где y принимает отрицательное значение, оно заменено нулем. Необходимо было найти количество углов, не равных 180 градусам, в графике функции, равной сумме функций указанного вида.Во-первых, несложно показать, что сумма прямых является прямой. В самом деле, если y = y1 + y2, то y = k1 * x + b1 + k2 * x + b2 = (k1 + k2) * x + (b1 + b2). Рассмотрим точки, в которых yi = 0, т.е. xi =  - bi / ki. Пока предположим, что ki не равно 0. Тогда i-ая функция разбивается на две прямые, одна из которых тождественно равна 0. Оставим среди xi различные точки и упорядочим их по возрастанию значения. Тогда, очевидно, между двумя соседними точками суммой заданных функций является прямая. Найдем уравнение этой прямой. Предположим, мы рассматриваем i-ую слева точку. Тогда если уравнение прямой между i-ой и (i + 1)-ой точками, отлично от уравнения прямой между (i - 1)-ой и i-ой точками, тогда в i-ой точке образуется угол, не равный 180 градусам.Таким образом, нам необходимо найти уравнение прямых на отрезках между соседними точками x, т.е. найти коэффициенты k и b. Это можно легко сделать с использованием 2 массивов запросами увеличения на отрезке в оффлайне.Когда мы обрабатываем очередную функцию, мы смотрим, если ki равно 0, то нужно ко всем отрезкам прибавить одну и ту же величину, но т.к. данное изменение не повлияет на ответ, то можно не обрабатывать функции такого вида. Если ki не равно 0, то найдем индекс j точки xi в упорядоченном списке x. Теперь если ki больше 0, то нужно сделать увеличение на суффиксе, начиная с позиции j, иначе нужно сделать увеличение на префиксе до позиции j (при этом увеличение на префиксе коэффициента k будет производиться на отрицательную величину).195E - Построение лесаРазбор от автора Fefer_IvanВ этой задаче самой долгой операцией является поиск корня вершины и длина пути до него. Эту операцию можно выполнять быстро используя эвристику сжатия путей. Такой же метод применяется в структуре данных Disjoint Set Union.Для каждой вершины v мы будем хранить два числа: c[v] и sum[v]. c[v] = v, если v — корень, иначе c[v] — следующая вершина на пути от v к корню. sum[v] = сумме длин ребер на пути от v до c[v].Таким образом для того, чтобы добавить ребро из u в v веса w, достаточно c[u] = v, а sum[u] = w. Теперь мы можем за O(n) находить по вершине нужные нам в задаче root(v) и depth(v) просто переходя каждый раз из v в c[v] и суммируя все sum[v] по пути.Заметим, что мы только добавляем ребра, но не удаляем. Это значит, что если мы для вершины v нашли root(v) и depth(v), то можно присвоить c[v] = root(v), sum[v] = depth(v). Таким образом в следующий раз мы найдем предка вершины v за О(1). В общем реализация этого подхода выглядит следующим образом: int root(int v){ \n if(c[v] == v){ \n return v; \n }else{ \n int u = root(c[v]); \n sum[v] = (sum[c[v]] + sum[v]) % M; \n c[v] = u; \n return u; \n } \n} Доказывается, что такая реализация работает в сумме за время, пропроциональное обратной фунции Аккермана http://en.wikipedia.org/wiki/Ackermann_function#Inverse) на запрос при применении ранговой эвристики. Поскольку в этом случае нельзя её применить, то такой запрос обрабатывается за log(n). Итого получаем решение за время O(n * log * (n)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4699",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 195\\s*D"
          },
          "content_length": 4957
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 1",
          "code": "set<long double>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 2",
          "code": "int root(int v){\n    if(c[v] == v){\n        return v;\n    }else{\n        int u = root(c[v]);\n        sum[v] = (sum[c[v]] + sum[v]) % M;\n        c[v] = u;\n        return u;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 3",
          "code": "int root(int v){\n    if(c[v] == v){\n        return v;\n    }else{\n        int u = root(c[v]);\n        sum[v] = (sum[c[v]] + sum[v]) % M;\n        c[v] = u;\n        return u;\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 4",
          "code": "FAIL Expected EOLN (stdin)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 5",
          "code": "abs((M + 1) - 2 * a.second)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 6",
          "code": "t.cha[len] = '\\0';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 7",
          "code": "t.msg[len] = '\\0';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 8",
          "code": "cin.getline(s,55,'\\n');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 9",
          "code": "down_time = (c*a + b - 1) / b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Разбор Задач - Codeforces - Code 1",
          "code": "int root(int v){  \n   if(c[v] == v){  \n       return v;  \n   }else{  \n       int u = root(c[v]);  \n       sum[v] = (sum[c[v]] + sum[v]) % M;  \n       c[v] = u;  \n       return u;  \n   }  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Разбор Задач - Codeforces - Code 2",
          "code": "int root(int v){  \n   if(c[v] == v){  \n       return v;  \n   }else{  \n       int u = root(c[v]);  \n       sum[v] = (sum[c[v]] + sum[v]) % M;  \n       c[v] = u;  \n       return u;  \n   }  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Разбор Задач - Codeforces - Code 3",
          "code": "for(int i = 0; i < n; ++i)\n    printf(\"%d\", a[i % m]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Разбор Задач - Codeforces - Code 4",
          "code": "for(int i = 0; i < n; ++i)\n    printf(\"%d\", a[i % m]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Разбор Задач - Codeforces - Code 5",
          "code": "Точки изломов не пропадают, т.к. производная будет кусочно - постоянной неубывающей функцией с точками разрыва = -b/k. (с точки зрения математика)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4699",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int k_i = inf.readInt(-1000000000, 1000000000, \"k_i\");\n        inf.readSpace();\n        int b_i = inf.readInt(-1000000000, 1000000000, \"b_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int k_i = inf.readInt(-1000000000, 1000000000, \"k_i\");\n        inf.readSpace();\n        int b_i = inf.readInt(-1000000000, 1000000000, \"b_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int k_i = inf.readInt(-1000000000, 1000000000, \"k_i\");\n        inf.readSpace();\n        int b_i = inf.readInt(-1000000000, 1000000000, \"b_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> k(n), b(n);\n\n    if (type == \"zeros\") {\n        /* All k_i and b_i are zero */\n        fill(k.begin(), k.end(), 0);\n        fill(b.begin(), b.end(), 0);\n    } else if (type == \"same_k\") {\n        /* All k_i are the same non-zero value */\n        int ki = rnd.next(-1000000000, 1000000000);\n        for(int i = 0; i < n; ++i) {\n            k[i] = ki;\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"altern_k\") {\n        /* k_i alternate between positive and negative values */\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                k[i] = rnd.next(1, 1000000000);\n            else\n                k[i] = rnd.next(-1000000000, -1);\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"all_positive_k\") {\n        /* All k_i are positive */\n        for(int i = 0; i < n; ++i) {\n            k[i] = rnd.next(1, 1000000000);\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"all_negative_k\") {\n        /* All k_i are negative */\n        for(int i = 0; i < n; ++i) {\n            k[i] = rnd.next(-1000000000, -1);\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"max_k_positive\") {\n        /* All k_i are the maximum positive value */\n        for(int i = 0; i < n; ++i) {\n            k[i] = 1000000000;\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"max_k_negative\") {\n        /* All k_i are the minimum negative value */\n        for(int i = 0; i < n; ++i) {\n            k[i] = -1000000000;\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"large_b\") {\n        /* All b_i are the maximum value */\n        for(int i = 0; i < n; ++i) {\n            k[i] = rnd.next(-1000000000, 1000000000);\n            b[i] = 1000000000;\n        }\n    } else if (type == \"min_b\") {\n        /* All b_i are the minimum value */\n        for(int i = 0; i < n; ++i) {\n            k[i] = rnd.next(-1000000000, 1000000000);\n            b[i] = -1000000000;\n        }\n    } else {\n        /* Random k_i and b_i */\n        for(int i = 0; i < n; ++i) {\n            k[i] = rnd.next(-1000000000, 1000000000);\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output k_i and b_i */\n    for (int i = 0; i < n; i++)\n        printf(\"%d %d\\n\", k[i], b[i]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> k(n), b(n);\n\n    if (type == \"zeros\") {\n        /* All k_i and b_i are zero */\n        fill(k.begin(), k.end(), 0);\n        fill(b.begin(), b.end(), 0);\n    } else if (type == \"same_k\") {\n        /* All k_i are the same non-zero value */\n        int ki = rnd.next(-1000000000, 1000000000);\n        for(int i = 0; i < n; ++i) {\n            k[i] = ki;\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"altern_k\") {\n        /* k_i alternate between positive and negative values */\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                k[i] = rnd.next(1, 1000000000);\n            else\n                k[i] = rnd.next(-1000000000, -1);\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"all_positive_k\") {\n        /* All k_i are positive */\n        for(int i = 0; i < n; ++i) {\n            k[i] = rnd.next(1, 1000000000);\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"all_negative_k\") {\n        /* All k_i are negative */\n        for(int i = 0; i < n; ++i) {\n            k[i] = rnd.next(-1000000000, -1);\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"max_k_positive\") {\n        /* All k_i are the maximum positive value */\n        for(int i = 0; i < n; ++i) {\n            k[i] = 1000000000;\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"max_k_negative\") {\n        /* All k_i are the minimum negative value */\n        for(int i = 0; i < n; ++i) {\n            k[i] = -1000000000;\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"large_b\") {\n        /* All b_i are the maximum value */\n        for(int i = 0; i < n; ++i) {\n            k[i] = rnd.next(-1000000000, 1000000000);\n            b[i] = 1000000000;\n        }\n    } else if (type == \"min_b\") {\n        /* All b_i are the minimum value */\n        for(int i = 0; i < n; ++i) {\n            k[i] = rnd.next(-1000000000, 1000000000);\n            b[i] = -1000000000;\n        }\n    } else {\n        /* Random k_i and b_i */\n        for(int i = 0; i < n; ++i) {\n            k[i] = rnd.next(-1000000000, 1000000000);\n            b[i] = rnd.next(-1000000000, 1000000000);\n        }\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output k_i and b_i */\n    for (int i = 0; i < n; i++)\n        printf(\"%d %d\\n\", k[i], b[i]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type zeros\n./gen -n 2 -type zeros\n./gen -n 10 -type zeros\n./gen -n 100000 -type zeros\n\n./gen -n 1 -type same_k\n./gen -n 10 -type same_k\n./gen -n 100000 -type same_k\n\n./gen -n 1 -type altern_k\n./gen -n 10 -type altern_k\n./gen -n 100000 -type altern_k\n\n./gen -n 1 -type all_positive_k\n./gen -n 10 -type all_positive_k\n./gen -n 100000 -type all_positive_k\n\n./gen -n 1 -type all_negative_k\n./gen -n 10 -type all_negative_k\n./gen -n 100000 -type all_negative_k\n\n./gen -n 1 -type max_k_positive\n./gen -n 10 -type max_k_positive\n./gen -n 100000 -type max_k_positive\n\n./gen -n 1 -type max_k_negative\n./gen -n 10 -type max_k_negative\n./gen -n 100000 -type max_k_negative\n\n./gen -n 1 -type large_b\n./gen -n 10 -type large_b\n./gen -n 100000 -type large_b\n\n./gen -n 1 -type min_b\n./gen -n 10 -type min_b\n./gen -n 100000 -type min_b\n\n./gen -n 1 -type random\n./gen -n 10 -type random\n./gen -n 1000 -type random\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:46:58.346333",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "195/E",
      "title": "E. Building Forest",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 105) — the number of operations of adding a vertex.Next n lines contain descriptions of the operations, the i-th line contains the description of the operation of adding the i-th vertex in the following format: the first number of a line is an integer k (0 ≤ k ≤ i - 1), then follow 2k space-separated integers: v1, x1, v2, x2, ... , vk, xk (1 ≤ vj ≤ i - 1, |xj| ≤ 109). The operations are given in the order, in which they should be applied to the graph. It is guaranteed that sum k of all operations does not exceed 105, also that applying operations of adding vertexes does not result in loops and multiple edges.",
      "output_spec": "OutputPrint a single number — the sum of weights of all edges of the resulting graph modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy6001 2 12 1 5 2 21 1 21 3 4OutputCopy30InputCopy501 1 5002 3 1 4 3OutputCopy9",
      "description": "E. Building Forest\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 105) — the number of operations of adding a vertex.Next n lines contain descriptions of the operations, the i-th line contains the description of the operation of adding the i-th vertex in the following format: the first number of a line is an integer k (0 ≤ k ≤ i - 1), then follow 2k space-separated integers: v1, x1, v2, x2, ... , vk, xk (1 ≤ vj ≤ i - 1, |xj| ≤ 109). The operations are given in the order, in which they should be applied to the graph. It is guaranteed that sum k of all operations does not exceed 105, also that applying operations of adding vertexes does not result in loops and multiple edges.\n\nOutputPrint a single number — the sum of weights of all edges of the resulting graph modulo 1000000007 (109 + 7).\n\nInputCopy6001 2 12 1 5 2 21 1 21 3 4OutputCopy30InputCopy501 1 5002 3 1 4 3OutputCopy9\n\nInputCopy6001 2 12 1 5 2 21 1 21 3 4\n\nOutputCopy30\n\nInputCopy501 1 5002 3 1 4 3\n\nOutputCopy9\n\nNoteConside the first sample: Vertex 1 is added. k = 0, thus no edges are added. Vertex 2 is added. k = 0, thus no edges are added. Vertex 3 is added. k = 1. v1 = 2, x1 = 1. Edge from vertex root(2) = 2 to vertex 3 with weight depth(2) + x1 = 0 + 1 = 1 is added.  Vertex 4 is added. k = 2. v1 = 1, x1 = 5. Edge from vertex root(1) = 1 to vertex 4 with weight depth(1) + x1 = 0 + 5 = 5 is added. v2 = 2, x2 = 2. Edge from vertex root(2) = 3 to vertex 4 with weight depth(2) + x1 = 1 + 2 = 3 is added. Vertex 5 is added. k = 1. v1 = 1, x1 = 2. Edge from vertex root(1) = 4 to vertex 5 with weight depth(1) + x1 = 5 + 2 = 7 is added. Vertex 6 is added. k = 1. v1 = 3, x1 = 4. Edge from vertex root(3) = 5 to vertex 6 with weight depth(3) + x1 = 10 + 4 = 14 is added.The resulting graph is shown on the pictore below:",
      "solutions": [
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces",
          "content": "Welcome, friends)We are glad to introduce you regular Codeforces round #123 for Div.2 participants. Everyone can traditionally participate in it.Problems are prepared by command of authors: Ivan Fefer (Fefer_Ivan), Igor Kudryashov (Igor_Kudryashov), Pavel Kholkin (HolkinPV) and Gerald Agapov (Gerald). Also thanks to Pavel Kunyavskiy (PavelKunyavskiy) and Alexander Kouprin (Alex_KPR) for their help. And traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for Codeforces system and Mary Belova (Delinur) for translating problems.Score distribution is standard: 500, 1000, 1500, 2000, 2500.We wish you success and high rating!Congratulations to winners: bmerry adrian.jaskolka cheshire_cat alexej psw UPD: the tutorial is here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 735
        },
        {
          "title": "403 Forbidden",
          "content": "403 Forbidden\nnginx/1.27.4",
          "author": "Unknown",
          "url": "http://www.codeforces.com/blog/entry/4696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 26
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Tutorial - Codeforces",
          "content": "195A - Let's Watch FootballThe whole video will be downloaded in all = (c·a + b - 1) / b seconds. In this problem you can choose every 1 <  = t <  = all as an answer. To fulfill coditions of the problem it is enough to check the condition t0·b >  = (t0 - t)·a at the moment of time t0 = all.195B - After TrainingIn this problem you should carefully implement the given process. Firstly note that ball number i > m will be in the same basket as ball number i - m. Therefore it is enough to distribute first m balls. It can be done using two pointers lf, rg from the middle. Alternately put one ball to the left and to the right and shift pointers. In only case you should shift left pointer twice in the first moment of time if m is odd.195C - Try and CatchIn this problem you was to implement what was writen in the statement. In my solution I did the following. Erase all spaces from the text except spaces in messages in try-catch blocks. Then when we get word \"try\" we put number of the new try-catch block in stack. When we get word \"throw\" we remember it's type and current state of stack (that is what try-catch blocks are opened). For example, put these number in set. When we get word \"catch\" if it's type equals to type of operator \"throw\" and the number of current try-catch block is in your set then write the answer now else erase this try-catch block from stack. If there was no suitable try-catch block write \"Unhandled Exception\".195D - Analyzing PolylineTutorial by author Igor_KudryashovIn fact in this problem we were given lines yi = ki * x + bi but negative values were replaced by zero. Your task was to find the number of angles that do not equal 180 degrees in the graph s(x), that is the sum of the given functions.Firstly note that sum of two lines is also line. Indeed y = y1 + y2 is y = k1 * x + b1 + k2 * x + b2 = (k1 + k2) * x + (b1 + b2).Consider points where yi = 0, that is xi =  - bi / ki. While we assume that ki doesn't equal to 0. Then line number i is divided in two lines one of which identically equals to 0. Consider all different points xi and sort them. Then, obviously, the sum of the given functions between two consecutive points is line. Find the equation of the line. Assume that we consider point i from the left. Then equation of the line between points i and i + 1 will not be equal to equation of the line between points i and i - 1. That is in point i is formed an angle that doesn't equal 180 degrees.So we should find equations of lines between every pair of points i and i + 1. It can be easily done using two arrays with queries of increasing value on the interval offline.195E - Building ForestTutorial by author Fefer_IvanThe longest operation in this problem is to find the root of some vertex and the sum of the path to this root. To find these values fast we will use compression ways heuristics which is used in data structure \"disjoint-set-union\".For every vertex v we keep two values : c[v] and sum[v]. c[v] = v, if v — root, else c[v] — next vertex on path from v to root. sum[v] = sum of lengths of edges on path from v to c[v].To add new edge from u to v of length w it is enough to do c[u] = v and sum[u] = w.Note that we only add new edges (we don't erase edges).That is, if we find root(v) and depth(v) for some vertex v we can assign c[v] = root(v), Unable to parse markup [type=CF_TEX] time. The approximate implementation is shown below. int root(int v){ \n if(c[v] == v){ \n return v; \n }else{ \n int u = root(c[v]); \n sum[v] = (sum[c[v]] + sum[v]) % M; \n c[v] = u; \n return u; \n } \n} It can proved that such implementation works using O(log(n)) time for every query. The complexity of the solution is O(n * log(n)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4699",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 195\\s*E"
          },
          "content_length": 3687
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 1",
          "code": "abs((M + 1) - 2 * a.second)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 2",
          "code": "t.cha[len] = '\\0';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 3",
          "code": "t.msg[len] = '\\0';",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 4",
          "code": "cin.getline(s,55,'\\n');",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) - Codeforces - Code 5",
          "code": "down_time = (c*a + b - 1) / b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Tutorial - Codeforces - Code 1",
          "code": "int root(int v){  \n   if(c[v] == v){  \n       return v;  \n   }else{  \n       int u = root(c[v]);  \n       sum[v] = (sum[c[v]] + sum[v]) % M;  \n       c[v] = u;  \n       return u;  \n   }  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4699",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #123 (Div. 2) Tutorial - Codeforces - Code 2",
          "code": "int root(int v){  \n   if(c[v] == v){  \n       return v;  \n   }else{  \n       int u = root(c[v]);  \n       sum[v] = (sum[c[v]] + sum[v]) % M;  \n       c[v] = u;  \n       return u;  \n   }  \n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4699",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_K_SUM = 100000;\nconst int MAX_XJ = 1000000000;\n\nvector<int> parent;\n\nint find_root(int v) {\n    if (parent[v] == 0)\n        return v;\n    else {\n        parent[v] = find_root(parent[v]); // path compression\n        return parent[v];\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n    int sum_k = 0;\n    parent.assign(n + 1, 0); // vertices are numbered from 1 to n\n    for (int i = 1; i <= n; i++) {\n        int k = inf.readInt(0, i - 1, \"k\");\n        sum_k += k;\n        ensuref(sum_k <= MAX_K_SUM, \"Sum of k over all operations must not exceed %d\", MAX_K_SUM);\n        if (k == 0) {\n            inf.readEoln();\n        } else {\n            set<int> local_root_vj; // to ensure no duplicate root_vj in current operation\n            for (int j = 1; j <= k; j++) {\n                inf.readSpace();\n                int vj = inf.readInt(1, i - 1, \"vj\");\n                int root_vj = find_root(vj);\n                ensuref(local_root_vj.count(root_vj) == 0, \"Multiple edges from root(vj)=%d to %d\", root_vj, i);\n                local_root_vj.insert(root_vj);\n                ensuref(parent[root_vj] == 0, \"Vertex %d (root_vj) already has an outgoing edge\", root_vj);\n                ensuref(root_vj != i, \"root(vj) == i, which means a self-loop\");\n                parent[root_vj] = i;\n                inf.readSpace();\n                int xj = inf.readInt(-MAX_XJ, MAX_XJ, \"xj\");\n            }\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_K_SUM = 100000;\nconst int MAX_XJ = 1000000000;\n\nvector<int> parent;\n\nint find_root(int v) {\n    if (parent[v] == 0)\n        return v;\n    else {\n        parent[v] = find_root(parent[v]); // path compression\n        return parent[v];\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n    int sum_k = 0;\n    parent.assign(n + 1, 0); // vertices are numbered from 1 to n\n    for (int i = 1; i <= n; i++) {\n        int k = inf.readInt(0, i - 1, \"k\");\n        sum_k += k;\n        ensuref(sum_k <= MAX_K_SUM, \"Sum of k over all operations must not exceed %d\", MAX_K_SUM);\n        if (k == 0) {\n            inf.readEoln();\n        } else {\n            set<int> local_root_vj; // to ensure no duplicate root_vj in current operation\n            for (int j = 1; j <= k; j++) {\n                inf.readSpace();\n                int vj = inf.readInt(1, i - 1, \"vj\");\n                int root_vj = find_root(vj);\n                ensuref(local_root_vj.count(root_vj) == 0, \"Multiple edges from root(vj)=%d to %d\", root_vj, i);\n                local_root_vj.insert(root_vj);\n                ensuref(parent[root_vj] == 0, \"Vertex %d (root_vj) already has an outgoing edge\", root_vj);\n                ensuref(root_vj != i, \"root(vj) == i, which means a self-loop\");\n                parent[root_vj] = i;\n                inf.readSpace();\n                int xj = inf.readInt(-MAX_XJ, MAX_XJ, \"xj\");\n            }\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_K_SUM = 100000;\nconst int MAX_XJ = 1000000000;\n\nvector<int> parent;\n\nint find_root(int v) {\n    if (parent[v] == 0)\n        return v;\n    else {\n        parent[v] = find_root(parent[v]); // path compression\n        return parent[v];\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n    int sum_k = 0;\n    parent.assign(n + 1, 0); // vertices are numbered from 1 to n\n    for (int i = 1; i <= n; i++) {\n        int k = inf.readInt(0, i - 1, \"k\");\n        sum_k += k;\n        ensuref(sum_k <= MAX_K_SUM, \"Sum of k over all operations must not exceed %d\", MAX_K_SUM);\n        if (k == 0) {\n            inf.readEoln();\n        } else {\n            set<int> local_root_vj; // to ensure no duplicate root_vj in current operation\n            for (int j = 1; j <= k; j++) {\n                inf.readSpace();\n                int vj = inf.readInt(1, i - 1, \"vj\");\n                int root_vj = find_root(vj);\n                ensuref(local_root_vj.count(root_vj) == 0, \"Multiple edges from root(vj)=%d to %d\", root_vj, i);\n                local_root_vj.insert(root_vj);\n                ensuref(parent[root_vj] == 0, \"Vertex %d (root_vj) already has an outgoing edge\", root_vj);\n                ensuref(root_vj != i, \"root(vj) == i, which means a self-loop\");\n                parent[root_vj] = i;\n                inf.readSpace();\n                int xj = inf.readInt(-MAX_XJ, MAX_XJ, \"xj\");\n            }\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Number of nodes\n    int sumk_max = opt<int>(\"sumk\", 0); // Maximum total number of edges (sum of all k)\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> parent(n+1, -1);\n    vector<int> root(n+1);\n    vector<long long> depth(n+1, 0);\n\n    // Initialize roots\n    for (int i = 1; i <= n; ++i) {\n        root[i] = i;\n    }\n\n    int total_k = 0;\n    int max_total_k = 100000; // As per constraints, sum of all k ≤ 1e5\n\n    vector<vector<pair<int, int> > > operations(n+1); // operations[i]: vector of pairs (vj, xj)\n\n    if (type == \"random\") {\n        // Random data generation\n        vector<bool> root_has_edge(n+1, false);\n        set<int> roots_without_edge;\n\n        for (int i = 1; i <= n; ++i) {\n            roots_without_edge.insert(i);\n        }\n\n        int remaining_k = (sumk_max > 0) ? min(sumk_max, max_total_k) : max_total_k;\n\n        for (int i = 1; i <= n; ++i) {\n            int max_k = min({i - 1, remaining_k, (int)roots_without_edge.size()});\n            int k = rnd.next(0, max_k);\n\n            remaining_k -= k;\n            total_k += k;\n\n            if (k > 0) {\n                vector<int> roots_vector(roots_without_edge.begin(), roots_without_edge.end());\n                shuffle(roots_vector.begin(), roots_vector.end());\n\n                for (int j = 0; j < k; ++j) {\n                    int root_vj = roots_vector[j];\n\n                    int vj = root_vj; // Any node with this root\n                    int xj = rnd.next(-1000000000, 1000000000);\n\n                    operations[i].push_back(make_pair(vj, xj));\n\n                    root_has_edge[root_vj] = true;\n                    roots_without_edge.erase(root_vj);\n\n                    root[i] = root_vj;\n                    depth[i] = depth[root_vj] + xj;\n                }\n            }\n        }\n\n    } else if (type == \"chain\") {\n        // Chain structure\n        total_k = n - 1;\n        if (total_k > max_total_k) total_k = max_total_k;\n\n        for (int i = 2; i <= n; ++i) {\n            int k = 1;\n            int vj = i - 1;\n            int xj = rnd.next(-1000000000, 1000000000);\n            operations[i].push_back(make_pair(vj, xj));\n\n            root[i] = root[vj];\n            depth[i] = depth[vj] + xj;\n        }\n\n    } else if (type == \"star\") {\n        // Star structure\n        total_k = n - 1;\n        if (total_k > max_total_k) total_k = max_total_k;\n\n        for (int i = 2; i <= n; ++i) {\n            int k = 1;\n            int vj = 1;\n            int xj = rnd.next(-1000000000, 1000000000);\n            operations[i].push_back(make_pair(vj, xj));\n\n            root[i] = root[vj];\n            depth[i] = depth[vj] + xj;\n        }\n\n    } else if (type == \"deep\") {\n        // Deep chain with maximum weights\n        for (int i = 2; i <= n; ++i) {\n            int k = 1;\n            int vj = i - 1;\n            int xj = 1000000000;\n            operations[i].push_back(make_pair(vj, xj));\n\n            root[i] = root[vj];\n            depth[i] = depth[vj] + xj;\n        }\n\n    } else if (type == \"negative\") {\n        // Negative weights\n        vector<int> available_nodes;\n        for (int i = 1; i < n; ++i) {\n            available_nodes.push_back(i);\n        }\n\n        shuffle(available_nodes.begin(), available_nodes.end());\n\n        for (int i = 2; i <= n; ++i) {\n            int k = 1;\n            int vj = available_nodes.back();\n            available_nodes.pop_back();\n\n            int xj = rnd.next(-1000000000, -1);\n            operations[i].push_back(make_pair(vj, xj));\n\n            root[i] = root[vj];\n            depth[i] = depth[vj] + xj;\n        }\n    }\n\n    // Output the operations\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        int k = operations[i].size();\n        printf(\"%d\", k);\n        for (int j = 0; j < k; ++j) {\n            int vj = operations[i][j].first;\n            int xj = operations[i][j].second;\n            printf(\" %d %d\", vj, xj);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Number of nodes\n    int sumk_max = opt<int>(\"sumk\", 0); // Maximum total number of edges (sum of all k)\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> parent(n+1, -1);\n    vector<int> root(n+1);\n    vector<long long> depth(n+1, 0);\n\n    // Initialize roots\n    for (int i = 1; i <= n; ++i) {\n        root[i] = i;\n    }\n\n    int total_k = 0;\n    int max_total_k = 100000; // As per constraints, sum of all k ≤ 1e5\n\n    vector<vector<pair<int, int> > > operations(n+1); // operations[i]: vector of pairs (vj, xj)\n\n    if (type == \"random\") {\n        // Random data generation\n        vector<bool> root_has_edge(n+1, false);\n        set<int> roots_without_edge;\n\n        for (int i = 1; i <= n; ++i) {\n            roots_without_edge.insert(i);\n        }\n\n        int remaining_k = (sumk_max > 0) ? min(sumk_max, max_total_k) : max_total_k;\n\n        for (int i = 1; i <= n; ++i) {\n            int max_k = min({i - 1, remaining_k, (int)roots_without_edge.size()});\n            int k = rnd.next(0, max_k);\n\n            remaining_k -= k;\n            total_k += k;\n\n            if (k > 0) {\n                vector<int> roots_vector(roots_without_edge.begin(), roots_without_edge.end());\n                shuffle(roots_vector.begin(), roots_vector.end());\n\n                for (int j = 0; j < k; ++j) {\n                    int root_vj = roots_vector[j];\n\n                    int vj = root_vj; // Any node with this root\n                    int xj = rnd.next(-1000000000, 1000000000);\n\n                    operations[i].push_back(make_pair(vj, xj));\n\n                    root_has_edge[root_vj] = true;\n                    roots_without_edge.erase(root_vj);\n\n                    root[i] = root_vj;\n                    depth[i] = depth[root_vj] + xj;\n                }\n            }\n        }\n\n    } else if (type == \"chain\") {\n        // Chain structure\n        total_k = n - 1;\n        if (total_k > max_total_k) total_k = max_total_k;\n\n        for (int i = 2; i <= n; ++i) {\n            int k = 1;\n            int vj = i - 1;\n            int xj = rnd.next(-1000000000, 1000000000);\n            operations[i].push_back(make_pair(vj, xj));\n\n            root[i] = root[vj];\n            depth[i] = depth[vj] + xj;\n        }\n\n    } else if (type == \"star\") {\n        // Star structure\n        total_k = n - 1;\n        if (total_k > max_total_k) total_k = max_total_k;\n\n        for (int i = 2; i <= n; ++i) {\n            int k = 1;\n            int vj = 1;\n            int xj = rnd.next(-1000000000, 1000000000);\n            operations[i].push_back(make_pair(vj, xj));\n\n            root[i] = root[vj];\n            depth[i] = depth[vj] + xj;\n        }\n\n    } else if (type == \"deep\") {\n        // Deep chain with maximum weights\n        for (int i = 2; i <= n; ++i) {\n            int k = 1;\n            int vj = i - 1;\n            int xj = 1000000000;\n            operations[i].push_back(make_pair(vj, xj));\n\n            root[i] = root[vj];\n            depth[i] = depth[vj] + xj;\n        }\n\n    } else if (type == \"negative\") {\n        // Negative weights\n        vector<int> available_nodes;\n        for (int i = 1; i < n; ++i) {\n            available_nodes.push_back(i);\n        }\n\n        shuffle(available_nodes.begin(), available_nodes.end());\n\n        for (int i = 2; i <= n; ++i) {\n            int k = 1;\n            int vj = available_nodes.back();\n            available_nodes.pop_back();\n\n            int xj = rnd.next(-1000000000, -1);\n            operations[i].push_back(make_pair(vj, xj));\n\n            root[i] = root[vj];\n            depth[i] = depth[vj] + xj;\n        }\n    }\n\n    // Output the operations\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        int k = operations[i].size();\n        printf(\"%d\", k);\n        for (int j = 0; j < k; ++j) {\n            int vj = operations[i][j].first;\n            int xj = operations[i][j].second;\n            printf(\" %d %d\", vj, xj);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type chain\n./gen -n 1 -type star\n\n./gen -n 2 -type random\n./gen -n 2 -type chain\n./gen -n 2 -type star\n\n./gen -n 10 -type random\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type deep\n./gen -n 10 -type negative\n\n./gen -n 100 -type random\n./gen -n 100 -type chain\n./gen -n 100 -type star\n\n./gen -n 1000 -type random\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 1000 -type deep\n./gen -n 1000 -type negative\n\n./gen -n 10000 -type random\n./gen -n 10000 -type chain -sumk 9999\n./gen -n 10000 -type star -sumk 5000\n\n./gen -n 50000 -type random -sumk 0\n./gen -n 50000 -type random -sumk 100000\n./gen -n 50000 -type chain -sumk 50000\n./gen -n 50000 -type deep\n\n./gen -n 100000 -type random -sumk 0\n./gen -n 100000 -type random -sumk 1\n./gen -n 100000 -type random -sumk 99999\n./gen -n 100000 -type chain\n./gen -n 100000 -type star\n./gen -n 100000 -type deep\n./gen -n 100000 -type negative\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:00.179952",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "196/A",
      "title": "A. Лексикографически максимальная подпоследовательность",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записана непустая строка s, состоящая только из строчных латинских букв и имеющая длину не более 105.",
      "output_spec": "Выходные данныеВыведите лексикографически максимальную подпоследовательность строки s.",
      "sample_tests": "ПримерыВходные данныеСкопироватьababbaВыходные данныеСкопироватьbbbaВходные данныеСкопироватьabbcbccacbbcbaabaВыходные данныеСкопироватьcccccbba",
      "description": "A. Лексикографически максимальная подпоследовательность\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке записана непустая строка s, состоящая только из строчных латинских букв и имеющая длину не более 105.\n\nВходные данные\n\nВыходные данныеВыведите лексикографически максимальную подпоследовательность строки s.\n\nВыходные данные\n\nВходные данныеСкопироватьababbaВыходные данныеСкопироватьbbbaВходные данныеСкопироватьabbcbccacbbcbaabaВыходные данныеСкопироватьcccccbba\n\nВходные данныеСкопироватьababba\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьbbba\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьabbcbccacbbcbaaba\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьcccccbba\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим примеры и покажем, как именно выглядят искомые подпоследовательности (они выделены прописными буквами полужирным шрифтом).Первый пример: aBaBBAВторой пример: abbCbCCaCbbCBaaBA",
      "solutions": [
        {
          "title": "Codeforces Round #124 - Codeforces",
          "content": "Всем привет!Сегодня, 12 июня, в день, когда Россия отмечает день себя, на Евро-2012 стартуют матчи второго круга, а I_love_natalia празднует свой день рождения, мы представляем вам Codeforces Round #124.К подготовке контеста имеют отношение команда Samara SAU Teddy Bears (craus, dalex, Hohol) и I_love_natalia. Также спасибо Alex_KPR и команде Codeforces (Gerald, Delinur, MikeMirzayanov). Мы думаем, что контест очень легкий, а вам придется за 2 часа доказать или опровергнуть это утверждение :)Система начисления очков — динамическая (подробнее о динамической стоимости). Авторы считают, что задачи упорядочены по неубыванию сложности.Всем полных решений и успешных взломов!UPD. Контест закончился, поздравляем победителей!Div-1 (полные результаты): tourist — единственный, кто решил все задачи! RAVEman aropan Div-2 (полные результаты): bmerry littlefriend gstsclq UPD 2. Доступен разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 898
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces",
          "content": "197A - Игра с тарелкамиЕсли первый игрок своим ходом не может поставить тарелку на стол (стол слишком маленький, и тарелка не помещается, т.е. 2r > min(a, b)), выигрывает второй игрок.Иначе выигрывает первый игрок. Выигрышная стратегия такова: первый игрок ставит свою первую тарелку в центр стола, а затем симметрично отражает ходы соперника относительно центра стола стола. Легко видеть, что если в этом случае второму игроку удастся совершить ход, первому это также удастся. А если не удастся, первый игрок победит, что ему и было нужно.197B - ПределРешение задачи — разбор случаев.Легко понять, что важны лишь степени многочленов и их коэффициенты при старшем члене, остальные числа в инпуте — для отвода глаз. Если степень знаменателя больше, ответ равен \"0/1\". Если степень числителя больше, ответ — бесконечность. Чтобы понять, какая именно, надо посмотреть на знаки при старших коэффициентах. Если знаки одинаковые, то положительная, иначе — отрицательная. Если степени числителя и знаменателя равны, ответ, как известно из курса математики, равен . Чтобы дробь была несократимой, надо a0 и b0 поделить на их gcd. Также надо быть внимательным, если один или оба из этих чисел отрицательные и не вывести \"1/-2\" вместо \"-1/2\". 196A - Лексикографически максимальная подпоследовательностьОчевидно, что сначала нам надо выписать все буквы 'z', если они есть — ответ от этого хуже точно не станет. Теперь множество доступных букв сократилось — мы не можем использовать те буквы, что находятся левее последней буквы 'z'. Поэтому выпишем все буквы 'y', что встречаются правее последней буквы 'z'. Множество доступных букв еще сократится, теперь это будут буквы, находящиеся правее самой правой из букв 'z' и 'y'. Продолжаем так, пока не выпишем все подходящие буквы.196B - Бесконечный лабиринтУтверждение: ответ будет положительным тогда и только тогда, когда в бесконечном лабиринте существуют две различные достижимые из старта клетки, соответствующие одной и той же клетке оригинального маленького лабиринта. Действительно, если бесконечно далеко уйти можно, по пути точно придется посетить такие клетки. А если такие клетки существуют, придем в одну из них, и бесконечно будем идти по траектории, переводящей из первой во вторую.Осталось проверить наличие таких клеток. Запустим поиск в глубину по бесконечному лабиринту из стартовой точки. Пусть он при посещении точки (x, y) сохраняет в visit[x%n][y%m] значение (x, y). Теперь если поиск пытается прийти в клетку (x, y) такую, что в visit[x%n][y%m] уже что-то есть, причем оно не равно (x, y), значит две требуемые клетки найдены — клетка (x, y) и та, что сохранена в visit[x%n][y%m]. Отметим, что этот поиск посетит не более nm + 1 клеток (принцип Дирихле). Асимптотика решения — O(nm).196C - Нарисуйте деревоТ.к. никакие три точки не лежат на одной прямой, решение всегда существует.Сначала подвесим дерево за какую-нибудь вершину и dfs-ом посчитаем размеры всех поддеревьев. Теперь будем рекурсивно строить ответ. Найдем самую левую нижнюю точку и поставим ей в соответствие корень дерева. Ничего плохого от этого не случится, ведь эта точка — крайняя в множестве. Отсортируем все остальные точки по углу относительно этой самой левой нижней точки. Теперь пусть размеры поддеревьев корня равны s1, s2, ..., sk. Запустим алгоритм рекурсивно, передав первому поддереву корня первые s1 точек (в уже отсортированном порядке), второму поддереву — следующие s2 точек после первых s1, ..., последнему поддереву — последние sk точек. Легко видеть, что ребра, принадлежащие разным поддеревьям, в этом случае не будут пересекаться. На каждом этапе рекурсии надо сопоставлять самую крайнюю из выбранных точек с корнем поддерева и сортировать все остальные точки относительно нее. Тогда никакие два поддерева не будут иметь попарно пересекающихся ребер. Асимптотика решения — .196D - Следующая хорошая строкаСразу заметим, что нас интересует только наличие подпалиндромов длины d и d + 1: любой подпалиндром большей длины будет содержать их, а если нет длины d и d + 1, нет и больших. Назовем их, для краткости, плохими.Сначала найдем самую левую позицию pos, в которой символ строки точно нужно увеличить. Если плохих подпалиндромов нет, это будет конец строки (так как нужно найти хорошую строку, строго большую данной), иначе это самая левая позиция среди всех концов плохих палиндромов.Увеличим s[pos]. Продолжим увеличивать, пока s[pos] является концом плохого палиндрома. Если пытаемся увеличить символ 'z', значит надо переходить к увеличению предыдущего символа. Если таким образом дошли до начала строки и увеличивать некуда, решения нет. Заметим, что при этом будет выполнено не более O(n) операций увеличения.Пусть теперь pos — позиция самого левого измененного символа. Мы знаем, что префикс s[0..pos] не содержит плохих палиндромов. Теперь суффикс s[pos + 1..n - 1] можно заполнить жадно, перебираем позицию i по возрастанию, полагаем s[i] = 'a', и увеличиваем s[i], пока он является концом плохого палиндрома. Несложно понять, что на роль любого символа суффикса подойдет один из символов 'a', 'b' или 'c' — так как каждой позиции могут \"помешать\" лишь два символа находящихся левее на d и d - 1 позиций.Таким образом, мы получили алгоритм, который требует быстрого выполнения двух операций: изменение одного символа и запрос, является ли данная подстрока палиндромом. Это можно делать с помощью хешей и дерева Фенвика.Научимся узнавать хеш подстроки в изменяющейся строке. Тогда просто будем поддерживать информацию о самой строке, и о ее развернутой копии. Для определения, является ли данная подстрока палиндромом, просто сравним ее хеш с хешем соответствующей подстроки в развернутой версии.Итак, пусть дерево Фенвика поддерживает величины h[i] = s[i]Pi, где P — простое число, используемое для хеширования. Тогда хеш подстроки s[L..R] равен (h[L] + h[L + 1] + ...h[R])P - L. (Разумеется, можно не домножать на P - L а просто при сравнении хешей домножать один из них на нужную степень) Если требуется изменить s[i] на c, прибавляем Фенвиком в i-ую позицию число (c - s[i])Pi.Существует более быстрое решение, без хешей и структур данных, оно будет опубликовано немного позже.196E - Открытие порталовСперва заметим, что если порталы расположены во всех вершинах графа, то ответ — сумма длин ребер в минимальном остовном дереве, которое можно найти алгоритмом Краскала. Это довольно очевидно.Однако порталы расположены не во всех вершинах. Попробуем это исправить.Сделаем небольшой предпросчет: запустим алгоритм Дейкстры одновременно из всех порталов. Таким образом можно посчитать 2 массива: d[i] — расстояние от вершины i до ближайшего портала, и p[i] — ближайший к вершине i портал.Теперь рассмотрим выполнение алгоритма Краскала на графе, состоящем только из порталов. На первой итерации этот алгоритм выберет ребро с минимальным весом среди всех ребер, соединяющем порталы. Только в исходном графе это могут быть не только ребра, но и пути.Пусть такой кратчайший путь — из портала x в портал y. Заметим, что можно найти путь не длиннее, такой, что p[i] на нем будет меняться ровно один раз. Действительно, p[x] = x, p[y] = y, значит, на кратчайшем пути хотя бы раз меняется значение p[i]. Пусть оно меняется на ребре , причем p[i] = x. Поскольку путь от j до p[j] — кратчайший путь от j до портала, путь не длиннее пути из x в y.Тогда, т.к. p[i] = x, p[j] = y, можно рассчитать длину этого пути: она равна d[i] + w(i, j) + d[j] (w(i, j) — вес ребра (i, j)). Алгоритм Краскала прибавит эту величину к ответу и объединит порталы x и y. При этом объединятся поддеревья ближайших к ним вершин.А теперь видим, что ничего не изменилось, и следующее по весу ребро можно найти точно таким же способом — . Если это ребро снова лежит между вершинами x и y, то DSU не даст посчитать это ребро, иначе это ребро соединяет другую пару порталов и войдет в ответ.Как это считать. Из определения ребер в новом графе нетрудно понять, что их столько же, сколько и в исходном: каждому ребру (i, j) веса w(i, j) в старом графе соответствует ребро (p[i], p[j]) веса d[i] + w(i, j) + d[j] в новом графе. Поэтому построим новый граф и запустим на нем алгоритм Краскала — он посчитает вес минимального остовного дерева в графе, где вершины — порталы.Осталось заметить, что если в стартовой вершине есть портал, то мы нашли ответ, а если нет — то надо сначала дойти до ближайшего портала, чтобы можно было начать считать миностов. Для этого можно просто в конце прибавить к ответу число d[1].",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 196\\s*A"
          },
          "content_length": 8436
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces",
          "content": "197A - Игра с тарелкамиЕсли первый игрок своим ходом не может поставить тарелку на стол (стол слишком маленький, и тарелка не помещается, т.е. 2r > min(a, b)), выигрывает второй игрок.Иначе выигрывает первый игрок. Выигрышная стратегия такова: первый игрок ставит свою первую тарелку в центр стола, а затем симметрично отражает ходы соперника относительно центра стола стола. Легко видеть, что если в этом случае второму игроку удастся совершить ход, первому это также удастся. А если не удастся, первый игрок победит, что ему и было нужно.197B - ПределРешение задачи — разбор случаев.Легко понять, что важны лишь степени многочленов и их коэффициенты при старшем члене, остальные числа в инпуте — для отвода глаз. Если степень знаменателя больше, ответ равен \"0/1\". Если степень числителя больше, ответ — бесконечность. Чтобы понять, какая именно, надо посмотреть на знаки при старших коэффициентах. Если знаки одинаковые, то положительная, иначе — отрицательная. Если степени числителя и знаменателя равны, ответ, как известно из курса математики, равен . Чтобы дробь была несократимой, надо a0 и b0 поделить на их gcd. Также надо быть внимательным, если один или оба из этих чисел отрицательные и не вывести \"1/-2\" вместо \"-1/2\". 196A - Лексикографически максимальная подпоследовательностьОчевидно, что сначала нам надо выписать все буквы 'z', если они есть — ответ от этого хуже точно не станет. Теперь множество доступных букв сократилось — мы не можем использовать те буквы, что находятся левее последней буквы 'z'. Поэтому выпишем все буквы 'y', что встречаются правее последней буквы 'z'. Множество доступных букв еще сократится, теперь это будут буквы, находящиеся правее самой правой из букв 'z' и 'y'. Продолжаем так, пока не выпишем все подходящие буквы.196B - Бесконечный лабиринтУтверждение: ответ будет положительным тогда и только тогда, когда в бесконечном лабиринте существуют две различные достижимые из старта клетки, соответствующие одной и той же клетке оригинального маленького лабиринта. Действительно, если бесконечно далеко уйти можно, по пути точно придется посетить такие клетки. А если такие клетки существуют, придем в одну из них, и бесконечно будем идти по траектории, переводящей из первой во вторую.Осталось проверить наличие таких клеток. Запустим поиск в глубину по бесконечному лабиринту из стартовой точки. Пусть он при посещении точки (x, y) сохраняет в visit[x%n][y%m] значение (x, y). Теперь если поиск пытается прийти в клетку (x, y) такую, что в visit[x%n][y%m] уже что-то есть, причем оно не равно (x, y), значит две требуемые клетки найдены — клетка (x, y) и та, что сохранена в visit[x%n][y%m]. Отметим, что этот поиск посетит не более nm + 1 клеток (принцип Дирихле). Асимптотика решения — O(nm).196C - Нарисуйте деревоТ.к. никакие три точки не лежат на одной прямой, решение всегда существует.Сначала подвесим дерево за какую-нибудь вершину и dfs-ом посчитаем размеры всех поддеревьев. Теперь будем рекурсивно строить ответ. Найдем самую левую нижнюю точку и поставим ей в соответствие корень дерева. Ничего плохого от этого не случится, ведь эта точка — крайняя в множестве. Отсортируем все остальные точки по углу относительно этой самой левой нижней точки. Теперь пусть размеры поддеревьев корня равны s1, s2, ..., sk. Запустим алгоритм рекурсивно, передав первому поддереву корня первые s1 точек (в уже отсортированном порядке), второму поддереву — следующие s2 точек после первых s1, ..., последнему поддереву — последние sk точек. Легко видеть, что ребра, принадлежащие разным поддеревьям, в этом случае не будут пересекаться. На каждом этапе рекурсии надо сопоставлять самую крайнюю из выбранных точек с корнем поддерева и сортировать все остальные точки относительно нее. Тогда никакие два поддерева не будут иметь попарно пересекающихся ребер. Асимптотика решения — .196D - Следующая хорошая строкаСразу заметим, что нас интересует только наличие подпалиндромов длины d и d + 1: любой подпалиндром большей длины будет содержать их, а если нет длины d и d + 1, нет и больших. Назовем их, для краткости, плохими.Сначала найдем самую левую позицию pos, в которой символ строки точно нужно увеличить. Если плохих подпалиндромов нет, это будет конец строки (так как нужно найти хорошую строку, строго большую данной), иначе это самая левая позиция среди всех концов плохих палиндромов.Увеличим s[pos]. Продолжим увеличивать, пока s[pos] является концом плохого палиндрома. Если пытаемся увеличить символ 'z', значит надо переходить к увеличению предыдущего символа. Если таким образом дошли до начала строки и увеличивать некуда, решения нет. Заметим, что при этом будет выполнено не более O(n) операций увеличения.Пусть теперь pos — позиция самого левого измененного символа. Мы знаем, что префикс s[0..pos] не содержит плохих палиндромов. Теперь суффикс s[pos + 1..n - 1] можно заполнить жадно, перебираем позицию i по возрастанию, полагаем s[i] = 'a', и увеличиваем s[i], пока он является концом плохого палиндрома. Несложно понять, что на роль любого символа суффикса подойдет один из символов 'a', 'b' или 'c' — так как каждой позиции могут \"помешать\" лишь два символа находящихся левее на d и d - 1 позиций.Таким образом, мы получили алгоритм, который требует быстрого выполнения двух операций: изменение одного символа и запрос, является ли данная подстрока палиндромом. Это можно делать с помощью хешей и дерева Фенвика.Научимся узнавать хеш подстроки в изменяющейся строке. Тогда просто будем поддерживать информацию о самой строке, и о ее развернутой копии. Для определения, является ли данная подстрока палиндромом, просто сравним ее хеш с хешем соответствующей подстроки в развернутой версии.Итак, пусть дерево Фенвика поддерживает величины h[i] = s[i]Pi, где P — простое число, используемое для хеширования. Тогда хеш подстроки s[L..R] равен (h[L] + h[L + 1] + ...h[R])P - L. (Разумеется, можно не домножать на P - L а просто при сравнении хешей домножать один из них на нужную степень) Если требуется изменить s[i] на c, прибавляем Фенвиком в i-ую позицию число (c - s[i])Pi.Существует более быстрое решение, без хешей и структур данных, оно будет опубликовано немного позже.196E - Открытие порталовСперва заметим, что если порталы расположены во всех вершинах графа, то ответ — сумма длин ребер в минимальном остовном дереве, которое можно найти алгоритмом Краскала. Это довольно очевидно.Однако порталы расположены не во всех вершинах. Попробуем это исправить.Сделаем небольшой предпросчет: запустим алгоритм Дейкстры одновременно из всех порталов. Таким образом можно посчитать 2 массива: d[i] — расстояние от вершины i до ближайшего портала, и p[i] — ближайший к вершине i портал.Теперь рассмотрим выполнение алгоритма Краскала на графе, состоящем только из порталов. На первой итерации этот алгоритм выберет ребро с минимальным весом среди всех ребер, соединяющем порталы. Только в исходном графе это могут быть не только ребра, но и пути.Пусть такой кратчайший путь — из портала x в портал y. Заметим, что можно найти путь не длиннее, такой, что p[i] на нем будет меняться ровно один раз. Действительно, p[x] = x, p[y] = y, значит, на кратчайшем пути хотя бы раз меняется значение p[i]. Пусть оно меняется на ребре , причем p[i] = x. Поскольку путь от j до p[j] — кратчайший путь от j до портала, путь не длиннее пути из x в y.Тогда, т.к. p[i] = x, p[j] = y, можно рассчитать длину этого пути: она равна d[i] + w(i, j) + d[j] (w(i, j) — вес ребра (i, j)). Алгоритм Краскала прибавит эту величину к ответу и объединит порталы x и y. При этом объединятся поддеревья ближайших к ним вершин.А теперь видим, что ничего не изменилось, и следующее по весу ребро можно найти точно таким же способом — . Если это ребро снова лежит между вершинами x и y, то DSU не даст посчитать это ребро, иначе это ребро соединяет другую пару порталов и войдет в ответ.Как это считать. Из определения ребер в новом графе нетрудно понять, что их столько же, сколько и в исходном: каждому ребру (i, j) веса w(i, j) в старом графе соответствует ребро (p[i], p[j]) веса d[i] + w(i, j) + d[j] в новом графе. Поэтому построим новый граф и запустим на нем алгоритм Краскала — он посчитает вес минимального остовного дерева в графе, где вершины — порталы.Осталось заметить, что если в стартовой вершине есть портал, то мы нашли ответ, а если нет — то надо сначала дойти до ближайшего портала, чтобы можно было начать считать миностов. Для этого можно просто в конце прибавить к ответу число d[1].",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 196\\s*A"
          },
          "content_length": 8436
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #124 - Codeforces - Code 1",
          "code": "#.#\n...\n###\n#S#\n#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 2",
          "code": "#.#\n...\n###\n#S#\n#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 3",
          "code": "7 9\n#.#.#.###\n#.#.#...#\n#.#.###S#\n#.#...#.#\n#.###.#.#\n#...#.#.#\n#.#.#.#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 4",
          "code": "7 9\n#.#.#.###\n#.#.#...#\n#.#.###S#\n#.#...#.#\n#.###.#.#\n#...#.#.#\n#.#.#.#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 5",
          "code": "5 9\n###.#.#.#\n#...#.#.#\n#S###.#.#\n#.#...#.#\n#.#.###.#\n#.#.#...#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 6",
          "code": "5 9\n###.#.#.#\n#...#.#.#\n#S###.#.#\n#.#...#.#\n#.#.###.#\n#.#.#...#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 7",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 8",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 9",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 10",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 11",
          "code": "(atan2(10^9, 10^9—1) == atan2(10^9+1, 10^9)) == true",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 12",
          "code": "(atan2(10^9, 10^9—1) == atan2(10^9+1, 10^9)) == false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 13",
          "code": "4\n\n1 2\n1 3\n3 4\n\n5 5\n0 0\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 14",
          "code": "4\n\n1 2\n1 3\n3 4\n\n5 5\n0 0\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 15",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 16",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 1",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 2",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 3",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 4",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 1",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 2",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 3",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 4",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"^[a-z]+$\", \"s\");\n    ensuref(1 <= s.size() && s.size() <= 100000, \"Length of s must be between %d and %d, but actually is %d\", 1, 100000, int(s.size()));\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"^[a-z]+$\", \"s\");\n    ensuref(1 <= s.size() && s.size() <= 100000, \"Length of s must be between %d and %d, but actually is %d\", 1, 100000, int(s.size()));\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"^[a-z]+$\", \"s\");\n    ensuref(1 <= s.size() && s.size() <= 100000, \"Length of s must be between %d and %d, but actually is %d\", 1, 100000, int(s.size()));\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, 'a');\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            s[i] = 'a' + rnd.next(26);\n    } else if (type == \"random_az\") {\n        for(int i = 0; i < n; ++i)\n            s[i] = rnd.next(2) ? 'a' : 'z';\n    } else if (type == \"ascending\") {\n        for(int i = 0; i < n; ++i)\n            s[i] = 'a' + i % 26;\n    } else if (type == \"descending\") {\n        for(int i = 0; i < n; ++i)\n            s[i] = 'z' - i % 26;\n    } else if (type == \"same_letter\") {\n        char c = 'a' + rnd.next(26);\n        for(int i = 0; i < n; ++i)\n            s[i] = c;\n    } else if (type == \"periodic\") {\n        int period = opt<int>(\"period\", 2);\n        for(int i = 0; i < n; ++i)\n            s[i] = 'a' + i % period;\n    } else if (type == \"max_at_end\") {\n        char max_char = 'z';\n        for(int i = 0; i < n-1; ++i)\n            s[i] = 'a' + rnd.next(25); // 'a' to 'y'\n        s[n-1] = max_char;\n    } else if (type == \"max_at_start\") {\n        char max_char = 'z';\n        s[0] = max_char;\n        for(int i = 1; i < n; ++i)\n            s[i] = 'a' + rnd.next(25); // 'a' to 'y'\n    } else if (type == \"alternating\") {\n        string chars = \"ab\";\n        for(int i = 0; i < n; ++i)\n            s[i] = chars[i % 2];\n    } else {\n        // default to random\n        for(int i = 0; i < n; ++i)\n            s[i] = 'a' + rnd.next(26);\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, 'a');\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            s[i] = 'a' + rnd.next(26);\n    } else if (type == \"random_az\") {\n        for(int i = 0; i < n; ++i)\n            s[i] = rnd.next(2) ? 'a' : 'z';\n    } else if (type == \"ascending\") {\n        for(int i = 0; i < n; ++i)\n            s[i] = 'a' + i % 26;\n    } else if (type == \"descending\") {\n        for(int i = 0; i < n; ++i)\n            s[i] = 'z' - i % 26;\n    } else if (type == \"same_letter\") {\n        char c = 'a' + rnd.next(26);\n        for(int i = 0; i < n; ++i)\n            s[i] = c;\n    } else if (type == \"periodic\") {\n        int period = opt<int>(\"period\", 2);\n        for(int i = 0; i < n; ++i)\n            s[i] = 'a' + i % period;\n    } else if (type == \"max_at_end\") {\n        char max_char = 'z';\n        for(int i = 0; i < n-1; ++i)\n            s[i] = 'a' + rnd.next(25); // 'a' to 'y'\n        s[n-1] = max_char;\n    } else if (type == \"max_at_start\") {\n        char max_char = 'z';\n        s[0] = max_char;\n        for(int i = 1; i < n; ++i)\n            s[i] = 'a' + rnd.next(25); // 'a' to 'y'\n    } else if (type == \"alternating\") {\n        string chars = \"ab\";\n        for(int i = 0; i < n; ++i)\n            s[i] = chars[i % 2];\n    } else {\n        // default to random\n        for(int i = 0; i < n; ++i)\n            s[i] = 'a' + rnd.next(26);\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Strings of length 1\n./gen -n 1 -type random\n./gen -n 1 -type same_letter\n./gen -n 1 -type ascending\n./gen -n 1 -type descending\n./gen -n 1 -type max_at_end\n./gen -n 1 -type max_at_start\n\n# Strings of length 10\n./gen -n 10 -type random\n./gen -n 10 -type same_letter\n./gen -n 10 -type ascending\n./gen -n 10 -type descending\n./gen -n 10 -type periodic -period 2\n./gen -n 10 -type periodic -period 3\n./gen -n 10 -type max_at_end\n./gen -n 10 -type max_at_start\n./gen -n 10 -type alternating\n./gen -n 10 -type random_az\n\n# Strings of length 100\n./gen -n 100 -type random\n./gen -n 100 -type same_letter\n./gen -n 100 -type periodic -period 5\n./gen -n 100 -type max_at_end\n./gen -n 100 -type max_at_start\n./gen -n 100 -type random_az\n\n# Strings of length 1000\n./gen -n 1000 -type random\n./gen -n 1000 -type same_letter\n./gen -n 1000 -type ascending\n./gen -n 1000 -type descending\n./gen -n 1000 -type max_at_end\n./gen -n 1000 -type max_at_start\n./gen -n 1000 -type random_az\n\n# Strings of length 50000\n./gen -n 50000 -type random\n./gen -n 50000 -type same_letter\n./gen -n 50000 -type ascending\n./gen -n 50000 -type descending\n./gen -n 50000 -type max_at_end\n./gen -n 50000 -type max_at_start\n./gen -n 50000 -type random_az\n\n# Strings of length 99999\n./gen -n 99999 -type random\n./gen -n 99999 -type same_letter\n./gen -n 99999 -type ascending\n./gen -n 99999 -type descending\n./gen -n 99999 -type max_at_end\n./gen -n 99999 -type max_at_start\n./gen -n 99999 -type random_az\n\n# Strings of length 100000\n./gen -n 100000 -type random\n./gen -n 100000 -type same_letter\n./gen -n 100000 -type ascending\n./gen -n 100000 -type descending\n./gen -n 100000 -type periodic -period 1\n./gen -n 100000 -type periodic -period 2\n./gen -n 100000 -type alternating\n./gen -n 100000 -type max_at_end\n./gen -n 100000 -type max_at_start\n./gen -n 100000 -type random_az\n\n# Edge cases\n./gen -n 1 -type same_letter\n./gen -n 99999 -type same_letter\n./gen -n 100000 -type same_letter\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:02.157033",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "196/B",
      "title": "B. Infinite Maze",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 1500) — the height and the width of the maze that the boy used to cyclically tile the plane.Each of the next n lines contains m characters — the description of the labyrinth. Each character is either a \"#\", that marks a wall, a \".\", that marks a passable cell, or an \"S\", that marks the little boy's starting point. The starting point is a passable cell. It is guaranteed that character \"S\" occurs exactly once in the input.",
      "output_spec": "OutputPrint \"Yes\" (without the quotes), if the little boy can walk infinitely far from the starting point. Otherwise, print \"No\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy5 4##.###S##..##.###..#OutputCopyYesInputCopy5 4##.###S##..#..#.#.##OutputCopyNo",
      "description": "B. Infinite Maze\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 1500) — the height and the width of the maze that the boy used to cyclically tile the plane.Each of the next n lines contains m characters — the description of the labyrinth. Each character is either a \"#\", that marks a wall, a \".\", that marks a passable cell, or an \"S\", that marks the little boy's starting point. The starting point is a passable cell. It is guaranteed that character \"S\" occurs exactly once in the input.\n\nOutputPrint \"Yes\" (without the quotes), if the little boy can walk infinitely far from the starting point. Otherwise, print \"No\" (without the quotes).\n\nInputCopy5 4##.###S##..##.###..#OutputCopyYesInputCopy5 4##.###S##..#..#.#.##OutputCopyNo\n\nInputCopy5 4##.###S##..##.###..#\n\nOutputCopyYes\n\nInputCopy5 4##.###S##..#..#.#.##\n\nOutputCopyNo\n\nNoteIn the first sample the little boy can go up for infinitely long as there is a \"clear path\" that goes vertically. He just needs to repeat the following steps infinitely: up, up, left, up, up, right, up.In the second sample the vertical path is blocked. The path to the left doesn't work, too — the next \"copy\" of the maze traps the boy.",
      "solutions": [
        {
          "title": "Codeforces Round #124 - Codeforces",
          "content": "Hi all!Today, June 12, when Russia celebrates Day of itself, Euro 2012 second round starts and I_love_natalia has a birthday, we present you Codeforces Round #124.Contest was prepared by team Samara SAU Teddy Bears (craus, dalex, Hohol) and I_love_natalia. Also thanks to Alex_KPR and Codeforces team (Gerald, Delinur, MikeMirzayanov). We think that contest is very easy, and your task will be prove of refute this assertion :)Scoring system is dynamic (Learn more about dynamic problem scoring). Authors think that problems are sorted by difficulty in non-descending order.Accepted solutions and successful hacks to you!UPD. Contest is over, congratulations to the winners!Div-1 (full results): tourist — the only one who solved all problems! RAVEman aropan Div-2 (full results): bmerry littlefriend gstsclq UPD 2. Tutorial is available.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 838
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces",
          "content": "197A - Plate GameIf first player can't make first move (table is too small and plate doesn't fit it, i.e. 2r > min(a, b)), second player wins. Else first player wins. Winning strategy for first player: place first plate to the center of table. After that he symmetrically reflects moves of second player with respect to center of table. If second player has move, first player has symmetrical move, too. If not, first player won.197B - LimitFrom math lessons we know, that only higher degrees of polinomials matter in this problem. If denominator degree is larger than numenator degree, answer is \"0/1\". If numenator degree is larger, answer is infinity. But what is sign of this infinity? To get it consider signs of highest degree factors of polinomials. If they are same, answer is positive infinity, else — negative infinity. If degrees of numenator and denominator are equal, answer is . To get irreducible fraction, you should divide this numbers by gcd(a0, b0). And don't forget that denominator of answer must be positive. 196A - Lexicographically Maximum SubsequenceSolution is greedy. First, write all 'z' letters (if there is any) — answer must contain them all for sure. Now it's time for 'y' letters. We can use only those of them which are on the right of last used 'z' letter. Then write 'x' letters — they must be on the right of the last used 'y' and 'z' letters. And so on.196B - Infinite MazeAnswer is \"Yes\" iff there are two distinct, reachable from start position cells, which correspond to same cell in initial labyrinth. Proof: If these cells exist, move to first of them, and infinitely repeat moves leading from first to second. On the contrary, if infinite far path exist, on this path we obviously can find such cells.How to find out if they exist? Start DFS from initial cell. For each cell visited, let visit[x%n][y%m] = (x, y). Now, if DFS tries to go to cell (x, y), visit[x%n][y%m] contains something, and (x, y) ≠ visit[x%n][y%m], we found these cells: they are (x, y) and visit[x%n][y%m]. Notice that DFS will visit no more than nm + 1 cells (Dirichlet's principle). So the asymptotic is O(nm).196C - Paint TreeNo three points are in the same line, so the solution always exists.First, choose any one vertex as the root of tree. Find size of each subtree using dfs.Then, we can build the answer recursively.Put the root of tree to the most lower left point.Sort all other points by angle relative to this lower left point.Let us name the sizes of subtrees of the root as s1, s2, ..., sk.Run the algorithm recursively, giving first s1 points (in sorted order) for the first subtree of root, next s2 points for the second subtree and so on.Obviously, no two edges from different subtrees can intersect now.At each step of recursion we are to put the root of current subtree to the first point in sorted-by-angle order, and then sort other points by angle relative to it.So, no two subtrees will have any intersecting edges.The asymptotic of solution is .196D - The Next Good StringNotice, that only palindromes with length d and d + 1 matter. Any palindrome with greater length contains one of them. Let's call these palindromes bad.First, find leftmost position pos, in which we surely should increase value of symbol. If there are no bad subpalindromes, pos = |s| - 1, else pos is leftmost position amongst all ends of bad palindromes.Increase s[pos]. Increase it more, while s[pos] is end of bad subpalindrome. If you try increase 'z' symbol, you should proceed to increasing previous symbol. If this way you reached situation when you need to increase first symbol, and it is 'z', answer is \"Impossible\".Now, let pos be position of leftmost changed symbol. We know, that prefix s[0..pos] doesn't contain bad palindromes. Now we can greedily fill suffix s[pos + 1..length(s) - 1]: go over positions i in ascending order, assign s[i] = 'a', and increase it, while s[i] is end of bad palindrome. Obviously, any of suffix symbols will be 'a', 'b' or 'c'.So we got algorithm, which requires fast implementation of next operations — assigning single symbol, and query: is given substring palindrome? You can perform this operations using hashes and Fenwick tree.Let's learn, how to get hash of substring in dynamically changing string. If we can it, we will keep string s and it's reversed copy. For query of second type we just need to compare hashes of substring in s and hash of corresponding substring in reversed copy.Let Fenwick tree store values h[i] = s[i]Pi, where P is the prime number used for hashing. Then hash of substring s[L..R] equals to (h[L] + h[L + 1] + ...h[R])P - L. For assigning s[i] = c, add value (c - s[i])Pi to h[i]. Both these operations Fenwick tree does in .Also we have faster solution without hashes and data structures, it will be published soon.196E - Opening PortalsFirst of all, we can note that if each graph vertex is portal, the answer will be a sum of all edges' weights in MST (minimal spanning tree). We can find MST by using Kruskal's algo.In this problem, not an every vertex is portal. Let's fix this.Start with a precalculation. Run Dijkstra's algo from all the portals, simultaneously. We will get d[i] — a distance between vertex i and p[i] — the nearest portal to vertex i.Let's trace Kruskal's algo on a graph of portals. On the first iteration, it will choose the edge with the minimal cost, i.e. a shortest path between all the portals in the original graph.Let the path leads from portal x to portal y. Note that there exists a path with the same length such as p[i] changes only once through it. Indeed, p[x] = x, p[y] = y, i.e. p[i] changed on the path. If it happens on edge , p[i] = x, a path will not be longer than the path from x to y.As p[i] = x and p[i] = y, we can see that the length of this path will be d[i] + w(i, j) + d[j], where w(i, j) is the weight of edge (i, j). Kruskal's algo will add this value to the answer and merge portals x and y. The shortest-path trees of vertexes x and y will also be merged.Note, that almost nothing changed. The next edge for Kruskal's algo can be find in a similar way — . If this edge connects x and y again, DSU makes us not to count this edge, otherwise this edge connects a different pair of edges and will be counted in an answer.We can easily implement this. Just create a new graph of portals, with an edge (p[i], p[j]) of weight d[i] + w(i, j) + d[j] for every edge (i, j) of weight w(i, j) from original graph and run Kruskal's algo.Finally, note that if the starting vertex is not a portal, we shall add d[1] to the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 196\\s*B"
          },
          "content_length": 6568
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces",
          "content": "197A - Plate GameIf first player can't make first move (table is too small and plate doesn't fit it, i.e. 2r > min(a, b)), second player wins. Else first player wins. Winning strategy for first player: place first plate to the center of table. After that he symmetrically reflects moves of second player with respect to center of table. If second player has move, first player has symmetrical move, too. If not, first player won.197B - LimitFrom math lessons we know, that only higher degrees of polinomials matter in this problem. If denominator degree is larger than numenator degree, answer is \"0/1\". If numenator degree is larger, answer is infinity. But what is sign of this infinity? To get it consider signs of highest degree factors of polinomials. If they are same, answer is positive infinity, else — negative infinity. If degrees of numenator and denominator are equal, answer is . To get irreducible fraction, you should divide this numbers by gcd(a0, b0). And don't forget that denominator of answer must be positive. 196A - Lexicographically Maximum SubsequenceSolution is greedy. First, write all 'z' letters (if there is any) — answer must contain them all for sure. Now it's time for 'y' letters. We can use only those of them which are on the right of last used 'z' letter. Then write 'x' letters — they must be on the right of the last used 'y' and 'z' letters. And so on.196B - Infinite MazeAnswer is \"Yes\" iff there are two distinct, reachable from start position cells, which correspond to same cell in initial labyrinth. Proof: If these cells exist, move to first of them, and infinitely repeat moves leading from first to second. On the contrary, if infinite far path exist, on this path we obviously can find such cells.How to find out if they exist? Start DFS from initial cell. For each cell visited, let visit[x%n][y%m] = (x, y). Now, if DFS tries to go to cell (x, y), visit[x%n][y%m] contains something, and (x, y) ≠ visit[x%n][y%m], we found these cells: they are (x, y) and visit[x%n][y%m]. Notice that DFS will visit no more than nm + 1 cells (Dirichlet's principle). So the asymptotic is O(nm).196C - Paint TreeNo three points are in the same line, so the solution always exists.First, choose any one vertex as the root of tree. Find size of each subtree using dfs.Then, we can build the answer recursively.Put the root of tree to the most lower left point.Sort all other points by angle relative to this lower left point.Let us name the sizes of subtrees of the root as s1, s2, ..., sk.Run the algorithm recursively, giving first s1 points (in sorted order) for the first subtree of root, next s2 points for the second subtree and so on.Obviously, no two edges from different subtrees can intersect now.At each step of recursion we are to put the root of current subtree to the first point in sorted-by-angle order, and then sort other points by angle relative to it.So, no two subtrees will have any intersecting edges.The asymptotic of solution is .196D - The Next Good StringNotice, that only palindromes with length d and d + 1 matter. Any palindrome with greater length contains one of them. Let's call these palindromes bad.First, find leftmost position pos, in which we surely should increase value of symbol. If there are no bad subpalindromes, pos = |s| - 1, else pos is leftmost position amongst all ends of bad palindromes.Increase s[pos]. Increase it more, while s[pos] is end of bad subpalindrome. If you try increase 'z' symbol, you should proceed to increasing previous symbol. If this way you reached situation when you need to increase first symbol, and it is 'z', answer is \"Impossible\".Now, let pos be position of leftmost changed symbol. We know, that prefix s[0..pos] doesn't contain bad palindromes. Now we can greedily fill suffix s[pos + 1..length(s) - 1]: go over positions i in ascending order, assign s[i] = 'a', and increase it, while s[i] is end of bad palindrome. Obviously, any of suffix symbols will be 'a', 'b' or 'c'.So we got algorithm, which requires fast implementation of next operations — assigning single symbol, and query: is given substring palindrome? You can perform this operations using hashes and Fenwick tree.Let's learn, how to get hash of substring in dynamically changing string. If we can it, we will keep string s and it's reversed copy. For query of second type we just need to compare hashes of substring in s and hash of corresponding substring in reversed copy.Let Fenwick tree store values h[i] = s[i]Pi, where P is the prime number used for hashing. Then hash of substring s[L..R] equals to (h[L] + h[L + 1] + ...h[R])P - L. For assigning s[i] = c, add value (c - s[i])Pi to h[i]. Both these operations Fenwick tree does in .Also we have faster solution without hashes and data structures, it will be published soon.196E - Opening PortalsFirst of all, we can note that if each graph vertex is portal, the answer will be a sum of all edges' weights in MST (minimal spanning tree). We can find MST by using Kruskal's algo.In this problem, not an every vertex is portal. Let's fix this.Start with a precalculation. Run Dijkstra's algo from all the portals, simultaneously. We will get d[i] — a distance between vertex i and p[i] — the nearest portal to vertex i.Let's trace Kruskal's algo on a graph of portals. On the first iteration, it will choose the edge with the minimal cost, i.e. a shortest path between all the portals in the original graph.Let the path leads from portal x to portal y. Note that there exists a path with the same length such as p[i] changes only once through it. Indeed, p[x] = x, p[y] = y, i.e. p[i] changed on the path. If it happens on edge , p[i] = x, a path will not be longer than the path from x to y.As p[i] = x and p[i] = y, we can see that the length of this path will be d[i] + w(i, j) + d[j], where w(i, j) is the weight of edge (i, j). Kruskal's algo will add this value to the answer and merge portals x and y. The shortest-path trees of vertexes x and y will also be merged.Note, that almost nothing changed. The next edge for Kruskal's algo can be find in a similar way — . If this edge connects x and y again, DSU makes us not to count this edge, otherwise this edge connects a different pair of edges and will be counted in an answer.We can easily implement this. Just create a new graph of portals, with an edge (p[i], p[j]) of weight d[i] + w(i, j) + d[j] for every edge (i, j) of weight w(i, j) from original graph and run Kruskal's algo.Finally, note that if the starting vertex is not a portal, we shall add d[1] to the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 196\\s*B"
          },
          "content_length": 6568
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #124 - Codeforces - Code 1",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 2",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 3",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 4",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 5",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 6",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 1",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 2",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 1",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 2",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1500, \"m\");\n    inf.readEoln();\n\n    int countS = 0;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == m, \"Line %d should contain exactly %d characters\", i + 1, m);\n        for (int j = 0; j < m; j++) {\n            char c = s[j];\n            ensuref(c == '#' || c == '.' || c == 'S', \"Invalid character '%c' at line %d, position %d\", c, i + 1, j + 1);\n            if (c == 'S')\n                countS++;\n        }\n    }\n    ensuref(countS == 1, \"There must be exactly one 'S' in the maze, but found %d\", countS);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1500, \"m\");\n    inf.readEoln();\n\n    int countS = 0;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == m, \"Line %d should contain exactly %d characters\", i + 1, m);\n        for (int j = 0; j < m; j++) {\n            char c = s[j];\n            ensuref(c == '#' || c == '.' || c == 'S', \"Invalid character '%c' at line %d, position %d\", c, i + 1, j + 1);\n            if (c == 'S')\n                countS++;\n        }\n    }\n    ensuref(countS == 1, \"There must be exactly one 'S' in the maze, but found %d\", countS);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1500, \"m\");\n    inf.readEoln();\n\n    int countS = 0;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == m, \"Line %d should contain exactly %d characters\", i + 1, m);\n        for (int j = 0; j < m; j++) {\n            char c = s[j];\n            ensuref(c == '#' || c == '.' || c == 'S', \"Invalid character '%c' at line %d, position %d\", c, i + 1, j + 1);\n            if (c == 'S')\n                countS++;\n        }\n    }\n    ensuref(countS == 1, \"There must be exactly one 'S' in the maze, but found %d\", countS);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // number of rows\n    int m = opt<int>(\"m\"); // number of columns\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize maze with empty cells\n    vector<string> maze(n, string(m, '.'));\n\n    int s_row = -1, s_col = -1; // Position of 'S'\n\n    if (type == \"empty\") {\n        // All cells are '.', except 'S'\n\n        // Place 'S' at random position\n        s_row = rnd.next(0, n - 1);\n        s_col = rnd.next(0, m - 1);\n        maze[s_row][s_col] = 'S';\n\n    } else if (type == \"full\") {\n        // All cells are '#', except 'S'\n\n        // Initialize with walls\n        for (int i = 0; i < n; ++i)\n            maze[i] = string(m, '#');\n\n        // Place 'S' at random position\n        s_row = rnd.next(0, n - 1);\n        s_col = rnd.next(0, m - 1);\n        maze[s_row][s_col] = 'S';\n\n    } else if (type == \"random\") {\n        // Each cell is '.' with probability p, '#' otherwise\n        double p = opt<double>(\"p\", 0.5); // Probability of a cell being '.'\n\n        for (int i = 0; i < n; ++i) {\n            maze[i] = string(m, '.');\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(0.0, 1.0) < p)\n                    maze[i][j] = '.';\n                else\n                    maze[i][j] = '#';\n            }\n        }\n        // Place 'S' at random passable cell\n        vector<pair<int, int>> passable_cells;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (maze[i][j] == '.')\n                    passable_cells.push_back({i, j});\n\n        if (passable_cells.empty()) {\n            // Make at least one cell passable\n            s_row = rnd.next(0, n - 1);\n            s_col = rnd.next(0, m - 1);\n            maze[s_row][s_col] = '.';\n        } else {\n            int idx = rnd.next(0, (int)passable_cells.size() - 1);\n            s_row = passable_cells[idx].first;\n            s_col = passable_cells[idx].second;\n        }\n\n        maze[s_row][s_col] = 'S';\n\n    } else if (type == \"cycle\") {\n        // Design a maze with a cycle to allow infinite movement\n\n        // Initialize maze with walls\n        for (int i = 0; i < n; ++i)\n            maze[i] = string(m, '#');\n\n        // Open up a vertical path in the first column\n        for (int i = 0; i < n; ++i)\n            maze[i][0] = '.';\n\n        // Place 'S' somewhere on the path\n        s_row = rnd.next(0, n - 1);\n        s_col = 0;\n        maze[s_row][s_col] = 'S';\n\n    } else if (type == \"no_cycle\") {\n        // Design a maze without cycles\n\n        // Initialize maze with walls\n        for (int i = 0; i < n; ++i)\n            maze[i] = string(m, '#');\n\n        // Create a simple path from 'S' to somewhere\n        s_row = 0;\n        s_col = 0;\n        maze[s_row][s_col] = 'S';\n\n        // Open up a path\n        for (int i = 0; i < n && i < m; ++i)\n            maze[i][i] = '.';\n\n        // 'S' is already at (0,0) which is passable\n\n    } else if (type == \"special\") {\n        // Create a special maze\n\n        // Initialize maze with walls\n        for (int i = 0; i < n; ++i)\n            maze[i] = string(m, '#');\n\n        // Create a vertical path in the first column\n        for (int i = 0; i < n; ++i)\n            maze[i][0] = '.';\n\n        // Create a horizontal path in the bottom row\n        for (int j = 0; j < m; ++j)\n            maze[n - 1][j] = '.';\n\n        // Place 'S' at (0,0)\n        s_row = 0;\n        s_col = 0;\n        maze[s_row][s_col] = 'S';\n\n    } else {\n        // Default to random maze\n        double p = opt<double>(\"p\", 0.5);\n\n        for (int i = 0; i < n; ++i) {\n            maze[i] = string(m, '.');\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(0.0, 1.0) < p)\n                    maze[i][j] = '.';\n                else\n                    maze[i][j] = '#';\n            }\n        }\n        // Place 'S' at random passable cell\n        vector<pair<int, int>> passable_cells;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (maze[i][j] == '.')\n                    passable_cells.push_back({i, j});\n\n        if (passable_cells.empty()) {\n            // Make at least one cell passable\n            s_row = rnd.next(0, n - 1);\n            s_col = rnd.next(0, m - 1);\n            maze[s_row][s_col] = '.';\n        } else {\n            int idx = rnd.next(0, (int)passable_cells.size() - 1);\n            s_row = passable_cells[idx].first;\n            s_col = passable_cells[idx].second;\n        }\n\n        maze[s_row][s_col] = 'S';\n    }\n\n    // Now, print n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Print the maze\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", maze[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // number of rows\n    int m = opt<int>(\"m\"); // number of columns\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize maze with empty cells\n    vector<string> maze(n, string(m, '.'));\n\n    int s_row = -1, s_col = -1; // Position of 'S'\n\n    if (type == \"empty\") {\n        // All cells are '.', except 'S'\n\n        // Place 'S' at random position\n        s_row = rnd.next(0, n - 1);\n        s_col = rnd.next(0, m - 1);\n        maze[s_row][s_col] = 'S';\n\n    } else if (type == \"full\") {\n        // All cells are '#', except 'S'\n\n        // Initialize with walls\n        for (int i = 0; i < n; ++i)\n            maze[i] = string(m, '#');\n\n        // Place 'S' at random position\n        s_row = rnd.next(0, n - 1);\n        s_col = rnd.next(0, m - 1);\n        maze[s_row][s_col] = 'S';\n\n    } else if (type == \"random\") {\n        // Each cell is '.' with probability p, '#' otherwise\n        double p = opt<double>(\"p\", 0.5); // Probability of a cell being '.'\n\n        for (int i = 0; i < n; ++i) {\n            maze[i] = string(m, '.');\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(0.0, 1.0) < p)\n                    maze[i][j] = '.';\n                else\n                    maze[i][j] = '#';\n            }\n        }\n        // Place 'S' at random passable cell\n        vector<pair<int, int>> passable_cells;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (maze[i][j] == '.')\n                    passable_cells.push_back({i, j});\n\n        if (passable_cells.empty()) {\n            // Make at least one cell passable\n            s_row = rnd.next(0, n - 1);\n            s_col = rnd.next(0, m - 1);\n            maze[s_row][s_col] = '.';\n        } else {\n            int idx = rnd.next(0, (int)passable_cells.size() - 1);\n            s_row = passable_cells[idx].first;\n            s_col = passable_cells[idx].second;\n        }\n\n        maze[s_row][s_col] = 'S';\n\n    } else if (type == \"cycle\") {\n        // Design a maze with a cycle to allow infinite movement\n\n        // Initialize maze with walls\n        for (int i = 0; i < n; ++i)\n            maze[i] = string(m, '#');\n\n        // Open up a vertical path in the first column\n        for (int i = 0; i < n; ++i)\n            maze[i][0] = '.';\n\n        // Place 'S' somewhere on the path\n        s_row = rnd.next(0, n - 1);\n        s_col = 0;\n        maze[s_row][s_col] = 'S';\n\n    } else if (type == \"no_cycle\") {\n        // Design a maze without cycles\n\n        // Initialize maze with walls\n        for (int i = 0; i < n; ++i)\n            maze[i] = string(m, '#');\n\n        // Create a simple path from 'S' to somewhere\n        s_row = 0;\n        s_col = 0;\n        maze[s_row][s_col] = 'S';\n\n        // Open up a path\n        for (int i = 0; i < n && i < m; ++i)\n            maze[i][i] = '.';\n\n        // 'S' is already at (0,0) which is passable\n\n    } else if (type == \"special\") {\n        // Create a special maze\n\n        // Initialize maze with walls\n        for (int i = 0; i < n; ++i)\n            maze[i] = string(m, '#');\n\n        // Create a vertical path in the first column\n        for (int i = 0; i < n; ++i)\n            maze[i][0] = '.';\n\n        // Create a horizontal path in the bottom row\n        for (int j = 0; j < m; ++j)\n            maze[n - 1][j] = '.';\n\n        // Place 'S' at (0,0)\n        s_row = 0;\n        s_col = 0;\n        maze[s_row][s_col] = 'S';\n\n    } else {\n        // Default to random maze\n        double p = opt<double>(\"p\", 0.5);\n\n        for (int i = 0; i < n; ++i) {\n            maze[i] = string(m, '.');\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(0.0, 1.0) < p)\n                    maze[i][j] = '.';\n                else\n                    maze[i][j] = '#';\n            }\n        }\n        // Place 'S' at random passable cell\n        vector<pair<int, int>> passable_cells;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (maze[i][j] == '.')\n                    passable_cells.push_back({i, j});\n\n        if (passable_cells.empty()) {\n            // Make at least one cell passable\n            s_row = rnd.next(0, n - 1);\n            s_col = rnd.next(0, m - 1);\n            maze[s_row][s_col] = '.';\n        } else {\n            int idx = rnd.next(0, (int)passable_cells.size() - 1);\n            s_row = passable_cells[idx].first;\n            s_col = passable_cells[idx].second;\n        }\n\n        maze[s_row][s_col] = 'S';\n    }\n\n    // Now, print n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Print the maze\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", maze[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small empty mazes\n./gen -n 1 -m 1 -type empty\n./gen -n 2 -m 2 -type empty\n./gen -n 10 -m 10 -type empty\n\n# Small full mazes\n./gen -n 1 -m 1 -type full\n./gen -n 2 -m 2 -type full\n./gen -n 10 -m 10 -type full\n\n# Random mazes with different probabilities\n./gen -n 5 -m 5 -type random -p 0.1\n./gen -n 5 -m 5 -type random -p 0.5\n./gen -n 5 -m 5 -type random -p 0.9\n\n# Random medium mazes\n./gen -n 100 -m 100 -type random -p 0.4\n./gen -n 100 -m 100 -type random -p 0.6\n\n# Large random mazes\n./gen -n 1500 -m 1500 -type random -p 0.3\n./gen -n 1500 -m 1500 -type random -p 0.7\n\n# Mazes with cycles\n./gen -n 5 -m 5 -type cycle\n./gen -n 100 -m 100 -type cycle\n./gen -n 1500 -m 1500 -type cycle\n\n# Mazes without cycles\n./gen -n 5 -m 5 -type no_cycle\n./gen -n 100 -m 100 -type no_cycle\n./gen -n 1000 -m 1000 -type no_cycle\n\n# Special mazes\n./gen -n 10 -m 10 -type special\n./gen -n 500 -m 500 -type special\n\n# Edge cases with maximum dimensions\n./gen -n 1 -m 1500 -type random -p 0.5\n./gen -n 1500 -m 1 -type random -p 0.5\n\n# Mazes with narrow paths\n./gen -n 1500 -m 2 -type cycle\n./gen -n 2 -m 1500 -type cycle\n\n# Empty large maze\n./gen -n 1500 -m 1500 -type empty\n\n# Full large maze\n./gen -n 1500 -m 1500 -type full\n\n# Random small maze with high wall density\n./gen -n 5 -m 5 -type random -p 0.95\n\n# Random small maze with low wall density\n./gen -n 5 -m 5 -type random -p 0.05\n\n# Testing with sparser mazes\n./gen -n 300 -m 300 -type random -p 0.2\n./gen -n 300 -m 300 -type random -p 0.8\n\n# Testing dense mazes\n./gen -n 1000 -m 1000 -type random -p 0.9\n\n# Edge case where n=1, m=1\n./gen -n 1 -m 1 -type random -p 0.5\n\n# Edge case where starting point is surrounded by walls\n./gen -n 3 -m 3 -type random -p 0.9\n\n# Edge case where starting point is at corner\n./gen -n 10 -m 10 -type random -p 0.5\n\n# Mazes with custom probabilities\n./gen -n 50 -m 50 -type random -p 0.25\n./gen -n 50 -m 50 -type random -p 0.75\n\n# Large maze with narrow passage\n./gen -n 1000 -m 10 -type cycle\n\n# Maze with only horizontal path\n./gen -n 10 -m 1000 -type cycle\n\n# Random maze with default type\n./gen -n 100 -m 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:04.162823",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "196/C",
      "title": "C. Paint Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 1500) — the number of vertexes on a tree (as well as the number of chosen points on the plane).Each of the next n - 1 lines contains two space-separated integers ui and vi (1 ≤ ui, vi ≤ n, ui ≠ vi) — the numbers of tree vertexes connected by the i-th edge.Each of the next n lines contain two space-separated integers xi and yi ( - 109 ≤ xi, yi ≤ 109) — the coordinates of the i-th point on the plane. No three points lie on one straight line.It is guaranteed that under given constraints problem has a solution.",
      "output_spec": "OutputPrint n distinct space-separated integers from 1 to n: the i-th number must equal the number of the vertex to place at the i-th point (the points are numbered in the order, in which they are listed in the input).If there are several solutions, print any of them.",
      "sample_tests": "ExamplesInputCopy31 32 30 01 12 0OutputCopy1 3 2InputCopy41 22 31 4-1 -23 5-3 32 0OutputCopy4 2 1 3",
      "description": "C. Paint Tree\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 1500) — the number of vertexes on a tree (as well as the number of chosen points on the plane).Each of the next n - 1 lines contains two space-separated integers ui and vi (1 ≤ ui, vi ≤ n, ui ≠ vi) — the numbers of tree vertexes connected by the i-th edge.Each of the next n lines contain two space-separated integers xi and yi ( - 109 ≤ xi, yi ≤ 109) — the coordinates of the i-th point on the plane. No three points lie on one straight line.It is guaranteed that under given constraints problem has a solution.\n\nOutputPrint n distinct space-separated integers from 1 to n: the i-th number must equal the number of the vertex to place at the i-th point (the points are numbered in the order, in which they are listed in the input).If there are several solutions, print any of them.\n\nInputCopy31 32 30 01 12 0OutputCopy1 3 2InputCopy41 22 31 4-1 -23 5-3 32 0OutputCopy4 2 1 3\n\nInputCopy31 32 30 01 12 0\n\nOutputCopy1 3 2\n\nInputCopy41 22 31 4-1 -23 5-3 32 0\n\nOutputCopy4 2 1 3\n\nNoteThe possible solutions for the sample are given below.",
      "solutions": [
        {
          "title": "Codeforces Round #124 - Codeforces",
          "content": "Hi all!Today, June 12, when Russia celebrates Day of itself, Euro 2012 second round starts and I_love_natalia has a birthday, we present you Codeforces Round #124.Contest was prepared by team Samara SAU Teddy Bears (craus, dalex, Hohol) and I_love_natalia. Also thanks to Alex_KPR and Codeforces team (Gerald, Delinur, MikeMirzayanov). We think that contest is very easy, and your task will be prove of refute this assertion :)Scoring system is dynamic (Learn more about dynamic problem scoring). Authors think that problems are sorted by difficulty in non-descending order.Accepted solutions and successful hacks to you!UPD. Contest is over, congratulations to the winners!Div-1 (full results): tourist — the only one who solved all problems! RAVEman aropan Div-2 (full results): bmerry littlefriend gstsclq UPD 2. Tutorial is available.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 838
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces",
          "content": "197A - Plate GameIf first player can't make first move (table is too small and plate doesn't fit it, i.e. 2r > min(a, b)), second player wins. Else first player wins. Winning strategy for first player: place first plate to the center of table. After that he symmetrically reflects moves of second player with respect to center of table. If second player has move, first player has symmetrical move, too. If not, first player won.197B - LimitFrom math lessons we know, that only higher degrees of polinomials matter in this problem. If denominator degree is larger than numenator degree, answer is \"0/1\". If numenator degree is larger, answer is infinity. But what is sign of this infinity? To get it consider signs of highest degree factors of polinomials. If they are same, answer is positive infinity, else — negative infinity. If degrees of numenator and denominator are equal, answer is . To get irreducible fraction, you should divide this numbers by gcd(a0, b0). And don't forget that denominator of answer must be positive. 196A - Lexicographically Maximum SubsequenceSolution is greedy. First, write all 'z' letters (if there is any) — answer must contain them all for sure. Now it's time for 'y' letters. We can use only those of them which are on the right of last used 'z' letter. Then write 'x' letters — they must be on the right of the last used 'y' and 'z' letters. And so on.196B - Infinite MazeAnswer is \"Yes\" iff there are two distinct, reachable from start position cells, which correspond to same cell in initial labyrinth. Proof: If these cells exist, move to first of them, and infinitely repeat moves leading from first to second. On the contrary, if infinite far path exist, on this path we obviously can find such cells.How to find out if they exist? Start DFS from initial cell. For each cell visited, let visit[x%n][y%m] = (x, y). Now, if DFS tries to go to cell (x, y), visit[x%n][y%m] contains something, and (x, y) ≠ visit[x%n][y%m], we found these cells: they are (x, y) and visit[x%n][y%m]. Notice that DFS will visit no more than nm + 1 cells (Dirichlet's principle). So the asymptotic is O(nm).196C - Paint TreeNo three points are in the same line, so the solution always exists.First, choose any one vertex as the root of tree. Find size of each subtree using dfs.Then, we can build the answer recursively.Put the root of tree to the most lower left point.Sort all other points by angle relative to this lower left point.Let us name the sizes of subtrees of the root as s1, s2, ..., sk.Run the algorithm recursively, giving first s1 points (in sorted order) for the first subtree of root, next s2 points for the second subtree and so on.Obviously, no two edges from different subtrees can intersect now.At each step of recursion we are to put the root of current subtree to the first point in sorted-by-angle order, and then sort other points by angle relative to it.So, no two subtrees will have any intersecting edges.The asymptotic of solution is .196D - The Next Good StringNotice, that only palindromes with length d and d + 1 matter. Any palindrome with greater length contains one of them. Let's call these palindromes bad.First, find leftmost position pos, in which we surely should increase value of symbol. If there are no bad subpalindromes, pos = |s| - 1, else pos is leftmost position amongst all ends of bad palindromes.Increase s[pos]. Increase it more, while s[pos] is end of bad subpalindrome. If you try increase 'z' symbol, you should proceed to increasing previous symbol. If this way you reached situation when you need to increase first symbol, and it is 'z', answer is \"Impossible\".Now, let pos be position of leftmost changed symbol. We know, that prefix s[0..pos] doesn't contain bad palindromes. Now we can greedily fill suffix s[pos + 1..length(s) - 1]: go over positions i in ascending order, assign s[i] = 'a', and increase it, while s[i] is end of bad palindrome. Obviously, any of suffix symbols will be 'a', 'b' or 'c'.So we got algorithm, which requires fast implementation of next operations — assigning single symbol, and query: is given substring palindrome? You can perform this operations using hashes and Fenwick tree.Let's learn, how to get hash of substring in dynamically changing string. If we can it, we will keep string s and it's reversed copy. For query of second type we just need to compare hashes of substring in s and hash of corresponding substring in reversed copy.Let Fenwick tree store values h[i] = s[i]Pi, where P is the prime number used for hashing. Then hash of substring s[L..R] equals to (h[L] + h[L + 1] + ...h[R])P - L. For assigning s[i] = c, add value (c - s[i])Pi to h[i]. Both these operations Fenwick tree does in .Also we have faster solution without hashes and data structures, it will be published soon.196E - Opening PortalsFirst of all, we can note that if each graph vertex is portal, the answer will be a sum of all edges' weights in MST (minimal spanning tree). We can find MST by using Kruskal's algo.In this problem, not an every vertex is portal. Let's fix this.Start with a precalculation. Run Dijkstra's algo from all the portals, simultaneously. We will get d[i] — a distance between vertex i and p[i] — the nearest portal to vertex i.Let's trace Kruskal's algo on a graph of portals. On the first iteration, it will choose the edge with the minimal cost, i.e. a shortest path between all the portals in the original graph.Let the path leads from portal x to portal y. Note that there exists a path with the same length such as p[i] changes only once through it. Indeed, p[x] = x, p[y] = y, i.e. p[i] changed on the path. If it happens on edge , p[i] = x, a path will not be longer than the path from x to y.As p[i] = x and p[i] = y, we can see that the length of this path will be d[i] + w(i, j) + d[j], where w(i, j) is the weight of edge (i, j). Kruskal's algo will add this value to the answer and merge portals x and y. The shortest-path trees of vertexes x and y will also be merged.Note, that almost nothing changed. The next edge for Kruskal's algo can be find in a similar way — . If this edge connects x and y again, DSU makes us not to count this edge, otherwise this edge connects a different pair of edges and will be counted in an answer.We can easily implement this. Just create a new graph of portals, with an edge (p[i], p[j]) of weight d[i] + w(i, j) + d[j] for every edge (i, j) of weight w(i, j) from original graph and run Kruskal's algo.Finally, note that if the starting vertex is not a portal, we shall add d[1] to the answer.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 196\\s*C"
          },
          "content_length": 6568
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces",
          "content": "197A - Plate GameIf first player can't make first move (table is too small and plate doesn't fit it, i.e. 2r > min(a, b)), second player wins. Else first player wins. Winning strategy for first player: place first plate to the center of table. After that he symmetrically reflects moves of second player with respect to center of table. If second player has move, first player has symmetrical move, too. If not, first player won.197B - LimitFrom math lessons we know, that only higher degrees of polinomials matter in this problem. If denominator degree is larger than numenator degree, answer is \"0/1\". If numenator degree is larger, answer is infinity. But what is sign of this infinity? To get it consider signs of highest degree factors of polinomials. If they are same, answer is positive infinity, else — negative infinity. If degrees of numenator and denominator are equal, answer is . To get irreducible fraction, you should divide this numbers by gcd(a0, b0). And don't forget that denominator of answer must be positive. 196A - Lexicographically Maximum SubsequenceSolution is greedy. First, write all 'z' letters (if there is any) — answer must contain them all for sure. Now it's time for 'y' letters. We can use only those of them which are on the right of last used 'z' letter. Then write 'x' letters — they must be on the right of the last used 'y' and 'z' letters. And so on.196B - Infinite MazeAnswer is \"Yes\" iff there are two distinct, reachable from start position cells, which correspond to same cell in initial labyrinth. Proof: If these cells exist, move to first of them, and infinitely repeat moves leading from first to second. On the contrary, if infinite far path exist, on this path we obviously can find such cells.How to find out if they exist? Start DFS from initial cell. For each cell visited, let visit[x%n][y%m] = (x, y). Now, if DFS tries to go to cell (x, y), visit[x%n][y%m] contains something, and (x, y) ≠ visit[x%n][y%m], we found these cells: they are (x, y) and visit[x%n][y%m]. Notice that DFS will visit no more than nm + 1 cells (Dirichlet's principle). So the asymptotic is O(nm).196C - Paint TreeNo three points are in the same line, so the solution always exists.First, choose any one vertex as the root of tree. Find size of each subtree using dfs.Then, we can build the answer recursively.Put the root of tree to the most lower left point.Sort all other points by angle relative to this lower left point.Let us name the sizes of subtrees of the root as s1, s2, ..., sk.Run the algorithm recursively, giving first s1 points (in sorted order) for the first subtree of root, next s2 points for the second subtree and so on.Obviously, no two edges from different subtrees can intersect now.At each step of recursion we are to put the root of current subtree to the first point in sorted-by-angle order, and then sort other points by angle relative to it.So, no two subtrees will have any intersecting edges.The asymptotic of solution is .196D - The Next Good StringNotice, that only palindromes with length d and d + 1 matter. Any palindrome with greater length contains one of them. Let's call these palindromes bad.First, find leftmost position pos, in which we surely should increase value of symbol. If there are no bad subpalindromes, pos = |s| - 1, else pos is leftmost position amongst all ends of bad palindromes.Increase s[pos]. Increase it more, while s[pos] is end of bad subpalindrome. If you try increase 'z' symbol, you should proceed to increasing previous symbol. If this way you reached situation when you need to increase first symbol, and it is 'z', answer is \"Impossible\".Now, let pos be position of leftmost changed symbol. We know, that prefix s[0..pos] doesn't contain bad palindromes. Now we can greedily fill suffix s[pos + 1..length(s) - 1]: go over positions i in ascending order, assign s[i] = 'a', and increase it, while s[i] is end of bad palindrome. Obviously, any of suffix symbols will be 'a', 'b' or 'c'.So we got algorithm, which requires fast implementation of next operations — assigning single symbol, and query: is given substring palindrome? You can perform this operations using hashes and Fenwick tree.Let's learn, how to get hash of substring in dynamically changing string. If we can it, we will keep string s and it's reversed copy. For query of second type we just need to compare hashes of substring in s and hash of corresponding substring in reversed copy.Let Fenwick tree store values h[i] = s[i]Pi, where P is the prime number used for hashing. Then hash of substring s[L..R] equals to (h[L] + h[L + 1] + ...h[R])P - L. For assigning s[i] = c, add value (c - s[i])Pi to h[i]. Both these operations Fenwick tree does in .Also we have faster solution without hashes and data structures, it will be published soon.196E - Opening PortalsFirst of all, we can note that if each graph vertex is portal, the answer will be a sum of all edges' weights in MST (minimal spanning tree). We can find MST by using Kruskal's algo.In this problem, not an every vertex is portal. Let's fix this.Start with a precalculation. Run Dijkstra's algo from all the portals, simultaneously. We will get d[i] — a distance between vertex i and p[i] — the nearest portal to vertex i.Let's trace Kruskal's algo on a graph of portals. On the first iteration, it will choose the edge with the minimal cost, i.e. a shortest path between all the portals in the original graph.Let the path leads from portal x to portal y. Note that there exists a path with the same length such as p[i] changes only once through it. Indeed, p[x] = x, p[y] = y, i.e. p[i] changed on the path. If it happens on edge , p[i] = x, a path will not be longer than the path from x to y.As p[i] = x and p[i] = y, we can see that the length of this path will be d[i] + w(i, j) + d[j], where w(i, j) is the weight of edge (i, j). Kruskal's algo will add this value to the answer and merge portals x and y. The shortest-path trees of vertexes x and y will also be merged.Note, that almost nothing changed. The next edge for Kruskal's algo can be find in a similar way — . If this edge connects x and y again, DSU makes us not to count this edge, otherwise this edge connects a different pair of edges and will be counted in an answer.We can easily implement this. Just create a new graph of portals, with an edge (p[i], p[j]) of weight d[i] + w(i, j) + d[j] for every edge (i, j) of weight w(i, j) from original graph and run Kruskal's algo.Finally, note that if the starting vertex is not a portal, we shall add d[1] to the answer.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 196\\s*C"
          },
          "content_length": 6568
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #124 - Codeforces - Code 1",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 2",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 3",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 4",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 5",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 6",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 1",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 2",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 1",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 2",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1500, \"n\");\n    inf.readEoln();\n    vector<pair<int,int>> edges;\n    vector<pair<long long, long long>> points(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge cannot be a loop (u_i (%d) != v_i (%d))\", u, v);\n        edges.push_back({u - 1, v - 1});\n    }\n    // Use Union-Find to detect cycles\n    vector<int> parent(n);\n    for (int i = 0; i < n; ++i) parent[i] = i;\n    function<int(int)> find = [&](int u) {\n        if (parent[u] != u) parent[u] = find(parent[u]);\n        return parent[u];\n    };\n    auto unite = [&](int u, int v) {\n        u = find(u);\n        v = find(v);\n        ensuref(u != v, \"Edges form a cycle\");\n        parent[u] = v;\n    };\n    for (const auto& e : edges) {\n        unite(e.first, e.second);\n    }\n    // Read points and check constraints\n    for (int i = 0; i < n; ++i) {\n        long long xi = inf.readLong(-1000000000LL, 1000000000LL, \"x_i\");\n        inf.readSpace();\n        long long yi = inf.readLong(-1000000000LL, 1000000000LL, \"y_i\");\n        inf.readEoln();\n        points[i] = {xi, yi};\n    }\n    // Check that no three points lie on a straight line\n    for (int i = 0; i < n; ++i) {\n        map<pair<long long, long long>, int> slopes;\n        for (int j = 0; j < n; ++j) {\n            if (j == i) continue;\n            long long dx = points[j].first - points[i].first;\n            long long dy = points[j].second - points[i].second;\n            // Ensure that two points are not the same\n            ensuref(dx != 0 || dy != 0, \"Two points are the same at indices %d and %d\", i + 1, j + 1);\n            // Normalize the direction vector\n            if (dx == 0) {\n                dy = 1;\n            } else if (dy == 0) {\n                dx = 1;\n            } else {\n                if (dx < 0) {\n                    dx = -dx;\n                    dy = -dy;\n                }\n                long long g = __gcd(abs(dx), abs(dy));\n                dx /= g;\n                dy /= g;\n            }\n            auto slope = make_pair(dx, dy);\n            if (slopes.count(slope)) {\n                // Found three colinear points\n                ensuref(false, \"Three points are colinear at indices %d, %d, and %d\", i + 1, slopes[slope] + 1, j + 1);\n            }\n            slopes[slope] = j;\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1500, \"n\");\n    inf.readEoln();\n    vector<pair<int,int>> edges;\n    vector<pair<long long, long long>> points(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge cannot be a loop (u_i (%d) != v_i (%d))\", u, v);\n        edges.push_back({u - 1, v - 1});\n    }\n    // Use Union-Find to detect cycles\n    vector<int> parent(n);\n    for (int i = 0; i < n; ++i) parent[i] = i;\n    function<int(int)> find = [&](int u) {\n        if (parent[u] != u) parent[u] = find(parent[u]);\n        return parent[u];\n    };\n    auto unite = [&](int u, int v) {\n        u = find(u);\n        v = find(v);\n        ensuref(u != v, \"Edges form a cycle\");\n        parent[u] = v;\n    };\n    for (const auto& e : edges) {\n        unite(e.first, e.second);\n    }\n    // Read points and check constraints\n    for (int i = 0; i < n; ++i) {\n        long long xi = inf.readLong(-1000000000LL, 1000000000LL, \"x_i\");\n        inf.readSpace();\n        long long yi = inf.readLong(-1000000000LL, 1000000000LL, \"y_i\");\n        inf.readEoln();\n        points[i] = {xi, yi};\n    }\n    // Check that no three points lie on a straight line\n    for (int i = 0; i < n; ++i) {\n        map<pair<long long, long long>, int> slopes;\n        for (int j = 0; j < n; ++j) {\n            if (j == i) continue;\n            long long dx = points[j].first - points[i].first;\n            long long dy = points[j].second - points[i].second;\n            // Ensure that two points are not the same\n            ensuref(dx != 0 || dy != 0, \"Two points are the same at indices %d and %d\", i + 1, j + 1);\n            // Normalize the direction vector\n            if (dx == 0) {\n                dy = 1;\n            } else if (dy == 0) {\n                dx = 1;\n            } else {\n                if (dx < 0) {\n                    dx = -dx;\n                    dy = -dy;\n                }\n                long long g = __gcd(abs(dx), abs(dy));\n                dx /= g;\n                dy /= g;\n            }\n            auto slope = make_pair(dx, dy);\n            if (slopes.count(slope)) {\n                // Found three colinear points\n                ensuref(false, \"Three points are colinear at indices %d, %d, and %d\", i + 1, slopes[slope] + 1, j + 1);\n            }\n            slopes[slope] = j;\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1500, \"n\");\n    inf.readEoln();\n    vector<pair<int,int>> edges;\n    vector<pair<long long, long long>> points(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge cannot be a loop (u_i (%d) != v_i (%d))\", u, v);\n        edges.push_back({u - 1, v - 1});\n    }\n    // Use Union-Find to detect cycles\n    vector<int> parent(n);\n    for (int i = 0; i < n; ++i) parent[i] = i;\n    function<int(int)> find = [&](int u) {\n        if (parent[u] != u) parent[u] = find(parent[u]);\n        return parent[u];\n    };\n    auto unite = [&](int u, int v) {\n        u = find(u);\n        v = find(v);\n        ensuref(u != v, \"Edges form a cycle\");\n        parent[u] = v;\n    };\n    for (const auto& e : edges) {\n        unite(e.first, e.second);\n    }\n    // Read points and check constraints\n    for (int i = 0; i < n; ++i) {\n        long long xi = inf.readLong(-1000000000LL, 1000000000LL, \"x_i\");\n        inf.readSpace();\n        long long yi = inf.readLong(-1000000000LL, 1000000000LL, \"y_i\");\n        inf.readEoln();\n        points[i] = {xi, yi};\n    }\n    // Check that no three points lie on a straight line\n    for (int i = 0; i < n; ++i) {\n        map<pair<long long, long long>, int> slopes;\n        for (int j = 0; j < n; ++j) {\n            if (j == i) continue;\n            long long dx = points[j].first - points[i].first;\n            long long dy = points[j].second - points[i].second;\n            // Ensure that two points are not the same\n            ensuref(dx != 0 || dy != 0, \"Two points are the same at indices %d and %d\", i + 1, j + 1);\n            // Normalize the direction vector\n            if (dx == 0) {\n                dy = 1;\n            } else if (dy == 0) {\n                dx = 1;\n            } else {\n                if (dx < 0) {\n                    dx = -dx;\n                    dy = -dy;\n                }\n                long long g = __gcd(abs(dx), abs(dy));\n                dx /= g;\n                dy /= g;\n            }\n            auto slope = make_pair(dx, dy);\n            if (slopes.count(slope)) {\n                // Found three colinear points\n                ensuref(false, \"Three points are colinear at indices %d, %d, and %d\", i + 1, slopes[slope] + 1, j + 1);\n            }\n            slopes[slope] = j;\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Point {\n    ll x, y;\n};\n\nstruct Edge {\n    int u, v; // vertices\n    int pu, pv; // indices of the points assigned to u and v\n};\n\nint n;\nvector<Edge> edges;\nvector<Point> points;\n\nll orientation(Point p, Point q, Point r) {\n    // Returns the orientation value\n    // >0 if counterclockwise\n    // <0 if clockwise\n    // 0 if colinear (which should not happen)\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\nbool doIntersect(Point p1, Point p2, Point q1, Point q2) {\n    ll o1 = orientation(p1, p2, q1);\n    ll o2 = orientation(p1, p2, q2);\n    ll o3 = orientation(q1, q2, p1);\n    ll o4 = orientation(q1, q2, p2);\n\n    if (o1 * o2 < 0 && o3 * o4 < 0)\n        return true;\n    else\n        return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, 1500, \"n\");\n    vector<pair<int, int>> treeEdges;\n    set<pair<int, int>> edgeSet;\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"u\");\n        int v = inf.readInt(1, n, \"v\");\n        // Ensure u != v\n        if (u == v)\n            quitf(_fail, \"Invalid edge in input: edge between same vertex %d\", u);\n        treeEdges.emplace_back(u, v);\n        edgeSet.emplace(min(u, v), max(u, v));\n    }\n    points.resize(n + 1); // 1-based indexing\n    for (int i = 1; i <= n; i++) {\n        points[i].x = inf.readInt(-1000000000, 1000000000, \"x_i\");\n        points[i].y = inf.readInt(-1000000000, 1000000000, \"y_i\");\n    }\n    // No need to check for colinear points since it's guaranteed\n\n    // Now read contestant's output\n    vector<int> a(n + 1);\n    vector<int> used(n + 1, 0);\n    for (int i = 1; i <= n; i++) {\n        if (ouf.seekEof())\n            quitf(_pe, \"Unexpected end of output\");\n        a[i] = ouf.readInt(1, n, format(\"a[%d]\", i).c_str());\n        if (used[a[i]])\n            quitf(_wa, \"Vertex %d is assigned to multiple points\", a[i]);\n        used[a[i]] = i;\n    }\n    // Now check if it's a permutation\n    for (int i = 1; i <= n; i++) {\n        if (!used[i])\n            quitf(_wa, \"Vertex %d is missing in the assignment\", i);\n    }\n\n    // Build mapping from vertex to assigned point index\n    vector<int> vertexToPoint(n + 1);\n    for (int i = 1; i <= n; i++) {\n        vertexToPoint[a[i]] = i;\n    }\n\n    // Build edges with corresponding point indices\n    vector<Edge> assignedEdges;\n    for (auto& e : treeEdges) {\n        Edge edge;\n        edge.u = e.first;\n        edge.v = e.second;\n        edge.pu = vertexToPoint[edge.u];\n        edge.pv = vertexToPoint[edge.v];\n        assignedEdges.push_back(edge);\n    }\n\n    // Check for segment intersections among non-adjacent edges\n    int m = assignedEdges.size();\n    for (int i = 0; i < m; i++) {\n        Edge& e1 = assignedEdges[i];\n        Point p1 = points[e1.pu];\n        Point p2 = points[e1.pv];\n        for (int j = i + 1; j < m; j++) {\n            Edge& e2 = assignedEdges[j];\n            // Check if edges are adjacent\n            bool adjacent = (e1.u == e2.u || e1.u == e2.v || e1.v == e2.u || e1.v == e2.v);\n            if (adjacent)\n                continue; // No need to check adjacent edges\n            Point q1 = points[e2.pu];\n            Point q2 = points[e2.pv];\n            if (doIntersect(p1, p2, q1, q2))\n                quitf(_wa, \"Segments corresponding to edges (%d-%d) and (%d-%d) intersect\", e1.u, e1.v, e2.u, e2.v);\n        }\n    }\n\n    // All checks passed\n    quitf(_ok, \"Correct solution\");\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree_type = opt<string>(\"tree-type\", \"random\");\n    bool shuffle_points = opt<bool>(\"shuffle-points\", false);\n    bool shuffle_edges = opt<bool>(\"shuffle-edges\", false);\n\n    // Generate tree edges according to tree_type\n    vector<pair<int, int>> edges;\n    if (tree_type == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"skewed\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({rnd.next(1, i - 1), i});\n        }\n    } else if (tree_type == \"balanced\") {\n        // Build a balanced binary tree\n        vector<int> nodes(n);\n        for (int i = 0; i < n; ++i) {\n            nodes[i] = i + 1;\n        }\n        edges.clear();\n        for (int i = 0; i < n; ++i) {\n            int left = 2 * i + 1;\n            int right = 2 * i + 2;\n            if (left < n) {\n                edges.push_back({nodes[i], nodes[left]});\n            }\n            if (right < n) {\n                edges.push_back({nodes[i], nodes[right]});\n            }\n        }\n    } else { // random tree\n        // Use Prüfer sequence to generate random tree\n        vector<int> prufer_sequence(n - 2);\n        for (int i = 0; i < n - 2; ++i) {\n            prufer_sequence[i] = rnd.next(1, n);\n        }\n        // Convert prufer sequence to tree edges\n        vector<int> degree(n + 1, 1);\n        for (int x : prufer_sequence) {\n            degree[x]++;\n        }\n        set<int> leaves;\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1) leaves.insert(i);\n        }\n        for (int x : prufer_sequence) {\n            int y = *leaves.begin();\n            leaves.erase(leaves.begin());\n            edges.push_back({x, y});\n            degree[x]--;\n            if (degree[x] == 1) {\n                leaves.insert(x);\n            }\n        }\n        int u = *leaves.begin();\n        leaves.erase(leaves.begin());\n        int v = *leaves.begin();\n        edges.push_back({u, v});\n    }\n\n    if (shuffle_edges) {\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Generate points\n    vector<pair<int, int>> points(n);\n    for (int i = 0; i < n; ++i) {\n        int x = i + 1; // x from 1 to n\n        long long y = 1LL * x * x;\n        points[i] = {x, y};\n    }\n    if (shuffle_points) {\n        shuffle(points.begin(), points.end());\n    }\n\n    // Output n\n    cout << n << '\\n';\n\n    // Output edges\n    for (auto e : edges) {\n        cout << e.first << ' ' << e.second << '\\n';\n    }\n\n    // Output points\n    for (auto p : points) {\n        cout << p.first << ' ' << p.second << '\\n';\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree_type = opt<string>(\"tree-type\", \"random\");\n    bool shuffle_points = opt<bool>(\"shuffle-points\", false);\n    bool shuffle_edges = opt<bool>(\"shuffle-edges\", false);\n\n    // Generate tree edges according to tree_type\n    vector<pair<int, int>> edges;\n    if (tree_type == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"skewed\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({rnd.next(1, i - 1), i});\n        }\n    } else if (tree_type == \"balanced\") {\n        // Build a balanced binary tree\n        vector<int> nodes(n);\n        for (int i = 0; i < n; ++i) {\n            nodes[i] = i + 1;\n        }\n        edges.clear();\n        for (int i = 0; i < n; ++i) {\n            int left = 2 * i + 1;\n            int right = 2 * i + 2;\n            if (left < n) {\n                edges.push_back({nodes[i], nodes[left]});\n            }\n            if (right < n) {\n                edges.push_back({nodes[i], nodes[right]});\n            }\n        }\n    } else { // random tree\n        // Use Prüfer sequence to generate random tree\n        vector<int> prufer_sequence(n - 2);\n        for (int i = 0; i < n - 2; ++i) {\n            prufer_sequence[i] = rnd.next(1, n);\n        }\n        // Convert prufer sequence to tree edges\n        vector<int> degree(n + 1, 1);\n        for (int x : prufer_sequence) {\n            degree[x]++;\n        }\n        set<int> leaves;\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1) leaves.insert(i);\n        }\n        for (int x : prufer_sequence) {\n            int y = *leaves.begin();\n            leaves.erase(leaves.begin());\n            edges.push_back({x, y});\n            degree[x]--;\n            if (degree[x] == 1) {\n                leaves.insert(x);\n            }\n        }\n        int u = *leaves.begin();\n        leaves.erase(leaves.begin());\n        int v = *leaves.begin();\n        edges.push_back({u, v});\n    }\n\n    if (shuffle_edges) {\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Generate points\n    vector<pair<int, int>> points(n);\n    for (int i = 0; i < n; ++i) {\n        int x = i + 1; // x from 1 to n\n        long long y = 1LL * x * x;\n        points[i] = {x, y};\n    }\n    if (shuffle_points) {\n        shuffle(points.begin(), points.end());\n    }\n\n    // Output n\n    cout << n << '\\n';\n\n    // Output edges\n    for (auto e : edges) {\n        cout << e.first << ' ' << e.second << '\\n';\n    }\n\n    // Output points\n    for (auto p : points) {\n        cout << p.first << ' ' << p.second << '\\n';\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -tree-type chain\n./gen -n 2 -tree-type chain\n./gen -n 2 -tree-type random -shuffle-edges\n./gen -n 10 -tree-type chain\n./gen -n 10 -tree-type star\n./gen -n 10 -tree-type balanced\n./gen -n 10 -tree-type random\n./gen -n 50 -tree-type chain -shuffle-points\n./gen -n 50 -tree-type star -shuffle-points\n./gen -n 50 -tree-type random -shuffle-points\n./gen -n 100 -tree-type random -shuffle-points -shuffle-edges\n./gen -n 300 -tree-type random\n./gen -n 300 -tree-type random -shuffle-points\n./gen -n 500 -tree-type balanced -shuffle-points\n./gen -n 500 -tree-type skewed\n./gen -n 700 -tree-type balanced -shuffle-points -shuffle-edges\n./gen -n 1000 -tree-type skewed -shuffle-edges\n./gen -n 1500 -tree-type random -shuffle-points -shuffle-edges\n./gen -n 1500 -tree-type chain\n./gen -n 1500 -tree-type star -shuffle-points\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:05.814802",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "196/D",
      "title": "D. Следующая хорошая строка",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число d (1 ≤ d ≤ |s|).Во второй строке записана непустая строка s длины не более 4·105 символов, состоящая из строчных латинских букв.",
      "output_spec": "Выходные данныеВыведите следующую после s в лексикографическом порядке хорошую строку той же длины, состоящую только из строчных латинских букв. Если такой строки не существует, выведите «Impossible» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать3aaaaaaaВыходные данныеСкопироватьaabbcaaВходные данныеСкопировать3zzyzzzzВыходные данныеСкопироватьImpossibleВходные данныеСкопировать4abbabbbabbbВыходные данныеСкопироватьabbbcaaabab",
      "description": "D. Следующая хорошая строка\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число d (1 ≤ d ≤ |s|).Во второй строке записана непустая строка s длины не более 4·105 символов, состоящая из строчных латинских букв.\n\nВходные данные\n\nВыходные данныеВыведите следующую после s в лексикографическом порядке хорошую строку той же длины, состоящую только из строчных латинских букв. Если такой строки не существует, выведите «Impossible» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать3aaaaaaaВыходные данныеСкопироватьaabbcaaВходные данныеСкопировать3zzyzzzzВыходные данныеСкопироватьImpossibleВходные данныеСкопировать4abbabbbabbbВыходные данныеСкопироватьabbbcaaabab\n\nВходные данныеСкопировать3aaaaaaa\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьaabbcaa\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3zzyzzzz\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьImpossible\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4abbabbbabbb\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьabbbcaaabab\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #124 - Codeforces",
          "content": "Всем привет!Сегодня, 12 июня, в день, когда Россия отмечает день себя, на Евро-2012 стартуют матчи второго круга, а I_love_natalia празднует свой день рождения, мы представляем вам Codeforces Round #124.К подготовке контеста имеют отношение команда Samara SAU Teddy Bears (craus, dalex, Hohol) и I_love_natalia. Также спасибо Alex_KPR и команде Codeforces (Gerald, Delinur, MikeMirzayanov). Мы думаем, что контест очень легкий, а вам придется за 2 часа доказать или опровергнуть это утверждение :)Система начисления очков — динамическая (подробнее о динамической стоимости). Авторы считают, что задачи упорядочены по неубыванию сложности.Всем полных решений и успешных взломов!UPD. Контест закончился, поздравляем победителей!Div-1 (полные результаты): tourist — единственный, кто решил все задачи! RAVEman aropan Div-2 (полные результаты): bmerry littlefriend gstsclq UPD 2. Доступен разбор задач.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 898
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces",
          "content": "197A - Игра с тарелкамиЕсли первый игрок своим ходом не может поставить тарелку на стол (стол слишком маленький, и тарелка не помещается, т.е. 2r > min(a, b)), выигрывает второй игрок.Иначе выигрывает первый игрок. Выигрышная стратегия такова: первый игрок ставит свою первую тарелку в центр стола, а затем симметрично отражает ходы соперника относительно центра стола стола. Легко видеть, что если в этом случае второму игроку удастся совершить ход, первому это также удастся. А если не удастся, первый игрок победит, что ему и было нужно.197B - ПределРешение задачи — разбор случаев.Легко понять, что важны лишь степени многочленов и их коэффициенты при старшем члене, остальные числа в инпуте — для отвода глаз. Если степень знаменателя больше, ответ равен \"0/1\". Если степень числителя больше, ответ — бесконечность. Чтобы понять, какая именно, надо посмотреть на знаки при старших коэффициентах. Если знаки одинаковые, то положительная, иначе — отрицательная. Если степени числителя и знаменателя равны, ответ, как известно из курса математики, равен . Чтобы дробь была несократимой, надо a0 и b0 поделить на их gcd. Также надо быть внимательным, если один или оба из этих чисел отрицательные и не вывести \"1/-2\" вместо \"-1/2\". 196A - Лексикографически максимальная подпоследовательностьОчевидно, что сначала нам надо выписать все буквы 'z', если они есть — ответ от этого хуже точно не станет. Теперь множество доступных букв сократилось — мы не можем использовать те буквы, что находятся левее последней буквы 'z'. Поэтому выпишем все буквы 'y', что встречаются правее последней буквы 'z'. Множество доступных букв еще сократится, теперь это будут буквы, находящиеся правее самой правой из букв 'z' и 'y'. Продолжаем так, пока не выпишем все подходящие буквы.196B - Бесконечный лабиринтУтверждение: ответ будет положительным тогда и только тогда, когда в бесконечном лабиринте существуют две различные достижимые из старта клетки, соответствующие одной и той же клетке оригинального маленького лабиринта. Действительно, если бесконечно далеко уйти можно, по пути точно придется посетить такие клетки. А если такие клетки существуют, придем в одну из них, и бесконечно будем идти по траектории, переводящей из первой во вторую.Осталось проверить наличие таких клеток. Запустим поиск в глубину по бесконечному лабиринту из стартовой точки. Пусть он при посещении точки (x, y) сохраняет в visit[x%n][y%m] значение (x, y). Теперь если поиск пытается прийти в клетку (x, y) такую, что в visit[x%n][y%m] уже что-то есть, причем оно не равно (x, y), значит две требуемые клетки найдены — клетка (x, y) и та, что сохранена в visit[x%n][y%m]. Отметим, что этот поиск посетит не более nm + 1 клеток (принцип Дирихле). Асимптотика решения — O(nm).196C - Нарисуйте деревоТ.к. никакие три точки не лежат на одной прямой, решение всегда существует.Сначала подвесим дерево за какую-нибудь вершину и dfs-ом посчитаем размеры всех поддеревьев. Теперь будем рекурсивно строить ответ. Найдем самую левую нижнюю точку и поставим ей в соответствие корень дерева. Ничего плохого от этого не случится, ведь эта точка — крайняя в множестве. Отсортируем все остальные точки по углу относительно этой самой левой нижней точки. Теперь пусть размеры поддеревьев корня равны s1, s2, ..., sk. Запустим алгоритм рекурсивно, передав первому поддереву корня первые s1 точек (в уже отсортированном порядке), второму поддереву — следующие s2 точек после первых s1, ..., последнему поддереву — последние sk точек. Легко видеть, что ребра, принадлежащие разным поддеревьям, в этом случае не будут пересекаться. На каждом этапе рекурсии надо сопоставлять самую крайнюю из выбранных точек с корнем поддерева и сортировать все остальные точки относительно нее. Тогда никакие два поддерева не будут иметь попарно пересекающихся ребер. Асимптотика решения — .196D - Следующая хорошая строкаСразу заметим, что нас интересует только наличие подпалиндромов длины d и d + 1: любой подпалиндром большей длины будет содержать их, а если нет длины d и d + 1, нет и больших. Назовем их, для краткости, плохими.Сначала найдем самую левую позицию pos, в которой символ строки точно нужно увеличить. Если плохих подпалиндромов нет, это будет конец строки (так как нужно найти хорошую строку, строго большую данной), иначе это самая левая позиция среди всех концов плохих палиндромов.Увеличим s[pos]. Продолжим увеличивать, пока s[pos] является концом плохого палиндрома. Если пытаемся увеличить символ 'z', значит надо переходить к увеличению предыдущего символа. Если таким образом дошли до начала строки и увеличивать некуда, решения нет. Заметим, что при этом будет выполнено не более O(n) операций увеличения.Пусть теперь pos — позиция самого левого измененного символа. Мы знаем, что префикс s[0..pos] не содержит плохих палиндромов. Теперь суффикс s[pos + 1..n - 1] можно заполнить жадно, перебираем позицию i по возрастанию, полагаем s[i] = 'a', и увеличиваем s[i], пока он является концом плохого палиндрома. Несложно понять, что на роль любого символа суффикса подойдет один из символов 'a', 'b' или 'c' — так как каждой позиции могут \"помешать\" лишь два символа находящихся левее на d и d - 1 позиций.Таким образом, мы получили алгоритм, который требует быстрого выполнения двух операций: изменение одного символа и запрос, является ли данная подстрока палиндромом. Это можно делать с помощью хешей и дерева Фенвика.Научимся узнавать хеш подстроки в изменяющейся строке. Тогда просто будем поддерживать информацию о самой строке, и о ее развернутой копии. Для определения, является ли данная подстрока палиндромом, просто сравним ее хеш с хешем соответствующей подстроки в развернутой версии.Итак, пусть дерево Фенвика поддерживает величины h[i] = s[i]Pi, где P — простое число, используемое для хеширования. Тогда хеш подстроки s[L..R] равен (h[L] + h[L + 1] + ...h[R])P - L. (Разумеется, можно не домножать на P - L а просто при сравнении хешей домножать один из них на нужную степень) Если требуется изменить s[i] на c, прибавляем Фенвиком в i-ую позицию число (c - s[i])Pi.Существует более быстрое решение, без хешей и структур данных, оно будет опубликовано немного позже.196E - Открытие порталовСперва заметим, что если порталы расположены во всех вершинах графа, то ответ — сумма длин ребер в минимальном остовном дереве, которое можно найти алгоритмом Краскала. Это довольно очевидно.Однако порталы расположены не во всех вершинах. Попробуем это исправить.Сделаем небольшой предпросчет: запустим алгоритм Дейкстры одновременно из всех порталов. Таким образом можно посчитать 2 массива: d[i] — расстояние от вершины i до ближайшего портала, и p[i] — ближайший к вершине i портал.Теперь рассмотрим выполнение алгоритма Краскала на графе, состоящем только из порталов. На первой итерации этот алгоритм выберет ребро с минимальным весом среди всех ребер, соединяющем порталы. Только в исходном графе это могут быть не только ребра, но и пути.Пусть такой кратчайший путь — из портала x в портал y. Заметим, что можно найти путь не длиннее, такой, что p[i] на нем будет меняться ровно один раз. Действительно, p[x] = x, p[y] = y, значит, на кратчайшем пути хотя бы раз меняется значение p[i]. Пусть оно меняется на ребре , причем p[i] = x. Поскольку путь от j до p[j] — кратчайший путь от j до портала, путь не длиннее пути из x в y.Тогда, т.к. p[i] = x, p[j] = y, можно рассчитать длину этого пути: она равна d[i] + w(i, j) + d[j] (w(i, j) — вес ребра (i, j)). Алгоритм Краскала прибавит эту величину к ответу и объединит порталы x и y. При этом объединятся поддеревья ближайших к ним вершин.А теперь видим, что ничего не изменилось, и следующее по весу ребро можно найти точно таким же способом — . Если это ребро снова лежит между вершинами x и y, то DSU не даст посчитать это ребро, иначе это ребро соединяет другую пару порталов и войдет в ответ.Как это считать. Из определения ребер в новом графе нетрудно понять, что их столько же, сколько и в исходном: каждому ребру (i, j) веса w(i, j) в старом графе соответствует ребро (p[i], p[j]) веса d[i] + w(i, j) + d[j] в новом графе. Поэтому построим новый граф и запустим на нем алгоритм Краскала — он посчитает вес минимального остовного дерева в графе, где вершины — порталы.Осталось заметить, что если в стартовой вершине есть портал, то мы нашли ответ, а если нет — то надо сначала дойти до ближайшего портала, чтобы можно было начать считать миностов. Для этого можно просто в конце прибавить к ответу число d[1].",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 196\\s*D"
          },
          "content_length": 8436
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces",
          "content": "197A - Игра с тарелкамиЕсли первый игрок своим ходом не может поставить тарелку на стол (стол слишком маленький, и тарелка не помещается, т.е. 2r > min(a, b)), выигрывает второй игрок.Иначе выигрывает первый игрок. Выигрышная стратегия такова: первый игрок ставит свою первую тарелку в центр стола, а затем симметрично отражает ходы соперника относительно центра стола стола. Легко видеть, что если в этом случае второму игроку удастся совершить ход, первому это также удастся. А если не удастся, первый игрок победит, что ему и было нужно.197B - ПределРешение задачи — разбор случаев.Легко понять, что важны лишь степени многочленов и их коэффициенты при старшем члене, остальные числа в инпуте — для отвода глаз. Если степень знаменателя больше, ответ равен \"0/1\". Если степень числителя больше, ответ — бесконечность. Чтобы понять, какая именно, надо посмотреть на знаки при старших коэффициентах. Если знаки одинаковые, то положительная, иначе — отрицательная. Если степени числителя и знаменателя равны, ответ, как известно из курса математики, равен . Чтобы дробь была несократимой, надо a0 и b0 поделить на их gcd. Также надо быть внимательным, если один или оба из этих чисел отрицательные и не вывести \"1/-2\" вместо \"-1/2\". 196A - Лексикографически максимальная подпоследовательностьОчевидно, что сначала нам надо выписать все буквы 'z', если они есть — ответ от этого хуже точно не станет. Теперь множество доступных букв сократилось — мы не можем использовать те буквы, что находятся левее последней буквы 'z'. Поэтому выпишем все буквы 'y', что встречаются правее последней буквы 'z'. Множество доступных букв еще сократится, теперь это будут буквы, находящиеся правее самой правой из букв 'z' и 'y'. Продолжаем так, пока не выпишем все подходящие буквы.196B - Бесконечный лабиринтУтверждение: ответ будет положительным тогда и только тогда, когда в бесконечном лабиринте существуют две различные достижимые из старта клетки, соответствующие одной и той же клетке оригинального маленького лабиринта. Действительно, если бесконечно далеко уйти можно, по пути точно придется посетить такие клетки. А если такие клетки существуют, придем в одну из них, и бесконечно будем идти по траектории, переводящей из первой во вторую.Осталось проверить наличие таких клеток. Запустим поиск в глубину по бесконечному лабиринту из стартовой точки. Пусть он при посещении точки (x, y) сохраняет в visit[x%n][y%m] значение (x, y). Теперь если поиск пытается прийти в клетку (x, y) такую, что в visit[x%n][y%m] уже что-то есть, причем оно не равно (x, y), значит две требуемые клетки найдены — клетка (x, y) и та, что сохранена в visit[x%n][y%m]. Отметим, что этот поиск посетит не более nm + 1 клеток (принцип Дирихле). Асимптотика решения — O(nm).196C - Нарисуйте деревоТ.к. никакие три точки не лежат на одной прямой, решение всегда существует.Сначала подвесим дерево за какую-нибудь вершину и dfs-ом посчитаем размеры всех поддеревьев. Теперь будем рекурсивно строить ответ. Найдем самую левую нижнюю точку и поставим ей в соответствие корень дерева. Ничего плохого от этого не случится, ведь эта точка — крайняя в множестве. Отсортируем все остальные точки по углу относительно этой самой левой нижней точки. Теперь пусть размеры поддеревьев корня равны s1, s2, ..., sk. Запустим алгоритм рекурсивно, передав первому поддереву корня первые s1 точек (в уже отсортированном порядке), второму поддереву — следующие s2 точек после первых s1, ..., последнему поддереву — последние sk точек. Легко видеть, что ребра, принадлежащие разным поддеревьям, в этом случае не будут пересекаться. На каждом этапе рекурсии надо сопоставлять самую крайнюю из выбранных точек с корнем поддерева и сортировать все остальные точки относительно нее. Тогда никакие два поддерева не будут иметь попарно пересекающихся ребер. Асимптотика решения — .196D - Следующая хорошая строкаСразу заметим, что нас интересует только наличие подпалиндромов длины d и d + 1: любой подпалиндром большей длины будет содержать их, а если нет длины d и d + 1, нет и больших. Назовем их, для краткости, плохими.Сначала найдем самую левую позицию pos, в которой символ строки точно нужно увеличить. Если плохих подпалиндромов нет, это будет конец строки (так как нужно найти хорошую строку, строго большую данной), иначе это самая левая позиция среди всех концов плохих палиндромов.Увеличим s[pos]. Продолжим увеличивать, пока s[pos] является концом плохого палиндрома. Если пытаемся увеличить символ 'z', значит надо переходить к увеличению предыдущего символа. Если таким образом дошли до начала строки и увеличивать некуда, решения нет. Заметим, что при этом будет выполнено не более O(n) операций увеличения.Пусть теперь pos — позиция самого левого измененного символа. Мы знаем, что префикс s[0..pos] не содержит плохих палиндромов. Теперь суффикс s[pos + 1..n - 1] можно заполнить жадно, перебираем позицию i по возрастанию, полагаем s[i] = 'a', и увеличиваем s[i], пока он является концом плохого палиндрома. Несложно понять, что на роль любого символа суффикса подойдет один из символов 'a', 'b' или 'c' — так как каждой позиции могут \"помешать\" лишь два символа находящихся левее на d и d - 1 позиций.Таким образом, мы получили алгоритм, который требует быстрого выполнения двух операций: изменение одного символа и запрос, является ли данная подстрока палиндромом. Это можно делать с помощью хешей и дерева Фенвика.Научимся узнавать хеш подстроки в изменяющейся строке. Тогда просто будем поддерживать информацию о самой строке, и о ее развернутой копии. Для определения, является ли данная подстрока палиндромом, просто сравним ее хеш с хешем соответствующей подстроки в развернутой версии.Итак, пусть дерево Фенвика поддерживает величины h[i] = s[i]Pi, где P — простое число, используемое для хеширования. Тогда хеш подстроки s[L..R] равен (h[L] + h[L + 1] + ...h[R])P - L. (Разумеется, можно не домножать на P - L а просто при сравнении хешей домножать один из них на нужную степень) Если требуется изменить s[i] на c, прибавляем Фенвиком в i-ую позицию число (c - s[i])Pi.Существует более быстрое решение, без хешей и структур данных, оно будет опубликовано немного позже.196E - Открытие порталовСперва заметим, что если порталы расположены во всех вершинах графа, то ответ — сумма длин ребер в минимальном остовном дереве, которое можно найти алгоритмом Краскала. Это довольно очевидно.Однако порталы расположены не во всех вершинах. Попробуем это исправить.Сделаем небольшой предпросчет: запустим алгоритм Дейкстры одновременно из всех порталов. Таким образом можно посчитать 2 массива: d[i] — расстояние от вершины i до ближайшего портала, и p[i] — ближайший к вершине i портал.Теперь рассмотрим выполнение алгоритма Краскала на графе, состоящем только из порталов. На первой итерации этот алгоритм выберет ребро с минимальным весом среди всех ребер, соединяющем порталы. Только в исходном графе это могут быть не только ребра, но и пути.Пусть такой кратчайший путь — из портала x в портал y. Заметим, что можно найти путь не длиннее, такой, что p[i] на нем будет меняться ровно один раз. Действительно, p[x] = x, p[y] = y, значит, на кратчайшем пути хотя бы раз меняется значение p[i]. Пусть оно меняется на ребре , причем p[i] = x. Поскольку путь от j до p[j] — кратчайший путь от j до портала, путь не длиннее пути из x в y.Тогда, т.к. p[i] = x, p[j] = y, можно рассчитать длину этого пути: она равна d[i] + w(i, j) + d[j] (w(i, j) — вес ребра (i, j)). Алгоритм Краскала прибавит эту величину к ответу и объединит порталы x и y. При этом объединятся поддеревья ближайших к ним вершин.А теперь видим, что ничего не изменилось, и следующее по весу ребро можно найти точно таким же способом — . Если это ребро снова лежит между вершинами x и y, то DSU не даст посчитать это ребро, иначе это ребро соединяет другую пару порталов и войдет в ответ.Как это считать. Из определения ребер в новом графе нетрудно понять, что их столько же, сколько и в исходном: каждому ребру (i, j) веса w(i, j) в старом графе соответствует ребро (p[i], p[j]) веса d[i] + w(i, j) + d[j] в новом графе. Поэтому построим новый граф и запустим на нем алгоритм Краскала — он посчитает вес минимального остовного дерева в графе, где вершины — порталы.Осталось заметить, что если в стартовой вершине есть портал, то мы нашли ответ, а если нет — то надо сначала дойти до ближайшего портала, чтобы можно было начать считать миностов. Для этого можно просто в конце прибавить к ответу число d[1].",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 196\\s*D"
          },
          "content_length": 8436
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #124 - Codeforces - Code 1",
          "code": "#.#\n...\n###\n#S#\n#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 2",
          "code": "#.#\n...\n###\n#S#\n#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 3",
          "code": "7 9\n#.#.#.###\n#.#.#...#\n#.#.###S#\n#.#...#.#\n#.###.#.#\n#...#.#.#\n#.#.#.#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 4",
          "code": "7 9\n#.#.#.###\n#.#.#...#\n#.#.###S#\n#.#...#.#\n#.###.#.#\n#...#.#.#\n#.#.#.#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 5",
          "code": "5 9\n###.#.#.#\n#...#.#.#\n#S###.#.#\n#.#...#.#\n#.#.###.#\n#.#.#...#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 6",
          "code": "5 9\n###.#.#.#\n#...#.#.#\n#S###.#.#\n#.#...#.#\n#.#.###.#\n#.#.#...#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 7",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 8",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 9",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 10",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 11",
          "code": "(atan2(10^9, 10^9—1) == atan2(10^9+1, 10^9)) == true",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 12",
          "code": "(atan2(10^9, 10^9—1) == atan2(10^9+1, 10^9)) == false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 13",
          "code": "4\n\n1 2\n1 3\n3 4\n\n5 5\n0 0\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 14",
          "code": "4\n\n1 2\n1 3\n3 4\n\n5 5\n0 0\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 15",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 16",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 1",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 2",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 3",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 4",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 1",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 2",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 3",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 4",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAX_LEN_S = 4 * 100000; // 4e5\n    const int MIN_LEN_S = 1; // Non-empty string\n\n    int d = inf.readInt(1, MAX_LEN_S, \"d\");\n    inf.readEoln();\n\n    string s = inf.readLine(\"[a-z]+\", \"s\");\n    int len_s = s.length();\n    ensuref(MIN_LEN_S <= len_s && len_s <= MAX_LEN_S, \"Length of s must be between %d and %d, but got %d\", MIN_LEN_S, MAX_LEN_S, len_s);\n\n    ensuref(d <= len_s, \"d (=%d) must be less than or equal to length of s (=%d)\", d, len_s);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAX_LEN_S = 4 * 100000; // 4e5\n    const int MIN_LEN_S = 1; // Non-empty string\n\n    int d = inf.readInt(1, MAX_LEN_S, \"d\");\n    inf.readEoln();\n\n    string s = inf.readLine(\"[a-z]+\", \"s\");\n    int len_s = s.length();\n    ensuref(MIN_LEN_S <= len_s && len_s <= MAX_LEN_S, \"Length of s must be between %d and %d, but got %d\", MIN_LEN_S, MAX_LEN_S, len_s);\n\n    ensuref(d <= len_s, \"d (=%d) must be less than or equal to length of s (=%d)\", d, len_s);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAX_LEN_S = 4 * 100000; // 4e5\n    const int MIN_LEN_S = 1; // Non-empty string\n\n    int d = inf.readInt(1, MAX_LEN_S, \"d\");\n    inf.readEoln();\n\n    string s = inf.readLine(\"[a-z]+\", \"s\");\n    int len_s = s.length();\n    ensuref(MIN_LEN_S <= len_s && len_s <= MAX_LEN_S, \"Length of s must be between %d and %d, but got %d\", MIN_LEN_S, MAX_LEN_S, len_s);\n\n    ensuref(d <= len_s, \"d (=%d) must be less than or equal to length of s (=%d)\", d, len_s);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_random_string(int n) {\n    string s(n, 'a');\n    for (int i = 0; i < n; ++i) {\n        s[i] = (char)('a' + rnd.next(26));\n    }\n    return s;\n}\n\nstring generate_all_same_char_string(int n, char c) {\n    return string(n, c);\n}\n\nstring generate_palindrome(int n) {\n    string s(n, 'a');\n    int half = n / 2;\n    for (int i = 0; i < half; ++i) {\n        s[i] = (char)('a' + rnd.next(26));\n        s[n - 1 - i] = s[i]; // mirror\n    }\n    if (n % 2 == 1) {\n        s[half] = (char)('a' + rnd.next(26));\n    }\n    return s;\n}\n\nstring generate_repeating_pattern(int n, int k) {\n    string pattern(k, 'a');\n    for (int i = 0; i < k; ++i) {\n        pattern[i] = (char)('a' + rnd.next(26));\n    }\n    string s = \"\";\n    while ((int)s.size() < n) {\n        s += pattern;\n    }\n    s = s.substr(0, n);\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= d && d <= n);\n\n    string s;\n\n    if (type == \"random\") {\n        s = generate_random_string(n);\n    } else if (type == \"all_a\") {\n        s = generate_all_same_char_string(n, 'a');\n    } else if (type == \"all_z\") {\n        s = generate_all_same_char_string(n, 'z');\n    } else if (type == \"palindrome\") {\n        s = generate_palindrome(n);\n    } else if (type == \"repeating\") {\n        int k = opt<int>(\"k\", 1);\n        ensure(k >= 1 && k <= n);\n        s = generate_repeating_pattern(n, k);\n    } else if (type == \"hard_case\") {\n        // Generate a string that is challenging for contestants\n        s = generate_all_same_char_string(n, 'z');\n        if (n >= 2) s[n - 2] = 'y';\n    } else {\n        // Default to random string\n        s = generate_random_string(n);\n    }\n\n    printf(\"%d\\n\", d);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_random_string(int n) {\n    string s(n, 'a');\n    for (int i = 0; i < n; ++i) {\n        s[i] = (char)('a' + rnd.next(26));\n    }\n    return s;\n}\n\nstring generate_all_same_char_string(int n, char c) {\n    return string(n, c);\n}\n\nstring generate_palindrome(int n) {\n    string s(n, 'a');\n    int half = n / 2;\n    for (int i = 0; i < half; ++i) {\n        s[i] = (char)('a' + rnd.next(26));\n        s[n - 1 - i] = s[i]; // mirror\n    }\n    if (n % 2 == 1) {\n        s[half] = (char)('a' + rnd.next(26));\n    }\n    return s;\n}\n\nstring generate_repeating_pattern(int n, int k) {\n    string pattern(k, 'a');\n    for (int i = 0; i < k; ++i) {\n        pattern[i] = (char)('a' + rnd.next(26));\n    }\n    string s = \"\";\n    while ((int)s.size() < n) {\n        s += pattern;\n    }\n    s = s.substr(0, n);\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= d && d <= n);\n\n    string s;\n\n    if (type == \"random\") {\n        s = generate_random_string(n);\n    } else if (type == \"all_a\") {\n        s = generate_all_same_char_string(n, 'a');\n    } else if (type == \"all_z\") {\n        s = generate_all_same_char_string(n, 'z');\n    } else if (type == \"palindrome\") {\n        s = generate_palindrome(n);\n    } else if (type == \"repeating\") {\n        int k = opt<int>(\"k\", 1);\n        ensure(k >= 1 && k <= n);\n        s = generate_repeating_pattern(n, k);\n    } else if (type == \"hard_case\") {\n        // Generate a string that is challenging for contestants\n        s = generate_all_same_char_string(n, 'z');\n        if (n >= 2) s[n - 2] = 'y';\n    } else {\n        // Default to random string\n        s = generate_random_string(n);\n    }\n\n    printf(\"%d\\n\", d);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimum size test cases\n./gen -n 1 -d 1 -type random\n./gen -n 1 -d 1 -type all_a\n./gen -n 1 -d 1 -type all_z\n\n# Small size test cases\n./gen -n 10 -d 1 -type random\n./gen -n 10 -d 10 -type palindrome\n./gen -n 10 -d 5 -type repeating -k 2\n./gen -n 10 -d 10 -type all_a\n./gen -n 10 -d 10 -type all_z\n\n# Medium size test cases\n./gen -n 1000 -d 2 -type random\n./gen -n 1000 -d 500 -type palindrome\n./gen -n 1000 -d 1000 -type repeating -k 5\n./gen -n 1000 -d 500 -type repeating -k 10\n\n# Maximum size test cases\n./gen -n 400000 -d 1 -type random\n./gen -n 400000 -d 200000 -type palindrome\n./gen -n 400000 -d 400000 -type all_z\n./gen -n 400000 -d 1 -type repeating -k 1\n./gen -n 400000 -d 1 -type repeating -k 26\n\n# Edge case test cases\n# String s is all 'z', so t might be \"Impossible\"\n./gen -n 1000 -d 500 -type all_z\n./gen -n 400000 -d 1 -type all_z\n\n# Repeating pattern test cases\n./gen -n 400000 -d 400 -type repeating -k 400\n./gen -n 400000 -d 399999 -type repeating -k 1\n\n# Palindrome test cases\n./gen -n 400000 -d 200000 -type palindrome\n\n# Hard case test cases\n./gen -n 1000 -d 500 -type hard_case\n./gen -n 400000 -d 200000 -type hard_case\n\n# Random strings with small d\n./gen -n 1000 -d 1 -type random\n./gen -n 400000 -d 1 -type random\n\n# Random strings with large d\n./gen -n 1000 -d 1000 -type random\n./gen -n 400000 -d 400000 -type random\n\n# All 'a's with various d\n./gen -n 1000 -d 1 -type all_a\n./gen -n 400000 -d 400000 -type all_a\n\n# Repeating patterns with k=1 (all same character)\n./gen -n 1000 -d 500 -type repeating -k 1\n./gen -n 400000 -d 1 -type repeating -k 1\n\n# Repeating patterns where k divides n\n./gen -n 1000 -d 250 -type repeating -k 250\n./gen -n 400000 -d 10000 -type repeating -k 10000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:07.635765",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "196/E",
      "title": "E. Открытие порталов",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке через пробел записано два целых числа n и m (1 ≤ n ≤ 105, 0 ≤ m ≤ 105) — количества городов и дорог в игре.В каждой из следующих m строк содержится описание дороги — три целых числа xi, yi, wi, записанные через пробел (1 ≤ xi, yi ≤ n, xi ≠ yi, 1 ≤ wi ≤ 109) — номера городов, соединенных i-ой дорогой и время, необходимое на ее преодоление. Между любыми двумя городами проведено не более одной дороги. Гарантируется, что из любого города можно добраться до любого, двигаясь по дорогам страны.В следующей строке записано целое число k (1 ≤ k ≤ n) — количество порталов.В следующей строке через пробел записаны k целых чисел p1, p2, ..., pk — номера городов, в которых установлены порталы. В каждом городе установлено не более одного портала.",
      "output_spec": "Выходные данныеВыведите единственное число — минимальное время, которое требуется игроку, чтобы открыть все порталы.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на C++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 31 2 11 3 12 3 131 2 3Выходные данныеСкопировать2Входные данныеСкопировать4 31 2 12 3 52 4 1032 3 4Выходные данныеСкопировать16Входные данныеСкопировать4 31 2 10000000002 3 10000000003 4 100000000041 2 3 4Выходные данныеСкопировать3000000000",
      "description": "E. Открытие порталов\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке через пробел записано два целых числа n и m (1 ≤ n ≤ 105, 0 ≤ m ≤ 105) — количества городов и дорог в игре.В каждой из следующих m строк содержится описание дороги — три целых числа xi, yi, wi, записанные через пробел (1 ≤ xi, yi ≤ n, xi ≠ yi, 1 ≤ wi ≤ 109) — номера городов, соединенных i-ой дорогой и время, необходимое на ее преодоление. Между любыми двумя городами проведено не более одной дороги. Гарантируется, что из любого города можно добраться до любого, двигаясь по дорогам страны.В следующей строке записано целое число k (1 ≤ k ≤ n) — количество порталов.В следующей строке через пробел записаны k целых чисел p1, p2, ..., pk — номера городов, в которых установлены порталы. В каждом городе установлено не более одного портала.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — минимальное время, которое требуется игроку, чтобы открыть все порталы.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных чисел на C++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать3 31 2 11 3 12 3 131 2 3Выходные данныеСкопировать2Входные данныеСкопировать4 31 2 12 3 52 4 1032 3 4Выходные данныеСкопировать16Входные данныеСкопировать4 31 2 10000000002 3 10000000003 4 100000000041 2 3 4Выходные данныеСкопировать3000000000\n\nВходные данныеСкопировать3 31 2 11 3 12 3 131 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 31 2 12 3 52 4 1032 3 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать16\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 31 2 10000000002 3 10000000003 4 100000000041 2 3 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВо втором примере игрок должен прийти в город 2, открыть в нем портал, затем отправиться в город 3, открыть там портал, телепортироваться обратно в город 2 и, наконец, завершить свое путешествие в городе 4.",
      "solutions": [
        {
          "title": "Codeforces Round #124 - Codeforces",
          "content": "Всем привет!Сегодня, 12 июня, в день, когда Россия отмечает день себя, на Евро-2012 стартуют матчи второго круга, а I_love_natalia празднует свой день рождения, мы представляем вам Codeforces Round #124.К подготовке контеста имеют отношение команда Samara SAU Teddy Bears (craus, dalex, Hohol) и I_love_natalia. Также спасибо Alex_KPR и команде Codeforces (Gerald, Delinur, MikeMirzayanov). Мы думаем, что контест очень легкий, а вам придется за 2 часа доказать или опровергнуть это утверждение :)Система начисления очков — динамическая (подробнее о динамической стоимости). Авторы считают, что задачи упорядочены по неубыванию сложности.Всем полных решений и успешных взломов!UPD. Контест закончился, поздравляем победителей!Div-1 (полные результаты): tourist — единственный, кто решил все задачи! RAVEman aropan Div-2 (полные результаты): bmerry littlefriend gstsclq UPD 2. Доступен разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 898
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces",
          "content": "197A - Игра с тарелкамиЕсли первый игрок своим ходом не может поставить тарелку на стол (стол слишком маленький, и тарелка не помещается, т.е. 2r > min(a, b)), выигрывает второй игрок.Иначе выигрывает первый игрок. Выигрышная стратегия такова: первый игрок ставит свою первую тарелку в центр стола, а затем симметрично отражает ходы соперника относительно центра стола стола. Легко видеть, что если в этом случае второму игроку удастся совершить ход, первому это также удастся. А если не удастся, первый игрок победит, что ему и было нужно.197B - ПределРешение задачи — разбор случаев.Легко понять, что важны лишь степени многочленов и их коэффициенты при старшем члене, остальные числа в инпуте — для отвода глаз. Если степень знаменателя больше, ответ равен \"0/1\". Если степень числителя больше, ответ — бесконечность. Чтобы понять, какая именно, надо посмотреть на знаки при старших коэффициентах. Если знаки одинаковые, то положительная, иначе — отрицательная. Если степени числителя и знаменателя равны, ответ, как известно из курса математики, равен . Чтобы дробь была несократимой, надо a0 и b0 поделить на их gcd. Также надо быть внимательным, если один или оба из этих чисел отрицательные и не вывести \"1/-2\" вместо \"-1/2\". 196A - Лексикографически максимальная подпоследовательностьОчевидно, что сначала нам надо выписать все буквы 'z', если они есть — ответ от этого хуже точно не станет. Теперь множество доступных букв сократилось — мы не можем использовать те буквы, что находятся левее последней буквы 'z'. Поэтому выпишем все буквы 'y', что встречаются правее последней буквы 'z'. Множество доступных букв еще сократится, теперь это будут буквы, находящиеся правее самой правой из букв 'z' и 'y'. Продолжаем так, пока не выпишем все подходящие буквы.196B - Бесконечный лабиринтУтверждение: ответ будет положительным тогда и только тогда, когда в бесконечном лабиринте существуют две различные достижимые из старта клетки, соответствующие одной и той же клетке оригинального маленького лабиринта. Действительно, если бесконечно далеко уйти можно, по пути точно придется посетить такие клетки. А если такие клетки существуют, придем в одну из них, и бесконечно будем идти по траектории, переводящей из первой во вторую.Осталось проверить наличие таких клеток. Запустим поиск в глубину по бесконечному лабиринту из стартовой точки. Пусть он при посещении точки (x, y) сохраняет в visit[x%n][y%m] значение (x, y). Теперь если поиск пытается прийти в клетку (x, y) такую, что в visit[x%n][y%m] уже что-то есть, причем оно не равно (x, y), значит две требуемые клетки найдены — клетка (x, y) и та, что сохранена в visit[x%n][y%m]. Отметим, что этот поиск посетит не более nm + 1 клеток (принцип Дирихле). Асимптотика решения — O(nm).196C - Нарисуйте деревоТ.к. никакие три точки не лежат на одной прямой, решение всегда существует.Сначала подвесим дерево за какую-нибудь вершину и dfs-ом посчитаем размеры всех поддеревьев. Теперь будем рекурсивно строить ответ. Найдем самую левую нижнюю точку и поставим ей в соответствие корень дерева. Ничего плохого от этого не случится, ведь эта точка — крайняя в множестве. Отсортируем все остальные точки по углу относительно этой самой левой нижней точки. Теперь пусть размеры поддеревьев корня равны s1, s2, ..., sk. Запустим алгоритм рекурсивно, передав первому поддереву корня первые s1 точек (в уже отсортированном порядке), второму поддереву — следующие s2 точек после первых s1, ..., последнему поддереву — последние sk точек. Легко видеть, что ребра, принадлежащие разным поддеревьям, в этом случае не будут пересекаться. На каждом этапе рекурсии надо сопоставлять самую крайнюю из выбранных точек с корнем поддерева и сортировать все остальные точки относительно нее. Тогда никакие два поддерева не будут иметь попарно пересекающихся ребер. Асимптотика решения — .196D - Следующая хорошая строкаСразу заметим, что нас интересует только наличие подпалиндромов длины d и d + 1: любой подпалиндром большей длины будет содержать их, а если нет длины d и d + 1, нет и больших. Назовем их, для краткости, плохими.Сначала найдем самую левую позицию pos, в которой символ строки точно нужно увеличить. Если плохих подпалиндромов нет, это будет конец строки (так как нужно найти хорошую строку, строго большую данной), иначе это самая левая позиция среди всех концов плохих палиндромов.Увеличим s[pos]. Продолжим увеличивать, пока s[pos] является концом плохого палиндрома. Если пытаемся увеличить символ 'z', значит надо переходить к увеличению предыдущего символа. Если таким образом дошли до начала строки и увеличивать некуда, решения нет. Заметим, что при этом будет выполнено не более O(n) операций увеличения.Пусть теперь pos — позиция самого левого измененного символа. Мы знаем, что префикс s[0..pos] не содержит плохих палиндромов. Теперь суффикс s[pos + 1..n - 1] можно заполнить жадно, перебираем позицию i по возрастанию, полагаем s[i] = 'a', и увеличиваем s[i], пока он является концом плохого палиндрома. Несложно понять, что на роль любого символа суффикса подойдет один из символов 'a', 'b' или 'c' — так как каждой позиции могут \"помешать\" лишь два символа находящихся левее на d и d - 1 позиций.Таким образом, мы получили алгоритм, который требует быстрого выполнения двух операций: изменение одного символа и запрос, является ли данная подстрока палиндромом. Это можно делать с помощью хешей и дерева Фенвика.Научимся узнавать хеш подстроки в изменяющейся строке. Тогда просто будем поддерживать информацию о самой строке, и о ее развернутой копии. Для определения, является ли данная подстрока палиндромом, просто сравним ее хеш с хешем соответствующей подстроки в развернутой версии.Итак, пусть дерево Фенвика поддерживает величины h[i] = s[i]Pi, где P — простое число, используемое для хеширования. Тогда хеш подстроки s[L..R] равен (h[L] + h[L + 1] + ...h[R])P - L. (Разумеется, можно не домножать на P - L а просто при сравнении хешей домножать один из них на нужную степень) Если требуется изменить s[i] на c, прибавляем Фенвиком в i-ую позицию число (c - s[i])Pi.Существует более быстрое решение, без хешей и структур данных, оно будет опубликовано немного позже.196E - Открытие порталовСперва заметим, что если порталы расположены во всех вершинах графа, то ответ — сумма длин ребер в минимальном остовном дереве, которое можно найти алгоритмом Краскала. Это довольно очевидно.Однако порталы расположены не во всех вершинах. Попробуем это исправить.Сделаем небольшой предпросчет: запустим алгоритм Дейкстры одновременно из всех порталов. Таким образом можно посчитать 2 массива: d[i] — расстояние от вершины i до ближайшего портала, и p[i] — ближайший к вершине i портал.Теперь рассмотрим выполнение алгоритма Краскала на графе, состоящем только из порталов. На первой итерации этот алгоритм выберет ребро с минимальным весом среди всех ребер, соединяющем порталы. Только в исходном графе это могут быть не только ребра, но и пути.Пусть такой кратчайший путь — из портала x в портал y. Заметим, что можно найти путь не длиннее, такой, что p[i] на нем будет меняться ровно один раз. Действительно, p[x] = x, p[y] = y, значит, на кратчайшем пути хотя бы раз меняется значение p[i]. Пусть оно меняется на ребре , причем p[i] = x. Поскольку путь от j до p[j] — кратчайший путь от j до портала, путь не длиннее пути из x в y.Тогда, т.к. p[i] = x, p[j] = y, можно рассчитать длину этого пути: она равна d[i] + w(i, j) + d[j] (w(i, j) — вес ребра (i, j)). Алгоритм Краскала прибавит эту величину к ответу и объединит порталы x и y. При этом объединятся поддеревья ближайших к ним вершин.А теперь видим, что ничего не изменилось, и следующее по весу ребро можно найти точно таким же способом — . Если это ребро снова лежит между вершинами x и y, то DSU не даст посчитать это ребро, иначе это ребро соединяет другую пару порталов и войдет в ответ.Как это считать. Из определения ребер в новом графе нетрудно понять, что их столько же, сколько и в исходном: каждому ребру (i, j) веса w(i, j) в старом графе соответствует ребро (p[i], p[j]) веса d[i] + w(i, j) + d[j] в новом графе. Поэтому построим новый граф и запустим на нем алгоритм Краскала — он посчитает вес минимального остовного дерева в графе, где вершины — порталы.Осталось заметить, что если в стартовой вершине есть портал, то мы нашли ответ, а если нет — то надо сначала дойти до ближайшего портала, чтобы можно было начать считать миностов. Для этого можно просто в конце прибавить к ответу число d[1].",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 196\\s*E"
          },
          "content_length": 8436
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces",
          "content": "197A - Игра с тарелкамиЕсли первый игрок своим ходом не может поставить тарелку на стол (стол слишком маленький, и тарелка не помещается, т.е. 2r > min(a, b)), выигрывает второй игрок.Иначе выигрывает первый игрок. Выигрышная стратегия такова: первый игрок ставит свою первую тарелку в центр стола, а затем симметрично отражает ходы соперника относительно центра стола стола. Легко видеть, что если в этом случае второму игроку удастся совершить ход, первому это также удастся. А если не удастся, первый игрок победит, что ему и было нужно.197B - ПределРешение задачи — разбор случаев.Легко понять, что важны лишь степени многочленов и их коэффициенты при старшем члене, остальные числа в инпуте — для отвода глаз. Если степень знаменателя больше, ответ равен \"0/1\". Если степень числителя больше, ответ — бесконечность. Чтобы понять, какая именно, надо посмотреть на знаки при старших коэффициентах. Если знаки одинаковые, то положительная, иначе — отрицательная. Если степени числителя и знаменателя равны, ответ, как известно из курса математики, равен . Чтобы дробь была несократимой, надо a0 и b0 поделить на их gcd. Также надо быть внимательным, если один или оба из этих чисел отрицательные и не вывести \"1/-2\" вместо \"-1/2\". 196A - Лексикографически максимальная подпоследовательностьОчевидно, что сначала нам надо выписать все буквы 'z', если они есть — ответ от этого хуже точно не станет. Теперь множество доступных букв сократилось — мы не можем использовать те буквы, что находятся левее последней буквы 'z'. Поэтому выпишем все буквы 'y', что встречаются правее последней буквы 'z'. Множество доступных букв еще сократится, теперь это будут буквы, находящиеся правее самой правой из букв 'z' и 'y'. Продолжаем так, пока не выпишем все подходящие буквы.196B - Бесконечный лабиринтУтверждение: ответ будет положительным тогда и только тогда, когда в бесконечном лабиринте существуют две различные достижимые из старта клетки, соответствующие одной и той же клетке оригинального маленького лабиринта. Действительно, если бесконечно далеко уйти можно, по пути точно придется посетить такие клетки. А если такие клетки существуют, придем в одну из них, и бесконечно будем идти по траектории, переводящей из первой во вторую.Осталось проверить наличие таких клеток. Запустим поиск в глубину по бесконечному лабиринту из стартовой точки. Пусть он при посещении точки (x, y) сохраняет в visit[x%n][y%m] значение (x, y). Теперь если поиск пытается прийти в клетку (x, y) такую, что в visit[x%n][y%m] уже что-то есть, причем оно не равно (x, y), значит две требуемые клетки найдены — клетка (x, y) и та, что сохранена в visit[x%n][y%m]. Отметим, что этот поиск посетит не более nm + 1 клеток (принцип Дирихле). Асимптотика решения — O(nm).196C - Нарисуйте деревоТ.к. никакие три точки не лежат на одной прямой, решение всегда существует.Сначала подвесим дерево за какую-нибудь вершину и dfs-ом посчитаем размеры всех поддеревьев. Теперь будем рекурсивно строить ответ. Найдем самую левую нижнюю точку и поставим ей в соответствие корень дерева. Ничего плохого от этого не случится, ведь эта точка — крайняя в множестве. Отсортируем все остальные точки по углу относительно этой самой левой нижней точки. Теперь пусть размеры поддеревьев корня равны s1, s2, ..., sk. Запустим алгоритм рекурсивно, передав первому поддереву корня первые s1 точек (в уже отсортированном порядке), второму поддереву — следующие s2 точек после первых s1, ..., последнему поддереву — последние sk точек. Легко видеть, что ребра, принадлежащие разным поддеревьям, в этом случае не будут пересекаться. На каждом этапе рекурсии надо сопоставлять самую крайнюю из выбранных точек с корнем поддерева и сортировать все остальные точки относительно нее. Тогда никакие два поддерева не будут иметь попарно пересекающихся ребер. Асимптотика решения — .196D - Следующая хорошая строкаСразу заметим, что нас интересует только наличие подпалиндромов длины d и d + 1: любой подпалиндром большей длины будет содержать их, а если нет длины d и d + 1, нет и больших. Назовем их, для краткости, плохими.Сначала найдем самую левую позицию pos, в которой символ строки точно нужно увеличить. Если плохих подпалиндромов нет, это будет конец строки (так как нужно найти хорошую строку, строго большую данной), иначе это самая левая позиция среди всех концов плохих палиндромов.Увеличим s[pos]. Продолжим увеличивать, пока s[pos] является концом плохого палиндрома. Если пытаемся увеличить символ 'z', значит надо переходить к увеличению предыдущего символа. Если таким образом дошли до начала строки и увеличивать некуда, решения нет. Заметим, что при этом будет выполнено не более O(n) операций увеличения.Пусть теперь pos — позиция самого левого измененного символа. Мы знаем, что префикс s[0..pos] не содержит плохих палиндромов. Теперь суффикс s[pos + 1..n - 1] можно заполнить жадно, перебираем позицию i по возрастанию, полагаем s[i] = 'a', и увеличиваем s[i], пока он является концом плохого палиндрома. Несложно понять, что на роль любого символа суффикса подойдет один из символов 'a', 'b' или 'c' — так как каждой позиции могут \"помешать\" лишь два символа находящихся левее на d и d - 1 позиций.Таким образом, мы получили алгоритм, который требует быстрого выполнения двух операций: изменение одного символа и запрос, является ли данная подстрока палиндромом. Это можно делать с помощью хешей и дерева Фенвика.Научимся узнавать хеш подстроки в изменяющейся строке. Тогда просто будем поддерживать информацию о самой строке, и о ее развернутой копии. Для определения, является ли данная подстрока палиндромом, просто сравним ее хеш с хешем соответствующей подстроки в развернутой версии.Итак, пусть дерево Фенвика поддерживает величины h[i] = s[i]Pi, где P — простое число, используемое для хеширования. Тогда хеш подстроки s[L..R] равен (h[L] + h[L + 1] + ...h[R])P - L. (Разумеется, можно не домножать на P - L а просто при сравнении хешей домножать один из них на нужную степень) Если требуется изменить s[i] на c, прибавляем Фенвиком в i-ую позицию число (c - s[i])Pi.Существует более быстрое решение, без хешей и структур данных, оно будет опубликовано немного позже.196E - Открытие порталовСперва заметим, что если порталы расположены во всех вершинах графа, то ответ — сумма длин ребер в минимальном остовном дереве, которое можно найти алгоритмом Краскала. Это довольно очевидно.Однако порталы расположены не во всех вершинах. Попробуем это исправить.Сделаем небольшой предпросчет: запустим алгоритм Дейкстры одновременно из всех порталов. Таким образом можно посчитать 2 массива: d[i] — расстояние от вершины i до ближайшего портала, и p[i] — ближайший к вершине i портал.Теперь рассмотрим выполнение алгоритма Краскала на графе, состоящем только из порталов. На первой итерации этот алгоритм выберет ребро с минимальным весом среди всех ребер, соединяющем порталы. Только в исходном графе это могут быть не только ребра, но и пути.Пусть такой кратчайший путь — из портала x в портал y. Заметим, что можно найти путь не длиннее, такой, что p[i] на нем будет меняться ровно один раз. Действительно, p[x] = x, p[y] = y, значит, на кратчайшем пути хотя бы раз меняется значение p[i]. Пусть оно меняется на ребре , причем p[i] = x. Поскольку путь от j до p[j] — кратчайший путь от j до портала, путь не длиннее пути из x в y.Тогда, т.к. p[i] = x, p[j] = y, можно рассчитать длину этого пути: она равна d[i] + w(i, j) + d[j] (w(i, j) — вес ребра (i, j)). Алгоритм Краскала прибавит эту величину к ответу и объединит порталы x и y. При этом объединятся поддеревья ближайших к ним вершин.А теперь видим, что ничего не изменилось, и следующее по весу ребро можно найти точно таким же способом — . Если это ребро снова лежит между вершинами x и y, то DSU не даст посчитать это ребро, иначе это ребро соединяет другую пару порталов и войдет в ответ.Как это считать. Из определения ребер в новом графе нетрудно понять, что их столько же, сколько и в исходном: каждому ребру (i, j) веса w(i, j) в старом графе соответствует ребро (p[i], p[j]) веса d[i] + w(i, j) + d[j] в новом графе. Поэтому построим новый граф и запустим на нем алгоритм Краскала — он посчитает вес минимального остовного дерева в графе, где вершины — порталы.Осталось заметить, что если в стартовой вершине есть портал, то мы нашли ответ, а если нет — то надо сначала дойти до ближайшего портала, чтобы можно было начать считать миностов. Для этого можно просто в конце прибавить к ответу число d[1].",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 196\\s*E"
          },
          "content_length": 8436
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #124 - Codeforces - Code 1",
          "code": "#.#\n...\n###\n#S#\n#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 2",
          "code": "#.#\n...\n###\n#S#\n#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 3",
          "code": "7 9\n#.#.#.###\n#.#.#...#\n#.#.###S#\n#.#...#.#\n#.###.#.#\n#...#.#.#\n#.#.#.#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 4",
          "code": "7 9\n#.#.#.###\n#.#.#...#\n#.#.###S#\n#.#...#.#\n#.###.#.#\n#...#.#.#\n#.#.#.#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 5",
          "code": "5 9\n###.#.#.#\n#...#.#.#\n#S###.#.#\n#.#...#.#\n#.#.###.#\n#.#.#...#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 6",
          "code": "5 9\n###.#.#.#\n#...#.#.#\n#S###.#.#\n#.#...#.#\n#.#.###.#\n#.#.#...#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 7",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 8",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 9",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 10",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 11",
          "code": "(atan2(10^9, 10^9—1) == atan2(10^9+1, 10^9)) == true",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 12",
          "code": "(atan2(10^9, 10^9—1) == atan2(10^9+1, 10^9)) == false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 13",
          "code": "4\n\n1 2\n1 3\n3 4\n\n5 5\n0 0\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 14",
          "code": "4\n\n1 2\n1 3\n3 4\n\n5 5\n0 0\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 15",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 16",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 1",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 2",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 3",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 4",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 1",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 2",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 3",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 4",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int a) {\n    if (parent[a] != a)\n        parent[a] = find(parent[a]);\n    return parent[a];\n}\n\nvoid unite(int a, int b, int& components) {\n    a = find(a);\n    b = find(b);\n    if (a != b) {\n        parent[a] = b;\n        components--;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n    \n    parent.resize(n + 1);\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n    int components = n;\n    \n    set<pair<int,int>> edges;\n    \n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readSpace();\n        ensuref(xi != yi, \"Edge %d: xi and yi must be different\", i + 2);\n        int wi = inf.readInt(1, 1000000000, \"wi\");\n        inf.readEoln();\n        \n        int a = min(xi, yi);\n        int b = max(xi, yi);\n        ensuref(edges.find({a, b}) == edges.end(), \"Multiple edges between cities %d and %d\", a, b);\n        edges.insert({a, b});\n        \n        unite(xi, yi, components);\n    }\n    \n    ensuref(components == 1, \"The graph is not connected\");\n    \n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    \n    vector<int> p = inf.readInts(k, 1, n, \"p\");\n    inf.readEoln();\n    \n    set<int> portalSet(p.begin(), p.end());\n    ensuref(portalSet.size() == k, \"Duplicate portal cities found\");\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int a) {\n    if (parent[a] != a)\n        parent[a] = find(parent[a]);\n    return parent[a];\n}\n\nvoid unite(int a, int b, int& components) {\n    a = find(a);\n    b = find(b);\n    if (a != b) {\n        parent[a] = b;\n        components--;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n    \n    parent.resize(n + 1);\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n    int components = n;\n    \n    set<pair<int,int>> edges;\n    \n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readSpace();\n        ensuref(xi != yi, \"Edge %d: xi and yi must be different\", i + 2);\n        int wi = inf.readInt(1, 1000000000, \"wi\");\n        inf.readEoln();\n        \n        int a = min(xi, yi);\n        int b = max(xi, yi);\n        ensuref(edges.find({a, b}) == edges.end(), \"Multiple edges between cities %d and %d\", a, b);\n        edges.insert({a, b});\n        \n        unite(xi, yi, components);\n    }\n    \n    ensuref(components == 1, \"The graph is not connected\");\n    \n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    \n    vector<int> p = inf.readInts(k, 1, n, \"p\");\n    inf.readEoln();\n    \n    set<int> portalSet(p.begin(), p.end());\n    ensuref(portalSet.size() == k, \"Duplicate portal cities found\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int a) {\n    if (parent[a] != a)\n        parent[a] = find(parent[a]);\n    return parent[a];\n}\n\nvoid unite(int a, int b, int& components) {\n    a = find(a);\n    b = find(b);\n    if (a != b) {\n        parent[a] = b;\n        components--;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n    \n    parent.resize(n + 1);\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n    int components = n;\n    \n    set<pair<int,int>> edges;\n    \n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readSpace();\n        ensuref(xi != yi, \"Edge %d: xi and yi must be different\", i + 2);\n        int wi = inf.readInt(1, 1000000000, \"wi\");\n        inf.readEoln();\n        \n        int a = min(xi, yi);\n        int b = max(xi, yi);\n        ensuref(edges.find({a, b}) == edges.end(), \"Multiple edges between cities %d and %d\", a, b);\n        edges.insert({a, b});\n        \n        unite(xi, yi, components);\n    }\n    \n    ensuref(components == 1, \"The graph is not connected\");\n    \n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    \n    vector<int> p = inf.readInts(k, 1, n, \"p\");\n    inf.readEoln();\n    \n    set<int> portalSet(p.begin(), p.end());\n    ensuref(portalSet.size() == k, \"Duplicate portal cities found\");\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int u, v;\n    int w;\n};\n\nvoid generate_chain(int n, int m, vector<Edge> &edge_list, set<pair<int, int>> &edge_set, int min_w, int max_w) {\n    for (int i = 1; i < n; ++i) {\n        edge_list.push_back({i, i + 1, rnd.next(min_w, max_w)});\n        edge_set.insert({min(i, i + 1), max(i, i + 1)});\n    }\n    int extra_edges = m - (n - 1);\n    while (extra_edges-- > 0) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        while (u == v || edge_set.count({min(u, v), max(u, v)})) {\n            u = rnd.next(1, n);\n            v = rnd.next(1, n);\n        }\n        edge_list.push_back({u, v, rnd.next(min_w, max_w)});\n        edge_set.insert({min(u, v), max(u, v)});\n    }\n}\n\nvoid generate_star(int n, int m, vector<Edge> &edge_list, set<pair<int, int>> &edge_set, int min_w, int max_w) {\n    for (int i = 2; i <= n; ++i) {\n        edge_list.push_back({1, i, rnd.next(min_w, max_w)});\n        edge_set.insert({1, i});\n    }\n    int extra_edges = m - (n - 1);\n    while (extra_edges-- > 0) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        while (u == v || edge_set.count({min(u, v), max(u, v)})) {\n            u = rnd.next(1, n);\n            v = rnd.next(1, n);\n        }\n        edge_list.push_back({u, v, rnd.next(min_w, max_w)});\n        edge_set.insert({min(u, v), max(u, v)});\n    }\n}\n\nvoid generate_random(int n, int m, vector<Edge> &edge_list, set<pair<int, int>> &edge_set, int min_w, int max_w) {\n    // Generate random tree first\n    for (int i = 2; i <= n; ++i) {\n        int u = i;\n        int v = rnd.next(1, i - 1);\n        edge_list.push_back({u, v, rnd.next(min_w, max_w)});\n        edge_set.insert({min(u, v), max(u, v)});\n    }\n    int extra_edges = m - (n - 1);\n    while (extra_edges-- > 0) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        while (u == v || edge_set.count({min(u, v), max(u, v)})) {\n            u = rnd.next(1, n);\n            v = rnd.next(1, n);\n        }\n        edge_list.push_back({u, v, rnd.next(min_w, max_w)});\n        edge_set.insert({min(u, v), max(u, v)});\n    }\n}\n\nvoid generate_portals(int n, int k, vector<int> &portals, string portal_type) {\n    if (portal_type == \"random\") {\n        portals = rnd.perm(n);\n        portals.resize(k);\n        for (int i = 0; i < k; ++i)\n            portals[i]++;\n    } else if (portal_type == \"begin\") {\n        for (int i = 1; i <= k; ++i)\n            portals.push_back(i);\n    } else if (portal_type == \"end\") {\n        for (int i = n - k + 1; i <= n; ++i)\n            portals.push_back(i);\n    } else if (portal_type == \"middle\") {\n        int start = n / 2 - k / 2;\n        start = max(1, start);\n        for (int i = 0; i < k; ++i)\n            portals.push_back(start + i);\n    } else {\n        // Default to random\n        portals = rnd.perm(n);\n        portals.resize(k);\n        for (int i = 0; i < k; ++i)\n            portals[i]++;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n - 1);\n    int k = opt<int>(\"k\", 1);\n    string type = opt<string>(\"type\", \"random\");\n    string portal_type = opt<string>(\"portal_type\", \"random\");\n    int min_w = opt<int>(\"min_w\", 1);\n    int max_w = opt<int>(\"max_w\", 1000000000);\n\n    // Adjust m to be within valid range\n    if (n == 1) {\n        m = 0;\n    } else {\n        if (m < n - 1)\n            m = n - 1;\n        if (m > int(1e5))\n            m = int(1e5);\n    }\n\n    if (k < 1)\n        k = 1;\n    if (k > n)\n        k = n;\n\n    vector<Edge> edge_list;\n    set<pair<int, int>> edge_set;\n\n    if (type == \"chain\") {\n        generate_chain(n, m, edge_list, edge_set, min_w, max_w);\n    } else if (type == \"star\") {\n        generate_star(n, m, edge_list, edge_set, min_w, max_w);\n    } else {\n        generate_random(n, m, edge_list, edge_set, min_w, max_w);\n    }\n\n    shuffle(edge_list.begin(), edge_list.end());\n\n    vector<int> portals;\n    generate_portals(n, k, portals, portal_type);\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edge_list)\n        printf(\"%d %d %d\\n\", e.u, e.v, e.w);\n    printf(\"%d\\n\", k);\n    for (int i = 0; i < k; ++i) {\n        printf(\"%d%c\", portals[i], i == k - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int u, v;\n    int w;\n};\n\nvoid generate_chain(int n, int m, vector<Edge> &edge_list, set<pair<int, int>> &edge_set, int min_w, int max_w) {\n    for (int i = 1; i < n; ++i) {\n        edge_list.push_back({i, i + 1, rnd.next(min_w, max_w)});\n        edge_set.insert({min(i, i + 1), max(i, i + 1)});\n    }\n    int extra_edges = m - (n - 1);\n    while (extra_edges-- > 0) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        while (u == v || edge_set.count({min(u, v), max(u, v)})) {\n            u = rnd.next(1, n);\n            v = rnd.next(1, n);\n        }\n        edge_list.push_back({u, v, rnd.next(min_w, max_w)});\n        edge_set.insert({min(u, v), max(u, v)});\n    }\n}\n\nvoid generate_star(int n, int m, vector<Edge> &edge_list, set<pair<int, int>> &edge_set, int min_w, int max_w) {\n    for (int i = 2; i <= n; ++i) {\n        edge_list.push_back({1, i, rnd.next(min_w, max_w)});\n        edge_set.insert({1, i});\n    }\n    int extra_edges = m - (n - 1);\n    while (extra_edges-- > 0) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        while (u == v || edge_set.count({min(u, v), max(u, v)})) {\n            u = rnd.next(1, n);\n            v = rnd.next(1, n);\n        }\n        edge_list.push_back({u, v, rnd.next(min_w, max_w)});\n        edge_set.insert({min(u, v), max(u, v)});\n    }\n}\n\nvoid generate_random(int n, int m, vector<Edge> &edge_list, set<pair<int, int>> &edge_set, int min_w, int max_w) {\n    // Generate random tree first\n    for (int i = 2; i <= n; ++i) {\n        int u = i;\n        int v = rnd.next(1, i - 1);\n        edge_list.push_back({u, v, rnd.next(min_w, max_w)});\n        edge_set.insert({min(u, v), max(u, v)});\n    }\n    int extra_edges = m - (n - 1);\n    while (extra_edges-- > 0) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        while (u == v || edge_set.count({min(u, v), max(u, v)})) {\n            u = rnd.next(1, n);\n            v = rnd.next(1, n);\n        }\n        edge_list.push_back({u, v, rnd.next(min_w, max_w)});\n        edge_set.insert({min(u, v), max(u, v)});\n    }\n}\n\nvoid generate_portals(int n, int k, vector<int> &portals, string portal_type) {\n    if (portal_type == \"random\") {\n        portals = rnd.perm(n);\n        portals.resize(k);\n        for (int i = 0; i < k; ++i)\n            portals[i]++;\n    } else if (portal_type == \"begin\") {\n        for (int i = 1; i <= k; ++i)\n            portals.push_back(i);\n    } else if (portal_type == \"end\") {\n        for (int i = n - k + 1; i <= n; ++i)\n            portals.push_back(i);\n    } else if (portal_type == \"middle\") {\n        int start = n / 2 - k / 2;\n        start = max(1, start);\n        for (int i = 0; i < k; ++i)\n            portals.push_back(start + i);\n    } else {\n        // Default to random\n        portals = rnd.perm(n);\n        portals.resize(k);\n        for (int i = 0; i < k; ++i)\n            portals[i]++;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n - 1);\n    int k = opt<int>(\"k\", 1);\n    string type = opt<string>(\"type\", \"random\");\n    string portal_type = opt<string>(\"portal_type\", \"random\");\n    int min_w = opt<int>(\"min_w\", 1);\n    int max_w = opt<int>(\"max_w\", 1000000000);\n\n    // Adjust m to be within valid range\n    if (n == 1) {\n        m = 0;\n    } else {\n        if (m < n - 1)\n            m = n - 1;\n        if (m > int(1e5))\n            m = int(1e5);\n    }\n\n    if (k < 1)\n        k = 1;\n    if (k > n)\n        k = n;\n\n    vector<Edge> edge_list;\n    set<pair<int, int>> edge_set;\n\n    if (type == \"chain\") {\n        generate_chain(n, m, edge_list, edge_set, min_w, max_w);\n    } else if (type == \"star\") {\n        generate_star(n, m, edge_list, edge_set, min_w, max_w);\n    } else {\n        generate_random(n, m, edge_list, edge_set, min_w, max_w);\n    }\n\n    shuffle(edge_list.begin(), edge_list.end());\n\n    vector<int> portals;\n    generate_portals(n, k, portals, portal_type);\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edge_list)\n        printf(\"%d %d %d\\n\", e.u, e.v, e.w);\n    printf(\"%d\\n\", k);\n    for (int i = 0; i < k; ++i) {\n        printf(\"%d%c\", portals[i], i == k - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 0 -k 1 -type chain\n./gen -n 2 -m 1 -k 1 -type chain\n./gen -n 5 -m 4 -k 3 -type chain\n\n./gen -n 10 -m 9 -k 5 -type chain\n./gen -n 10 -m 45 -k 7 -type random\n\n./gen -n 100 -m 99 -k 1 -type star\n./gen -n 100 -m 100 -k 50 -type star\n./gen -n 100 -m 5000 -k 50 -type random\n\n./gen -n 1000 -m 999 -k 100 -type chain\n./gen -n 1000 -m 50000 -k 500 -type random\n\n./gen -n 10000 -m 9999 -k 1 -type chain -portal_type begin\n./gen -n 10000 -m 100000 -k 5000 -type random -portal_type random\n./gen -n 10000 -m 100000 -k 10000 -type random -portal_type end\n\n./gen -n 100000 -m 100000 -k 1 -type random -portal_type begin\n./gen -n 100000 -m 100000 -k 100000 -type random -portal_type random\n./gen -n 100000 -m 100000 -k 50000 -type star -portal_type middle\n\n./gen -n 100000 -m 100000 -k 50000 -type random -min_w 1000000000 -max_w 1000000000\n./gen -n 100000 -m 100000 -k 50000 -type random -min_w 1 -max_w 1\n\n./gen -n 100000 -m 100000 -k 1 -type chain -min_w 1000000000 -max_w 1000000000\n\n./gen -n 1 -m 0 -k 1 -type chain\n\n./gen -n 100000 -m 100000 -k 50000 -type random -min_w 1000000000 -max_w 1000000000 -portal_type random\n\n./gen -n 100000 -m 100000 -k 1 -type random -portal_type begin\n\n./gen -n 100000 -m 100000 -k 1 -type chain -portal_type end\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:09.703993",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "197/A",
      "title": "A. Игра с тарелками",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке находятся три целых числа a, b, r (1 ≤ a, b, r ≤ 100), записанные через пробел, — размеры стола и радиус тарелок соответственно.",
      "output_spec": "Выходные данныеЕсли победит игрок, который ходит первым, выведите «First» (без кавычек). Иначе выведите «Second» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать5 5 2Выходные данныеСкопироватьFirstВходные данныеСкопировать6 7 4Выходные данныеСкопироватьSecond",
      "description": "A. Игра с тарелками\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке находятся три целых числа a, b, r (1 ≤ a, b, r ≤ 100), записанные через пробел, — размеры стола и радиус тарелок соответственно.\n\nВходные данные\n\nВыходные данныеЕсли победит игрок, который ходит первым, выведите «First» (без кавычек). Иначе выведите «Second» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать5 5 2Выходные данныеСкопироватьFirstВходные данныеСкопировать6 7 4Выходные данныеСкопироватьSecond\n\nВходные данныеСкопировать5 5 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьFirst\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 7 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьSecond\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере на столе есть место только для одной тарелки. Первый игрок поставит тарелку на стол, а второй этого сделать не сможет и проиграет.  Во втором примере стол настолько маленький, что туда не помещается даже одна тарелка. Поэтому первый игрок проигрывает, не сделав ни одного хода.",
      "solutions": [
        {
          "title": "Codeforces Round #124 - Codeforces",
          "content": "Всем привет!Сегодня, 12 июня, в день, когда Россия отмечает день себя, на Евро-2012 стартуют матчи второго круга, а I_love_natalia празднует свой день рождения, мы представляем вам Codeforces Round #124.К подготовке контеста имеют отношение команда Samara SAU Teddy Bears (craus, dalex, Hohol) и I_love_natalia. Также спасибо Alex_KPR и команде Codeforces (Gerald, Delinur, MikeMirzayanov). Мы думаем, что контест очень легкий, а вам придется за 2 часа доказать или опровергнуть это утверждение :)Система начисления очков — динамическая (подробнее о динамической стоимости). Авторы считают, что задачи упорядочены по неубыванию сложности.Всем полных решений и успешных взломов!UPD. Контест закончился, поздравляем победителей!Div-1 (полные результаты): tourist — единственный, кто решил все задачи! RAVEman aropan Div-2 (полные результаты): bmerry littlefriend gstsclq UPD 2. Доступен разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 898
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces",
          "content": "197A - Игра с тарелкамиЕсли первый игрок своим ходом не может поставить тарелку на стол (стол слишком маленький, и тарелка не помещается, т.е. 2r > min(a, b)), выигрывает второй игрок.Иначе выигрывает первый игрок. Выигрышная стратегия такова: первый игрок ставит свою первую тарелку в центр стола, а затем симметрично отражает ходы соперника относительно центра стола стола. Легко видеть, что если в этом случае второму игроку удастся совершить ход, первому это также удастся. А если не удастся, первый игрок победит, что ему и было нужно.197B - ПределРешение задачи — разбор случаев.Легко понять, что важны лишь степени многочленов и их коэффициенты при старшем члене, остальные числа в инпуте — для отвода глаз. Если степень знаменателя больше, ответ равен \"0/1\". Если степень числителя больше, ответ — бесконечность. Чтобы понять, какая именно, надо посмотреть на знаки при старших коэффициентах. Если знаки одинаковые, то положительная, иначе — отрицательная. Если степени числителя и знаменателя равны, ответ, как известно из курса математики, равен . Чтобы дробь была несократимой, надо a0 и b0 поделить на их gcd. Также надо быть внимательным, если один или оба из этих чисел отрицательные и не вывести \"1/-2\" вместо \"-1/2\". 196A - Лексикографически максимальная подпоследовательностьОчевидно, что сначала нам надо выписать все буквы 'z', если они есть — ответ от этого хуже точно не станет. Теперь множество доступных букв сократилось — мы не можем использовать те буквы, что находятся левее последней буквы 'z'. Поэтому выпишем все буквы 'y', что встречаются правее последней буквы 'z'. Множество доступных букв еще сократится, теперь это будут буквы, находящиеся правее самой правой из букв 'z' и 'y'. Продолжаем так, пока не выпишем все подходящие буквы.196B - Бесконечный лабиринтУтверждение: ответ будет положительным тогда и только тогда, когда в бесконечном лабиринте существуют две различные достижимые из старта клетки, соответствующие одной и той же клетке оригинального маленького лабиринта. Действительно, если бесконечно далеко уйти можно, по пути точно придется посетить такие клетки. А если такие клетки существуют, придем в одну из них, и бесконечно будем идти по траектории, переводящей из первой во вторую.Осталось проверить наличие таких клеток. Запустим поиск в глубину по бесконечному лабиринту из стартовой точки. Пусть он при посещении точки (x, y) сохраняет в visit[x%n][y%m] значение (x, y). Теперь если поиск пытается прийти в клетку (x, y) такую, что в visit[x%n][y%m] уже что-то есть, причем оно не равно (x, y), значит две требуемые клетки найдены — клетка (x, y) и та, что сохранена в visit[x%n][y%m]. Отметим, что этот поиск посетит не более nm + 1 клеток (принцип Дирихле). Асимптотика решения — O(nm).196C - Нарисуйте деревоТ.к. никакие три точки не лежат на одной прямой, решение всегда существует.Сначала подвесим дерево за какую-нибудь вершину и dfs-ом посчитаем размеры всех поддеревьев. Теперь будем рекурсивно строить ответ. Найдем самую левую нижнюю точку и поставим ей в соответствие корень дерева. Ничего плохого от этого не случится, ведь эта точка — крайняя в множестве. Отсортируем все остальные точки по углу относительно этой самой левой нижней точки. Теперь пусть размеры поддеревьев корня равны s1, s2, ..., sk. Запустим алгоритм рекурсивно, передав первому поддереву корня первые s1 точек (в уже отсортированном порядке), второму поддереву — следующие s2 точек после первых s1, ..., последнему поддереву — последние sk точек. Легко видеть, что ребра, принадлежащие разным поддеревьям, в этом случае не будут пересекаться. На каждом этапе рекурсии надо сопоставлять самую крайнюю из выбранных точек с корнем поддерева и сортировать все остальные точки относительно нее. Тогда никакие два поддерева не будут иметь попарно пересекающихся ребер. Асимптотика решения — .196D - Следующая хорошая строкаСразу заметим, что нас интересует только наличие подпалиндромов длины d и d + 1: любой подпалиндром большей длины будет содержать их, а если нет длины d и d + 1, нет и больших. Назовем их, для краткости, плохими.Сначала найдем самую левую позицию pos, в которой символ строки точно нужно увеличить. Если плохих подпалиндромов нет, это будет конец строки (так как нужно найти хорошую строку, строго большую данной), иначе это самая левая позиция среди всех концов плохих палиндромов.Увеличим s[pos]. Продолжим увеличивать, пока s[pos] является концом плохого палиндрома. Если пытаемся увеличить символ 'z', значит надо переходить к увеличению предыдущего символа. Если таким образом дошли до начала строки и увеличивать некуда, решения нет. Заметим, что при этом будет выполнено не более O(n) операций увеличения.Пусть теперь pos — позиция самого левого измененного символа. Мы знаем, что префикс s[0..pos] не содержит плохих палиндромов. Теперь суффикс s[pos + 1..n - 1] можно заполнить жадно, перебираем позицию i по возрастанию, полагаем s[i] = 'a', и увеличиваем s[i], пока он является концом плохого палиндрома. Несложно понять, что на роль любого символа суффикса подойдет один из символов 'a', 'b' или 'c' — так как каждой позиции могут \"помешать\" лишь два символа находящихся левее на d и d - 1 позиций.Таким образом, мы получили алгоритм, который требует быстрого выполнения двух операций: изменение одного символа и запрос, является ли данная подстрока палиндромом. Это можно делать с помощью хешей и дерева Фенвика.Научимся узнавать хеш подстроки в изменяющейся строке. Тогда просто будем поддерживать информацию о самой строке, и о ее развернутой копии. Для определения, является ли данная подстрока палиндромом, просто сравним ее хеш с хешем соответствующей подстроки в развернутой версии.Итак, пусть дерево Фенвика поддерживает величины h[i] = s[i]Pi, где P — простое число, используемое для хеширования. Тогда хеш подстроки s[L..R] равен (h[L] + h[L + 1] + ...h[R])P - L. (Разумеется, можно не домножать на P - L а просто при сравнении хешей домножать один из них на нужную степень) Если требуется изменить s[i] на c, прибавляем Фенвиком в i-ую позицию число (c - s[i])Pi.Существует более быстрое решение, без хешей и структур данных, оно будет опубликовано немного позже.196E - Открытие порталовСперва заметим, что если порталы расположены во всех вершинах графа, то ответ — сумма длин ребер в минимальном остовном дереве, которое можно найти алгоритмом Краскала. Это довольно очевидно.Однако порталы расположены не во всех вершинах. Попробуем это исправить.Сделаем небольшой предпросчет: запустим алгоритм Дейкстры одновременно из всех порталов. Таким образом можно посчитать 2 массива: d[i] — расстояние от вершины i до ближайшего портала, и p[i] — ближайший к вершине i портал.Теперь рассмотрим выполнение алгоритма Краскала на графе, состоящем только из порталов. На первой итерации этот алгоритм выберет ребро с минимальным весом среди всех ребер, соединяющем порталы. Только в исходном графе это могут быть не только ребра, но и пути.Пусть такой кратчайший путь — из портала x в портал y. Заметим, что можно найти путь не длиннее, такой, что p[i] на нем будет меняться ровно один раз. Действительно, p[x] = x, p[y] = y, значит, на кратчайшем пути хотя бы раз меняется значение p[i]. Пусть оно меняется на ребре , причем p[i] = x. Поскольку путь от j до p[j] — кратчайший путь от j до портала, путь не длиннее пути из x в y.Тогда, т.к. p[i] = x, p[j] = y, можно рассчитать длину этого пути: она равна d[i] + w(i, j) + d[j] (w(i, j) — вес ребра (i, j)). Алгоритм Краскала прибавит эту величину к ответу и объединит порталы x и y. При этом объединятся поддеревья ближайших к ним вершин.А теперь видим, что ничего не изменилось, и следующее по весу ребро можно найти точно таким же способом — . Если это ребро снова лежит между вершинами x и y, то DSU не даст посчитать это ребро, иначе это ребро соединяет другую пару порталов и войдет в ответ.Как это считать. Из определения ребер в новом графе нетрудно понять, что их столько же, сколько и в исходном: каждому ребру (i, j) веса w(i, j) в старом графе соответствует ребро (p[i], p[j]) веса d[i] + w(i, j) + d[j] в новом графе. Поэтому построим новый граф и запустим на нем алгоритм Краскала — он посчитает вес минимального остовного дерева в графе, где вершины — порталы.Осталось заметить, что если в стартовой вершине есть портал, то мы нашли ответ, а если нет — то надо сначала дойти до ближайшего портала, чтобы можно было начать считать миностов. Для этого можно просто в конце прибавить к ответу число d[1].",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 197\\s*A"
          },
          "content_length": 8436
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces",
          "content": "197A - Игра с тарелкамиЕсли первый игрок своим ходом не может поставить тарелку на стол (стол слишком маленький, и тарелка не помещается, т.е. 2r > min(a, b)), выигрывает второй игрок.Иначе выигрывает первый игрок. Выигрышная стратегия такова: первый игрок ставит свою первую тарелку в центр стола, а затем симметрично отражает ходы соперника относительно центра стола стола. Легко видеть, что если в этом случае второму игроку удастся совершить ход, первому это также удастся. А если не удастся, первый игрок победит, что ему и было нужно.197B - ПределРешение задачи — разбор случаев.Легко понять, что важны лишь степени многочленов и их коэффициенты при старшем члене, остальные числа в инпуте — для отвода глаз. Если степень знаменателя больше, ответ равен \"0/1\". Если степень числителя больше, ответ — бесконечность. Чтобы понять, какая именно, надо посмотреть на знаки при старших коэффициентах. Если знаки одинаковые, то положительная, иначе — отрицательная. Если степени числителя и знаменателя равны, ответ, как известно из курса математики, равен . Чтобы дробь была несократимой, надо a0 и b0 поделить на их gcd. Также надо быть внимательным, если один или оба из этих чисел отрицательные и не вывести \"1/-2\" вместо \"-1/2\". 196A - Лексикографически максимальная подпоследовательностьОчевидно, что сначала нам надо выписать все буквы 'z', если они есть — ответ от этого хуже точно не станет. Теперь множество доступных букв сократилось — мы не можем использовать те буквы, что находятся левее последней буквы 'z'. Поэтому выпишем все буквы 'y', что встречаются правее последней буквы 'z'. Множество доступных букв еще сократится, теперь это будут буквы, находящиеся правее самой правой из букв 'z' и 'y'. Продолжаем так, пока не выпишем все подходящие буквы.196B - Бесконечный лабиринтУтверждение: ответ будет положительным тогда и только тогда, когда в бесконечном лабиринте существуют две различные достижимые из старта клетки, соответствующие одной и той же клетке оригинального маленького лабиринта. Действительно, если бесконечно далеко уйти можно, по пути точно придется посетить такие клетки. А если такие клетки существуют, придем в одну из них, и бесконечно будем идти по траектории, переводящей из первой во вторую.Осталось проверить наличие таких клеток. Запустим поиск в глубину по бесконечному лабиринту из стартовой точки. Пусть он при посещении точки (x, y) сохраняет в visit[x%n][y%m] значение (x, y). Теперь если поиск пытается прийти в клетку (x, y) такую, что в visit[x%n][y%m] уже что-то есть, причем оно не равно (x, y), значит две требуемые клетки найдены — клетка (x, y) и та, что сохранена в visit[x%n][y%m]. Отметим, что этот поиск посетит не более nm + 1 клеток (принцип Дирихле). Асимптотика решения — O(nm).196C - Нарисуйте деревоТ.к. никакие три точки не лежат на одной прямой, решение всегда существует.Сначала подвесим дерево за какую-нибудь вершину и dfs-ом посчитаем размеры всех поддеревьев. Теперь будем рекурсивно строить ответ. Найдем самую левую нижнюю точку и поставим ей в соответствие корень дерева. Ничего плохого от этого не случится, ведь эта точка — крайняя в множестве. Отсортируем все остальные точки по углу относительно этой самой левой нижней точки. Теперь пусть размеры поддеревьев корня равны s1, s2, ..., sk. Запустим алгоритм рекурсивно, передав первому поддереву корня первые s1 точек (в уже отсортированном порядке), второму поддереву — следующие s2 точек после первых s1, ..., последнему поддереву — последние sk точек. Легко видеть, что ребра, принадлежащие разным поддеревьям, в этом случае не будут пересекаться. На каждом этапе рекурсии надо сопоставлять самую крайнюю из выбранных точек с корнем поддерева и сортировать все остальные точки относительно нее. Тогда никакие два поддерева не будут иметь попарно пересекающихся ребер. Асимптотика решения — .196D - Следующая хорошая строкаСразу заметим, что нас интересует только наличие подпалиндромов длины d и d + 1: любой подпалиндром большей длины будет содержать их, а если нет длины d и d + 1, нет и больших. Назовем их, для краткости, плохими.Сначала найдем самую левую позицию pos, в которой символ строки точно нужно увеличить. Если плохих подпалиндромов нет, это будет конец строки (так как нужно найти хорошую строку, строго большую данной), иначе это самая левая позиция среди всех концов плохих палиндромов.Увеличим s[pos]. Продолжим увеличивать, пока s[pos] является концом плохого палиндрома. Если пытаемся увеличить символ 'z', значит надо переходить к увеличению предыдущего символа. Если таким образом дошли до начала строки и увеличивать некуда, решения нет. Заметим, что при этом будет выполнено не более O(n) операций увеличения.Пусть теперь pos — позиция самого левого измененного символа. Мы знаем, что префикс s[0..pos] не содержит плохих палиндромов. Теперь суффикс s[pos + 1..n - 1] можно заполнить жадно, перебираем позицию i по возрастанию, полагаем s[i] = 'a', и увеличиваем s[i], пока он является концом плохого палиндрома. Несложно понять, что на роль любого символа суффикса подойдет один из символов 'a', 'b' или 'c' — так как каждой позиции могут \"помешать\" лишь два символа находящихся левее на d и d - 1 позиций.Таким образом, мы получили алгоритм, который требует быстрого выполнения двух операций: изменение одного символа и запрос, является ли данная подстрока палиндромом. Это можно делать с помощью хешей и дерева Фенвика.Научимся узнавать хеш подстроки в изменяющейся строке. Тогда просто будем поддерживать информацию о самой строке, и о ее развернутой копии. Для определения, является ли данная подстрока палиндромом, просто сравним ее хеш с хешем соответствующей подстроки в развернутой версии.Итак, пусть дерево Фенвика поддерживает величины h[i] = s[i]Pi, где P — простое число, используемое для хеширования. Тогда хеш подстроки s[L..R] равен (h[L] + h[L + 1] + ...h[R])P - L. (Разумеется, можно не домножать на P - L а просто при сравнении хешей домножать один из них на нужную степень) Если требуется изменить s[i] на c, прибавляем Фенвиком в i-ую позицию число (c - s[i])Pi.Существует более быстрое решение, без хешей и структур данных, оно будет опубликовано немного позже.196E - Открытие порталовСперва заметим, что если порталы расположены во всех вершинах графа, то ответ — сумма длин ребер в минимальном остовном дереве, которое можно найти алгоритмом Краскала. Это довольно очевидно.Однако порталы расположены не во всех вершинах. Попробуем это исправить.Сделаем небольшой предпросчет: запустим алгоритм Дейкстры одновременно из всех порталов. Таким образом можно посчитать 2 массива: d[i] — расстояние от вершины i до ближайшего портала, и p[i] — ближайший к вершине i портал.Теперь рассмотрим выполнение алгоритма Краскала на графе, состоящем только из порталов. На первой итерации этот алгоритм выберет ребро с минимальным весом среди всех ребер, соединяющем порталы. Только в исходном графе это могут быть не только ребра, но и пути.Пусть такой кратчайший путь — из портала x в портал y. Заметим, что можно найти путь не длиннее, такой, что p[i] на нем будет меняться ровно один раз. Действительно, p[x] = x, p[y] = y, значит, на кратчайшем пути хотя бы раз меняется значение p[i]. Пусть оно меняется на ребре , причем p[i] = x. Поскольку путь от j до p[j] — кратчайший путь от j до портала, путь не длиннее пути из x в y.Тогда, т.к. p[i] = x, p[j] = y, можно рассчитать длину этого пути: она равна d[i] + w(i, j) + d[j] (w(i, j) — вес ребра (i, j)). Алгоритм Краскала прибавит эту величину к ответу и объединит порталы x и y. При этом объединятся поддеревья ближайших к ним вершин.А теперь видим, что ничего не изменилось, и следующее по весу ребро можно найти точно таким же способом — . Если это ребро снова лежит между вершинами x и y, то DSU не даст посчитать это ребро, иначе это ребро соединяет другую пару порталов и войдет в ответ.Как это считать. Из определения ребер в новом графе нетрудно понять, что их столько же, сколько и в исходном: каждому ребру (i, j) веса w(i, j) в старом графе соответствует ребро (p[i], p[j]) веса d[i] + w(i, j) + d[j] в новом графе. Поэтому построим новый граф и запустим на нем алгоритм Краскала — он посчитает вес минимального остовного дерева в графе, где вершины — порталы.Осталось заметить, что если в стартовой вершине есть портал, то мы нашли ответ, а если нет — то надо сначала дойти до ближайшего портала, чтобы можно было начать считать миностов. Для этого можно просто в конце прибавить к ответу число d[1].",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 197\\s*A"
          },
          "content_length": 8436
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #124 - Codeforces - Code 1",
          "code": "#.#\n...\n###\n#S#\n#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 2",
          "code": "#.#\n...\n###\n#S#\n#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 3",
          "code": "7 9\n#.#.#.###\n#.#.#...#\n#.#.###S#\n#.#...#.#\n#.###.#.#\n#...#.#.#\n#.#.#.#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 4",
          "code": "7 9\n#.#.#.###\n#.#.#...#\n#.#.###S#\n#.#...#.#\n#.###.#.#\n#...#.#.#\n#.#.#.#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 5",
          "code": "5 9\n###.#.#.#\n#...#.#.#\n#S###.#.#\n#.#...#.#\n#.#.###.#\n#.#.#...#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 6",
          "code": "5 9\n###.#.#.#\n#...#.#.#\n#S###.#.#\n#.#...#.#\n#.#.###.#\n#.#.#...#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 7",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 8",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 9",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 10",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 11",
          "code": "(atan2(10^9, 10^9—1) == atan2(10^9+1, 10^9)) == true",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 12",
          "code": "(atan2(10^9, 10^9—1) == atan2(10^9+1, 10^9)) == false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 13",
          "code": "4\n\n1 2\n1 3\n3 4\n\n5 5\n0 0\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 14",
          "code": "4\n\n1 2\n1 3\n3 4\n\n5 5\n0 0\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 15",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 16",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 1",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 2",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 3",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 4",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 1",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 2",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 3",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 4",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 100, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 100, \"b\");\n    inf.readSpace();\n    int r = inf.readInt(1, 100, \"r\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 100, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 100, \"b\");\n    inf.readSpace();\n    int r = inf.readInt(1, 100, \"r\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 100, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 100, \"b\");\n    inf.readSpace();\n    int r = inf.readInt(1, 100, \"r\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int r = opt<int>(\"r\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    \n    int aa, bb, rr;\n\n    if (type == \"min\") {\n        /* Minimal values for a, b, r */\n        aa = 1;\n        bb = 1;\n        rr = 1;\n    } else if (type == \"max\") {\n        /* Maximal values for a, b, r */\n        aa = 100;\n        bb = 100;\n        rr = 100;\n    } else if (type == \"zero_plates\") {\n        /* No plates can fit on the table */\n        rr = rnd.next(1, 50);\n        aa = rnd.next(1, 2 * rr - 1);\n        bb = rnd.next(1, 2 * rr - 1);\n    } else if (type == \"one_plate\") {\n        /* Only one plate can fit on the table */\n        rr = rnd.next(1, 50);\n        aa = 2 * rr;\n        bb = 2 * rr;\n        while (aa > 100 || bb > 100) {\n            rr = rnd.next(1, 50);\n            aa = 2 * rr;\n            bb = 2 * rr;\n        }\n    } else if (type == \"tight_fit\") {\n        /* Plates fit tightly in one dimension */\n        rr = rnd.next(1, 20);\n        int num_a = rnd.next(1, 100 / (2 * rr));\n        aa = num_a * 2 * rr;\n        if (aa > 100) aa = 100;\n        bb = rnd.next(1, 2 * rr - 1);\n    } else if (type == \"odd_win\") {\n        /* The number of plates that fit is odd */\n        rr = rnd.next(1, 20);\n        int max_num = 100 / (2 * rr);\n        int num_a = rnd.next(1, max_num);\n        int num_b = rnd.next(1, max_num);\n        while ((num_a * num_b) % 2 != 1) {\n            num_a = rnd.next(1, max_num);\n            num_b = rnd.next(1, max_num);\n        }\n        aa = num_a * 2 * rr;\n        bb = num_b * 2 * rr;\n    } else if (type == \"even_win\") {\n        /* The number of plates that fit is even */\n        rr = rnd.next(1, 20);\n        int max_num = 100 / (2 * rr);\n        int num_a = rnd.next(1, max_num);\n        int num_b = rnd.next(1, max_num);\n        while ((num_a * num_b) % 2 != 0) {\n            num_a = rnd.next(1, max_num);\n            num_b = rnd.next(1, max_num);\n        }\n        aa = num_a * 2 * rr;\n        bb = num_b * 2 * rr;\n    } else if (type == \"random\") {\n        /* Random values for a, b, r */\n        aa = rnd.next(1, 100);\n        bb = rnd.next(1, 100);\n        rr = rnd.next(1, 100);\n    } else if (type == \"small\") {\n        /* Small values of a, b, r */\n        aa = rnd.next(1, 10);\n        bb = rnd.next(1, 10);\n        rr = rnd.next(1, 5);\n    } else if (type == \"large\") {\n        /* Large values of a, b, r */\n        aa = rnd.next(90, 100);\n        bb = rnd.next(90, 100);\n        rr = rnd.next(40, 50);\n    } else if (type == \"thin_table\") {\n        /* Table with one small dimension */\n        rr = rnd.next(1, 50);\n        aa = rnd.next(1, 100);\n        bb = rnd.next(1, 2 * rr - 1);\n    } else {\n        /* If type not recognized, generate random values */\n        aa = rnd.next(1, 100);\n        bb = rnd.next(1, 100);\n        rr = rnd.next(1, 100);\n    }\n\n    /* Override with provided -a, -b, -r if given */\n    if (a != -1) aa = a;\n    if (b != -1) bb = b;\n    if (r != -1) rr = r;\n\n    /* Ensure constraints are satisfied */\n    aa = max(1, min(aa, 100));\n    bb = max(1, min(bb, 100));\n    rr = max(1, min(rr, 100));\n\n    /* Output the test case */\n    printf(\"%d %d %d\\n\", aa, bb, rr);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int r = opt<int>(\"r\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    \n    int aa, bb, rr;\n\n    if (type == \"min\") {\n        /* Minimal values for a, b, r */\n        aa = 1;\n        bb = 1;\n        rr = 1;\n    } else if (type == \"max\") {\n        /* Maximal values for a, b, r */\n        aa = 100;\n        bb = 100;\n        rr = 100;\n    } else if (type == \"zero_plates\") {\n        /* No plates can fit on the table */\n        rr = rnd.next(1, 50);\n        aa = rnd.next(1, 2 * rr - 1);\n        bb = rnd.next(1, 2 * rr - 1);\n    } else if (type == \"one_plate\") {\n        /* Only one plate can fit on the table */\n        rr = rnd.next(1, 50);\n        aa = 2 * rr;\n        bb = 2 * rr;\n        while (aa > 100 || bb > 100) {\n            rr = rnd.next(1, 50);\n            aa = 2 * rr;\n            bb = 2 * rr;\n        }\n    } else if (type == \"tight_fit\") {\n        /* Plates fit tightly in one dimension */\n        rr = rnd.next(1, 20);\n        int num_a = rnd.next(1, 100 / (2 * rr));\n        aa = num_a * 2 * rr;\n        if (aa > 100) aa = 100;\n        bb = rnd.next(1, 2 * rr - 1);\n    } else if (type == \"odd_win\") {\n        /* The number of plates that fit is odd */\n        rr = rnd.next(1, 20);\n        int max_num = 100 / (2 * rr);\n        int num_a = rnd.next(1, max_num);\n        int num_b = rnd.next(1, max_num);\n        while ((num_a * num_b) % 2 != 1) {\n            num_a = rnd.next(1, max_num);\n            num_b = rnd.next(1, max_num);\n        }\n        aa = num_a * 2 * rr;\n        bb = num_b * 2 * rr;\n    } else if (type == \"even_win\") {\n        /* The number of plates that fit is even */\n        rr = rnd.next(1, 20);\n        int max_num = 100 / (2 * rr);\n        int num_a = rnd.next(1, max_num);\n        int num_b = rnd.next(1, max_num);\n        while ((num_a * num_b) % 2 != 0) {\n            num_a = rnd.next(1, max_num);\n            num_b = rnd.next(1, max_num);\n        }\n        aa = num_a * 2 * rr;\n        bb = num_b * 2 * rr;\n    } else if (type == \"random\") {\n        /* Random values for a, b, r */\n        aa = rnd.next(1, 100);\n        bb = rnd.next(1, 100);\n        rr = rnd.next(1, 100);\n    } else if (type == \"small\") {\n        /* Small values of a, b, r */\n        aa = rnd.next(1, 10);\n        bb = rnd.next(1, 10);\n        rr = rnd.next(1, 5);\n    } else if (type == \"large\") {\n        /* Large values of a, b, r */\n        aa = rnd.next(90, 100);\n        bb = rnd.next(90, 100);\n        rr = rnd.next(40, 50);\n    } else if (type == \"thin_table\") {\n        /* Table with one small dimension */\n        rr = rnd.next(1, 50);\n        aa = rnd.next(1, 100);\n        bb = rnd.next(1, 2 * rr - 1);\n    } else {\n        /* If type not recognized, generate random values */\n        aa = rnd.next(1, 100);\n        bb = rnd.next(1, 100);\n        rr = rnd.next(1, 100);\n    }\n\n    /* Override with provided -a, -b, -r if given */\n    if (a != -1) aa = a;\n    if (b != -1) bb = b;\n    if (r != -1) rr = r;\n\n    /* Ensure constraints are satisfied */\n    aa = max(1, min(aa, 100));\n    bb = max(1, min(bb, 100));\n    rr = max(1, min(rr, 100));\n\n    /* Output the test case */\n    printf(\"%d %d %d\\n\", aa, bb, rr);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type zero_plates\n./gen -type zero_plates\n./gen -type zero_plates\n./gen -type one_plate\n./gen -type one_plate\n./gen -type tight_fit\n./gen -type tight_fit\n./gen -type odd_win\n./gen -type odd_win\n./gen -type even_win\n./gen -type even_win\n./gen -type random\n./gen -type random\n./gen -type small\n./gen -type small\n./gen -type large\n./gen -type large\n./gen -type thin_table\n./gen -type thin_table\n./gen -a 5 -b 5 -r 2\n./gen -a 6 -b 7 -r 4\n./gen -a 10 -b 10 -r 5\n./gen -a 5 -b 100 -r 10\n./gen -a 100 -b 1 -r 1\n./gen -a 100 -b 1 -r 50\n./gen -a 1 -b 100 -r 50\n./gen -a 100 -b 100 -r 50\n./gen -a 99 -b 99 -r 49\n./gen -a 98 -b 98 -r 49\n./gen -type zero_plates\n./gen -type one_plate\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:12.182857",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "197/B",
      "title": "B. Limit",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (0 ≤ n, m ≤ 100) — degrees of polynomials P(x) and Q(x) correspondingly.The second line contains n + 1 space-separated integers — the factors of polynomial P(x): a0, a1, ..., an - 1, an ( - 100 ≤ ai ≤ 100, a0 ≠ 0).The third line contains m + 1 space-separated integers — the factors of polynomial Q(x): b0, b1, ..., bm - 1, bm ( - 100 ≤ bi ≤ 100, b0 ≠ 0).",
      "output_spec": "OutputIf the limit equals  + ∞, print \"Infinity\" (without quotes). If the limit equals  - ∞, print \"-Infinity\" (without the quotes).If the value of the limit equals zero, print \"0/1\" (without the quotes).Otherwise, print an irreducible fraction — the value of limit , in the format \"p/q\" (without the quotes), where p is the — numerator, q (q > 0) is the denominator of the fraction.",
      "sample_tests": "ExamplesInputCopy2 11 1 12 5OutputCopyInfinityInputCopy1 0-1 32OutputCopy-InfinityInputCopy0 111 0OutputCopy0/1InputCopy2 22 1 64 5 -7OutputCopy1/2InputCopy1 19 0-5 2OutputCopy-9/5",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (0 ≤ n, m ≤ 100) — degrees of polynomials P(x) and Q(x) correspondingly.The second line contains n + 1 space-separated integers — the factors of polynomial P(x): a0, a1, ..., an - 1, an ( - 100 ≤ ai ≤ 100, a0 ≠ 0).The third line contains m + 1 space-separated integers — the factors of polynomial Q(x): b0, b1, ..., bm - 1, bm ( - 100 ≤ bi ≤ 100, b0 ≠ 0).\n\nOutputIf the limit equals  + ∞, print \"Infinity\" (without quotes). If the limit equals  - ∞, print \"-Infinity\" (without the quotes).If the value of the limit equals zero, print \"0/1\" (without the quotes).Otherwise, print an irreducible fraction — the value of limit , in the format \"p/q\" (without the quotes), where p is the — numerator, q (q > 0) is the denominator of the fraction.\n\nInputCopy2 11 1 12 5OutputCopyInfinityInputCopy1 0-1 32OutputCopy-InfinityInputCopy0 111 0OutputCopy0/1InputCopy2 22 1 64 5 -7OutputCopy1/2InputCopy1 19 0-5 2OutputCopy-9/5\n\nInputCopy2 11 1 12 5\n\nOutputCopyInfinity\n\nInputCopy1 0-1 32\n\nOutputCopy-Infinity\n\nInputCopy0 111 0\n\nOutputCopy0/1\n\nInputCopy2 22 1 64 5 -7\n\nOutputCopy1/2\n\nInputCopy1 19 0-5 2\n\nOutputCopy-9/5\n\nNoteLet's consider all samples:           You can learn more about the definition and properties of limits if you follow the link: http://en.wikipedia.org/wiki/Limit_of_a_function",
      "solutions": [
        {
          "title": "Codeforces Round #124 - Codeforces",
          "content": "Hi all!Today, June 12, when Russia celebrates Day of itself, Euro 2012 second round starts and I_love_natalia has a birthday, we present you Codeforces Round #124.Contest was prepared by team Samara SAU Teddy Bears (craus, dalex, Hohol) and I_love_natalia. Also thanks to Alex_KPR and Codeforces team (Gerald, Delinur, MikeMirzayanov). We think that contest is very easy, and your task will be prove of refute this assertion :)Scoring system is dynamic (Learn more about dynamic problem scoring). Authors think that problems are sorted by difficulty in non-descending order.Accepted solutions and successful hacks to you!UPD. Contest is over, congratulations to the winners!Div-1 (full results): tourist — the only one who solved all problems! RAVEman aropan Div-2 (full results): bmerry littlefriend gstsclq UPD 2. Tutorial is available.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 838
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces",
          "content": "197A - Plate GameIf first player can't make first move (table is too small and plate doesn't fit it, i.e. 2r > min(a, b)), second player wins. Else first player wins. Winning strategy for first player: place first plate to the center of table. After that he symmetrically reflects moves of second player with respect to center of table. If second player has move, first player has symmetrical move, too. If not, first player won.197B - LimitFrom math lessons we know, that only higher degrees of polinomials matter in this problem. If denominator degree is larger than numenator degree, answer is \"0/1\". If numenator degree is larger, answer is infinity. But what is sign of this infinity? To get it consider signs of highest degree factors of polinomials. If they are same, answer is positive infinity, else — negative infinity. If degrees of numenator and denominator are equal, answer is . To get irreducible fraction, you should divide this numbers by gcd(a0, b0). And don't forget that denominator of answer must be positive. 196A - Lexicographically Maximum SubsequenceSolution is greedy. First, write all 'z' letters (if there is any) — answer must contain them all for sure. Now it's time for 'y' letters. We can use only those of them which are on the right of last used 'z' letter. Then write 'x' letters — they must be on the right of the last used 'y' and 'z' letters. And so on.196B - Infinite MazeAnswer is \"Yes\" iff there are two distinct, reachable from start position cells, which correspond to same cell in initial labyrinth. Proof: If these cells exist, move to first of them, and infinitely repeat moves leading from first to second. On the contrary, if infinite far path exist, on this path we obviously can find such cells.How to find out if they exist? Start DFS from initial cell. For each cell visited, let visit[x%n][y%m] = (x, y). Now, if DFS tries to go to cell (x, y), visit[x%n][y%m] contains something, and (x, y) ≠ visit[x%n][y%m], we found these cells: they are (x, y) and visit[x%n][y%m]. Notice that DFS will visit no more than nm + 1 cells (Dirichlet's principle). So the asymptotic is O(nm).196C - Paint TreeNo three points are in the same line, so the solution always exists.First, choose any one vertex as the root of tree. Find size of each subtree using dfs.Then, we can build the answer recursively.Put the root of tree to the most lower left point.Sort all other points by angle relative to this lower left point.Let us name the sizes of subtrees of the root as s1, s2, ..., sk.Run the algorithm recursively, giving first s1 points (in sorted order) for the first subtree of root, next s2 points for the second subtree and so on.Obviously, no two edges from different subtrees can intersect now.At each step of recursion we are to put the root of current subtree to the first point in sorted-by-angle order, and then sort other points by angle relative to it.So, no two subtrees will have any intersecting edges.The asymptotic of solution is .196D - The Next Good StringNotice, that only palindromes with length d and d + 1 matter. Any palindrome with greater length contains one of them. Let's call these palindromes bad.First, find leftmost position pos, in which we surely should increase value of symbol. If there are no bad subpalindromes, pos = |s| - 1, else pos is leftmost position amongst all ends of bad palindromes.Increase s[pos]. Increase it more, while s[pos] is end of bad subpalindrome. If you try increase 'z' symbol, you should proceed to increasing previous symbol. If this way you reached situation when you need to increase first symbol, and it is 'z', answer is \"Impossible\".Now, let pos be position of leftmost changed symbol. We know, that prefix s[0..pos] doesn't contain bad palindromes. Now we can greedily fill suffix s[pos + 1..length(s) - 1]: go over positions i in ascending order, assign s[i] = 'a', and increase it, while s[i] is end of bad palindrome. Obviously, any of suffix symbols will be 'a', 'b' or 'c'.So we got algorithm, which requires fast implementation of next operations — assigning single symbol, and query: is given substring palindrome? You can perform this operations using hashes and Fenwick tree.Let's learn, how to get hash of substring in dynamically changing string. If we can it, we will keep string s and it's reversed copy. For query of second type we just need to compare hashes of substring in s and hash of corresponding substring in reversed copy.Let Fenwick tree store values h[i] = s[i]Pi, where P is the prime number used for hashing. Then hash of substring s[L..R] equals to (h[L] + h[L + 1] + ...h[R])P - L. For assigning s[i] = c, add value (c - s[i])Pi to h[i]. Both these operations Fenwick tree does in .Also we have faster solution without hashes and data structures, it will be published soon.196E - Opening PortalsFirst of all, we can note that if each graph vertex is portal, the answer will be a sum of all edges' weights in MST (minimal spanning tree). We can find MST by using Kruskal's algo.In this problem, not an every vertex is portal. Let's fix this.Start with a precalculation. Run Dijkstra's algo from all the portals, simultaneously. We will get d[i] — a distance between vertex i and p[i] — the nearest portal to vertex i.Let's trace Kruskal's algo on a graph of portals. On the first iteration, it will choose the edge with the minimal cost, i.e. a shortest path between all the portals in the original graph.Let the path leads from portal x to portal y. Note that there exists a path with the same length such as p[i] changes only once through it. Indeed, p[x] = x, p[y] = y, i.e. p[i] changed on the path. If it happens on edge , p[i] = x, a path will not be longer than the path from x to y.As p[i] = x and p[i] = y, we can see that the length of this path will be d[i] + w(i, j) + d[j], where w(i, j) is the weight of edge (i, j). Kruskal's algo will add this value to the answer and merge portals x and y. The shortest-path trees of vertexes x and y will also be merged.Note, that almost nothing changed. The next edge for Kruskal's algo can be find in a similar way — . If this edge connects x and y again, DSU makes us not to count this edge, otherwise this edge connects a different pair of edges and will be counted in an answer.We can easily implement this. Just create a new graph of portals, with an edge (p[i], p[j]) of weight d[i] + w(i, j) + d[j] for every edge (i, j) of weight w(i, j) from original graph and run Kruskal's algo.Finally, note that if the starting vertex is not a portal, we shall add d[1] to the answer.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 197\\s*B"
          },
          "content_length": 6568
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces",
          "content": "197A - Plate GameIf first player can't make first move (table is too small and plate doesn't fit it, i.e. 2r > min(a, b)), second player wins. Else first player wins. Winning strategy for first player: place first plate to the center of table. After that he symmetrically reflects moves of second player with respect to center of table. If second player has move, first player has symmetrical move, too. If not, first player won.197B - LimitFrom math lessons we know, that only higher degrees of polinomials matter in this problem. If denominator degree is larger than numenator degree, answer is \"0/1\". If numenator degree is larger, answer is infinity. But what is sign of this infinity? To get it consider signs of highest degree factors of polinomials. If they are same, answer is positive infinity, else — negative infinity. If degrees of numenator and denominator are equal, answer is . To get irreducible fraction, you should divide this numbers by gcd(a0, b0). And don't forget that denominator of answer must be positive. 196A - Lexicographically Maximum SubsequenceSolution is greedy. First, write all 'z' letters (if there is any) — answer must contain them all for sure. Now it's time for 'y' letters. We can use only those of them which are on the right of last used 'z' letter. Then write 'x' letters — they must be on the right of the last used 'y' and 'z' letters. And so on.196B - Infinite MazeAnswer is \"Yes\" iff there are two distinct, reachable from start position cells, which correspond to same cell in initial labyrinth. Proof: If these cells exist, move to first of them, and infinitely repeat moves leading from first to second. On the contrary, if infinite far path exist, on this path we obviously can find such cells.How to find out if they exist? Start DFS from initial cell. For each cell visited, let visit[x%n][y%m] = (x, y). Now, if DFS tries to go to cell (x, y), visit[x%n][y%m] contains something, and (x, y) ≠ visit[x%n][y%m], we found these cells: they are (x, y) and visit[x%n][y%m]. Notice that DFS will visit no more than nm + 1 cells (Dirichlet's principle). So the asymptotic is O(nm).196C - Paint TreeNo three points are in the same line, so the solution always exists.First, choose any one vertex as the root of tree. Find size of each subtree using dfs.Then, we can build the answer recursively.Put the root of tree to the most lower left point.Sort all other points by angle relative to this lower left point.Let us name the sizes of subtrees of the root as s1, s2, ..., sk.Run the algorithm recursively, giving first s1 points (in sorted order) for the first subtree of root, next s2 points for the second subtree and so on.Obviously, no two edges from different subtrees can intersect now.At each step of recursion we are to put the root of current subtree to the first point in sorted-by-angle order, and then sort other points by angle relative to it.So, no two subtrees will have any intersecting edges.The asymptotic of solution is .196D - The Next Good StringNotice, that only palindromes with length d and d + 1 matter. Any palindrome with greater length contains one of them. Let's call these palindromes bad.First, find leftmost position pos, in which we surely should increase value of symbol. If there are no bad subpalindromes, pos = |s| - 1, else pos is leftmost position amongst all ends of bad palindromes.Increase s[pos]. Increase it more, while s[pos] is end of bad subpalindrome. If you try increase 'z' symbol, you should proceed to increasing previous symbol. If this way you reached situation when you need to increase first symbol, and it is 'z', answer is \"Impossible\".Now, let pos be position of leftmost changed symbol. We know, that prefix s[0..pos] doesn't contain bad palindromes. Now we can greedily fill suffix s[pos + 1..length(s) - 1]: go over positions i in ascending order, assign s[i] = 'a', and increase it, while s[i] is end of bad palindrome. Obviously, any of suffix symbols will be 'a', 'b' or 'c'.So we got algorithm, which requires fast implementation of next operations — assigning single symbol, and query: is given substring palindrome? You can perform this operations using hashes and Fenwick tree.Let's learn, how to get hash of substring in dynamically changing string. If we can it, we will keep string s and it's reversed copy. For query of second type we just need to compare hashes of substring in s and hash of corresponding substring in reversed copy.Let Fenwick tree store values h[i] = s[i]Pi, where P is the prime number used for hashing. Then hash of substring s[L..R] equals to (h[L] + h[L + 1] + ...h[R])P - L. For assigning s[i] = c, add value (c - s[i])Pi to h[i]. Both these operations Fenwick tree does in .Also we have faster solution without hashes and data structures, it will be published soon.196E - Opening PortalsFirst of all, we can note that if each graph vertex is portal, the answer will be a sum of all edges' weights in MST (minimal spanning tree). We can find MST by using Kruskal's algo.In this problem, not an every vertex is portal. Let's fix this.Start with a precalculation. Run Dijkstra's algo from all the portals, simultaneously. We will get d[i] — a distance between vertex i and p[i] — the nearest portal to vertex i.Let's trace Kruskal's algo on a graph of portals. On the first iteration, it will choose the edge with the minimal cost, i.e. a shortest path between all the portals in the original graph.Let the path leads from portal x to portal y. Note that there exists a path with the same length such as p[i] changes only once through it. Indeed, p[x] = x, p[y] = y, i.e. p[i] changed on the path. If it happens on edge , p[i] = x, a path will not be longer than the path from x to y.As p[i] = x and p[i] = y, we can see that the length of this path will be d[i] + w(i, j) + d[j], where w(i, j) is the weight of edge (i, j). Kruskal's algo will add this value to the answer and merge portals x and y. The shortest-path trees of vertexes x and y will also be merged.Note, that almost nothing changed. The next edge for Kruskal's algo can be find in a similar way — . If this edge connects x and y again, DSU makes us not to count this edge, otherwise this edge connects a different pair of edges and will be counted in an answer.We can easily implement this. Just create a new graph of portals, with an edge (p[i], p[j]) of weight d[i] + w(i, j) + d[j] for every edge (i, j) of weight w(i, j) from original graph and run Kruskal's algo.Finally, note that if the starting vertex is not a portal, we shall add d[1] to the answer.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 197\\s*B"
          },
          "content_length": 6568
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #124 - Codeforces - Code 1",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 2",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 3",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 4",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 5",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 6",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 1",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 2",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 1",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 2",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(0, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n + 1, -100, 100);\n    inf.readEoln();\n    ensuref(a[0] != 0, \"a[0] must not be zero\");\n\n    vector<int> b = inf.readInts(m + 1, -100, 100);\n    inf.readEoln();\n    ensuref(b[0] != 0, \"b[0] must not be zero\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(0, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n + 1, -100, 100);\n    inf.readEoln();\n    ensuref(a[0] != 0, \"a[0] must not be zero\");\n\n    vector<int> b = inf.readInts(m + 1, -100, 100);\n    inf.readEoln();\n    ensuref(b[0] != 0, \"b[0] must not be zero\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(0, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n + 1, -100, 100);\n    inf.readEoln();\n    ensuref(a[0] != 0, \"a[0] must not be zero\");\n\n    vector<int> b = inf.readInts(m + 1, -100, 100);\n    inf.readEoln();\n    ensuref(b[0] != 0, \"b[0] must not be zero\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse input arguments\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\");\n\n    // Determine n and m based on the type if not provided\n    if (type == \"random\") {\n        if (n == -1) n = rnd.next(0, 100);\n        if (m == -1) m = rnd.next(0, 100);\n    } else if (type == \"n_greater_m_pos_leading\" || type == \"n_greater_m_neg_leading\" || type == \"n_greater_m_mixed_leading\") {\n        if (n == -1) n = rnd.next(1, 100);\n        if (m == -1) m = rnd.next(0, n - 1);\n        else ensure(n > m);\n    } else if (type == \"n_eq_m_pos_leading\" || type == \"n_eq_m_neg_leading\" || type == \"n_eq_m_mixed_leading\") {\n        if (n == -1) n = rnd.next(0, 100);\n        if (m == -1) m = n;\n        else ensure(n == m);\n    } else if (type == \"n_less_m\") {\n        if (n == -1) n = rnd.next(0, 99);\n        if (m == -1) m = rnd.next(n + 1, 100);\n        else ensure(n < m);\n    } else if (type == \"n_zero\") {\n        n = 0;\n        if (m == -1) m = rnd.next(1, 100);\n    } else if (type == \"m_zero\") {\n        m = 0;\n        if (n == -1) n = rnd.next(1, 100);\n    } else if (type == \"both_zero\") {\n        n = 0;\n        m = 0;\n    } else {\n        ensure(false); // Unknown type\n    }\n\n    // Create coefficient vectors\n    vector<int> a(n + 1);\n    vector<int> b(m + 1);\n\n    // Generate leading coefficients based on type\n    if (type == \"n_greater_m_pos_leading\" || type == \"n_eq_m_pos_leading\") {\n        a[0] = rnd.next(1, 100);\n        b[0] = rnd.next(1, 100);\n    } else if (type == \"n_greater_m_neg_leading\" || type == \"n_eq_m_neg_leading\") {\n        a[0] = -rnd.next(1, 100);\n        b[0] = -rnd.next(1, 100);\n    } else if (type == \"n_greater_m_mixed_leading\" || type == \"n_eq_m_mixed_leading\") {\n        a[0] = rnd.next(1, 100);\n        b[0] = -rnd.next(1, 100);\n    } else {\n        a[0] = rnd.next(-100, 100);\n        while (a[0] == 0)\n            a[0] = rnd.next(-100, 100);\n        b[0] = rnd.next(-100, 100);\n        while (b[0] == 0)\n            b[0] = rnd.next(-100, 100);\n    }\n\n    // Generate the rest of the coefficients\n    for (int i = 1; i <= n; ++i) {\n        a[i] = rnd.next(-100, 100);\n    }\n    for (int i = 1; i <= m; ++i) {\n        b[i] = rnd.next(-100, 100);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output coefficients of polynomial P(x)\n    for (int i = 0; i <= n; ++i) {\n        printf(\"%d%c\", a[i], i == n ? '\\n' : ' ');\n    }\n\n    // Output coefficients of polynomial Q(x)\n    for (int i = 0; i <= m; ++i) {\n        printf(\"%d%c\", b[i], i == m ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse input arguments\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\");\n\n    // Determine n and m based on the type if not provided\n    if (type == \"random\") {\n        if (n == -1) n = rnd.next(0, 100);\n        if (m == -1) m = rnd.next(0, 100);\n    } else if (type == \"n_greater_m_pos_leading\" || type == \"n_greater_m_neg_leading\" || type == \"n_greater_m_mixed_leading\") {\n        if (n == -1) n = rnd.next(1, 100);\n        if (m == -1) m = rnd.next(0, n - 1);\n        else ensure(n > m);\n    } else if (type == \"n_eq_m_pos_leading\" || type == \"n_eq_m_neg_leading\" || type == \"n_eq_m_mixed_leading\") {\n        if (n == -1) n = rnd.next(0, 100);\n        if (m == -1) m = n;\n        else ensure(n == m);\n    } else if (type == \"n_less_m\") {\n        if (n == -1) n = rnd.next(0, 99);\n        if (m == -1) m = rnd.next(n + 1, 100);\n        else ensure(n < m);\n    } else if (type == \"n_zero\") {\n        n = 0;\n        if (m == -1) m = rnd.next(1, 100);\n    } else if (type == \"m_zero\") {\n        m = 0;\n        if (n == -1) n = rnd.next(1, 100);\n    } else if (type == \"both_zero\") {\n        n = 0;\n        m = 0;\n    } else {\n        ensure(false); // Unknown type\n    }\n\n    // Create coefficient vectors\n    vector<int> a(n + 1);\n    vector<int> b(m + 1);\n\n    // Generate leading coefficients based on type\n    if (type == \"n_greater_m_pos_leading\" || type == \"n_eq_m_pos_leading\") {\n        a[0] = rnd.next(1, 100);\n        b[0] = rnd.next(1, 100);\n    } else if (type == \"n_greater_m_neg_leading\" || type == \"n_eq_m_neg_leading\") {\n        a[0] = -rnd.next(1, 100);\n        b[0] = -rnd.next(1, 100);\n    } else if (type == \"n_greater_m_mixed_leading\" || type == \"n_eq_m_mixed_leading\") {\n        a[0] = rnd.next(1, 100);\n        b[0] = -rnd.next(1, 100);\n    } else {\n        a[0] = rnd.next(-100, 100);\n        while (a[0] == 0)\n            a[0] = rnd.next(-100, 100);\n        b[0] = rnd.next(-100, 100);\n        while (b[0] == 0)\n            b[0] = rnd.next(-100, 100);\n    }\n\n    // Generate the rest of the coefficients\n    for (int i = 1; i <= n; ++i) {\n        a[i] = rnd.next(-100, 100);\n    }\n    for (int i = 1; i <= m; ++i) {\n        b[i] = rnd.next(-100, 100);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output coefficients of polynomial P(x)\n    for (int i = 0; i <= n; ++i) {\n        printf(\"%d%c\", a[i], i == n ? '\\n' : ' ');\n    }\n\n    // Output coefficients of polynomial Q(x)\n    for (int i = 0; i <= m; ++i) {\n        printf(\"%d%c\", b[i], i == m ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type n_greater_m_pos_leading -n 100 -m 99\n./gen -type n_greater_m_pos_leading -n 100\n./gen -type n_greater_m_pos_leading\n\n./gen -type n_greater_m_neg_leading -n 100 -m 50\n./gen -type n_greater_m_neg_leading\n\n./gen -type n_greater_m_mixed_leading -n 50 -m 10\n\n./gen -type n_eq_m_pos_leading -n 100\n./gen -type n_eq_m_neg_leading -n 100\n./gen -type n_eq_m_mixed_leading -n 100\n\n./gen -type n_less_m -n 50 -m 100\n./gen -type n_less_m\n\n./gen -type n_zero\n./gen -type m_zero\n\n./gen -type both_zero\n\n./gen -type random\n\n./gen -type random\n./gen -type random\n\n# Edge cases\n./gen -type n_greater_m_pos_leading -n 1 -m 0\n./gen -type n_greater_m_neg_leading -n 100 -m 0\n./gen -type n_eq_m_mixed_leading -n 0\n./gen -type n_less_m -n 0 -m 1\n./gen -type m_zero -n 100\n./gen -type n_zero -m 100\n\n# Large degrees\n./gen -type n_eq_m_pos_leading -n 100 -m 100\n./gen -type n_less_m -n 0 -m 100\n./gen -type n_zero\n./gen -type m_zero\n\n# Random tests\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:13.943655",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "197/C",
      "title": "C. Лексикографически максимальная подпоследовательность",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записана непустая строка s, состоящая только из строчных латинских букв и имеющая длину не более 105.",
      "output_spec": "Выходные данныеВыведите лексикографически максимальную подпоследовательность строки s.",
      "sample_tests": "ПримерыВходные данныеСкопироватьababbaВыходные данныеСкопироватьbbbaВходные данныеСкопироватьabbcbccacbbcbaabaВыходные данныеСкопироватьcccccbba",
      "description": "C. Лексикографически максимальная подпоследовательность\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке записана непустая строка s, состоящая только из строчных латинских букв и имеющая длину не более 105.\n\nВходные данные\n\nВыходные данныеВыведите лексикографически максимальную подпоследовательность строки s.\n\nВыходные данные\n\nВходные данныеСкопироватьababbaВыходные данныеСкопироватьbbbaВходные данныеСкопироватьabbcbccacbbcbaabaВыходные данныеСкопироватьcccccbba\n\nВходные данныеСкопироватьababba\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьbbba\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьabbcbccacbbcbaaba\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьcccccbba\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим примеры и покажем, как именно выглядят искомые подпоследовательности (они выделены прописными буквами полужирным шрифтом).Первый пример: aBaBBAВторой пример: abbCbCCaCbbCBaaBA",
      "solutions": [
        {
          "title": "Codeforces Round #124 - Codeforces",
          "content": "Всем привет!Сегодня, 12 июня, в день, когда Россия отмечает день себя, на Евро-2012 стартуют матчи второго круга, а I_love_natalia празднует свой день рождения, мы представляем вам Codeforces Round #124.К подготовке контеста имеют отношение команда Samara SAU Teddy Bears (craus, dalex, Hohol) и I_love_natalia. Также спасибо Alex_KPR и команде Codeforces (Gerald, Delinur, MikeMirzayanov). Мы думаем, что контест очень легкий, а вам придется за 2 часа доказать или опровергнуть это утверждение :)Система начисления очков — динамическая (подробнее о динамической стоимости). Авторы считают, что задачи упорядочены по неубыванию сложности.Всем полных решений и успешных взломов!UPD. Контест закончился, поздравляем победителей!Div-1 (полные результаты): tourist — единственный, кто решил все задачи! RAVEman aropan Div-2 (полные результаты): bmerry littlefriend gstsclq UPD 2. Доступен разбор задач.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 898
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces",
          "content": "197A - Игра с тарелкамиЕсли первый игрок своим ходом не может поставить тарелку на стол (стол слишком маленький, и тарелка не помещается, т.е. 2r > min(a, b)), выигрывает второй игрок.Иначе выигрывает первый игрок. Выигрышная стратегия такова: первый игрок ставит свою первую тарелку в центр стола, а затем симметрично отражает ходы соперника относительно центра стола стола. Легко видеть, что если в этом случае второму игроку удастся совершить ход, первому это также удастся. А если не удастся, первый игрок победит, что ему и было нужно.197B - ПределРешение задачи — разбор случаев.Легко понять, что важны лишь степени многочленов и их коэффициенты при старшем члене, остальные числа в инпуте — для отвода глаз. Если степень знаменателя больше, ответ равен \"0/1\". Если степень числителя больше, ответ — бесконечность. Чтобы понять, какая именно, надо посмотреть на знаки при старших коэффициентах. Если знаки одинаковые, то положительная, иначе — отрицательная. Если степени числителя и знаменателя равны, ответ, как известно из курса математики, равен . Чтобы дробь была несократимой, надо a0 и b0 поделить на их gcd. Также надо быть внимательным, если один или оба из этих чисел отрицательные и не вывести \"1/-2\" вместо \"-1/2\". 196A - Лексикографически максимальная подпоследовательностьОчевидно, что сначала нам надо выписать все буквы 'z', если они есть — ответ от этого хуже точно не станет. Теперь множество доступных букв сократилось — мы не можем использовать те буквы, что находятся левее последней буквы 'z'. Поэтому выпишем все буквы 'y', что встречаются правее последней буквы 'z'. Множество доступных букв еще сократится, теперь это будут буквы, находящиеся правее самой правой из букв 'z' и 'y'. Продолжаем так, пока не выпишем все подходящие буквы.196B - Бесконечный лабиринтУтверждение: ответ будет положительным тогда и только тогда, когда в бесконечном лабиринте существуют две различные достижимые из старта клетки, соответствующие одной и той же клетке оригинального маленького лабиринта. Действительно, если бесконечно далеко уйти можно, по пути точно придется посетить такие клетки. А если такие клетки существуют, придем в одну из них, и бесконечно будем идти по траектории, переводящей из первой во вторую.Осталось проверить наличие таких клеток. Запустим поиск в глубину по бесконечному лабиринту из стартовой точки. Пусть он при посещении точки (x, y) сохраняет в visit[x%n][y%m] значение (x, y). Теперь если поиск пытается прийти в клетку (x, y) такую, что в visit[x%n][y%m] уже что-то есть, причем оно не равно (x, y), значит две требуемые клетки найдены — клетка (x, y) и та, что сохранена в visit[x%n][y%m]. Отметим, что этот поиск посетит не более nm + 1 клеток (принцип Дирихле). Асимптотика решения — O(nm).196C - Нарисуйте деревоТ.к. никакие три точки не лежат на одной прямой, решение всегда существует.Сначала подвесим дерево за какую-нибудь вершину и dfs-ом посчитаем размеры всех поддеревьев. Теперь будем рекурсивно строить ответ. Найдем самую левую нижнюю точку и поставим ей в соответствие корень дерева. Ничего плохого от этого не случится, ведь эта точка — крайняя в множестве. Отсортируем все остальные точки по углу относительно этой самой левой нижней точки. Теперь пусть размеры поддеревьев корня равны s1, s2, ..., sk. Запустим алгоритм рекурсивно, передав первому поддереву корня первые s1 точек (в уже отсортированном порядке), второму поддереву — следующие s2 точек после первых s1, ..., последнему поддереву — последние sk точек. Легко видеть, что ребра, принадлежащие разным поддеревьям, в этом случае не будут пересекаться. На каждом этапе рекурсии надо сопоставлять самую крайнюю из выбранных точек с корнем поддерева и сортировать все остальные точки относительно нее. Тогда никакие два поддерева не будут иметь попарно пересекающихся ребер. Асимптотика решения — .196D - Следующая хорошая строкаСразу заметим, что нас интересует только наличие подпалиндромов длины d и d + 1: любой подпалиндром большей длины будет содержать их, а если нет длины d и d + 1, нет и больших. Назовем их, для краткости, плохими.Сначала найдем самую левую позицию pos, в которой символ строки точно нужно увеличить. Если плохих подпалиндромов нет, это будет конец строки (так как нужно найти хорошую строку, строго большую данной), иначе это самая левая позиция среди всех концов плохих палиндромов.Увеличим s[pos]. Продолжим увеличивать, пока s[pos] является концом плохого палиндрома. Если пытаемся увеличить символ 'z', значит надо переходить к увеличению предыдущего символа. Если таким образом дошли до начала строки и увеличивать некуда, решения нет. Заметим, что при этом будет выполнено не более O(n) операций увеличения.Пусть теперь pos — позиция самого левого измененного символа. Мы знаем, что префикс s[0..pos] не содержит плохих палиндромов. Теперь суффикс s[pos + 1..n - 1] можно заполнить жадно, перебираем позицию i по возрастанию, полагаем s[i] = 'a', и увеличиваем s[i], пока он является концом плохого палиндрома. Несложно понять, что на роль любого символа суффикса подойдет один из символов 'a', 'b' или 'c' — так как каждой позиции могут \"помешать\" лишь два символа находящихся левее на d и d - 1 позиций.Таким образом, мы получили алгоритм, который требует быстрого выполнения двух операций: изменение одного символа и запрос, является ли данная подстрока палиндромом. Это можно делать с помощью хешей и дерева Фенвика.Научимся узнавать хеш подстроки в изменяющейся строке. Тогда просто будем поддерживать информацию о самой строке, и о ее развернутой копии. Для определения, является ли данная подстрока палиндромом, просто сравним ее хеш с хешем соответствующей подстроки в развернутой версии.Итак, пусть дерево Фенвика поддерживает величины h[i] = s[i]Pi, где P — простое число, используемое для хеширования. Тогда хеш подстроки s[L..R] равен (h[L] + h[L + 1] + ...h[R])P - L. (Разумеется, можно не домножать на P - L а просто при сравнении хешей домножать один из них на нужную степень) Если требуется изменить s[i] на c, прибавляем Фенвиком в i-ую позицию число (c - s[i])Pi.Существует более быстрое решение, без хешей и структур данных, оно будет опубликовано немного позже.196E - Открытие порталовСперва заметим, что если порталы расположены во всех вершинах графа, то ответ — сумма длин ребер в минимальном остовном дереве, которое можно найти алгоритмом Краскала. Это довольно очевидно.Однако порталы расположены не во всех вершинах. Попробуем это исправить.Сделаем небольшой предпросчет: запустим алгоритм Дейкстры одновременно из всех порталов. Таким образом можно посчитать 2 массива: d[i] — расстояние от вершины i до ближайшего портала, и p[i] — ближайший к вершине i портал.Теперь рассмотрим выполнение алгоритма Краскала на графе, состоящем только из порталов. На первой итерации этот алгоритм выберет ребро с минимальным весом среди всех ребер, соединяющем порталы. Только в исходном графе это могут быть не только ребра, но и пути.Пусть такой кратчайший путь — из портала x в портал y. Заметим, что можно найти путь не длиннее, такой, что p[i] на нем будет меняться ровно один раз. Действительно, p[x] = x, p[y] = y, значит, на кратчайшем пути хотя бы раз меняется значение p[i]. Пусть оно меняется на ребре , причем p[i] = x. Поскольку путь от j до p[j] — кратчайший путь от j до портала, путь не длиннее пути из x в y.Тогда, т.к. p[i] = x, p[j] = y, можно рассчитать длину этого пути: она равна d[i] + w(i, j) + d[j] (w(i, j) — вес ребра (i, j)). Алгоритм Краскала прибавит эту величину к ответу и объединит порталы x и y. При этом объединятся поддеревья ближайших к ним вершин.А теперь видим, что ничего не изменилось, и следующее по весу ребро можно найти точно таким же способом — . Если это ребро снова лежит между вершинами x и y, то DSU не даст посчитать это ребро, иначе это ребро соединяет другую пару порталов и войдет в ответ.Как это считать. Из определения ребер в новом графе нетрудно понять, что их столько же, сколько и в исходном: каждому ребру (i, j) веса w(i, j) в старом графе соответствует ребро (p[i], p[j]) веса d[i] + w(i, j) + d[j] в новом графе. Поэтому построим новый граф и запустим на нем алгоритм Краскала — он посчитает вес минимального остовного дерева в графе, где вершины — порталы.Осталось заметить, что если в стартовой вершине есть портал, то мы нашли ответ, а если нет — то надо сначала дойти до ближайшего портала, чтобы можно было начать считать миностов. Для этого можно просто в конце прибавить к ответу число d[1].",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 197 和字母"
          },
          "content_length": 8436
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces",
          "content": "197A - Игра с тарелкамиЕсли первый игрок своим ходом не может поставить тарелку на стол (стол слишком маленький, и тарелка не помещается, т.е. 2r > min(a, b)), выигрывает второй игрок.Иначе выигрывает первый игрок. Выигрышная стратегия такова: первый игрок ставит свою первую тарелку в центр стола, а затем симметрично отражает ходы соперника относительно центра стола стола. Легко видеть, что если в этом случае второму игроку удастся совершить ход, первому это также удастся. А если не удастся, первый игрок победит, что ему и было нужно.197B - ПределРешение задачи — разбор случаев.Легко понять, что важны лишь степени многочленов и их коэффициенты при старшем члене, остальные числа в инпуте — для отвода глаз. Если степень знаменателя больше, ответ равен \"0/1\". Если степень числителя больше, ответ — бесконечность. Чтобы понять, какая именно, надо посмотреть на знаки при старших коэффициентах. Если знаки одинаковые, то положительная, иначе — отрицательная. Если степени числителя и знаменателя равны, ответ, как известно из курса математики, равен . Чтобы дробь была несократимой, надо a0 и b0 поделить на их gcd. Также надо быть внимательным, если один или оба из этих чисел отрицательные и не вывести \"1/-2\" вместо \"-1/2\". 196A - Лексикографически максимальная подпоследовательностьОчевидно, что сначала нам надо выписать все буквы 'z', если они есть — ответ от этого хуже точно не станет. Теперь множество доступных букв сократилось — мы не можем использовать те буквы, что находятся левее последней буквы 'z'. Поэтому выпишем все буквы 'y', что встречаются правее последней буквы 'z'. Множество доступных букв еще сократится, теперь это будут буквы, находящиеся правее самой правой из букв 'z' и 'y'. Продолжаем так, пока не выпишем все подходящие буквы.196B - Бесконечный лабиринтУтверждение: ответ будет положительным тогда и только тогда, когда в бесконечном лабиринте существуют две различные достижимые из старта клетки, соответствующие одной и той же клетке оригинального маленького лабиринта. Действительно, если бесконечно далеко уйти можно, по пути точно придется посетить такие клетки. А если такие клетки существуют, придем в одну из них, и бесконечно будем идти по траектории, переводящей из первой во вторую.Осталось проверить наличие таких клеток. Запустим поиск в глубину по бесконечному лабиринту из стартовой точки. Пусть он при посещении точки (x, y) сохраняет в visit[x%n][y%m] значение (x, y). Теперь если поиск пытается прийти в клетку (x, y) такую, что в visit[x%n][y%m] уже что-то есть, причем оно не равно (x, y), значит две требуемые клетки найдены — клетка (x, y) и та, что сохранена в visit[x%n][y%m]. Отметим, что этот поиск посетит не более nm + 1 клеток (принцип Дирихле). Асимптотика решения — O(nm).196C - Нарисуйте деревоТ.к. никакие три точки не лежат на одной прямой, решение всегда существует.Сначала подвесим дерево за какую-нибудь вершину и dfs-ом посчитаем размеры всех поддеревьев. Теперь будем рекурсивно строить ответ. Найдем самую левую нижнюю точку и поставим ей в соответствие корень дерева. Ничего плохого от этого не случится, ведь эта точка — крайняя в множестве. Отсортируем все остальные точки по углу относительно этой самой левой нижней точки. Теперь пусть размеры поддеревьев корня равны s1, s2, ..., sk. Запустим алгоритм рекурсивно, передав первому поддереву корня первые s1 точек (в уже отсортированном порядке), второму поддереву — следующие s2 точек после первых s1, ..., последнему поддереву — последние sk точек. Легко видеть, что ребра, принадлежащие разным поддеревьям, в этом случае не будут пересекаться. На каждом этапе рекурсии надо сопоставлять самую крайнюю из выбранных точек с корнем поддерева и сортировать все остальные точки относительно нее. Тогда никакие два поддерева не будут иметь попарно пересекающихся ребер. Асимптотика решения — .196D - Следующая хорошая строкаСразу заметим, что нас интересует только наличие подпалиндромов длины d и d + 1: любой подпалиндром большей длины будет содержать их, а если нет длины d и d + 1, нет и больших. Назовем их, для краткости, плохими.Сначала найдем самую левую позицию pos, в которой символ строки точно нужно увеличить. Если плохих подпалиндромов нет, это будет конец строки (так как нужно найти хорошую строку, строго большую данной), иначе это самая левая позиция среди всех концов плохих палиндромов.Увеличим s[pos]. Продолжим увеличивать, пока s[pos] является концом плохого палиндрома. Если пытаемся увеличить символ 'z', значит надо переходить к увеличению предыдущего символа. Если таким образом дошли до начала строки и увеличивать некуда, решения нет. Заметим, что при этом будет выполнено не более O(n) операций увеличения.Пусть теперь pos — позиция самого левого измененного символа. Мы знаем, что префикс s[0..pos] не содержит плохих палиндромов. Теперь суффикс s[pos + 1..n - 1] можно заполнить жадно, перебираем позицию i по возрастанию, полагаем s[i] = 'a', и увеличиваем s[i], пока он является концом плохого палиндрома. Несложно понять, что на роль любого символа суффикса подойдет один из символов 'a', 'b' или 'c' — так как каждой позиции могут \"помешать\" лишь два символа находящихся левее на d и d - 1 позиций.Таким образом, мы получили алгоритм, который требует быстрого выполнения двух операций: изменение одного символа и запрос, является ли данная подстрока палиндромом. Это можно делать с помощью хешей и дерева Фенвика.Научимся узнавать хеш подстроки в изменяющейся строке. Тогда просто будем поддерживать информацию о самой строке, и о ее развернутой копии. Для определения, является ли данная подстрока палиндромом, просто сравним ее хеш с хешем соответствующей подстроки в развернутой версии.Итак, пусть дерево Фенвика поддерживает величины h[i] = s[i]Pi, где P — простое число, используемое для хеширования. Тогда хеш подстроки s[L..R] равен (h[L] + h[L + 1] + ...h[R])P - L. (Разумеется, можно не домножать на P - L а просто при сравнении хешей домножать один из них на нужную степень) Если требуется изменить s[i] на c, прибавляем Фенвиком в i-ую позицию число (c - s[i])Pi.Существует более быстрое решение, без хешей и структур данных, оно будет опубликовано немного позже.196E - Открытие порталовСперва заметим, что если порталы расположены во всех вершинах графа, то ответ — сумма длин ребер в минимальном остовном дереве, которое можно найти алгоритмом Краскала. Это довольно очевидно.Однако порталы расположены не во всех вершинах. Попробуем это исправить.Сделаем небольшой предпросчет: запустим алгоритм Дейкстры одновременно из всех порталов. Таким образом можно посчитать 2 массива: d[i] — расстояние от вершины i до ближайшего портала, и p[i] — ближайший к вершине i портал.Теперь рассмотрим выполнение алгоритма Краскала на графе, состоящем только из порталов. На первой итерации этот алгоритм выберет ребро с минимальным весом среди всех ребер, соединяющем порталы. Только в исходном графе это могут быть не только ребра, но и пути.Пусть такой кратчайший путь — из портала x в портал y. Заметим, что можно найти путь не длиннее, такой, что p[i] на нем будет меняться ровно один раз. Действительно, p[x] = x, p[y] = y, значит, на кратчайшем пути хотя бы раз меняется значение p[i]. Пусть оно меняется на ребре , причем p[i] = x. Поскольку путь от j до p[j] — кратчайший путь от j до портала, путь не длиннее пути из x в y.Тогда, т.к. p[i] = x, p[j] = y, можно рассчитать длину этого пути: она равна d[i] + w(i, j) + d[j] (w(i, j) — вес ребра (i, j)). Алгоритм Краскала прибавит эту величину к ответу и объединит порталы x и y. При этом объединятся поддеревья ближайших к ним вершин.А теперь видим, что ничего не изменилось, и следующее по весу ребро можно найти точно таким же способом — . Если это ребро снова лежит между вершинами x и y, то DSU не даст посчитать это ребро, иначе это ребро соединяет другую пару порталов и войдет в ответ.Как это считать. Из определения ребер в новом графе нетрудно понять, что их столько же, сколько и в исходном: каждому ребру (i, j) веса w(i, j) в старом графе соответствует ребро (p[i], p[j]) веса d[i] + w(i, j) + d[j] в новом графе. Поэтому построим новый граф и запустим на нем алгоритм Краскала — он посчитает вес минимального остовного дерева в графе, где вершины — порталы.Осталось заметить, что если в стартовой вершине есть портал, то мы нашли ответ, а если нет — то надо сначала дойти до ближайшего портала, чтобы можно было начать считать миностов. Для этого можно просто в конце прибавить к ответу число d[1].",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 197 和字母"
          },
          "content_length": 8436
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #124 - Codeforces - Code 1",
          "code": "#.#\n...\n###\n#S#\n#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 2",
          "code": "#.#\n...\n###\n#S#\n#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 3",
          "code": "7 9\n#.#.#.###\n#.#.#...#\n#.#.###S#\n#.#...#.#\n#.###.#.#\n#...#.#.#\n#.#.#.#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 4",
          "code": "7 9\n#.#.#.###\n#.#.#...#\n#.#.###S#\n#.#...#.#\n#.###.#.#\n#...#.#.#\n#.#.#.#.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 5",
          "code": "5 9\n###.#.#.#\n#...#.#.#\n#S###.#.#\n#.#...#.#\n#.#.###.#\n#.#.#...#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 6",
          "code": "5 9\n###.#.#.#\n#...#.#.#\n#S###.#.#\n#.#...#.#\n#.#.###.#\n#.#.#...#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 7",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 8",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 9",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 10",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 11",
          "code": "(atan2(10^9, 10^9—1) == atan2(10^9+1, 10^9)) == true",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 12",
          "code": "(atan2(10^9, 10^9—1) == atan2(10^9+1, 10^9)) == false",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 13",
          "code": "4\n\n1 2\n1 3\n3 4\n\n5 5\n0 0\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 14",
          "code": "4\n\n1 2\n1 3\n3 4\n\n5 5\n0 0\n3 4\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 15",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 16",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 1",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 2",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 3",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 4",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 1",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 2",
          "code": "stack<char> q;\n    q.push(s[0]);\n    for (size_t i = 1; i < s.length(); i++) {\n        while (!q.empty() && s[i] > q.top())\n            q.pop();\n        q.push(s[i]);\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 3",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #124 - Codeforces - Code 4",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    ensuref(!s.empty(), \"String is empty\");\n    ensuref(s.size() <= 100000, \"String length exceeds 1e5: %d\", (int)s.size());\n\n    for (char c : s) {\n        ensuref('a' <= c && c <= 'z', \"Character '%c' is not a lowercase lowercase\", c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    ensuref(!s.empty(), \"String is empty\");\n    ensuref(s.size() <= 100000, \"String length exceeds 1e5: %d\", (int)s.size());\n\n    for (char c : s) {\n        ensuref('a' <= c && c <= 'z', \"Character '%c' is not a lowercase lowercase\", c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    ensuref(!s.empty(), \"String is empty\");\n    ensuref(s.size() <= 100000, \"String length exceeds 1e5: %d\", (int)s.size());\n\n    for (char c : s) {\n        ensuref('a' <= c && c <= 'z', \"Character '%c' is not a lowercase lowercase\", c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\"); // Length of the string\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate a random string of length len\n        s.resize(len);\n        for (int i = 0; i < len; ++i) {\n            s[i] = 'a' + rnd.next(26); // Random character from 'a' to 'z'\n        }\n    } else if (type == \"all_same\") {\n        // All characters are the same\n        char c = 'a' + rnd.next(26);\n        s = string(len, c);\n    } else if (type == \"increasing\") {\n        // Characters are non-decreasing\n        s.resize(len);\n        char c = 'a';\n        for (int i = 0; i < len; ++i) {\n            s[i] = c;\n            if (c < 'z') c += rnd.next(0, 1); // Randomly stay the same or increase\n        }\n    } else if (type == \"decreasing\") {\n        // Characters are non-increasing\n        s.resize(len);\n        char c = 'z';\n        for (int i = 0; i < len; ++i) {\n            s[i] = c;\n            if (c > 'a') c -= rnd.next(0, 1); // Randomly stay the same or decrease\n        }\n    } else if (type == \"max_at_end\") {\n        // Max character at the end\n        s.resize(len);\n        for (int i = 0; i < len - 1; ++i) {\n            s[i] = 'a' + rnd.next(25); // Random character from 'a' to 'y'\n        }\n        s[len -1] = 'z'; // Max character at the end\n    } else if (type == \"max_at_beginning\") {\n        // Max character at the beginning\n        s.resize(len);\n        s[0] = 'z';\n        for (int i = 1; i < len; ++i) {\n            s[i] = 'a' + rnd.next(25); // Random character from 'a' to 'y'\n        }\n    } else if (type == \"alternating_max_min\") {\n        // Alternating between max and min characters\n        s.resize(len);\n        for (int i = 0; i < len; ++i) {\n            s[i] = (i % 2 == 0) ? 'z' : 'a';\n        }\n    } else if (type == \"palindrome\") {\n        // Generate a palindrome\n        string half;\n        for (int i = 0; i < (len + 1) / 2; ++i) {\n            half += 'a' + rnd.next(26);\n        }\n        s = half;\n        if (len % 2 == 0) {\n            reverse(half.begin(), half.end());\n        } else {\n            reverse(half.begin(), half.end() -1);\n        }\n        s += half;\n    } else if (type == \"single_char\") {\n        // Single character string\n        s = string(1, 'a' + rnd.next(26));\n    } else {\n        // Default to random if unknown type\n        s.resize(len);\n        for (int i = 0; i < len; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n    }\n\n    // Output the string\n    cout << s << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\"); // Length of the string\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate a random string of length len\n        s.resize(len);\n        for (int i = 0; i < len; ++i) {\n            s[i] = 'a' + rnd.next(26); // Random character from 'a' to 'z'\n        }\n    } else if (type == \"all_same\") {\n        // All characters are the same\n        char c = 'a' + rnd.next(26);\n        s = string(len, c);\n    } else if (type == \"increasing\") {\n        // Characters are non-decreasing\n        s.resize(len);\n        char c = 'a';\n        for (int i = 0; i < len; ++i) {\n            s[i] = c;\n            if (c < 'z') c += rnd.next(0, 1); // Randomly stay the same or increase\n        }\n    } else if (type == \"decreasing\") {\n        // Characters are non-increasing\n        s.resize(len);\n        char c = 'z';\n        for (int i = 0; i < len; ++i) {\n            s[i] = c;\n            if (c > 'a') c -= rnd.next(0, 1); // Randomly stay the same or decrease\n        }\n    } else if (type == \"max_at_end\") {\n        // Max character at the end\n        s.resize(len);\n        for (int i = 0; i < len - 1; ++i) {\n            s[i] = 'a' + rnd.next(25); // Random character from 'a' to 'y'\n        }\n        s[len -1] = 'z'; // Max character at the end\n    } else if (type == \"max_at_beginning\") {\n        // Max character at the beginning\n        s.resize(len);\n        s[0] = 'z';\n        for (int i = 1; i < len; ++i) {\n            s[i] = 'a' + rnd.next(25); // Random character from 'a' to 'y'\n        }\n    } else if (type == \"alternating_max_min\") {\n        // Alternating between max and min characters\n        s.resize(len);\n        for (int i = 0; i < len; ++i) {\n            s[i] = (i % 2 == 0) ? 'z' : 'a';\n        }\n    } else if (type == \"palindrome\") {\n        // Generate a palindrome\n        string half;\n        for (int i = 0; i < (len + 1) / 2; ++i) {\n            half += 'a' + rnd.next(26);\n        }\n        s = half;\n        if (len % 2 == 0) {\n            reverse(half.begin(), half.end());\n        } else {\n            reverse(half.begin(), half.end() -1);\n        }\n        s += half;\n    } else if (type == \"single_char\") {\n        // Single character string\n        s = string(1, 'a' + rnd.next(26));\n    } else {\n        // Default to random if unknown type\n        s.resize(len);\n        for (int i = 0; i < len; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n    }\n\n    // Output the string\n    cout << s << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -len 1 -type random\n./gen -len 1 -type all_same\n./gen -len 1 -type increasing\n./gen -len 1 -type decreasing\n./gen -len 1 -type max_at_end\n./gen -len 1 -type max_at_beginning\n./gen -len 1 -type alternating_max_min\n./gen -len 1 -type palindrome\n./gen -len 1 -type single_char\n\n./gen -len 5 -type random\n./gen -len 5 -type all_same\n./gen -len 5 -type increasing\n./gen -len 5 -type decreasing\n./gen -len 5 -type max_at_end\n./gen -len 5 -type max_at_beginning\n./gen -len 5 -type alternating_max_min\n./gen -len 5 -type palindrome\n\n./gen -len 10 -type random\n./gen -len 10 -type increasing\n./gen -len 10 -type decreasing\n\n./gen -len 100 -type random\n./gen -len 100 -type all_same\n./gen -len 100 -type increasing\n./gen -len 100 -type decreasing\n./gen -len 100 -type max_at_end\n./gen -len 100 -type max_at_beginning\n./gen -len 100 -type alternating_max_min\n./gen -len 100 -type palindrome\n\n./gen -len 1000 -type random\n./gen -len 1000 -type all_same\n./gen -len 1000 -type increasing\n./gen -len 1000 -type decreasing\n\n./gen -len 100000 -type random\n./gen -len 100000 -type all_same\n./gen -len 100000 -type increasing\n./gen -len 100000 -type decreasing\n./gen -len 100000 -type max_at_end\n./gen -len 100000 -type max_at_beginning\n./gen -len 100000 -type alternating_max_min\n./gen -len 100000 -type palindrome\n\n./gen -len 100000 -type single_char\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:15.742371",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "197/D",
      "title": "D. Infinite Maze",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 1500) — the height and the width of the maze that the boy used to cyclically tile the plane.Each of the next n lines contains m characters — the description of the labyrinth. Each character is either a \"#\", that marks a wall, a \".\", that marks a passable cell, or an \"S\", that marks the little boy's starting point. The starting point is a passable cell. It is guaranteed that character \"S\" occurs exactly once in the input.",
      "output_spec": "OutputPrint \"Yes\" (without the quotes), if the little boy can walk infinitely far from the starting point. Otherwise, print \"No\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy5 4##.###S##..##.###..#OutputCopyYesInputCopy5 4##.###S##..#..#.#.##OutputCopyNo",
      "description": "D. Infinite Maze\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 1500) — the height and the width of the maze that the boy used to cyclically tile the plane.Each of the next n lines contains m characters — the description of the labyrinth. Each character is either a \"#\", that marks a wall, a \".\", that marks a passable cell, or an \"S\", that marks the little boy's starting point. The starting point is a passable cell. It is guaranteed that character \"S\" occurs exactly once in the input.\n\nOutputPrint \"Yes\" (without the quotes), if the little boy can walk infinitely far from the starting point. Otherwise, print \"No\" (without the quotes).\n\nInputCopy5 4##.###S##..##.###..#OutputCopyYesInputCopy5 4##.###S##..#..#.#.##OutputCopyNo\n\nInputCopy5 4##.###S##..##.###..#\n\nOutputCopyYes\n\nInputCopy5 4##.###S##..#..#.#.##\n\nOutputCopyNo\n\nNoteIn the first sample the little boy can go up for infinitely long as there is a \"clear path\" that goes vertically. He just needs to repeat the following steps infinitely: up, up, left, up, up, right, up.In the second sample the vertical path is blocked. The path to the left doesn't work, too — the next \"copy\" of the maze traps the boy.",
      "solutions": [
        {
          "title": "Codeforces Round #124 - Codeforces",
          "content": "Hi all!Today, June 12, when Russia celebrates Day of itself, Euro 2012 second round starts and I_love_natalia has a birthday, we present you Codeforces Round #124.Contest was prepared by team Samara SAU Teddy Bears (craus, dalex, Hohol) and I_love_natalia. Also thanks to Alex_KPR and Codeforces team (Gerald, Delinur, MikeMirzayanov). We think that contest is very easy, and your task will be prove of refute this assertion :)Scoring system is dynamic (Learn more about dynamic problem scoring). Authors think that problems are sorted by difficulty in non-descending order.Accepted solutions and successful hacks to you!UPD. Contest is over, congratulations to the winners!Div-1 (full results): tourist — the only one who solved all problems! RAVEman aropan Div-2 (full results): bmerry littlefriend gstsclq UPD 2. Tutorial is available.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 838
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces",
          "content": "197A - Plate GameIf first player can't make first move (table is too small and plate doesn't fit it, i.e. 2r > min(a, b)), second player wins. Else first player wins. Winning strategy for first player: place first plate to the center of table. After that he symmetrically reflects moves of second player with respect to center of table. If second player has move, first player has symmetrical move, too. If not, first player won.197B - LimitFrom math lessons we know, that only higher degrees of polinomials matter in this problem. If denominator degree is larger than numenator degree, answer is \"0/1\". If numenator degree is larger, answer is infinity. But what is sign of this infinity? To get it consider signs of highest degree factors of polinomials. If they are same, answer is positive infinity, else — negative infinity. If degrees of numenator and denominator are equal, answer is . To get irreducible fraction, you should divide this numbers by gcd(a0, b0). And don't forget that denominator of answer must be positive. 196A - Lexicographically Maximum SubsequenceSolution is greedy. First, write all 'z' letters (if there is any) — answer must contain them all for sure. Now it's time for 'y' letters. We can use only those of them which are on the right of last used 'z' letter. Then write 'x' letters — they must be on the right of the last used 'y' and 'z' letters. And so on.196B - Infinite MazeAnswer is \"Yes\" iff there are two distinct, reachable from start position cells, which correspond to same cell in initial labyrinth. Proof: If these cells exist, move to first of them, and infinitely repeat moves leading from first to second. On the contrary, if infinite far path exist, on this path we obviously can find such cells.How to find out if they exist? Start DFS from initial cell. For each cell visited, let visit[x%n][y%m] = (x, y). Now, if DFS tries to go to cell (x, y), visit[x%n][y%m] contains something, and (x, y) ≠ visit[x%n][y%m], we found these cells: they are (x, y) and visit[x%n][y%m]. Notice that DFS will visit no more than nm + 1 cells (Dirichlet's principle). So the asymptotic is O(nm).196C - Paint TreeNo three points are in the same line, so the solution always exists.First, choose any one vertex as the root of tree. Find size of each subtree using dfs.Then, we can build the answer recursively.Put the root of tree to the most lower left point.Sort all other points by angle relative to this lower left point.Let us name the sizes of subtrees of the root as s1, s2, ..., sk.Run the algorithm recursively, giving first s1 points (in sorted order) for the first subtree of root, next s2 points for the second subtree and so on.Obviously, no two edges from different subtrees can intersect now.At each step of recursion we are to put the root of current subtree to the first point in sorted-by-angle order, and then sort other points by angle relative to it.So, no two subtrees will have any intersecting edges.The asymptotic of solution is .196D - The Next Good StringNotice, that only palindromes with length d and d + 1 matter. Any palindrome with greater length contains one of them. Let's call these palindromes bad.First, find leftmost position pos, in which we surely should increase value of symbol. If there are no bad subpalindromes, pos = |s| - 1, else pos is leftmost position amongst all ends of bad palindromes.Increase s[pos]. Increase it more, while s[pos] is end of bad subpalindrome. If you try increase 'z' symbol, you should proceed to increasing previous symbol. If this way you reached situation when you need to increase first symbol, and it is 'z', answer is \"Impossible\".Now, let pos be position of leftmost changed symbol. We know, that prefix s[0..pos] doesn't contain bad palindromes. Now we can greedily fill suffix s[pos + 1..length(s) - 1]: go over positions i in ascending order, assign s[i] = 'a', and increase it, while s[i] is end of bad palindrome. Obviously, any of suffix symbols will be 'a', 'b' or 'c'.So we got algorithm, which requires fast implementation of next operations — assigning single symbol, and query: is given substring palindrome? You can perform this operations using hashes and Fenwick tree.Let's learn, how to get hash of substring in dynamically changing string. If we can it, we will keep string s and it's reversed copy. For query of second type we just need to compare hashes of substring in s and hash of corresponding substring in reversed copy.Let Fenwick tree store values h[i] = s[i]Pi, where P is the prime number used for hashing. Then hash of substring s[L..R] equals to (h[L] + h[L + 1] + ...h[R])P - L. For assigning s[i] = c, add value (c - s[i])Pi to h[i]. Both these operations Fenwick tree does in .Also we have faster solution without hashes and data structures, it will be published soon.196E - Opening PortalsFirst of all, we can note that if each graph vertex is portal, the answer will be a sum of all edges' weights in MST (minimal spanning tree). We can find MST by using Kruskal's algo.In this problem, not an every vertex is portal. Let's fix this.Start with a precalculation. Run Dijkstra's algo from all the portals, simultaneously. We will get d[i] — a distance between vertex i and p[i] — the nearest portal to vertex i.Let's trace Kruskal's algo on a graph of portals. On the first iteration, it will choose the edge with the minimal cost, i.e. a shortest path between all the portals in the original graph.Let the path leads from portal x to portal y. Note that there exists a path with the same length such as p[i] changes only once through it. Indeed, p[x] = x, p[y] = y, i.e. p[i] changed on the path. If it happens on edge , p[i] = x, a path will not be longer than the path from x to y.As p[i] = x and p[i] = y, we can see that the length of this path will be d[i] + w(i, j) + d[j], where w(i, j) is the weight of edge (i, j). Kruskal's algo will add this value to the answer and merge portals x and y. The shortest-path trees of vertexes x and y will also be merged.Note, that almost nothing changed. The next edge for Kruskal's algo can be find in a similar way — . If this edge connects x and y again, DSU makes us not to count this edge, otherwise this edge connects a different pair of edges and will be counted in an answer.We can easily implement this. Just create a new graph of portals, with an edge (p[i], p[j]) of weight d[i] + w(i, j) + d[j] for every edge (i, j) of weight w(i, j) from original graph and run Kruskal's algo.Finally, note that if the starting vertex is not a portal, we shall add d[1] to the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 197 和字母"
          },
          "content_length": 6568
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces",
          "content": "197A - Plate GameIf first player can't make first move (table is too small and plate doesn't fit it, i.e. 2r > min(a, b)), second player wins. Else first player wins. Winning strategy for first player: place first plate to the center of table. After that he symmetrically reflects moves of second player with respect to center of table. If second player has move, first player has symmetrical move, too. If not, first player won.197B - LimitFrom math lessons we know, that only higher degrees of polinomials matter in this problem. If denominator degree is larger than numenator degree, answer is \"0/1\". If numenator degree is larger, answer is infinity. But what is sign of this infinity? To get it consider signs of highest degree factors of polinomials. If they are same, answer is positive infinity, else — negative infinity. If degrees of numenator and denominator are equal, answer is . To get irreducible fraction, you should divide this numbers by gcd(a0, b0). And don't forget that denominator of answer must be positive. 196A - Lexicographically Maximum SubsequenceSolution is greedy. First, write all 'z' letters (if there is any) — answer must contain them all for sure. Now it's time for 'y' letters. We can use only those of them which are on the right of last used 'z' letter. Then write 'x' letters — they must be on the right of the last used 'y' and 'z' letters. And so on.196B - Infinite MazeAnswer is \"Yes\" iff there are two distinct, reachable from start position cells, which correspond to same cell in initial labyrinth. Proof: If these cells exist, move to first of them, and infinitely repeat moves leading from first to second. On the contrary, if infinite far path exist, on this path we obviously can find such cells.How to find out if they exist? Start DFS from initial cell. For each cell visited, let visit[x%n][y%m] = (x, y). Now, if DFS tries to go to cell (x, y), visit[x%n][y%m] contains something, and (x, y) ≠ visit[x%n][y%m], we found these cells: they are (x, y) and visit[x%n][y%m]. Notice that DFS will visit no more than nm + 1 cells (Dirichlet's principle). So the asymptotic is O(nm).196C - Paint TreeNo three points are in the same line, so the solution always exists.First, choose any one vertex as the root of tree. Find size of each subtree using dfs.Then, we can build the answer recursively.Put the root of tree to the most lower left point.Sort all other points by angle relative to this lower left point.Let us name the sizes of subtrees of the root as s1, s2, ..., sk.Run the algorithm recursively, giving first s1 points (in sorted order) for the first subtree of root, next s2 points for the second subtree and so on.Obviously, no two edges from different subtrees can intersect now.At each step of recursion we are to put the root of current subtree to the first point in sorted-by-angle order, and then sort other points by angle relative to it.So, no two subtrees will have any intersecting edges.The asymptotic of solution is .196D - The Next Good StringNotice, that only palindromes with length d and d + 1 matter. Any palindrome with greater length contains one of them. Let's call these palindromes bad.First, find leftmost position pos, in which we surely should increase value of symbol. If there are no bad subpalindromes, pos = |s| - 1, else pos is leftmost position amongst all ends of bad palindromes.Increase s[pos]. Increase it more, while s[pos] is end of bad subpalindrome. If you try increase 'z' symbol, you should proceed to increasing previous symbol. If this way you reached situation when you need to increase first symbol, and it is 'z', answer is \"Impossible\".Now, let pos be position of leftmost changed symbol. We know, that prefix s[0..pos] doesn't contain bad palindromes. Now we can greedily fill suffix s[pos + 1..length(s) - 1]: go over positions i in ascending order, assign s[i] = 'a', and increase it, while s[i] is end of bad palindrome. Obviously, any of suffix symbols will be 'a', 'b' or 'c'.So we got algorithm, which requires fast implementation of next operations — assigning single symbol, and query: is given substring palindrome? You can perform this operations using hashes and Fenwick tree.Let's learn, how to get hash of substring in dynamically changing string. If we can it, we will keep string s and it's reversed copy. For query of second type we just need to compare hashes of substring in s and hash of corresponding substring in reversed copy.Let Fenwick tree store values h[i] = s[i]Pi, where P is the prime number used for hashing. Then hash of substring s[L..R] equals to (h[L] + h[L + 1] + ...h[R])P - L. For assigning s[i] = c, add value (c - s[i])Pi to h[i]. Both these operations Fenwick tree does in .Also we have faster solution without hashes and data structures, it will be published soon.196E - Opening PortalsFirst of all, we can note that if each graph vertex is portal, the answer will be a sum of all edges' weights in MST (minimal spanning tree). We can find MST by using Kruskal's algo.In this problem, not an every vertex is portal. Let's fix this.Start with a precalculation. Run Dijkstra's algo from all the portals, simultaneously. We will get d[i] — a distance between vertex i and p[i] — the nearest portal to vertex i.Let's trace Kruskal's algo on a graph of portals. On the first iteration, it will choose the edge with the minimal cost, i.e. a shortest path between all the portals in the original graph.Let the path leads from portal x to portal y. Note that there exists a path with the same length such as p[i] changes only once through it. Indeed, p[x] = x, p[y] = y, i.e. p[i] changed on the path. If it happens on edge , p[i] = x, a path will not be longer than the path from x to y.As p[i] = x and p[i] = y, we can see that the length of this path will be d[i] + w(i, j) + d[j], where w(i, j) is the weight of edge (i, j). Kruskal's algo will add this value to the answer and merge portals x and y. The shortest-path trees of vertexes x and y will also be merged.Note, that almost nothing changed. The next edge for Kruskal's algo can be find in a similar way — . If this edge connects x and y again, DSU makes us not to count this edge, otherwise this edge connects a different pair of edges and will be counted in an answer.We can easily implement this. Just create a new graph of portals, with an edge (p[i], p[j]) of weight d[i] + w(i, j) + d[j] for every edge (i, j) of weight w(i, j) from original graph and run Kruskal's algo.Finally, note that if the starting vertex is not a portal, we shall add d[1] to the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 197 和字母"
          },
          "content_length": 6568
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #124 - Codeforces - Code 1",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 2",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 3",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 4",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 5",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 6",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 1",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 2",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 1",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 2",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and m\n    int n = inf.readInt(1, 1500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1500, \"m\");\n    inf.readEoln();\n\n    // Read maze lines\n    int s_count = 0;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must have length %d\", i+1, m);\n        for (int j = 0; j < m; j++) {\n            char c = s[j];\n            ensuref(c == '#' || c == '.' || c == 'S', \"Invalid character '%c' in line %d, position %d\", c, i+1, j+1);\n            if (c == 'S') s_count++;\n        }\n    }\n    ensuref(s_count == 1, \"There must be exactly one 'S' in the maze, found %d\", s_count);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and m\n    int n = inf.readInt(1, 1500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1500, \"m\");\n    inf.readEoln();\n\n    // Read maze lines\n    int s_count = 0;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must have length %d\", i+1, m);\n        for (int j = 0; j < m; j++) {\n            char c = s[j];\n            ensuref(c == '#' || c == '.' || c == 'S', \"Invalid character '%c' in line %d, position %d\", c, i+1, j+1);\n            if (c == 'S') s_count++;\n        }\n    }\n    ensuref(s_count == 1, \"There must be exactly one 'S' in the maze, found %d\", s_count);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and m\n    int n = inf.readInt(1, 1500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1500, \"m\");\n    inf.readEoln();\n\n    // Read maze lines\n    int s_count = 0;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must have length %d\", i+1, m);\n        for (int j = 0; j < m; j++) {\n            char c = s[j];\n            ensuref(c == '#' || c == '.' || c == 'S', \"Invalid character '%c' in line %d, position %d\", c, i+1, j+1);\n            if (c == 'S') s_count++;\n        }\n    }\n    ensuref(s_count == 1, \"There must be exactly one 'S' in the maze, found %d\", s_count);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    // Place the starting position 'S' at some passable cell\n\n    int sx = rnd.next(0, n - 1);\n    int sy = rnd.next(0, m - 1);\n\n    // default to 'S' at (sx, sy)\n\n    grid[sx][sy] = 'S';\n\n    if (type == \"random\") {\n        // Randomly fill walls and passable cells\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (grid[i][j] == 'S') continue;\n                // Decide whether to place a wall\n                if (rnd.next(100) < 30) { // 30% chance to be a wall\n                    grid[i][j] = '#';\n                } else {\n                    grid[i][j] = '.';\n                }\n            }\n        }\n    } else if (type == \"trapped\") {\n        // Place walls around the starting position to trap the boy\n\n        // First, fill the grid with walls\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '#');\n        }\n\n        // Carve out a small area around 'S'\n\n        int x_start = max(0, sx - 1);\n        int x_end = min(n - 1, sx + 1);\n        int y_start = max(0, sy - 1);\n        int y_end = min(m - 1, sy + 1);\n\n        for (int i = x_start; i <= x_end; ++i) {\n            for (int j = y_start; j <= y_end; ++j) {\n                grid[i][j] = '.';\n            }\n        }\n        grid[sx][sy] = 'S'; // Ensure 'S' is in the grid\n        // Surround this area with walls (already walls)\n\n    } else if (type == \"infinite\") {\n        // Create an open path allowing to escape infinitely\n        // Let's create an open column at sy\n        for (int i = 0; i < n; ++i) {\n            grid[i][sy] = '.';\n        }\n        grid[sx][sy] = 'S';\n\n        // Fill other cells with walls\n        for (int i = 0; i < n; ++i) {\n            if (i == sx) continue;\n            for (int j = 0; j < m; ++j) {\n                if (grid[i][j] == 'S' || grid[i][j] == '.') continue;\n                grid[i][j] = '#';\n            }\n        }\n    } else if (type == \"full\") {\n        // Maze is fully open, no walls\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '.');\n        }\n        grid[sx][sy] = 'S';\n    } else if (type == \"fullwalls\") {\n        // Maze is fully walls except for 'S'\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '#');\n        }\n        grid[sx][sy] = 'S';\n    } else if (type == \"maze\") {\n        // Generate a random maze using a maze generation algorithm\n        // For simplification, we can generate a simple maze using DFS\n        // Initialize grid with walls\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '#');\n        }\n\n        // Start positions for maze generation\n        stack<pair<int, int>> s;\n        s.push({sx, sy});\n        grid[sx][sy] = 'S';\n\n        while (!s.empty()) {\n            auto [x, y] = s.top();\n            s.pop();\n\n            vector<pair<int, int>> directions = {{0,1},{1,0},{0,-1},{-1,0}};\n            shuffle(directions.begin(), directions.end());\n\n            for (auto [dx, dy] : directions) {\n                int nx = x + 2*dx;\n                int ny = y + 2*dy;\n                if (nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] == '#') {\n                    grid[nx - dx][ny - dy] = '.';\n                    grid[nx][ny] = '.';\n                    s.push({nx, ny});\n                }\n            }\n        }\n\n    } else if (type == \"thinpath\") {\n        // Create a thin path from 'S' to an edge to allow infinite movement\n\n        // Initialize grid with walls\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '#');\n        }\n        int x = sx, y = sy;\n        grid[x][y] = 'S';\n\n        while (x > 0) {\n            grid[x][y] = '.';\n            x--;\n        }\n        while (y > 0) {\n            grid[x][y] = '.';\n            y--;\n        }\n        while (x < n) {\n            grid[x][y] = '.';\n            x++;\n        }\n        // This path reaches the bottom edge allowing infinite movement\n\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (grid[i][j] == 'S') continue;\n                if (rnd.next(100) < 30) { // 30% walls\n                    grid[i][j] = '#';\n                } else {\n                    grid[i][j] = '.';\n                }\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    // Place the starting position 'S' at some passable cell\n\n    int sx = rnd.next(0, n - 1);\n    int sy = rnd.next(0, m - 1);\n\n    // default to 'S' at (sx, sy)\n\n    grid[sx][sy] = 'S';\n\n    if (type == \"random\") {\n        // Randomly fill walls and passable cells\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (grid[i][j] == 'S') continue;\n                // Decide whether to place a wall\n                if (rnd.next(100) < 30) { // 30% chance to be a wall\n                    grid[i][j] = '#';\n                } else {\n                    grid[i][j] = '.';\n                }\n            }\n        }\n    } else if (type == \"trapped\") {\n        // Place walls around the starting position to trap the boy\n\n        // First, fill the grid with walls\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '#');\n        }\n\n        // Carve out a small area around 'S'\n\n        int x_start = max(0, sx - 1);\n        int x_end = min(n - 1, sx + 1);\n        int y_start = max(0, sy - 1);\n        int y_end = min(m - 1, sy + 1);\n\n        for (int i = x_start; i <= x_end; ++i) {\n            for (int j = y_start; j <= y_end; ++j) {\n                grid[i][j] = '.';\n            }\n        }\n        grid[sx][sy] = 'S'; // Ensure 'S' is in the grid\n        // Surround this area with walls (already walls)\n\n    } else if (type == \"infinite\") {\n        // Create an open path allowing to escape infinitely\n        // Let's create an open column at sy\n        for (int i = 0; i < n; ++i) {\n            grid[i][sy] = '.';\n        }\n        grid[sx][sy] = 'S';\n\n        // Fill other cells with walls\n        for (int i = 0; i < n; ++i) {\n            if (i == sx) continue;\n            for (int j = 0; j < m; ++j) {\n                if (grid[i][j] == 'S' || grid[i][j] == '.') continue;\n                grid[i][j] = '#';\n            }\n        }\n    } else if (type == \"full\") {\n        // Maze is fully open, no walls\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '.');\n        }\n        grid[sx][sy] = 'S';\n    } else if (type == \"fullwalls\") {\n        // Maze is fully walls except for 'S'\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '#');\n        }\n        grid[sx][sy] = 'S';\n    } else if (type == \"maze\") {\n        // Generate a random maze using a maze generation algorithm\n        // For simplification, we can generate a simple maze using DFS\n        // Initialize grid with walls\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '#');\n        }\n\n        // Start positions for maze generation\n        stack<pair<int, int>> s;\n        s.push({sx, sy});\n        grid[sx][sy] = 'S';\n\n        while (!s.empty()) {\n            auto [x, y] = s.top();\n            s.pop();\n\n            vector<pair<int, int>> directions = {{0,1},{1,0},{0,-1},{-1,0}};\n            shuffle(directions.begin(), directions.end());\n\n            for (auto [dx, dy] : directions) {\n                int nx = x + 2*dx;\n                int ny = y + 2*dy;\n                if (nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] == '#') {\n                    grid[nx - dx][ny - dy] = '.';\n                    grid[nx][ny] = '.';\n                    s.push({nx, ny});\n                }\n            }\n        }\n\n    } else if (type == \"thinpath\") {\n        // Create a thin path from 'S' to an edge to allow infinite movement\n\n        // Initialize grid with walls\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '#');\n        }\n        int x = sx, y = sy;\n        grid[x][y] = 'S';\n\n        while (x > 0) {\n            grid[x][y] = '.';\n            x--;\n        }\n        while (y > 0) {\n            grid[x][y] = '.';\n            y--;\n        }\n        while (x < n) {\n            grid[x][y] = '.';\n            x++;\n        }\n        // This path reaches the bottom edge allowing infinite movement\n\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (grid[i][j] == 'S') continue;\n                if (rnd.next(100) < 30) { // 30% walls\n                    grid[i][j] = '#';\n                } else {\n                    grid[i][j] = '.';\n                }\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -type random\n./gen -n 5 -m 5 -type trapped\n./gen -n 5 -m 5 -type infinite\n./gen -n 5 -m 5 -type full\n./gen -n 5 -m 5 -type fullwalls\n./gen -n 5 -m 5 -type maze\n\n./gen -n 50 -m 50 -type random\n./gen -n 50 -m 50 -type trapped\n./gen -n 50 -m 50 -type infinite\n./gen -n 50 -m 50 -type thinpath\n./gen -n 50 -m 50 -type maze\n\n./gen -n 500 -m 500 -type random\n./gen -n 500 -m 500 -type infinite\n./gen -n 500 -m 500 -type thinpath\n\n./gen -n 1500 -m 1500 -type random\n./gen -n 1500 -m 1500 -type infinite\n\n./gen -n 1 -m 1500 -type random\n./gen -n 1500 -m 1 -type random\n\n./gen -n 1500 -m 1500 -type full\n\n./gen -n 1000 -m 1000 -type trapped\n\n./gen -n 10 -m 10 -type thinpath\n./gen -n 100 -m 100 -type thinpath\n\n./gen -n 1500 -m 1500 -type maze\n\n./gen -n 999 -m 999 -type infinite\n\n./gen -n 2 -m 2 -type fullwalls\n\n./gen -n 2 -m 2 -type full\n\n./gen -n 1500 -m 1 -type infinite\n./gen -n 1 -m 1500 -type infinite\n\n./gen -n 1500 -m 1500 -type fullwalls\n\n./gen -n 1000 -m 1500 -type random\n./gen -n 1500 -m 1000 -type random\n\n./gen -n 1499 -m 1499 -type trapped\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:17.461767",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "197/E",
      "title": "E. Paint Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 1500) — the number of vertexes on a tree (as well as the number of chosen points on the plane).Each of the next n - 1 lines contains two space-separated integers ui and vi (1 ≤ ui, vi ≤ n, ui ≠ vi) — the numbers of tree vertexes connected by the i-th edge.Each of the next n lines contain two space-separated integers xi and yi ( - 109 ≤ xi, yi ≤ 109) — the coordinates of the i-th point on the plane. No three points lie on one straight line.It is guaranteed that under given constraints problem has a solution.",
      "output_spec": "OutputPrint n distinct space-separated integers from 1 to n: the i-th number must equal the number of the vertex to place at the i-th point (the points are numbered in the order, in which they are listed in the input).If there are several solutions, print any of them.",
      "sample_tests": "ExamplesInputCopy31 32 30 01 12 0OutputCopy1 3 2InputCopy41 22 31 4-1 -23 5-3 32 0OutputCopy4 2 1 3",
      "description": "E. Paint Tree\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 1500) — the number of vertexes on a tree (as well as the number of chosen points on the plane).Each of the next n - 1 lines contains two space-separated integers ui and vi (1 ≤ ui, vi ≤ n, ui ≠ vi) — the numbers of tree vertexes connected by the i-th edge.Each of the next n lines contain two space-separated integers xi and yi ( - 109 ≤ xi, yi ≤ 109) — the coordinates of the i-th point on the plane. No three points lie on one straight line.It is guaranteed that under given constraints problem has a solution.\n\nOutputPrint n distinct space-separated integers from 1 to n: the i-th number must equal the number of the vertex to place at the i-th point (the points are numbered in the order, in which they are listed in the input).If there are several solutions, print any of them.\n\nInputCopy31 32 30 01 12 0OutputCopy1 3 2InputCopy41 22 31 4-1 -23 5-3 32 0OutputCopy4 2 1 3\n\nInputCopy31 32 30 01 12 0\n\nOutputCopy1 3 2\n\nInputCopy41 22 31 4-1 -23 5-3 32 0\n\nOutputCopy4 2 1 3\n\nNoteThe possible solutions for the sample are given below.",
      "solutions": [
        {
          "title": "Codeforces Round #124 - Codeforces",
          "content": "Hi all!Today, June 12, when Russia celebrates Day of itself, Euro 2012 second round starts and I_love_natalia has a birthday, we present you Codeforces Round #124.Contest was prepared by team Samara SAU Teddy Bears (craus, dalex, Hohol) and I_love_natalia. Also thanks to Alex_KPR and Codeforces team (Gerald, Delinur, MikeMirzayanov). We think that contest is very easy, and your task will be prove of refute this assertion :)Scoring system is dynamic (Learn more about dynamic problem scoring). Authors think that problems are sorted by difficulty in non-descending order.Accepted solutions and successful hacks to you!UPD. Contest is over, congratulations to the winners!Div-1 (full results): tourist — the only one who solved all problems! RAVEman aropan Div-2 (full results): bmerry littlefriend gstsclq UPD 2. Tutorial is available.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4708",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 838
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces",
          "content": "197A - Plate GameIf first player can't make first move (table is too small and plate doesn't fit it, i.e. 2r > min(a, b)), second player wins. Else first player wins. Winning strategy for first player: place first plate to the center of table. After that he symmetrically reflects moves of second player with respect to center of table. If second player has move, first player has symmetrical move, too. If not, first player won.197B - LimitFrom math lessons we know, that only higher degrees of polinomials matter in this problem. If denominator degree is larger than numenator degree, answer is \"0/1\". If numenator degree is larger, answer is infinity. But what is sign of this infinity? To get it consider signs of highest degree factors of polinomials. If they are same, answer is positive infinity, else — negative infinity. If degrees of numenator and denominator are equal, answer is . To get irreducible fraction, you should divide this numbers by gcd(a0, b0). And don't forget that denominator of answer must be positive. 196A - Lexicographically Maximum SubsequenceSolution is greedy. First, write all 'z' letters (if there is any) — answer must contain them all for sure. Now it's time for 'y' letters. We can use only those of them which are on the right of last used 'z' letter. Then write 'x' letters — they must be on the right of the last used 'y' and 'z' letters. And so on.196B - Infinite MazeAnswer is \"Yes\" iff there are two distinct, reachable from start position cells, which correspond to same cell in initial labyrinth. Proof: If these cells exist, move to first of them, and infinitely repeat moves leading from first to second. On the contrary, if infinite far path exist, on this path we obviously can find such cells.How to find out if they exist? Start DFS from initial cell. For each cell visited, let visit[x%n][y%m] = (x, y). Now, if DFS tries to go to cell (x, y), visit[x%n][y%m] contains something, and (x, y) ≠ visit[x%n][y%m], we found these cells: they are (x, y) and visit[x%n][y%m]. Notice that DFS will visit no more than nm + 1 cells (Dirichlet's principle). So the asymptotic is O(nm).196C - Paint TreeNo three points are in the same line, so the solution always exists.First, choose any one vertex as the root of tree. Find size of each subtree using dfs.Then, we can build the answer recursively.Put the root of tree to the most lower left point.Sort all other points by angle relative to this lower left point.Let us name the sizes of subtrees of the root as s1, s2, ..., sk.Run the algorithm recursively, giving first s1 points (in sorted order) for the first subtree of root, next s2 points for the second subtree and so on.Obviously, no two edges from different subtrees can intersect now.At each step of recursion we are to put the root of current subtree to the first point in sorted-by-angle order, and then sort other points by angle relative to it.So, no two subtrees will have any intersecting edges.The asymptotic of solution is .196D - The Next Good StringNotice, that only palindromes with length d and d + 1 matter. Any palindrome with greater length contains one of them. Let's call these palindromes bad.First, find leftmost position pos, in which we surely should increase value of symbol. If there are no bad subpalindromes, pos = |s| - 1, else pos is leftmost position amongst all ends of bad palindromes.Increase s[pos]. Increase it more, while s[pos] is end of bad subpalindrome. If you try increase 'z' symbol, you should proceed to increasing previous symbol. If this way you reached situation when you need to increase first symbol, and it is 'z', answer is \"Impossible\".Now, let pos be position of leftmost changed symbol. We know, that prefix s[0..pos] doesn't contain bad palindromes. Now we can greedily fill suffix s[pos + 1..length(s) - 1]: go over positions i in ascending order, assign s[i] = 'a', and increase it, while s[i] is end of bad palindrome. Obviously, any of suffix symbols will be 'a', 'b' or 'c'.So we got algorithm, which requires fast implementation of next operations — assigning single symbol, and query: is given substring palindrome? You can perform this operations using hashes and Fenwick tree.Let's learn, how to get hash of substring in dynamically changing string. If we can it, we will keep string s and it's reversed copy. For query of second type we just need to compare hashes of substring in s and hash of corresponding substring in reversed copy.Let Fenwick tree store values h[i] = s[i]Pi, where P is the prime number used for hashing. Then hash of substring s[L..R] equals to (h[L] + h[L + 1] + ...h[R])P - L. For assigning s[i] = c, add value (c - s[i])Pi to h[i]. Both these operations Fenwick tree does in .Also we have faster solution without hashes and data structures, it will be published soon.196E - Opening PortalsFirst of all, we can note that if each graph vertex is portal, the answer will be a sum of all edges' weights in MST (minimal spanning tree). We can find MST by using Kruskal's algo.In this problem, not an every vertex is portal. Let's fix this.Start with a precalculation. Run Dijkstra's algo from all the portals, simultaneously. We will get d[i] — a distance between vertex i and p[i] — the nearest portal to vertex i.Let's trace Kruskal's algo on a graph of portals. On the first iteration, it will choose the edge with the minimal cost, i.e. a shortest path between all the portals in the original graph.Let the path leads from portal x to portal y. Note that there exists a path with the same length such as p[i] changes only once through it. Indeed, p[x] = x, p[y] = y, i.e. p[i] changed on the path. If it happens on edge , p[i] = x, a path will not be longer than the path from x to y.As p[i] = x and p[i] = y, we can see that the length of this path will be d[i] + w(i, j) + d[j], where w(i, j) is the weight of edge (i, j). Kruskal's algo will add this value to the answer and merge portals x and y. The shortest-path trees of vertexes x and y will also be merged.Note, that almost nothing changed. The next edge for Kruskal's algo can be find in a similar way — . If this edge connects x and y again, DSU makes us not to count this edge, otherwise this edge connects a different pair of edges and will be counted in an answer.We can easily implement this. Just create a new graph of portals, with an edge (p[i], p[j]) of weight d[i] + w(i, j) + d[j] for every edge (i, j) of weight w(i, j) from original graph and run Kruskal's algo.Finally, note that if the starting vertex is not a portal, we shall add d[1] to the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 197 和字母"
          },
          "content_length": 6568
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces",
          "content": "197A - Plate GameIf first player can't make first move (table is too small and plate doesn't fit it, i.e. 2r > min(a, b)), second player wins. Else first player wins. Winning strategy for first player: place first plate to the center of table. After that he symmetrically reflects moves of second player with respect to center of table. If second player has move, first player has symmetrical move, too. If not, first player won.197B - LimitFrom math lessons we know, that only higher degrees of polinomials matter in this problem. If denominator degree is larger than numenator degree, answer is \"0/1\". If numenator degree is larger, answer is infinity. But what is sign of this infinity? To get it consider signs of highest degree factors of polinomials. If they are same, answer is positive infinity, else — negative infinity. If degrees of numenator and denominator are equal, answer is . To get irreducible fraction, you should divide this numbers by gcd(a0, b0). And don't forget that denominator of answer must be positive. 196A - Lexicographically Maximum SubsequenceSolution is greedy. First, write all 'z' letters (if there is any) — answer must contain them all for sure. Now it's time for 'y' letters. We can use only those of them which are on the right of last used 'z' letter. Then write 'x' letters — they must be on the right of the last used 'y' and 'z' letters. And so on.196B - Infinite MazeAnswer is \"Yes\" iff there are two distinct, reachable from start position cells, which correspond to same cell in initial labyrinth. Proof: If these cells exist, move to first of them, and infinitely repeat moves leading from first to second. On the contrary, if infinite far path exist, on this path we obviously can find such cells.How to find out if they exist? Start DFS from initial cell. For each cell visited, let visit[x%n][y%m] = (x, y). Now, if DFS tries to go to cell (x, y), visit[x%n][y%m] contains something, and (x, y) ≠ visit[x%n][y%m], we found these cells: they are (x, y) and visit[x%n][y%m]. Notice that DFS will visit no more than nm + 1 cells (Dirichlet's principle). So the asymptotic is O(nm).196C - Paint TreeNo three points are in the same line, so the solution always exists.First, choose any one vertex as the root of tree. Find size of each subtree using dfs.Then, we can build the answer recursively.Put the root of tree to the most lower left point.Sort all other points by angle relative to this lower left point.Let us name the sizes of subtrees of the root as s1, s2, ..., sk.Run the algorithm recursively, giving first s1 points (in sorted order) for the first subtree of root, next s2 points for the second subtree and so on.Obviously, no two edges from different subtrees can intersect now.At each step of recursion we are to put the root of current subtree to the first point in sorted-by-angle order, and then sort other points by angle relative to it.So, no two subtrees will have any intersecting edges.The asymptotic of solution is .196D - The Next Good StringNotice, that only palindromes with length d and d + 1 matter. Any palindrome with greater length contains one of them. Let's call these palindromes bad.First, find leftmost position pos, in which we surely should increase value of symbol. If there are no bad subpalindromes, pos = |s| - 1, else pos is leftmost position amongst all ends of bad palindromes.Increase s[pos]. Increase it more, while s[pos] is end of bad subpalindrome. If you try increase 'z' symbol, you should proceed to increasing previous symbol. If this way you reached situation when you need to increase first symbol, and it is 'z', answer is \"Impossible\".Now, let pos be position of leftmost changed symbol. We know, that prefix s[0..pos] doesn't contain bad palindromes. Now we can greedily fill suffix s[pos + 1..length(s) - 1]: go over positions i in ascending order, assign s[i] = 'a', and increase it, while s[i] is end of bad palindrome. Obviously, any of suffix symbols will be 'a', 'b' or 'c'.So we got algorithm, which requires fast implementation of next operations — assigning single symbol, and query: is given substring palindrome? You can perform this operations using hashes and Fenwick tree.Let's learn, how to get hash of substring in dynamically changing string. If we can it, we will keep string s and it's reversed copy. For query of second type we just need to compare hashes of substring in s and hash of corresponding substring in reversed copy.Let Fenwick tree store values h[i] = s[i]Pi, where P is the prime number used for hashing. Then hash of substring s[L..R] equals to (h[L] + h[L + 1] + ...h[R])P - L. For assigning s[i] = c, add value (c - s[i])Pi to h[i]. Both these operations Fenwick tree does in .Also we have faster solution without hashes and data structures, it will be published soon.196E - Opening PortalsFirst of all, we can note that if each graph vertex is portal, the answer will be a sum of all edges' weights in MST (minimal spanning tree). We can find MST by using Kruskal's algo.In this problem, not an every vertex is portal. Let's fix this.Start with a precalculation. Run Dijkstra's algo from all the portals, simultaneously. We will get d[i] — a distance between vertex i and p[i] — the nearest portal to vertex i.Let's trace Kruskal's algo on a graph of portals. On the first iteration, it will choose the edge with the minimal cost, i.e. a shortest path between all the portals in the original graph.Let the path leads from portal x to portal y. Note that there exists a path with the same length such as p[i] changes only once through it. Indeed, p[x] = x, p[y] = y, i.e. p[i] changed on the path. If it happens on edge , p[i] = x, a path will not be longer than the path from x to y.As p[i] = x and p[i] = y, we can see that the length of this path will be d[i] + w(i, j) + d[j], where w(i, j) is the weight of edge (i, j). Kruskal's algo will add this value to the answer and merge portals x and y. The shortest-path trees of vertexes x and y will also be merged.Note, that almost nothing changed. The next edge for Kruskal's algo can be find in a similar way — . If this edge connects x and y again, DSU makes us not to count this edge, otherwise this edge connects a different pair of edges and will be counted in an answer.We can easily implement this. Just create a new graph of portals, with an edge (p[i], p[j]) of weight d[i] + w(i, j) + d[j] for every edge (i, j) of weight w(i, j) from original graph and run Kruskal's algo.Finally, note that if the starting vertex is not a portal, we shall add d[1] to the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4717",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 197 和字母"
          },
          "content_length": 6568
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #124 - Codeforces - Code 1",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 2",
          "code": "3 16\n.##..##..##..##.\n#...#...#...#...\nS.##..##..##..##",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 3",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 4",
          "code": "No, example:\n##.#\n...#\n.###\n.#S.\n##.#",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 5",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 - Codeforces - Code 6",
          "code": "3 2\n4 3 1 2\n-5 7 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4708",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 1",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 2",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 1",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #124 — editorial - Codeforces - Code 2",
          "code": "DFS(vertex v,vertex par){\n  for every child of v (like u) do:\n    search for point (like p) that flag[p]==false and angle between (point[par],point[v],p) is maximum;\n    point[u]=p;\n    flag[p]=true;\n    DFS(u,v);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4717",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    ensuref(x != y, \"Graph contains a cycle\");\n    parent[x] = y;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1500, \"n\");\n    inf.readEoln();\n    \n    vector<pair<int, int>> edges;\n    \n    parent.resize(n + 1);\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n    \n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge cannot connect a vertex to itself (loop)\");\n        edges.push_back({u, v});\n        unite(u, v);\n    }\n    \n    vector<pair<long long, long long>> points(n + 1); // index from 1 to n\n    \n    set<pair<long long, long long>> pointSet;\n    \n    for (int i = 1; i <= n; i++) {\n        long long xi = inf.readLong(-1000000000LL, 1000000000LL, \"xi\");\n        inf.readSpace();\n        long long yi = inf.readLong(-1000000000LL, 1000000000LL, \"yi\");\n        inf.readEoln();\n        points[i] = {xi, yi};\n        // Check for duplicate points\n        ensuref(pointSet.count({xi, yi}) == 0, \"Duplicate point detected at index %d\", i);\n        pointSet.insert({xi, yi});\n    }\n    \n    // Now, check that no three points lie on a straight line\n    // For each point i:\n    for (int i = 1; i <= n; i++) {\n        map<pair<long long, long long>, int> slopes;\n        for (int j = 1; j <= n; j++) {\n            if (i == j) continue;\n            long long dx = points[j].first - points[i].first;\n            long long dy = points[j].second - points[i].second;\n            \n            if (dx == 0 && dy == 0) {\n                ensuref(false, \"Two identical points detected at indices %d and %d\", i, j);\n            }\n            \n            long long g = __gcd(abs(dx), abs(dy));\n            dx /= g;\n            dy /= g;\n            \n            // Normalize signs\n            if (dx < 0) {\n                dx = -dx;\n                dy = -dy;\n            } else if (dx == 0 && dy < 0) {\n                dy = -dy;\n            }\n            \n            pair<long long, long long> slope = make_pair(dy, dx);\n            if (slopes.count(slope)) {\n                int k = slopes[slope];\n                ensuref(false, \"Points %d, %d, and %d are colinear\", i, j, k);\n            }\n            slopes[slope] = j;\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    ensuref(x != y, \"Graph contains a cycle\");\n    parent[x] = y;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1500, \"n\");\n    inf.readEoln();\n    \n    vector<pair<int, int>> edges;\n    \n    parent.resize(n + 1);\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n    \n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge cannot connect a vertex to itself (loop)\");\n        edges.push_back({u, v});\n        unite(u, v);\n    }\n    \n    vector<pair<long long, long long>> points(n + 1); // index from 1 to n\n    \n    set<pair<long long, long long>> pointSet;\n    \n    for (int i = 1; i <= n; i++) {\n        long long xi = inf.readLong(-1000000000LL, 1000000000LL, \"xi\");\n        inf.readSpace();\n        long long yi = inf.readLong(-1000000000LL, 1000000000LL, \"yi\");\n        inf.readEoln();\n        points[i] = {xi, yi};\n        // Check for duplicate points\n        ensuref(pointSet.count({xi, yi}) == 0, \"Duplicate point detected at index %d\", i);\n        pointSet.insert({xi, yi});\n    }\n    \n    // Now, check that no three points lie on a straight line\n    // For each point i:\n    for (int i = 1; i <= n; i++) {\n        map<pair<long long, long long>, int> slopes;\n        for (int j = 1; j <= n; j++) {\n            if (i == j) continue;\n            long long dx = points[j].first - points[i].first;\n            long long dy = points[j].second - points[i].second;\n            \n            if (dx == 0 && dy == 0) {\n                ensuref(false, \"Two identical points detected at indices %d and %d\", i, j);\n            }\n            \n            long long g = __gcd(abs(dx), abs(dy));\n            dx /= g;\n            dy /= g;\n            \n            // Normalize signs\n            if (dx < 0) {\n                dx = -dx;\n                dy = -dy;\n            } else if (dx == 0 && dy < 0) {\n                dy = -dy;\n            }\n            \n            pair<long long, long long> slope = make_pair(dy, dx);\n            if (slopes.count(slope)) {\n                int k = slopes[slope];\n                ensuref(false, \"Points %d, %d, and %d are colinear\", i, j, k);\n            }\n            slopes[slope] = j;\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    ensuref(x != y, \"Graph contains a cycle\");\n    parent[x] = y;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1500, \"n\");\n    inf.readEoln();\n    \n    vector<pair<int, int>> edges;\n    \n    parent.resize(n + 1);\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n    \n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge cannot connect a vertex to itself (loop)\");\n        edges.push_back({u, v});\n        unite(u, v);\n    }\n    \n    vector<pair<long long, long long>> points(n + 1); // index from 1 to n\n    \n    set<pair<long long, long long>> pointSet;\n    \n    for (int i = 1; i <= n; i++) {\n        long long xi = inf.readLong(-1000000000LL, 1000000000LL, \"xi\");\n        inf.readSpace();\n        long long yi = inf.readLong(-1000000000LL, 1000000000LL, \"yi\");\n        inf.readEoln();\n        points[i] = {xi, yi};\n        // Check for duplicate points\n        ensuref(pointSet.count({xi, yi}) == 0, \"Duplicate point detected at index %d\", i);\n        pointSet.insert({xi, yi});\n    }\n    \n    // Now, check that no three points lie on a straight line\n    // For each point i:\n    for (int i = 1; i <= n; i++) {\n        map<pair<long long, long long>, int> slopes;\n        for (int j = 1; j <= n; j++) {\n            if (i == j) continue;\n            long long dx = points[j].first - points[i].first;\n            long long dy = points[j].second - points[i].second;\n            \n            if (dx == 0 && dy == 0) {\n                ensuref(false, \"Two identical points detected at indices %d and %d\", i, j);\n            }\n            \n            long long g = __gcd(abs(dx), abs(dy));\n            dx /= g;\n            dy /= g;\n            \n            // Normalize signs\n            if (dx < 0) {\n                dx = -dx;\n                dy = -dy;\n            } else if (dx == 0 && dy < 0) {\n                dy = -dy;\n            }\n            \n            pair<long long, long long> slope = make_pair(dy, dx);\n            if (slopes.count(slope)) {\n                int k = slopes[slope];\n                ensuref(false, \"Points %d, %d, and %d are colinear\", i, j, k);\n            }\n            slopes[slope] = j;\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<long long, long long> Point;\n\nint orientation(Point a, Point b, Point c) {\n    // Compute the orientation of triplet (a, b, c)\n    // It returns:\n    // 0 --> colinear points (won't happen as no three points are colinear)\n    // 1 --> clockwise\n    // 2 --> counterclockwise\n    long long val = (b.second - a.second) * (c.first - b.first) -\n                    (b.first - a.first) * (c.second - b.second);\n    if (val == 0)\n        return 0; // Colinear (should not happen)\n    return (val > 0) ? 1 : 2; // Clockwise or counterclockwise\n}\n\nbool doIntersect(Point p1, Point p2, Point p3, Point p4) {\n    // Check if segments p1-p2 and p3-p4 intersect\n    int o1 = orientation(p1, p2, p3);\n    int o2 = orientation(p1, p2, p4);\n    int o3 = orientation(p3, p4, p1);\n    int o4 = orientation(p3, p4, p2);\n\n    // General case\n    if (o1 != o2 && o3 != o4)\n        return true;\n\n    return false; // Do not intersect\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input\n    int n = inf.readInt();\n    vector<pair<int, int>> edges;\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(), v = inf.readInt();\n        edges.emplace_back(u - 1, v - 1); // 0-based indexing\n    }\n    vector<Point> points(n);\n    for (int i = 0; i < n; ++i) {\n        long long x = inf.readLong(), y = inf.readLong();\n        points[i] = {x, y};\n    }\n\n    // Read participant's output\n    vector<int> mapping(n);\n    set<int> usedVertices;\n    for (int i = 0; i < n; ++i) {\n        int v = ouf.readInt(1, n, format(\"mapping[%d]\", i + 1).c_str()) - 1; // 0-based indexing\n        if (usedVertices.count(v))\n            quitf(_wa, \"Vertex %d appears more than once in the mapping\", v + 1);\n        usedVertices.insert(v);\n        mapping[i] = v;\n    }\n\n    if ((int)usedVertices.size() != n)\n        quitf(_wa, \"Mapping is not a valid permutation\");\n\n    // Create segments for edges\n    vector<pair<Point, Point>> segments(edges.size());\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n        int u_point_idx = -1, v_point_idx = -1;\n        for (int j = 0; j < n; ++j) {\n            if (mapping[j] == u)\n                u_point_idx = j;\n            else if (mapping[j] == v)\n                v_point_idx = j;\n        }\n        if (u_point_idx == -1 || v_point_idx == -1)\n            quitf(_fail, \"Could not find point assignment for vertices %d and %d\", u + 1, v + 1);\n        Point p_u = points[u_point_idx];\n        Point p_v = points[v_point_idx];\n        segments[i] = {p_u, p_v};\n    }\n\n    // Check for segment intersections between non-adjacent edges\n    for (size_t i = 0; i < segments.size(); ++i) {\n        for (size_t j = i + 1; j < segments.size(); ++j) {\n            int u1 = edges[i].first, v1 = edges[i].second;\n            int u2 = edges[j].first, v2 = edges[j].second;\n            // Skip if edges share a vertex (adjacent edges)\n            if (u1 == u2 || u1 == v2 || v1 == u2 || v1 == v2)\n                continue;\n            if (doIntersect(segments[i].first, segments[i].second, segments[j].first, segments[j].second))\n                quitf(_wa, \"Segments between edges %d-%d and %d-%d intersect\", \n                      u1 + 1, v1 + 1, u2 + 1, v2 + 1);\n        }\n    }\n\n    quitf(_ok, \"Correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool are_colinear(pair<int, int>& p1, pair<int, int>& p2, pair<int, int>& p3) {\n    long long x1 = p2.first - p1.first;\n    long long y1 = p2.second - p1.second;\n    long long x2 = p3.first - p1.first;\n    long long y2 = p3.second - p1.second;\n    return x1 * y2 - x2 * y1 == 0;\n}\n\nvector<pair<int, int>> generate_chain_tree(int n) {\n    vector<pair<int, int>> edges;\n    for (int i = 2; i <= n; ++i) {\n        edges.emplace_back(i - 1, i);\n    }\n    return edges;\n}\n\nvector<pair<int, int>> generate_star_tree(int n) {\n    vector<pair<int, int>> edges;\n    for (int i = 2; i <= n; ++i) {\n        edges.emplace_back(1, i);\n    }\n    return edges;\n}\n\nvector<pair<int, int>> generate_random_tree(int n) {\n    vector<pair<int, int>> edges;\n    for (int i = 2; i <= n; ++i) {\n        int u = i;\n        int v = rnd.next(1, i - 1);\n        edges.emplace_back(u, v);\n    }\n    return edges;\n}\n\nvoid create_balanced_tree(vector<int>& nodes, int l, int r, int parent, vector<pair<int, int>>& edges) {\n    if (l > r) return;\n    int mid = (l + r) / 2;\n    if (parent != -1) {\n        edges.emplace_back(parent, nodes[mid]);\n    }\n    create_balanced_tree(nodes, l, mid - 1, nodes[mid], edges);\n    create_balanced_tree(nodes, mid + 1, r, nodes[mid], edges);\n}\n\nvector<pair<int, int>> generate_balanced_tree(int n) {\n    vector<int> nodes(n);\n    for (int i = 0; i < n; ++i) nodes[i] = i + 1;\n    vector<pair<int, int>> edges;\n    create_balanced_tree(nodes, 0, n - 1, -1, edges);\n    return edges;\n}\n\nvector<pair<int,int>> generate_circle_points(int n) {\n    vector<pair<int,int>> points(n);\n    double R = 1e8;\n    double delta = 2 * acos(-1.0) / n;\n    for (int i = 0; i < n; ++i) {\n        double angle = delta * i + rnd.next(0.0, delta/10.0);\n        double x = R * cos(angle);\n        double y = R * sin(angle);\n        points[i] = make_pair((int)x, (int)y);\n    }\n    return points;\n}\n\nvector<pair<int,int>> generate_random_points(int n) {\n    set<int> x_set, y_set;\n    vector<int> x_list(n), y_list(n);\n    for(int i = 0; i < n; ++i) {\n        int x;\n        do {\n            x = rnd.next(-1000000000, 1000000000);\n        } while(x_set.count(x));\n        x_set.insert(x);\n        x_list[i] = x;\n    }\n    for(int i = 0; i < n; ++i) {\n        int y;\n        do {\n            y = rnd.next(-1000000000, 1000000000);\n        } while(y_set.count(y));\n        y_set.insert(y);\n        y_list[i] = y;\n    }\n    shuffle(x_list.begin(), x_list.end());\n    shuffle(y_list.begin(), y_list.end());\n    vector<pair<int,int>> points(n);\n    for(int i = 0; i < n; ++i) {\n        points[i] = make_pair(x_list[i], y_list[i]);\n    }\n    int attempts = 0;\n    const int MAX_ATTEMPTS = 10;\n    while(attempts < MAX_ATTEMPTS) {\n        bool found_colinear = false;\n        for(int iter = 0; iter < 10000; ++iter) {\n            int idx1 = rnd.next(0, n - 1);\n            int idx2 = rnd.next(0, n - 1);\n            int idx3 = rnd.next(0, n - 1);\n            if(idx1 == idx2 || idx1 == idx3 || idx2 == idx3) continue;\n            if(are_colinear(points[idx1], points[idx2], points[idx3])) {\n                found_colinear = true;\n                break;\n            }\n        }\n        if(found_colinear) {\n            // Regenerate y_list and points\n            y_set.clear();\n            for(int i = 0; i < n; ++i) {\n                int y;\n                do {\n                    y = rnd.next(-1000000000, 1000000000);\n                } while(y_set.count(y));\n                y_set.insert(y);\n                y_list[i] = y;\n            }\n            shuffle(y_list.begin(), y_list.end());\n            for(int i = 0; i < n; ++i) {\n                points[i] = make_pair(x_list[i], y_list[i]);\n            }\n            attempts++;\n        } else {\n            break;\n        }\n    }\n    if(attempts == MAX_ATTEMPTS) {\n        cerr << \"Failed to generate non-colinear points\\n\";\n        exit(1);\n    }\n    return points;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree_type = opt<string>(\"tree\", \"random\");\n    string point_type = opt<string>(\"points\", \"circle\");\n\n    vector<pair<int, int>> edges;\n    if (tree_type == \"chain\") {\n        edges = generate_chain_tree(n);\n    } else if (tree_type == \"star\") {\n        edges = generate_star_tree(n);\n    } else if (tree_type == \"balanced\") {\n        edges = generate_balanced_tree(n);\n    } else {\n        edges = generate_random_tree(n);\n    }\n\n    vector<pair<int, int>> points;\n    if (point_type == \"circle\") {\n        points = generate_circle_points(n);\n    } else {\n        points = generate_random_points(n);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output edges\n    for (auto& edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n    // Output points\n    for (auto& point : points) {\n        printf(\"%d %d\\n\", point.first, point.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool are_colinear(pair<int, int>& p1, pair<int, int>& p2, pair<int, int>& p3) {\n    long long x1 = p2.first - p1.first;\n    long long y1 = p2.second - p1.second;\n    long long x2 = p3.first - p1.first;\n    long long y2 = p3.second - p1.second;\n    return x1 * y2 - x2 * y1 == 0;\n}\n\nvector<pair<int, int>> generate_chain_tree(int n) {\n    vector<pair<int, int>> edges;\n    for (int i = 2; i <= n; ++i) {\n        edges.emplace_back(i - 1, i);\n    }\n    return edges;\n}\n\nvector<pair<int, int>> generate_star_tree(int n) {\n    vector<pair<int, int>> edges;\n    for (int i = 2; i <= n; ++i) {\n        edges.emplace_back(1, i);\n    }\n    return edges;\n}\n\nvector<pair<int, int>> generate_random_tree(int n) {\n    vector<pair<int, int>> edges;\n    for (int i = 2; i <= n; ++i) {\n        int u = i;\n        int v = rnd.next(1, i - 1);\n        edges.emplace_back(u, v);\n    }\n    return edges;\n}\n\nvoid create_balanced_tree(vector<int>& nodes, int l, int r, int parent, vector<pair<int, int>>& edges) {\n    if (l > r) return;\n    int mid = (l + r) / 2;\n    if (parent != -1) {\n        edges.emplace_back(parent, nodes[mid]);\n    }\n    create_balanced_tree(nodes, l, mid - 1, nodes[mid], edges);\n    create_balanced_tree(nodes, mid + 1, r, nodes[mid], edges);\n}\n\nvector<pair<int, int>> generate_balanced_tree(int n) {\n    vector<int> nodes(n);\n    for (int i = 0; i < n; ++i) nodes[i] = i + 1;\n    vector<pair<int, int>> edges;\n    create_balanced_tree(nodes, 0, n - 1, -1, edges);\n    return edges;\n}\n\nvector<pair<int,int>> generate_circle_points(int n) {\n    vector<pair<int,int>> points(n);\n    double R = 1e8;\n    double delta = 2 * acos(-1.0) / n;\n    for (int i = 0; i < n; ++i) {\n        double angle = delta * i + rnd.next(0.0, delta/10.0);\n        double x = R * cos(angle);\n        double y = R * sin(angle);\n        points[i] = make_pair((int)x, (int)y);\n    }\n    return points;\n}\n\nvector<pair<int,int>> generate_random_points(int n) {\n    set<int> x_set, y_set;\n    vector<int> x_list(n), y_list(n);\n    for(int i = 0; i < n; ++i) {\n        int x;\n        do {\n            x = rnd.next(-1000000000, 1000000000);\n        } while(x_set.count(x));\n        x_set.insert(x);\n        x_list[i] = x;\n    }\n    for(int i = 0; i < n; ++i) {\n        int y;\n        do {\n            y = rnd.next(-1000000000, 1000000000);\n        } while(y_set.count(y));\n        y_set.insert(y);\n        y_list[i] = y;\n    }\n    shuffle(x_list.begin(), x_list.end());\n    shuffle(y_list.begin(), y_list.end());\n    vector<pair<int,int>> points(n);\n    for(int i = 0; i < n; ++i) {\n        points[i] = make_pair(x_list[i], y_list[i]);\n    }\n    int attempts = 0;\n    const int MAX_ATTEMPTS = 10;\n    while(attempts < MAX_ATTEMPTS) {\n        bool found_colinear = false;\n        for(int iter = 0; iter < 10000; ++iter) {\n            int idx1 = rnd.next(0, n - 1);\n            int idx2 = rnd.next(0, n - 1);\n            int idx3 = rnd.next(0, n - 1);\n            if(idx1 == idx2 || idx1 == idx3 || idx2 == idx3) continue;\n            if(are_colinear(points[idx1], points[idx2], points[idx3])) {\n                found_colinear = true;\n                break;\n            }\n        }\n        if(found_colinear) {\n            // Regenerate y_list and points\n            y_set.clear();\n            for(int i = 0; i < n; ++i) {\n                int y;\n                do {\n                    y = rnd.next(-1000000000, 1000000000);\n                } while(y_set.count(y));\n                y_set.insert(y);\n                y_list[i] = y;\n            }\n            shuffle(y_list.begin(), y_list.end());\n            for(int i = 0; i < n; ++i) {\n                points[i] = make_pair(x_list[i], y_list[i]);\n            }\n            attempts++;\n        } else {\n            break;\n        }\n    }\n    if(attempts == MAX_ATTEMPTS) {\n        cerr << \"Failed to generate non-colinear points\\n\";\n        exit(1);\n    }\n    return points;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree_type = opt<string>(\"tree\", \"random\");\n    string point_type = opt<string>(\"points\", \"circle\");\n\n    vector<pair<int, int>> edges;\n    if (tree_type == \"chain\") {\n        edges = generate_chain_tree(n);\n    } else if (tree_type == \"star\") {\n        edges = generate_star_tree(n);\n    } else if (tree_type == \"balanced\") {\n        edges = generate_balanced_tree(n);\n    } else {\n        edges = generate_random_tree(n);\n    }\n\n    vector<pair<int, int>> points;\n    if (point_type == \"circle\") {\n        points = generate_circle_points(n);\n    } else {\n        points = generate_random_points(n);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output edges\n    for (auto& edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n    // Output points\n    for (auto& point : points) {\n        printf(\"%d %d\\n\", point.first, point.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -tree chain -points random\n./gen -n 1 -tree star -points circle\n./gen -n 2 -tree chain -points random\n./gen -n 2 -tree star -points circle\n./gen -n 3 -tree chain -points random\n./gen -n 3 -tree star -points circle\n./gen -n 10 -tree chain -points random\n./gen -n 10 -tree star -points circle\n./gen -n 10 -tree balanced -points random\n./gen -n 10 -tree random -points circle\n./gen -n 100 -tree chain -points random\n./gen -n 100 -tree star -points circle\n./gen -n 100 -tree balanced -points random\n./gen -n 100 -tree random -points circle\n./gen -n 500 -tree random -points random\n./gen -n 500 -tree balanced -points circle\n./gen -n 1000 -tree random -points random\n./gen -n 1000 -tree balanced -points circle\n./gen -n 1500 -tree random -points random\n./gen -n 1500 -tree balanced -points circle\n./gen -n 1500 -tree chain -points circle\n./gen -n 1500 -tree star -points random\n./gen -n 1499 -tree random -points circle\n./gen -n 1500 -tree random -points random\n./gen -n 1500 -tree balanced -points random\n./gen -n 1 -tree random -points random\n./gen -n 2 -tree balanced -points random\n./gen -n 3 -tree chain -points circle\n./gen -n 4 -tree star -points circle\n./gen -n 5 -tree random -points random\n./gen -n 1000 -tree random -points random\n./gen -n 1000 -tree random -points circle\n./gen -n 1000 -tree random -points random\n./gen -n 1500 -tree balanced -points random\n./gen -n 1500 -tree balanced -points circle\n./gen -n 1500 -tree chain -points random\n./gen -n 1500 -tree chain -points circle\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:19.087766",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "198/A",
      "title": "A. About Bacteria",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four space-separated integers k, b, n and t (1 ≤ k, b, n, t ≤ 106) — the parameters of bacterial growth, the time Qwerty needed to grow z bacteria in the first experiment and the initial number of bacteria in the second experiment, correspondingly.",
      "output_spec": "OutputPrint a single number — the minimum number of seconds Qwerty needs to grow at least z bacteria in the tube.",
      "sample_tests": "ExamplesInputCopy3 1 3 5OutputCopy2InputCopy1 4 4 7OutputCopy3InputCopy2 2 4 100OutputCopy0",
      "description": "A. About Bacteria\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains four space-separated integers k, b, n and t (1 ≤ k, b, n, t ≤ 106) — the parameters of bacterial growth, the time Qwerty needed to grow z bacteria in the first experiment and the initial number of bacteria in the second experiment, correspondingly.\n\nOutputPrint a single number — the minimum number of seconds Qwerty needs to grow at least z bacteria in the tube.\n\nInputCopy3 1 3 5OutputCopy2InputCopy1 4 4 7OutputCopy3InputCopy2 2 4 100OutputCopy0\n\nInputCopy3 1 3 5\n\nOutputCopy2\n\nInputCopy1 4 4 7\n\nOutputCopy3\n\nInputCopy2 2 4 100\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #125 - Codeforces",
          "content": "Hello everyone!There is yet another Codeforces round. Now it is the 53-th one.The round will run for both divisions by classic rules of Codeforces format.Points are standard: 500-1000-1500-2000-2500.Round was prepared by Ripatti , Alex_KPR , Gerald , Aksenov239 , RAD , Delinur .Good luck!UPD. Round is ended.Winners of div1:1. Petr2. tourist3. SergeyRogulenko4. bmerry5. UESTC_Nocturne Winners of div2:1. gflegar2. mylyanyk.ivan3. arbesfeld Petr is only who solved all 5 problems in the first division. No one solved all 5 problems in the second division.UPD. Editorial.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4757",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 571
        },
        {
          "title": "Codeforces Round #125 - Codeforces",
          "content": "Hello everyone!There is yet another Codeforces round. Now it is the 53-th one.The round will run for both divisions by classic rules of Codeforces format.Points are standard: 500-1000-1500-2000-2500.Round was prepared by Ripatti , Alex_KPR , Gerald , Aksenov239 , RAD , Delinur .Good luck!UPD. Round is ended.Winners of div1:1. Petr2. tourist3. SergeyRogulenko4. bmerry5. UESTC_Nocturne Winners of div2:1. gflegar2. mylyanyk.ivan3. arbesfeld Petr is only who solved all 5 problems in the first division. No one solved all 5 problems in the second division.UPD. Editorial.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4757",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 571
        },
        {
          "title": "Solutions for Codeforces Round #125 - Codeforces",
          "content": "Div2 A. You can just output \"0 0 n\". Author is Alex_KPR . Div2 B. You should check for every circle of one ring: it have intersections with another ring or not. So, there are 4 checks. There are 2 cases:1. circle is inside of ring;2. circle is outside of ring and ring is outside of circle;3. circle is outside of ring and ring is inside of circle.If at least one of these cases is performed, circle is good.You can easily do checks following way. Let us d be a distance between centers of ring and circle, r1 and R1 are inside and outside radii of ring, r be radius of circle. Then conditions for all cases will be1. d + r ≤ r1.2. r + R1 ≤ d.3. d + R1 ≤ r.You can check all conditions in integers using squares of distances. Author is Alex_KPR Div2 C. Div1 A.The first solution. Consider sequence a0 = 1, ai = ai - 1k + b:a0, a1, a2, ..., an = z.You can see that for all numbers from segment [a0, a1 - 1] you can number not less than z using exactly n steps. But for n - 1 steps you will bet number less than z. It works because transformation is monotonous. Analogically, for numbers from segments [a1, a2 - 1], [a2, a3 - 1], etc, you need exactly n - 1, n - 2, etc steps. So you just need find segment that contains number t. You can do it by generate a few first members of the sequence a. You need no more than t members. The second solution. Equation:tkx + b(kx - 1 + kx - 2... + 1) ≥ kn + b(kx - 1 + kx - 2... + 1)Using formula for geometric progression you can get:For k ≠ 1 we can multiply both sides by k - 1, (you can consider case k = 1 by yourself).t(k - 1)kx + bkx - b ≥ (k - 1)kn + bkn - b kx(t(k - 1) + b) ≥ kn(k - 1 + b) So, you can find value n - x using simply raising to a power.Authors are Gerald and RipattiDiv2 D. Div1 B. You should construct graph where vertices are areas of walls and edges are actions of ninja. Then you should run BFS with one modification: is you reach vertex later then water, you shouldn't do moves from this vertex.It is solution in O(n).Author is RipattiDiv2 E. Div1 C. If you can reach the planet in time t, you also can reach one in any time greater then t (you can just reach planet in time t and then move along with planet). There exists some t0 for that for all t > t0 you can reach planet, and for all t < t0 you cannot do in. Let us find t0 using binary search.Checking every of t inside of binary search you can do following way. You should calculate place if planet after time t and find distance between ship's place and new planet place.So, you have following \"classic\" problem: there are two points A and B and circle with center in O and radius R (points are outside of circle), you need find distance between points and you cannot moving inside of circle.There are 2 cases:1. You can move direct way2. You should skirt the circle The second case is performed iff two following conditions are performed:a. Angles OAB and OBA are acuteb. Height OH of triangle OAB less than RAll checks you can do in integers.Well, let's understand how to precess our cases:1. Obviously2. Let us C and D be tangency points (i.e. you are moving along line ACDB). Thiangles OAC and OBD are right and you can easily calculate all angles inside of them. Then you should find angle COD. After that you can find length of line ACDB. You can see that you don't need find places of points C and D.Author is RipattiDiv1 D. We will construct solution recursively. For every k it is possible construct parallelepiped k × k × (k + 1) that contains 2 cubes k × k × k. For k = 2 solution is obliviousо. How to build solutions for k > 2 is shown in following picture:Red and blue cubes are start and end of chain. Firstly you should build one floor over. Then you should build 2 layers on two opposite sides.For every n you can build parallelepiped n × n × (n + 1), and drop one layer for getting cube n × n × n.Author is RipattiDiv1 E. You can allocate all grippers as points on plane with coordinates (distance, mass). So, when you use some gripper, you are collecting grippers inside some rectangle with corner in origin. Let us collect grippers and put them into queue. For current gripper you should take all grippers from rectangle and store them into queue. Then you should take next gripper from queue and do some manipulations with them and so on. Well, now you need do it fast.Let us create segment tree (for example, there you can use Fenwick tree) for dimention \"distance\". In every vertex of that tree you should store stack of points ordered by \"mass\". More details: every vertex of segment tree is some range of coordinates, and you should store in thet vertex points only from this range. At the top of every stack should be point with minimal mass. Well, let us put all points into tree. Every position is covered by no more thenм segmetns, therefore all tree will require of memory.When you process query, you should extract points from some stacks and put them into queue. You can see that you may put some points into queue twice. To avoid this you should also put number of point into stack. So, when you are extracting point from stack you can check that it is the first extract using some array of flags.This solution works in .Author is Ripatti ; the above solution was proposed by RAD",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4764",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5239
        }
      ],
      "code_examples": [
        {
          "title": "Solutions for Codeforces Round #125 - Codeforces - Code 1",
          "code": "The input contains of a single integer n (0 ≤ n < 10^9) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4764",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000, \"b\");\n    inf.readSpace();\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000000, \"t\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000, \"b\");\n    inf.readSpace();\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000000, \"t\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000, \"b\");\n    inf.readSpace();\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000000, \"t\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_VAL = 1000000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int t_param = opt<int>(\"t\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    int k, b, t;\n\n    if (type == \"max\") {\n        k = MAX_VAL;\n        b = MAX_VAL;\n        t = t_param != -1 ? t_param : MAX_VAL;\n    } else if (type == \"kone\") {\n        k = 1;\n        b = rnd.next(1, MAX_VAL);\n        t = t_param != -1 ? t_param : rnd.next(1, MAX_VAL);\n    } else if (type == \"bzero\") {\n        k = rnd.next(1, MAX_VAL);\n        b = 0;\n        t = t_param != -1 ? t_param : rnd.next(1, MAX_VAL);\n    } else if (type == \"tgeqz\") {\n        k = rnd.next(1, MAX_VAL);\n        b = rnd.next(1, MAX_VAL);\n\n        // Compute z from first experiment\n        long long z = 1;\n        for (int i = 0; i < n; ++i) {\n            if (k > 0 && z > (LLONG_MAX - b) / k) {\n                z = LLONG_MAX;\n                break;\n            }\n            z = k * z + b;\n        }\n        t = t_param != -1 ? t_param : (int)min(z, (long long)MAX_VAL);\n    } else if (type == \"tlez\") {\n        k = rnd.next(1, MAX_VAL);\n        b = rnd.next(1, MAX_VAL);\n\n        // Compute z from first experiment\n        long long z = 1;\n        for (int i = 0; i < n; ++i) {\n            if (k > 0 && z > (LLONG_MAX - b) / k) {\n                z = LLONG_MAX;\n                break;\n            }\n            z = k * z + b;\n        }\n        long long maxT = min(z - 1, (long long)MAX_VAL);\n        if (maxT < 1) maxT = 1;\n        t = t_param != -1 ? t_param : rnd.next(1, (int)maxT);\n    } else if (type == \"overflows\") {\n        k = MAX_VAL;\n        b = MAX_VAL;\n        t = t_param != -1 ? t_param : 1;\n    } else if (type == \"special1\") {\n        k = 1;\n        b = 0;\n        t = t_param != -1 ? t_param : 1;\n    } else {\n        // Random type\n        k = rnd.next(1, MAX_VAL);\n        b = rnd.next(1, MAX_VAL);\n        t = t_param != -1 ? t_param : rnd.next(1, MAX_VAL);\n    }\n\n    // Output k, b, n, t\n    printf(\"%d %d %d %d\\n\", k, b, n, t);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_VAL = 1000000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int t_param = opt<int>(\"t\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    int k, b, t;\n\n    if (type == \"max\") {\n        k = MAX_VAL;\n        b = MAX_VAL;\n        t = t_param != -1 ? t_param : MAX_VAL;\n    } else if (type == \"kone\") {\n        k = 1;\n        b = rnd.next(1, MAX_VAL);\n        t = t_param != -1 ? t_param : rnd.next(1, MAX_VAL);\n    } else if (type == \"bzero\") {\n        k = rnd.next(1, MAX_VAL);\n        b = 0;\n        t = t_param != -1 ? t_param : rnd.next(1, MAX_VAL);\n    } else if (type == \"tgeqz\") {\n        k = rnd.next(1, MAX_VAL);\n        b = rnd.next(1, MAX_VAL);\n\n        // Compute z from first experiment\n        long long z = 1;\n        for (int i = 0; i < n; ++i) {\n            if (k > 0 && z > (LLONG_MAX - b) / k) {\n                z = LLONG_MAX;\n                break;\n            }\n            z = k * z + b;\n        }\n        t = t_param != -1 ? t_param : (int)min(z, (long long)MAX_VAL);\n    } else if (type == \"tlez\") {\n        k = rnd.next(1, MAX_VAL);\n        b = rnd.next(1, MAX_VAL);\n\n        // Compute z from first experiment\n        long long z = 1;\n        for (int i = 0; i < n; ++i) {\n            if (k > 0 && z > (LLONG_MAX - b) / k) {\n                z = LLONG_MAX;\n                break;\n            }\n            z = k * z + b;\n        }\n        long long maxT = min(z - 1, (long long)MAX_VAL);\n        if (maxT < 1) maxT = 1;\n        t = t_param != -1 ? t_param : rnd.next(1, (int)maxT);\n    } else if (type == \"overflows\") {\n        k = MAX_VAL;\n        b = MAX_VAL;\n        t = t_param != -1 ? t_param : 1;\n    } else if (type == \"special1\") {\n        k = 1;\n        b = 0;\n        t = t_param != -1 ? t_param : 1;\n    } else {\n        // Random type\n        k = rnd.next(1, MAX_VAL);\n        b = rnd.next(1, MAX_VAL);\n        t = t_param != -1 ? t_param : rnd.next(1, MAX_VAL);\n    }\n\n    // Output k, b, n, t\n    printf(\"%d %d %d %d\\n\", k, b, n, t);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type max\n./gen -n 1000000 -type max\n./gen -n 1 -type kone\n./gen -n 1000000 -type kone\n./gen -n 1 -type bzero\n./gen -n 1000000 -type bzero\n./gen -n 1 -type random\n./gen -n 1000000 -type random\n./gen -n 500000 -type tgeqz\n./gen -n 1000000 -type tgeqz\n./gen -n 1 -type tgeqz\n./gen -n 500000 -type tlez\n./gen -n 1000000 -type tlez\n./gen -n 1 -type tlez\n./gen -n 1 -type overflows\n./gen -n 1000000 -type overflows\n./gen -n 1 -type special1\n./gen -n 1000000 -type special1\n./gen -n 1000000 -type random\n./gen -n 999999 -type random\n./gen -n 1 -t 1 -type max\n./gen -n 500000 -t 1000000 -type tgeqz\n./gen -n 500000 -t 1 -type tlez\n./gen -n 1 -t 1000000 -type tgeqz\n./gen -n 1 -t 1 -type tlez\n./gen -n 1 -t 1 -type special1\n./gen -n 1000000 -t 1000000 -type special1\n./gen -n 500000 -t 500000 -type tlez\n./gen -n 500000 -t 500000 -type tgeqz\n./gen -n 500000 -t 500000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:21.323893",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "198/B",
      "title": "B. Прыжки по стенам",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n и k (1 ≤ n, k ≤ 105) — высота ущелья и высота прыжка ниндзя соответственно.Во второй строке задано описание левой стены — строка длиной n символов. i-ый символ обозначает состояние i-го участка стены: символ «X» обозначает, что участок опасен, символ «-» — что нет.В третьей строке задано описание правой стены в аналогичном формате.Гарантируется, что первый участок левой стены не опасен.",
      "output_spec": "Выходные данныеВыведите «YES» (без кавычек) если ниндзя может выбраться из ущелья или «NO» (без кавычек) в противном случае.",
      "sample_tests": "ПримерыВходные данныеСкопировать7 3---X--X-X--XX-Выходные данныеСкопироватьYESВходные данныеСкопировать6 2--X-X-X--XX-Выходные данныеСкопироватьNO",
      "description": "B. Прыжки по стенам\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n и k (1 ≤ n, k ≤ 105) — высота ущелья и высота прыжка ниндзя соответственно.Во второй строке задано описание левой стены — строка длиной n символов. i-ый символ обозначает состояние i-го участка стены: символ «X» обозначает, что участок опасен, символ «-» — что нет.В третьей строке задано описание правой стены в аналогичном формате.Гарантируется, что первый участок левой стены не опасен.\n\nВходные данные\n\nВыходные данныеВыведите «YES» (без кавычек) если ниндзя может выбраться из ущелья или «NO» (без кавычек) в противном случае.\n\nВыходные данные\n\nВходные данныеСкопировать7 3---X--X-X--XX-Выходные данныеСкопироватьYESВходные данныеСкопировать6 2--X-X-X--XX-Выходные данныеСкопироватьNO\n\nВходные данныеСкопировать7 3---X--X-X--XX-\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 2--X-X-X--XX-\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере сначала ниндзя должен перепрыгнуть на правую стену, потом спуститься вниз на один метр по правой стене, потом перепрыгнуть на левую стену. Следующим прыжком ниндзя может выпрыгнуть из ущелья.Во втором примере ниндзя никак не может выбраться из ущелья.",
      "solutions": [
        {
          "title": "Codeforces Round #125 - Codeforces",
          "content": "Привет всем!Сегодня очередной раунд на Codeforces, вот уже 53-ый.Раунд будет проходить для обоих дивизионов по классическим правилам формата Codeforces.Разбалловка стандартная: 500-1000-1500-2000-2500.В подготовке контеста участвовали Ripatti , Alex_KPR , Gerald , Aksenov239 , RAD , Delinur .Всем удачи!UPD. Раунд окончен.Победители div1:1. Petr2. tourist3. SergeyRogulenko4. bmerry5. UESTC_Nocturne Победители div2:1. gflegar2. mylyanyk.ivan3. arbesfeld Petr — единственный в первом дивизионе, решивший все 5 задач. Во втором дивизионе 5 задач не решил никто.UPD. Разбор задач.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4757",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 579
        },
        {
          "title": "Codeforces Round #125 - Codeforces",
          "content": "Привет всем!Сегодня очередной раунд на Codeforces, вот уже 53-ый.Раунд будет проходить для обоих дивизионов по классическим правилам формата Codeforces.Разбалловка стандартная: 500-1000-1500-2000-2500.В подготовке контеста участвовали Ripatti , Alex_KPR , Gerald , Aksenov239 , RAD , Delinur .Всем удачи!UPD. Раунд окончен.Победители div1:1. Petr2. tourist3. SergeyRogulenko4. bmerry5. UESTC_Nocturne Победители div2:1. gflegar2. mylyanyk.ivan3. arbesfeld Petr — единственный в первом дивизионе, решивший все 5 задач. Во втором дивизионе 5 задач не решил никто.UPD. Разбор задач.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4757",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 579
        },
        {
          "title": "Разбор задач Codeforces Round #125 - Codeforces",
          "content": "Div2 A. Для решения данной задачи достаточно вывести \"0 0 n\". Автор задачи — Alex_KPR . Div2 B. Для каждой окружности одного кольца нужно определить — имеет ли она пересечения с другим кольцом (касаться можно). Итого 4 проверки. Возможны 3 случая:1. окружность внутри кольца;2. окружность вне кольца и кольцо находится вне окружности;3. окружность вне кольца и кольцо находится внутри окружности.Если хотя бы одно из этих условий выполняется, то окружность хорошая.Проверку легко сделать следующим образом. Пусть d — расстояние между центрами кольца и окружности, r1 и R1 — внутренний и внешний радиусы кольца, r — радиус окружности. Тогда условия запишутся как1. d + r ≤ r1.2. r + R1 ≤ d.3. d + R1 ≤ r.Эти проверки удобно проводить в целых числах, используя квадраты расстояний. Автор задачи — Alex_KPR Div2 C. Div1 A.Первый вариант решения. Рассмотрим последовательность a0 = 1, ai = ai - 1k + b:a0, a1, a2, ..., an = z.Заметим, что для всех чисел из отрезка [a0, a1 - 1] ровно за n преобразований мы получим число не меньше z, однако за n - 1 преобразование мы получим число строго меньше z. Это верно из соображений монотонности функции преобразования. Аналогичные рассуждения можно применить и к числам из отрезков [a1, a2 - 1], [a2, a3 - 1] и так далее, только там будет n - 1, n - 2 шагов и так далее. Значит, для решения задачи, нам нужно узнать к какому из отрезков принадлежит число t. Это можно сделать просто сгенерировав несколько первых членов последовательности a. Не более чем через t шагов найдется подходящий отрезок. Второй вариант решения. Запишем уравнения в лоб:tkx + b(kx - 1 + kx - 2... + 1) ≥ kn + b(kx - 1 + kx - 2... + 1)Воспользуемся формулой для геометрической прогрессии:Далее считаем k ≠ 1, случай k = 1 удобно рассмотреть отдельно в самом начале (его разбирать не будем, он тривиален).t(k - 1)kx + bkx - b ≥ (k - 1)kn + bkn - b kx(t(k - 1) + b) ≥ kn(k - 1 + b) Итак, величину n - x можно найти простым возведением в степень \"пока не переполнится\".Авторы — Gerald и RipattiDiv2 D. Div1 B. Заведем граф, в котором вершинами являются участки стен, ребрами — возможные перемещения ниндзя и запустим на нем поиск в ширину (BFS) с одной модификацией: если мы добрались до некоторой вершины позже, чем до туда добралась вода, то оттуда не делаем ходов.Решение имеет сложность O(n).Автор — RipattiDiv2 E. Div1 C. Заметим, что если мы можем достичь планеты за некоторое время t, то мы можем достичь ее и за любое большее время (для этого достаточно достичь ее за время t, а затем просто перемещаться вместе с планетой). Понятно, что существует некоторое t0, для которого для всех t > t0 достичь планету можно, а для всех t < t0 — нельзя. Будем искать t0 при помощи бинпоиска.Проверку каждого из t внутри бинпоиска можно осуществлять следующим образом. Вычислим положение планеты через время t и найдем расстояние от корабля до этого нового положения.Задача свелась к следующей \"классической\" задаче: есть две точки A и B и круг с центром в O радиуса R (точки вне круга), нужно найти расстояние между точками, при этом в круг заходить нельзя.Возможны 2 случая:1. Можно пройти напрямую2. Следует огибать круг Второй случай выполняется тогда и только тогда, когда верны оба утверждения:a. Углы OAB и OBA острыеb. Высота OH меньше RВсе проверки можно сделать в целых числах.Теперь поймем как обработать случаи:1. Очевидно2. Пусть C и D — точки касания (т.е. мы должны двигаться по линии ACDB). Треугольники OAC и OBD — прямоугольные, там можно легко вычислить все углы, откуда легко найти угол COD. Дальше вычислить длину линии несложно. Заметим, что находить положения точек C и D совсем не обязательно.Автор — RipattiDiv1 D. Суть авторского решения в том, чтобы рекурсивно строить решения в виде параллелепипедов размера k × k × (k + 1), содержащих нужные 2 куба размера k × k × k. Для k = 2 решение очевидно. Далее решение расширятся в соответствии с картинкой:Красный и синий кубики — начало и конец цепи. Сначала мы надстраиваем один этаж сверху, а затем 2 слоя по бокам. Построения зависят от четности текущего k.Чтобы получить решение для n построим n × n × (n + 1), а потом просто отбросим один слой.Автор — RipattiDiv1 E. Расположим все захваты как точки на плоскости с координатами (расстояние, масса). Тогда, пользуясь некоторым захватом, мы можем собирать все захваты внутри некоторого прямоугольника с углом в начале координат. Будем собирать захваты и помещать их в очередь. Тогда для текущего захвата все захваты в прямоугольнике собраны — будем доставать следующий захват из очереди и делать манипуляции с ним. Осталось научиться делать запросы быстро.Заведем дерево отрезков (например, удобно использовать дерево Фенвика) по координате \"расстояние\", в каждой вершине которого будем хранить стек из точек, упорядоченных по координате \"масса\". Каждая вершина дерева отрезков есть некоторый диапазон координат, именно точки из этого диапазона будут храниться в данной вершине. На вершине каждого стека будет захват с наименьшей массой. Положим вначале все точки в это дерево отрезков. Так как каждая координата покрыта не более чем отрезками, всего это дерево будет использовать памяти.При выполнении запроса мы извлекаем из некоторых стеков точки с массой, не превышающей некоторого значения и помещаем их в очередь. Следует отметить, что одна и та же точка может находиться в разных стеках и мы можем случайно положить в очередь одну и ту же точку дважды. Чтобы избежать этого, можно вместе с точкой складывать в дерево отрезков ее номер. А при извлечении точки проверять первое это извлечение или нет в некотором массиве флагов по номеру.Итого решение имеет сложность .Автор — Ripatti ; описанное выше решение предложил RAD",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4764",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 5659
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #125 - Codeforces - Code 1",
          "code": "UPD. Надеюсь матч Германия-Греция поможет расслабиться тем кому контест не удался...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #125 - Codeforces - Code 2",
          "code": "UPD. Надеюсь матч Германия-Греция поможет расслабиться тем кому контест не удался...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #125 - Codeforces - Code 3",
          "code": "UPD. А вы считаете что когда решаешь 1 задачу(Div.2) это круто?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #125 - Codeforces - Code 4",
          "code": "public class TaskC {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n        int xp = in.nextInt();\n        int yp = in.nextInt();\n        int vp = in.nextInt();\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int v = in.nextInt();\n        int r = in.nextInt();\n        double R = Math.sqrt(xp * xp + yp * yp);\n        double left = 0;\n        double right = 1e7;\n        while ((right - left) / right > 1e-10) {\n            double middle = (left + right) / 2;\n            double alpha = middle / (R / vp);\n            double nx = xp * Math.cos(alpha) - yp * Math.sin(alpha);\n            double ny = xp * Math.sin(alpha) + yp * Math.cos(alpha);\n            double a = ny - y;\n            double b = x - nx;\n            double c = -(a * x + b * y);\n            double z = Math.sqrt(a * a + b * b);\n            a /= z;\n            b /= z;\n            c /= z;\n            double need;\n            if (Math.abs(c) < r - 1e-8) {\n                double mx = a * (-c);\n                double my = b * (-c);\n                if (dist(x, y, mx, my) + dist(mx, my, nx, ny) > dist(x, y, nx, ny) + 1e-8) {\n                    need = dist(x, y, nx, ny);\n                } else {\n                    need = catet(dist(x, y, 0, 0), r) + catet(dist(nx, ny, 0, 0), r);\n                    double alp = Math.abs(Math.atan2(y, x) - Math.atan2(ny, nx));\n                    if (alp > Math.PI) alp = 2 * Math.PI - alp;\n                    alp -= Math.acos(Math.min(1.0, r / dist(x, y, 0, 0)));\n                    alp -= Math.acos(Math.min(1.0, r / dist(nx, ny, 0, 0)));\n                    need += alp * r;\n                }\n            } else {\n                need = dist(x, y, nx, ny);\n            }\n            if (need / v <= middle)\n                right = middle;\n            else\n                left = middle;\n        }\n        out.println(right);\n\t}\n\n    private double catet(double a, int b) {\n        double z = a * a - b * b;\n        if (z < 1e-12) z = 0;\n        return Math.sqrt(z);\n    }\n\n    private double dist(double x1, double y1, double x2, double y2) {\n        double dx = x1 - x2;\n        double dy = y1 - y2;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #125 - Codeforces - Code 5",
          "code": "public class TaskC {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n        int xp = in.nextInt();\n        int yp = in.nextInt();\n        int vp = in.nextInt();\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int v = in.nextInt();\n        int r = in.nextInt();\n        double R = Math.sqrt(xp * xp + yp * yp);\n        double left = 0;\n        double right = 1e7;\n        while ((right - left) / right > 1e-10) {\n            double middle = (left + right) / 2;\n            double alpha = middle / (R / vp);\n            double nx = xp * Math.cos(alpha) - yp * Math.sin(alpha);\n            double ny = xp * Math.sin(alpha) + yp * Math.cos(alpha);\n            double a = ny - y;\n            double b = x - nx;\n            double c = -(a * x + b * y);\n            double z = Math.sqrt(a * a + b * b);\n            a /= z;\n            b /= z;\n            c /= z;\n            double need;\n            if (Math.abs(c) < r - 1e-8) {\n                double mx = a * (-c);\n                double my = b * (-c);\n                if (dist(x, y, mx, my) + dist(mx, my, nx, ny) > dist(x, y, nx, ny) + 1e-8) {\n                    need = dist(x, y, nx, ny);\n                } else {\n                    need = catet(dist(x, y, 0, 0), r) + catet(dist(nx, ny, 0, 0), r);\n                    double alp = Math.abs(Math.atan2(y, x) - Math.atan2(ny, nx));\n                    if (alp > Math.PI) alp = 2 * Math.PI - alp;\n                    alp -= Math.acos(Math.min(1.0, r / dist(x, y, 0, 0)));\n                    alp -= Math.acos(Math.min(1.0, r / dist(nx, ny, 0, 0)));\n                    need += alp * r;\n                }\n            } else {\n                need = dist(x, y, nx, ny);\n            }\n            if (need / v <= middle)\n                right = middle;\n            else\n                left = middle;\n        }\n        out.println(right);\n\t}\n\n    private double catet(double a, int b) {\n        double z = a * a - b * b;\n        if (z < 1e-12) z = 0;\n        return Math.sqrt(z);\n    }\n\n    private double dist(double x1, double y1, double x2, double y2) {\n        double dx = x1 - x2;\n        double dy = y1 - y2;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #125 - Codeforces - Code 1",
          "code": "UPD. Надеюсь матч Германия-Греция поможет расслабиться тем кому контест не удался...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #125 - Codeforces - Code 2",
          "code": "UPD. Надеюсь матч Германия-Греция поможет расслабиться тем кому контест не удался...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #125 - Codeforces - Code 3",
          "code": "UPD. А вы считаете что когда решаешь 1 задачу(Div.2) это круто?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #125 - Codeforces - Code 4",
          "code": "public class TaskC {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n        int xp = in.nextInt();\n        int yp = in.nextInt();\n        int vp = in.nextInt();\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int v = in.nextInt();\n        int r = in.nextInt();\n        double R = Math.sqrt(xp * xp + yp * yp);\n        double left = 0;\n        double right = 1e7;\n        while ((right - left) / right > 1e-10) {\n            double middle = (left + right) / 2;\n            double alpha = middle / (R / vp);\n            double nx = xp * Math.cos(alpha) - yp * Math.sin(alpha);\n            double ny = xp * Math.sin(alpha) + yp * Math.cos(alpha);\n            double a = ny - y;\n            double b = x - nx;\n            double c = -(a * x + b * y);\n            double z = Math.sqrt(a * a + b * b);\n            a /= z;\n            b /= z;\n            c /= z;\n            double need;\n            if (Math.abs(c) < r - 1e-8) {\n                double mx = a * (-c);\n                double my = b * (-c);\n                if (dist(x, y, mx, my) + dist(mx, my, nx, ny) > dist(x, y, nx, ny) + 1e-8) {\n                    need = dist(x, y, nx, ny);\n                } else {\n                    need = catet(dist(x, y, 0, 0), r) + catet(dist(nx, ny, 0, 0), r);\n                    double alp = Math.abs(Math.atan2(y, x) - Math.atan2(ny, nx));\n                    if (alp > Math.PI) alp = 2 * Math.PI - alp;\n                    alp -= Math.acos(Math.min(1.0, r / dist(x, y, 0, 0)));\n                    alp -= Math.acos(Math.min(1.0, r / dist(nx, ny, 0, 0)));\n                    need += alp * r;\n                }\n            } else {\n                need = dist(x, y, nx, ny);\n            }\n            if (need / v <= middle)\n                right = middle;\n            else\n                left = middle;\n        }\n        out.println(right);\n\t}\n\n    private double catet(double a, int b) {\n        double z = a * a - b * b;\n        if (z < 1e-12) z = 0;\n        return Math.sqrt(z);\n    }\n\n    private double dist(double x1, double y1, double x2, double y2) {\n        double dx = x1 - x2;\n        double dy = y1 - y2;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #125 - Codeforces - Code 5",
          "code": "public class TaskC {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n        int xp = in.nextInt();\n        int yp = in.nextInt();\n        int vp = in.nextInt();\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int v = in.nextInt();\n        int r = in.nextInt();\n        double R = Math.sqrt(xp * xp + yp * yp);\n        double left = 0;\n        double right = 1e7;\n        while ((right - left) / right > 1e-10) {\n            double middle = (left + right) / 2;\n            double alpha = middle / (R / vp);\n            double nx = xp * Math.cos(alpha) - yp * Math.sin(alpha);\n            double ny = xp * Math.sin(alpha) + yp * Math.cos(alpha);\n            double a = ny - y;\n            double b = x - nx;\n            double c = -(a * x + b * y);\n            double z = Math.sqrt(a * a + b * b);\n            a /= z;\n            b /= z;\n            c /= z;\n            double need;\n            if (Math.abs(c) < r - 1e-8) {\n                double mx = a * (-c);\n                double my = b * (-c);\n                if (dist(x, y, mx, my) + dist(mx, my, nx, ny) > dist(x, y, nx, ny) + 1e-8) {\n                    need = dist(x, y, nx, ny);\n                } else {\n                    need = catet(dist(x, y, 0, 0), r) + catet(dist(nx, ny, 0, 0), r);\n                    double alp = Math.abs(Math.atan2(y, x) - Math.atan2(ny, nx));\n                    if (alp > Math.PI) alp = 2 * Math.PI - alp;\n                    alp -= Math.acos(Math.min(1.0, r / dist(x, y, 0, 0)));\n                    alp -= Math.acos(Math.min(1.0, r / dist(nx, ny, 0, 0)));\n                    need += alp * r;\n                }\n            } else {\n                need = dist(x, y, nx, ny);\n            }\n            if (need / v <= middle)\n                right = middle;\n            else\n                left = middle;\n        }\n        out.println(right);\n\t}\n\n    private double catet(double a, int b) {\n        double z = a * a - b * b;\n        if (z < 1e-12) z = 0;\n        return Math.sqrt(z);\n    }\n\n    private double dist(double x1, double y1, double x2, double y2) {\n        double dx = x1 - x2;\n        double dy = y1 - y2;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/4757",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #125 - Codeforces - Code 1",
          "code": "The input contains of a single integer n (0 ≤ n < 10^9) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4764",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    string left = inf.readLine();\n    ensuref(int(left.size()) == n, \"Length of left wall string (%d) is not equal to n (%d)\", int(left.size()), n);\n    ensuref(left[0] == '-', \"The first area of the left wall is dangerous\");\n    for (char c : left) {\n        ensuref(c == 'X' || c == '-', \"Invalid character '%c' in left wall string\", c);\n    }\n\n    string right = inf.readLine();\n    ensuref(int(right.size()) == n, \"Length of right wall string (%d) is not equal to n (%d)\", int(right.size()), n);\n    for (char c : right) {\n        ensuref(c == 'X' || c == '-', \"Invalid character '%c' in right wall string\", c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    string left = inf.readLine();\n    ensuref(int(left.size()) == n, \"Length of left wall string (%d) is not equal to n (%d)\", int(left.size()), n);\n    ensuref(left[0] == '-', \"The first area of the left wall is dangerous\");\n    for (char c : left) {\n        ensuref(c == 'X' || c == '-', \"Invalid character '%c' in left wall string\", c);\n    }\n\n    string right = inf.readLine();\n    ensuref(int(right.size()) == n, \"Length of right wall string (%d) is not equal to n (%d)\", int(right.size()), n);\n    for (char c : right) {\n        ensuref(c == 'X' || c == '-', \"Invalid character '%c' in right wall string\", c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    string left = inf.readLine();\n    ensuref(int(left.size()) == n, \"Length of left wall string (%d) is not equal to n (%d)\", int(left.size()), n);\n    ensuref(left[0] == '-', \"The first area of the left wall is dangerous\");\n    for (char c : left) {\n        ensuref(c == 'X' || c == '-', \"Invalid character '%c' in left wall string\", c);\n    }\n\n    string right = inf.readLine();\n    ensuref(int(right.size()) == n, \"Length of right wall string (%d) is not equal to n (%d)\", int(right.size()), n);\n    for (char c : right) {\n        ensuref(c == 'X' || c == '-', \"Invalid character '%c' in right wall string\", c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\");\n    int dangerous_prob = opt<int>(\"d\", -1); // Dangerous cells probability\n\n    string left_wall(n, '-'), right_wall(n, '-');\n\n    if (type == \"all_safe\") {\n        left_wall.assign(n, '-');\n        right_wall.assign(n, '-');\n    } else if (type == \"all_dangerous\") {\n        left_wall.assign(n, 'X');\n        right_wall.assign(n, 'X');\n        left_wall[0] = '-'; // Ensure starting area is safe\n    } else if (type == \"random\") {\n        if (dangerous_prob == -1) dangerous_prob = 50;\n        left_wall[0] = '-'; // Ensure starting area is safe\n        for (int i = 1; i < n; ++i) {\n            left_wall[i] = rnd.next(100) < dangerous_prob ? 'X' : '-';\n            right_wall[i] = rnd.next(100) < dangerous_prob ? 'X' : '-';\n        }\n    } else if (type == \"impossible\") {\n        left_wall.assign(n, 'X');\n        right_wall.assign(n, 'X');\n        left_wall[0] = '-';\n    } else if (type == \"possible\") {\n        left_wall.assign(n, 'X');\n        right_wall.assign(n, 'X');\n        left_wall[0] = '-';\n        for (int i = 0; i < n; i += k) {\n            if ((i / k) % 2 == 0) {\n                left_wall[i] = '-';\n            } else {\n                right_wall[i] = '-';\n            }\n        }\n    } else if (type == \"need_jump\") {\n        left_wall.assign(n, 'X');\n        right_wall.assign(n, 'X');\n        left_wall[0] = '-';\n        for (int i = 0; i < n; i += k) {\n            if ((i / k) % 2 == 0) {\n                left_wall[i] = '-';\n            } else {\n                right_wall[i] = '-';\n            }\n        }\n    } else if (type == \"k1\") {\n        k = 1;\n        left_wall[0] = '-';\n        if (dangerous_prob == -1) dangerous_prob = 50;\n        for (int i = 1; i < n; ++i) {\n            left_wall[i] = rnd.next(100) < dangerous_prob ? 'X' : '-';\n            right_wall[i] = rnd.next(100) < dangerous_prob ? 'X' : '-';\n        }\n    } else if (type == \"kmax\") {\n        k = n;\n        left_wall[0] = '-';\n        if (dangerous_prob == -1) dangerous_prob = 50;\n        for (int i = 1; i < n; ++i) {\n            left_wall[i] = rnd.next(100) < dangerous_prob ? 'X' : '-';\n            right_wall[i] = rnd.next(100) < dangerous_prob ? 'X' : '-';\n        }\n    } else {\n        left_wall[0] = '-';\n        if (dangerous_prob == -1) dangerous_prob = 50;\n        for (int i = 1; i < n; ++i) {\n            left_wall[i] = rnd.next(100) < dangerous_prob ? 'X' : '-';\n            right_wall[i] = rnd.next(100) < dangerous_prob ? 'X' : '-';\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%s\\n\", left_wall.c_str());\n    printf(\"%s\\n\", right_wall.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\");\n    int dangerous_prob = opt<int>(\"d\", -1); // Dangerous cells probability\n\n    string left_wall(n, '-'), right_wall(n, '-');\n\n    if (type == \"all_safe\") {\n        left_wall.assign(n, '-');\n        right_wall.assign(n, '-');\n    } else if (type == \"all_dangerous\") {\n        left_wall.assign(n, 'X');\n        right_wall.assign(n, 'X');\n        left_wall[0] = '-'; // Ensure starting area is safe\n    } else if (type == \"random\") {\n        if (dangerous_prob == -1) dangerous_prob = 50;\n        left_wall[0] = '-'; // Ensure starting area is safe\n        for (int i = 1; i < n; ++i) {\n            left_wall[i] = rnd.next(100) < dangerous_prob ? 'X' : '-';\n            right_wall[i] = rnd.next(100) < dangerous_prob ? 'X' : '-';\n        }\n    } else if (type == \"impossible\") {\n        left_wall.assign(n, 'X');\n        right_wall.assign(n, 'X');\n        left_wall[0] = '-';\n    } else if (type == \"possible\") {\n        left_wall.assign(n, 'X');\n        right_wall.assign(n, 'X');\n        left_wall[0] = '-';\n        for (int i = 0; i < n; i += k) {\n            if ((i / k) % 2 == 0) {\n                left_wall[i] = '-';\n            } else {\n                right_wall[i] = '-';\n            }\n        }\n    } else if (type == \"need_jump\") {\n        left_wall.assign(n, 'X');\n        right_wall.assign(n, 'X');\n        left_wall[0] = '-';\n        for (int i = 0; i < n; i += k) {\n            if ((i / k) % 2 == 0) {\n                left_wall[i] = '-';\n            } else {\n                right_wall[i] = '-';\n            }\n        }\n    } else if (type == \"k1\") {\n        k = 1;\n        left_wall[0] = '-';\n        if (dangerous_prob == -1) dangerous_prob = 50;\n        for (int i = 1; i < n; ++i) {\n            left_wall[i] = rnd.next(100) < dangerous_prob ? 'X' : '-';\n            right_wall[i] = rnd.next(100) < dangerous_prob ? 'X' : '-';\n        }\n    } else if (type == \"kmax\") {\n        k = n;\n        left_wall[0] = '-';\n        if (dangerous_prob == -1) dangerous_prob = 50;\n        for (int i = 1; i < n; ++i) {\n            left_wall[i] = rnd.next(100) < dangerous_prob ? 'X' : '-';\n            right_wall[i] = rnd.next(100) < dangerous_prob ? 'X' : '-';\n        }\n    } else {\n        left_wall[0] = '-';\n        if (dangerous_prob == -1) dangerous_prob = 50;\n        for (int i = 1; i < n; ++i) {\n            left_wall[i] = rnd.next(100) < dangerous_prob ? 'X' : '-';\n            right_wall[i] = rnd.next(100) < dangerous_prob ? 'X' : '-';\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%s\\n\", left_wall.c_str());\n    printf(\"%s\\n\", right_wall.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -k 5 -type all_safe\n./gen -n 10 -k 5 -type all_dangerous\n./gen -n 10 -k 1 -type random -d 50\n./gen -n 10 -k 2 -type random -d 75\n./gen -n 10 -k 10 -type random -d 25\n\n./gen -n 1000 -k 500 -type all_safe\n./gen -n 1000 -k 500 -type all_dangerous\n./gen -n 1000 -k 1 -type random -d 50\n./gen -n 1000 -k 100 -type random -d 90\n./gen -n 1000 -k 1000 -type random -d 10\n\n./gen -n 100000 -k 50000 -type all_safe\n./gen -n 100000 -k 50000 -type all_dangerous\n./gen -n 100000 -k 1 -type random -d 50\n./gen -n 100000 -k 10000 -type random -d 90\n./gen -n 100000 -k 100000 -type random -d 10\n\n./gen -n 1 -k 1 -type all_safe\n./gen -n 1 -k 1 -type all_dangerous\n./gen -n 1 -k 1 -type random -d 50\n\n./gen -n 1000 -k 5 -type need_jump\n./gen -n 1000 -k 10 -type possible\n./gen -n 1000 -k 10 -type impossible\n\n./gen -n 1000 -k 1 -type k1\n\n./gen -n 1000 -k 1000 -type kmax\n\n./gen -n 100000 -k 1 -type random -d 50\n\n./gen -n 100000 -k 1 -type need_jump\n\n./gen -n 100000 -k 100000 -type random -d 50\n\n./gen -n 100000 -k 100000 -type possible\n\n./gen -n 100000 -k 500 -type random -d 0\n\n./gen -n 100000 -k 500 -type random -d 100\n\n./gen -n 99999 -k 99999 -type need_jump\n\n./gen -n 50000 -k 25000 -type random -d 30\n\n./gen -n 50000 -k 25000 -type random -d 70\n\n./gen -n 50000 -k 1 -type need_jump\n\n./gen -n 50000 -k 1 -type impossible\n\n./gen -n 50000 -k 50000 -type need_jump\n\n./gen -n 2 -k 1 -type possible\n\n./gen -n 2 -k 2 -type impossible\n\n./gen -n 100000 -k 2 -type possible\n\n./gen -n 100000 -k 2 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:23.146484",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "198/C",
      "title": "C. Delivering Carcinogen",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains space-separated integers xp, yp and vp ( - 104 ≤ xp, yp ≤ 104, 1 ≤ vp < 104) — Persephone's initial position and the speed at which it goes round Diatar.The second line contains space-separated integers x, y, v and r ( - 104 ≤ x, y ≤ 104, 1 < v ≤ 104, 1 ≤ r ≤ 104) — The intial position of Qwerty's ship, its maximum speed and the minimum safe distance to star Diatar.It is guaranteed that r2 < x2 + y2, r2 < xp2 + yp2 and vp < v.",
      "output_spec": "OutputPrint a single real number — the minimum possible delivery time. The answer will be considered valid if its absolute or relative error does not exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy10 0 1-10 0 2 8OutputCopy9.584544103InputCopy50 60 1050 60 20 40OutputCopy0.000000000",
      "description": "C. Delivering Carcinogen\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains space-separated integers xp, yp and vp ( - 104 ≤ xp, yp ≤ 104, 1 ≤ vp < 104) — Persephone's initial position and the speed at which it goes round Diatar.The second line contains space-separated integers x, y, v and r ( - 104 ≤ x, y ≤ 104, 1 < v ≤ 104, 1 ≤ r ≤ 104) — The intial position of Qwerty's ship, its maximum speed and the minimum safe distance to star Diatar.It is guaranteed that r2 < x2 + y2, r2 < xp2 + yp2 and vp < v.\n\nOutputPrint a single real number — the minimum possible delivery time. The answer will be considered valid if its absolute or relative error does not exceed 10 - 6.\n\nInputCopy10 0 1-10 0 2 8OutputCopy9.584544103InputCopy50 60 1050 60 20 40OutputCopy0.000000000\n\nInputCopy10 0 1-10 0 2 8\n\nOutputCopy9.584544103\n\nInputCopy50 60 1050 60 20 40\n\nOutputCopy0.000000000",
      "solutions": [
        {
          "title": "Codeforces Round #125 - Codeforces",
          "content": "Hello everyone!There is yet another Codeforces round. Now it is the 53-th one.The round will run for both divisions by classic rules of Codeforces format.Points are standard: 500-1000-1500-2000-2500.Round was prepared by Ripatti , Alex_KPR , Gerald , Aksenov239 , RAD , Delinur .Good luck!UPD. Round is ended.Winners of div1:1. Petr2. tourist3. SergeyRogulenko4. bmerry5. UESTC_Nocturne Winners of div2:1. gflegar2. mylyanyk.ivan3. arbesfeld Petr is only who solved all 5 problems in the first division. No one solved all 5 problems in the second division.UPD. Editorial.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4757",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 571
        },
        {
          "title": "Codeforces Round #125 - Codeforces",
          "content": "Hello everyone!There is yet another Codeforces round. Now it is the 53-th one.The round will run for both divisions by classic rules of Codeforces format.Points are standard: 500-1000-1500-2000-2500.Round was prepared by Ripatti , Alex_KPR , Gerald , Aksenov239 , RAD , Delinur .Good luck!UPD. Round is ended.Winners of div1:1. Petr2. tourist3. SergeyRogulenko4. bmerry5. UESTC_Nocturne Winners of div2:1. gflegar2. mylyanyk.ivan3. arbesfeld Petr is only who solved all 5 problems in the first division. No one solved all 5 problems in the second division.UPD. Editorial.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4757",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 571
        },
        {
          "title": "Solutions for Codeforces Round #125 - Codeforces",
          "content": "Div2 A. You can just output \"0 0 n\". Author is Alex_KPR . Div2 B. You should check for every circle of one ring: it have intersections with another ring or not. So, there are 4 checks. There are 2 cases:1. circle is inside of ring;2. circle is outside of ring and ring is outside of circle;3. circle is outside of ring and ring is inside of circle.If at least one of these cases is performed, circle is good.You can easily do checks following way. Let us d be a distance between centers of ring and circle, r1 and R1 are inside and outside radii of ring, r be radius of circle. Then conditions for all cases will be1. d + r ≤ r1.2. r + R1 ≤ d.3. d + R1 ≤ r.You can check all conditions in integers using squares of distances. Author is Alex_KPR Div2 C. Div1 A.The first solution. Consider sequence a0 = 1, ai = ai - 1k + b:a0, a1, a2, ..., an = z.You can see that for all numbers from segment [a0, a1 - 1] you can number not less than z using exactly n steps. But for n - 1 steps you will bet number less than z. It works because transformation is monotonous. Analogically, for numbers from segments [a1, a2 - 1], [a2, a3 - 1], etc, you need exactly n - 1, n - 2, etc steps. So you just need find segment that contains number t. You can do it by generate a few first members of the sequence a. You need no more than t members. The second solution. Equation:tkx + b(kx - 1 + kx - 2... + 1) ≥ kn + b(kx - 1 + kx - 2... + 1)Using formula for geometric progression you can get:For k ≠ 1 we can multiply both sides by k - 1, (you can consider case k = 1 by yourself).t(k - 1)kx + bkx - b ≥ (k - 1)kn + bkn - b kx(t(k - 1) + b) ≥ kn(k - 1 + b) So, you can find value n - x using simply raising to a power.Authors are Gerald and RipattiDiv2 D. Div1 B. You should construct graph where vertices are areas of walls and edges are actions of ninja. Then you should run BFS with one modification: is you reach vertex later then water, you shouldn't do moves from this vertex.It is solution in O(n).Author is RipattiDiv2 E. Div1 C. If you can reach the planet in time t, you also can reach one in any time greater then t (you can just reach planet in time t and then move along with planet). There exists some t0 for that for all t > t0 you can reach planet, and for all t < t0 you cannot do in. Let us find t0 using binary search.Checking every of t inside of binary search you can do following way. You should calculate place if planet after time t and find distance between ship's place and new planet place.So, you have following \"classic\" problem: there are two points A and B and circle with center in O and radius R (points are outside of circle), you need find distance between points and you cannot moving inside of circle.There are 2 cases:1. You can move direct way2. You should skirt the circle The second case is performed iff two following conditions are performed:a. Angles OAB and OBA are acuteb. Height OH of triangle OAB less than RAll checks you can do in integers.Well, let's understand how to precess our cases:1. Obviously2. Let us C and D be tangency points (i.e. you are moving along line ACDB). Thiangles OAC and OBD are right and you can easily calculate all angles inside of them. Then you should find angle COD. After that you can find length of line ACDB. You can see that you don't need find places of points C and D.Author is RipattiDiv1 D. We will construct solution recursively. For every k it is possible construct parallelepiped k × k × (k + 1) that contains 2 cubes k × k × k. For k = 2 solution is obliviousо. How to build solutions for k > 2 is shown in following picture:Red and blue cubes are start and end of chain. Firstly you should build one floor over. Then you should build 2 layers on two opposite sides.For every n you can build parallelepiped n × n × (n + 1), and drop one layer for getting cube n × n × n.Author is RipattiDiv1 E. You can allocate all grippers as points on plane with coordinates (distance, mass). So, when you use some gripper, you are collecting grippers inside some rectangle with corner in origin. Let us collect grippers and put them into queue. For current gripper you should take all grippers from rectangle and store them into queue. Then you should take next gripper from queue and do some manipulations with them and so on. Well, now you need do it fast.Let us create segment tree (for example, there you can use Fenwick tree) for dimention \"distance\". In every vertex of that tree you should store stack of points ordered by \"mass\". More details: every vertex of segment tree is some range of coordinates, and you should store in thet vertex points only from this range. At the top of every stack should be point with minimal mass. Well, let us put all points into tree. Every position is covered by no more thenм segmetns, therefore all tree will require of memory.When you process query, you should extract points from some stacks and put them into queue. You can see that you may put some points into queue twice. To avoid this you should also put number of point into stack. So, when you are extracting point from stack you can check that it is the first extract using some array of flags.This solution works in .Author is Ripatti ; the above solution was proposed by RAD",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4764",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5239
        }
      ],
      "code_examples": [
        {
          "title": "Solutions for Codeforces Round #125 - Codeforces - Code 1",
          "code": "The input contains of a single integer n (0 ≤ n < 10^9) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4764",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read xp, yp, vp\n    int xp = inf.readInt(-10000, 10000, \"xp\");\n    inf.readSpace();\n    int yp = inf.readInt(-10000, 10000, \"yp\");\n    inf.readSpace();\n    int vp = inf.readInt(1, 9999, \"vp\"); // Since vp < 10000\n    inf.readEoln();\n\n    // Read x, y, v, r\n    int x = inf.readInt(-10000, 10000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-10000, 10000, \"y\");\n    inf.readSpace();\n    int v = inf.readInt(2, 10000, \"v\"); // Since v > 1\n    inf.readSpace();\n    int r = inf.readInt(1, 10000, \"r\");\n    inf.readEoln();\n\n    // Ensure constraints\n    ensuref(vp < v, \"vp (%d) must be less than v (%d)\", vp, v);\n\n    long long rsq = 1LL * r * r;\n\n    long long xsq1 = 1LL * x * x + 1LL * y * y;\n    ensuref(rsq < xsq1, \"r^2 (%lld) must be less than x^2 + y^2 (%lld)\", rsq, xsq1);\n\n    long long xsq2 = 1LL * xp * xp + 1LL * yp * yp;\n    ensuref(rsq < xsq2, \"r^2 (%lld) must be less than xp^2 + yp^2 (%lld)\", rsq, xsq2);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read xp, yp, vp\n    int xp = inf.readInt(-10000, 10000, \"xp\");\n    inf.readSpace();\n    int yp = inf.readInt(-10000, 10000, \"yp\");\n    inf.readSpace();\n    int vp = inf.readInt(1, 9999, \"vp\"); // Since vp < 10000\n    inf.readEoln();\n\n    // Read x, y, v, r\n    int x = inf.readInt(-10000, 10000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-10000, 10000, \"y\");\n    inf.readSpace();\n    int v = inf.readInt(2, 10000, \"v\"); // Since v > 1\n    inf.readSpace();\n    int r = inf.readInt(1, 10000, \"r\");\n    inf.readEoln();\n\n    // Ensure constraints\n    ensuref(vp < v, \"vp (%d) must be less than v (%d)\", vp, v);\n\n    long long rsq = 1LL * r * r;\n\n    long long xsq1 = 1LL * x * x + 1LL * y * y;\n    ensuref(rsq < xsq1, \"r^2 (%lld) must be less than x^2 + y^2 (%lld)\", rsq, xsq1);\n\n    long long xsq2 = 1LL * xp * xp + 1LL * yp * yp;\n    ensuref(rsq < xsq2, \"r^2 (%lld) must be less than xp^2 + yp^2 (%lld)\", rsq, xsq2);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read xp, yp, vp\n    int xp = inf.readInt(-10000, 10000, \"xp\");\n    inf.readSpace();\n    int yp = inf.readInt(-10000, 10000, \"yp\");\n    inf.readSpace();\n    int vp = inf.readInt(1, 9999, \"vp\"); // Since vp < 10000\n    inf.readEoln();\n\n    // Read x, y, v, r\n    int x = inf.readInt(-10000, 10000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-10000, 10000, \"y\");\n    inf.readSpace();\n    int v = inf.readInt(2, 10000, \"v\"); // Since v > 1\n    inf.readSpace();\n    int r = inf.readInt(1, 10000, \"r\");\n    inf.readEoln();\n\n    // Ensure constraints\n    ensuref(vp < v, \"vp (%d) must be less than v (%d)\", vp, v);\n\n    long long rsq = 1LL * r * r;\n\n    long long xsq1 = 1LL * x * x + 1LL * y * y;\n    ensuref(rsq < xsq1, \"r^2 (%lld) must be less than x^2 + y^2 (%lld)\", rsq, xsq1);\n\n    long long xsq2 = 1LL * xp * xp + 1LL * yp * yp;\n    ensuref(rsq < xsq2, \"r^2 (%lld) must be less than xp^2 + yp^2 (%lld)\", rsq, xsq2);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int c = opt<int>(\"c\", 10000);\n\n    int xp, yp, vp;\n    int x, y, v, r;\n\n    if (type == \"random\") {\n        while (true) {\n            xp = rnd.next(-c, c);\n            yp = rnd.next(-c, c);\n            x = rnd.next(-c, c);\n            y = rnd.next(-c, c);\n            vp = rnd.next(1, 9998);\n            v = rnd.next(vp + 1, 10000);\n            r = rnd.next(1, c);\n\n            long long r2 = 1LL * r * r;\n            long long xpsq = 1LL * xp * xp + 1LL * yp * yp;\n            long long xsq = 1LL * x * x + 1LL * y * y;\n\n            if (r2 < xpsq && r2 < xsq)\n                break;\n        }\n    } else if (type == \"same_position\") {\n        while (true) {\n            xp = rnd.next(-c, c);\n            yp = rnd.next(-c, c);\n            x = xp;\n            y = yp;\n            vp = rnd.next(1, 9998);\n            v = rnd.next(vp + 1, 10000);\n            r = rnd.next(1, c);\n            long long r2 = 1LL * r * r;\n            long long xpsq = 1LL * xp * xp + 1LL * yp * yp;\n\n            if (r2 < xpsq)\n                break;\n        }\n    } else if (type == \"opposite_position\") {\n        int R = rnd.next(2, c);\n        r = rnd.next(1, R - 1);\n\n        int directions[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n        int idx = rnd.next(0, 3);\n\n        xp = R * directions[idx][0];\n        yp = R * directions[idx][1];\n        x = -xp;\n        y = -yp;\n\n        vp = rnd.next(1, 9998);\n        v = rnd.next(vp + 1, 10000);\n    } else if (type == \"far_away\") {\n        int R = rnd.next(2, c / 2);\n        r = rnd.next(1, R - 1);\n\n        int directions[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n        int idx1 = rnd.next(0, 3);\n        int idx2 = (idx1 + 2) % 4;\n\n        xp = R * directions[idx1][0];\n        yp = R * directions[idx1][1];\n\n        int d = rnd.next(c / 2, c);\n        x = d * directions[idx2][0];\n        y = d * directions[idx2][1];\n\n        vp = rnd.next(1, 9998);\n        v = rnd.next(vp + 1, 10000);\n    } else if (type == \"min_speed_gap\") {\n        while (true) {\n            vp = rnd.next(1, 9999);\n            v = vp + 1;\n            xp = rnd.next(-c, c);\n            yp = rnd.next(-c, c);\n            x = rnd.next(-c, c);\n            y = rnd.next(-c, c);\n            r = rnd.next(1, c);\n            long long r2 = 1LL * r * r;\n            long long xpsq = 1LL * xp * xp + 1LL * yp * yp;\n            long long xsq = 1LL * x * x + 1LL * y * y;\n\n            if (r2 < xpsq && r2 < xsq)\n                break;\n        }\n    } else if (type == \"orbit_radius_near_r\") {\n        r = rnd.next(1, c - 10);\n        int epsilon = rnd.next(1, 10);\n        int R = r + epsilon;\n\n        int directions[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n        int idx = rnd.next(0, 3);\n\n        xp = R * directions[idx][0];\n        yp = R * directions[idx][1];\n\n        while (true) {\n            x = rnd.next(-c, c);\n            y = rnd.next(-c, c);\n            long long xsq = 1LL * x * x + 1LL * y * y;\n            long long r2 = 1LL * r * r;\n            if (r2 < xsq)\n                break;\n        }\n\n        vp = rnd.next(1, 9998);\n        v = rnd.next(vp + 1, 10000);\n    }\n\n    printf(\"%d %d %d\\n\", xp, yp, vp);\n    printf(\"%d %d %d %d\\n\", x, y, v, r);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int c = opt<int>(\"c\", 10000);\n\n    int xp, yp, vp;\n    int x, y, v, r;\n\n    if (type == \"random\") {\n        while (true) {\n            xp = rnd.next(-c, c);\n            yp = rnd.next(-c, c);\n            x = rnd.next(-c, c);\n            y = rnd.next(-c, c);\n            vp = rnd.next(1, 9998);\n            v = rnd.next(vp + 1, 10000);\n            r = rnd.next(1, c);\n\n            long long r2 = 1LL * r * r;\n            long long xpsq = 1LL * xp * xp + 1LL * yp * yp;\n            long long xsq = 1LL * x * x + 1LL * y * y;\n\n            if (r2 < xpsq && r2 < xsq)\n                break;\n        }\n    } else if (type == \"same_position\") {\n        while (true) {\n            xp = rnd.next(-c, c);\n            yp = rnd.next(-c, c);\n            x = xp;\n            y = yp;\n            vp = rnd.next(1, 9998);\n            v = rnd.next(vp + 1, 10000);\n            r = rnd.next(1, c);\n            long long r2 = 1LL * r * r;\n            long long xpsq = 1LL * xp * xp + 1LL * yp * yp;\n\n            if (r2 < xpsq)\n                break;\n        }\n    } else if (type == \"opposite_position\") {\n        int R = rnd.next(2, c);\n        r = rnd.next(1, R - 1);\n\n        int directions[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n        int idx = rnd.next(0, 3);\n\n        xp = R * directions[idx][0];\n        yp = R * directions[idx][1];\n        x = -xp;\n        y = -yp;\n\n        vp = rnd.next(1, 9998);\n        v = rnd.next(vp + 1, 10000);\n    } else if (type == \"far_away\") {\n        int R = rnd.next(2, c / 2);\n        r = rnd.next(1, R - 1);\n\n        int directions[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n        int idx1 = rnd.next(0, 3);\n        int idx2 = (idx1 + 2) % 4;\n\n        xp = R * directions[idx1][0];\n        yp = R * directions[idx1][1];\n\n        int d = rnd.next(c / 2, c);\n        x = d * directions[idx2][0];\n        y = d * directions[idx2][1];\n\n        vp = rnd.next(1, 9998);\n        v = rnd.next(vp + 1, 10000);\n    } else if (type == \"min_speed_gap\") {\n        while (true) {\n            vp = rnd.next(1, 9999);\n            v = vp + 1;\n            xp = rnd.next(-c, c);\n            yp = rnd.next(-c, c);\n            x = rnd.next(-c, c);\n            y = rnd.next(-c, c);\n            r = rnd.next(1, c);\n            long long r2 = 1LL * r * r;\n            long long xpsq = 1LL * xp * xp + 1LL * yp * yp;\n            long long xsq = 1LL * x * x + 1LL * y * y;\n\n            if (r2 < xpsq && r2 < xsq)\n                break;\n        }\n    } else if (type == \"orbit_radius_near_r\") {\n        r = rnd.next(1, c - 10);\n        int epsilon = rnd.next(1, 10);\n        int R = r + epsilon;\n\n        int directions[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n        int idx = rnd.next(0, 3);\n\n        xp = R * directions[idx][0];\n        yp = R * directions[idx][1];\n\n        while (true) {\n            x = rnd.next(-c, c);\n            y = rnd.next(-c, c);\n            long long xsq = 1LL * x * x + 1LL * y * y;\n            long long r2 = 1LL * r * r;\n            if (r2 < xsq)\n                break;\n        }\n\n        vp = rnd.next(1, 9998);\n        v = rnd.next(vp + 1, 10000);\n    }\n\n    printf(\"%d %d %d\\n\", xp, yp, vp);\n    printf(\"%d %d %d %d\\n\", x, y, v, r);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random -c 1000\n./gen -type random -c 100000\n\n./gen -type same_position\n./gen -type same_position -c 1000\n./gen -type same_position -c 100000\n\n./gen -type opposite_position\n./gen -type opposite_position -c 1000\n./gen -type opposite_position -c 100000\n\n./gen -type far_away\n./gen -type far_away -c 1000\n./gen -type far_away -c 100000\n\n./gen -type min_speed_gap\n./gen -type min_speed_gap -c 1000\n./gen -type min_speed_gap -c 100000\n\n./gen -type orbit_radius_near_r\n./gen -type orbit_radius_near_r -c 1000\n./gen -type orbit_radius_near_r -c 100000\n\n# Generate multiple test cases for each type\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type same_position\n./gen -type same_position\n./gen -type same_position\n\n./gen -type opposite_position\n./gen -type opposite_position\n./gen -type opposite_position\n\n./gen -type far_away\n./gen -type far_away\n./gen -type far_away\n\n./gen -type min_speed_gap\n./gen -type min_speed_gap\n./gen -type min_speed_gap\n\n./gen -type orbit_radius_near_r\n./gen -type orbit_radius_near_r\n./gen -type orbit_radius_near_r\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:25.215723",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "198/D",
      "title": "D. Cube Snake",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 50) — the size of the cube, whose unit cubes need to be numbered.",
      "output_spec": "OutputPrint all layers of the cube as n n × n matrices. Separate them with new lines. Print the layers in the order in which they follow in the cube. See the samples for clarifications. It is guaranteed that there always is a solution that meets the conditions given in the problem statement.",
      "sample_tests": "ExamplesInputCopy3OutputCopy1 4 17 2 3 18 27 26 19 8 5 16 7 6 15 24 25 20 9 12 13 10 11 14 23 22 21",
      "description": "D. Cube Snake\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 50) — the size of the cube, whose unit cubes need to be numbered.\n\nOutputPrint all layers of the cube as n n × n matrices. Separate them with new lines. Print the layers in the order in which they follow in the cube. See the samples for clarifications. It is guaranteed that there always is a solution that meets the conditions given in the problem statement.\n\nInputCopy3OutputCopy1 4 17 2 3 18 27 26 19 8 5 16 7 6 15 24 25 20 9 12 13 10 11 14 23 22 21\n\nOutputCopy1 4 17 2 3 18 27 26 19 8 5 16 7 6 15 24 25 20 9 12 13 10 11 14 23 22 21\n\nNoteIn the sample the cubes with sizes 2 × 2 × 2 are numbered with integers 1, ..., 8 and 5, ..., 12.",
      "solutions": [
        {
          "title": "Codeforces Round #125 - Codeforces",
          "content": "Hello everyone!There is yet another Codeforces round. Now it is the 53-th one.The round will run for both divisions by classic rules of Codeforces format.Points are standard: 500-1000-1500-2000-2500.Round was prepared by Ripatti , Alex_KPR , Gerald , Aksenov239 , RAD , Delinur .Good luck!UPD. Round is ended.Winners of div1:1. Petr2. tourist3. SergeyRogulenko4. bmerry5. UESTC_Nocturne Winners of div2:1. gflegar2. mylyanyk.ivan3. arbesfeld Petr is only who solved all 5 problems in the first division. No one solved all 5 problems in the second division.UPD. Editorial.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4757",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 571
        },
        {
          "title": "Codeforces Round #125 - Codeforces",
          "content": "Hello everyone!There is yet another Codeforces round. Now it is the 53-th one.The round will run for both divisions by classic rules of Codeforces format.Points are standard: 500-1000-1500-2000-2500.Round was prepared by Ripatti , Alex_KPR , Gerald , Aksenov239 , RAD , Delinur .Good luck!UPD. Round is ended.Winners of div1:1. Petr2. tourist3. SergeyRogulenko4. bmerry5. UESTC_Nocturne Winners of div2:1. gflegar2. mylyanyk.ivan3. arbesfeld Petr is only who solved all 5 problems in the first division. No one solved all 5 problems in the second division.UPD. Editorial.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4757",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 571
        },
        {
          "title": "Solutions for Codeforces Round #125 - Codeforces",
          "content": "Div2 A. You can just output \"0 0 n\". Author is Alex_KPR . Div2 B. You should check for every circle of one ring: it have intersections with another ring or not. So, there are 4 checks. There are 2 cases:1. circle is inside of ring;2. circle is outside of ring and ring is outside of circle;3. circle is outside of ring and ring is inside of circle.If at least one of these cases is performed, circle is good.You can easily do checks following way. Let us d be a distance between centers of ring and circle, r1 and R1 are inside and outside radii of ring, r be radius of circle. Then conditions for all cases will be1. d + r ≤ r1.2. r + R1 ≤ d.3. d + R1 ≤ r.You can check all conditions in integers using squares of distances. Author is Alex_KPR Div2 C. Div1 A.The first solution. Consider sequence a0 = 1, ai = ai - 1k + b:a0, a1, a2, ..., an = z.You can see that for all numbers from segment [a0, a1 - 1] you can number not less than z using exactly n steps. But for n - 1 steps you will bet number less than z. It works because transformation is monotonous. Analogically, for numbers from segments [a1, a2 - 1], [a2, a3 - 1], etc, you need exactly n - 1, n - 2, etc steps. So you just need find segment that contains number t. You can do it by generate a few first members of the sequence a. You need no more than t members. The second solution. Equation:tkx + b(kx - 1 + kx - 2... + 1) ≥ kn + b(kx - 1 + kx - 2... + 1)Using formula for geometric progression you can get:For k ≠ 1 we can multiply both sides by k - 1, (you can consider case k = 1 by yourself).t(k - 1)kx + bkx - b ≥ (k - 1)kn + bkn - b kx(t(k - 1) + b) ≥ kn(k - 1 + b) So, you can find value n - x using simply raising to a power.Authors are Gerald and RipattiDiv2 D. Div1 B. You should construct graph where vertices are areas of walls and edges are actions of ninja. Then you should run BFS with one modification: is you reach vertex later then water, you shouldn't do moves from this vertex.It is solution in O(n).Author is RipattiDiv2 E. Div1 C. If you can reach the planet in time t, you also can reach one in any time greater then t (you can just reach planet in time t and then move along with planet). There exists some t0 for that for all t > t0 you can reach planet, and for all t < t0 you cannot do in. Let us find t0 using binary search.Checking every of t inside of binary search you can do following way. You should calculate place if planet after time t and find distance between ship's place and new planet place.So, you have following \"classic\" problem: there are two points A and B and circle with center in O and radius R (points are outside of circle), you need find distance between points and you cannot moving inside of circle.There are 2 cases:1. You can move direct way2. You should skirt the circle The second case is performed iff two following conditions are performed:a. Angles OAB and OBA are acuteb. Height OH of triangle OAB less than RAll checks you can do in integers.Well, let's understand how to precess our cases:1. Obviously2. Let us C and D be tangency points (i.e. you are moving along line ACDB). Thiangles OAC and OBD are right and you can easily calculate all angles inside of them. Then you should find angle COD. After that you can find length of line ACDB. You can see that you don't need find places of points C and D.Author is RipattiDiv1 D. We will construct solution recursively. For every k it is possible construct parallelepiped k × k × (k + 1) that contains 2 cubes k × k × k. For k = 2 solution is obliviousо. How to build solutions for k > 2 is shown in following picture:Red and blue cubes are start and end of chain. Firstly you should build one floor over. Then you should build 2 layers on two opposite sides.For every n you can build parallelepiped n × n × (n + 1), and drop one layer for getting cube n × n × n.Author is RipattiDiv1 E. You can allocate all grippers as points on plane with coordinates (distance, mass). So, when you use some gripper, you are collecting grippers inside some rectangle with corner in origin. Let us collect grippers and put them into queue. For current gripper you should take all grippers from rectangle and store them into queue. Then you should take next gripper from queue and do some manipulations with them and so on. Well, now you need do it fast.Let us create segment tree (for example, there you can use Fenwick tree) for dimention \"distance\". In every vertex of that tree you should store stack of points ordered by \"mass\". More details: every vertex of segment tree is some range of coordinates, and you should store in thet vertex points only from this range. At the top of every stack should be point with minimal mass. Well, let us put all points into tree. Every position is covered by no more thenм segmetns, therefore all tree will require of memory.When you process query, you should extract points from some stacks and put them into queue. You can see that you may put some points into queue twice. To avoid this you should also put number of point into stack. So, when you are extracting point from stack you can check that it is the first extract using some array of flags.This solution works in .Author is Ripatti ; the above solution was proposed by RAD",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/4764",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5239
        }
      ],
      "code_examples": [
        {
          "title": "Solutions for Codeforces Round #125 - Codeforces - Code 1",
          "code": "The input contains of a single integer n (0 ≤ n < 10^9) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4764",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 50;\nconst int MAX_N3 = MAX_N * MAX_N * MAX_N;\n\nstruct Pos {\n    int x, y, z;\n};\n\nint n;\nvector<vector<vector<int>>> cube;\nvector<Pos> num_pos;\nvector<int> used;\n\nint dx[6] = {1, -1, 0, 0, 0, 0};\nint dy[6] = {0, 0, 1, -1, 0, 0};\nint dz[6] = {0, 0, 0, 0, 1, -1};\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, 50);\n    int n3 = n * n * n;\n\n    // Initialize\n    cube.resize(n, vector<vector<int>>(n, vector<int>(n, 0)));\n    num_pos.resize(n3 + 1);\n    used.resize(n3 + 1, 0);\n\n    // Read participant's output\n    vector<int> nums = ouf.readInts(n3, 1, n3, \"numbers\");\n    // Check for extra output\n    if (!ouf.seekEof())\n        ouf.quitf(_wa, \"Extra data in output\");\n\n    // Fill the cube and record positions\n    for (int idx = 0; idx < n3; ++idx) {\n        int num = nums[idx];\n        if (used[num])\n            ouf.quitf(_wa, \"Number %d occurs more than once\", num);\n        used[num] = 1;\n        int total_idx = idx;\n        int k = total_idx / (n * n);\n        int tmp = total_idx % (n * n);\n        int i = tmp / n;\n        int j = tmp % n;\n        cube[k][i][j] = num;\n        num_pos[num] = {k, i, j};\n    }\n\n    // Check that each number from 1 to n^3 is used exactly once\n    for (int num = 1; num <= n3; ++num) {\n        if (!used[num])\n            ouf.quitf(_wa, \"Number %d is missing\", num);\n    }\n\n    // Check that consecutive numbers are on neighbouring cubes\n    for (int num = 1; num < n3; ++num) {\n        Pos p1 = num_pos[num];\n        Pos p2 = num_pos[num + 1];\n        bool adjacent = false;\n        for (int d = 0; d < 6; ++d) {\n            int nx = p1.x + dx[d];\n            int ny = p1.y + dy[d];\n            int nz = p1.z + dz[d];\n            if (nx == p2.x && ny == p2.y && nz == p2.z) {\n                adjacent = true;\n                break;\n            }\n        }\n        if (!adjacent) {\n            ouf.quitf(_wa, \"Numbers %d and %d are not on neighbouring cubes\", num, num + 1);\n        }\n    }\n\n    // Check for each size t from 1 to n - 1\n    for (int t = 1; t < n; ++t) {\n        int found = 0;\n        set<pair<int, int>> positions;\n        for (int x = 0; x <= n - t; ++x) {\n            for (int y = 0; y <= n - t; ++y) {\n                for (int z = 0; z <= n - t; ++z) {\n                    vector<int> nums_in_subcube;\n                    for (int k = x; k < x + t; ++k) {\n                        for (int i = y; i < y + t; ++i) {\n                            for (int j = z; j < z + t; ++j) {\n                                nums_in_subcube.push_back(cube[k][i][j]);\n                            }\n                        }\n                    }\n                    int t3 = t * t * t;\n                    int min_num = *min_element(nums_in_subcube.begin(), nums_in_subcube.end());\n                    int max_num = *max_element(nums_in_subcube.begin(), nums_in_subcube.end());\n                    if (max_num - min_num + 1 != t3)\n                        continue;\n                    vector<bool> seen(t3, false);\n                    bool is_consecutive = true;\n                    for (int num : nums_in_subcube) {\n                        int idx = num - min_num;\n                        if (idx < 0 || idx >= t3 || seen[idx]) {\n                            is_consecutive = false;\n                            break;\n                        }\n                        seen[idx] = true;\n                    }\n                    if (is_consecutive) {\n                        pair<int, int> pos = {min_num, x * n * n + y * n + z};\n                        if (positions.count(pos) == 0) {\n                            positions.insert(pos);\n                            found++;\n                            if (found >= 2)\n                                goto FOUND_T;\n                        }\n                    }\n                }\n            }\n        }\n        FOUND_T:\n        if (found < 2) {\n            ouf.quitf(_wa, \"For size %d, fewer than two consecutively numbered subcubes were found\", t);\n        }\n    }\n\n    quitf(_ok, \"Correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n;\n    string type = opt<string>(\"type\", \"random\");\n    int nmin = opt<int>(\"nmin\", 1);\n    int nmax = opt<int>(\"nmax\", 50);\n\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 50;\n    } else if (type == \"small\") {\n        n = rnd.next(nmin, min(5, nmax));\n    } else if (type == \"odd\") {\n        vector<int> possible_n;\n        for(int i = nmin; i <= nmax; i++)\n            if (i % 2 == 1)\n                possible_n.push_back(i);\n        if(possible_n.empty()) {\n            n = nmin; // default to nmin if no odd numbers\n        } else {\n            n = possible_n[rnd.next(0, (int)possible_n.size() - 1)];\n        }\n    } else if (type == \"even\") {\n        vector<int> possible_n;\n        for(int i = nmin; i <= nmax; i++)\n            if (i % 2 == 0)\n                possible_n.push_back(i);\n        if(possible_n.empty()) {\n            n = nmin; // default to nmin if no even numbers\n        } else {\n            n = possible_n[rnd.next(0, (int)possible_n.size() - 1)];\n        }\n    } else if (type == \"specified\") {\n        n = opt<int>(\"n\");\n    } else if (type == \"random\") {\n        n = rnd.next(nmin, nmax);\n    } else {\n        n = rnd.next(nmin, nmax);\n    }\n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n;\n    string type = opt<string>(\"type\", \"random\");\n    int nmin = opt<int>(\"nmin\", 1);\n    int nmax = opt<int>(\"nmax\", 50);\n\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 50;\n    } else if (type == \"small\") {\n        n = rnd.next(nmin, min(5, nmax));\n    } else if (type == \"odd\") {\n        vector<int> possible_n;\n        for(int i = nmin; i <= nmax; i++)\n            if (i % 2 == 1)\n                possible_n.push_back(i);\n        if(possible_n.empty()) {\n            n = nmin; // default to nmin if no odd numbers\n        } else {\n            n = possible_n[rnd.next(0, (int)possible_n.size() - 1)];\n        }\n    } else if (type == \"even\") {\n        vector<int> possible_n;\n        for(int i = nmin; i <= nmax; i++)\n            if (i % 2 == 0)\n                possible_n.push_back(i);\n        if(possible_n.empty()) {\n            n = nmin; // default to nmin if no even numbers\n        } else {\n            n = possible_n[rnd.next(0, (int)possible_n.size() - 1)];\n        }\n    } else if (type == \"specified\") {\n        n = opt<int>(\"n\");\n    } else if (type == \"random\") {\n        n = rnd.next(nmin, nmax);\n    } else {\n        n = rnd.next(nmin, nmax);\n    }\n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type small\n./gen -type small -nmax 5\n./gen -type small -nmax 10\n./gen -type specified -n 1\n./gen -type specified -n 2\n./gen -type specified -n 3\n./gen -type specified -n 4\n./gen -type specified -n 5\n./gen -type specified -n 10\n./gen -type specified -n 25\n./gen -type specified -n 49\n./gen -type specified -n 50\n./gen -type odd\n./gen -type odd -nmin 1 -nmax 50\n./gen -type even\n./gen -type even -nmin 1 -nmax 50\n./gen -type random\n./gen -type random -nmin 1 -nmax 50\n./gen -type random -nmin 1 -nmax 10\n./gen -type random -nmin 10 -nmax 20\n./gen -type random -nmin 20 -nmax 30\n./gen -type random -nmin 30 -nmax 40\n./gen -type random -nmin 40 -nmax 50\n./gen -type random -nmin 45 -nmax 50\n./gen -type random -nmin 1 -nmax 1\n./gen -type random -nmin 50 -nmax 50\n./gen -type random -nmin 25 -nmax 25\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:27.155259",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "198/E",
      "title": "E. Gripping Story",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains five integers x, y, p, r and n ( - 109 ≤ x, y ≤ 109, 1 ≤ p, r ≤ 109, 1 ≤ n ≤ 250000) — the ship's initial position, the initial gripper's features and the number of grippers that got into the space during the collision.Next n lines contain the grippers' descriptions: the i-th line contains five integers xi, yi, mi, pi, ri ( - 109 ≤ xi, yi ≤ 109, 1 ≤ mi, pi, ri ≤ 109) — the i-th gripper's coordinates and features.It is guaranteed that all grippers are located at different points. No gripper is located at the same point with Qwerty's ship.",
      "output_spec": "OutputPrint a single number — the maximum number of grippers Qwerty can draw to his ship. You do not need to count the initial old magnet gripper.",
      "sample_tests": "ExamplesInputCopy0 0 5 10 55 4 7 11 5-7 1 4 7 80 2 13 5 62 -3 9 3 413 5 1 9 9OutputCopy3",
      "description": "E. Gripping Story\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains five integers x, y, p, r and n ( - 109 ≤ x, y ≤ 109, 1 ≤ p, r ≤ 109, 1 ≤ n ≤ 250000) — the ship's initial position, the initial gripper's features and the number of grippers that got into the space during the collision.Next n lines contain the grippers' descriptions: the i-th line contains five integers xi, yi, mi, pi, ri ( - 109 ≤ xi, yi ≤ 109, 1 ≤ mi, pi, ri ≤ 109) — the i-th gripper's coordinates and features.It is guaranteed that all grippers are located at different points. No gripper is located at the same point with Qwerty's ship.\n\nOutputPrint a single number — the maximum number of grippers Qwerty can draw to his ship. You do not need to count the initial old magnet gripper.\n\nInputCopy0 0 5 10 55 4 7 11 5-7 1 4 7 80 2 13 5 62 -3 9 3 413 5 1 9 9OutputCopy3\n\nInputCopy0 0 5 10 55 4 7 11 5-7 1 4 7 80 2 13 5 62 -3 9 3 413 5 1 9 9\n\nOutputCopy3\n\nNoteIn the first sample you should get the second gripper, then use the second gripper to get the first one, then use the first gripper to get the fourth one. You cannot get neither the third gripper as it is too heavy, nor the fifth one as it is too far away.",
      "solutions": [
        {
          "title": "Codeforces Round #125 - Codeforces",
          "content": "Hello everyone!There is yet another Codeforces round. Now it is the 53-th one.The round will run for both divisions by classic rules of Codeforces format.Points are standard: 500-1000-1500-2000-2500.Round was prepared by Ripatti , Alex_KPR , Gerald , Aksenov239 , RAD , Delinur .Good luck!UPD. Round is ended.Winners of div1:1. Petr2. tourist3. SergeyRogulenko4. bmerry5. UESTC_Nocturne Winners of div2:1. gflegar2. mylyanyk.ivan3. arbesfeld Petr is only who solved all 5 problems in the first division. No one solved all 5 problems in the second division.UPD. Editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4757",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 571
        },
        {
          "title": "Codeforces Round #125 - Codeforces",
          "content": "Hello everyone!There is yet another Codeforces round. Now it is the 53-th one.The round will run for both divisions by classic rules of Codeforces format.Points are standard: 500-1000-1500-2000-2500.Round was prepared by Ripatti , Alex_KPR , Gerald , Aksenov239 , RAD , Delinur .Good luck!UPD. Round is ended.Winners of div1:1. Petr2. tourist3. SergeyRogulenko4. bmerry5. UESTC_Nocturne Winners of div2:1. gflegar2. mylyanyk.ivan3. arbesfeld Petr is only who solved all 5 problems in the first division. No one solved all 5 problems in the second division.UPD. Editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4757",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 571
        },
        {
          "title": "Solutions for Codeforces Round #125 - Codeforces",
          "content": "Div2 A. You can just output \"0 0 n\". Author is Alex_KPR . Div2 B. You should check for every circle of one ring: it have intersections with another ring or not. So, there are 4 checks. There are 2 cases:1. circle is inside of ring;2. circle is outside of ring and ring is outside of circle;3. circle is outside of ring and ring is inside of circle.If at least one of these cases is performed, circle is good.You can easily do checks following way. Let us d be a distance between centers of ring and circle, r1 and R1 are inside and outside radii of ring, r be radius of circle. Then conditions for all cases will be1. d + r ≤ r1.2. r + R1 ≤ d.3. d + R1 ≤ r.You can check all conditions in integers using squares of distances. Author is Alex_KPR Div2 C. Div1 A.The first solution. Consider sequence a0 = 1, ai = ai - 1k + b:a0, a1, a2, ..., an = z.You can see that for all numbers from segment [a0, a1 - 1] you can number not less than z using exactly n steps. But for n - 1 steps you will bet number less than z. It works because transformation is monotonous. Analogically, for numbers from segments [a1, a2 - 1], [a2, a3 - 1], etc, you need exactly n - 1, n - 2, etc steps. So you just need find segment that contains number t. You can do it by generate a few first members of the sequence a. You need no more than t members. The second solution. Equation:tkx + b(kx - 1 + kx - 2... + 1) ≥ kn + b(kx - 1 + kx - 2... + 1)Using formula for geometric progression you can get:For k ≠ 1 we can multiply both sides by k - 1, (you can consider case k = 1 by yourself).t(k - 1)kx + bkx - b ≥ (k - 1)kn + bkn - b kx(t(k - 1) + b) ≥ kn(k - 1 + b) So, you can find value n - x using simply raising to a power.Authors are Gerald and RipattiDiv2 D. Div1 B. You should construct graph where vertices are areas of walls and edges are actions of ninja. Then you should run BFS with one modification: is you reach vertex later then water, you shouldn't do moves from this vertex.It is solution in O(n).Author is RipattiDiv2 E. Div1 C. If you can reach the planet in time t, you also can reach one in any time greater then t (you can just reach planet in time t and then move along with planet). There exists some t0 for that for all t > t0 you can reach planet, and for all t < t0 you cannot do in. Let us find t0 using binary search.Checking every of t inside of binary search you can do following way. You should calculate place if planet after time t and find distance between ship's place and new planet place.So, you have following \"classic\" problem: there are two points A and B and circle with center in O and radius R (points are outside of circle), you need find distance between points and you cannot moving inside of circle.There are 2 cases:1. You can move direct way2. You should skirt the circle The second case is performed iff two following conditions are performed:a. Angles OAB and OBA are acuteb. Height OH of triangle OAB less than RAll checks you can do in integers.Well, let's understand how to precess our cases:1. Obviously2. Let us C and D be tangency points (i.e. you are moving along line ACDB). Thiangles OAC and OBD are right and you can easily calculate all angles inside of them. Then you should find angle COD. After that you can find length of line ACDB. You can see that you don't need find places of points C and D.Author is RipattiDiv1 D. We will construct solution recursively. For every k it is possible construct parallelepiped k × k × (k + 1) that contains 2 cubes k × k × k. For k = 2 solution is obliviousо. How to build solutions for k > 2 is shown in following picture:Red and blue cubes are start and end of chain. Firstly you should build one floor over. Then you should build 2 layers on two opposite sides.For every n you can build parallelepiped n × n × (n + 1), and drop one layer for getting cube n × n × n.Author is RipattiDiv1 E. You can allocate all grippers as points on plane with coordinates (distance, mass). So, when you use some gripper, you are collecting grippers inside some rectangle with corner in origin. Let us collect grippers and put them into queue. For current gripper you should take all grippers from rectangle and store them into queue. Then you should take next gripper from queue and do some manipulations with them and so on. Well, now you need do it fast.Let us create segment tree (for example, there you can use Fenwick tree) for dimention \"distance\". In every vertex of that tree you should store stack of points ordered by \"mass\". More details: every vertex of segment tree is some range of coordinates, and you should store in thet vertex points only from this range. At the top of every stack should be point with minimal mass. Well, let us put all points into tree. Every position is covered by no more thenм segmetns, therefore all tree will require of memory.When you process query, you should extract points from some stacks and put them into queue. You can see that you may put some points into queue twice. To avoid this you should also put number of point into stack. So, when you are extracting point from stack you can check that it is the first extract using some array of flags.This solution works in .Author is Ripatti ; the above solution was proposed by RAD",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4764",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5239
        }
      ],
      "code_examples": [
        {
          "title": "Solutions for Codeforces Round #125 - Codeforces - Code 1",
          "code": "The input contains of a single integer n (0 ≤ n < 10^9) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4764",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MIN_COORD = -1000000000;\n    const int MAX_COORD = 1000000000;\n    const int MIN_P_R = 1;\n    const int MAX_P_R = 1000000000;\n    const int MIN_N = 1;\n    const int MAX_N = 250000;\n    const int MIN_MI_PI_RI = 1;\n    const int MAX_MI_PI_RI = 1000000000;\n\n    int x = inf.readInt(MIN_COORD, MAX_COORD, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(MIN_COORD, MAX_COORD, \"y\");\n    inf.readSpace();\n    int p = inf.readInt(MIN_P_R, MAX_P_R, \"p\");\n    inf.readSpace();\n    int r = inf.readInt(MIN_P_R, MAX_P_R, \"r\");\n    inf.readSpace();\n    int n = inf.readInt(MIN_N, MAX_N, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> positions;\n    positions.insert(make_pair(x, y)); // Ship's position\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(MIN_COORD, MAX_COORD, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(MIN_COORD, MAX_COORD, \"yi\");\n        inf.readSpace();\n        int mi = inf.readInt(MIN_MI_PI_RI, MAX_MI_PI_RI, \"mi\");\n        inf.readSpace();\n        int pi = inf.readInt(MIN_MI_PI_RI, MAX_MI_PI_RI, \"pi\");\n        inf.readSpace();\n        int ri = inf.readInt(MIN_MI_PI_RI, MAX_MI_PI_RI, \"ri\");\n        inf.readEoln();\n\n        ensuref(!(xi == x && yi == y), \"Gripper %d is located at the same position as the ship\", i+1);\n\n        pair<int, int> pos = make_pair(xi, yi);\n        ensuref(positions.find(pos) == positions.end(), \"Gripper %d is located at the same position as another gripper\", i+1);\n\n        positions.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MIN_COORD = -1000000000;\n    const int MAX_COORD = 1000000000;\n    const int MIN_P_R = 1;\n    const int MAX_P_R = 1000000000;\n    const int MIN_N = 1;\n    const int MAX_N = 250000;\n    const int MIN_MI_PI_RI = 1;\n    const int MAX_MI_PI_RI = 1000000000;\n\n    int x = inf.readInt(MIN_COORD, MAX_COORD, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(MIN_COORD, MAX_COORD, \"y\");\n    inf.readSpace();\n    int p = inf.readInt(MIN_P_R, MAX_P_R, \"p\");\n    inf.readSpace();\n    int r = inf.readInt(MIN_P_R, MAX_P_R, \"r\");\n    inf.readSpace();\n    int n = inf.readInt(MIN_N, MAX_N, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> positions;\n    positions.insert(make_pair(x, y)); // Ship's position\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(MIN_COORD, MAX_COORD, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(MIN_COORD, MAX_COORD, \"yi\");\n        inf.readSpace();\n        int mi = inf.readInt(MIN_MI_PI_RI, MAX_MI_PI_RI, \"mi\");\n        inf.readSpace();\n        int pi = inf.readInt(MIN_MI_PI_RI, MAX_MI_PI_RI, \"pi\");\n        inf.readSpace();\n        int ri = inf.readInt(MIN_MI_PI_RI, MAX_MI_PI_RI, \"ri\");\n        inf.readEoln();\n\n        ensuref(!(xi == x && yi == y), \"Gripper %d is located at the same position as the ship\", i+1);\n\n        pair<int, int> pos = make_pair(xi, yi);\n        ensuref(positions.find(pos) == positions.end(), \"Gripper %d is located at the same position as another gripper\", i+1);\n\n        positions.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MIN_COORD = -1000000000;\n    const int MAX_COORD = 1000000000;\n    const int MIN_P_R = 1;\n    const int MAX_P_R = 1000000000;\n    const int MIN_N = 1;\n    const int MAX_N = 250000;\n    const int MIN_MI_PI_RI = 1;\n    const int MAX_MI_PI_RI = 1000000000;\n\n    int x = inf.readInt(MIN_COORD, MAX_COORD, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(MIN_COORD, MAX_COORD, \"y\");\n    inf.readSpace();\n    int p = inf.readInt(MIN_P_R, MAX_P_R, \"p\");\n    inf.readSpace();\n    int r = inf.readInt(MIN_P_R, MAX_P_R, \"r\");\n    inf.readSpace();\n    int n = inf.readInt(MIN_N, MAX_N, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int>> positions;\n    positions.insert(make_pair(x, y)); // Ship's position\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(MIN_COORD, MAX_COORD, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(MIN_COORD, MAX_COORD, \"yi\");\n        inf.readSpace();\n        int mi = inf.readInt(MIN_MI_PI_RI, MAX_MI_PI_RI, \"mi\");\n        inf.readSpace();\n        int pi = inf.readInt(MIN_MI_PI_RI, MAX_MI_PI_RI, \"pi\");\n        inf.readSpace();\n        int ri = inf.readInt(MIN_MI_PI_RI, MAX_MI_PI_RI, \"ri\");\n        inf.readEoln();\n\n        ensuref(!(xi == x && yi == y), \"Gripper %d is located at the same position as the ship\", i+1);\n\n        pair<int, int> pos = make_pair(xi, yi);\n        ensuref(positions.find(pos) == positions.end(), \"Gripper %d is located at the same position as another gripper\", i+1);\n\n        positions.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    long long x, y;\n    int p, r;\n    vector<long long> xi, yi;\n    vector<int> mi, pi, ri;\n\n    set<pair<long long, long long>> positions;\n\n    if (type == \"random\") {\n        // Generate initial x, y, p, r randomly\n        x = rnd.next(-1e9, 1e9);\n        y = rnd.next(-1e9, 1e9);\n        p = rnd.next(1, (int)1e9);\n        r = rnd.next(1, (int)1e9);\n\n        positions.insert({x, y});\n\n        xi.resize(n); yi.resize(n); mi.resize(n); pi.resize(n); ri.resize(n);\n\n        for(int i = 0; i < n; ++i) {\n            do {\n                xi[i] = rnd.next(-1e9, 1e9);\n                yi[i] = rnd.next(-1e9, 1e9);\n            } while (positions.count({xi[i], yi[i]}));\n            positions.insert({xi[i], yi[i]});\n\n            mi[i] = rnd.next(1, (int)1e9);\n            pi[i] = rnd.next(1, (int)1e9);\n            ri[i] = rnd.next(1, (int)1e9);\n        }\n    }\n    else if (type == \"max_n\") {\n        // Generate n = 250000, and maximum values\n        n = 250000;\n\n        x = rnd.next(-1e9, 1e9);\n        y = rnd.next(-1e9, 1e9);\n        p = (int)1e9;\n        r = (int)1e9;\n\n        positions.insert({x, y});\n\n        xi.resize(n); yi.resize(n); mi.resize(n); pi.resize(n); ri.resize(n);\n\n        for(int i = 0; i < n; ++i) {\n            do {\n                xi[i] = rnd.next(-1e9, 1e9);\n                yi[i] = rnd.next(-1e9, 1e9);\n            } while (positions.count({xi[i], yi[i]}));\n            positions.insert({xi[i], yi[i]});\n\n            mi[i] = (int)1e9;\n            pi[i] = (int)1e9;\n            ri[i] = (int)1e9;\n        }\n    }\n    else if (type == \"line\") {\n        // Generate grippers in a line, increasing distance and features\n        x = 0;\n        y = 0;\n        p = 1;\n        r = 1;\n\n        positions.insert({x, y});\n\n        xi.resize(n); yi.resize(n); mi.resize(n); pi.resize(n); ri.resize(n);\n\n        for(int i = 0; i < n; ++i) {\n            xi[i] = x + (i+1)*10;\n            yi[i] = y;\n\n            positions.insert({xi[i], yi[i]});\n\n            mi[i] = p + i; // Each gripper requires higher power\n            pi[i] = p + i + 1; // Each gripper has higher power\n            ri[i] = r + i + 1; // Each gripper has higher radius\n        }\n    }\n    else if (type == \"increasing\") {\n        // Grippers that can only be picked in order\n        x = 0;\n        y = 0;\n        p = 1;\n        r = 1;\n\n        positions.insert({x, y});\n\n        xi.resize(n); yi.resize(n); mi.resize(n); pi.resize(n); ri.resize(n);\n\n        for(int i = 0; i < n; ++i) {\n            xi[i] = x + (i+1)*2;\n            yi[i] = y;\n\n            positions.insert({xi[i], yi[i]});\n\n            mi[i] = p; // All grippers can be picked by current p\n            pi[i] = p; // Grippers do not improve p\n            ri[i] = r + (i+1)*2; // Grippers have increasing radius\n        }\n    }\n    else if (type == \"boundary\") {\n        // Grippers with mi, pi, ri equal to 1 or 1e9\n        x = rnd.next(-1e9, 1e9);\n        y = rnd.next(-1e9, 1e9);\n        p = rnd.next(1, (int)1e9);\n        r = rnd.next(1, (int)1e9);\n\n        positions.insert({x, y});\n\n        xi.resize(n); yi.resize(n); mi.resize(n); pi.resize(n); ri.resize(n);\n\n        for(int i = 0; i < n; ++i) {\n            do {\n                xi[i] = rnd.next(-1e9, 1e9);\n                yi[i] = rnd.next(-1e9, 1e9);\n            } while (positions.count({xi[i], yi[i]}));\n            positions.insert({xi[i], yi[i]});\n\n            if (i % 3 == 0) {\n                mi[i] = 1;\n                pi[i] = 1;\n                ri[i] = 1;\n            } else if (i % 3 == 1) {\n                mi[i] = (int)1e9;\n                pi[i] = (int)1e9;\n                ri[i] = (int)1e9;\n            } else {\n                mi[i] = rnd.next(1, (int)1e9);\n                pi[i] = rnd.next(1, (int)1e9);\n                ri[i] = rnd.next(1, (int)1e9);\n            }\n        }\n    }\n    else if (type == \"cluster\") {\n        // Grippers clustered around the ship\n        x = 0;\n        y = 0;\n        p = 1e9;\n        r = 1e9;\n\n        positions.insert({x, y});\n\n        xi.resize(n); yi.resize(n); mi.resize(n); pi.resize(n); ri.resize(n);\n\n        for(int i = 0; i < n; ++i) {\n            long long dx, dy;\n            do {\n                dx = rnd.next(-1000, 1000);\n                dy = rnd.next(-1000, 1000);\n                xi[i] = x + dx;\n                yi[i] = y + dy;\n            } while (positions.count({xi[i], yi[i]}));\n            positions.insert({xi[i], yi[i]});\n\n            mi[i] = rnd.next(1, (int)1e9);\n            pi[i] = rnd.next(1, (int)1e9);\n            ri[i] = rnd.next(1, (int)1e9);\n        }\n    }\n    else if (type == \"impossible\") {\n        // No gripper can be picked\n        x = 0;\n        y = 0;\n        p = 1;\n        r = 1;\n\n        positions.insert({x, y});\n\n        xi.resize(n); yi.resize(n); mi.resize(n); pi.resize(n); ri.resize(n);\n\n        for(int i = 0; i < n; ++i) {\n            xi[i] = x + 1e9;\n            yi[i] = y;\n\n            positions.insert({xi[i], yi[i]});\n\n            mi[i] = (int)1e9;\n            pi[i] = rnd.next(1, (int)1e9);\n            ri[i] = rnd.next(1, (int)1e9);\n        }\n    }\n    else {\n        // Default to random\n        x = rnd.next(-1e9, 1e9);\n        y = rnd.next(-1e9, 1e9);\n        p = rnd.next(1, (int)1e9);\n        r = rnd.next(1, (int)1e9);\n\n        positions.insert({x, y});\n\n        xi.resize(n); yi.resize(n); mi.resize(n); pi.resize(n); ri.resize(n);\n\n        for(int i = 0; i < n; ++i) {\n            do {\n                xi[i] = rnd.next(-1e9, 1e9);\n                yi[i] = rnd.next(-1e9, 1e9);\n            } while (positions.count({xi[i], yi[i]}));\n            positions.insert({xi[i], yi[i]});\n\n            mi[i] = rnd.next(1, (int)1e9);\n            pi[i] = rnd.next(1, (int)1e9);\n            ri[i] = rnd.next(1, (int)1e9);\n        }\n    }\n\n    // Output data\n    printf(\"%lld %lld %d %d %d\\n\", x, y, p, r, n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%lld %lld %d %d %d\\n\", xi[i], yi[i], mi[i], pi[i], ri[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    long long x, y;\n    int p, r;\n    vector<long long> xi, yi;\n    vector<int> mi, pi, ri;\n\n    set<pair<long long, long long>> positions;\n\n    if (type == \"random\") {\n        // Generate initial x, y, p, r randomly\n        x = rnd.next(-1e9, 1e9);\n        y = rnd.next(-1e9, 1e9);\n        p = rnd.next(1, (int)1e9);\n        r = rnd.next(1, (int)1e9);\n\n        positions.insert({x, y});\n\n        xi.resize(n); yi.resize(n); mi.resize(n); pi.resize(n); ri.resize(n);\n\n        for(int i = 0; i < n; ++i) {\n            do {\n                xi[i] = rnd.next(-1e9, 1e9);\n                yi[i] = rnd.next(-1e9, 1e9);\n            } while (positions.count({xi[i], yi[i]}));\n            positions.insert({xi[i], yi[i]});\n\n            mi[i] = rnd.next(1, (int)1e9);\n            pi[i] = rnd.next(1, (int)1e9);\n            ri[i] = rnd.next(1, (int)1e9);\n        }\n    }\n    else if (type == \"max_n\") {\n        // Generate n = 250000, and maximum values\n        n = 250000;\n\n        x = rnd.next(-1e9, 1e9);\n        y = rnd.next(-1e9, 1e9);\n        p = (int)1e9;\n        r = (int)1e9;\n\n        positions.insert({x, y});\n\n        xi.resize(n); yi.resize(n); mi.resize(n); pi.resize(n); ri.resize(n);\n\n        for(int i = 0; i < n; ++i) {\n            do {\n                xi[i] = rnd.next(-1e9, 1e9);\n                yi[i] = rnd.next(-1e9, 1e9);\n            } while (positions.count({xi[i], yi[i]}));\n            positions.insert({xi[i], yi[i]});\n\n            mi[i] = (int)1e9;\n            pi[i] = (int)1e9;\n            ri[i] = (int)1e9;\n        }\n    }\n    else if (type == \"line\") {\n        // Generate grippers in a line, increasing distance and features\n        x = 0;\n        y = 0;\n        p = 1;\n        r = 1;\n\n        positions.insert({x, y});\n\n        xi.resize(n); yi.resize(n); mi.resize(n); pi.resize(n); ri.resize(n);\n\n        for(int i = 0; i < n; ++i) {\n            xi[i] = x + (i+1)*10;\n            yi[i] = y;\n\n            positions.insert({xi[i], yi[i]});\n\n            mi[i] = p + i; // Each gripper requires higher power\n            pi[i] = p + i + 1; // Each gripper has higher power\n            ri[i] = r + i + 1; // Each gripper has higher radius\n        }\n    }\n    else if (type == \"increasing\") {\n        // Grippers that can only be picked in order\n        x = 0;\n        y = 0;\n        p = 1;\n        r = 1;\n\n        positions.insert({x, y});\n\n        xi.resize(n); yi.resize(n); mi.resize(n); pi.resize(n); ri.resize(n);\n\n        for(int i = 0; i < n; ++i) {\n            xi[i] = x + (i+1)*2;\n            yi[i] = y;\n\n            positions.insert({xi[i], yi[i]});\n\n            mi[i] = p; // All grippers can be picked by current p\n            pi[i] = p; // Grippers do not improve p\n            ri[i] = r + (i+1)*2; // Grippers have increasing radius\n        }\n    }\n    else if (type == \"boundary\") {\n        // Grippers with mi, pi, ri equal to 1 or 1e9\n        x = rnd.next(-1e9, 1e9);\n        y = rnd.next(-1e9, 1e9);\n        p = rnd.next(1, (int)1e9);\n        r = rnd.next(1, (int)1e9);\n\n        positions.insert({x, y});\n\n        xi.resize(n); yi.resize(n); mi.resize(n); pi.resize(n); ri.resize(n);\n\n        for(int i = 0; i < n; ++i) {\n            do {\n                xi[i] = rnd.next(-1e9, 1e9);\n                yi[i] = rnd.next(-1e9, 1e9);\n            } while (positions.count({xi[i], yi[i]}));\n            positions.insert({xi[i], yi[i]});\n\n            if (i % 3 == 0) {\n                mi[i] = 1;\n                pi[i] = 1;\n                ri[i] = 1;\n            } else if (i % 3 == 1) {\n                mi[i] = (int)1e9;\n                pi[i] = (int)1e9;\n                ri[i] = (int)1e9;\n            } else {\n                mi[i] = rnd.next(1, (int)1e9);\n                pi[i] = rnd.next(1, (int)1e9);\n                ri[i] = rnd.next(1, (int)1e9);\n            }\n        }\n    }\n    else if (type == \"cluster\") {\n        // Grippers clustered around the ship\n        x = 0;\n        y = 0;\n        p = 1e9;\n        r = 1e9;\n\n        positions.insert({x, y});\n\n        xi.resize(n); yi.resize(n); mi.resize(n); pi.resize(n); ri.resize(n);\n\n        for(int i = 0; i < n; ++i) {\n            long long dx, dy;\n            do {\n                dx = rnd.next(-1000, 1000);\n                dy = rnd.next(-1000, 1000);\n                xi[i] = x + dx;\n                yi[i] = y + dy;\n            } while (positions.count({xi[i], yi[i]}));\n            positions.insert({xi[i], yi[i]});\n\n            mi[i] = rnd.next(1, (int)1e9);\n            pi[i] = rnd.next(1, (int)1e9);\n            ri[i] = rnd.next(1, (int)1e9);\n        }\n    }\n    else if (type == \"impossible\") {\n        // No gripper can be picked\n        x = 0;\n        y = 0;\n        p = 1;\n        r = 1;\n\n        positions.insert({x, y});\n\n        xi.resize(n); yi.resize(n); mi.resize(n); pi.resize(n); ri.resize(n);\n\n        for(int i = 0; i < n; ++i) {\n            xi[i] = x + 1e9;\n            yi[i] = y;\n\n            positions.insert({xi[i], yi[i]});\n\n            mi[i] = (int)1e9;\n            pi[i] = rnd.next(1, (int)1e9);\n            ri[i] = rnd.next(1, (int)1e9);\n        }\n    }\n    else {\n        // Default to random\n        x = rnd.next(-1e9, 1e9);\n        y = rnd.next(-1e9, 1e9);\n        p = rnd.next(1, (int)1e9);\n        r = rnd.next(1, (int)1e9);\n\n        positions.insert({x, y});\n\n        xi.resize(n); yi.resize(n); mi.resize(n); pi.resize(n); ri.resize(n);\n\n        for(int i = 0; i < n; ++i) {\n            do {\n                xi[i] = rnd.next(-1e9, 1e9);\n                yi[i] = rnd.next(-1e9, 1e9);\n            } while (positions.count({xi[i], yi[i]}));\n            positions.insert({xi[i], yi[i]});\n\n            mi[i] = rnd.next(1, (int)1e9);\n            pi[i] = rnd.next(1, (int)1e9);\n            ri[i] = rnd.next(1, (int)1e9);\n        }\n    }\n\n    // Output data\n    printf(\"%lld %lld %d %d %d\\n\", x, y, p, r, n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%lld %lld %d %d %d\\n\", xi[i], yi[i], mi[i], pi[i], ri[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n./gen -n 250000 -type random\n\n./gen -n 250000 -type max_n\n\n./gen -n 10 -type line\n./gen -n 100 -type line\n./gen -n 1000 -type line\n./gen -n 10000 -type line\n./gen -n 100000 -type line\n\n./gen -n 10 -type increasing\n./gen -n 100 -type increasing\n./gen -n 1000 -type increasing\n./gen -n 10000 -type increasing\n./gen -n 100000 -type increasing\n\n./gen -n 10 -type boundary\n./gen -n 100 -type boundary\n./gen -n 1000 -type boundary\n./gen -n 10000 -type boundary\n./gen -n 100000 -type boundary\n\n./gen -n 10 -type cluster\n./gen -n 100 -type cluster\n./gen -n 1000 -type cluster\n./gen -n 10000 -type cluster\n./gen -n 100000 -type cluster\n\n./gen -n 10 -type impossible\n./gen -n 100 -type impossible\n./gen -n 1000 -type impossible\n./gen -n 10000 -type impossible\n./gen -n 100000 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:28.959933",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "199/A",
      "title": "A. Hexadecimal's theorem",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input contains of a single integer n (0 ≤ n < 109) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.",
      "output_spec": "OutputOutput three required numbers: a, b and c. If there is no answer for the test you have to print \"I'm too stupid to solve this problem\" without the quotes.If there are multiple answers, print any of them.",
      "sample_tests": "ExamplesInputCopy3OutputCopy1 1 1InputCopy13OutputCopy2 3 8",
      "description": "A. Hexadecimal's theorem\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input contains of a single integer n (0 ≤ n < 109) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.\n\nOutputOutput three required numbers: a, b and c. If there is no answer for the test you have to print \"I'm too stupid to solve this problem\" without the quotes.If there are multiple answers, print any of them.\n\nInputCopy3OutputCopy1 1 1InputCopy13OutputCopy2 3 8\n\nOutputCopy1 1 1\n\nInputCopy13\n\nOutputCopy2 3 8",
      "solutions": [
        {
          "title": "Codeforces Round #125 - Codeforces",
          "content": "Hello everyone!There is yet another Codeforces round. Now it is the 53-th one.The round will run for both divisions by classic rules of Codeforces format.Points are standard: 500-1000-1500-2000-2500.Round was prepared by Ripatti , Alex_KPR , Gerald , Aksenov239 , RAD , Delinur .Good luck!UPD. Round is ended.Winners of div1:1. Petr2. tourist3. SergeyRogulenko4. bmerry5. UESTC_Nocturne Winners of div2:1. gflegar2. mylyanyk.ivan3. arbesfeld Petr is only who solved all 5 problems in the first division. No one solved all 5 problems in the second division.UPD. Editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4757",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 571
        },
        {
          "title": "Solutions for Codeforces Round #125 - Codeforces",
          "content": "Div2 A. You can just output \"0 0 n\". Author is Alex_KPR . Div2 B. You should check for every circle of one ring: it have intersections with another ring or not. So, there are 4 checks. There are 2 cases:1. circle is inside of ring;2. circle is outside of ring and ring is outside of circle;3. circle is outside of ring and ring is inside of circle.If at least one of these cases is performed, circle is good.You can easily do checks following way. Let us d be a distance between centers of ring and circle, r1 and R1 are inside and outside radii of ring, r be radius of circle. Then conditions for all cases will be1. d + r ≤ r1.2. r + R1 ≤ d.3. d + R1 ≤ r.You can check all conditions in integers using squares of distances. Author is Alex_KPR Div2 C. Div1 A.The first solution. Consider sequence a0 = 1, ai = ai - 1k + b:a0, a1, a2, ..., an = z.You can see that for all numbers from segment [a0, a1 - 1] you can number not less than z using exactly n steps. But for n - 1 steps you will bet number less than z. It works because transformation is monotonous. Analogically, for numbers from segments [a1, a2 - 1], [a2, a3 - 1], etc, you need exactly n - 1, n - 2, etc steps. So you just need find segment that contains number t. You can do it by generate a few first members of the sequence a. You need no more than t members. The second solution. Equation:tkx + b(kx - 1 + kx - 2... + 1) ≥ kn + b(kx - 1 + kx - 2... + 1)Using formula for geometric progression you can get:For k ≠ 1 we can multiply both sides by k - 1, (you can consider case k = 1 by yourself).t(k - 1)kx + bkx - b ≥ (k - 1)kn + bkn - b kx(t(k - 1) + b) ≥ kn(k - 1 + b) So, you can find value n - x using simply raising to a power.Authors are Gerald and RipattiDiv2 D. Div1 B. You should construct graph where vertices are areas of walls and edges are actions of ninja. Then you should run BFS with one modification: is you reach vertex later then water, you shouldn't do moves from this vertex.It is solution in O(n).Author is RipattiDiv2 E. Div1 C. If you can reach the planet in time t, you also can reach one in any time greater then t (you can just reach planet in time t and then move along with planet). There exists some t0 for that for all t > t0 you can reach planet, and for all t < t0 you cannot do in. Let us find t0 using binary search.Checking every of t inside of binary search you can do following way. You should calculate place if planet after time t and find distance between ship's place and new planet place.So, you have following \"classic\" problem: there are two points A and B and circle with center in O and radius R (points are outside of circle), you need find distance between points and you cannot moving inside of circle.There are 2 cases:1. You can move direct way2. You should skirt the circle The second case is performed iff two following conditions are performed:a. Angles OAB and OBA are acuteb. Height OH of triangle OAB less than RAll checks you can do in integers.Well, let's understand how to precess our cases:1. Obviously2. Let us C and D be tangency points (i.e. you are moving along line ACDB). Thiangles OAC and OBD are right and you can easily calculate all angles inside of them. Then you should find angle COD. After that you can find length of line ACDB. You can see that you don't need find places of points C and D.Author is RipattiDiv1 D. We will construct solution recursively. For every k it is possible construct parallelepiped k × k × (k + 1) that contains 2 cubes k × k × k. For k = 2 solution is obliviousо. How to build solutions for k > 2 is shown in following picture:Red and blue cubes are start and end of chain. Firstly you should build one floor over. Then you should build 2 layers on two opposite sides.For every n you can build parallelepiped n × n × (n + 1), and drop one layer for getting cube n × n × n.Author is RipattiDiv1 E. You can allocate all grippers as points on plane with coordinates (distance, mass). So, when you use some gripper, you are collecting grippers inside some rectangle with corner in origin. Let us collect grippers and put them into queue. For current gripper you should take all grippers from rectangle and store them into queue. Then you should take next gripper from queue and do some manipulations with them and so on. Well, now you need do it fast.Let us create segment tree (for example, there you can use Fenwick tree) for dimention \"distance\". In every vertex of that tree you should store stack of points ordered by \"mass\". More details: every vertex of segment tree is some range of coordinates, and you should store in thet vertex points only from this range. At the top of every stack should be point with minimal mass. Well, let us put all points into tree. Every position is covered by no more thenм segmetns, therefore all tree will require of memory.When you process query, you should extract points from some stacks and put them into queue. You can see that you may put some points into queue twice. To avoid this you should also put number of point into stack. So, when you are extracting point from stack you can check that it is the first extract using some array of flags.This solution works in .Author is Ripatti ; the above solution was proposed by RAD",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/4764",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5239
        }
      ],
      "code_examples": [
        {
          "title": "Solutions for Codeforces Round #125 - Codeforces - Code 1",
          "code": "The input contains of a single integer n (0 ≤ n < 10^9) — the number that should be represented by the rules described above. It is guaranteed that n is a Fibonacci number.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/4764",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPerfectSquare(long long x) {\n    if (x < 0) return false;\n    long long s = (long long)(sqrt((double)x) + 0.5);\n    return s * s == x;\n}\n\nbool isFibonacci(int n) {\n    long long n_ll = n;\n    long long t1 = 5LL * n_ll * n_ll + 4;\n    long long t2 = 5LL * n_ll * n_ll - 4;\n    return isPerfectSquare(t1) || isPerfectSquare(t2);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(0, 999999999, \"n\"); // Upper bound is 10^9 - 1\n    inf.readEoln();\n    inf.readEof();\n\n    ensuref(isFibonacci(n), \"n is not a Fibonacci number\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPerfectSquare(long long x) {\n    if (x < 0) return false;\n    long long s = (long long)(sqrt((double)x) + 0.5);\n    return s * s == x;\n}\n\nbool isFibonacci(int n) {\n    long long n_ll = n;\n    long long t1 = 5LL * n_ll * n_ll + 4;\n    long long t2 = 5LL * n_ll * n_ll - 4;\n    return isPerfectSquare(t1) || isPerfectSquare(t2);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(0, 999999999, \"n\"); // Upper bound is 10^9 - 1\n    inf.readEoln();\n    inf.readEof();\n\n    ensuref(isFibonacci(n), \"n is not a Fibonacci number\");\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPerfectSquare(long long x) {\n    if (x < 0) return false;\n    long long s = (long long)(sqrt((double)x) + 0.5);\n    return s * s == x;\n}\n\nbool isFibonacci(int n) {\n    long long n_ll = n;\n    long long t1 = 5LL * n_ll * n_ll + 4;\n    long long t2 = 5LL * n_ll * n_ll - 4;\n    return isPerfectSquare(t1) || isPerfectSquare(t2);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(0, 999999999, \"n\"); // Upper bound is 10^9 - 1\n    inf.readEoln();\n    inf.readEof();\n\n    ensuref(isFibonacci(n), \"n is not a Fibonacci number\");\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt(0, 1000000000, \"n\");\n\n    // Generate Fibonacci numbers up to 1e9\n    vector<int> fib;\n    set<int> fibSet;\n    fib.push_back(0);\n    fib.push_back(1);\n    fibSet.insert(0);\n    fibSet.insert(1);\n\n    while (true) {\n        int sz = fib.size();\n        int nextFib = fib[sz - 1] + fib[sz - 2];\n        if (nextFib > 1000000000) break;\n        fib.push_back(nextFib);\n        fibSet.insert(nextFib);\n    }\n\n    // Read participant's output\n    string participant_output = \"\"; \n    while (!ouf.eof()) {\n        string s = ouf.readLine(); // Read line by line\n        if (!participant_output.empty())\n            participant_output += \"\\n\";\n        participant_output += s;\n    }\n    trim(participant_output);\n\n    // Try to parse three integers\n    istringstream iss(participant_output);\n    int a, b, c;\n    if (iss >> a >> b >> c) {\n        // Check for extra tokens\n        string extra;\n        if (iss >> extra) {\n            quitf(_wa, \"Extra tokens found after reading three integers\");\n        }\n\n        // Check that a, b, c are Fibonacci numbers\n        if (!fibSet.count(a))\n            quitf(_wa, \"%d is not a Fibonacci number\", a);\n        if (!fibSet.count(b))\n            quitf(_wa, \"%d is not a Fibonacci number\", b);\n        if (!fibSet.count(c))\n            quitf(_wa, \"%d is not a Fibonacci number\", c);\n\n        // Check that a + b + c == n\n        if (a + b + c != n)\n            quitf(_wa, \"Sum of given Fibonacci numbers %d + %d + %d != %d\", a, b, c, n);\n\n        // All checks passed\n        quitf(_ok, \"Found a valid solution\");\n    } else {\n        // Could not read three integers, check for exact phrase\n        if (participant_output == \"I'm too stupid to solve this problem\") {\n            // Check whether a solution exists\n            bool solution_exists = false;\n            for (int c_value : fib) {\n                int target = n - c_value;\n                for (int a_value : fib) {\n                    int b_value = target - a_value;\n                    if (fibSet.count(b_value)) {\n                        // Found a solution\n                        solution_exists = true;\n                        break;\n                    }\n                }\n                if (solution_exists) break;\n            }\n            if (solution_exists) {\n                // Participant claimed impossible when solution exists\n                quitf(_wa, \"Solution exists but participant claimed impossible\");\n            } else {\n                // Correct, no solution exists\n                quitf(_ok, \"Correctly determined that no solution exists\");\n            }\n        } else {\n            // Participant's output is invalid\n            quitf(_wa, \"Invalid output\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to get the list of Fibonacci numbers up to 1e9\nvector<int> getFibonacciNumbers() {\n    vector<int> fib;\n    fib.push_back(0);\n    fib.push_back(1);\n    while (true) {\n        int sz = fib.size();\n        int next = fib[sz - 1] + fib[sz - 2];\n        if (next > 1e9)\n            break;\n        fib.push_back(next);\n    }\n    return fib;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"small\");\n    int idx = opt<int>(\"index\", -1);\n\n    vector<int> fib = getFibonacciNumbers();\n\n    if (type == \"small\") {\n        // Output small n\n        int maxSmallIndex = 10; // First 10 Fibonacci numbers\n        int index;\n        if (idx >= 0 && idx < maxSmallIndex)\n            index = idx;\n        else\n            index = rnd.next(0, maxSmallIndex - 1);\n        printf(\"%d\\n\", fib[index]);\n    } else if (type == \"large\") {\n        // Output large n\n        int minLargeIndex = fib.size() - 10; // Last 10 Fibonacci numbers\n        int index;\n        if (idx >= minLargeIndex && idx < (int)fib.size())\n            index = idx;\n        else\n            index = rnd.next(minLargeIndex, (int)fib.size() - 1);\n        printf(\"%d\\n\", fib[index]);\n    } else if (type == \"max\") {\n        // Output maximum n\n        printf(\"%d\\n\", fib.back());\n    } else if (type == \"random\") {\n        // Output random n\n        int index = rnd.next(0, (int)fib.size() - 1);\n        printf(\"%d\\n\", fib[index]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to get the list of Fibonacci numbers up to 1e9\nvector<int> getFibonacciNumbers() {\n    vector<int> fib;\n    fib.push_back(0);\n    fib.push_back(1);\n    while (true) {\n        int sz = fib.size();\n        int next = fib[sz - 1] + fib[sz - 2];\n        if (next > 1e9)\n            break;\n        fib.push_back(next);\n    }\n    return fib;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"small\");\n    int idx = opt<int>(\"index\", -1);\n\n    vector<int> fib = getFibonacciNumbers();\n\n    if (type == \"small\") {\n        // Output small n\n        int maxSmallIndex = 10; // First 10 Fibonacci numbers\n        int index;\n        if (idx >= 0 && idx < maxSmallIndex)\n            index = idx;\n        else\n            index = rnd.next(0, maxSmallIndex - 1);\n        printf(\"%d\\n\", fib[index]);\n    } else if (type == \"large\") {\n        // Output large n\n        int minLargeIndex = fib.size() - 10; // Last 10 Fibonacci numbers\n        int index;\n        if (idx >= minLargeIndex && idx < (int)fib.size())\n            index = idx;\n        else\n            index = rnd.next(minLargeIndex, (int)fib.size() - 1);\n        printf(\"%d\\n\", fib[index]);\n    } else if (type == \"max\") {\n        // Output maximum n\n        printf(\"%d\\n\", fib.back());\n    } else if (type == \"random\") {\n        // Output random n\n        int index = rnd.next(0, (int)fib.size() - 1);\n        printf(\"%d\\n\", fib[index]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n values\n./gen -type small -index 0\n./gen -type small -index 1\n./gen -type small -index 2\n./gen -type small -index 3\n./gen -type small -index 4\n./gen -type small -index 5\n./gen -type small -index 6\n./gen -type small -index 7\n./gen -type small -index 8\n./gen -type small -index 9\n\n# Large n values\n./gen -type large -index 35\n./gen -type large -index 36\n./gen -type large -index 37\n./gen -type large -index 38\n./gen -type large -index 39\n./gen -type large -index 40\n./gen -type large -index 41\n./gen -type large -index 42\n./gen -type large -index 43\n./gen -type large -index 44\n\n# Max n value\n./gen -type max\n\n# Random n values\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Additional specific n values\n# Edge case at index 0 (n=0)\n./gen -type small -index 0\n# Edge case at index 1 (n=1)\n./gen -type small -index 1\n# Edge case at index 2 (n=1)\n./gen -type small -index 2\n# Middle n values\n./gen -type small -index 10\n./gen -type small -index 15\n./gen -type small -index 20\n./gen -type small -index 25\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T19:47:31.180343",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}