{
  "metadata": {
    "batch_number": 51,
    "batch_size": 100,
    "problems_in_batch": 100,
    "total_processed": 5200,
    "created_at": "2025-08-28T20:55:23.482691",
    "format": "wenjiajia_v1.0_incremental"
  },
  "problems": [
    {
      "problem_id": "578/B",
      "title": "B. Игра",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано три целых числа n, k и x (1 ≤ n ≤ 200 000, 1 ≤ k ≤ 10, 2 ≤ x ≤ 8).Во второй строке записано n целых чисел a1, a2, ..., an (0 ≤ ai ≤ 109).",
      "output_spec": "Выходные данныеВыведите максимальное значение побитового ИЛИ для элементов последовательности после выполнения операций.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 1 21 1 1Выходные данныеСкопировать3Входные данныеСкопировать4 2 31 2 4 8Выходные данныеСкопировать79",
      "description": "ограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке записано три целых числа n, k и x (1 ≤ n ≤ 200 000, 1 ≤ k ≤ 10, 2 ≤ x ≤ 8).Во второй строке записано n целых чисел a1, a2, ..., an (0 ≤ ai ≤ 109).\n\nВходные данные\n\nВыходные данныеВыведите максимальное значение побитового ИЛИ для элементов последовательности после выполнения операций.\n\nВыходные данные\n\nВходные данныеСкопировать3 1 21 1 1Выходные данныеСкопировать3Входные данныеСкопировать4 2 31 2 4 8Выходные данныеСкопировать79\n\nВходные данныеСкопировать3 1 21 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 2 31 2 4 8\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать79\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере любой возможный выбор проведения одной операции приведет к трём различным числам 1, 1, 2, так что результат будет равен . Во втором примере, если дважды умножить 8 на 3, то получим 72. В этом случае числа будут таковы: 1, 2, 4, 72, так что значение ИЛИ будет равно 79, что является наилучшим возможным результатом.",
      "solutions": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] - Codeforces",
          "content": "Hello, everyone! Codeforces Round #320 will be held at Sep/16/2015 18:00 MSK. Note that round starts in the unusual time!The problems are from tmt514, Shik, drazil, and me(dreamoon_love_AA). Also we want to thank Zlobober for helping us preparing the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is my second time organizing a problemset for a Codeforces round (my previous round: #292). In my previous round all problems were provided by me. But I think that if problems are provided by more people, then the contest will be more interesting! So I asked my friends to help me this time. Hope everybody can have fun during the round!Participants in each division will be given six tasks and two and a half hours for solving them (the last four problems in Div. 2 are as same as as the first four problems in Div. 1). Scoring system will be announced later closer to the start of the round.Bayan is an Iranian software company working on large-scale web applications. It doesn't only develop the search engine, but also it holds an annual open competition Bayan Programming Contest with an on-site round in Tehran. The on-site round of 2015 became an international event with many strong participants.Bayan has supported Codeforces on our Codeforces 5-year crowdfunding program. Thank you Bayan! This round is in your honor!UPD 1: Due to technical reasons the round starts at 18:15 Moscow time.UPD 2: The round will use the dynamic scoring with 250 points step.UPD 3: Problems are ordered according to their supposed difficulty.UPD 4: Winners!Div1:1) Um_nik2) Egor3) EndagorionDiv2:1) EmaxxMaster2) gongy3) Irisviel_von_EinzberUPD5: link of Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1762
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces",
          "content": "Problm 1 : Raising BacteriaWrite down x into its binary form. If the ith least significant bit is 1 and x contains n bits, we put one bacteria into this box in the morning of (n + 1 - i)th day. Then at the noon of the nth day, the box will contain x bacteria. So the answer is the number of ones in the binary form of x.code of author's friend: thisProblem 2 : Finding Team MemberSort all possible combinations from high strength to low strength. Then iterator all combinations. If two people in a combination still are not contained in any team. then we make these two people as a team.author's code: thisProblem 3 : A Problem about PolylineIf point (a,b) is located on the up slope/ down slope of this polyline. Then the polyline will pass the point (a - b,0)/(a + b,0).(we call (a - b) or (a + b) as c afterwards) And we can derive that c / (2 * x) should be a positive integer. Another condition we need to satisfy is that x must be larger than or equal to b. It’s easy to show that when those two conditions are satisfied, then the polyline will pass the point (a,b).Formally speaking in math : Let c / (2 * x) = y Then we have x = c / (2 * y) ≥ b and we want to find the maximum integer y. After some more math derivation, we can get the answer is . Besides, the only case of no solution is when a < b.In fact, always dosn't exist or larger than .author's code: #include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n LL a,b;\n cin>>a>>b;\n if(a<b)puts(\"-1\");\n else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n return 0;\n}\nProblem 4 : Or GameWe can describe a strategy as multiplying ai by x ti times so ai will become bi = ai * xti and sum of all ti will be equals to k. The fact is there must be a ti equal to k and all other ti equals to 0. If not, we can choose the largest number bj in sequence b, and change the strategy so that tj = k and all other tj = 0. The change will make the highest bit 1 of bj become higher so the or-ed result would be higher.After knowing the fact, We can iterator all number in sequence a and multiply it by xk and find the maximum value of our target between them. There are several method to do it in lower time complexity. You can check the sample code we provide.(I believe you can understand it quickly.)author's code: #include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n int n,k,x;\n scanf(\"%d%d%d\", &n, &k, &x);\n long long mul=1;\n while(k--)\n mul *= x;\n for(int i = 1; i <= n; i++)\n scanf(\"%I64d\", &a[i]);\n for(int i = 1; i <= n; i++)\n prefix[i] = prefix[i-1] | a[i];\n for(int i = n; i > 0; i--)\n suffix[i] = suffix[i+1] | a[i];\n long long ans = 0;\n for(int i= 1; i <= n; i++)\n ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n printf(\"%I64d\\n\",ans);\n}Problem 5 : Weakness and PoornessLet , we can write down the definition of poorness formally as. It's easy to see that A is a strictly decreasing function of x, and B is a strictly increasing function of x. Thus the minimum of max(A, B) can be found using binary or ternary search. The time complexity is ,Now here give people geometry viewpoint of this problem:let We plot n + 1 straight line y = i * x + bi in the plane for i from 0 to n.We can discover when you are given x. The weakness will be (y coordinator of highest line at x) — (y coordinator of lowest line at x).So we only need to consider the upper convex hull and the lower convex hull of all lines. And the target x value will be one of the intersection of these convex hull.Because you can get these line in order of their slope value. we can use stack to get the convex hulls in O(n).author's code : this (using binary search)code of author's friend (using stack to handle convexhull with O(n), have more precision)Problem 6 : LCS againFollowings are solution in short. Considering the LCS dp table lcs[x][y] which denotes the LCS value of first x characters of S and first y characters of T. If we know lcs[n][n] = n - 1, then we only concern values in the table which abs(x - y) ≤ 1 and all value of lcs[x][y] must be min(x, y) or min(x, y) - 1. So each row contains only 8 states(In fact,three states among these states will never be used), we can do dp on it row by row with time complexity O(n).There is another not dp method. You can refer this comment.author's code: #include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n DRII(n,m);\n RS(s+1);\n REPP(i,1,n+1)s[i]-='a';\n s[n+1]=-1;\n REP(i,m){\n int state=1;\n if(i==s[1])state|=2;\n if(i==s[1]||i==s[2])state|=4;\n dp[1][state]++;\n }\n REPP(i,2,n+1){\n REP(j,8){\n int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n REP(k,m){\n int d2[4]={};\n REPP(l,1,4){\n if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n else d2[l]=max(d2[l-1],d[l]);\n }\n if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n }\n }\n }\n printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n return 0;\n}Problem 7 : Walking!Since there is only one person, it’s not hard to show the difference between the number of left footprints and the number of right footprints is at most one.For a particular possible time order of a sequence of footprints, if there are k backward steps, we can easily divide all footprints into at most k + 1 subsequences without backward steps. Then you might guess that another direction of the induction is also true.That is, we can combine any k + 1 subsequence without backward steps into a whole sequence contains at most k backward steps. Your guess is correct !Now we demostrate the process of combining those subsequences.We only concern the first step and the last step of a divided subsequence. There are four possible combinations, we denote them as LL/LR/RL/RR subsequence separately(the first character is the type of the first step and the second character is the type of the second step).Suppose the number of four types of subseueqnce(LL/LR/RL/RR) are A, B, C, D separately. We have abs(A - D) ≤ 1.We can combine all RR, LL subsequeces in turn into one subsequenceswith at most A + D - 1 backward steps(the result may be of any of the four subsquence types). Now we have at most one LL or RR type subsequence.Then we can combine all RL subsequence into only one RL subsequence with at most A - 1 backward steps easily. And so do LR subsequences. Now we want to combine the final RL and LR subsequences together. We could pick the last footprint among two subsequences, exclude it from the original subsequcne and append it at the tail of another subsequence. The move will not increase the number of backward step and the types of the two subsequences would become RR and LL ! We can easily combine them into one LR or RL subsequence now. If there is still a LL or RR type subsequence reamained. We can easily combine them, too.So if we can divide all footprints into the least number of subsequences without backward steps. Then we have solved the problem. And this part can be done with greedy method.Now we provide one possible greedy method:Firstly, we translate this problem to a maximum matching problem on bipartite graph as following:Take \"RLLRRL\" as example: We split each footprint into two vertices which on is in left part and another is in right part.If two footprints is next to each other in resulted subsequnces, we will connect the left vertex of the former to right vertex of the latter in the corresponded matching. So the matching described in above left graph is subsequences: \"RL-R--\" and \"--L-RL\" and in above right graph is \"RL-R-L\" and \"--L-R-\". we can find that the number of subsequences is (number of footprints) — (value of matching).Due to the graphs produced by this problem is very special, we can solve this bipartite matching as following:Iterate each vertex in left part from top to bottom and find the uppermost vertex which is able to be matched in right part and connect them.If we process this algorithm in \"RLLRRL\", the resulted matching is the above right graph.Why the greedy method is correct? we can prove it by adjusting any maximum matching to our intended matching step by step. In each step, you can find the uppermost vertex the state of which is different to what we intend and change its state. I guess the mission of adjusting is not too hard for you to think out! Please solve it by yourself >_<By the way, I believe there are also many other greedy methods will work. If your greedy method is different to author's. Don't feel strange.author's code: thisProblem 8 : The Mirror BoxIf we view the grid intersections alternatively colored by blue and red like this:Then we know that the two conditions in the description are equivalent to a spanning tree in either entire red intersections or entire blue dots. So we can consider a red spanning tree and blue spanning tree one at a time.We can use disjoint-sets to merge connected components. Each component should be a tree, otherwise some grid edges will be enclosed inside some mirrors. So for the contracted graph, we would like to know how many spanning trees are there. This can be done by Kirchhoff’s theorem.Since there are at most 200 broken mirrors, the number of vertices in the contracted graph should be no more than 401. Hence a O(|V|3) determinant calculation algorithm may be applied onto the matrix.author's code: this",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20368",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10347
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "a[i][j] == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((ab)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 14",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 15",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 16",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 17",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(2, 8, \"x\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(2, 8, \"x\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(2, 8, \"x\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    int x = opt<int>(\"x\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random_small\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 10);\n        }\n    }\n    else if (type == \"random_large\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, (int)1e9);\n        }\n    }\n    else if (type == \"all_zeros\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    }\n    else if (type == \"all_max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (int)1e9;\n        }\n    }\n    else if (type == \"powers_of_two\") {\n        for (int i = 0; i < n; ++i) {\n            int power = rnd.next(0, 29);\n            a[i] = 1 << power;\n        }\n    }\n    else if (type == \"one_large_rest_small\") {\n        a[0] = (int)1e9;\n        for (int i = 1; i < n; ++i) {\n            a[i] = rnd.next(0, 10);\n        }\n    }\n    else if (type == \"one_small_rest_large\") {\n        a[0] = 0;\n        for (int i = 1; i < n; ++i) {\n            a[i] = (int)1e9;\n        }\n    }\n    else if (type == \"max_or\") {\n        // Generate numbers to maximize the OR value\n        int max_bits = 29;\n        int value = (1 << max_bits) - 1; // This will be <= 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    }\n    else if (type == \"min_or\") {\n        // Generate numbers to get minimal OR value\n        int val = rnd.next(0, 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    }\n    else if (type == \"varying_numbers\") {\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(0, 2);\n            if (t == 0)\n                a[i] = rnd.next(0, 10);\n            else if (t == 1)\n                a[i] = rnd.next((int)1e5, (int)1e6);\n            else\n                a[i] = rnd.next((int)1e8, (int)1e9);\n        }\n    }\n    else if (type == \"maximally_increasable\") {\n        // Generate a number which, when multiplied by x^k, reaches near 1e9\n        long long max_factor = 1;\n        for (int i = 0; i < k; ++i) {\n            max_factor *= x;\n            if (max_factor > (long long)1e9)\n                break;\n        }\n        int base = (int)(1e9 / max_factor);\n        if (base == 0) base = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = base;\n        }\n    }\n    else if (type == \"single_number\") {\n        n = 1;\n        a[0] = rnd.next(0, (int)1e9);\n    }\n    else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, (int)1e9);\n        }\n    }\n\n    // Output n, k, x\n    printf(\"%d %d %d\\n\", n, k, x);\n\n    // Output the array\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    int x = opt<int>(\"x\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random_small\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 10);\n        }\n    }\n    else if (type == \"random_large\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, (int)1e9);\n        }\n    }\n    else if (type == \"all_zeros\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    }\n    else if (type == \"all_max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (int)1e9;\n        }\n    }\n    else if (type == \"powers_of_two\") {\n        for (int i = 0; i < n; ++i) {\n            int power = rnd.next(0, 29);\n            a[i] = 1 << power;\n        }\n    }\n    else if (type == \"one_large_rest_small\") {\n        a[0] = (int)1e9;\n        for (int i = 1; i < n; ++i) {\n            a[i] = rnd.next(0, 10);\n        }\n    }\n    else if (type == \"one_small_rest_large\") {\n        a[0] = 0;\n        for (int i = 1; i < n; ++i) {\n            a[i] = (int)1e9;\n        }\n    }\n    else if (type == \"max_or\") {\n        // Generate numbers to maximize the OR value\n        int max_bits = 29;\n        int value = (1 << max_bits) - 1; // This will be <= 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    }\n    else if (type == \"min_or\") {\n        // Generate numbers to get minimal OR value\n        int val = rnd.next(0, 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    }\n    else if (type == \"varying_numbers\") {\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(0, 2);\n            if (t == 0)\n                a[i] = rnd.next(0, 10);\n            else if (t == 1)\n                a[i] = rnd.next((int)1e5, (int)1e6);\n            else\n                a[i] = rnd.next((int)1e8, (int)1e9);\n        }\n    }\n    else if (type == \"maximally_increasable\") {\n        // Generate a number which, when multiplied by x^k, reaches near 1e9\n        long long max_factor = 1;\n        for (int i = 0; i < k; ++i) {\n            max_factor *= x;\n            if (max_factor > (long long)1e9)\n                break;\n        }\n        int base = (int)(1e9 / max_factor);\n        if (base == 0) base = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = base;\n        }\n    }\n    else if (type == \"single_number\") {\n        n = 1;\n        a[0] = rnd.next(0, (int)1e9);\n    }\n    else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, (int)1e9);\n        }\n    }\n\n    // Output n, k, x\n    printf(\"%d %d %d\\n\", n, k, x);\n\n    // Output the array\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -x 2 -type single_number\n./gen -n 1 -k 10 -x 8 -type single_number\n\n./gen -n 5 -k 1 -x 2 -type random_small\n./gen -n 5 -k 10 -x 8 -type random_small\n\n./gen -n 100 -k 5 -x 5 -type random_small\n./gen -n 100 -k 1 -x 2 -type random_small\n./gen -n 100 -k 10 -x 8 -type random_small\n\n./gen -n 1000 -k 1 -x 2 -type random_large\n./gen -n 1000 -k 10 -x 8 -type random_large\n\n./gen -n 200000 -k 1 -x 2 -type random_large\n./gen -n 200000 -k 10 -x 8 -type random_large\n\n./gen -n 200000 -k 10 -x 8 -type all_zeros\n\n./gen -n 200000 -k 10 -x 8 -type all_max\n\n./gen -n 200000 -k 10 -x 8 -type one_large_rest_small\n\n./gen -n 200000 -k 10 -x 2 -type one_small_rest_large\n\n./gen -n 200000 -k 10 -x 8 -type powers_of_two\n\n./gen -n 200000 -k 10 -x 8 -type max_or\n\n./gen -n 200000 -k 10 -x 2 -type min_or\n\n./gen -n 200000 -k 10 -x 8 -type varying_numbers\n\n./gen -n 200000 -k 10 -x 8 -type maximally_increasable\n\n./gen -n 200000 -k 1 -x 2 -type one_large_rest_small\n\n./gen -n 200000 -k 1 -x 8 -type powers_of_two\n\n./gen -n 200000 -k 5 -x 5 -type random_large\n\n./gen -n 200000 -k 5 -x 5 -type random_small\n\n./gen -n 100000 -k 10 -x 8 -type random_large\n\n./gen -n 2 -k 10 -x 8 -type one_large_rest_small\n\n./gen -n 100 -k 10 -x 8 -type min_or\n\n./gen -n 200000 -k 10 -x 8 -type max_or\n\n./gen -n 100 -k 5 -x 5 -type maximally_increasable\n\n./gen -n 199999 -k 10 -x 8 -type powers_of_two\n\n./gen -n 200000 -k 10 -x 8 -type one_small_rest_large\n\n./gen -n 1 -k 10 -x 8 -type maximally_increasable\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:03.995937",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "578/C",
      "title": "C. Weakness and Poorness",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one integer n (1 ≤ n ≤ 200 000), the length of a sequence.The second line contains n integers a1, a2, ..., an (|ai| ≤ 10 000).",
      "output_spec": "OutputOutput a real number denoting the minimum possible weakness of a1 - x, a2 - x, ..., an - x. Your answer will be considered correct if its relative or absolute error doesn't exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy31 2 3OutputCopy1.000000000000000InputCopy41 2 3 4OutputCopy2.000000000000000InputCopy101 10 2 9 3 8 4 7 5 6OutputCopy4.500000000000000",
      "description": "C. Weakness and Poorness\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains one integer n (1 ≤ n ≤ 200 000), the length of a sequence.The second line contains n integers a1, a2, ..., an (|ai| ≤ 10 000).\n\nOutputOutput a real number denoting the minimum possible weakness of a1 - x, a2 - x, ..., an - x. Your answer will be considered correct if its relative or absolute error doesn't exceed 10 - 6.\n\nInputCopy31 2 3OutputCopy1.000000000000000InputCopy41 2 3 4OutputCopy2.000000000000000InputCopy101 10 2 9 3 8 4 7 5 6OutputCopy4.500000000000000\n\nInputCopy31 2 3\n\nOutputCopy1.000000000000000\n\nInputCopy41 2 3 4\n\nOutputCopy2.000000000000000\n\nInputCopy101 10 2 9 3 8 4 7 5 6\n\nOutputCopy4.500000000000000\n\nNoteFor the first case, the optimal value of x is 2 so the sequence becomes  - 1, 0, 1 and the max poorness occurs at the segment \"-1\" or segment \"1\". The poorness value (answer) equals to 1 in this case. For the second sample the optimal value of x is 2.5 so the sequence becomes  - 1.5,  - 0.5, 0.5, 1.5 and the max poorness occurs on segment \"-1.5 -0.5\" or \"0.5 1.5\". The poorness value (answer) equals to 2 in this case.",
      "solutions": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] - Codeforces",
          "content": "Hello, everyone! Codeforces Round #320 will be held at Sep/16/2015 18:00 MSK. Note that round starts in the unusual time!The problems are from tmt514, Shik, drazil, and me(dreamoon_love_AA). Also we want to thank Zlobober for helping us preparing the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is my second time organizing a problemset for a Codeforces round (my previous round: #292). In my previous round all problems were provided by me. But I think that if problems are provided by more people, then the contest will be more interesting! So I asked my friends to help me this time. Hope everybody can have fun during the round!Participants in each division will be given six tasks and two and a half hours for solving them (the last four problems in Div. 2 are as same as as the first four problems in Div. 1). Scoring system will be announced later closer to the start of the round.Bayan is an Iranian software company working on large-scale web applications. It doesn't only develop the search engine, but also it holds an annual open competition Bayan Programming Contest with an on-site round in Tehran. The on-site round of 2015 became an international event with many strong participants.Bayan has supported Codeforces on our Codeforces 5-year crowdfunding program. Thank you Bayan! This round is in your honor!UPD 1: Due to technical reasons the round starts at 18:15 Moscow time.UPD 2: The round will use the dynamic scoring with 250 points step.UPD 3: Problems are ordered according to their supposed difficulty.UPD 4: Winners!Div1:1) Um_nik2) Egor3) EndagorionDiv2:1) EmaxxMaster2) gongy3) Irisviel_von_EinzberUPD5: link of Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1762
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces",
          "content": "Problm 1 : Raising BacteriaWrite down x into its binary form. If the ith least significant bit is 1 and x contains n bits, we put one bacteria into this box in the morning of (n + 1 - i)th day. Then at the noon of the nth day, the box will contain x bacteria. So the answer is the number of ones in the binary form of x.code of author's friend: thisProblem 2 : Finding Team MemberSort all possible combinations from high strength to low strength. Then iterator all combinations. If two people in a combination still are not contained in any team. then we make these two people as a team.author's code: thisProblem 3 : A Problem about PolylineIf point (a,b) is located on the up slope/ down slope of this polyline. Then the polyline will pass the point (a - b,0)/(a + b,0).(we call (a - b) or (a + b) as c afterwards) And we can derive that c / (2 * x) should be a positive integer. Another condition we need to satisfy is that x must be larger than or equal to b. It’s easy to show that when those two conditions are satisfied, then the polyline will pass the point (a,b).Formally speaking in math : Let c / (2 * x) = y Then we have x = c / (2 * y) ≥ b and we want to find the maximum integer y. After some more math derivation, we can get the answer is . Besides, the only case of no solution is when a < b.In fact, always dosn't exist or larger than .author's code: #include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n LL a,b;\n cin>>a>>b;\n if(a<b)puts(\"-1\");\n else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n return 0;\n}\nProblem 4 : Or GameWe can describe a strategy as multiplying ai by x ti times so ai will become bi = ai * xti and sum of all ti will be equals to k. The fact is there must be a ti equal to k and all other ti equals to 0. If not, we can choose the largest number bj in sequence b, and change the strategy so that tj = k and all other tj = 0. The change will make the highest bit 1 of bj become higher so the or-ed result would be higher.After knowing the fact, We can iterator all number in sequence a and multiply it by xk and find the maximum value of our target between them. There are several method to do it in lower time complexity. You can check the sample code we provide.(I believe you can understand it quickly.)author's code: #include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n int n,k,x;\n scanf(\"%d%d%d\", &n, &k, &x);\n long long mul=1;\n while(k--)\n mul *= x;\n for(int i = 1; i <= n; i++)\n scanf(\"%I64d\", &a[i]);\n for(int i = 1; i <= n; i++)\n prefix[i] = prefix[i-1] | a[i];\n for(int i = n; i > 0; i--)\n suffix[i] = suffix[i+1] | a[i];\n long long ans = 0;\n for(int i= 1; i <= n; i++)\n ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n printf(\"%I64d\\n\",ans);\n}Problem 5 : Weakness and PoornessLet , we can write down the definition of poorness formally as. It's easy to see that A is a strictly decreasing function of x, and B is a strictly increasing function of x. Thus the minimum of max(A, B) can be found using binary or ternary search. The time complexity is ,Now here give people geometry viewpoint of this problem:let We plot n + 1 straight line y = i * x + bi in the plane for i from 0 to n.We can discover when you are given x. The weakness will be (y coordinator of highest line at x) — (y coordinator of lowest line at x).So we only need to consider the upper convex hull and the lower convex hull of all lines. And the target x value will be one of the intersection of these convex hull.Because you can get these line in order of their slope value. we can use stack to get the convex hulls in O(n).author's code : this (using binary search)code of author's friend (using stack to handle convexhull with O(n), have more precision)Problem 6 : LCS againFollowings are solution in short. Considering the LCS dp table lcs[x][y] which denotes the LCS value of first x characters of S and first y characters of T. If we know lcs[n][n] = n - 1, then we only concern values in the table which abs(x - y) ≤ 1 and all value of lcs[x][y] must be min(x, y) or min(x, y) - 1. So each row contains only 8 states(In fact,three states among these states will never be used), we can do dp on it row by row with time complexity O(n).There is another not dp method. You can refer this comment.author's code: #include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n DRII(n,m);\n RS(s+1);\n REPP(i,1,n+1)s[i]-='a';\n s[n+1]=-1;\n REP(i,m){\n int state=1;\n if(i==s[1])state|=2;\n if(i==s[1]||i==s[2])state|=4;\n dp[1][state]++;\n }\n REPP(i,2,n+1){\n REP(j,8){\n int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n REP(k,m){\n int d2[4]={};\n REPP(l,1,4){\n if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n else d2[l]=max(d2[l-1],d[l]);\n }\n if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n }\n }\n }\n printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n return 0;\n}Problem 7 : Walking!Since there is only one person, it’s not hard to show the difference between the number of left footprints and the number of right footprints is at most one.For a particular possible time order of a sequence of footprints, if there are k backward steps, we can easily divide all footprints into at most k + 1 subsequences without backward steps. Then you might guess that another direction of the induction is also true.That is, we can combine any k + 1 subsequence without backward steps into a whole sequence contains at most k backward steps. Your guess is correct !Now we demostrate the process of combining those subsequences.We only concern the first step and the last step of a divided subsequence. There are four possible combinations, we denote them as LL/LR/RL/RR subsequence separately(the first character is the type of the first step and the second character is the type of the second step).Suppose the number of four types of subseueqnce(LL/LR/RL/RR) are A, B, C, D separately. We have abs(A - D) ≤ 1.We can combine all RR, LL subsequeces in turn into one subsequenceswith at most A + D - 1 backward steps(the result may be of any of the four subsquence types). Now we have at most one LL or RR type subsequence.Then we can combine all RL subsequence into only one RL subsequence with at most A - 1 backward steps easily. And so do LR subsequences. Now we want to combine the final RL and LR subsequences together. We could pick the last footprint among two subsequences, exclude it from the original subsequcne and append it at the tail of another subsequence. The move will not increase the number of backward step and the types of the two subsequences would become RR and LL ! We can easily combine them into one LR or RL subsequence now. If there is still a LL or RR type subsequence reamained. We can easily combine them, too.So if we can divide all footprints into the least number of subsequences without backward steps. Then we have solved the problem. And this part can be done with greedy method.Now we provide one possible greedy method:Firstly, we translate this problem to a maximum matching problem on bipartite graph as following:Take \"RLLRRL\" as example: We split each footprint into two vertices which on is in left part and another is in right part.If two footprints is next to each other in resulted subsequnces, we will connect the left vertex of the former to right vertex of the latter in the corresponded matching. So the matching described in above left graph is subsequences: \"RL-R--\" and \"--L-RL\" and in above right graph is \"RL-R-L\" and \"--L-R-\". we can find that the number of subsequences is (number of footprints) — (value of matching).Due to the graphs produced by this problem is very special, we can solve this bipartite matching as following:Iterate each vertex in left part from top to bottom and find the uppermost vertex which is able to be matched in right part and connect them.If we process this algorithm in \"RLLRRL\", the resulted matching is the above right graph.Why the greedy method is correct? we can prove it by adjusting any maximum matching to our intended matching step by step. In each step, you can find the uppermost vertex the state of which is different to what we intend and change its state. I guess the mission of adjusting is not too hard for you to think out! Please solve it by yourself >_<By the way, I believe there are also many other greedy methods will work. If your greedy method is different to author's. Don't feel strange.author's code: thisProblem 8 : The Mirror BoxIf we view the grid intersections alternatively colored by blue and red like this:Then we know that the two conditions in the description are equivalent to a spanning tree in either entire red intersections or entire blue dots. So we can consider a red spanning tree and blue spanning tree one at a time.We can use disjoint-sets to merge connected components. Each component should be a tree, otherwise some grid edges will be enclosed inside some mirrors. So for the contracted graph, we would like to know how many spanning trees are there. This can be done by Kirchhoff’s theorem.Since there are at most 200 broken mirrors, the number of vertices in the contracted graph should be no more than 401. Hence a O(|V|3) determinant calculation algorithm may be applied onto the matrix.author's code: this",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20368",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10347
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "a[i][j] == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((ab)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 14",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 15",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 16",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 17",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, -10000, 10000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, -10000, 10000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, -10000, 10000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-10000, 10000);\n    } else if (type == \"all_equal\") {\n        int val = rnd.next(-10000, 10000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"increasing\") {\n        if (n <= 20000) {\n            int start = rnd.next(-10000, 10000 - n + 1);\n            for (int i = 0; i < n; ++i)\n                a[i] = start + i;\n        } else {\n            // For larger n, generate sequence with mod to keep within range\n            for (int i = 0; i < n; ++i)\n                a[i] = ((i % 20001) - 10000);\n        }\n    } else if (type == \"decreasing\") {\n        if (n <= 20000) {\n            int start = rnd.next(-10000 + n - 1, 10000);\n            for (int i = 0; i < n; ++i)\n                a[i] = start - i;\n        } else {\n            for (int i = 0; i < n; ++i)\n                a[i] = 10000 - (i % 20001);\n        }\n    } else if (type == \"max_values\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 10000;\n    } else if (type == \"min_values\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = -10000;\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? rnd.next(1, 10000) : rnd.next(-10000, -1);\n    } else if (type == \"small_numbers\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-10, 10);\n    } else if (type == \"large_positive\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 10000);\n    } else if (type == \"large_negative\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-10000, -1);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-10000, 10000);\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-10000, 10000);\n    } else if (type == \"all_equal\") {\n        int val = rnd.next(-10000, 10000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"increasing\") {\n        if (n <= 20000) {\n            int start = rnd.next(-10000, 10000 - n + 1);\n            for (int i = 0; i < n; ++i)\n                a[i] = start + i;\n        } else {\n            // For larger n, generate sequence with mod to keep within range\n            for (int i = 0; i < n; ++i)\n                a[i] = ((i % 20001) - 10000);\n        }\n    } else if (type == \"decreasing\") {\n        if (n <= 20000) {\n            int start = rnd.next(-10000 + n - 1, 10000);\n            for (int i = 0; i < n; ++i)\n                a[i] = start - i;\n        } else {\n            for (int i = 0; i < n; ++i)\n                a[i] = 10000 - (i % 20001);\n        }\n    } else if (type == \"max_values\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 10000;\n    } else if (type == \"min_values\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = -10000;\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? rnd.next(1, 10000) : rnd.next(-10000, -1);\n    } else if (type == \"small_numbers\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-10, 10);\n    } else if (type == \"large_positive\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 10000);\n    } else if (type == \"large_negative\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-10000, -1);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-10000, 10000);\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type all_equal\n./gen -n 1 -type max_values\n./gen -n 1 -type min_values\n\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type alternating\n\n./gen -n 10 -type random\n./gen -n 10 -type small_numbers\n./gen -n 10 -type large_positive\n./gen -n 10 -type large_negative\n\n./gen -n 100 -type random\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type alternating\n\n./gen -n 1000 -type random\n./gen -n 1000 -type all_equal\n./gen -n 1000 -type max_values\n./gen -n 1000 -type min_values\n\n./gen -n 10000 -type random\n./gen -n 10000 -type small_numbers\n./gen -n 10000 -type large_positive\n./gen -n 10000 -type large_negative\n\n./gen -n 100000 -type random\n./gen -n 100000 -type increasing\n./gen -n 100000 -type decreasing\n./gen -n 100000 -type alternating\n\n./gen -n 200000 -type random\n./gen -n 200000 -type all_equal\n./gen -n 200000 -type max_values\n./gen -n 200000 -type min_values\n./gen -n 200000 -type small_numbers\n./gen -n 200000 -type large_positive\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:05.702238",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "578/D",
      "title": "D. LCS Again",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two numbers n and m denoting the length of string S and number of first English lowercase characters forming the character set for strings (1 ≤ n ≤ 100 000, 2 ≤ m ≤ 26).The second line contains string S.",
      "output_spec": "OutputPrint the only line containing the answer.",
      "sample_tests": "ExamplesInputCopy3 3aaaOutputCopy6InputCopy3 3aabOutputCopy11InputCopy1 2aOutputCopy1InputCopy10 9abacadefghOutputCopy789",
      "description": "D. LCS Again\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two numbers n and m denoting the length of string S and number of first English lowercase characters forming the character set for strings (1 ≤ n ≤ 100 000, 2 ≤ m ≤ 26).The second line contains string S.\n\nOutputPrint the only line containing the answer.\n\nInputCopy3 3aaaOutputCopy6InputCopy3 3aabOutputCopy11InputCopy1 2aOutputCopy1InputCopy10 9abacadefghOutputCopy789\n\nInputCopy3 3aaa\n\nOutputCopy6\n\nInputCopy3 3aab\n\nOutputCopy11\n\nInputCopy1 2a\n\nOutputCopy1\n\nInputCopy10 9abacadefgh\n\nOutputCopy789\n\nNoteFor the first sample, the 6 possible strings T are: aab, aac, aba, aca, baa, caa. For the second sample, the 11 possible strings T are: aaa, aac, aba, abb, abc, aca, acb, baa, bab, caa, cab.For the third sample, the only possible string T is b.",
      "solutions": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] - Codeforces",
          "content": "Hello, everyone! Codeforces Round #320 will be held at Sep/16/2015 18:00 MSK. Note that round starts in the unusual time!The problems are from tmt514, Shik, drazil, and me(dreamoon_love_AA). Also we want to thank Zlobober for helping us preparing the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is my second time organizing a problemset for a Codeforces round (my previous round: #292). In my previous round all problems were provided by me. But I think that if problems are provided by more people, then the contest will be more interesting! So I asked my friends to help me this time. Hope everybody can have fun during the round!Participants in each division will be given six tasks and two and a half hours for solving them (the last four problems in Div. 2 are as same as as the first four problems in Div. 1). Scoring system will be announced later closer to the start of the round.Bayan is an Iranian software company working on large-scale web applications. It doesn't only develop the search engine, but also it holds an annual open competition Bayan Programming Contest with an on-site round in Tehran. The on-site round of 2015 became an international event with many strong participants.Bayan has supported Codeforces on our Codeforces 5-year crowdfunding program. Thank you Bayan! This round is in your honor!UPD 1: Due to technical reasons the round starts at 18:15 Moscow time.UPD 2: The round will use the dynamic scoring with 250 points step.UPD 3: Problems are ordered according to their supposed difficulty.UPD 4: Winners!Div1:1) Um_nik2) Egor3) EndagorionDiv2:1) EmaxxMaster2) gongy3) Irisviel_von_EinzberUPD5: link of Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1762
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces",
          "content": "Problm 1 : Raising BacteriaWrite down x into its binary form. If the ith least significant bit is 1 and x contains n bits, we put one bacteria into this box in the morning of (n + 1 - i)th day. Then at the noon of the nth day, the box will contain x bacteria. So the answer is the number of ones in the binary form of x.code of author's friend: thisProblem 2 : Finding Team MemberSort all possible combinations from high strength to low strength. Then iterator all combinations. If two people in a combination still are not contained in any team. then we make these two people as a team.author's code: thisProblem 3 : A Problem about PolylineIf point (a,b) is located on the up slope/ down slope of this polyline. Then the polyline will pass the point (a - b,0)/(a + b,0).(we call (a - b) or (a + b) as c afterwards) And we can derive that c / (2 * x) should be a positive integer. Another condition we need to satisfy is that x must be larger than or equal to b. It’s easy to show that when those two conditions are satisfied, then the polyline will pass the point (a,b).Formally speaking in math : Let c / (2 * x) = y Then we have x = c / (2 * y) ≥ b and we want to find the maximum integer y. After some more math derivation, we can get the answer is . Besides, the only case of no solution is when a < b.In fact, always dosn't exist or larger than .author's code: #include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n LL a,b;\n cin>>a>>b;\n if(a<b)puts(\"-1\");\n else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n return 0;\n}\nProblem 4 : Or GameWe can describe a strategy as multiplying ai by x ti times so ai will become bi = ai * xti and sum of all ti will be equals to k. The fact is there must be a ti equal to k and all other ti equals to 0. If not, we can choose the largest number bj in sequence b, and change the strategy so that tj = k and all other tj = 0. The change will make the highest bit 1 of bj become higher so the or-ed result would be higher.After knowing the fact, We can iterator all number in sequence a and multiply it by xk and find the maximum value of our target between them. There are several method to do it in lower time complexity. You can check the sample code we provide.(I believe you can understand it quickly.)author's code: #include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n int n,k,x;\n scanf(\"%d%d%d\", &n, &k, &x);\n long long mul=1;\n while(k--)\n mul *= x;\n for(int i = 1; i <= n; i++)\n scanf(\"%I64d\", &a[i]);\n for(int i = 1; i <= n; i++)\n prefix[i] = prefix[i-1] | a[i];\n for(int i = n; i > 0; i--)\n suffix[i] = suffix[i+1] | a[i];\n long long ans = 0;\n for(int i= 1; i <= n; i++)\n ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n printf(\"%I64d\\n\",ans);\n}Problem 5 : Weakness and PoornessLet , we can write down the definition of poorness formally as. It's easy to see that A is a strictly decreasing function of x, and B is a strictly increasing function of x. Thus the minimum of max(A, B) can be found using binary or ternary search. The time complexity is ,Now here give people geometry viewpoint of this problem:let We plot n + 1 straight line y = i * x + bi in the plane for i from 0 to n.We can discover when you are given x. The weakness will be (y coordinator of highest line at x) — (y coordinator of lowest line at x).So we only need to consider the upper convex hull and the lower convex hull of all lines. And the target x value will be one of the intersection of these convex hull.Because you can get these line in order of their slope value. we can use stack to get the convex hulls in O(n).author's code : this (using binary search)code of author's friend (using stack to handle convexhull with O(n), have more precision)Problem 6 : LCS againFollowings are solution in short. Considering the LCS dp table lcs[x][y] which denotes the LCS value of first x characters of S and first y characters of T. If we know lcs[n][n] = n - 1, then we only concern values in the table which abs(x - y) ≤ 1 and all value of lcs[x][y] must be min(x, y) or min(x, y) - 1. So each row contains only 8 states(In fact,three states among these states will never be used), we can do dp on it row by row with time complexity O(n).There is another not dp method. You can refer this comment.author's code: #include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n DRII(n,m);\n RS(s+1);\n REPP(i,1,n+1)s[i]-='a';\n s[n+1]=-1;\n REP(i,m){\n int state=1;\n if(i==s[1])state|=2;\n if(i==s[1]||i==s[2])state|=4;\n dp[1][state]++;\n }\n REPP(i,2,n+1){\n REP(j,8){\n int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n REP(k,m){\n int d2[4]={};\n REPP(l,1,4){\n if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n else d2[l]=max(d2[l-1],d[l]);\n }\n if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n }\n }\n }\n printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n return 0;\n}Problem 7 : Walking!Since there is only one person, it’s not hard to show the difference between the number of left footprints and the number of right footprints is at most one.For a particular possible time order of a sequence of footprints, if there are k backward steps, we can easily divide all footprints into at most k + 1 subsequences without backward steps. Then you might guess that another direction of the induction is also true.That is, we can combine any k + 1 subsequence without backward steps into a whole sequence contains at most k backward steps. Your guess is correct !Now we demostrate the process of combining those subsequences.We only concern the first step and the last step of a divided subsequence. There are four possible combinations, we denote them as LL/LR/RL/RR subsequence separately(the first character is the type of the first step and the second character is the type of the second step).Suppose the number of four types of subseueqnce(LL/LR/RL/RR) are A, B, C, D separately. We have abs(A - D) ≤ 1.We can combine all RR, LL subsequeces in turn into one subsequenceswith at most A + D - 1 backward steps(the result may be of any of the four subsquence types). Now we have at most one LL or RR type subsequence.Then we can combine all RL subsequence into only one RL subsequence with at most A - 1 backward steps easily. And so do LR subsequences. Now we want to combine the final RL and LR subsequences together. We could pick the last footprint among two subsequences, exclude it from the original subsequcne and append it at the tail of another subsequence. The move will not increase the number of backward step and the types of the two subsequences would become RR and LL ! We can easily combine them into one LR or RL subsequence now. If there is still a LL or RR type subsequence reamained. We can easily combine them, too.So if we can divide all footprints into the least number of subsequences without backward steps. Then we have solved the problem. And this part can be done with greedy method.Now we provide one possible greedy method:Firstly, we translate this problem to a maximum matching problem on bipartite graph as following:Take \"RLLRRL\" as example: We split each footprint into two vertices which on is in left part and another is in right part.If two footprints is next to each other in resulted subsequnces, we will connect the left vertex of the former to right vertex of the latter in the corresponded matching. So the matching described in above left graph is subsequences: \"RL-R--\" and \"--L-RL\" and in above right graph is \"RL-R-L\" and \"--L-R-\". we can find that the number of subsequences is (number of footprints) — (value of matching).Due to the graphs produced by this problem is very special, we can solve this bipartite matching as following:Iterate each vertex in left part from top to bottom and find the uppermost vertex which is able to be matched in right part and connect them.If we process this algorithm in \"RLLRRL\", the resulted matching is the above right graph.Why the greedy method is correct? we can prove it by adjusting any maximum matching to our intended matching step by step. In each step, you can find the uppermost vertex the state of which is different to what we intend and change its state. I guess the mission of adjusting is not too hard for you to think out! Please solve it by yourself >_<By the way, I believe there are also many other greedy methods will work. If your greedy method is different to author's. Don't feel strange.author's code: thisProblem 8 : The Mirror BoxIf we view the grid intersections alternatively colored by blue and red like this:Then we know that the two conditions in the description are equivalent to a spanning tree in either entire red intersections or entire blue dots. So we can consider a red spanning tree and blue spanning tree one at a time.We can use disjoint-sets to merge connected components. Each component should be a tree, otherwise some grid edges will be enclosed inside some mirrors. So for the contracted graph, we would like to know how many spanning trees are there. This can be done by Kirchhoff’s theorem.Since there are at most 200 broken mirrors, the number of vertices in the contracted graph should be no more than 401. Hence a O(|V|3) determinant calculation algorithm may be applied onto the matrix.author's code: this",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20368",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10347
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "a[i][j] == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((ab)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 14",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 15",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 16",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 17",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 26, \"m\");\n    inf.readEoln();\n\n    string S = inf.readToken();\n    inf.readEoln();\n\n    ensuref(int(S.length()) == n, \"Length of S should be equal to n; n=%d, length of S=%d\", n, int(S.length()));\n\n    char maxAllowed = 'a' + m - 1;\n    for (int i = 0; i < n; i++) {\n        char c = S[i];\n        ensuref(c >= 'a' && c <= maxAllowed, \"Character '%c' at position %d is invalid\", c, i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 26, \"m\");\n    inf.readEoln();\n\n    string S = inf.readToken();\n    inf.readEoln();\n\n    ensuref(int(S.length()) == n, \"Length of S should be equal to n; n=%d, length of S=%d\", n, int(S.length()));\n\n    char maxAllowed = 'a' + m - 1;\n    for (int i = 0; i < n; i++) {\n        char c = S[i];\n        ensuref(c >= 'a' && c <= maxAllowed, \"Character '%c' at position %d is invalid\", c, i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 26, \"m\");\n    inf.readEoln();\n\n    string S = inf.readToken();\n    inf.readEoln();\n\n    ensuref(int(S.length()) == n, \"Length of S should be equal to n; n=%d, length of S=%d\", n, int(S.length()));\n\n    char maxAllowed = 'a' + m - 1;\n    for (int i = 0; i < n; i++) {\n        char c = S[i];\n        ensuref(c >= 'a' && c <= maxAllowed, \"Character '%c' at position %d is invalid\", c, i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string S;\n\n    if (type == \"random\") {\n        // Generate a random string of length n using first m lowercase letters\n        S.resize(n);\n        for (int i = 0; i < n; ++i) {\n            S[i] = 'a' + rnd.next(0, m - 1);\n        }\n    } else if (type == \"all_same\") {\n        // S is made of the same letter\n        char c = 'a' + rnd.next(0, m - 1); // select random letter from m letters\n        S = string(n, c);\n    } else if (type == \"all_different\") {\n        // S is made of different letters\n        if (n > m) {\n            // Not possible to have n different letters from m letters\n            // Generate a random string instead\n            S.resize(n);\n            for (int i = 0; i < n; ++i) {\n                S[i] = 'a' + rnd.next(0, m - 1);\n            }\n        } else {\n            vector<char> letters(m);\n            for (int i = 0; i < m; ++i) {\n                letters[i] = 'a' + i;\n            }\n            shuffle(letters.begin(), letters.end());\n            S = string(letters.begin(), letters.begin() + n);\n        }\n    } else if (type == \"first_letter\") {\n        // S is made up of the first letter\n        S = string(n, 'a');\n    } else if (type == \"last_letter\") {\n        // S is made up of the last letter\n        S = string(n, 'a' + m - 1);\n    } else if (type == \"alternate\") {\n        // S alternates between two letters\n        if (m >= 2) {\n            char c1 = 'a';\n            char c2 = 'a' + 1;\n            S.resize(n);\n            for (int i = 0; i < n; ++i) {\n                S[i] = (i % 2 == 0) ? c1 : c2;\n            }\n        } else {\n            // Cannot alternate with less than 2 letters\n            S = string(n, 'a');\n        }\n    } else if (type == \"periodic\") {\n        // S is made up of a repeating pattern\n        int period = opt<int>(\"period\", 2);\n        period = min(period, n);\n        period = min(period, m);\n        string pattern;\n        for (int i = 0; i < period; ++i) {\n            pattern += 'a' + i;\n        }\n        S.clear();\n        while ((int)S.size() < n) {\n            S += pattern;\n        }\n        S.resize(n);\n    } else if (type == \"reverse\") {\n        // S is a palindrome\n        vector<char> letters(m);\n        for (int i = 0; i < m; ++i) {\n            letters[i] = 'a' + i;\n        }\n        string half;\n        for (int i = 0; i < (n + 1) / 2; ++i) {\n            half += letters[rnd.next(0, m - 1)];\n        }\n        S = half;\n        for (int i = n / 2 - 1; i >= 0; --i) {\n            S += half[i];\n        }\n    } else {\n        // Default to random\n        S.resize(n);\n        for (int i = 0; i < n; ++i) {\n            S[i] = 'a' + rnd.next(0, m - 1);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output S\n    printf(\"%s\\n\", S.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string S;\n\n    if (type == \"random\") {\n        // Generate a random string of length n using first m lowercase letters\n        S.resize(n);\n        for (int i = 0; i < n; ++i) {\n            S[i] = 'a' + rnd.next(0, m - 1);\n        }\n    } else if (type == \"all_same\") {\n        // S is made of the same letter\n        char c = 'a' + rnd.next(0, m - 1); // select random letter from m letters\n        S = string(n, c);\n    } else if (type == \"all_different\") {\n        // S is made of different letters\n        if (n > m) {\n            // Not possible to have n different letters from m letters\n            // Generate a random string instead\n            S.resize(n);\n            for (int i = 0; i < n; ++i) {\n                S[i] = 'a' + rnd.next(0, m - 1);\n            }\n        } else {\n            vector<char> letters(m);\n            for (int i = 0; i < m; ++i) {\n                letters[i] = 'a' + i;\n            }\n            shuffle(letters.begin(), letters.end());\n            S = string(letters.begin(), letters.begin() + n);\n        }\n    } else if (type == \"first_letter\") {\n        // S is made up of the first letter\n        S = string(n, 'a');\n    } else if (type == \"last_letter\") {\n        // S is made up of the last letter\n        S = string(n, 'a' + m - 1);\n    } else if (type == \"alternate\") {\n        // S alternates between two letters\n        if (m >= 2) {\n            char c1 = 'a';\n            char c2 = 'a' + 1;\n            S.resize(n);\n            for (int i = 0; i < n; ++i) {\n                S[i] = (i % 2 == 0) ? c1 : c2;\n            }\n        } else {\n            // Cannot alternate with less than 2 letters\n            S = string(n, 'a');\n        }\n    } else if (type == \"periodic\") {\n        // S is made up of a repeating pattern\n        int period = opt<int>(\"period\", 2);\n        period = min(period, n);\n        period = min(period, m);\n        string pattern;\n        for (int i = 0; i < period; ++i) {\n            pattern += 'a' + i;\n        }\n        S.clear();\n        while ((int)S.size() < n) {\n            S += pattern;\n        }\n        S.resize(n);\n    } else if (type == \"reverse\") {\n        // S is a palindrome\n        vector<char> letters(m);\n        for (int i = 0; i < m; ++i) {\n            letters[i] = 'a' + i;\n        }\n        string half;\n        for (int i = 0; i < (n + 1) / 2; ++i) {\n            half += letters[rnd.next(0, m - 1)];\n        }\n        S = half;\n        for (int i = n / 2 - 1; i >= 0; --i) {\n            S += half[i];\n        }\n    } else {\n        // Default to random\n        S.resize(n);\n        for (int i = 0; i < n; ++i) {\n            S[i] = 'a' + rnd.next(0, m - 1);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output S\n    printf(\"%s\\n\", S.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 2 -type first_letter\n./gen -n 1 -m 2 -type last_letter\n./gen -n 2 -m 2 -type first_letter\n./gen -n 2 -m 2 -type alternate\n./gen -n 5 -m 3 -type periodic -period 3\n./gen -n 5 -m 3 -type all_same\n./gen -n 5 -m 5 -type all_different\n./gen -n 100000 -m 2 -type alternate\n./gen -n 100000 -m 26 -type random\n./gen -n 99999 -m 26 -type random\n./gen -n 100000 -m 26 -type all_same\n./gen -n 100000 -m 2 -type last_letter\n./gen -n 26 -m 26 -type all_different\n./gen -n 99999 -m 2 -type all_same\n./gen -n 1 -m 26 -type first_letter\n./gen -n 100000 -m 3 -type periodic -period 2\n./gen -n 100000 -m 26 -type reverse\n./gen -n 100000 -m 2 -type random\n./gen -n 100000 -m 26 -type alternate\n./gen -n 50000 -m 26 -type all_same\n./gen -n 50000 -m 13 -type random\n./gen -n 12345 -m 5 -type periodic -period 3\n./gen -n 67890 -m 26 -type random\n./gen -n 99999 -m 4 -type periodic -period 4\n./gen -n 100000 -m 2 -type first_letter\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:07.660455",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "578/E",
      "title": "E. Walking!",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputOnly one line containing the string S (1 ≤ |S| ≤ 100 000) containing all footprints in order along the trail from entrance to exit.It is guaranteed that there is at least one possible footprint history.",
      "output_spec": "OutputYou should output 2 lines.The first line should contain a number denoting the minimum number of backward steps.The second line should contain a permutation of integers from 1 to |S|. This permutation should denote the order of footprints that may possible be used by person walked there.If there are several possible answers, you may output any of them.",
      "sample_tests": "ExamplesInputCopyRRLRLOutputCopy12 5 1 3 4InputCopyRLRLRLRLROutputCopy01 2 3 4 5 6 7 8 9InputCopyRRRRRLLLLOutputCopy44 9 3 8 2 7 1 6 5",
      "description": "E. Walking!\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputOnly one line containing the string S (1 ≤ |S| ≤ 100 000) containing all footprints in order along the trail from entrance to exit.It is guaranteed that there is at least one possible footprint history.\n\nOutputYou should output 2 lines.The first line should contain a number denoting the minimum number of backward steps.The second line should contain a permutation of integers from 1 to |S|. This permutation should denote the order of footprints that may possible be used by person walked there.If there are several possible answers, you may output any of them.\n\nInputCopyRRLRLOutputCopy12 5 1 3 4InputCopyRLRLRLRLROutputCopy01 2 3 4 5 6 7 8 9InputCopyRRRRRLLLLOutputCopy44 9 3 8 2 7 1 6 5\n\nInputCopyRRLRL\n\nOutputCopy12 5 1 3 4\n\nInputCopyRLRLRLRLR\n\nOutputCopy01 2 3 4 5 6 7 8 9\n\nInputCopyRRRRRLLLL\n\nOutputCopy44 9 3 8 2 7 1 6 5\n\nNoteFor the first sample, one possible order is 2 → 5 → 1 → 3 → 4, among them only the step 5 → 1 is backward step so the answer is 1. For the second example one possible order is just to follow the order of input, thus there are no backward steps. For the third sample, there will be 4 backward steps because every step from L to R will be a backward step.",
      "solutions": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] - Codeforces",
          "content": "Hello, everyone! Codeforces Round #320 will be held at Sep/16/2015 18:00 MSK. Note that round starts in the unusual time!The problems are from tmt514, Shik, drazil, and me(dreamoon_love_AA). Also we want to thank Zlobober for helping us preparing the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is my second time organizing a problemset for a Codeforces round (my previous round: #292). In my previous round all problems were provided by me. But I think that if problems are provided by more people, then the contest will be more interesting! So I asked my friends to help me this time. Hope everybody can have fun during the round!Participants in each division will be given six tasks and two and a half hours for solving them (the last four problems in Div. 2 are as same as as the first four problems in Div. 1). Scoring system will be announced later closer to the start of the round.Bayan is an Iranian software company working on large-scale web applications. It doesn't only develop the search engine, but also it holds an annual open competition Bayan Programming Contest with an on-site round in Tehran. The on-site round of 2015 became an international event with many strong participants.Bayan has supported Codeforces on our Codeforces 5-year crowdfunding program. Thank you Bayan! This round is in your honor!UPD 1: Due to technical reasons the round starts at 18:15 Moscow time.UPD 2: The round will use the dynamic scoring with 250 points step.UPD 3: Problems are ordered according to their supposed difficulty.UPD 4: Winners!Div1:1) Um_nik2) Egor3) EndagorionDiv2:1) EmaxxMaster2) gongy3) Irisviel_von_EinzberUPD5: link of Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1762
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces",
          "content": "Problm 1 : Raising BacteriaWrite down x into its binary form. If the ith least significant bit is 1 and x contains n bits, we put one bacteria into this box in the morning of (n + 1 - i)th day. Then at the noon of the nth day, the box will contain x bacteria. So the answer is the number of ones in the binary form of x.code of author's friend: thisProblem 2 : Finding Team MemberSort all possible combinations from high strength to low strength. Then iterator all combinations. If two people in a combination still are not contained in any team. then we make these two people as a team.author's code: thisProblem 3 : A Problem about PolylineIf point (a,b) is located on the up slope/ down slope of this polyline. Then the polyline will pass the point (a - b,0)/(a + b,0).(we call (a - b) or (a + b) as c afterwards) And we can derive that c / (2 * x) should be a positive integer. Another condition we need to satisfy is that x must be larger than or equal to b. It’s easy to show that when those two conditions are satisfied, then the polyline will pass the point (a,b).Formally speaking in math : Let c / (2 * x) = y Then we have x = c / (2 * y) ≥ b and we want to find the maximum integer y. After some more math derivation, we can get the answer is . Besides, the only case of no solution is when a < b.In fact, always dosn't exist or larger than .author's code: #include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n LL a,b;\n cin>>a>>b;\n if(a<b)puts(\"-1\");\n else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n return 0;\n}\nProblem 4 : Or GameWe can describe a strategy as multiplying ai by x ti times so ai will become bi = ai * xti and sum of all ti will be equals to k. The fact is there must be a ti equal to k and all other ti equals to 0. If not, we can choose the largest number bj in sequence b, and change the strategy so that tj = k and all other tj = 0. The change will make the highest bit 1 of bj become higher so the or-ed result would be higher.After knowing the fact, We can iterator all number in sequence a and multiply it by xk and find the maximum value of our target between them. There are several method to do it in lower time complexity. You can check the sample code we provide.(I believe you can understand it quickly.)author's code: #include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n int n,k,x;\n scanf(\"%d%d%d\", &n, &k, &x);\n long long mul=1;\n while(k--)\n mul *= x;\n for(int i = 1; i <= n; i++)\n scanf(\"%I64d\", &a[i]);\n for(int i = 1; i <= n; i++)\n prefix[i] = prefix[i-1] | a[i];\n for(int i = n; i > 0; i--)\n suffix[i] = suffix[i+1] | a[i];\n long long ans = 0;\n for(int i= 1; i <= n; i++)\n ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n printf(\"%I64d\\n\",ans);\n}Problem 5 : Weakness and PoornessLet , we can write down the definition of poorness formally as. It's easy to see that A is a strictly decreasing function of x, and B is a strictly increasing function of x. Thus the minimum of max(A, B) can be found using binary or ternary search. The time complexity is ,Now here give people geometry viewpoint of this problem:let We plot n + 1 straight line y = i * x + bi in the plane for i from 0 to n.We can discover when you are given x. The weakness will be (y coordinator of highest line at x) — (y coordinator of lowest line at x).So we only need to consider the upper convex hull and the lower convex hull of all lines. And the target x value will be one of the intersection of these convex hull.Because you can get these line in order of their slope value. we can use stack to get the convex hulls in O(n).author's code : this (using binary search)code of author's friend (using stack to handle convexhull with O(n), have more precision)Problem 6 : LCS againFollowings are solution in short. Considering the LCS dp table lcs[x][y] which denotes the LCS value of first x characters of S and first y characters of T. If we know lcs[n][n] = n - 1, then we only concern values in the table which abs(x - y) ≤ 1 and all value of lcs[x][y] must be min(x, y) or min(x, y) - 1. So each row contains only 8 states(In fact,three states among these states will never be used), we can do dp on it row by row with time complexity O(n).There is another not dp method. You can refer this comment.author's code: #include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n DRII(n,m);\n RS(s+1);\n REPP(i,1,n+1)s[i]-='a';\n s[n+1]=-1;\n REP(i,m){\n int state=1;\n if(i==s[1])state|=2;\n if(i==s[1]||i==s[2])state|=4;\n dp[1][state]++;\n }\n REPP(i,2,n+1){\n REP(j,8){\n int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n REP(k,m){\n int d2[4]={};\n REPP(l,1,4){\n if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n else d2[l]=max(d2[l-1],d[l]);\n }\n if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n }\n }\n }\n printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n return 0;\n}Problem 7 : Walking!Since there is only one person, it’s not hard to show the difference between the number of left footprints and the number of right footprints is at most one.For a particular possible time order of a sequence of footprints, if there are k backward steps, we can easily divide all footprints into at most k + 1 subsequences without backward steps. Then you might guess that another direction of the induction is also true.That is, we can combine any k + 1 subsequence without backward steps into a whole sequence contains at most k backward steps. Your guess is correct !Now we demostrate the process of combining those subsequences.We only concern the first step and the last step of a divided subsequence. There are four possible combinations, we denote them as LL/LR/RL/RR subsequence separately(the first character is the type of the first step and the second character is the type of the second step).Suppose the number of four types of subseueqnce(LL/LR/RL/RR) are A, B, C, D separately. We have abs(A - D) ≤ 1.We can combine all RR, LL subsequeces in turn into one subsequenceswith at most A + D - 1 backward steps(the result may be of any of the four subsquence types). Now we have at most one LL or RR type subsequence.Then we can combine all RL subsequence into only one RL subsequence with at most A - 1 backward steps easily. And so do LR subsequences. Now we want to combine the final RL and LR subsequences together. We could pick the last footprint among two subsequences, exclude it from the original subsequcne and append it at the tail of another subsequence. The move will not increase the number of backward step and the types of the two subsequences would become RR and LL ! We can easily combine them into one LR or RL subsequence now. If there is still a LL or RR type subsequence reamained. We can easily combine them, too.So if we can divide all footprints into the least number of subsequences without backward steps. Then we have solved the problem. And this part can be done with greedy method.Now we provide one possible greedy method:Firstly, we translate this problem to a maximum matching problem on bipartite graph as following:Take \"RLLRRL\" as example: We split each footprint into two vertices which on is in left part and another is in right part.If two footprints is next to each other in resulted subsequnces, we will connect the left vertex of the former to right vertex of the latter in the corresponded matching. So the matching described in above left graph is subsequences: \"RL-R--\" and \"--L-RL\" and in above right graph is \"RL-R-L\" and \"--L-R-\". we can find that the number of subsequences is (number of footprints) — (value of matching).Due to the graphs produced by this problem is very special, we can solve this bipartite matching as following:Iterate each vertex in left part from top to bottom and find the uppermost vertex which is able to be matched in right part and connect them.If we process this algorithm in \"RLLRRL\", the resulted matching is the above right graph.Why the greedy method is correct? we can prove it by adjusting any maximum matching to our intended matching step by step. In each step, you can find the uppermost vertex the state of which is different to what we intend and change its state. I guess the mission of adjusting is not too hard for you to think out! Please solve it by yourself >_<By the way, I believe there are also many other greedy methods will work. If your greedy method is different to author's. Don't feel strange.author's code: thisProblem 8 : The Mirror BoxIf we view the grid intersections alternatively colored by blue and red like this:Then we know that the two conditions in the description are equivalent to a spanning tree in either entire red intersections or entire blue dots. So we can consider a red spanning tree and blue spanning tree one at a time.We can use disjoint-sets to merge connected components. Each component should be a tree, otherwise some grid edges will be enclosed inside some mirrors. So for the contracted graph, we would like to know how many spanning trees are there. This can be done by Kirchhoff’s theorem.Since there are at most 200 broken mirrors, the number of vertices in the contracted graph should be no more than 401. Hence a O(|V|3) determinant calculation algorithm may be applied onto the matrix.author's code: this",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20368",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10347
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "a[i][j] == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((ab)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 14",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 15",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 16",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 17",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string S = inf.readLine(\"[LR]{1,100000}\", \"S\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string S = inf.readLine(\"[LR]{1,100000}\", \"S\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string S = inf.readLine(\"[LR]{1,100000}\", \"S\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Counts how many times a consecutive pair goes \"backwards\" (i.e. seq[i+1] < seq[i]).\nint countBackwardSteps(const vector<int>& seq) {\n    int cnt = 0;\n    for (int i = 0; i + 1 < (int)seq.size(); i++) {\n        if (seq[i + 1] < seq[i]) cnt++;\n    }\n    return cnt;\n}\n\n// Builds a walk sequence by interleaving r[] and l[] footprints,\n// starting with the 'rFirst' foot pattern. Only meaningful if\n// |r.size() - l.size()| <= 1. Returns an empty vector if the full\n// interleaving can't produce exactly r.size() + l.size() steps.\nvector<int> buildSequence(const vector<int>& r, const vector<int>& l, bool rFirst) {\n    vector<int> seq;\n    seq.reserve(r.size() + l.size());\n    int i = 0, nR = (int)r.size(), nL = (int)l.size();\n    // Interleave\n    while (i < nR && i < nL) {\n        if (rFirst) {\n            seq.push_back(r[i]);\n            seq.push_back(l[i]);\n        } else {\n            seq.push_back(l[i]);\n            seq.push_back(r[i]);\n        }\n        i++;\n    }\n    // If there's a leftover foot\n    if (i < nR) seq.push_back(r[i]);\n    if (i < nL) seq.push_back(l[i]);\n    // Sanity check: must use up all footprints\n    if ((int)seq.size() != (nR + nL)) {\n        // can't produce the full walk properly\n        return {};\n    }\n    return seq;\n}\n\n// Checks if perm[] (1-based indices) is consistent with an alternating foot pattern\n// (either R->L->R->L... or L->R->L->R...) given the string S.\n// Returns true if valid for exactly one of the two possible starts.\nbool checkFootPattern(const string &S, const vector<int> &perm) {\n    // Try \"R first\" pattern\n    bool okR = true;\n    for (int i = 0; i < (int)perm.size(); i++) {\n        char needed = ((i % 2) == 0 ? 'R' : 'L');\n        if (S[perm[i] - 1] != needed) {\n            okR = false;\n            break;\n        }\n    }\n    // Try \"L first\" pattern\n    bool okL = true;\n    for (int i = 0; i < (int)perm.size(); i++) {\n        char needed = ((i % 2) == 0 ? 'L' : 'R');\n        if (S[perm[i] - 1] != needed) {\n            okL = false;\n            break;\n        }\n    }\n    return (okR || okL);\n}\n\n// Computes the minimal number of backward steps over all valid ways of\n// interleaving R/L footprints in ascending or descending index order,\n// for both possible starting feet.\nint computeMinimalBackward(const string &S) {\n    int n = (int)S.size();\n    // Collect indices of R and L footprints (1-based).\n    vector<int> R, L;\n    R.reserve(n);\n    L.reserve(n);\n    for (int i = 0; i < n; i++) {\n        if (S[i] == 'R') R.push_back(i + 1);\n        else L.push_back(i + 1);\n    }\n    // Sort ascending\n    sort(R.begin(), R.end());\n    sort(L.begin(), L.end());\n    // Make descending copies\n    vector<int> Rdesc = R, Ldesc = L;\n    reverse(Rdesc.begin(), Rdesc.end());\n    reverse(Ldesc.begin(), Ldesc.end());\n\n    // We'll try up to 8 possible merges:\n    //  - foot pattern = R-first or L-first\n    //  - R ascending or descending\n    //  - L ascending or descending\n    // We'll keep track of the global minimum\n    int best = INT_MAX;\n    // Helper lambda to process a pattern and update best\n    auto tryPattern = [&](const vector<int>& rArr, const vector<int>& lArr, bool rFirst) {\n        auto seq = buildSequence(rArr, lArr, rFirst);\n        if (!seq.empty() && (int)seq.size() == n) {\n            best = min(best, countBackwardSteps(seq));\n        }\n    };\n\n    // Try all combos\n    // R-first\n    tryPattern(R, L, true);\n    tryPattern(R, Ldesc, true);\n    tryPattern(Rdesc, L, true);\n    tryPattern(Rdesc, Ldesc, true);\n    // L-first\n    tryPattern(R, L, false);\n    tryPattern(R, Ldesc, false);\n    tryPattern(Rdesc, L, false);\n    tryPattern(Rdesc, Ldesc, false);\n\n    return best;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // FIX: use readToken() without an argument so it doesn't interpret\n    // \"S\" as a regular expression.\n    string S = inf.readToken();\n    int n = (int)S.size();\n\n    // Read contestant's output\n    int claimedMin = ouf.readInt(0, n - 1, \"claimed_min_backward_steps\");\n    vector<int> perm(n);\n    {\n        vector<bool> used(n, false);\n        for (int i = 0; i < n; i++) {\n            int x = ouf.readInt(1, n, \"perm[i]\");\n            if (used[x - 1]) {\n                ouf.quitf(_wa, \"duplicate index %d in the permutation\", x);\n            }\n            used[x - 1] = true;\n            perm[i] = x;\n        }\n    }\n\n    // 1) Check foot pattern consistency\n    if (!checkFootPattern(S, perm)) {\n        ouf.quitf(_wa, \"the permutation does not respect alternating feet\");\n    }\n\n    // 2) Check the actual number of backward steps in the given permutation\n    int actualBackward = countBackwardSteps(perm);\n    if (actualBackward != claimedMin) {\n        ouf.quitf(_wa,\n                  \"claimed backward steps = %d, but found = %d in the provided permutation\",\n                  claimedMin, actualBackward);\n    }\n\n    // 3) Check if claimedMin is actually minimal\n    int correctMin = computeMinimalBackward(S);\n    if (claimedMin != correctMin) {\n        ouf.quitf(_wa,\n                  \"the submitted solution is not minimal, minimal = %d, your claimed = %d\",\n                  correctMin, claimedMin);\n    }\n\n    // Everything is good\n    ouf.quitf(_ok, \"solution is correct, minimal backward steps = %d\", claimedMin);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string S(n, ' ');\n\n    if (type == \"all_L\") {\n        fill(S.begin(), S.end(), 'L');\n    } else if (type == \"all_R\") {\n        fill(S.begin(), S.end(), 'R');\n    } else if (type == \"alternate_LR\") {\n        for (int i = 0; i < n; ++i) {\n            S[i] = (i % 2 == 0) ? 'L' : 'R';\n        }\n    } else if (type == \"alternate_RL\") {\n        for (int i = 0; i < n; ++i) {\n            S[i] = (i % 2 == 0) ? 'R' : 'L';\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            S[i] = rnd.next(0, 1) ? 'L' : 'R';\n        }\n    } else if (type == \"blocks\") {\n        int k = opt<int>(\"k\", 10);\n        vector<int> block_sizes(k, n / k);\n        int remainder = n % k;\n        for (int i = 0; i < remainder; ++i) {\n            ++block_sizes[i];\n        }\n        char c = rnd.next(0, 1) ? 'L' : 'R';\n        int idx = 0;\n        for (int i = 0; i < k; ++i) {\n            for (int j = 0; j < block_sizes[i]; ++j) {\n                S[idx++] = c;\n            }\n            c = (c == 'L') ? 'R' : 'L';\n        }\n    } else if (type == \"max_backward\") {\n        int half = n / 2;\n        fill(S.begin(), S.begin() + half, 'L');\n        fill(S.begin() + half, S.end(), 'R');\n    } else if (type == \"min_backward\") {\n        for (int i = 0; i < n; ++i) {\n            S[i] = (i % 2 == 0) ? 'L' : 'R';\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    cout << S << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string S(n, ' ');\n\n    if (type == \"all_L\") {\n        fill(S.begin(), S.end(), 'L');\n    } else if (type == \"all_R\") {\n        fill(S.begin(), S.end(), 'R');\n    } else if (type == \"alternate_LR\") {\n        for (int i = 0; i < n; ++i) {\n            S[i] = (i % 2 == 0) ? 'L' : 'R';\n        }\n    } else if (type == \"alternate_RL\") {\n        for (int i = 0; i < n; ++i) {\n            S[i] = (i % 2 == 0) ? 'R' : 'L';\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            S[i] = rnd.next(0, 1) ? 'L' : 'R';\n        }\n    } else if (type == \"blocks\") {\n        int k = opt<int>(\"k\", 10);\n        vector<int> block_sizes(k, n / k);\n        int remainder = n % k;\n        for (int i = 0; i < remainder; ++i) {\n            ++block_sizes[i];\n        }\n        char c = rnd.next(0, 1) ? 'L' : 'R';\n        int idx = 0;\n        for (int i = 0; i < k; ++i) {\n            for (int j = 0; j < block_sizes[i]; ++j) {\n                S[idx++] = c;\n            }\n            c = (c == 'L') ? 'R' : 'L';\n        }\n    } else if (type == \"max_backward\") {\n        int half = n / 2;\n        fill(S.begin(), S.begin() + half, 'L');\n        fill(S.begin() + half, S.end(), 'R');\n    } else if (type == \"min_backward\") {\n        for (int i = 0; i < n; ++i) {\n            S[i] = (i % 2 == 0) ? 'L' : 'R';\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    cout << S << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_L\n./gen -n 1 -type all_R\n./gen -n 2 -type alternate_LR\n./gen -n 2 -type alternate_RL\n./gen -n 10 -type random\n./gen -n 10 -type blocks -k 2\n./gen -n 50 -type max_backward\n./gen -n 50 -type min_backward\n./gen -n 100 -type all_L\n./gen -n 100 -type all_R\n./gen -n 100 -type alternate_LR\n./gen -n 100 -type alternate_RL\n./gen -n 500 -type random\n./gen -n 500 -type blocks -k 5\n./gen -n 1000 -type max_backward\n./gen -n 1000 -type min_backward\n./gen -n 10000 -type random\n./gen -n 10000 -type blocks -k 100\n./gen -n 100000 -type all_L\n./gen -n 100000 -type all_R\n./gen -n 100000 -type alternate_LR\n./gen -n 100000 -type alternate_RL\n./gen -n 100000 -type random\n./gen -n 100000 -type blocks -k 1000\n./gen -n 100000 -type max_backward\n./gen -n 100000 -type min_backward\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:09.841982",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "578/F",
      "title": "F. Mirror Box",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m, MOD (1 ≤ n, m ≤ 100, 3 ≤ MOD ≤ 109 + 7, MOD is prime), m, n indicates the dimensions of a box and MOD is the number to module the answer.The following n lines each contains a string of length m. Each string contains only ' / ', '\\', '*', where '*' denotes that the mirror in that grid has been destroyed. It is guaranteed that the number of '*' is no more than 200.",
      "output_spec": "OutputOutput the answer modulo MOD.",
      "sample_tests": "ExamplesInputCopy2 2 1000000007*//*OutputCopy1InputCopy2 2 1000000007**\\\\OutputCopy1InputCopy2 2 3****OutputCopy2",
      "description": "F. Mirror Box\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains three integers n, m, MOD (1 ≤ n, m ≤ 100, 3 ≤ MOD ≤ 109 + 7, MOD is prime), m, n indicates the dimensions of a box and MOD is the number to module the answer.The following n lines each contains a string of length m. Each string contains only ' / ', '\\', '*', where '*' denotes that the mirror in that grid has been destroyed. It is guaranteed that the number of '*' is no more than 200.\n\nOutputOutput the answer modulo MOD.\n\nInputCopy2 2 1000000007*//*OutputCopy1InputCopy2 2 1000000007**\\\\OutputCopy1InputCopy2 2 3****OutputCopy2\n\nInputCopy2 2 1000000007*//*\n\nOutputCopy1\n\nInputCopy2 2 1000000007**\\\\\n\nOutputCopy1\n\nInputCopy2 2 3****\n\nOutputCopy2\n\nNoteThe only way for sample 1 is shown on the left picture from the statement.The only way for sample 2 is shown on the right picture from the statement.For the third sample, there are 5 possibilities that are listed below: 1.2.3.4.5.The answer is then module by 3 so the output should be 2.",
      "solutions": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] - Codeforces",
          "content": "Hello, everyone! Codeforces Round #320 will be held at Sep/16/2015 18:00 MSK. Note that round starts in the unusual time!The problems are from tmt514, Shik, drazil, and me(dreamoon_love_AA). Also we want to thank Zlobober for helping us preparing the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is my second time organizing a problemset for a Codeforces round (my previous round: #292). In my previous round all problems were provided by me. But I think that if problems are provided by more people, then the contest will be more interesting! So I asked my friends to help me this time. Hope everybody can have fun during the round!Participants in each division will be given six tasks and two and a half hours for solving them (the last four problems in Div. 2 are as same as as the first four problems in Div. 1). Scoring system will be announced later closer to the start of the round.Bayan is an Iranian software company working on large-scale web applications. It doesn't only develop the search engine, but also it holds an annual open competition Bayan Programming Contest with an on-site round in Tehran. The on-site round of 2015 became an international event with many strong participants.Bayan has supported Codeforces on our Codeforces 5-year crowdfunding program. Thank you Bayan! This round is in your honor!UPD 1: Due to technical reasons the round starts at 18:15 Moscow time.UPD 2: The round will use the dynamic scoring with 250 points step.UPD 3: Problems are ordered according to their supposed difficulty.UPD 4: Winners!Div1:1) Um_nik2) Egor3) EndagorionDiv2:1) EmaxxMaster2) gongy3) Irisviel_von_EinzberUPD5: link of Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1762
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces",
          "content": "Problm 1 : Raising BacteriaWrite down x into its binary form. If the ith least significant bit is 1 and x contains n bits, we put one bacteria into this box in the morning of (n + 1 - i)th day. Then at the noon of the nth day, the box will contain x bacteria. So the answer is the number of ones in the binary form of x.code of author's friend: thisProblem 2 : Finding Team MemberSort all possible combinations from high strength to low strength. Then iterator all combinations. If two people in a combination still are not contained in any team. then we make these two people as a team.author's code: thisProblem 3 : A Problem about PolylineIf point (a,b) is located on the up slope/ down slope of this polyline. Then the polyline will pass the point (a - b,0)/(a + b,0).(we call (a - b) or (a + b) as c afterwards) And we can derive that c / (2 * x) should be a positive integer. Another condition we need to satisfy is that x must be larger than or equal to b. It’s easy to show that when those two conditions are satisfied, then the polyline will pass the point (a,b).Formally speaking in math : Let c / (2 * x) = y Then we have x = c / (2 * y) ≥ b and we want to find the maximum integer y. After some more math derivation, we can get the answer is . Besides, the only case of no solution is when a < b.In fact, always dosn't exist or larger than .author's code: #include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n LL a,b;\n cin>>a>>b;\n if(a<b)puts(\"-1\");\n else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n return 0;\n}\nProblem 4 : Or GameWe can describe a strategy as multiplying ai by x ti times so ai will become bi = ai * xti and sum of all ti will be equals to k. The fact is there must be a ti equal to k and all other ti equals to 0. If not, we can choose the largest number bj in sequence b, and change the strategy so that tj = k and all other tj = 0. The change will make the highest bit 1 of bj become higher so the or-ed result would be higher.After knowing the fact, We can iterator all number in sequence a and multiply it by xk and find the maximum value of our target between them. There are several method to do it in lower time complexity. You can check the sample code we provide.(I believe you can understand it quickly.)author's code: #include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n int n,k,x;\n scanf(\"%d%d%d\", &n, &k, &x);\n long long mul=1;\n while(k--)\n mul *= x;\n for(int i = 1; i <= n; i++)\n scanf(\"%I64d\", &a[i]);\n for(int i = 1; i <= n; i++)\n prefix[i] = prefix[i-1] | a[i];\n for(int i = n; i > 0; i--)\n suffix[i] = suffix[i+1] | a[i];\n long long ans = 0;\n for(int i= 1; i <= n; i++)\n ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n printf(\"%I64d\\n\",ans);\n}Problem 5 : Weakness and PoornessLet , we can write down the definition of poorness formally as. It's easy to see that A is a strictly decreasing function of x, and B is a strictly increasing function of x. Thus the minimum of max(A, B) can be found using binary or ternary search. The time complexity is ,Now here give people geometry viewpoint of this problem:let We plot n + 1 straight line y = i * x + bi in the plane for i from 0 to n.We can discover when you are given x. The weakness will be (y coordinator of highest line at x) — (y coordinator of lowest line at x).So we only need to consider the upper convex hull and the lower convex hull of all lines. And the target x value will be one of the intersection of these convex hull.Because you can get these line in order of their slope value. we can use stack to get the convex hulls in O(n).author's code : this (using binary search)code of author's friend (using stack to handle convexhull with O(n), have more precision)Problem 6 : LCS againFollowings are solution in short. Considering the LCS dp table lcs[x][y] which denotes the LCS value of first x characters of S and first y characters of T. If we know lcs[n][n] = n - 1, then we only concern values in the table which abs(x - y) ≤ 1 and all value of lcs[x][y] must be min(x, y) or min(x, y) - 1. So each row contains only 8 states(In fact,three states among these states will never be used), we can do dp on it row by row with time complexity O(n).There is another not dp method. You can refer this comment.author's code: #include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n DRII(n,m);\n RS(s+1);\n REPP(i,1,n+1)s[i]-='a';\n s[n+1]=-1;\n REP(i,m){\n int state=1;\n if(i==s[1])state|=2;\n if(i==s[1]||i==s[2])state|=4;\n dp[1][state]++;\n }\n REPP(i,2,n+1){\n REP(j,8){\n int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n REP(k,m){\n int d2[4]={};\n REPP(l,1,4){\n if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n else d2[l]=max(d2[l-1],d[l]);\n }\n if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n }\n }\n }\n printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n return 0;\n}Problem 7 : Walking!Since there is only one person, it’s not hard to show the difference between the number of left footprints and the number of right footprints is at most one.For a particular possible time order of a sequence of footprints, if there are k backward steps, we can easily divide all footprints into at most k + 1 subsequences without backward steps. Then you might guess that another direction of the induction is also true.That is, we can combine any k + 1 subsequence without backward steps into a whole sequence contains at most k backward steps. Your guess is correct !Now we demostrate the process of combining those subsequences.We only concern the first step and the last step of a divided subsequence. There are four possible combinations, we denote them as LL/LR/RL/RR subsequence separately(the first character is the type of the first step and the second character is the type of the second step).Suppose the number of four types of subseueqnce(LL/LR/RL/RR) are A, B, C, D separately. We have abs(A - D) ≤ 1.We can combine all RR, LL subsequeces in turn into one subsequenceswith at most A + D - 1 backward steps(the result may be of any of the four subsquence types). Now we have at most one LL or RR type subsequence.Then we can combine all RL subsequence into only one RL subsequence with at most A - 1 backward steps easily. And so do LR subsequences. Now we want to combine the final RL and LR subsequences together. We could pick the last footprint among two subsequences, exclude it from the original subsequcne and append it at the tail of another subsequence. The move will not increase the number of backward step and the types of the two subsequences would become RR and LL ! We can easily combine them into one LR or RL subsequence now. If there is still a LL or RR type subsequence reamained. We can easily combine them, too.So if we can divide all footprints into the least number of subsequences without backward steps. Then we have solved the problem. And this part can be done with greedy method.Now we provide one possible greedy method:Firstly, we translate this problem to a maximum matching problem on bipartite graph as following:Take \"RLLRRL\" as example: We split each footprint into two vertices which on is in left part and another is in right part.If two footprints is next to each other in resulted subsequnces, we will connect the left vertex of the former to right vertex of the latter in the corresponded matching. So the matching described in above left graph is subsequences: \"RL-R--\" and \"--L-RL\" and in above right graph is \"RL-R-L\" and \"--L-R-\". we can find that the number of subsequences is (number of footprints) — (value of matching).Due to the graphs produced by this problem is very special, we can solve this bipartite matching as following:Iterate each vertex in left part from top to bottom and find the uppermost vertex which is able to be matched in right part and connect them.If we process this algorithm in \"RLLRRL\", the resulted matching is the above right graph.Why the greedy method is correct? we can prove it by adjusting any maximum matching to our intended matching step by step. In each step, you can find the uppermost vertex the state of which is different to what we intend and change its state. I guess the mission of adjusting is not too hard for you to think out! Please solve it by yourself >_<By the way, I believe there are also many other greedy methods will work. If your greedy method is different to author's. Don't feel strange.author's code: thisProblem 8 : The Mirror BoxIf we view the grid intersections alternatively colored by blue and red like this:Then we know that the two conditions in the description are equivalent to a spanning tree in either entire red intersections or entire blue dots. So we can consider a red spanning tree and blue spanning tree one at a time.We can use disjoint-sets to merge connected components. Each component should be a tree, otherwise some grid edges will be enclosed inside some mirrors. So for the contracted graph, we would like to know how many spanning trees are there. This can be done by Kirchhoff’s theorem.Since there are at most 200 broken mirrors, the number of vertices in the contracted graph should be no more than 401. Hence a O(|V|3) determinant calculation algorithm may be applied onto the matrix.author's code: this",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20368",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10347
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "a[i][j] == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((ab)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 14",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 15",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 16",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 17",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nuint64_t mulmod(uint64_t a, uint64_t b, uint64_t mod) {\n    uint64_t result = 0;\n    a %= mod;\n    b %= mod;\n    while (b > 0) {\n        if (b & 1)\n            result = (result + a) % mod;\n        a = (a * 2) % mod;\n        b >>=1;\n    }\n    return result;\n}\n\nuint64_t powermod(uint64_t a, uint64_t b, uint64_t mod) {\n    uint64_t result = 1;\n    a %= mod;\n    while (b > 0) {\n        if (b & 1)\n            result = mulmod(result, a, mod);\n        a = mulmod(a, a, mod);\n        b >>=1;\n    }\n    return result;\n}\n\nbool isPrime(uint64_t n) {\n    if (n < 2) return false;\n    uint64_t d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>=1;\n        s++;\n    }\n    uint64_t bases[] = {2,3,5,7,11};\n    for (uint64_t a : bases) {\n        if (a >= n) continue;\n        uint64_t x = powermod(a, d, n);\n        if (x == 1 || x == n-1) continue;\n        bool composite = true;\n        for (int r = 1; r < s; r++) {\n            x = mulmod(x, x, n);\n            if (x == n -1) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite)\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    uint64_t MOD = inf.readLong(3LL, 1000000007LL, \"MOD\");\n    inf.readEoln();\n\n    ensuref(isPrime(MOD), \"MOD must be a prime number.\");\n\n    int total_stars = 0;\n    string pattern = \"[/\\\\\\\\*]{\" + to_string(m) + \"}\";\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(pattern);\n        total_stars += count(s.begin(), s.end(), '*');\n    }\n\n    ensuref(total_stars <= 200, \"The number of '*' must be at most 200, but found %d\", total_stars);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nuint64_t mulmod(uint64_t a, uint64_t b, uint64_t mod) {\n    uint64_t result = 0;\n    a %= mod;\n    b %= mod;\n    while (b > 0) {\n        if (b & 1)\n            result = (result + a) % mod;\n        a = (a * 2) % mod;\n        b >>=1;\n    }\n    return result;\n}\n\nuint64_t powermod(uint64_t a, uint64_t b, uint64_t mod) {\n    uint64_t result = 1;\n    a %= mod;\n    while (b > 0) {\n        if (b & 1)\n            result = mulmod(result, a, mod);\n        a = mulmod(a, a, mod);\n        b >>=1;\n    }\n    return result;\n}\n\nbool isPrime(uint64_t n) {\n    if (n < 2) return false;\n    uint64_t d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>=1;\n        s++;\n    }\n    uint64_t bases[] = {2,3,5,7,11};\n    for (uint64_t a : bases) {\n        if (a >= n) continue;\n        uint64_t x = powermod(a, d, n);\n        if (x == 1 || x == n-1) continue;\n        bool composite = true;\n        for (int r = 1; r < s; r++) {\n            x = mulmod(x, x, n);\n            if (x == n -1) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite)\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    uint64_t MOD = inf.readLong(3LL, 1000000007LL, \"MOD\");\n    inf.readEoln();\n\n    ensuref(isPrime(MOD), \"MOD must be a prime number.\");\n\n    int total_stars = 0;\n    string pattern = \"[/\\\\\\\\*]{\" + to_string(m) + \"}\";\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(pattern);\n        total_stars += count(s.begin(), s.end(), '*');\n    }\n\n    ensuref(total_stars <= 200, \"The number of '*' must be at most 200, but found %d\", total_stars);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nuint64_t mulmod(uint64_t a, uint64_t b, uint64_t mod) {\n    uint64_t result = 0;\n    a %= mod;\n    b %= mod;\n    while (b > 0) {\n        if (b & 1)\n            result = (result + a) % mod;\n        a = (a * 2) % mod;\n        b >>=1;\n    }\n    return result;\n}\n\nuint64_t powermod(uint64_t a, uint64_t b, uint64_t mod) {\n    uint64_t result = 1;\n    a %= mod;\n    while (b > 0) {\n        if (b & 1)\n            result = mulmod(result, a, mod);\n        a = mulmod(a, a, mod);\n        b >>=1;\n    }\n    return result;\n}\n\nbool isPrime(uint64_t n) {\n    if (n < 2) return false;\n    uint64_t d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>=1;\n        s++;\n    }\n    uint64_t bases[] = {2,3,5,7,11};\n    for (uint64_t a : bases) {\n        if (a >= n) continue;\n        uint64_t x = powermod(a, d, n);\n        if (x == 1 || x == n-1) continue;\n        bool composite = true;\n        for (int r = 1; r < s; r++) {\n            x = mulmod(x, x, n);\n            if (x == n -1) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite)\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    uint64_t MOD = inf.readLong(3LL, 1000000007LL, \"MOD\");\n    inf.readEoln();\n\n    ensuref(isPrime(MOD), \"MOD must be a prime number.\");\n\n    int total_stars = 0;\n    string pattern = \"[/\\\\\\\\*]{\" + to_string(m) + \"}\";\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(pattern);\n        total_stars += count(s.begin(), s.end(), '*');\n    }\n\n    ensuref(total_stars <= 200, \"The number of '*' must be at most 200, but found %d\", total_stars);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int MOD = opt<int>(\"MOD\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check that MOD is within the valid range\n    ensure(3 <= MOD && MOD <= 1000000007);\n\n    // Limit the number of destroyed mirrors to 200\n    int max_destroyed = min(n * m, 200);\n\n    vector<string> grid(n, string(m, ' '));\n\n    if (type == \"full\") {\n        // Fill grid with random mirrors '/' or '\\'\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                grid[i][j] = rnd.next(2) ? '/' : '\\\\';\n    } else if (type == \"empty\") {\n        // All mirrors are destroyed\n        for (int i = 0; i < n; i++)\n            grid[i] = string(m, '*');\n    } else if (type == \"random\") {\n        // Get number of destroyed mirrors 'k', default is 0\n        int k = opt<int>(\"k\", 0);\n        k = min(k, max_destroyed);\n\n        // Fill grid with random mirrors\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                grid[i][j] = rnd.next(2) ? '/' : '\\\\';\n\n        // Randomly destroy 'k' mirrors\n        vector<pair<int, int>> positions;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                positions.emplace_back(i, j);\n\n        shuffle(positions.begin(), positions.end());\n\n        for (int idx = 0; idx < k; idx++) {\n            int i = positions[idx].first;\n            int j = positions[idx].second;\n            grid[i][j] = '*';\n        }\n    } else if (type == \"border_destroyed\") {\n        // Fill grid with random mirrors\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                grid[i][j] = rnd.next(2) ? '/' : '\\\\';\n\n        // Destroy mirrors along the border\n        int count_destroyed = 0;\n        for (int i = 0; i < n && count_destroyed < 200; i++) {\n            grid[i][0] = '*';\n            count_destroyed++;\n            if (m > 1 && count_destroyed < 200) {\n                grid[i][m - 1] = '*';\n                count_destroyed++;\n            }\n        }\n        for (int j = 1; j < m - 1 && count_destroyed < 200; j++) {\n            grid[0][j] = '*';\n            count_destroyed++;\n            if (n > 1 && count_destroyed < 200) {\n                grid[n - 1][j] = '*';\n                count_destroyed++;\n            }\n        }\n    } else if (type == \"max_destroyed\") {\n        // Fill grid with random mirrors\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                grid[i][j] = rnd.next(2) ? '/' : '\\\\';\n\n        // Destroy up to 200 mirrors randomly\n        int k = min(200, n * m);\n        vector<pair<int, int>> positions;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                positions.emplace_back(i, j);\n\n        shuffle(positions.begin(), positions.end());\n\n        for (int idx = 0; idx < k; idx++) {\n            int i = positions[idx].first;\n            int j = positions[idx].second;\n            grid[i][j] = '*';\n        }\n    } else if (type == \"checkerboard\") {\n        // Create a checkerboard pattern\n        int count_destroyed = 0;\n        for (int i = 0; i < n && count_destroyed < 200; i++) {\n            for (int j = 0; j < m && count_destroyed < 200; j++) {\n                if ((i + j) % 2 == 0) {\n                    grid[i][j] = rnd.next(2) ? '/' : '\\\\';\n                } else {\n                    grid[i][j] = '*';\n                    count_destroyed++;\n                }\n            }\n        }\n        // Fill remaining cells if any\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                if (grid[i][j] == ' ')\n                    grid[i][j] = rnd.next(2) ? '/' : '\\\\';\n    } else if (type == \"line_destroyed\") {\n        // Destroy mirrors in a horizontal or vertical line\n        bool horizontal = rnd.next(2);\n        // Fill grid with random mirrors\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                grid[i][j] = rnd.next(2) ? '/' : '\\\\';\n\n        if (horizontal) {\n            int row = rnd.next(n);\n            for (int j = 0; j < m && j < 200; j++) {\n                grid[row][j] = '*';\n            }\n        } else {\n            int col = rnd.next(m);\n            for (int i = 0; i < n && i < 200; i++) {\n                grid[i][col] = '*';\n            }\n        }\n    } else {\n        // Default: Random mirrors with no destroyed mirrors\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                grid[i][j] = rnd.next(2) ? '/' : '\\\\';\n    }\n\n    // Output n, m, MOD\n    printf(\"%d %d %d\\n\", n, m, MOD);\n\n    // Output grid\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int MOD = opt<int>(\"MOD\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check that MOD is within the valid range\n    ensure(3 <= MOD && MOD <= 1000000007);\n\n    // Limit the number of destroyed mirrors to 200\n    int max_destroyed = min(n * m, 200);\n\n    vector<string> grid(n, string(m, ' '));\n\n    if (type == \"full\") {\n        // Fill grid with random mirrors '/' or '\\'\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                grid[i][j] = rnd.next(2) ? '/' : '\\\\';\n    } else if (type == \"empty\") {\n        // All mirrors are destroyed\n        for (int i = 0; i < n; i++)\n            grid[i] = string(m, '*');\n    } else if (type == \"random\") {\n        // Get number of destroyed mirrors 'k', default is 0\n        int k = opt<int>(\"k\", 0);\n        k = min(k, max_destroyed);\n\n        // Fill grid with random mirrors\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                grid[i][j] = rnd.next(2) ? '/' : '\\\\';\n\n        // Randomly destroy 'k' mirrors\n        vector<pair<int, int>> positions;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                positions.emplace_back(i, j);\n\n        shuffle(positions.begin(), positions.end());\n\n        for (int idx = 0; idx < k; idx++) {\n            int i = positions[idx].first;\n            int j = positions[idx].second;\n            grid[i][j] = '*';\n        }\n    } else if (type == \"border_destroyed\") {\n        // Fill grid with random mirrors\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                grid[i][j] = rnd.next(2) ? '/' : '\\\\';\n\n        // Destroy mirrors along the border\n        int count_destroyed = 0;\n        for (int i = 0; i < n && count_destroyed < 200; i++) {\n            grid[i][0] = '*';\n            count_destroyed++;\n            if (m > 1 && count_destroyed < 200) {\n                grid[i][m - 1] = '*';\n                count_destroyed++;\n            }\n        }\n        for (int j = 1; j < m - 1 && count_destroyed < 200; j++) {\n            grid[0][j] = '*';\n            count_destroyed++;\n            if (n > 1 && count_destroyed < 200) {\n                grid[n - 1][j] = '*';\n                count_destroyed++;\n            }\n        }\n    } else if (type == \"max_destroyed\") {\n        // Fill grid with random mirrors\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                grid[i][j] = rnd.next(2) ? '/' : '\\\\';\n\n        // Destroy up to 200 mirrors randomly\n        int k = min(200, n * m);\n        vector<pair<int, int>> positions;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                positions.emplace_back(i, j);\n\n        shuffle(positions.begin(), positions.end());\n\n        for (int idx = 0; idx < k; idx++) {\n            int i = positions[idx].first;\n            int j = positions[idx].second;\n            grid[i][j] = '*';\n        }\n    } else if (type == \"checkerboard\") {\n        // Create a checkerboard pattern\n        int count_destroyed = 0;\n        for (int i = 0; i < n && count_destroyed < 200; i++) {\n            for (int j = 0; j < m && count_destroyed < 200; j++) {\n                if ((i + j) % 2 == 0) {\n                    grid[i][j] = rnd.next(2) ? '/' : '\\\\';\n                } else {\n                    grid[i][j] = '*';\n                    count_destroyed++;\n                }\n            }\n        }\n        // Fill remaining cells if any\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                if (grid[i][j] == ' ')\n                    grid[i][j] = rnd.next(2) ? '/' : '\\\\';\n    } else if (type == \"line_destroyed\") {\n        // Destroy mirrors in a horizontal or vertical line\n        bool horizontal = rnd.next(2);\n        // Fill grid with random mirrors\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                grid[i][j] = rnd.next(2) ? '/' : '\\\\';\n\n        if (horizontal) {\n            int row = rnd.next(n);\n            for (int j = 0; j < m && j < 200; j++) {\n                grid[row][j] = '*';\n            }\n        } else {\n            int col = rnd.next(m);\n            for (int i = 0; i < n && i < 200; i++) {\n                grid[i][col] = '*';\n            }\n        }\n    } else {\n        // Default: Random mirrors with no destroyed mirrors\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                grid[i][j] = rnd.next(2) ? '/' : '\\\\';\n    }\n\n    // Output n, m, MOD\n    printf(\"%d %d %d\\n\", n, m, MOD);\n\n    // Output grid\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -MOD 3 -type full\n./gen -n 1 -m 1 -MOD 3 -type empty\n./gen -n 1 -m 1 -MOD 3 -type random -k 1\n./gen -n 2 -m 2 -MOD 3 -type full\n./gen -n 2 -m 2 -MOD 3 -type empty\n./gen -n 2 -m 2 -MOD 3 -type random -k 2\n./gen -n 5 -m 5 -MOD 1000000007 -type border_destroyed\n./gen -n 10 -m 10 -MOD 1000000007 -type checkerboard\n./gen -n 100 -m 1 -MOD 1000000007 -type max_destroyed\n./gen -n 1 -m 100 -MOD 1000000007 -type max_destroyed\n./gen -n 100 -m 100 -MOD 1000000007 -type random -k 200\n./gen -n 100 -m 100 -MOD 1000000007 -type full\n./gen -n 100 -m 100 -MOD 1000000007 -type empty\n./gen -n 100 -m 100 -MOD 1000000007 -type checkerboard\n./gen -n 100 -m 100 -MOD 3 -type random -k 0\n./gen -n 50 -m 50 -MOD 999999937 -type random -k 50\n./gen -n 50 -m 50 -MOD 999999937 -type line_destroyed\n./gen -n 100 -m 100 -MOD 999999937 -type line_destroyed\n./gen -n 99 -m 100 -MOD 1000000007 -type border_destroyed\n./gen -n 100 -m 100 -MOD 3 -type random -k 199\n./gen -n 99 -m 99 -MOD 3 -type random -k 200\n./gen -n 3 -m 3 -MOD 3 -type max_destroyed\n./gen -n 4 -m 4 -MOD 3 -type random\n./gen -n 100 -m 100 -MOD 1000003 -type random\n./gen -n 50 -m 50 -MOD 1000000007 -type random\n./gen -n 70 -m 80 -MOD 999999937 -type random\n./gen -n 100 -m 100 -MOD 1000000007 -type random -k 0\n./gen -n 100 -m 100 -MOD 1000000007 -type random -k 200\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:11.775180",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "579/A",
      "title": "A. Raising Bacteria",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line containing one integer x (1 ≤ x ≤ 109).",
      "output_spec": "OutputThe only line containing one integer: the answer.",
      "sample_tests": "ExamplesInputCopy5OutputCopy2InputCopy8OutputCopy1",
      "description": "A. Raising Bacteria\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line containing one integer x (1 ≤ x ≤ 109).\n\nOutputThe only line containing one integer: the answer.\n\nInputCopy5OutputCopy2InputCopy8OutputCopy1\n\nOutputCopy2\n\nOutputCopy1\n\nNoteFor the first sample, we can add one bacterium in the box in the first day morning and at the third morning there will be 4 bacteria in the box. Now we put one more resulting 5 in the box. We added 2 bacteria in the process so the answer is 2.For the second sample, we can put one in the first morning and in the 4-th morning there will be 8 in the box. So the answer is 1.",
      "solutions": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] - Codeforces",
          "content": "Hello, everyone! Codeforces Round #320 will be held at Sep/16/2015 18:00 MSK. Note that round starts in the unusual time!The problems are from tmt514, Shik, drazil, and me(dreamoon_love_AA). Also we want to thank Zlobober for helping us preparing the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is my second time organizing a problemset for a Codeforces round (my previous round: #292). In my previous round all problems were provided by me. But I think that if problems are provided by more people, then the contest will be more interesting! So I asked my friends to help me this time. Hope everybody can have fun during the round!Participants in each division will be given six tasks and two and a half hours for solving them (the last four problems in Div. 2 are as same as as the first four problems in Div. 1). Scoring system will be announced later closer to the start of the round.Bayan is an Iranian software company working on large-scale web applications. It doesn't only develop the search engine, but also it holds an annual open competition Bayan Programming Contest with an on-site round in Tehran. The on-site round of 2015 became an international event with many strong participants.Bayan has supported Codeforces on our Codeforces 5-year crowdfunding program. Thank you Bayan! This round is in your honor!UPD 1: Due to technical reasons the round starts at 18:15 Moscow time.UPD 2: The round will use the dynamic scoring with 250 points step.UPD 3: Problems are ordered according to their supposed difficulty.UPD 4: Winners!Div1:1) Um_nik2) Egor3) EndagorionDiv2:1) EmaxxMaster2) gongy3) Irisviel_von_EinzberUPD5: link of Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1762
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces",
          "content": "Problm 1 : Raising BacteriaWrite down x into its binary form. If the ith least significant bit is 1 and x contains n bits, we put one bacteria into this box in the morning of (n + 1 - i)th day. Then at the noon of the nth day, the box will contain x bacteria. So the answer is the number of ones in the binary form of x.code of author's friend: thisProblem 2 : Finding Team MemberSort all possible combinations from high strength to low strength. Then iterator all combinations. If two people in a combination still are not contained in any team. then we make these two people as a team.author's code: thisProblem 3 : A Problem about PolylineIf point (a,b) is located on the up slope/ down slope of this polyline. Then the polyline will pass the point (a - b,0)/(a + b,0).(we call (a - b) or (a + b) as c afterwards) And we can derive that c / (2 * x) should be a positive integer. Another condition we need to satisfy is that x must be larger than or equal to b. It’s easy to show that when those two conditions are satisfied, then the polyline will pass the point (a,b).Formally speaking in math : Let c / (2 * x) = y Then we have x = c / (2 * y) ≥ b and we want to find the maximum integer y. After some more math derivation, we can get the answer is . Besides, the only case of no solution is when a < b.In fact, always dosn't exist or larger than .author's code: #include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n LL a,b;\n cin>>a>>b;\n if(a<b)puts(\"-1\");\n else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n return 0;\n}\nProblem 4 : Or GameWe can describe a strategy as multiplying ai by x ti times so ai will become bi = ai * xti and sum of all ti will be equals to k. The fact is there must be a ti equal to k and all other ti equals to 0. If not, we can choose the largest number bj in sequence b, and change the strategy so that tj = k and all other tj = 0. The change will make the highest bit 1 of bj become higher so the or-ed result would be higher.After knowing the fact, We can iterator all number in sequence a and multiply it by xk and find the maximum value of our target between them. There are several method to do it in lower time complexity. You can check the sample code we provide.(I believe you can understand it quickly.)author's code: #include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n int n,k,x;\n scanf(\"%d%d%d\", &n, &k, &x);\n long long mul=1;\n while(k--)\n mul *= x;\n for(int i = 1; i <= n; i++)\n scanf(\"%I64d\", &a[i]);\n for(int i = 1; i <= n; i++)\n prefix[i] = prefix[i-1] | a[i];\n for(int i = n; i > 0; i--)\n suffix[i] = suffix[i+1] | a[i];\n long long ans = 0;\n for(int i= 1; i <= n; i++)\n ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n printf(\"%I64d\\n\",ans);\n}Problem 5 : Weakness and PoornessLet , we can write down the definition of poorness formally as. It's easy to see that A is a strictly decreasing function of x, and B is a strictly increasing function of x. Thus the minimum of max(A, B) can be found using binary or ternary search. The time complexity is ,Now here give people geometry viewpoint of this problem:let We plot n + 1 straight line y = i * x + bi in the plane for i from 0 to n.We can discover when you are given x. The weakness will be (y coordinator of highest line at x) — (y coordinator of lowest line at x).So we only need to consider the upper convex hull and the lower convex hull of all lines. And the target x value will be one of the intersection of these convex hull.Because you can get these line in order of their slope value. we can use stack to get the convex hulls in O(n).author's code : this (using binary search)code of author's friend (using stack to handle convexhull with O(n), have more precision)Problem 6 : LCS againFollowings are solution in short. Considering the LCS dp table lcs[x][y] which denotes the LCS value of first x characters of S and first y characters of T. If we know lcs[n][n] = n - 1, then we only concern values in the table which abs(x - y) ≤ 1 and all value of lcs[x][y] must be min(x, y) or min(x, y) - 1. So each row contains only 8 states(In fact,three states among these states will never be used), we can do dp on it row by row with time complexity O(n).There is another not dp method. You can refer this comment.author's code: #include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n DRII(n,m);\n RS(s+1);\n REPP(i,1,n+1)s[i]-='a';\n s[n+1]=-1;\n REP(i,m){\n int state=1;\n if(i==s[1])state|=2;\n if(i==s[1]||i==s[2])state|=4;\n dp[1][state]++;\n }\n REPP(i,2,n+1){\n REP(j,8){\n int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n REP(k,m){\n int d2[4]={};\n REPP(l,1,4){\n if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n else d2[l]=max(d2[l-1],d[l]);\n }\n if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n }\n }\n }\n printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n return 0;\n}Problem 7 : Walking!Since there is only one person, it’s not hard to show the difference between the number of left footprints and the number of right footprints is at most one.For a particular possible time order of a sequence of footprints, if there are k backward steps, we can easily divide all footprints into at most k + 1 subsequences without backward steps. Then you might guess that another direction of the induction is also true.That is, we can combine any k + 1 subsequence without backward steps into a whole sequence contains at most k backward steps. Your guess is correct !Now we demostrate the process of combining those subsequences.We only concern the first step and the last step of a divided subsequence. There are four possible combinations, we denote them as LL/LR/RL/RR subsequence separately(the first character is the type of the first step and the second character is the type of the second step).Suppose the number of four types of subseueqnce(LL/LR/RL/RR) are A, B, C, D separately. We have abs(A - D) ≤ 1.We can combine all RR, LL subsequeces in turn into one subsequenceswith at most A + D - 1 backward steps(the result may be of any of the four subsquence types). Now we have at most one LL or RR type subsequence.Then we can combine all RL subsequence into only one RL subsequence with at most A - 1 backward steps easily. And so do LR subsequences. Now we want to combine the final RL and LR subsequences together. We could pick the last footprint among two subsequences, exclude it from the original subsequcne and append it at the tail of another subsequence. The move will not increase the number of backward step and the types of the two subsequences would become RR and LL ! We can easily combine them into one LR or RL subsequence now. If there is still a LL or RR type subsequence reamained. We can easily combine them, too.So if we can divide all footprints into the least number of subsequences without backward steps. Then we have solved the problem. And this part can be done with greedy method.Now we provide one possible greedy method:Firstly, we translate this problem to a maximum matching problem on bipartite graph as following:Take \"RLLRRL\" as example: We split each footprint into two vertices which on is in left part and another is in right part.If two footprints is next to each other in resulted subsequnces, we will connect the left vertex of the former to right vertex of the latter in the corresponded matching. So the matching described in above left graph is subsequences: \"RL-R--\" and \"--L-RL\" and in above right graph is \"RL-R-L\" and \"--L-R-\". we can find that the number of subsequences is (number of footprints) — (value of matching).Due to the graphs produced by this problem is very special, we can solve this bipartite matching as following:Iterate each vertex in left part from top to bottom and find the uppermost vertex which is able to be matched in right part and connect them.If we process this algorithm in \"RLLRRL\", the resulted matching is the above right graph.Why the greedy method is correct? we can prove it by adjusting any maximum matching to our intended matching step by step. In each step, you can find the uppermost vertex the state of which is different to what we intend and change its state. I guess the mission of adjusting is not too hard for you to think out! Please solve it by yourself >_<By the way, I believe there are also many other greedy methods will work. If your greedy method is different to author's. Don't feel strange.author's code: thisProblem 8 : The Mirror BoxIf we view the grid intersections alternatively colored by blue and red like this:Then we know that the two conditions in the description are equivalent to a spanning tree in either entire red intersections or entire blue dots. So we can consider a red spanning tree and blue spanning tree one at a time.We can use disjoint-sets to merge connected components. Each component should be a tree, otherwise some grid edges will be enclosed inside some mirrors. So for the contracted graph, we would like to know how many spanning trees are there. This can be done by Kirchhoff’s theorem.Since there are at most 200 broken mirrors, the number of vertices in the contracted graph should be no more than 401. Hence a O(|V|3) determinant calculation algorithm may be applied onto the matrix.author's code: this",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20368",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10347
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "a[i][j] == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((ab)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 14",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 15",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 16",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 17",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int max_value = opt<int>(\"max\", 1000000000); // default max 1e9\n\n    int x;\n\n    if (type == \"random\") {\n        x = rnd.next(1, max_value);\n    } else if (type == \"power_of_two\") {\n        int exp = rnd.next(0, 30);\n        x = 1 << exp;\n        if (x > max_value) x = max_value;\n        if (x < 1) x = 1;\n    } else if (type == \"all_ones\") {\n        // Generate x with all bits set up to max_value\n        int bits = 0;\n        while ((1LL << bits) - 1 <= max_value) bits++;\n        bits--;\n        x = (1 << bits) - 1;\n    } else if (type == \"boundary\") {\n        x = rnd.next(0, 1) ? 1 : max_value;\n    } else if (type == \"near_power_of_two\") {\n        int exp = rnd.next(1, 30);\n        int base = 1 << exp;\n        if (rnd.next(0, 1)) {\n            x = base - 1;\n        } else {\n            x = base + 1;\n        }\n        if (x > max_value) x = max_value;\n        if (x < 1) x = 1;\n    } else if (type == \"sum_of_powers\") {\n        // Generate x as sum of random powers of 2\n        x = 0;\n        int num_terms = rnd.next(1, min(30, max_value));\n        set<int> exponents;\n        for (int i = 0; i < num_terms; ++i) {\n            int exp = rnd.next(0, 30);\n            exponents.insert(exp);\n        }\n        for (int exp : exponents) {\n            x += 1 << exp;\n            if (x > max_value) {\n                x = max_value;\n                break;\n            }\n        }\n        if (x > max_value) x = max_value;\n        if (x < 1) x = 1;\n    } else {\n        // Default random\n        x = rnd.next(1, max_value);\n    }\n\n    printf(\"%d\\n\", x);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int max_value = opt<int>(\"max\", 1000000000); // default max 1e9\n\n    int x;\n\n    if (type == \"random\") {\n        x = rnd.next(1, max_value);\n    } else if (type == \"power_of_two\") {\n        int exp = rnd.next(0, 30);\n        x = 1 << exp;\n        if (x > max_value) x = max_value;\n        if (x < 1) x = 1;\n    } else if (type == \"all_ones\") {\n        // Generate x with all bits set up to max_value\n        int bits = 0;\n        while ((1LL << bits) - 1 <= max_value) bits++;\n        bits--;\n        x = (1 << bits) - 1;\n    } else if (type == \"boundary\") {\n        x = rnd.next(0, 1) ? 1 : max_value;\n    } else if (type == \"near_power_of_two\") {\n        int exp = rnd.next(1, 30);\n        int base = 1 << exp;\n        if (rnd.next(0, 1)) {\n            x = base - 1;\n        } else {\n            x = base + 1;\n        }\n        if (x > max_value) x = max_value;\n        if (x < 1) x = 1;\n    } else if (type == \"sum_of_powers\") {\n        // Generate x as sum of random powers of 2\n        x = 0;\n        int num_terms = rnd.next(1, min(30, max_value));\n        set<int> exponents;\n        for (int i = 0; i < num_terms; ++i) {\n            int exp = rnd.next(0, 30);\n            exponents.insert(exp);\n        }\n        for (int exp : exponents) {\n            x += 1 << exp;\n            if (x > max_value) {\n                x = max_value;\n                break;\n            }\n        }\n        if (x > max_value) x = max_value;\n        if (x < 1) x = 1;\n    } else {\n        // Default random\n        x = rnd.next(1, max_value);\n    }\n\n    printf(\"%d\\n\", x);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal x\n./gen -type boundary -max 1\n\n# Maximal x\n./gen -type boundary -max 1000000000\n\n# Random tests\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Powers of two\n./gen -type power_of_two\n./gen -type power_of_two\n./gen -type power_of_two\n\n# One less than powers of two\n./gen -type near_power_of_two\n\n# One more than powers of two\n./gen -type near_power_of_two\n\n# All ones in binary (x = (1<<k)-1)\n./gen -type all_ones\n\n# Sum of random powers of two\n./gen -type sum_of_powers\n./gen -type sum_of_powers\n./gen -type sum_of_powers\n\n# Boundary test cases\n./gen -type boundary\n\n# Maximal x with all ones\n./gen -type all_ones -max 1000000000\n\n# Random x with max value decreased\n./gen -type random -max 100\n./gen -type random -max 1000\n./gen -type random -max 1000000\n\n# Specific x values\n# x = 999999999\n./gen -type random -max 999999999\n\n# x = 2^30, but since 2^30=1073741824>1e9, limit to max value.\n./gen -type power_of_two -max 1000000000\n\n# x = sum of first k powers of two\n./gen -type sum_of_powers -max 1000000000\n\n# x = large random x\n./gen -type random -max 1000000000\n./gen -type random -max 1000000000\n\n# x = 1 less than max\n./gen -type random -max 999999999\n\n# Random x near middle of range\n./gen -type random -max 500000000\n\n# x = 999999937 (a large prime)\n./gen -type random -max 999999937\n\n# x = 1\n./gen -type random -max 1\n\n# x = 10\n./gen -type random -max 10\n\n# x = (1<<29) + (1<<15) + (1<<5)\n./gen -type sum_of_powers -max 1000000000\n\n# x = (1<<10) - 1 = 1023\n./gen -type all_ones -max 1023\n\n# x = 31\n./gen -type random -max 31\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:13.975339",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "579/B",
      "title": "B. Finding Team Member",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThere are 2n lines in the input. The first line contains an integer n (1 ≤ n ≤ 400) — the number of teams to be formed.The i-th line (i > 1) contains i - 1 numbers ai1, ai2, ... , ai(i - 1). Here aij (1 ≤ aij ≤ 106, all aij are distinct) denotes the strength of a team consisting of person i and person j (people are numbered starting from 1.)",
      "output_spec": "OutputOutput a line containing 2n numbers. The i-th number should represent the number of teammate of i-th person.",
      "sample_tests": "ExamplesInputCopy261 23 4 5OutputCopy2 1 4 3InputCopy34870603831 161856845957 794650 97697783847 50566 691206 498447698377 156232 59015 382455 626960OutputCopy6 5 4 3 2 1",
      "description": "B. Finding Team Member\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThere are 2n lines in the input. The first line contains an integer n (1 ≤ n ≤ 400) — the number of teams to be formed.The i-th line (i > 1) contains i - 1 numbers ai1, ai2, ... , ai(i - 1). Here aij (1 ≤ aij ≤ 106, all aij are distinct) denotes the strength of a team consisting of person i and person j (people are numbered starting from 1.)\n\nOutputOutput a line containing 2n numbers. The i-th number should represent the number of teammate of i-th person.\n\nInputCopy261 23 4 5OutputCopy2 1 4 3InputCopy34870603831 161856845957 794650 97697783847 50566 691206 498447698377 156232 59015 382455 626960OutputCopy6 5 4 3 2 1\n\nInputCopy261 23 4 5\n\nOutputCopy2 1 4 3\n\nInputCopy34870603831 161856845957 794650 97697783847 50566 691206 498447698377 156232 59015 382455 626960\n\nOutputCopy6 5 4 3 2 1\n\nNoteIn the first sample, contestant 1 and 2 will be teammates and so do contestant 3 and 4, so the teammate of contestant 1, 2, 3, 4 will be 2, 1, 4, 3 respectively.",
      "solutions": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] - Codeforces",
          "content": "Hello, everyone! Codeforces Round #320 will be held at Sep/16/2015 18:00 MSK. Note that round starts in the unusual time!The problems are from tmt514, Shik, drazil, and me(dreamoon_love_AA). Also we want to thank Zlobober for helping us preparing the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is my second time organizing a problemset for a Codeforces round (my previous round: #292). In my previous round all problems were provided by me. But I think that if problems are provided by more people, then the contest will be more interesting! So I asked my friends to help me this time. Hope everybody can have fun during the round!Participants in each division will be given six tasks and two and a half hours for solving them (the last four problems in Div. 2 are as same as as the first four problems in Div. 1). Scoring system will be announced later closer to the start of the round.Bayan is an Iranian software company working on large-scale web applications. It doesn't only develop the search engine, but also it holds an annual open competition Bayan Programming Contest with an on-site round in Tehran. The on-site round of 2015 became an international event with many strong participants.Bayan has supported Codeforces on our Codeforces 5-year crowdfunding program. Thank you Bayan! This round is in your honor!UPD 1: Due to technical reasons the round starts at 18:15 Moscow time.UPD 2: The round will use the dynamic scoring with 250 points step.UPD 3: Problems are ordered according to their supposed difficulty.UPD 4: Winners!Div1:1) Um_nik2) Egor3) EndagorionDiv2:1) EmaxxMaster2) gongy3) Irisviel_von_EinzberUPD5: link of Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1762
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces",
          "content": "Problm 1 : Raising BacteriaWrite down x into its binary form. If the ith least significant bit is 1 and x contains n bits, we put one bacteria into this box in the morning of (n + 1 - i)th day. Then at the noon of the nth day, the box will contain x bacteria. So the answer is the number of ones in the binary form of x.code of author's friend: thisProblem 2 : Finding Team MemberSort all possible combinations from high strength to low strength. Then iterator all combinations. If two people in a combination still are not contained in any team. then we make these two people as a team.author's code: thisProblem 3 : A Problem about PolylineIf point (a,b) is located on the up slope/ down slope of this polyline. Then the polyline will pass the point (a - b,0)/(a + b,0).(we call (a - b) or (a + b) as c afterwards) And we can derive that c / (2 * x) should be a positive integer. Another condition we need to satisfy is that x must be larger than or equal to b. It’s easy to show that when those two conditions are satisfied, then the polyline will pass the point (a,b).Formally speaking in math : Let c / (2 * x) = y Then we have x = c / (2 * y) ≥ b and we want to find the maximum integer y. After some more math derivation, we can get the answer is . Besides, the only case of no solution is when a < b.In fact, always dosn't exist or larger than .author's code: #include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n LL a,b;\n cin>>a>>b;\n if(a<b)puts(\"-1\");\n else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n return 0;\n}\nProblem 4 : Or GameWe can describe a strategy as multiplying ai by x ti times so ai will become bi = ai * xti and sum of all ti will be equals to k. The fact is there must be a ti equal to k and all other ti equals to 0. If not, we can choose the largest number bj in sequence b, and change the strategy so that tj = k and all other tj = 0. The change will make the highest bit 1 of bj become higher so the or-ed result would be higher.After knowing the fact, We can iterator all number in sequence a and multiply it by xk and find the maximum value of our target between them. There are several method to do it in lower time complexity. You can check the sample code we provide.(I believe you can understand it quickly.)author's code: #include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n int n,k,x;\n scanf(\"%d%d%d\", &n, &k, &x);\n long long mul=1;\n while(k--)\n mul *= x;\n for(int i = 1; i <= n; i++)\n scanf(\"%I64d\", &a[i]);\n for(int i = 1; i <= n; i++)\n prefix[i] = prefix[i-1] | a[i];\n for(int i = n; i > 0; i--)\n suffix[i] = suffix[i+1] | a[i];\n long long ans = 0;\n for(int i= 1; i <= n; i++)\n ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n printf(\"%I64d\\n\",ans);\n}Problem 5 : Weakness and PoornessLet , we can write down the definition of poorness formally as. It's easy to see that A is a strictly decreasing function of x, and B is a strictly increasing function of x. Thus the minimum of max(A, B) can be found using binary or ternary search. The time complexity is ,Now here give people geometry viewpoint of this problem:let We plot n + 1 straight line y = i * x + bi in the plane for i from 0 to n.We can discover when you are given x. The weakness will be (y coordinator of highest line at x) — (y coordinator of lowest line at x).So we only need to consider the upper convex hull and the lower convex hull of all lines. And the target x value will be one of the intersection of these convex hull.Because you can get these line in order of their slope value. we can use stack to get the convex hulls in O(n).author's code : this (using binary search)code of author's friend (using stack to handle convexhull with O(n), have more precision)Problem 6 : LCS againFollowings are solution in short. Considering the LCS dp table lcs[x][y] which denotes the LCS value of first x characters of S and first y characters of T. If we know lcs[n][n] = n - 1, then we only concern values in the table which abs(x - y) ≤ 1 and all value of lcs[x][y] must be min(x, y) or min(x, y) - 1. So each row contains only 8 states(In fact,three states among these states will never be used), we can do dp on it row by row with time complexity O(n).There is another not dp method. You can refer this comment.author's code: #include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n DRII(n,m);\n RS(s+1);\n REPP(i,1,n+1)s[i]-='a';\n s[n+1]=-1;\n REP(i,m){\n int state=1;\n if(i==s[1])state|=2;\n if(i==s[1]||i==s[2])state|=4;\n dp[1][state]++;\n }\n REPP(i,2,n+1){\n REP(j,8){\n int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n REP(k,m){\n int d2[4]={};\n REPP(l,1,4){\n if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n else d2[l]=max(d2[l-1],d[l]);\n }\n if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n }\n }\n }\n printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n return 0;\n}Problem 7 : Walking!Since there is only one person, it’s not hard to show the difference between the number of left footprints and the number of right footprints is at most one.For a particular possible time order of a sequence of footprints, if there are k backward steps, we can easily divide all footprints into at most k + 1 subsequences without backward steps. Then you might guess that another direction of the induction is also true.That is, we can combine any k + 1 subsequence without backward steps into a whole sequence contains at most k backward steps. Your guess is correct !Now we demostrate the process of combining those subsequences.We only concern the first step and the last step of a divided subsequence. There are four possible combinations, we denote them as LL/LR/RL/RR subsequence separately(the first character is the type of the first step and the second character is the type of the second step).Suppose the number of four types of subseueqnce(LL/LR/RL/RR) are A, B, C, D separately. We have abs(A - D) ≤ 1.We can combine all RR, LL subsequeces in turn into one subsequenceswith at most A + D - 1 backward steps(the result may be of any of the four subsquence types). Now we have at most one LL or RR type subsequence.Then we can combine all RL subsequence into only one RL subsequence with at most A - 1 backward steps easily. And so do LR subsequences. Now we want to combine the final RL and LR subsequences together. We could pick the last footprint among two subsequences, exclude it from the original subsequcne and append it at the tail of another subsequence. The move will not increase the number of backward step and the types of the two subsequences would become RR and LL ! We can easily combine them into one LR or RL subsequence now. If there is still a LL or RR type subsequence reamained. We can easily combine them, too.So if we can divide all footprints into the least number of subsequences without backward steps. Then we have solved the problem. And this part can be done with greedy method.Now we provide one possible greedy method:Firstly, we translate this problem to a maximum matching problem on bipartite graph as following:Take \"RLLRRL\" as example: We split each footprint into two vertices which on is in left part and another is in right part.If two footprints is next to each other in resulted subsequnces, we will connect the left vertex of the former to right vertex of the latter in the corresponded matching. So the matching described in above left graph is subsequences: \"RL-R--\" and \"--L-RL\" and in above right graph is \"RL-R-L\" and \"--L-R-\". we can find that the number of subsequences is (number of footprints) — (value of matching).Due to the graphs produced by this problem is very special, we can solve this bipartite matching as following:Iterate each vertex in left part from top to bottom and find the uppermost vertex which is able to be matched in right part and connect them.If we process this algorithm in \"RLLRRL\", the resulted matching is the above right graph.Why the greedy method is correct? we can prove it by adjusting any maximum matching to our intended matching step by step. In each step, you can find the uppermost vertex the state of which is different to what we intend and change its state. I guess the mission of adjusting is not too hard for you to think out! Please solve it by yourself >_<By the way, I believe there are also many other greedy methods will work. If your greedy method is different to author's. Don't feel strange.author's code: thisProblem 8 : The Mirror BoxIf we view the grid intersections alternatively colored by blue and red like this:Then we know that the two conditions in the description are equivalent to a spanning tree in either entire red intersections or entire blue dots. So we can consider a red spanning tree and blue spanning tree one at a time.We can use disjoint-sets to merge connected components. Each component should be a tree, otherwise some grid edges will be enclosed inside some mirrors. So for the contracted graph, we would like to know how many spanning trees are there. This can be done by Kirchhoff’s theorem.Since there are at most 200 broken mirrors, the number of vertices in the contracted graph should be no more than 401. Hence a O(|V|3) determinant calculation algorithm may be applied onto the matrix.author's code: this",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20368",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10347
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "a[i][j] == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((ab)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 14",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 15",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 16",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 17",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 400, \"n\");\n    inf.readEoln();\n    int num_people = 2 * n;\n    set<int> strengths;\n\n    const int MAX_STRENGTH = 1000000;\n\n    for (int i = 2; i <= num_people; ++i) {\n        vector<int> aij = inf.readInts(i - 1, 1, MAX_STRENGTH, \"aij\");\n        for (int a : aij) {\n            ensuref(strengths.count(a) == 0, \"All strengths must be distinct\");\n            strengths.insert(a);\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 400, \"n\");\n    inf.readEoln();\n    int num_people = 2 * n;\n    set<int> strengths;\n\n    const int MAX_STRENGTH = 1000000;\n\n    for (int i = 2; i <= num_people; ++i) {\n        vector<int> aij = inf.readInts(i - 1, 1, MAX_STRENGTH, \"aij\");\n        for (int a : aij) {\n            ensuref(strengths.count(a) == 0, \"All strengths must be distinct\");\n            strengths.insert(a);\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 400, \"n\");\n    inf.readEoln();\n    int num_people = 2 * n;\n    set<int> strengths;\n\n    const int MAX_STRENGTH = 1000000;\n\n    for (int i = 2; i <= num_people; ++i) {\n        vector<int> aij = inf.readInts(i - 1, 1, MAX_STRENGTH, \"aij\");\n        for (int a : aij) {\n            ensuref(strengths.count(a) == 0, \"All strengths must be distinct\");\n            strengths.insert(a);\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int total_people = 2 * n; // Total number of people\n    int M = total_people * (total_people - 1) / 2; // Total number of strengths\n\n    // Initialize strengths\n    vector< vector<int> > strengths(total_people + 1);\n\n    // Initialize all possible strengths\n    vector<int> all_strengths(M);\n    for(int s = 0; s < M; ++s)\n        all_strengths[s] = s + 1; // Strengths from 1 to M\n\n    if (type == \"random\") {\n        // Random type: shuffle all strengths\n        shuffle(all_strengths.begin(), all_strengths.end());\n    }\n    else if (type == \"star\") {\n        // Star type: Assign high strengths between person 1 and others\n        int num_high = total_people - 1; // Number of high strengths involving person 1\n        // Shuffle all strengths\n        shuffle(all_strengths.begin(), all_strengths.end());\n        // Assign high strengths to pairs involving person 1\n        int idx = 0;\n        for (int i = 2; i <= total_people; ++i) {\n            strengths[i].resize(i);\n            strengths[i][1] = all_strengths[M - num_high + idx++];\n        }\n        idx = 0;\n        // Assign remaining strengths\n        for (int i = 2; i <= total_people; ++i) {\n            strengths[i].resize(i);\n            for (int j = 1; j < i; ++j) {\n                if (j == 1) continue; // Already assigned\n                strengths[i][j] = all_strengths[idx++];\n            }\n        }\n    }\n    else if (type == \"chain\") {\n        // Chain type: Assign high strengths between person i and i+1\n        int num_high = total_people - 1; // Number of high strengths in chain\n        // Shuffle all strengths\n        shuffle(all_strengths.begin(), all_strengths.end());\n        // Assign high strengths to chain pairs\n        map<pair<int,int>, int> high_strengths;\n        for (int i = 1; i < total_people; ++i) {\n            int a = i + 1;\n            int b = i;\n            if (a < b) swap(a, b);\n            high_strengths[{a, b}] = all_strengths[M - num_high + (i - 1)];\n        }\n        int idx = 0;\n        // Assign strengths\n        for (int i = 2; i <= total_people; ++i) {\n            strengths[i].resize(i);\n            for (int j = 1; j < i; ++j) {\n                pair<int,int> p = {i, j};\n                if (high_strengths.count(p)) {\n                    strengths[i][j] = high_strengths[p];\n                } else {\n                    strengths[i][j] = all_strengths[idx++];\n                }\n            }\n        }\n    }\n    else {\n        // Default to random if unknown type\n        // Random type: shuffle all strengths\n        shuffle(all_strengths.begin(), all_strengths.end());\n    }\n\n    if (type == \"random\" || type != \"star\" && type != \"chain\") {\n        // Assign strengths for random or unknown types\n        int idx = 0;\n        for (int i = 2; i <= total_people; ++i) {\n            strengths[i].resize(i);\n            for (int j = 1; j < i; ++j) {\n                strengths[i][j] = all_strengths[idx++];\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 2; i <= total_people; ++i) {\n        for (int j = 1; j < i; ++j) {\n            printf(\"%d\", strengths[i][j]);\n            if (j + 1 < i)\n                printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int total_people = 2 * n; // Total number of people\n    int M = total_people * (total_people - 1) / 2; // Total number of strengths\n\n    // Initialize strengths\n    vector< vector<int> > strengths(total_people + 1);\n\n    // Initialize all possible strengths\n    vector<int> all_strengths(M);\n    for(int s = 0; s < M; ++s)\n        all_strengths[s] = s + 1; // Strengths from 1 to M\n\n    if (type == \"random\") {\n        // Random type: shuffle all strengths\n        shuffle(all_strengths.begin(), all_strengths.end());\n    }\n    else if (type == \"star\") {\n        // Star type: Assign high strengths between person 1 and others\n        int num_high = total_people - 1; // Number of high strengths involving person 1\n        // Shuffle all strengths\n        shuffle(all_strengths.begin(), all_strengths.end());\n        // Assign high strengths to pairs involving person 1\n        int idx = 0;\n        for (int i = 2; i <= total_people; ++i) {\n            strengths[i].resize(i);\n            strengths[i][1] = all_strengths[M - num_high + idx++];\n        }\n        idx = 0;\n        // Assign remaining strengths\n        for (int i = 2; i <= total_people; ++i) {\n            strengths[i].resize(i);\n            for (int j = 1; j < i; ++j) {\n                if (j == 1) continue; // Already assigned\n                strengths[i][j] = all_strengths[idx++];\n            }\n        }\n    }\n    else if (type == \"chain\") {\n        // Chain type: Assign high strengths between person i and i+1\n        int num_high = total_people - 1; // Number of high strengths in chain\n        // Shuffle all strengths\n        shuffle(all_strengths.begin(), all_strengths.end());\n        // Assign high strengths to chain pairs\n        map<pair<int,int>, int> high_strengths;\n        for (int i = 1; i < total_people; ++i) {\n            int a = i + 1;\n            int b = i;\n            if (a < b) swap(a, b);\n            high_strengths[{a, b}] = all_strengths[M - num_high + (i - 1)];\n        }\n        int idx = 0;\n        // Assign strengths\n        for (int i = 2; i <= total_people; ++i) {\n            strengths[i].resize(i);\n            for (int j = 1; j < i; ++j) {\n                pair<int,int> p = {i, j};\n                if (high_strengths.count(p)) {\n                    strengths[i][j] = high_strengths[p];\n                } else {\n                    strengths[i][j] = all_strengths[idx++];\n                }\n            }\n        }\n    }\n    else {\n        // Default to random if unknown type\n        // Random type: shuffle all strengths\n        shuffle(all_strengths.begin(), all_strengths.end());\n    }\n\n    if (type == \"random\" || type != \"star\" && type != \"chain\") {\n        // Assign strengths for random or unknown types\n        int idx = 0;\n        for (int i = 2; i <= total_people; ++i) {\n            strengths[i].resize(i);\n            for (int j = 1; j < i; ++j) {\n                strengths[i][j] = all_strengths[idx++];\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 2; i <= total_people; ++i) {\n        for (int j = 1; j < i; ++j) {\n            printf(\"%d\", strengths[i][j]);\n            if (j + 1 < i)\n                printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type star\n./gen -n 1 -type chain\n\n./gen -n 2 -type random\n./gen -n 2 -type star\n./gen -n 2 -type chain\n\n./gen -n 5 -type random\n./gen -n 5 -type star\n./gen -n 5 -type chain\n\n./gen -n 10 -type random\n./gen -n 10 -type star\n./gen -n 10 -type chain\n\n./gen -n 50 -type random\n./gen -n 50 -type star\n./gen -n 50 -type chain\n\n./gen -n 100 -type random\n./gen -n 100 -type star\n./gen -n 100 -type chain\n\n./gen -n 200 -type random\n./gen -n 200 -type star\n./gen -n 200 -type chain\n\n./gen -n 400 -type random\n./gen -n 400 -type star\n./gen -n 400 -type chain\n\n./gen -n 300 -type random\n./gen -n 300 -type star\n./gen -n 300 -type chain\n\n./gen -n 350 -type random\n./gen -n 350 -type star\n./gen -n 350 -type chain\n\n./gen -n 400 -type random\n./gen -n 400 -type star\n./gen -n 400 -type chain\n\n./gen -n 1 -type random\n./gen -n 400 -type random\n\n./gen -n 100 -type random\n./gen -n 100 -type cycle\n\n./gen -n 250 -type random\n./gen -n 250 -type chain\n\n./gen -n 400 -type random\n./gen -n 400 -type star\n\n./gen -n 50 -type random\n./gen -n 50 -type chain\n\n./gen -n 75 -type random\n./gen -n 75 -type star\n\n./gen -n 125 -type random\n./gen -n 125 -type chain\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:16.011343",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "579/C",
      "title": "C. A Problem about Polyline",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputOnly one line containing two positive integers a and b (1 ≤ a, b ≤ 109).",
      "output_spec": "OutputOutput the only line containing the answer. Your answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9. If there is no such x then output  - 1 as the answer.",
      "sample_tests": "ExamplesInputCopy3 1OutputCopy1.000000000000InputCopy1 3OutputCopy-1InputCopy4 1OutputCopy1.250000000000",
      "description": "C. A Problem about Polyline\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputOnly one line containing two positive integers a and b (1 ≤ a, b ≤ 109).\n\nOutputOutput the only line containing the answer. Your answer will be considered correct if its relative or absolute error doesn't exceed 10 - 9. If there is no such x then output  - 1 as the answer.\n\nInputCopy3 1OutputCopy1.000000000000InputCopy1 3OutputCopy-1InputCopy4 1OutputCopy1.250000000000\n\nInputCopy3 1\n\nOutputCopy1.000000000000\n\nInputCopy1 3\n\nOutputCopy-1\n\nInputCopy4 1\n\nOutputCopy1.250000000000\n\nNoteYou can see following graphs for sample 1 and sample 3.",
      "solutions": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] - Codeforces",
          "content": "Hello, everyone! Codeforces Round #320 will be held at Sep/16/2015 18:00 MSK. Note that round starts in the unusual time!The problems are from tmt514, Shik, drazil, and me(dreamoon_love_AA). Also we want to thank Zlobober for helping us preparing the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is my second time organizing a problemset for a Codeforces round (my previous round: #292). In my previous round all problems were provided by me. But I think that if problems are provided by more people, then the contest will be more interesting! So I asked my friends to help me this time. Hope everybody can have fun during the round!Participants in each division will be given six tasks and two and a half hours for solving them (the last four problems in Div. 2 are as same as as the first four problems in Div. 1). Scoring system will be announced later closer to the start of the round.Bayan is an Iranian software company working on large-scale web applications. It doesn't only develop the search engine, but also it holds an annual open competition Bayan Programming Contest with an on-site round in Tehran. The on-site round of 2015 became an international event with many strong participants.Bayan has supported Codeforces on our Codeforces 5-year crowdfunding program. Thank you Bayan! This round is in your honor!UPD 1: Due to technical reasons the round starts at 18:15 Moscow time.UPD 2: The round will use the dynamic scoring with 250 points step.UPD 3: Problems are ordered according to their supposed difficulty.UPD 4: Winners!Div1:1) Um_nik2) Egor3) EndagorionDiv2:1) EmaxxMaster2) gongy3) Irisviel_von_EinzberUPD5: link of Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1762
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces",
          "content": "Problm 1 : Raising BacteriaWrite down x into its binary form. If the ith least significant bit is 1 and x contains n bits, we put one bacteria into this box in the morning of (n + 1 - i)th day. Then at the noon of the nth day, the box will contain x bacteria. So the answer is the number of ones in the binary form of x.code of author's friend: thisProblem 2 : Finding Team MemberSort all possible combinations from high strength to low strength. Then iterator all combinations. If two people in a combination still are not contained in any team. then we make these two people as a team.author's code: thisProblem 3 : A Problem about PolylineIf point (a,b) is located on the up slope/ down slope of this polyline. Then the polyline will pass the point (a - b,0)/(a + b,0).(we call (a - b) or (a + b) as c afterwards) And we can derive that c / (2 * x) should be a positive integer. Another condition we need to satisfy is that x must be larger than or equal to b. It’s easy to show that when those two conditions are satisfied, then the polyline will pass the point (a,b).Formally speaking in math : Let c / (2 * x) = y Then we have x = c / (2 * y) ≥ b and we want to find the maximum integer y. After some more math derivation, we can get the answer is . Besides, the only case of no solution is when a < b.In fact, always dosn't exist or larger than .author's code: #include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n LL a,b;\n cin>>a>>b;\n if(a<b)puts(\"-1\");\n else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n return 0;\n}\nProblem 4 : Or GameWe can describe a strategy as multiplying ai by x ti times so ai will become bi = ai * xti and sum of all ti will be equals to k. The fact is there must be a ti equal to k and all other ti equals to 0. If not, we can choose the largest number bj in sequence b, and change the strategy so that tj = k and all other tj = 0. The change will make the highest bit 1 of bj become higher so the or-ed result would be higher.After knowing the fact, We can iterator all number in sequence a and multiply it by xk and find the maximum value of our target between them. There are several method to do it in lower time complexity. You can check the sample code we provide.(I believe you can understand it quickly.)author's code: #include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n int n,k,x;\n scanf(\"%d%d%d\", &n, &k, &x);\n long long mul=1;\n while(k--)\n mul *= x;\n for(int i = 1; i <= n; i++)\n scanf(\"%I64d\", &a[i]);\n for(int i = 1; i <= n; i++)\n prefix[i] = prefix[i-1] | a[i];\n for(int i = n; i > 0; i--)\n suffix[i] = suffix[i+1] | a[i];\n long long ans = 0;\n for(int i= 1; i <= n; i++)\n ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n printf(\"%I64d\\n\",ans);\n}Problem 5 : Weakness and PoornessLet , we can write down the definition of poorness formally as. It's easy to see that A is a strictly decreasing function of x, and B is a strictly increasing function of x. Thus the minimum of max(A, B) can be found using binary or ternary search. The time complexity is ,Now here give people geometry viewpoint of this problem:let We plot n + 1 straight line y = i * x + bi in the plane for i from 0 to n.We can discover when you are given x. The weakness will be (y coordinator of highest line at x) — (y coordinator of lowest line at x).So we only need to consider the upper convex hull and the lower convex hull of all lines. And the target x value will be one of the intersection of these convex hull.Because you can get these line in order of their slope value. we can use stack to get the convex hulls in O(n).author's code : this (using binary search)code of author's friend (using stack to handle convexhull with O(n), have more precision)Problem 6 : LCS againFollowings are solution in short. Considering the LCS dp table lcs[x][y] which denotes the LCS value of first x characters of S and first y characters of T. If we know lcs[n][n] = n - 1, then we only concern values in the table which abs(x - y) ≤ 1 and all value of lcs[x][y] must be min(x, y) or min(x, y) - 1. So each row contains only 8 states(In fact,three states among these states will never be used), we can do dp on it row by row with time complexity O(n).There is another not dp method. You can refer this comment.author's code: #include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n DRII(n,m);\n RS(s+1);\n REPP(i,1,n+1)s[i]-='a';\n s[n+1]=-1;\n REP(i,m){\n int state=1;\n if(i==s[1])state|=2;\n if(i==s[1]||i==s[2])state|=4;\n dp[1][state]++;\n }\n REPP(i,2,n+1){\n REP(j,8){\n int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n REP(k,m){\n int d2[4]={};\n REPP(l,1,4){\n if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n else d2[l]=max(d2[l-1],d[l]);\n }\n if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n }\n }\n }\n printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n return 0;\n}Problem 7 : Walking!Since there is only one person, it’s not hard to show the difference between the number of left footprints and the number of right footprints is at most one.For a particular possible time order of a sequence of footprints, if there are k backward steps, we can easily divide all footprints into at most k + 1 subsequences without backward steps. Then you might guess that another direction of the induction is also true.That is, we can combine any k + 1 subsequence without backward steps into a whole sequence contains at most k backward steps. Your guess is correct !Now we demostrate the process of combining those subsequences.We only concern the first step and the last step of a divided subsequence. There are four possible combinations, we denote them as LL/LR/RL/RR subsequence separately(the first character is the type of the first step and the second character is the type of the second step).Suppose the number of four types of subseueqnce(LL/LR/RL/RR) are A, B, C, D separately. We have abs(A - D) ≤ 1.We can combine all RR, LL subsequeces in turn into one subsequenceswith at most A + D - 1 backward steps(the result may be of any of the four subsquence types). Now we have at most one LL or RR type subsequence.Then we can combine all RL subsequence into only one RL subsequence with at most A - 1 backward steps easily. And so do LR subsequences. Now we want to combine the final RL and LR subsequences together. We could pick the last footprint among two subsequences, exclude it from the original subsequcne and append it at the tail of another subsequence. The move will not increase the number of backward step and the types of the two subsequences would become RR and LL ! We can easily combine them into one LR or RL subsequence now. If there is still a LL or RR type subsequence reamained. We can easily combine them, too.So if we can divide all footprints into the least number of subsequences without backward steps. Then we have solved the problem. And this part can be done with greedy method.Now we provide one possible greedy method:Firstly, we translate this problem to a maximum matching problem on bipartite graph as following:Take \"RLLRRL\" as example: We split each footprint into two vertices which on is in left part and another is in right part.If two footprints is next to each other in resulted subsequnces, we will connect the left vertex of the former to right vertex of the latter in the corresponded matching. So the matching described in above left graph is subsequences: \"RL-R--\" and \"--L-RL\" and in above right graph is \"RL-R-L\" and \"--L-R-\". we can find that the number of subsequences is (number of footprints) — (value of matching).Due to the graphs produced by this problem is very special, we can solve this bipartite matching as following:Iterate each vertex in left part from top to bottom and find the uppermost vertex which is able to be matched in right part and connect them.If we process this algorithm in \"RLLRRL\", the resulted matching is the above right graph.Why the greedy method is correct? we can prove it by adjusting any maximum matching to our intended matching step by step. In each step, you can find the uppermost vertex the state of which is different to what we intend and change its state. I guess the mission of adjusting is not too hard for you to think out! Please solve it by yourself >_<By the way, I believe there are also many other greedy methods will work. If your greedy method is different to author's. Don't feel strange.author's code: thisProblem 8 : The Mirror BoxIf we view the grid intersections alternatively colored by blue and red like this:Then we know that the two conditions in the description are equivalent to a spanning tree in either entire red intersections or entire blue dots. So we can consider a red spanning tree and blue spanning tree one at a time.We can use disjoint-sets to merge connected components. Each component should be a tree, otherwise some grid edges will be enclosed inside some mirrors. So for the contracted graph, we would like to know how many spanning trees are there. This can be done by Kirchhoff’s theorem.Since there are at most 200 broken mirrors, the number of vertices in the contracted graph should be no more than 401. Hence a O(|V|3) determinant calculation algorithm may be applied onto the matrix.author's code: this",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20368",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10347
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "a[i][j] == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((ab)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 14",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 15",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 16",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 17",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test (a, b) for the described problem.\n\n  Usage examples:\n    ./gen -mode random\n    ./gen -mode less\n    ./gen -mode equal\n    ./gen -mode greater\n    ./gen -mode small\n    ./gen -mode large\n    ./gen -mode one\n    ./gen -mode two\n    ./gen -mode three\n\n  You can also specify an upper bound for random generation using \"-n <value>\",\n  defaulting to 1e9 if not provided. For example:\n    ./gen -mode random -n 1000000\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // The maximum value for a or b, default to 1e9 if not provided.\n    long long N = opt<long long>(\"n\", 1000000000LL);\n\n    // The mode determines how (a, b) will be generated.\n    // Default is \"random\".\n    string mode = opt<string>(\"mode\", \"random\");\n\n    long long a, b;\n\n    // Helper to clamp values into [1, N].\n    auto clamp = [&](long long x) {\n        if (x < 1) return 1LL;\n        if (x > N) return N;\n        return x;\n    };\n\n    if (mode == \"one\") {\n        // Directly from sample #2: yields -1 for correct solutions\n        // a=1, b=3\n        a = 1; \n        b = 3;\n    }\n    else if (mode == \"two\") {\n        // Directly from sample #1: solution = 1\n        // a=3, b=1\n        a = 3;\n        b = 1;\n    }\n    else if (mode == \"three\") {\n        // Directly from sample #3: solution = 1.25\n        // a=4, b=1\n        a = 4;\n        b = 1;\n    }\n    else if (mode == \"less\") {\n        // Generate a < b\n        // First pick b randomly in [2, N]. Then pick a in [1, b-1].\n        b = rnd.next(2LL, N);\n        a = rnd.next(1LL, b - 1);\n    }\n    else if (mode == \"equal\") {\n        // Generate a = b\n        a = rnd.next(1LL, N);\n        b = a;\n    }\n    else if (mode == \"greater\") {\n        // Generate a > b\n        // First pick a in [2, N]. Then pick b in [1, a-1].\n        a = rnd.next(2LL, N);\n        b = rnd.next(1LL, a - 1);\n    }\n    else if (mode == \"small\") {\n        // Generate a, b in [1, min(N,100]].\n        long long limit = min(N, 100LL);\n        a = rnd.next(1LL, limit);\n        b = rnd.next(1LL, limit);\n    }\n    else if (mode == \"large\") {\n        // Generate both a and b close to N\n        // For example, pick a, b in [max(1, N-1000), N].\n        long long low = max(1LL, N - 1000);\n        a = rnd.next(low, N);\n        b = rnd.next(low, N);\n    }\n    else {\n        // mode == \"random\" (default)\n        // Just pick a, b from [1, N].\n        a = rnd.next(1LL, N);\n        b = rnd.next(1LL, N);\n    }\n\n    // Clamp, though it should already be in [1, N].\n    a = clamp(a);\n    b = clamp(b);\n\n    // Output a single test: a b\n    // The problem statement requires them on a single line.\n    cout << a << \" \" << b << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test (a, b) for the described problem.\n\n  Usage examples:\n    ./gen -mode random\n    ./gen -mode less\n    ./gen -mode equal\n    ./gen -mode greater\n    ./gen -mode small\n    ./gen -mode large\n    ./gen -mode one\n    ./gen -mode two\n    ./gen -mode three\n\n  You can also specify an upper bound for random generation using \"-n <value>\",\n  defaulting to 1e9 if not provided. For example:\n    ./gen -mode random -n 1000000\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // The maximum value for a or b, default to 1e9 if not provided.\n    long long N = opt<long long>(\"n\", 1000000000LL);\n\n    // The mode determines how (a, b) will be generated.\n    // Default is \"random\".\n    string mode = opt<string>(\"mode\", \"random\");\n\n    long long a, b;\n\n    // Helper to clamp values into [1, N].\n    auto clamp = [&](long long x) {\n        if (x < 1) return 1LL;\n        if (x > N) return N;\n        return x;\n    };\n\n    if (mode == \"one\") {\n        // Directly from sample #2: yields -1 for correct solutions\n        // a=1, b=3\n        a = 1; \n        b = 3;\n    }\n    else if (mode == \"two\") {\n        // Directly from sample #1: solution = 1\n        // a=3, b=1\n        a = 3;\n        b = 1;\n    }\n    else if (mode == \"three\") {\n        // Directly from sample #3: solution = 1.25\n        // a=4, b=1\n        a = 4;\n        b = 1;\n    }\n    else if (mode == \"less\") {\n        // Generate a < b\n        // First pick b randomly in [2, N]. Then pick a in [1, b-1].\n        b = rnd.next(2LL, N);\n        a = rnd.next(1LL, b - 1);\n    }\n    else if (mode == \"equal\") {\n        // Generate a = b\n        a = rnd.next(1LL, N);\n        b = a;\n    }\n    else if (mode == \"greater\") {\n        // Generate a > b\n        // First pick a in [2, N]. Then pick b in [1, a-1].\n        a = rnd.next(2LL, N);\n        b = rnd.next(1LL, a - 1);\n    }\n    else if (mode == \"small\") {\n        // Generate a, b in [1, min(N,100]].\n        long long limit = min(N, 100LL);\n        a = rnd.next(1LL, limit);\n        b = rnd.next(1LL, limit);\n    }\n    else if (mode == \"large\") {\n        // Generate both a and b close to N\n        // For example, pick a, b in [max(1, N-1000), N].\n        long long low = max(1LL, N - 1000);\n        a = rnd.next(low, N);\n        b = rnd.next(low, N);\n    }\n    else {\n        // mode == \"random\" (default)\n        // Just pick a, b from [1, N].\n        a = rnd.next(1LL, N);\n        b = rnd.next(1LL, N);\n    }\n\n    // Clamp, though it should already be in [1, N].\n    a = clamp(a);\n    b = clamp(b);\n\n    // Output a single test: a b\n    // The problem statement requires them on a single line.\n    cout << a << \" \" << b << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are sample commands to run this generator multiple times to produce\n# a variety of test inputs. Each command prints exactly one test (a, b).\n\n# 1) Identical to sample #2 => a=1, b=3, should output -1 in the correct solution.\n./gen -mode one\n\n# 2) Identical to sample #1 => a=3, b=1, solution is 1.\n./gen -mode two\n\n# 3) Identical to sample #3 => a=4, b=1, solution is 1.25.\n./gen -mode three\n\n# 4) Small random test => a,b in [1,100].\n./gen -mode small\n\n# 5) Another small random test.\n./gen -mode small\n\n# 6) Generate a < b in [1,1e9].\n./gen -mode less\n\n# 7) Another a < b test.\n./gen -mode less\n\n# 8) Generate a = b in [1,1e9].\n./gen -mode equal\n\n# 9) Another a = b test.\n./gen -mode equal\n\n# 10) Generate a > b in [1,1e9].\n./gen -mode greater\n\n# 11) Another a > b test.\n./gen -mode greater\n\n# 12) Fully random in [1,1e9].\n./gen -mode random\n\n# 13) Fully random in [1,1e9].\n./gen -mode random\n\n# 14) Large random test, a,b close to 1e9.\n./gen -mode large\n\n# 15) Another large random test, still close to 1e9.\n./gen -mode large\n\n# 16) Random with a,b in [1, 10^6].\n./gen -mode random -n 1000000\n\n# 17) Small random again.\n./gen -mode small\n\n# 18) Another random (default range 1..1e9).\n./gen -mode random\n\n# 19) Yet another random test with a,b in [1..500].\n./gen -mode random -n 500\n\n# 20) Large random test with an even bigger limit, if desired (though 1e9 is default).\n./gen -mode large -n 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:18.209990",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "579/D",
      "title": "D. \"Or\" Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, k and x (1 ≤ n ≤ 200 000, 1 ≤ k ≤ 10, 2 ≤ x ≤ 8).The second line contains n integers a1, a2, ..., an (0 ≤ ai ≤ 109).",
      "output_spec": "OutputOutput the maximum value of a bitwise OR of sequence elements after performing operations.",
      "sample_tests": "ExamplesInputCopy3 1 21 1 1OutputCopy3InputCopy4 2 31 2 4 8OutputCopy79",
      "description": "D. \"Or\" Game\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains three integers n, k and x (1 ≤ n ≤ 200 000, 1 ≤ k ≤ 10, 2 ≤ x ≤ 8).The second line contains n integers a1, a2, ..., an (0 ≤ ai ≤ 109).\n\nOutputOutput the maximum value of a bitwise OR of sequence elements after performing operations.\n\nInputCopy3 1 21 1 1OutputCopy3InputCopy4 2 31 2 4 8OutputCopy79\n\nInputCopy3 1 21 1 1\n\nOutputCopy3\n\nInputCopy4 2 31 2 4 8\n\nOutputCopy79\n\nNoteFor the first sample, any possible choice of doing one operation will result the same three numbers 1, 1, 2 so the result is . For the second sample if we multiply 8 by 3 two times we'll get 72. In this case the numbers will become 1, 2, 4, 72 so the OR value will be 79 and is the largest possible result.",
      "solutions": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] - Codeforces",
          "content": "Hello, everyone! Codeforces Round #320 will be held at Sep/16/2015 18:00 MSK. Note that round starts in the unusual time!The problems are from tmt514, Shik, drazil, and me(dreamoon_love_AA). Also we want to thank Zlobober for helping us preparing the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is my second time organizing a problemset for a Codeforces round (my previous round: #292). In my previous round all problems were provided by me. But I think that if problems are provided by more people, then the contest will be more interesting! So I asked my friends to help me this time. Hope everybody can have fun during the round!Participants in each division will be given six tasks and two and a half hours for solving them (the last four problems in Div. 2 are as same as as the first four problems in Div. 1). Scoring system will be announced later closer to the start of the round.Bayan is an Iranian software company working on large-scale web applications. It doesn't only develop the search engine, but also it holds an annual open competition Bayan Programming Contest with an on-site round in Tehran. The on-site round of 2015 became an international event with many strong participants.Bayan has supported Codeforces on our Codeforces 5-year crowdfunding program. Thank you Bayan! This round is in your honor!UPD 1: Due to technical reasons the round starts at 18:15 Moscow time.UPD 2: The round will use the dynamic scoring with 250 points step.UPD 3: Problems are ordered according to their supposed difficulty.UPD 4: Winners!Div1:1) Um_nik2) Egor3) EndagorionDiv2:1) EmaxxMaster2) gongy3) Irisviel_von_EinzberUPD5: link of Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1762
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces",
          "content": "Problm 1 : Raising BacteriaWrite down x into its binary form. If the ith least significant bit is 1 and x contains n bits, we put one bacteria into this box in the morning of (n + 1 - i)th day. Then at the noon of the nth day, the box will contain x bacteria. So the answer is the number of ones in the binary form of x.code of author's friend: thisProblem 2 : Finding Team MemberSort all possible combinations from high strength to low strength. Then iterator all combinations. If two people in a combination still are not contained in any team. then we make these two people as a team.author's code: thisProblem 3 : A Problem about PolylineIf point (a,b) is located on the up slope/ down slope of this polyline. Then the polyline will pass the point (a - b,0)/(a + b,0).(we call (a - b) or (a + b) as c afterwards) And we can derive that c / (2 * x) should be a positive integer. Another condition we need to satisfy is that x must be larger than or equal to b. It’s easy to show that when those two conditions are satisfied, then the polyline will pass the point (a,b).Formally speaking in math : Let c / (2 * x) = y Then we have x = c / (2 * y) ≥ b and we want to find the maximum integer y. After some more math derivation, we can get the answer is . Besides, the only case of no solution is when a < b.In fact, always dosn't exist or larger than .author's code: #include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n LL a,b;\n cin>>a>>b;\n if(a<b)puts(\"-1\");\n else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n return 0;\n}\nProblem 4 : Or GameWe can describe a strategy as multiplying ai by x ti times so ai will become bi = ai * xti and sum of all ti will be equals to k. The fact is there must be a ti equal to k and all other ti equals to 0. If not, we can choose the largest number bj in sequence b, and change the strategy so that tj = k and all other tj = 0. The change will make the highest bit 1 of bj become higher so the or-ed result would be higher.After knowing the fact, We can iterator all number in sequence a and multiply it by xk and find the maximum value of our target between them. There are several method to do it in lower time complexity. You can check the sample code we provide.(I believe you can understand it quickly.)author's code: #include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n int n,k,x;\n scanf(\"%d%d%d\", &n, &k, &x);\n long long mul=1;\n while(k--)\n mul *= x;\n for(int i = 1; i <= n; i++)\n scanf(\"%I64d\", &a[i]);\n for(int i = 1; i <= n; i++)\n prefix[i] = prefix[i-1] | a[i];\n for(int i = n; i > 0; i--)\n suffix[i] = suffix[i+1] | a[i];\n long long ans = 0;\n for(int i= 1; i <= n; i++)\n ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n printf(\"%I64d\\n\",ans);\n}Problem 5 : Weakness and PoornessLet , we can write down the definition of poorness formally as. It's easy to see that A is a strictly decreasing function of x, and B is a strictly increasing function of x. Thus the minimum of max(A, B) can be found using binary or ternary search. The time complexity is ,Now here give people geometry viewpoint of this problem:let We plot n + 1 straight line y = i * x + bi in the plane for i from 0 to n.We can discover when you are given x. The weakness will be (y coordinator of highest line at x) — (y coordinator of lowest line at x).So we only need to consider the upper convex hull and the lower convex hull of all lines. And the target x value will be one of the intersection of these convex hull.Because you can get these line in order of their slope value. we can use stack to get the convex hulls in O(n).author's code : this (using binary search)code of author's friend (using stack to handle convexhull with O(n), have more precision)Problem 6 : LCS againFollowings are solution in short. Considering the LCS dp table lcs[x][y] which denotes the LCS value of first x characters of S and first y characters of T. If we know lcs[n][n] = n - 1, then we only concern values in the table which abs(x - y) ≤ 1 and all value of lcs[x][y] must be min(x, y) or min(x, y) - 1. So each row contains only 8 states(In fact,three states among these states will never be used), we can do dp on it row by row with time complexity O(n).There is another not dp method. You can refer this comment.author's code: #include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n DRII(n,m);\n RS(s+1);\n REPP(i,1,n+1)s[i]-='a';\n s[n+1]=-1;\n REP(i,m){\n int state=1;\n if(i==s[1])state|=2;\n if(i==s[1]||i==s[2])state|=4;\n dp[1][state]++;\n }\n REPP(i,2,n+1){\n REP(j,8){\n int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n REP(k,m){\n int d2[4]={};\n REPP(l,1,4){\n if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n else d2[l]=max(d2[l-1],d[l]);\n }\n if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n }\n }\n }\n printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n return 0;\n}Problem 7 : Walking!Since there is only one person, it’s not hard to show the difference between the number of left footprints and the number of right footprints is at most one.For a particular possible time order of a sequence of footprints, if there are k backward steps, we can easily divide all footprints into at most k + 1 subsequences without backward steps. Then you might guess that another direction of the induction is also true.That is, we can combine any k + 1 subsequence without backward steps into a whole sequence contains at most k backward steps. Your guess is correct !Now we demostrate the process of combining those subsequences.We only concern the first step and the last step of a divided subsequence. There are four possible combinations, we denote them as LL/LR/RL/RR subsequence separately(the first character is the type of the first step and the second character is the type of the second step).Suppose the number of four types of subseueqnce(LL/LR/RL/RR) are A, B, C, D separately. We have abs(A - D) ≤ 1.We can combine all RR, LL subsequeces in turn into one subsequenceswith at most A + D - 1 backward steps(the result may be of any of the four subsquence types). Now we have at most one LL or RR type subsequence.Then we can combine all RL subsequence into only one RL subsequence with at most A - 1 backward steps easily. And so do LR subsequences. Now we want to combine the final RL and LR subsequences together. We could pick the last footprint among two subsequences, exclude it from the original subsequcne and append it at the tail of another subsequence. The move will not increase the number of backward step and the types of the two subsequences would become RR and LL ! We can easily combine them into one LR or RL subsequence now. If there is still a LL or RR type subsequence reamained. We can easily combine them, too.So if we can divide all footprints into the least number of subsequences without backward steps. Then we have solved the problem. And this part can be done with greedy method.Now we provide one possible greedy method:Firstly, we translate this problem to a maximum matching problem on bipartite graph as following:Take \"RLLRRL\" as example: We split each footprint into two vertices which on is in left part and another is in right part.If two footprints is next to each other in resulted subsequnces, we will connect the left vertex of the former to right vertex of the latter in the corresponded matching. So the matching described in above left graph is subsequences: \"RL-R--\" and \"--L-RL\" and in above right graph is \"RL-R-L\" and \"--L-R-\". we can find that the number of subsequences is (number of footprints) — (value of matching).Due to the graphs produced by this problem is very special, we can solve this bipartite matching as following:Iterate each vertex in left part from top to bottom and find the uppermost vertex which is able to be matched in right part and connect them.If we process this algorithm in \"RLLRRL\", the resulted matching is the above right graph.Why the greedy method is correct? we can prove it by adjusting any maximum matching to our intended matching step by step. In each step, you can find the uppermost vertex the state of which is different to what we intend and change its state. I guess the mission of adjusting is not too hard for you to think out! Please solve it by yourself >_<By the way, I believe there are also many other greedy methods will work. If your greedy method is different to author's. Don't feel strange.author's code: thisProblem 8 : The Mirror BoxIf we view the grid intersections alternatively colored by blue and red like this:Then we know that the two conditions in the description are equivalent to a spanning tree in either entire red intersections or entire blue dots. So we can consider a red spanning tree and blue spanning tree one at a time.We can use disjoint-sets to merge connected components. Each component should be a tree, otherwise some grid edges will be enclosed inside some mirrors. So for the contracted graph, we would like to know how many spanning trees are there. This can be done by Kirchhoff’s theorem.Since there are at most 200 broken mirrors, the number of vertices in the contracted graph should be no more than 401. Hence a O(|V|3) determinant calculation algorithm may be applied onto the matrix.author's code: this",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20368",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10347
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "a[i][j] == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((ab)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 14",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 15",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 16",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 17",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(2, 8, \"x\");\n    inf.readEoln();\n\n    vector<long long> a = inf.readLongs(n, 0LL, 1000000000LL, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(2, 8, \"x\");\n    inf.readEoln();\n\n    vector<long long> a = inf.readLongs(n, 0LL, 1000000000LL, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(2, 8, \"x\");\n    inf.readEoln();\n\n    vector<long long> a = inf.readLongs(n, 0LL, 1000000000LL, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    int x = opt<int>(\"x\");\n    string t = opt<string>(\"t\", \"random\");\n\n    vector<ll> a(n);\n\n    if (t == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, 1000000000LL);\n        }\n    } else if (t == \"zeros\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (t == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000LL;\n        }\n    } else if (t == \"powers\") {\n        for (int i = 0; i < n; ++i) {\n            int bit = rnd.next(0, 30);\n            a[i] = 1LL << bit;\n        }\n    } else if (t == \"ones\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1LL;\n        }\n    } else if (t == \"small\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, 1000LL);\n        }\n    } else if (t == \"large\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1000000000LL - 1000LL, 1000000000LL);\n        }\n    } else if (t == \"single_maximize\") {\n        // Set one number small, others small\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, 1000LL);\n        }\n        a[0] = 1LL; // The number to which we'll apply operations\n    } else if (t == \"distributed\") {\n        // Prepare numbers with non-overlapping bits\n        int bits = min(n, 63); // cannot have more than 63 bits\n        for (int i = 0; i < n; ++i) {\n            int bit = i % bits;\n            a[i] = 1LL << bit;\n        }\n    } else {\n        fprintf(stderr, \"Unknown test type\\n\");\n        return 1;\n    }\n\n    printf(\"%d %d %d\\n\", n, k, x);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    int x = opt<int>(\"x\");\n    string t = opt<string>(\"t\", \"random\");\n\n    vector<ll> a(n);\n\n    if (t == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, 1000000000LL);\n        }\n    } else if (t == \"zeros\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (t == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000LL;\n        }\n    } else if (t == \"powers\") {\n        for (int i = 0; i < n; ++i) {\n            int bit = rnd.next(0, 30);\n            a[i] = 1LL << bit;\n        }\n    } else if (t == \"ones\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1LL;\n        }\n    } else if (t == \"small\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, 1000LL);\n        }\n    } else if (t == \"large\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1000000000LL - 1000LL, 1000000000LL);\n        }\n    } else if (t == \"single_maximize\") {\n        // Set one number small, others small\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0LL, 1000LL);\n        }\n        a[0] = 1LL; // The number to which we'll apply operations\n    } else if (t == \"distributed\") {\n        // Prepare numbers with non-overlapping bits\n        int bits = min(n, 63); // cannot have more than 63 bits\n        for (int i = 0; i < n; ++i) {\n            int bit = i % bits;\n            a[i] = 1LL << bit;\n        }\n    } else {\n        fprintf(stderr, \"Unknown test type\\n\");\n        return 1;\n    }\n\n    printf(\"%d %d %d\\n\", n, k, x);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -x 2 -t zeros\n./gen -n 1 -k 0 -x 2 -t ones\n./gen -n 1 -k 0 -x 2 -t random\n\n./gen -n 10 -k 1 -x 2 -t small\n./gen -n 10 -k 1 -x 2 -t powers\n./gen -n 10 -k 1 -x 2 -t random\n\n./gen -n 100 -k 2 -x 3 -t zeros\n./gen -n 100 -k 2 -x 3 -t large\n./gen -n 100 -k 2 -x 3 -t random\n\n./gen -n 1000 -k 5 -x 4 -t ones\n./gen -n 1000 -k 5 -x 4 -t small\n./gen -n 1000 -k 5 -x 4 -t random\n\n./gen -n 5000 -k 10 -x 8 -t max\n./gen -n 5000 -k 10 -x 8 -t powers\n./gen -n 5000 -k 10 -x 8 -t random\n\n./gen -n 10000 -k 0 -x 2 -t zeros\n./gen -n 10000 -k 0 -x 2 -t random\n\n./gen -n 100000 -k 10 -x 8 -t single_maximize\n./gen -n 100000 -k 10 -x 2 -t distributed\n\n./gen -n 200000 -k 10 -x 8 -t random\n./gen -n 200000 -k 5 -x 4 -t random\n\n./gen -n 200000 -k 1 -x 2 -t zeros\n./gen -n 200000 -k 1 -x 2 -t ones\n\n./gen -n 200000 -k 0 -x 8 -t random\n\n./gen -n 200000 -k 10 -x 8 -t large\n\n./gen -n 200000 -k 10 -x 8 -t small\n\n./gen -n 200000 -k 10 -x 2 -t powers\n\n./gen -n 200000 -k 10 -x 8 -t ones\n\n./gen -n 200000 -k 10 -x 8 -t zeros\n\n./gen -n 200000 -k 10 -x 8 -t distributed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:20.556937",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "579/E",
      "title": "E. Слабость и бедность",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано единственное целое число n (1 ≤ n ≤ 200 000), длина последовательности.Во второй строке записано n целых чисел a1, a2, ..., an (|ai| ≤ 10 000).",
      "output_spec": "Выходные данныеВыведите действительное число, обозначающее минимально возможную слабость a1 - x, a2 - x, ..., an - x. Ответ будет засчитан, если его относительная или абсолютная погрешность не превышает 10 - 6.",
      "sample_tests": "ПримерыВходные данныеСкопировать31 2 3Выходные данныеСкопировать1.000000000000000Входные данныеСкопировать41 2 3 4Выходные данныеСкопировать2.000000000000000Входные данныеСкопировать101 10 2 9 3 8 4 7 5 6Выходные данныеСкопировать4.500000000000000",
      "description": "E. Слабость и бедность\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке записано единственное целое число n (1 ≤ n ≤ 200 000), длина последовательности.Во второй строке записано n целых чисел a1, a2, ..., an (|ai| ≤ 10 000).\n\nВходные данные\n\nВыходные данныеВыведите действительное число, обозначающее минимально возможную слабость a1 - x, a2 - x, ..., an - x. Ответ будет засчитан, если его относительная или абсолютная погрешность не превышает 10 - 6.\n\nВыходные данные\n\nВходные данныеСкопировать31 2 3Выходные данныеСкопировать1.000000000000000Входные данныеСкопировать41 2 3 4Выходные данныеСкопировать2.000000000000000Входные данныеСкопировать101 10 2 9 3 8 4 7 5 6Выходные данныеСкопировать4.500000000000000\n\nВходные данныеСкопировать31 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1.000000000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать41 2 3 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2.000000000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать101 10 2 9 3 8 4 7 5 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4.500000000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеДля первого примера оптимальное значение x равняется 2, в таком случае последовательность примет вид  - 1, 0, 1 и максимальная бедность достигается либо на отрезке \"-1\", либо отрезке \"1\". Значение слабости (ответ) равняется в этом случае 1. Во втором примере оптимальное значение x равняется 2.5, в таком случае последовательность принимает вид  - 1.5,  - 0.5, 0.5, 1.5, а максимальная бедность достигается либо на отрезке \"-1.5 -0.5\", либо на отрезке \"0.5 1.5\". Значение слабости (ответ) равняется в этом случае 2.",
      "solutions": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] - Codeforces",
          "content": "Hello, everyone! Codeforces Round #320 will be held at Sep/16/2015 18:00 MSK. Note that round starts in the unusual time!The problems are from tmt514, Shik, drazil, and me(dreamoon_love_AA). Also we want to thank Zlobober for helping us preparing the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is my second time organizing a problemset for a Codeforces round (my previous round: #292). In my previous round all problems were provided by me. But I think that if problems are provided by more people, then the contest will be more interesting! So I asked my friends to help me this time. Hope everybody can have fun during the round!Participants in each division will be given six tasks and two and a half hours for solving them (the last four problems in Div. 2 are as same as as the first four problems in Div. 1). Scoring system will be announced later closer to the start of the round.Bayan is an Iranian software company working on large-scale web applications. It doesn't only develop the search engine, but also it holds an annual open competition Bayan Programming Contest with an on-site round in Tehran. The on-site round of 2015 became an international event with many strong participants.Bayan has supported Codeforces on our Codeforces 5-year crowdfunding program. Thank you Bayan! This round is in your honor!UPD 1: Due to technical reasons the round starts at 18:15 Moscow time.UPD 2: The round will use the dynamic scoring with 250 points step.UPD 3: Problems are ordered according to their supposed difficulty.UPD 4: Winners!Div1:1) Um_nik2) Egor3) EndagorionDiv2:1) EmaxxMaster2) gongy3) Irisviel_von_EinzberUPD5: link of Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1762
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces",
          "content": "Problm 1 : Raising BacteriaWrite down x into its binary form. If the ith least significant bit is 1 and x contains n bits, we put one bacteria into this box in the morning of (n + 1 - i)th day. Then at the noon of the nth day, the box will contain x bacteria. So the answer is the number of ones in the binary form of x.code of author's friend: thisProblem 2 : Finding Team MemberSort all possible combinations from high strength to low strength. Then iterator all combinations. If two people in a combination still are not contained in any team. then we make these two people as a team.author's code: thisProblem 3 : A Problem about PolylineIf point (a,b) is located on the up slope/ down slope of this polyline. Then the polyline will pass the point (a - b,0)/(a + b,0).(we call (a - b) or (a + b) as c afterwards) And we can derive that c / (2 * x) should be a positive integer. Another condition we need to satisfy is that x must be larger than or equal to b. It’s easy to show that when those two conditions are satisfied, then the polyline will pass the point (a,b).Formally speaking in math : Let c / (2 * x) = y Then we have x = c / (2 * y) ≥ b and we want to find the maximum integer y. After some more math derivation, we can get the answer is . Besides, the only case of no solution is when a < b.In fact, always dosn't exist or larger than .author's code: #include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n LL a,b;\n cin>>a>>b;\n if(a<b)puts(\"-1\");\n else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n return 0;\n}\nProblem 4 : Or GameWe can describe a strategy as multiplying ai by x ti times so ai will become bi = ai * xti and sum of all ti will be equals to k. The fact is there must be a ti equal to k and all other ti equals to 0. If not, we can choose the largest number bj in sequence b, and change the strategy so that tj = k and all other tj = 0. The change will make the highest bit 1 of bj become higher so the or-ed result would be higher.After knowing the fact, We can iterator all number in sequence a and multiply it by xk and find the maximum value of our target between them. There are several method to do it in lower time complexity. You can check the sample code we provide.(I believe you can understand it quickly.)author's code: #include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n int n,k,x;\n scanf(\"%d%d%d\", &n, &k, &x);\n long long mul=1;\n while(k--)\n mul *= x;\n for(int i = 1; i <= n; i++)\n scanf(\"%I64d\", &a[i]);\n for(int i = 1; i <= n; i++)\n prefix[i] = prefix[i-1] | a[i];\n for(int i = n; i > 0; i--)\n suffix[i] = suffix[i+1] | a[i];\n long long ans = 0;\n for(int i= 1; i <= n; i++)\n ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n printf(\"%I64d\\n\",ans);\n}Problem 5 : Weakness and PoornessLet , we can write down the definition of poorness formally as. It's easy to see that A is a strictly decreasing function of x, and B is a strictly increasing function of x. Thus the minimum of max(A, B) can be found using binary or ternary search. The time complexity is ,Now here give people geometry viewpoint of this problem:let We plot n + 1 straight line y = i * x + bi in the plane for i from 0 to n.We can discover when you are given x. The weakness will be (y coordinator of highest line at x) — (y coordinator of lowest line at x).So we only need to consider the upper convex hull and the lower convex hull of all lines. And the target x value will be one of the intersection of these convex hull.Because you can get these line in order of their slope value. we can use stack to get the convex hulls in O(n).author's code : this (using binary search)code of author's friend (using stack to handle convexhull with O(n), have more precision)Problem 6 : LCS againFollowings are solution in short. Considering the LCS dp table lcs[x][y] which denotes the LCS value of first x characters of S and first y characters of T. If we know lcs[n][n] = n - 1, then we only concern values in the table which abs(x - y) ≤ 1 and all value of lcs[x][y] must be min(x, y) or min(x, y) - 1. So each row contains only 8 states(In fact,three states among these states will never be used), we can do dp on it row by row with time complexity O(n).There is another not dp method. You can refer this comment.author's code: #include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n DRII(n,m);\n RS(s+1);\n REPP(i,1,n+1)s[i]-='a';\n s[n+1]=-1;\n REP(i,m){\n int state=1;\n if(i==s[1])state|=2;\n if(i==s[1]||i==s[2])state|=4;\n dp[1][state]++;\n }\n REPP(i,2,n+1){\n REP(j,8){\n int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n REP(k,m){\n int d2[4]={};\n REPP(l,1,4){\n if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n else d2[l]=max(d2[l-1],d[l]);\n }\n if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n }\n }\n }\n printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n return 0;\n}Problem 7 : Walking!Since there is only one person, it’s not hard to show the difference between the number of left footprints and the number of right footprints is at most one.For a particular possible time order of a sequence of footprints, if there are k backward steps, we can easily divide all footprints into at most k + 1 subsequences without backward steps. Then you might guess that another direction of the induction is also true.That is, we can combine any k + 1 subsequence without backward steps into a whole sequence contains at most k backward steps. Your guess is correct !Now we demostrate the process of combining those subsequences.We only concern the first step and the last step of a divided subsequence. There are four possible combinations, we denote them as LL/LR/RL/RR subsequence separately(the first character is the type of the first step and the second character is the type of the second step).Suppose the number of four types of subseueqnce(LL/LR/RL/RR) are A, B, C, D separately. We have abs(A - D) ≤ 1.We can combine all RR, LL subsequeces in turn into one subsequenceswith at most A + D - 1 backward steps(the result may be of any of the four subsquence types). Now we have at most one LL or RR type subsequence.Then we can combine all RL subsequence into only one RL subsequence with at most A - 1 backward steps easily. And so do LR subsequences. Now we want to combine the final RL and LR subsequences together. We could pick the last footprint among two subsequences, exclude it from the original subsequcne and append it at the tail of another subsequence. The move will not increase the number of backward step and the types of the two subsequences would become RR and LL ! We can easily combine them into one LR or RL subsequence now. If there is still a LL or RR type subsequence reamained. We can easily combine them, too.So if we can divide all footprints into the least number of subsequences without backward steps. Then we have solved the problem. And this part can be done with greedy method.Now we provide one possible greedy method:Firstly, we translate this problem to a maximum matching problem on bipartite graph as following:Take \"RLLRRL\" as example: We split each footprint into two vertices which on is in left part and another is in right part.If two footprints is next to each other in resulted subsequnces, we will connect the left vertex of the former to right vertex of the latter in the corresponded matching. So the matching described in above left graph is subsequences: \"RL-R--\" and \"--L-RL\" and in above right graph is \"RL-R-L\" and \"--L-R-\". we can find that the number of subsequences is (number of footprints) — (value of matching).Due to the graphs produced by this problem is very special, we can solve this bipartite matching as following:Iterate each vertex in left part from top to bottom and find the uppermost vertex which is able to be matched in right part and connect them.If we process this algorithm in \"RLLRRL\", the resulted matching is the above right graph.Why the greedy method is correct? we can prove it by adjusting any maximum matching to our intended matching step by step. In each step, you can find the uppermost vertex the state of which is different to what we intend and change its state. I guess the mission of adjusting is not too hard for you to think out! Please solve it by yourself >_<By the way, I believe there are also many other greedy methods will work. If your greedy method is different to author's. Don't feel strange.author's code: thisProblem 8 : The Mirror BoxIf we view the grid intersections alternatively colored by blue and red like this:Then we know that the two conditions in the description are equivalent to a spanning tree in either entire red intersections or entire blue dots. So we can consider a red spanning tree and blue spanning tree one at a time.We can use disjoint-sets to merge connected components. Each component should be a tree, otherwise some grid edges will be enclosed inside some mirrors. So for the contracted graph, we would like to know how many spanning trees are there. This can be done by Kirchhoff’s theorem.Since there are at most 200 broken mirrors, the number of vertices in the contracted graph should be no more than 401. Hence a O(|V|3) determinant calculation algorithm may be applied onto the matrix.author's code: this",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20368",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10347
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "a[i][j] == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((ab)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 14",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 15",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 16",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 17",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -10000, 10000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -10000, 10000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -10000, 10000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_ai = opt<int>(\"max_ai\", 10000);\n\n    vector<int> a(n);\n\n    if (type == \"zeros\") {\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"constant\") {\n        int const_val = opt<int>(\"const_val\", max_ai);\n        fill(a.begin(), a.end(), const_val);\n    } else if (type == \"increasing\") {\n        int start_val = opt<int>(\"start_val\", -max_ai);\n        int step = opt<int>(\"step\", 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start_val + i * step;\n            if (a[i] > max_ai) a[i] = max_ai;\n            if (a[i] < -max_ai) a[i] = -max_ai;\n        }\n    } else if (type == \"decreasing\") {\n        int start_val = opt<int>(\"start_val\", max_ai);\n        int step = opt<int>(\"step\", 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start_val - i * step;\n            if (a[i] > max_ai) a[i] = max_ai;\n            if (a[i] < -max_ai) a[i] = -max_ai;\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-max_ai, max_ai);\n    } else if (type == \"alternating_large_small\") {\n        int small_val = opt<int>(\"small_val\", 1);\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = (rnd.next(0, 1) ? 1 : -1) * max_ai;\n            else\n                a[i] = (rnd.next(0, 1) ? 1 : -1) * small_val;\n        }\n    } else if (type == \"alternating_sign\") {\n        for (int i = 0; i < n; ++i) {\n            int val = rnd.next(0, max_ai);\n            a[i] = ((i % 2 == 0) ? val : -val);\n        }\n    } else if (type == \"outliers\") {\n        int num_outliers = opt<int>(\"outliers\", 10);\n        int interval = max(1, n / num_outliers);\n        for (int i = 0; i < n; ++i) {\n            if (i % interval == 0)\n                a[i] = (rnd.next(0, 1) ? 1 : -1) * max_ai;\n            else\n                a[i] = rnd.next(-10, 10);\n        }\n    } else if (type == \"large_mean_small_median\") {\n        int num_large = opt<int>(\"num_large\", n / 10);\n        int large_val = max_ai;\n        for (int i = 0; i < n; ++i) {\n            if (i < num_large)\n                a[i] = large_val;\n            else\n                a[i] = rnd.next(-1, 1);\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"small_mean_large_median\") {\n        int num_small = opt<int>(\"num_small\", n / 10);\n        int large_val = max_ai;\n        for (int i = 0; i < n; ++i) {\n            if (i < n - num_small)\n                a[i] = large_val;\n            else\n                a[i] = rnd.next(-1, 1);\n        }\n        shuffle(a.begin(), a.end());\n    } else {\n        // Type not recognized, output an error\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output the sequence\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_ai = opt<int>(\"max_ai\", 10000);\n\n    vector<int> a(n);\n\n    if (type == \"zeros\") {\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"constant\") {\n        int const_val = opt<int>(\"const_val\", max_ai);\n        fill(a.begin(), a.end(), const_val);\n    } else if (type == \"increasing\") {\n        int start_val = opt<int>(\"start_val\", -max_ai);\n        int step = opt<int>(\"step\", 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start_val + i * step;\n            if (a[i] > max_ai) a[i] = max_ai;\n            if (a[i] < -max_ai) a[i] = -max_ai;\n        }\n    } else if (type == \"decreasing\") {\n        int start_val = opt<int>(\"start_val\", max_ai);\n        int step = opt<int>(\"step\", 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start_val - i * step;\n            if (a[i] > max_ai) a[i] = max_ai;\n            if (a[i] < -max_ai) a[i] = -max_ai;\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-max_ai, max_ai);\n    } else if (type == \"alternating_large_small\") {\n        int small_val = opt<int>(\"small_val\", 1);\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = (rnd.next(0, 1) ? 1 : -1) * max_ai;\n            else\n                a[i] = (rnd.next(0, 1) ? 1 : -1) * small_val;\n        }\n    } else if (type == \"alternating_sign\") {\n        for (int i = 0; i < n; ++i) {\n            int val = rnd.next(0, max_ai);\n            a[i] = ((i % 2 == 0) ? val : -val);\n        }\n    } else if (type == \"outliers\") {\n        int num_outliers = opt<int>(\"outliers\", 10);\n        int interval = max(1, n / num_outliers);\n        for (int i = 0; i < n; ++i) {\n            if (i % interval == 0)\n                a[i] = (rnd.next(0, 1) ? 1 : -1) * max_ai;\n            else\n                a[i] = rnd.next(-10, 10);\n        }\n    } else if (type == \"large_mean_small_median\") {\n        int num_large = opt<int>(\"num_large\", n / 10);\n        int large_val = max_ai;\n        for (int i = 0; i < n; ++i) {\n            if (i < num_large)\n                a[i] = large_val;\n            else\n                a[i] = rnd.next(-1, 1);\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"small_mean_large_median\") {\n        int num_small = opt<int>(\"num_small\", n / 10);\n        int large_val = max_ai;\n        for (int i = 0; i < n; ++i) {\n            if (i < n - num_small)\n                a[i] = large_val;\n            else\n                a[i] = rnd.next(-1, 1);\n        }\n        shuffle(a.begin(), a.end());\n    } else {\n        // Type not recognized, output an error\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output the sequence\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type zeros\n./gen -n 1 -type constant -const_val 10000\n./gen -n 1 -type constant -const_val -10000\n./gen -n 2 -type increasing -start_val -10000 -step 0\n./gen -n 2 -type decreasing -start_val 10000 -step 0\n./gen -n 5 -type random\n./gen -n 10 -type zeros\n./gen -n 10 -type constant -const_val 10000\n./gen -n 10 -type random\n./gen -n 10 -type alternating_large_small\n./gen -n 10 -type alternating_sign\n./gen -n 100 -type constant -const_val -10000\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type random\n./gen -n 100 -type outliers -outliers 5\n./gen -n 1000 -type zeros\n./gen -n 1000 -type constant -const_val 9999\n./gen -n 1000 -type random\n./gen -n 1000 -type alternating_large_small\n./gen -n 1000 -type alternating_sign\n./gen -n 1000 -type outliers -outliers 10\n./gen -n 10000 -type large_mean_small_median -num_large 100\n./gen -n 10000 -type small_mean_large_median -num_small 100\n./gen -n 50000 -type random\n./gen -n 100000 -type zeros\n./gen -n 100000 -type constant -const_val -9999\n./gen -n 100000 -type random\n./gen -n 100000 -type alternating_large_small\n./gen -n 100000 -type alternating_sign\n./gen -n 100000 -type outliers\n./gen -n 200000 -type random\n./gen -n 200000 -type zeros\n./gen -n 200000 -type constant -const_val 1\n./gen -n 200000 -type large_mean_small_median -num_large 1000\n./gen -n 200000 -type small_mean_large_median -num_small 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:22.751692",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "579/F",
      "title": "F. LCS Again",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two numbers n and m denoting the length of string S and number of first English lowercase characters forming the character set for strings (1 ≤ n ≤ 100 000, 2 ≤ m ≤ 26).The second line contains string S.",
      "output_spec": "OutputPrint the only line containing the answer.",
      "sample_tests": "ExamplesInputCopy3 3aaaOutputCopy6InputCopy3 3aabOutputCopy11InputCopy1 2aOutputCopy1InputCopy10 9abacadefghOutputCopy789",
      "description": "F. LCS Again\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two numbers n and m denoting the length of string S and number of first English lowercase characters forming the character set for strings (1 ≤ n ≤ 100 000, 2 ≤ m ≤ 26).The second line contains string S.\n\nOutputPrint the only line containing the answer.\n\nInputCopy3 3aaaOutputCopy6InputCopy3 3aabOutputCopy11InputCopy1 2aOutputCopy1InputCopy10 9abacadefghOutputCopy789\n\nInputCopy3 3aaa\n\nOutputCopy6\n\nInputCopy3 3aab\n\nOutputCopy11\n\nInputCopy1 2a\n\nOutputCopy1\n\nInputCopy10 9abacadefgh\n\nOutputCopy789\n\nNoteFor the first sample, the 6 possible strings T are: aab, aac, aba, aca, baa, caa. For the second sample, the 11 possible strings T are: aaa, aac, aba, abb, abc, aca, acb, baa, bab, caa, cab.For the third sample, the only possible string T is b.",
      "solutions": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] - Codeforces",
          "content": "Hello, everyone! Codeforces Round #320 will be held at Sep/16/2015 18:00 MSK. Note that round starts in the unusual time!The problems are from tmt514, Shik, drazil, and me(dreamoon_love_AA). Also we want to thank Zlobober for helping us preparing the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is my second time organizing a problemset for a Codeforces round (my previous round: #292). In my previous round all problems were provided by me. But I think that if problems are provided by more people, then the contest will be more interesting! So I asked my friends to help me this time. Hope everybody can have fun during the round!Participants in each division will be given six tasks and two and a half hours for solving them (the last four problems in Div. 2 are as same as as the first four problems in Div. 1). Scoring system will be announced later closer to the start of the round.Bayan is an Iranian software company working on large-scale web applications. It doesn't only develop the search engine, but also it holds an annual open competition Bayan Programming Contest with an on-site round in Tehran. The on-site round of 2015 became an international event with many strong participants.Bayan has supported Codeforces on our Codeforces 5-year crowdfunding program. Thank you Bayan! This round is in your honor!UPD 1: Due to technical reasons the round starts at 18:15 Moscow time.UPD 2: The round will use the dynamic scoring with 250 points step.UPD 3: Problems are ordered according to their supposed difficulty.UPD 4: Winners!Div1:1) Um_nik2) Egor3) EndagorionDiv2:1) EmaxxMaster2) gongy3) Irisviel_von_EinzberUPD5: link of Editorial",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/20334",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1762
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces",
          "content": "Problm 1 : Raising BacteriaWrite down x into its binary form. If the ith least significant bit is 1 and x contains n bits, we put one bacteria into this box in the morning of (n + 1 - i)th day. Then at the noon of the nth day, the box will contain x bacteria. So the answer is the number of ones in the binary form of x.code of author's friend: thisProblem 2 : Finding Team MemberSort all possible combinations from high strength to low strength. Then iterator all combinations. If two people in a combination still are not contained in any team. then we make these two people as a team.author's code: thisProblem 3 : A Problem about PolylineIf point (a,b) is located on the up slope/ down slope of this polyline. Then the polyline will pass the point (a - b,0)/(a + b,0).(we call (a - b) or (a + b) as c afterwards) And we can derive that c / (2 * x) should be a positive integer. Another condition we need to satisfy is that x must be larger than or equal to b. It’s easy to show that when those two conditions are satisfied, then the polyline will pass the point (a,b).Formally speaking in math : Let c / (2 * x) = y Then we have x = c / (2 * y) ≥ b and we want to find the maximum integer y. After some more math derivation, we can get the answer is . Besides, the only case of no solution is when a < b.In fact, always dosn't exist or larger than .author's code: #include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n LL a,b;\n cin>>a>>b;\n if(a<b)puts(\"-1\");\n else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n return 0;\n}\nProblem 4 : Or GameWe can describe a strategy as multiplying ai by x ti times so ai will become bi = ai * xti and sum of all ti will be equals to k. The fact is there must be a ti equal to k and all other ti equals to 0. If not, we can choose the largest number bj in sequence b, and change the strategy so that tj = k and all other tj = 0. The change will make the highest bit 1 of bj become higher so the or-ed result would be higher.After knowing the fact, We can iterator all number in sequence a and multiply it by xk and find the maximum value of our target between them. There are several method to do it in lower time complexity. You can check the sample code we provide.(I believe you can understand it quickly.)author's code: #include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n int n,k,x;\n scanf(\"%d%d%d\", &n, &k, &x);\n long long mul=1;\n while(k--)\n mul *= x;\n for(int i = 1; i <= n; i++)\n scanf(\"%I64d\", &a[i]);\n for(int i = 1; i <= n; i++)\n prefix[i] = prefix[i-1] | a[i];\n for(int i = n; i > 0; i--)\n suffix[i] = suffix[i+1] | a[i];\n long long ans = 0;\n for(int i= 1; i <= n; i++)\n ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n printf(\"%I64d\\n\",ans);\n}Problem 5 : Weakness and PoornessLet , we can write down the definition of poorness formally as. It's easy to see that A is a strictly decreasing function of x, and B is a strictly increasing function of x. Thus the minimum of max(A, B) can be found using binary or ternary search. The time complexity is ,Now here give people geometry viewpoint of this problem:let We plot n + 1 straight line y = i * x + bi in the plane for i from 0 to n.We can discover when you are given x. The weakness will be (y coordinator of highest line at x) — (y coordinator of lowest line at x).So we only need to consider the upper convex hull and the lower convex hull of all lines. And the target x value will be one of the intersection of these convex hull.Because you can get these line in order of their slope value. we can use stack to get the convex hulls in O(n).author's code : this (using binary search)code of author's friend (using stack to handle convexhull with O(n), have more precision)Problem 6 : LCS againFollowings are solution in short. Considering the LCS dp table lcs[x][y] which denotes the LCS value of first x characters of S and first y characters of T. If we know lcs[n][n] = n - 1, then we only concern values in the table which abs(x - y) ≤ 1 and all value of lcs[x][y] must be min(x, y) or min(x, y) - 1. So each row contains only 8 states(In fact,three states among these states will never be used), we can do dp on it row by row with time complexity O(n).There is another not dp method. You can refer this comment.author's code: #include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n DRII(n,m);\n RS(s+1);\n REPP(i,1,n+1)s[i]-='a';\n s[n+1]=-1;\n REP(i,m){\n int state=1;\n if(i==s[1])state|=2;\n if(i==s[1]||i==s[2])state|=4;\n dp[1][state]++;\n }\n REPP(i,2,n+1){\n REP(j,8){\n int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n REP(k,m){\n int d2[4]={};\n REPP(l,1,4){\n if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n else d2[l]=max(d2[l-1],d[l]);\n }\n if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n }\n }\n }\n printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n return 0;\n}Problem 7 : Walking!Since there is only one person, it’s not hard to show the difference between the number of left footprints and the number of right footprints is at most one.For a particular possible time order of a sequence of footprints, if there are k backward steps, we can easily divide all footprints into at most k + 1 subsequences without backward steps. Then you might guess that another direction of the induction is also true.That is, we can combine any k + 1 subsequence without backward steps into a whole sequence contains at most k backward steps. Your guess is correct !Now we demostrate the process of combining those subsequences.We only concern the first step and the last step of a divided subsequence. There are four possible combinations, we denote them as LL/LR/RL/RR subsequence separately(the first character is the type of the first step and the second character is the type of the second step).Suppose the number of four types of subseueqnce(LL/LR/RL/RR) are A, B, C, D separately. We have abs(A - D) ≤ 1.We can combine all RR, LL subsequeces in turn into one subsequenceswith at most A + D - 1 backward steps(the result may be of any of the four subsquence types). Now we have at most one LL or RR type subsequence.Then we can combine all RL subsequence into only one RL subsequence with at most A - 1 backward steps easily. And so do LR subsequences. Now we want to combine the final RL and LR subsequences together. We could pick the last footprint among two subsequences, exclude it from the original subsequcne and append it at the tail of another subsequence. The move will not increase the number of backward step and the types of the two subsequences would become RR and LL ! We can easily combine them into one LR or RL subsequence now. If there is still a LL or RR type subsequence reamained. We can easily combine them, too.So if we can divide all footprints into the least number of subsequences without backward steps. Then we have solved the problem. And this part can be done with greedy method.Now we provide one possible greedy method:Firstly, we translate this problem to a maximum matching problem on bipartite graph as following:Take \"RLLRRL\" as example: We split each footprint into two vertices which on is in left part and another is in right part.If two footprints is next to each other in resulted subsequnces, we will connect the left vertex of the former to right vertex of the latter in the corresponded matching. So the matching described in above left graph is subsequences: \"RL-R--\" and \"--L-RL\" and in above right graph is \"RL-R-L\" and \"--L-R-\". we can find that the number of subsequences is (number of footprints) — (value of matching).Due to the graphs produced by this problem is very special, we can solve this bipartite matching as following:Iterate each vertex in left part from top to bottom and find the uppermost vertex which is able to be matched in right part and connect them.If we process this algorithm in \"RLLRRL\", the resulted matching is the above right graph.Why the greedy method is correct? we can prove it by adjusting any maximum matching to our intended matching step by step. In each step, you can find the uppermost vertex the state of which is different to what we intend and change its state. I guess the mission of adjusting is not too hard for you to think out! Please solve it by yourself >_<By the way, I believe there are also many other greedy methods will work. If your greedy method is different to author's. Don't feel strange.author's code: thisProblem 8 : The Mirror BoxIf we view the grid intersections alternatively colored by blue and red like this:Then we know that the two conditions in the description are equivalent to a spanning tree in either entire red intersections or entire blue dots. So we can consider a red spanning tree and blue spanning tree one at a time.We can use disjoint-sets to merge connected components. Each component should be a tree, otherwise some grid edges will be enclosed inside some mirrors. So for the contracted graph, we would like to know how many spanning trees are there. This can be done by Kirchhoff’s theorem.Since there are at most 200 broken mirrors, the number of vertices in the contracted graph should be no more than 401. Hence a O(|V|3) determinant calculation algorithm may be applied onto the matrix.author's code: this",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/20368",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10347
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main(){\n    LL a,b;\n    cin>>a>>b;\n    if(a<b)puts(\"-1\");\n    else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 3",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 4",
          "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int SIZE = 2e5+2;\nlong long a[SIZE],prefix[SIZE],suffix[SIZE];\nint main(){\n    int n,k,x;\n    scanf(\"%d%d%d\", &n, &k, &x);\n    long long mul=1;\n    while(k--)\n        mul *= x;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%I64d\", &a[i]);\n    for(int i = 1; i <= n; i++)\n        prefix[i] = prefix[i-1] | a[i];\n    for(int i = n; i > 0; i--)\n        suffix[i] = suffix[i+1] | a[i];\n    long long ans = 0;\n    for(int i= 1; i <= n; i++)\n        ans = max(ans, prefix[i-1] | (a[i] * mul) | suffix[i+1]);\n    printf(\"%I64d\\n\",ans);\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 5",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 6",
          "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e5+10;\n// template end here\nLL dp[SIZE][8];\nchar s[SIZE];\nint get_bit(int x,int v){return (x>>v)&1;}\nint main(){\n    DRII(n,m);\n    RS(s+1);\n    REPP(i,1,n+1)s[i]-='a';\n    s[n+1]=-1;\n    REP(i,m){\n        int state=1;\n        if(i==s[1])state|=2;\n        if(i==s[1]||i==s[2])state|=4;\n        dp[1][state]++;\n    }\n    REPP(i,2,n+1){\n        REP(j,8){\n            int d[4]={i-3+get_bit(j,0),i-2+get_bit(j,1),i-2+get_bit(j,2)};\n            REP(k,m){\n                int d2[4]={};\n                REPP(l,1,4){\n                    if(s[i-2+l]==k)d2[l]=d[l-1]+1;\n                    else d2[l]=max(d2[l-1],d[l]);\n                }\n                if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];\n            }\n        }\n    }\n    printf(\"%lld\\n\",dp[n][0]+dp[n][1]+dp[n][4]+dp[n][5]);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 7",
          "code": "a[i][j] == 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 8",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 9",
          "code": "Test: #28, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER\nInput\n1488 1\nOutput\n1.00067204\nAnswer\n1.000672043011\n\nChecker Log\nwrong answer 1st numbers differ - expected: '1.0006720', found: '1.0006720', error = '0.0000000'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 10",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((ab)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 11",
          "code": "else printf(\"%.12f\\n\",(a+b)/(2.*((a+b)/(2*b))));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 12",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 13",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 14",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 15",
          "code": "if(d2[1]>=i-2&&min(d2[2],d2[3])>=i-1)dp[i][(d2[1]-(i-2))|((d2[2]-(i-1))<<1)|((d2[3]-(i-1))<<2)]+=dp[i-1][j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 16",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #320 [Bayan Thanks-Round] Editorial - Codeforces - Code 17",
          "code": "2 2 5\n/\\\n\\/",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20368",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 26, \"m\");\n    inf.readEoln();\n\n    string s = inf.readToken();\n    inf.readEoln();\n\n    ensuref(int(s.length()) == n, \"Length of string S must be n (%d), but s.length() = %d\", n, int(s.length()));\n\n    for (char c : s) {\n        ensuref('a' <= c && c <= 'a' + m - 1, \"Each character in S must be one of the first m lowercase English letters\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 26, \"m\");\n    inf.readEoln();\n\n    string s = inf.readToken();\n    inf.readEoln();\n\n    ensuref(int(s.length()) == n, \"Length of string S must be n (%d), but s.length() = %d\", n, int(s.length()));\n\n    for (char c : s) {\n        ensuref('a' <= c && c <= 'a' + m - 1, \"Each character in S must be one of the first m lowercase English letters\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 26, \"m\");\n    inf.readEoln();\n\n    string s = inf.readToken();\n    inf.readEoln();\n\n    ensuref(int(s.length()) == n, \"Length of string S must be n (%d), but s.length() = %d\", n, int(s.length()));\n\n    for (char c : s) {\n        ensuref('a' <= c && c <= 'a' + m - 1, \"Each character in S must be one of the first m lowercase English letters\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\npattern pnum(\"0|-?[1-9][0-9]*\");\r\n\r\nbool isNumeric(const string &p) {\r\n    return pnum.matches(p);\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two signed huge integers\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    string ja = ans.readWord();\r\n    string pa = ouf.readWord();\r\n\r\n    if (!isNumeric(ja))\r\n        quitf(_fail, \"%s is not a valid integer\", compress(ja).c_str());\r\n\r\n    if (!ans.seekEof())\r\n        quitf(_fail, \"expected exactly one token in the answer file\");\r\n\r\n    if (!isNumeric(pa))\r\n        quitf(_pe, \"%s is not a valid integer\", compress(pa).c_str());\r\n\r\n    if (ja != pa)\r\n        quitf(_wa, \"expected '%s', found '%s'\", compress(ja).c_str(), compress(pa).c_str());\r\n\r\n    quitf(_ok, \"answer is '%s'\", compress(ja).c_str());\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 100000)\n        ensuref(false, \"n is out of bounds. 1 ≤ n ≤ 1e5\");\n    if (m < 2 || m > 26)\n        ensuref(false, \"m is out of bounds. 2 ≤ m ≤ 26\");\n\n    string S;\n\n    if (type == \"random\") {\n        // Generate a random string of length n over m letters\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(0, m - 1);\n            S += c;\n        }\n    } else if (type == \"same_char\") {\n        // All the same character\n        char c = 'a' + rnd.next(0, m - 1);\n        S = string(n, c);\n    } else if (type == \"all_diff\") {\n        // All different characters, m ≥ n\n        ensuref(m >= n, \"For 'all_diff' type, m must be at least n\");\n        vector<int> perm(n);\n        iota(perm.begin(), perm.end(), 0);\n        shuffle(perm.begin(), perm.end());\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + perm[i];\n            S += c;\n        }\n    } else if (type == \"alternating\") {\n        // Alternating between two characters\n        int c1 = 0;\n        int c2 = 1 % m;\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + ((i % 2 == 0) ? c1 : c2);\n            S += c;\n        }\n    } else if (type == \"periodic\") {\n        // S has a period of length p\n        int p = opt<int>(\"p\", 1);\n        ensuref(p >= 1 && p <= n, \"For 'periodic' type, p must be between 1 and n\");\n        vector<char> period;\n        for (int i = 0; i < p; ++i) {\n            char c = 'a' + rnd.next(0, m - 1);\n            period.push_back(c);\n        }\n        for (int i = 0; i < n; ++i) {\n            S += period[i % p];\n        }\n    } else if (type == \"prefix_suffix_same\") {\n        // Prefix and suffix are the same\n        int len = min(n / 2, 10); // arbitrary small length\n        string prefix;\n        for (int i = 0; i < len; ++i) {\n            char c = 'a' + rnd.next(0, m - 1);\n            prefix += c;\n        }\n        S = prefix;\n        for (int i = len; i < n - len; ++i) {\n            char c = 'a' + rnd.next(0, m - 1);\n            S += c;\n        }\n        S += prefix;\n    } else if (type == \"random_few_chars\") {\n        // Random string but uses only a few characters (say k characters where k < m)\n        int k = opt<int>(\"k\", 2);\n        ensuref(k >= 2 && k <= m, \"For 'random_few_chars' type, k must be between 2 and m\");\n        vector<int> chars(k);\n        for (int i = 0; i < k; ++i) {\n            chars[i] = i;\n        }\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + chars[rnd.next(0, k - 1)];\n            S += c;\n        }\n    } else if (type == \"max_m\") {\n        // Use maximal m\n        m = 26;\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(0, m - 1);\n            S += c;\n        }\n    } else {\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output S\n    printf(\"%s\\n\", S.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 100000)\n        ensuref(false, \"n is out of bounds. 1 ≤ n ≤ 1e5\");\n    if (m < 2 || m > 26)\n        ensuref(false, \"m is out of bounds. 2 ≤ m ≤ 26\");\n\n    string S;\n\n    if (type == \"random\") {\n        // Generate a random string of length n over m letters\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(0, m - 1);\n            S += c;\n        }\n    } else if (type == \"same_char\") {\n        // All the same character\n        char c = 'a' + rnd.next(0, m - 1);\n        S = string(n, c);\n    } else if (type == \"all_diff\") {\n        // All different characters, m ≥ n\n        ensuref(m >= n, \"For 'all_diff' type, m must be at least n\");\n        vector<int> perm(n);\n        iota(perm.begin(), perm.end(), 0);\n        shuffle(perm.begin(), perm.end());\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + perm[i];\n            S += c;\n        }\n    } else if (type == \"alternating\") {\n        // Alternating between two characters\n        int c1 = 0;\n        int c2 = 1 % m;\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + ((i % 2 == 0) ? c1 : c2);\n            S += c;\n        }\n    } else if (type == \"periodic\") {\n        // S has a period of length p\n        int p = opt<int>(\"p\", 1);\n        ensuref(p >= 1 && p <= n, \"For 'periodic' type, p must be between 1 and n\");\n        vector<char> period;\n        for (int i = 0; i < p; ++i) {\n            char c = 'a' + rnd.next(0, m - 1);\n            period.push_back(c);\n        }\n        for (int i = 0; i < n; ++i) {\n            S += period[i % p];\n        }\n    } else if (type == \"prefix_suffix_same\") {\n        // Prefix and suffix are the same\n        int len = min(n / 2, 10); // arbitrary small length\n        string prefix;\n        for (int i = 0; i < len; ++i) {\n            char c = 'a' + rnd.next(0, m - 1);\n            prefix += c;\n        }\n        S = prefix;\n        for (int i = len; i < n - len; ++i) {\n            char c = 'a' + rnd.next(0, m - 1);\n            S += c;\n        }\n        S += prefix;\n    } else if (type == \"random_few_chars\") {\n        // Random string but uses only a few characters (say k characters where k < m)\n        int k = opt<int>(\"k\", 2);\n        ensuref(k >= 2 && k <= m, \"For 'random_few_chars' type, k must be between 2 and m\");\n        vector<int> chars(k);\n        for (int i = 0; i < k; ++i) {\n            chars[i] = i;\n        }\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + chars[rnd.next(0, k - 1)];\n            S += c;\n        }\n    } else if (type == \"max_m\") {\n        // Use maximal m\n        m = 26;\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(0, m - 1);\n            S += c;\n        }\n    } else {\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output S\n    printf(\"%s\\n\", S.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, m\n./gen -n 1 -m 2 -type random\n./gen -n 1 -m 2 -type same_char\n./gen -n 1 -m 2 -type alternating\n\n# Maximal n\n./gen -n 100000 -m 26 -type random\n./gen -n 100000 -m 26 -type same_char\n\n# Minimal m\n./gen -n 1000 -m 2 -type random\n./gen -n 1000 -m 2 -type same_char\n\n# All different characters\n./gen -n 26 -m 26 -type all_diff\n\n# Alternating characters\n./gen -n 10000 -m 3 -type alternating\n\n# Periodic with small period\n./gen -n 1000 -m 5 -type periodic -p 2\n./gen -n 1000 -m 5 -type periodic -p 5\n\n# Periodic with large period\n./gen -n 1000 -m 5 -type periodic -p 500\n\n# Prefix and suffix the same\n./gen -n 1000 -m 5 -type prefix_suffix_same\n\n# Random few chars, k = 2\n./gen -n 10000 -m 26 -type random_few_chars -k 2\n\n# Random few chars, k = m\n./gen -n 10000 -m 26 -type random_few_chars -k 26\n\n# Max m\n./gen -n 100000 -m 26 -type max_m\n\n# Edge case n=1\n./gen -n 1 -m 2 -type random\n\n# Edge case m=26\n./gen -n 1000 -m 26 -type random\n\n# Maximal n and minimal m\n./gen -n 100000 -m 2 -type random\n\n# Max n, random few chars k=2\n./gen -n 100000 -m 26 -type random_few_chars -k 2\n\n# Max n, periodic p=1\n./gen -n 100000 -m 26 -type periodic -p 1\n\n# Max n, periodic p=n\n./gen -n 100000 -m 26 -type periodic -p 100000\n\n# Max n, alternating\n./gen -n 100000 -m 2 -type alternating\n\n# All same character, min m\n./gen -n 100000 -m 2 -type same_char\n\n# All same character, max m\n./gen -n 100000 -m 26 -type same_char\n\n# All different characters with n=m=26\n./gen -n 26 -m 26 -type all_diff\n\n# All different characters with n < m\n./gen -n 20 -m 26 -type all_diff\n\n# Prefix suffix same with maximum n\n./gen -n 100000 -m 26 -type prefix_suffix_same\n\n# Random with min n and max m\n./gen -n 1 -m 26 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:24.459507",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "58/A",
      "title": "A. Чат",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 second",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой и единственной строке записано слово s, которое напечатал Вася. Это слово состоит из маленьких букв латинского алфавита, его длина не меньше 1 и не больше 100 букв.",
      "output_spec": "Выходные данныеЕсли Васе удалось поздороваться, выведите \"YES\", иначе выведите \"NO\".",
      "sample_tests": "ПримерыВходные данныеСкопироватьahhellllloouВыходные данныеСкопироватьYESВходные данныеСкопироватьhleloВыходные данныеСкопироватьNO",
      "description": "ограничение по времени на тест1 second\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой и единственной строке записано слово s, которое напечатал Вася. Это слово состоит из маленьких букв латинского алфавита, его длина не меньше 1 и не больше 100 букв.\n\nВходные данные\n\nВыходные данныеЕсли Васе удалось поздороваться, выведите \"YES\", иначе выведите \"NO\".\n\nВыходные данные\n\nВходные данныеСкопироватьahhellllloouВыходные данныеСкопироватьYESВходные данныеСкопироватьhleloВыходные данныеСкопироватьNO\n\nВходные данныеСкопироватьahhellllloou\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьhlelo\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #54 (Div. 2) - Codeforces",
          "content": "Всем привет! Этот контест был подготовлен в срочном порядке Артемом Раховым и другими участниками сборов в Петрозаводске от Саратовского ГУ. Пришлось оторваться от дорешивания, не пойти на лекцию Виталия Гольдштейна (не сердись, Виталий), но зато раунд подготовлен и мы ждем вас — участников. Как говорится, \"happy hacking\" MikeMirzayanov и команда Codeforces UPD. Контест закончен, всем спасибо за участие. Победил участник из Китая winmad. Лучший участник вне конкурса: anonymous. Последняя задача контеста поддалась только ему, браво!результатызадачи",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1197",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 553
        },
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces",
          "content": "Задача A. ЧатЗадача решается жадным алгоритмом. Сначала найдём в строке первую букву ('h\"). Далее - найдём следующую после неё букву 'e'. Если мы таким образом нашли все буквы, то ответ, очевидно, YES. Теперь давайте докажем, что если ответ был, то он обязательно найдётся. В самом деле, пусть был какой-то ответ. Посмотрим на позицию буквы 'h'. Если мы её сдвинем до самой первой влево (той, которую найдёт жадник), то ничего не изменится. Аналогично поступим со второй и следующими буквами.Получили жадный алгоритм, работающий за O(n), где n - длина входа.Задача B. МонетыВ этой задаче правильным решением опять же является жадный алгоритм. Выглядит он так: перебираем все числа от 2 и далее, пока стоимость последней добавленной монеты делится на него, делим, добавляем в ответ.Доказать корректность можно, если посмотреть на стоимости монет в разложении на простые множители. В каждой следующей стоимости все простые входят в меньшей либо равной степени, нежели в текущей (это равносильно тому, что одно делится на другое). Также очевидно, что если суммарная степень уменьшилась хотя бы на два (например, было число a = x· y· z (где y, z > 1, а стало b = x, то можно добавить еще одну промежуточную стоимость a > c = x· y > b. Таким образом, в правильном ответе сумма степеней вхождений при переходе от стоимости к следующей и меньшей уменьшается каждый раз на один. Наш жадный алгоритм именно так и поступает.Задача C. ДеревьяПервая мысль - красивая последовательность полностью задаётся любым своим членом. Следующая мысль: хотя бы одно дерево мы трогать не будем. Доказательство: скажем, что мы не трогаем первое дерево, а высоты остальных подгоним. Они, очевидно, все будут положительны.Решение за квадрат: перебираем, какое дерево мы не трогаем, узнаём первый член последовательности, смотрим, сколько деревьев не совпало.Это оптимизируется до решения за линию: если мы не трогаем какое-то дерево, то у нас фиксирован первый член последовательности. Давайте подсчитаем для каждого возможного первого члена, скольки деревьям он подходит. Это делается линейным проходом по всем деревьям и операцией \"инкремент\" на массиве. После чего осталось найти значение первого члена, которому удовлетворяет наибольшее количетсво деревьев, и вывести n - x, где x - это значение.Задача D. КалендарьДля начала заметим, что так как все строки календаря должны иметь одинаковую длину, то мы легко может эту длину найти. Это просто , где suml - суммарная длина всех строк. Теперь посмотрим на строку, которую поставим самой первой. Очевидно, выгодно брать строку, чтобы s + d было минимально (где s - наша строка, а d - дописываемый символ). Понятно, что такая найдётся однозначно, иначе получается, что две строки совпадают (так как символ d нигде не встречается). Разумеется, нельзя забывать, что зафиксировав первую строку, мы зафиксируем длину второй - надо, чтобы хотя бы одна была. Отлично, с первой строкой мы определились. Теперь мы знаем длину второй строки. Здесь нам надо взять просто минимальную строку соответствующей длины (одна префиксом другой быть не может - длины равны). Таким образом, заполняем календарь по линиям.Задача E. ВыражениеUnder construction. Основная идея - кубическая динамика с переходом за 102.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1771",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3219
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #54 (Div. 2) - Codeforces - Code 1",
          "code": "ad6airnnpg\nbad6jvcjsxfob\njvcjsxfo6quryai\nqury6rnnpg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #54 (Div. 2) - Codeforces - Code 2",
          "code": "ad6jvcjsxfob\nairnnpg6qury\nbad6jvcjsxfo\nquryai6rnnpg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #54 (Div. 2) - Codeforces - Code 3",
          "code": "ad6airnnpgbad6jvcjsxfobjvcjsxfo6quryaiqury6rnnpg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #54 (Div. 2) - Codeforces - Code 4",
          "code": "ad6jvcjsxfobairnnpg6qurybad6jvcjsxfoquryai6rnnpg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces - Code 1",
          "code": "1 1 1 2 3 3 2 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1771",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces - Code 2",
          "code": "1 2 3 4 5 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1771",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces - Code 3",
          "code": "-1 0 1 2 3 3 2 1 0 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1771",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n\n    ensuref(1 <= s.length() && s.length() <= 100, \"The length of s must be between 1 and 100, but it's %d\", int(s.length()));\n\n    for (int i = 0; i < (int)s.length(); i++) {\n        ensuref('a' <= s[i] && s[i] <= 'z', \"s must contain only small letters, but s[%d]='%c'\", i + 1, s[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n\n    ensuref(1 <= s.length() && s.length() <= 100, \"The length of s must be between 1 and 100, but it's %d\", int(s.length()));\n\n    for (int i = 0; i < (int)s.length(); i++) {\n        ensuref('a' <= s[i] && s[i] <= 'z', \"s must contain only small letters, but s[%d]='%c'\", i + 1, s[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n\n    ensuref(1 <= s.length() && s.length() <= 100, \"The length of s must be between 1 and 100, but it's %d\", int(s.length()));\n\n    for (int i = 0; i < (int)s.length(); i++) {\n        ensuref('a' <= s[i] && s[i] <= 'z', \"s must contain only small letters, but s[%d]='%c'\", i + 1, s[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\", 5); // default n=5\n    string type = opt<string>(\"type\", \"random_yes\");\n    \n    string s;\n    \n    if (type == \"exact_hello\") {\n        s = \"hello\";\n    } else if (type == \"minimal_yes\") {\n        // s is 'hello'\n        s = \"hello\";\n    } else if (type == \"maximal_yes\") {\n        // s of length n (n=100), such that 'hello' can be formed\n        // Insert random letters among letters of 'hello'\n        string hello = \"hello\";\n        vector<char> extra_chars;\n        int total_extra = n - hello.size();\n        for (int i = 0; i < total_extra; ++i)\n            extra_chars.push_back('a' + rnd.next(26));\n        vector<char> result;\n        int idx_extra = 0;\n        for (char c : hello) {\n            int num_extra = rnd.next(0, total_extra - idx_extra);\n            for (int i = 0; i < num_extra; ++i)\n                result.push_back(extra_chars[idx_extra++]);\n            result.push_back(c);\n        }\n        while (idx_extra < total_extra)\n            result.push_back(extra_chars[idx_extra++]);\n        s = string(result.begin(), result.end());\n    } else if (type == \"maximal_no\") {\n        // s of length n (n=100), such that 'hello' cannot be formed\n        // Exclude letters from 'hello'\n        string letters = \"abcdfgijkmnpqrstuvwxyz\"; // exclude 'h','e','l','o'\n        for (int i = 0; i < n; ++i) {\n            s += letters[rnd.next(letters.size())];\n        }\n    } else if (type == \"random_yes\") {\n        // Random s of length n, 'hello' can be formed\n        string hello = \"hello\";\n        vector<char> extra_chars;\n        int total_extra = n - hello.size();\n        for (int i = 0; i < total_extra; ++i)\n            extra_chars.push_back('a' + rnd.next(26));\n        vector<char> result;\n        int idx_extra = 0;\n        for (char c : hello) {\n            int num_extra = rnd.next(0, total_extra - idx_extra);\n            for (int i = 0; i < num_extra; ++i)\n                result.push_back(extra_chars[idx_extra++]);\n            result.push_back(c);\n        }\n        while (idx_extra < total_extra)\n            result.push_back(extra_chars[idx_extra++]);\n        s = string(result.begin(), result.end());\n    } else if (type == \"random_no\") {\n        // Random s of length n, 'hello' cannot be formed\n        string hello = \"hello\";\n        char exclude = hello[rnd.next(hello.size())];\n        for (int i = 0; i < n; ++i) {\n            char c;\n            do {\n                c = 'a' + rnd.next(26);\n            } while (c == exclude);\n            s += c;\n        }\n    } else if (type == \"reverse_hello\") {\n        // s is 'olleh'\n        s = \"olleh\";\n    } else if (type == \"only_hello_letters_no\") {\n        // s contains only letters from 'h','e','l','o' but cannot form 'hello'\n        string letters = \"helo\";\n        string hello = \"hello\";\n        char exclude = hello[rnd.next(hello.size())];\n        letters.erase(remove(letters.begin(), letters.end(), exclude), letters.end());\n        for (int i = 0; i < n; ++i) {\n            s += letters[rnd.next(letters.size())];\n        }\n    } else if (type == \"length_one\") {\n        s = string(1, 'a' + rnd.next(26));\n    } else if (type == \"length_maximal\") {\n        // s is of length 100, randomly generated\n        for (int i = 0; i < 100; ++i)\n            s += 'a' + rnd.next(26);\n    }\n    \n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\", 5); // default n=5\n    string type = opt<string>(\"type\", \"random_yes\");\n    \n    string s;\n    \n    if (type == \"exact_hello\") {\n        s = \"hello\";\n    } else if (type == \"minimal_yes\") {\n        // s is 'hello'\n        s = \"hello\";\n    } else if (type == \"maximal_yes\") {\n        // s of length n (n=100), such that 'hello' can be formed\n        // Insert random letters among letters of 'hello'\n        string hello = \"hello\";\n        vector<char> extra_chars;\n        int total_extra = n - hello.size();\n        for (int i = 0; i < total_extra; ++i)\n            extra_chars.push_back('a' + rnd.next(26));\n        vector<char> result;\n        int idx_extra = 0;\n        for (char c : hello) {\n            int num_extra = rnd.next(0, total_extra - idx_extra);\n            for (int i = 0; i < num_extra; ++i)\n                result.push_back(extra_chars[idx_extra++]);\n            result.push_back(c);\n        }\n        while (idx_extra < total_extra)\n            result.push_back(extra_chars[idx_extra++]);\n        s = string(result.begin(), result.end());\n    } else if (type == \"maximal_no\") {\n        // s of length n (n=100), such that 'hello' cannot be formed\n        // Exclude letters from 'hello'\n        string letters = \"abcdfgijkmnpqrstuvwxyz\"; // exclude 'h','e','l','o'\n        for (int i = 0; i < n; ++i) {\n            s += letters[rnd.next(letters.size())];\n        }\n    } else if (type == \"random_yes\") {\n        // Random s of length n, 'hello' can be formed\n        string hello = \"hello\";\n        vector<char> extra_chars;\n        int total_extra = n - hello.size();\n        for (int i = 0; i < total_extra; ++i)\n            extra_chars.push_back('a' + rnd.next(26));\n        vector<char> result;\n        int idx_extra = 0;\n        for (char c : hello) {\n            int num_extra = rnd.next(0, total_extra - idx_extra);\n            for (int i = 0; i < num_extra; ++i)\n                result.push_back(extra_chars[idx_extra++]);\n            result.push_back(c);\n        }\n        while (idx_extra < total_extra)\n            result.push_back(extra_chars[idx_extra++]);\n        s = string(result.begin(), result.end());\n    } else if (type == \"random_no\") {\n        // Random s of length n, 'hello' cannot be formed\n        string hello = \"hello\";\n        char exclude = hello[rnd.next(hello.size())];\n        for (int i = 0; i < n; ++i) {\n            char c;\n            do {\n                c = 'a' + rnd.next(26);\n            } while (c == exclude);\n            s += c;\n        }\n    } else if (type == \"reverse_hello\") {\n        // s is 'olleh'\n        s = \"olleh\";\n    } else if (type == \"only_hello_letters_no\") {\n        // s contains only letters from 'h','e','l','o' but cannot form 'hello'\n        string letters = \"helo\";\n        string hello = \"hello\";\n        char exclude = hello[rnd.next(hello.size())];\n        letters.erase(remove(letters.begin(), letters.end(), exclude), letters.end());\n        for (int i = 0; i < n; ++i) {\n            s += letters[rnd.next(letters.size())];\n        }\n    } else if (type == \"length_one\") {\n        s = string(1, 'a' + rnd.next(26));\n    } else if (type == \"length_maximal\") {\n        // s is of length 100, randomly generated\n        for (int i = 0; i < 100; ++i)\n            s += 'a' + rnd.next(26);\n    }\n    \n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test cases with exact 'hello'\n./gen -type exact_hello\n\n# Minimal 'yes' cases\n./gen -type minimal_yes\n\n# Maximal 'yes' cases (n=100)\n./gen -n 100 -type maximal_yes\n\n# Minimal 'no' cases (n=1)\n./gen -n 1 -type minimal_no\n\n# Maximal 'no' cases (n=100)\n./gen -n 100 -type maximal_no\n\n# Random 'yes' cases with various n\n./gen -n 10 -type random_yes\n./gen -n 50 -type random_yes\n./gen -n 100 -type random_yes\n\n# Random 'no' cases with various n\n./gen -n 10 -type random_no\n./gen -n 50 -type random_no\n./gen -n 100 -type random_no\n\n# Reverse 'hello' case\n./gen -type reverse_hello\n\n# 'no' case with only letters from 'hello' but cannot form 'hello'\n./gen -n 10 -type only_hello_letters_no\n\n# Length one case\n./gen -n 1 -type length_one\n\n# Length maximal case\n./gen -type length_maximal\n\n# Edge cases\n./gen -n 2 -type random_no\n./gen -n 99 -type random_yes\n\n# Cases to test repeating letters\n./gen -n 50 -type random_yes\n./gen -n 50 -type random_no\n\n# More test cases with variations\n./gen -n 5 -type random_no\n./gen -n 5 -type random_yes\n\n# Maximal length with reverse 'hello'\n./gen -n 100 -type reverse_hello\n\n./gen -n 100 -type only_hello_letters_no\n\n./gen -n 100 -type length_maximal\n\n./gen -n 1 -type length_one\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:26.328322",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "58/B",
      "title": "B. Монеты",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой и единственной строке записано одно целое число n (1 ≤ n ≤ 106) — стоимость самой дорогой монеты.",
      "output_spec": "Выходные данныеВыведите стоимости всех монет в порядке убывания. Количество монет должно быть наибольшим возможным (с заданной стоимостью n самой дорогой монеты), а так же стоимость каждой монеты должна делиться на стоимость любой более дешевой монеты. Естественно, стоимости всех монет должны быть различны. Если решений несколько, выведите любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать10Выходные данныеСкопировать10 5 1Входные данныеСкопировать4Выходные данныеСкопировать4 2 1Входные данныеСкопировать3Выходные данныеСкопировать3 1",
      "description": "ограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой и единственной строке записано одно целое число n (1 ≤ n ≤ 106) — стоимость самой дорогой монеты.\n\nВходные данные\n\nВыходные данныеВыведите стоимости всех монет в порядке убывания. Количество монет должно быть наибольшим возможным (с заданной стоимостью n самой дорогой монеты), а так же стоимость каждой монеты должна делиться на стоимость любой более дешевой монеты. Естественно, стоимости всех монет должны быть различны. Если решений несколько, выведите любое.\n\nВыходные данные\n\nВходные данныеСкопировать10Выходные данныеСкопировать10 5 1Входные данныеСкопировать4Выходные данныеСкопировать4 2 1Входные данныеСкопировать3Выходные данныеСкопировать3 1\n\nВходные данныеСкопировать10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10 5 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4 2 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3 1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #54 (Div. 2) - Codeforces",
          "content": "Всем привет! Этот контест был подготовлен в срочном порядке Артемом Раховым и другими участниками сборов в Петрозаводске от Саратовского ГУ. Пришлось оторваться от дорешивания, не пойти на лекцию Виталия Гольдштейна (не сердись, Виталий), но зато раунд подготовлен и мы ждем вас — участников. Как говорится, \"happy hacking\" MikeMirzayanov и команда Codeforces UPD. Контест закончен, всем спасибо за участие. Победил участник из Китая winmad. Лучший участник вне конкурса: anonymous. Последняя задача контеста поддалась только ему, браво!результатызадачи",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/1197",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 553
        },
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces",
          "content": "Задача A. ЧатЗадача решается жадным алгоритмом. Сначала найдём в строке первую букву ('h\"). Далее - найдём следующую после неё букву 'e'. Если мы таким образом нашли все буквы, то ответ, очевидно, YES. Теперь давайте докажем, что если ответ был, то он обязательно найдётся. В самом деле, пусть был какой-то ответ. Посмотрим на позицию буквы 'h'. Если мы её сдвинем до самой первой влево (той, которую найдёт жадник), то ничего не изменится. Аналогично поступим со второй и следующими буквами.Получили жадный алгоритм, работающий за O(n), где n - длина входа.Задача B. МонетыВ этой задаче правильным решением опять же является жадный алгоритм. Выглядит он так: перебираем все числа от 2 и далее, пока стоимость последней добавленной монеты делится на него, делим, добавляем в ответ.Доказать корректность можно, если посмотреть на стоимости монет в разложении на простые множители. В каждой следующей стоимости все простые входят в меньшей либо равной степени, нежели в текущей (это равносильно тому, что одно делится на другое). Также очевидно, что если суммарная степень уменьшилась хотя бы на два (например, было число a = x· y· z (где y, z > 1, а стало b = x, то можно добавить еще одну промежуточную стоимость a > c = x· y > b. Таким образом, в правильном ответе сумма степеней вхождений при переходе от стоимости к следующей и меньшей уменьшается каждый раз на один. Наш жадный алгоритм именно так и поступает.Задача C. ДеревьяПервая мысль - красивая последовательность полностью задаётся любым своим членом. Следующая мысль: хотя бы одно дерево мы трогать не будем. Доказательство: скажем, что мы не трогаем первое дерево, а высоты остальных подгоним. Они, очевидно, все будут положительны.Решение за квадрат: перебираем, какое дерево мы не трогаем, узнаём первый член последовательности, смотрим, сколько деревьев не совпало.Это оптимизируется до решения за линию: если мы не трогаем какое-то дерево, то у нас фиксирован первый член последовательности. Давайте подсчитаем для каждого возможного первого члена, скольки деревьям он подходит. Это делается линейным проходом по всем деревьям и операцией \"инкремент\" на массиве. После чего осталось найти значение первого члена, которому удовлетворяет наибольшее количетсво деревьев, и вывести n - x, где x - это значение.Задача D. КалендарьДля начала заметим, что так как все строки календаря должны иметь одинаковую длину, то мы легко может эту длину найти. Это просто , где suml - суммарная длина всех строк. Теперь посмотрим на строку, которую поставим самой первой. Очевидно, выгодно брать строку, чтобы s + d было минимально (где s - наша строка, а d - дописываемый символ). Понятно, что такая найдётся однозначно, иначе получается, что две строки совпадают (так как символ d нигде не встречается). Разумеется, нельзя забывать, что зафиксировав первую строку, мы зафиксируем длину второй - надо, чтобы хотя бы одна была. Отлично, с первой строкой мы определились. Теперь мы знаем длину второй строки. Здесь нам надо взять просто минимальную строку соответствующей длины (одна префиксом другой быть не может - длины равны). Таким образом, заполняем календарь по линиям.Задача E. ВыражениеUnder construction. Основная идея - кубическая динамика с переходом за 102.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/1771",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3219
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #54 (Div. 2) - Codeforces - Code 1",
          "code": "ad6airnnpg\nbad6jvcjsxfob\njvcjsxfo6quryai\nqury6rnnpg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #54 (Div. 2) - Codeforces - Code 2",
          "code": "ad6jvcjsxfob\nairnnpg6qury\nbad6jvcjsxfo\nquryai6rnnpg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #54 (Div. 2) - Codeforces - Code 3",
          "code": "ad6airnnpgbad6jvcjsxfobjvcjsxfo6quryaiqury6rnnpg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #54 (Div. 2) - Codeforces - Code 4",
          "code": "ad6jvcjsxfobairnnpg6qurybad6jvcjsxfoquryai6rnnpg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1197",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces - Code 1",
          "code": "1 1 1 2 3 3 2 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1771",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces - Code 2",
          "code": "1 2 3 4 5 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1771",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces - Code 3",
          "code": "-1 0 1 2 3 3 2 1 0 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1771",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1'000'000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1'000'000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1'000'000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <vector>\n#include <set>\nusing namespace std;\n\nint n;\n\n// This function reads the contestant's or jury's answer from the provided stream,\n// verifies the correctness according to the problem's constraints,\n// and returns the number of coins.\nint readAns(InStream& stream) {\n    vector<int> denominations;\n    while (!stream.seekEof()) {\n        int d = stream.readInt(1, n, \"denomination\");\n        denominations.push_back(d);\n    }\n\n    int k = denominations.size();\n    if (k == 0)\n        stream.quitf(_wa, \"No denominations provided\");\n\n    // Check that denominations are in strictly decreasing order and are within bounds.\n    for (int i = 0; i < k; i++) {\n        if (denominations[i] < 1 || denominations[i] > n)\n            stream.quitf(_wa, \"Denomination %d out of bounds [1, %d]\", denominations[i], n);\n        if (i > 0 && denominations[i] >= denominations[i - 1])\n            stream.quitf(_wa, \"Denominations are not in strictly decreasing order at position %d\", i + 1);\n    }\n\n    // Check that denominations are distinct.\n    set<int> denomSet(denominations.begin(), denominations.end());\n    if ((int)denomSet.size() != k)\n        stream.quitf(_wa, \"Denominations are not distinct\");\n\n    // Check that the first denomination equals n.\n    if (denominations[0] != n)\n        stream.quitf(_wa, \"The largest denomination should be n = %d, found %d\", n, denominations[0]);\n\n    // Check divisibility: For all i < j, denominations[i] % denominations[j] == 0.\n    for (int i = 0; i < k; i++) {\n        for (int j = i + 1; j < k; j++) {\n            if (denominations[i] % denominations[j] != 0)\n                stream.quitf(_wa, \"Denomination %d is not divisible by cheaper coin %d\", denominations[i], denominations[j]);\n        }\n    }\n\n    return k;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, 1000000);\n\n    int jury_k = readAns(ans);\n    int participant_k = readAns(ouf);\n\n    if (participant_k < jury_k)\n        quitf(_wa, \"Participant uses fewer coins (%d) than required (%d)\", participant_k, jury_k);\n    else if (participant_k == jury_k)\n        quitf(_ok, \"Correct number of coins: %d\", participant_k);\n    else\n        quitf(_fail, \"Participant uses more coins (%d) than jury's answer (%d)\", participant_k, jury_k);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    \n    if (n == -1) {\n        if (type == \"small\") {\n            n = rnd.next(1, 10);\n        } else if (type == \"large\") {\n            n = rnd.next(1000000 - 1000, 1000000);\n        } else if (type == \"prime\") {\n            vector<int> primes = {\n                999983, 999979, 999961, 999959, 999953, \n                999931, 999929, 999919, 999907, 999883, \n                999857, 999853, 999841, 999833, 999827, \n                999809, 999803, 999797, 999791, 999764\n            };\n            n = primes[rnd.next(0, int(primes.size()) - 1)];\n        } else if (type == \"power_of_two\") {\n            vector<int> powers_of_two;\n            for (int i = 0; ; i++) {\n                int val = 1 << i;\n                if (val > 1000000)\n                    break;\n                powers_of_two.push_back(val);\n            }\n            n = powers_of_two[rnd.next(0, int(powers_of_two.size()) - 1)];\n        } else if (type == \"square\") {\n            vector<int> primes;\n            const int MAX_P = 1000;\n            vector<bool> is_prime(MAX_P + 1, true);\n            for (int i = 2; i <= MAX_P; ++i) {\n                if (is_prime[i]) {\n                    primes.push_back(i);\n                    for (int j = i * 2; j <= MAX_P; j += i)\n                        is_prime[j] = false;\n                }\n            }\n            int p = primes[rnd.next(0, int(primes.size()) -1)];\n            n = p * p;\n        } else if (type == \"composite_many_factors\") {\n            vector<int> small_primes = {2, 3, 5, 7, 11, 13};\n            n = 1;\n            while (true) {\n                int p = small_primes[rnd.next(0, int(small_primes.size()) - 1)];\n                if ((long long)n * p > 1000000)\n                    break;\n                n *= p;\n            }\n        } else {\n            n = rnd.next(1, 1000000);\n        }\n    }\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    \n    if (n == -1) {\n        if (type == \"small\") {\n            n = rnd.next(1, 10);\n        } else if (type == \"large\") {\n            n = rnd.next(1000000 - 1000, 1000000);\n        } else if (type == \"prime\") {\n            vector<int> primes = {\n                999983, 999979, 999961, 999959, 999953, \n                999931, 999929, 999919, 999907, 999883, \n                999857, 999853, 999841, 999833, 999827, \n                999809, 999803, 999797, 999791, 999764\n            };\n            n = primes[rnd.next(0, int(primes.size()) - 1)];\n        } else if (type == \"power_of_two\") {\n            vector<int> powers_of_two;\n            for (int i = 0; ; i++) {\n                int val = 1 << i;\n                if (val > 1000000)\n                    break;\n                powers_of_two.push_back(val);\n            }\n            n = powers_of_two[rnd.next(0, int(powers_of_two.size()) - 1)];\n        } else if (type == \"square\") {\n            vector<int> primes;\n            const int MAX_P = 1000;\n            vector<bool> is_prime(MAX_P + 1, true);\n            for (int i = 2; i <= MAX_P; ++i) {\n                if (is_prime[i]) {\n                    primes.push_back(i);\n                    for (int j = i * 2; j <= MAX_P; j += i)\n                        is_prime[j] = false;\n                }\n            }\n            int p = primes[rnd.next(0, int(primes.size()) -1)];\n            n = p * p;\n        } else if (type == \"composite_many_factors\") {\n            vector<int> small_primes = {2, 3, 5, 7, 11, 13};\n            n = 1;\n            while (true) {\n                int p = small_primes[rnd.next(0, int(small_primes.size()) - 1)];\n                if ((long long)n * p > 1000000)\n                    break;\n                n *= p;\n            }\n        } else {\n            n = rnd.next(1, 1000000);\n        }\n    }\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n values\n./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 6\n./gen -n 7\n./gen -n 8\n./gen -n 9\n./gen -n 10\n\n# Large n values\n./gen -n 999990\n./gen -n 1000000\n\n# Random small values\n./gen -type small\n./gen -type small\n./gen -type small\n\n# Random large values\n./gen -type large\n./gen -type large\n\n# Prime n values\n./gen -type prime\n./gen -type prime\n./gen -n 999983\n\n# Composite n with many factors\n./gen -type composite_many_factors\n./gen -type composite_many_factors\n\n# Power of two n values\n./gen -type power_of_two\n./gen -type power_of_two\n./gen -n 524288\n\n# Square of prime n values\n./gen -type square\n./gen -type square\n./gen -n 961\n\n# Random n values\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:28.387698",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "58/C",
      "title": "C. Trees",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105) which is the number of trees. The second line contains integers ai (1 ≤ ai ≤ 105) which are the heights of the trees.",
      "output_spec": "OutputPrint a single number which is the minimal number of trees whose heights will have to be changed for the sequence to become beautiful.",
      "sample_tests": "ExamplesInputCopy32 2 2OutputCopy1InputCopy41 2 2 1OutputCopy0",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105) which is the number of trees. The second line contains integers ai (1 ≤ ai ≤ 105) which are the heights of the trees.\n\nOutputPrint a single number which is the minimal number of trees whose heights will have to be changed for the sequence to become beautiful.\n\nInputCopy32 2 2OutputCopy1InputCopy41 2 2 1OutputCopy0\n\nInputCopy32 2 2\n\nOutputCopy1\n\nInputCopy41 2 2 1\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Beta Round #54 (Div. 2) - Codeforces",
          "content": "Hello! This contest has been prepared by Artem Rakhov and other participants of Petrozavodsk Training Camp from Saratov State University. We stopped solving problems of the camp, missed the lecture by Vitaly Goldstein (do not be angry, Vitaly), but the round has been prepared and we are waiting for you - the participants. Happy hacking, MikeMirzayanov and team Codeforces UPD:ProblemsStandingsWinner: winmad",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1197",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 409
        },
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces",
          "content": "Problem A. Chat roomSolution is greedy algorithm. The first thing we do is find in our string the first letter 'h'. Then we find letter 'e' which is righter that found 'h'. If we find the whole word 'hello' in such way, obliviously, answer is YES.Now let's prove that if answer exists, we find it. Let see on position of the 'h' in right answer. If we move it to the first 'h' in our string, nothing changes. But now we can say that our greedy algorithm correctly Now let's do such with the second letter, and so on.We have greedy algorithm with work time O(n), where n - length of the input.Problem B. CoinsThis problem also have greedy solution: we run down all number from 2 and greater and while denomination of the last added to answer coin is divisible by current number, we divide and increase answer.You can prove correctness, if you take a look at prime factorizations of coins' denominations. In each next denomination each prime have less or equal power than the current one (it's equivalent to 'a divide b'). Obliviously, if summary degree of primes decreases at least two (for example, we had numbera = x· y· z (where y, z > 1, and the current number is b = x), then we can add one more coin with demonitaion a > c = x· y > b. So, in the optimal answer sum of degrees decreasing at exactly one. Our greedy algorithm do exactly what it need.Problem C. Trees.The first thing we notice - beautiful sequence is can be determined with any member. The next thing - at least one tree will remain the same height. Prove: let's fix height of the first tree, and correct heights of all other ones. Obliviously, they all remain positive.Solution with work time O(n2): we run down which tree we will fix, determine required height of the first tree and then relax answer.This solution can be optimized to linear solution: if we don't touch some tree, we know the first element of sequence. Let's count for each possible element amount of trees, which have required height. It can be done with linear loop and the 'increment' operation on array. After that we just find value of the first element, for which amount of 'good' trees is maximal and output n - x, where x is this amount.Problem D. CalendarWe know, that all lines of calendar should have equal length, so we can find this length. It's just , where suml - summary length of all strings. Now let take a look at string, which will be the first one in our calendar. Obliviously, it's profitably to take string with maximal s + d (where s is our string and d - is character from input). Such string is unique otherwise we have two equal strings in input (as d is not contained in any string); Of cause, you should remember that if you fix the first string in a line, you fix length of the second one - it's required to have at least one such. Great, now we know the first string in our calendar. Now let's determine the second one. We know it's length, so we need just to take minimal string with such length.We know one line, let's do similary with the second line and so on.Problem E. ExpressionUnder construction. The main idea is 3D dynamic with O(102) transition.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1771",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3125
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces - Code 1",
          "code": "1 1 1 2 3 3 2 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1771",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces - Code 2",
          "code": "1 2 3 4 5 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1771",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces - Code 3",
          "code": "-1 0 1 2 3 3 2 1 0 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1771",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 100000, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a(n);\n    \n    if (type == \"beautiful\") {\n        int h = opt<int>(\"h\", 1);\n        int limit = opt<int>(\"max_a\", 100000);\n        if (h + n/2 > limit) h = limit - n/2; // Adjust h to avoid exceeding max_a\n        int mid = n / 2;\n        for (int i = 0; i <= mid; ++i) {\n            a[i] = h + i;\n            a[n - i - 1] = a[i];\n        }\n    } else if (type == \"random\") {\n        int max_a = opt<int>(\"max_a\", 100000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    } else if (type == \"almost_beautiful\") {\n        int h = opt<int>(\"h\", 1);\n        int limit = opt<int>(\"max_a\", 100000);\n        if (h + n/2 > limit) h = limit - n/2;\n        int mid = n / 2;\n        for (int i = 0; i <= mid; ++i) {\n            a[i] = h + i;\n            a[n - i - 1] = a[i];\n        }\n        int changes = opt<int>(\"changes\", 1);\n        for (int i = 0; i < changes; ++i) {\n            int idx = rnd.next(0, n - 1);\n            a[idx] = rnd.next(1, limit);\n        }\n    } else if (type == \"constant\") {\n        int value = opt<int>(\"value\", 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (type == \"one_off\") {\n        int h = opt<int>(\"h\", 1);\n        int limit = opt<int>(\"max_a\", 100000);\n        if (h + n/2 > limit) h = limit - n/2;\n        int mid = n / 2;\n        for (int i = 0; i <= mid; ++i) {\n            a[i] = h + i;\n            a[n - i - 1] = a[i];\n        }\n        int idx = opt<int>(\"idx\", n / 2);\n        int delta = opt<int>(\"delta\", 1);\n        a[idx] = max(1, min(limit, a[idx] + delta));\n    } else if (type == \"max_ai\") {\n        int max_a = 100000;\n        for (int i = 0; i < n; ++i) {\n            a[i] = max_a;\n        }\n    } else if (type == \"min_ai\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else {\n        int max_a = opt<int>(\"max_a\", 100000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n -1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a(n);\n    \n    if (type == \"beautiful\") {\n        int h = opt<int>(\"h\", 1);\n        int limit = opt<int>(\"max_a\", 100000);\n        if (h + n/2 > limit) h = limit - n/2; // Adjust h to avoid exceeding max_a\n        int mid = n / 2;\n        for (int i = 0; i <= mid; ++i) {\n            a[i] = h + i;\n            a[n - i - 1] = a[i];\n        }\n    } else if (type == \"random\") {\n        int max_a = opt<int>(\"max_a\", 100000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    } else if (type == \"almost_beautiful\") {\n        int h = opt<int>(\"h\", 1);\n        int limit = opt<int>(\"max_a\", 100000);\n        if (h + n/2 > limit) h = limit - n/2;\n        int mid = n / 2;\n        for (int i = 0; i <= mid; ++i) {\n            a[i] = h + i;\n            a[n - i - 1] = a[i];\n        }\n        int changes = opt<int>(\"changes\", 1);\n        for (int i = 0; i < changes; ++i) {\n            int idx = rnd.next(0, n - 1);\n            a[idx] = rnd.next(1, limit);\n        }\n    } else if (type == \"constant\") {\n        int value = opt<int>(\"value\", 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (type == \"one_off\") {\n        int h = opt<int>(\"h\", 1);\n        int limit = opt<int>(\"max_a\", 100000);\n        if (h + n/2 > limit) h = limit - n/2;\n        int mid = n / 2;\n        for (int i = 0; i <= mid; ++i) {\n            a[i] = h + i;\n            a[n - i - 1] = a[i];\n        }\n        int idx = opt<int>(\"idx\", n / 2);\n        int delta = opt<int>(\"delta\", 1);\n        a[idx] = max(1, min(limit, a[idx] + delta));\n    } else if (type == \"max_ai\") {\n        int max_a = 100000;\n        for (int i = 0; i < n; ++i) {\n            a[i] = max_a;\n        }\n    } else if (type == \"min_ai\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else {\n        int max_a = opt<int>(\"max_a\", 100000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n -1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type beautiful\n./gen -n 2 -type beautiful -h 1\n./gen -n 3 -type beautiful -h 100\n./gen -n 10 -type beautiful -h 50000\n./gen -n 100 -type beautiful -h 1\n./gen -n 1000 -type beautiful -h 10000\n./gen -n 10000 -type beautiful -h 100\n./gen -n 100000 -type beautiful -h 1\n\n./gen -n 1 -type random -max_a 1\n./gen -n 2 -type random -max_a 10\n./gen -n 10 -type random -max_a 100\n./gen -n 100 -type random -max_a 1000\n./gen -n 1000 -type random -max_a 10000\n./gen -n 10000 -type random -max_a 100000\n./gen -n 100000 -type random -max_a 100000\n\n./gen -n 1 -type constant -value 1\n./gen -n 2 -type constant -value 1\n./gen -n 100 -type constant -value 1\n./gen -n 100000 -type constant -value 1\n\n./gen -n 1 -type one_off -h 1 -idx 0 -delta 1\n./gen -n 2 -type one_off -h 10 -idx 1 -delta 1\n./gen -n 10 -type one_off -h 5 -idx 5 -delta -1\n./gen -n 100 -type one_off -h 1 -idx 50 -delta 2\n./gen -n 1000 -type one_off -h 100 -idx 999 -delta -2\n./gen -n 100000 -type one_off -h 1 -idx 50000 -delta 1000\n\n./gen -n 100000 -type max_ai\n./gen -n 100000 -type min_ai\n\n./gen -n 100000 -type almost_beautiful -changes 1\n./gen -n 100000 -type almost_beautiful -changes 10\n./gen -n 100000 -type almost_beautiful -changes 100\n./gen -n 100000 -type almost_beautiful -changes 1000\n./gen -n 100000 -type almost_beautiful -changes 10000\n\n./gen -n 99999 -type beautiful -h 1\n./gen -n 100000 -type beautiful -h 1\n./gen -n 99999 -type random -max_a 100000\n./gen -n 100000 -type random -max_a 100000\n\n./gen -n 10 -type random -max_a 100000\n./gen -n 100 -type random -max_a 100000\n./gen -n 1000 -type random -max_a 100000\n./gen -n 10000 -type random -max_a 100000\n./gen -n 100000 -type random -max_a 100000\n\n./gen -n 1 -type random -max_a 1\n./gen -n 1 -type random -max_a 100000\n./gen -n 2 -type random -max_a 100000\n./gen -n 1 -type beautiful -h 100000\n./gen -n 2 -type beautiful -h 99999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:30.640270",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "58/D",
      "title": "D. Calendar",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 104, n is even) which is the number of branches. Then follow n lines which are the names of the cities. All the names consist of lowercase Latin letters; their lengths are no less than 1 and no more than 10 symbols. The next line contains a single symbol d (d has an ASCII-code from 33 to 126 inclusively, excluding lowercase Latin letters) which is the separator between words in the calendar lines. It is guaranteed that the calendar is possible to be constructed and all the names are different.",
      "output_spec": "OutputPrint n / 2 lines of similar length which are the required calendar. Every line should contain exactly two words and exactly one separator between them. If there are several solutions, print the lexicographically minimal one. The lexicographical comparison of lines is realized by the \"<\" operator in the modern programming languages.",
      "sample_tests": "ExamplesInputCopy4baahgc.OutputCopyaa.bc.hgInputCopy2aaa!OutputCopya!aaInputCopy2aaa|OutputCopyaa|a",
      "description": "D. Calendar\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 104, n is even) which is the number of branches. Then follow n lines which are the names of the cities. All the names consist of lowercase Latin letters; their lengths are no less than 1 and no more than 10 symbols. The next line contains a single symbol d (d has an ASCII-code from 33 to 126 inclusively, excluding lowercase Latin letters) which is the separator between words in the calendar lines. It is guaranteed that the calendar is possible to be constructed and all the names are different.\n\nOutputPrint n / 2 lines of similar length which are the required calendar. Every line should contain exactly two words and exactly one separator between them. If there are several solutions, print the lexicographically minimal one. The lexicographical comparison of lines is realized by the \"<\" operator in the modern programming languages.\n\nInputCopy4baahgc.OutputCopyaa.bc.hgInputCopy2aaa!OutputCopya!aaInputCopy2aaa|OutputCopyaa|a\n\nInputCopy4baahgc.\n\nOutputCopyaa.bc.hg\n\nInputCopy2aaa!\n\nOutputCopya!aa\n\nInputCopy2aaa|\n\nOutputCopyaa|a",
      "solutions": [
        {
          "title": "Codeforces Beta Round #54 (Div. 2) - Codeforces",
          "content": "Hello! This contest has been prepared by Artem Rakhov and other participants of Petrozavodsk Training Camp from Saratov State University. We stopped solving problems of the camp, missed the lecture by Vitaly Goldstein (do not be angry, Vitaly), but the round has been prepared and we are waiting for you - the participants. Happy hacking, MikeMirzayanov and team Codeforces UPD:ProblemsStandingsWinner: winmad",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1197",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 409
        },
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces",
          "content": "Problem A. Chat roomSolution is greedy algorithm. The first thing we do is find in our string the first letter 'h'. Then we find letter 'e' which is righter that found 'h'. If we find the whole word 'hello' in such way, obliviously, answer is YES.Now let's prove that if answer exists, we find it. Let see on position of the 'h' in right answer. If we move it to the first 'h' in our string, nothing changes. But now we can say that our greedy algorithm correctly Now let's do such with the second letter, and so on.We have greedy algorithm with work time O(n), where n - length of the input.Problem B. CoinsThis problem also have greedy solution: we run down all number from 2 and greater and while denomination of the last added to answer coin is divisible by current number, we divide and increase answer.You can prove correctness, if you take a look at prime factorizations of coins' denominations. In each next denomination each prime have less or equal power than the current one (it's equivalent to 'a divide b'). Obliviously, if summary degree of primes decreases at least two (for example, we had numbera = x· y· z (where y, z > 1, and the current number is b = x), then we can add one more coin with demonitaion a > c = x· y > b. So, in the optimal answer sum of degrees decreasing at exactly one. Our greedy algorithm do exactly what it need.Problem C. Trees.The first thing we notice - beautiful sequence is can be determined with any member. The next thing - at least one tree will remain the same height. Prove: let's fix height of the first tree, and correct heights of all other ones. Obliviously, they all remain positive.Solution with work time O(n2): we run down which tree we will fix, determine required height of the first tree and then relax answer.This solution can be optimized to linear solution: if we don't touch some tree, we know the first element of sequence. Let's count for each possible element amount of trees, which have required height. It can be done with linear loop and the 'increment' operation on array. After that we just find value of the first element, for which amount of 'good' trees is maximal and output n - x, where x is this amount.Problem D. CalendarWe know, that all lines of calendar should have equal length, so we can find this length. It's just , where suml - summary length of all strings. Now let take a look at string, which will be the first one in our calendar. Obliviously, it's profitably to take string with maximal s + d (where s is our string and d - is character from input). Such string is unique otherwise we have two equal strings in input (as d is not contained in any string); Of cause, you should remember that if you fix the first string in a line, you fix length of the second one - it's required to have at least one such. Great, now we know the first string in our calendar. Now let's determine the second one. We know it's length, so we need just to take minimal string with such length.We know one line, let's do similary with the second line and so on.Problem E. ExpressionUnder construction. The main idea is 3D dynamic with O(102) transition.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1771",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3125
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces - Code 1",
          "code": "1 1 1 2 3 3 2 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1771",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces - Code 2",
          "code": "1 2 3 4 5 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1771",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces - Code 3",
          "code": "-1 0 1 2 3 3 2 1 0 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1771",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n\n    ensuref(n % 2 == 0, \"n must be even, but n=%d\", n);\n\n    set<string> city_names;\n\n    for (int i = 0; i < n; ++i) {\n        string city = inf.readLine(\"[a-z]{1,10}\", \"city_name\");\n\n        ensuref(city_names.insert(city).second, \"city names must be unique, but duplicate city name found: %s\", city.c_str());\n    }\n\n    string s = inf.readLine();\n    ensuref(s.length() == 1, \"Separator character d must be a single character, but length=%d\", (int)s.length());\n\n    char d = s[0];\n    int code = (int)d;\n    ensuref(code >=33 && code <=126 && !(code >=97 && code <=122), \"Separator character d must have ASCII code between 33 and 126 (inclusive), excluding codes 97 to 122 (lowercase letters), but found code=%d\", code);\n\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n\n    ensuref(n % 2 == 0, \"n must be even, but n=%d\", n);\n\n    set<string> city_names;\n\n    for (int i = 0; i < n; ++i) {\n        string city = inf.readLine(\"[a-z]{1,10}\", \"city_name\");\n\n        ensuref(city_names.insert(city).second, \"city names must be unique, but duplicate city name found: %s\", city.c_str());\n    }\n\n    string s = inf.readLine();\n    ensuref(s.length() == 1, \"Separator character d must be a single character, but length=%d\", (int)s.length());\n\n    char d = s[0];\n    int code = (int)d;\n    ensuref(code >=33 && code <=126 && !(code >=97 && code <=122), \"Separator character d must have ASCII code between 33 and 126 (inclusive), excluding codes 97 to 122 (lowercase letters), but found code=%d\", code);\n\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n\n    ensuref(n % 2 == 0, \"n must be even, but n=%d\", n);\n\n    set<string> city_names;\n\n    for (int i = 0; i < n; ++i) {\n        string city = inf.readLine(\"[a-z]{1,10}\", \"city_name\");\n\n        ensuref(city_names.insert(city).second, \"city names must be unique, but duplicate city name found: %s\", city.c_str());\n    }\n\n    string s = inf.readLine();\n    ensuref(s.length() == 1, \"Separator character d must be a single character, but length=%d\", (int)s.length());\n\n    char d = s[0];\n    int code = (int)d;\n    ensuref(code >=33 && code <=126 && !(code >=97 && code <=122), \"Separator character d must have ASCII code between 33 and 126 (inclusive), excluding codes 97 to 122 (lowercase letters), but found code=%d\", code);\n\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    ensure(n >= 2 && n <= 10000 && n % 2 == 0);\n    string type = opt<string>(\"type\", \"random\");\n    string sep = opt<string>(\"sep\", \"\");\n    \n    // Generate separator character\n    char d;\n    if (!sep.empty()) {\n        d = sep[0];\n        ensure((33 <= d && d <= 126) && !(d >= 'a' && d <= 'z'));\n    } else {\n        // Generate a random separator character\n        vector<char> valid_separators;\n        for (int c = 33; c <= 126; c++) {\n            if (!(c >= 'a' && c <= 'z')) {\n                valid_separators.push_back(char(c));\n            }\n        }\n        d = valid_separators[rnd.next(0, int(valid_separators.size()) -1)];\n    }\n    \n    // Generate n unique city names\n    vector<string> names;\n    set<string> name_set;\n    \n    if (type == \"random\") {\n        // Random names of random length between 1 and 10\n        while(names.size() < n) {\n            int len = rnd.next(1,10);\n            string s;\n            for (int i = 0; i < len; i++) {\n                char c = rnd.next('a', 'z'); // Lowercase letters\n                s += c;\n            }\n            if(!name_set.count(s)) {\n                name_set.insert(s);\n                names.push_back(s);\n            }\n        }\n    } else if (type == \"maxlen\") {\n        // Names of length 10\n        while(names.size() < n) {\n            string s;\n            for (int i = 0; i < 10; i++) {\n                char c = rnd.next('a', 'z'); // Lowercase letters\n                s += c;\n            }\n            if(!name_set.count(s)) {\n                name_set.insert(s);\n                names.push_back(s);\n            }\n        }\n    } else if (type == \"minlen\") {\n        // Generate names starting from length 1, increasing lengths as needed\n        int len = 1;\n        string s(len, 'a');\n        while (names.size() < n) {\n            if (!name_set.count(s)) {\n                name_set.insert(s);\n                names.push_back(s);\n            }\n            // Increment the string s lexographically\n            int idx = len - 1;\n            while (idx >= 0 && s[idx] == 'z') {\n                s[idx] = 'a';\n                idx--;\n            }\n            if (idx < 0) {\n                len++;\n                ensure(len <= 10); // Ensure name length does not exceed 10\n                s = string(len, 'a');\n            } else {\n                s[idx]++;\n            }\n        }\n    } else if (type == \"asc\") {\n        // Generate names in lexicographical ascending order\n        int len = 1;\n        string s(len, 'a');\n        while (names.size() < n) {\n            if (!name_set.count(s)) {\n                name_set.insert(s);\n                names.push_back(s);\n            }\n            // Increment the string s lexographically\n            int idx = len - 1;\n            while (idx >= 0 && s[idx] == 'z') {\n                s[idx] = 'a';\n                idx--;\n            }\n            if (idx < 0) {\n                len++;\n                ensure(len <= 10); // Ensure name length does not exceed 10\n                s = string(len, 'a');\n            } else {\n                s[idx]++;\n            }\n        }\n    } else if (type == \"desc\") {\n        // Generate names in lexicographical descending order\n        int len = 1;\n        string s(len, 'z');\n        while (names.size() < n) {\n            if (!name_set.count(s)) {\n                name_set.insert(s);\n                names.push_back(s);\n            }\n            // Decrement the string s lexographically\n            int idx = len - 1;\n            while (idx >= 0 && s[idx] == 'a') {\n                s[idx] = 'z';\n                idx--;\n            }\n            if (idx < 0) {\n                len++;\n                ensure(len <= 10); // Ensure name length does not exceed 10\n                s = string(len, 'z');\n            } else {\n                s[idx]--;\n            }\n        }\n    } else if (type == \"sameprefix\") {\n        // Generate names with the same prefix\n        string prefix;\n        int preflen = rnd.next(1, 5);\n        for (int i = 0; i < preflen; i++) {\n            prefix += rnd.next('a', 'z');\n        }\n        while (names.size() < n) {\n            int len = rnd.next(preflen + 1, 10);\n            string s = prefix;\n            for (int i = preflen; i < len; i++) {\n                char c = rnd.next('a', 'z');\n                s += c;\n            }\n            if (!name_set.count(s)) {\n                name_set.insert(s);\n                names.push_back(s);\n            }\n        }\n    } else if (type == \"varylen\") {\n        // Names with varying lengths between 1 and 10\n        while (names.size() < n) {\n            int len = rnd.next(1, 10);\n            string s;\n            for (int i = 0; i < len; i++) {\n                s += rnd.next('a', 'z');\n            }\n            if (!name_set.count(s)) {\n                name_set.insert(s);\n                names.push_back(s);\n            }\n        }\n    } else {\n        // Default to random\n        while(names.size() < n) {\n            int len = rnd.next(1,10);\n            string s;\n            for (int i = 0; i < len; i++) {\n                char c = rnd.next('a', 'z');\n                s += c;\n            }\n            if(!name_set.count(s)) {\n                name_set.insert(s);\n                names.push_back(s);\n            }\n        }\n    }\n    \n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", names[i].c_str());\n    }\n    printf(\"%c\\n\", d);\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    ensure(n >= 2 && n <= 10000 && n % 2 == 0);\n    string type = opt<string>(\"type\", \"random\");\n    string sep = opt<string>(\"sep\", \"\");\n    \n    // Generate separator character\n    char d;\n    if (!sep.empty()) {\n        d = sep[0];\n        ensure((33 <= d && d <= 126) && !(d >= 'a' && d <= 'z'));\n    } else {\n        // Generate a random separator character\n        vector<char> valid_separators;\n        for (int c = 33; c <= 126; c++) {\n            if (!(c >= 'a' && c <= 'z')) {\n                valid_separators.push_back(char(c));\n            }\n        }\n        d = valid_separators[rnd.next(0, int(valid_separators.size()) -1)];\n    }\n    \n    // Generate n unique city names\n    vector<string> names;\n    set<string> name_set;\n    \n    if (type == \"random\") {\n        // Random names of random length between 1 and 10\n        while(names.size() < n) {\n            int len = rnd.next(1,10);\n            string s;\n            for (int i = 0; i < len; i++) {\n                char c = rnd.next('a', 'z'); // Lowercase letters\n                s += c;\n            }\n            if(!name_set.count(s)) {\n                name_set.insert(s);\n                names.push_back(s);\n            }\n        }\n    } else if (type == \"maxlen\") {\n        // Names of length 10\n        while(names.size() < n) {\n            string s;\n            for (int i = 0; i < 10; i++) {\n                char c = rnd.next('a', 'z'); // Lowercase letters\n                s += c;\n            }\n            if(!name_set.count(s)) {\n                name_set.insert(s);\n                names.push_back(s);\n            }\n        }\n    } else if (type == \"minlen\") {\n        // Generate names starting from length 1, increasing lengths as needed\n        int len = 1;\n        string s(len, 'a');\n        while (names.size() < n) {\n            if (!name_set.count(s)) {\n                name_set.insert(s);\n                names.push_back(s);\n            }\n            // Increment the string s lexographically\n            int idx = len - 1;\n            while (idx >= 0 && s[idx] == 'z') {\n                s[idx] = 'a';\n                idx--;\n            }\n            if (idx < 0) {\n                len++;\n                ensure(len <= 10); // Ensure name length does not exceed 10\n                s = string(len, 'a');\n            } else {\n                s[idx]++;\n            }\n        }\n    } else if (type == \"asc\") {\n        // Generate names in lexicographical ascending order\n        int len = 1;\n        string s(len, 'a');\n        while (names.size() < n) {\n            if (!name_set.count(s)) {\n                name_set.insert(s);\n                names.push_back(s);\n            }\n            // Increment the string s lexographically\n            int idx = len - 1;\n            while (idx >= 0 && s[idx] == 'z') {\n                s[idx] = 'a';\n                idx--;\n            }\n            if (idx < 0) {\n                len++;\n                ensure(len <= 10); // Ensure name length does not exceed 10\n                s = string(len, 'a');\n            } else {\n                s[idx]++;\n            }\n        }\n    } else if (type == \"desc\") {\n        // Generate names in lexicographical descending order\n        int len = 1;\n        string s(len, 'z');\n        while (names.size() < n) {\n            if (!name_set.count(s)) {\n                name_set.insert(s);\n                names.push_back(s);\n            }\n            // Decrement the string s lexographically\n            int idx = len - 1;\n            while (idx >= 0 && s[idx] == 'a') {\n                s[idx] = 'z';\n                idx--;\n            }\n            if (idx < 0) {\n                len++;\n                ensure(len <= 10); // Ensure name length does not exceed 10\n                s = string(len, 'z');\n            } else {\n                s[idx]--;\n            }\n        }\n    } else if (type == \"sameprefix\") {\n        // Generate names with the same prefix\n        string prefix;\n        int preflen = rnd.next(1, 5);\n        for (int i = 0; i < preflen; i++) {\n            prefix += rnd.next('a', 'z');\n        }\n        while (names.size() < n) {\n            int len = rnd.next(preflen + 1, 10);\n            string s = prefix;\n            for (int i = preflen; i < len; i++) {\n                char c = rnd.next('a', 'z');\n                s += c;\n            }\n            if (!name_set.count(s)) {\n                name_set.insert(s);\n                names.push_back(s);\n            }\n        }\n    } else if (type == \"varylen\") {\n        // Names with varying lengths between 1 and 10\n        while (names.size() < n) {\n            int len = rnd.next(1, 10);\n            string s;\n            for (int i = 0; i < len; i++) {\n                s += rnd.next('a', 'z');\n            }\n            if (!name_set.count(s)) {\n                name_set.insert(s);\n                names.push_back(s);\n            }\n        }\n    } else {\n        // Default to random\n        while(names.size() < n) {\n            int len = rnd.next(1,10);\n            string s;\n            for (int i = 0; i < len; i++) {\n                char c = rnd.next('a', 'z');\n                s += c;\n            }\n            if(!name_set.count(s)) {\n                name_set.insert(s);\n                names.push_back(s);\n            }\n        }\n    }\n    \n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", names[i].c_str());\n    }\n    printf(\"%c\\n\", d);\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type minlen -sep '!'\n./gen -n 4 -type minlen -sep '@'\n./gen -n 10 -type minlen -sep '#'\n./gen -n 2 -type maxlen -sep '~'\n./gen -n 4 -type maxlen -sep '}'\n./gen -n 10 -type maxlen -sep '{'\n./gen -n 2 -type asc -sep '%'\n./gen -n 4 -type asc -sep '+'\n./gen -n 6 -type asc -sep '-'\n./gen -n 10000 -type asc -sep '^'\n./gen -n 2 -type desc -sep '&'\n./gen -n 4 -type desc -sep '|'\n./gen -n 6 -type desc -sep '`'\n./gen -n 10000 -type desc -sep '_'\n./gen -n 2 -type random -sep '='\n./gen -n 4 -type random -sep '*'\n./gen -n 6 -type random -sep '$'\n./gen -n 10000 -type random -sep '+'\n./gen -n 10000 -type random\n./gen -n 10000 -type random -sep '0'\n./gen -n 10000 -type sameprefix -sep 'A'\n./gen -n 10000 -type sameprefix -sep 'Z'\n./gen -n 10000 -type varylen -sep '9'\n./gen -n 10000 -type varylen -sep '['\n./gen -n 10000 -type minlen -sep ']'\n./gen -n 10000 -type maxlen -sep ';'\n./gen -n 10000 -type random -sep ':'\n./gen -n 10000 -type random -sep ','\n./gen -n 10000 -type random -sep '.'\n./gen -n 10000 -type random -sep '?'\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:32.880679",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "58/E",
      "title": "E. Выражение",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой и единственной строке записано выражение a + b = c (1 ≤ a, b, c ≤ 106, a, b и c не содержат лидирующие нули) — выражение, которое было записано у Васи.",
      "output_spec": "Выходные данныеВыведите корректное выражение x + y = z (x, y и z — неотрицательные числа без лидирующих нулей). Выражение a + b = c должно встречаться в x + y = z как подпоследовательность. Выводимое решение должно иметь наименьшее возможное число символов; если же таких решений несколько, можно вывести любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать2+4=5Выходные данныеСкопировать21+4=25Входные данныеСкопировать1+1=3Выходные данныеСкопировать1+31=32Входные данныеСкопировать1+1=2Выходные данныеСкопировать1+1=2",
      "description": "E. Выражение\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой и единственной строке записано выражение a + b = c (1 ≤ a, b, c ≤ 106, a, b и c не содержат лидирующие нули) — выражение, которое было записано у Васи.\n\nВходные данные\n\nВыходные данныеВыведите корректное выражение x + y = z (x, y и z — неотрицательные числа без лидирующих нулей). Выражение a + b = c должно встречаться в x + y = z как подпоследовательность. Выводимое решение должно иметь наименьшее возможное число символов; если же таких решений несколько, можно вывести любое.\n\nВыходные данные\n\nВходные данныеСкопировать2+4=5Выходные данныеСкопировать21+4=25Входные данныеСкопировать1+1=3Выходные данныеСкопировать1+31=32Входные данныеСкопировать1+1=2Выходные данныеСкопировать1+1=2\n\nВходные данныеСкопировать2+4=5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать21+4=25\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1+1=3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1+31=32\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1+1=2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1+1=2\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #54 (Div. 2) - Codeforces",
          "content": "Всем привет! Этот контест был подготовлен в срочном порядке Артемом Раховым и другими участниками сборов в Петрозаводске от Саратовского ГУ. Пришлось оторваться от дорешивания, не пойти на лекцию Виталия Гольдштейна (не сердись, Виталий), но зато раунд подготовлен и мы ждем вас — участников. Как говорится, \"happy hacking\" MikeMirzayanov и команда Codeforces UPD. Контест закончен, всем спасибо за участие. Победил участник из Китая winmad. Лучший участник вне конкурса: anonymous. Последняя задача контеста поддалась только ему, браво!результатызадачи",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1197",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 553
        },
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces",
          "content": "Задача A. ЧатЗадача решается жадным алгоритмом. Сначала найдём в строке первую букву ('h\"). Далее - найдём следующую после неё букву 'e'. Если мы таким образом нашли все буквы, то ответ, очевидно, YES. Теперь давайте докажем, что если ответ был, то он обязательно найдётся. В самом деле, пусть был какой-то ответ. Посмотрим на позицию буквы 'h'. Если мы её сдвинем до самой первой влево (той, которую найдёт жадник), то ничего не изменится. Аналогично поступим со второй и следующими буквами.Получили жадный алгоритм, работающий за O(n), где n - длина входа.Задача B. МонетыВ этой задаче правильным решением опять же является жадный алгоритм. Выглядит он так: перебираем все числа от 2 и далее, пока стоимость последней добавленной монеты делится на него, делим, добавляем в ответ.Доказать корректность можно, если посмотреть на стоимости монет в разложении на простые множители. В каждой следующей стоимости все простые входят в меньшей либо равной степени, нежели в текущей (это равносильно тому, что одно делится на другое). Также очевидно, что если суммарная степень уменьшилась хотя бы на два (например, было число a = x· y· z (где y, z > 1, а стало b = x, то можно добавить еще одну промежуточную стоимость a > c = x· y > b. Таким образом, в правильном ответе сумма степеней вхождений при переходе от стоимости к следующей и меньшей уменьшается каждый раз на один. Наш жадный алгоритм именно так и поступает.Задача C. ДеревьяПервая мысль - красивая последовательность полностью задаётся любым своим членом. Следующая мысль: хотя бы одно дерево мы трогать не будем. Доказательство: скажем, что мы не трогаем первое дерево, а высоты остальных подгоним. Они, очевидно, все будут положительны.Решение за квадрат: перебираем, какое дерево мы не трогаем, узнаём первый член последовательности, смотрим, сколько деревьев не совпало.Это оптимизируется до решения за линию: если мы не трогаем какое-то дерево, то у нас фиксирован первый член последовательности. Давайте подсчитаем для каждого возможного первого члена, скольки деревьям он подходит. Это делается линейным проходом по всем деревьям и операцией \"инкремент\" на массиве. После чего осталось найти значение первого члена, которому удовлетворяет наибольшее количетсво деревьев, и вывести n - x, где x - это значение.Задача D. КалендарьДля начала заметим, что так как все строки календаря должны иметь одинаковую длину, то мы легко может эту длину найти. Это просто , где suml - суммарная длина всех строк. Теперь посмотрим на строку, которую поставим самой первой. Очевидно, выгодно брать строку, чтобы s + d было минимально (где s - наша строка, а d - дописываемый символ). Понятно, что такая найдётся однозначно, иначе получается, что две строки совпадают (так как символ d нигде не встречается). Разумеется, нельзя забывать, что зафиксировав первую строку, мы зафиксируем длину второй - надо, чтобы хотя бы одна была. Отлично, с первой строкой мы определились. Теперь мы знаем длину второй строки. Здесь нам надо взять просто минимальную строку соответствующей длины (одна префиксом другой быть не может - длины равны). Таким образом, заполняем календарь по линиям.Задача E. ВыражениеUnder construction. Основная идея - кубическая динамика с переходом за 102.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1771",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3219
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #54 (Div. 2) - Codeforces - Code 1",
          "code": "ad6airnnpg\nbad6jvcjsxfob\njvcjsxfo6quryai\nqury6rnnpg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #54 (Div. 2) - Codeforces - Code 2",
          "code": "ad6jvcjsxfob\nairnnpg6qury\nbad6jvcjsxfo\nquryai6rnnpg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #54 (Div. 2) - Codeforces - Code 3",
          "code": "ad6airnnpgbad6jvcjsxfobjvcjsxfo6quryaiqury6rnnpg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #54 (Div. 2) - Codeforces - Code 4",
          "code": "ad6jvcjsxfobairnnpg6qurybad6jvcjsxfoquryai6rnnpg",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1197",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces - Code 1",
          "code": "1 1 1 2 3 3 2 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1771",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces - Code 2",
          "code": "1 2 3 4 5 5 4 3 2 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1771",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #54 (Div.2) - разбор A-D - Codeforces - Code 3",
          "code": "-1 0 1 2 3 3 2 1 0 -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1771",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    ensuref(!s.empty(), \"Input line is empty\");\n\n    size_t plusPos = s.find('+');\n    ensuref(plusPos != string::npos, \"No '+' sign found in the expression\");\n\n    size_t equalPos = s.find('=');\n    ensuref(equalPos != string::npos, \"No '=' sign found in the expression\");\n\n    ensuref(plusPos < equalPos, \"'+' sign must come before '=' sign\");\n\n    size_t anotherPlusPos = s.find('+', plusPos + 1);\n    ensuref(anotherPlusPos == string::npos, \"More than one '+' sign found in the expression\");\n\n    size_t anotherEqualPos = s.find('=', equalPos + 1);\n    ensuref(anotherEqualPos == string::npos, \"More than one '=' sign found in the expression\");\n\n    string aStr = s.substr(0, plusPos);\n    string bStr = s.substr(plusPos + 1, equalPos - plusPos - 1);\n    string cStr = s.substr(equalPos + 1);\n\n    ensuref(!aStr.empty(), \"Number 'a' is empty\");\n    ensuref(!bStr.empty(), \"Number 'b' is empty\");\n    ensuref(!cStr.empty(), \"Number 'c' is empty\");\n\n    for (char c : aStr)\n        ensuref(isdigit(c), \"Invalid character in number 'a'\");\n    for (char c : bStr)\n        ensuref(isdigit(c), \"Invalid character in number 'b'\");\n    for (char c : cStr)\n        ensuref(isdigit(c), \"Invalid character in number 'c'\");\n\n    ensuref(aStr[0] >= '1' && aStr[0] <= '9', \"Number 'a' has leading zeros or is zero\");\n    ensuref(bStr[0] >= '1' && bStr[0] <= '9', \"Number 'b' has leading zeros or is zero\");\n    ensuref(cStr[0] >= '1' && cStr[0] <= '9', \"Number 'c' has leading zeros or is zero\");\n\n    long long a = stoll(aStr);\n    long long b = stoll(bStr);\n    long long c = stoll(cStr);\n\n    ensuref(a >= 1 && a <= 1000000, \"Number 'a' is not in the range [1, 1000000]\");\n    ensuref(b >= 1 && b <= 1000000, \"Number 'b' is not in the range [1, 1000000]\");\n    ensuref(c >= 1 && c <= 1000000, \"Number 'c' is not in the range [1, 1000000]\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    ensuref(!s.empty(), \"Input line is empty\");\n\n    size_t plusPos = s.find('+');\n    ensuref(plusPos != string::npos, \"No '+' sign found in the expression\");\n\n    size_t equalPos = s.find('=');\n    ensuref(equalPos != string::npos, \"No '=' sign found in the expression\");\n\n    ensuref(plusPos < equalPos, \"'+' sign must come before '=' sign\");\n\n    size_t anotherPlusPos = s.find('+', plusPos + 1);\n    ensuref(anotherPlusPos == string::npos, \"More than one '+' sign found in the expression\");\n\n    size_t anotherEqualPos = s.find('=', equalPos + 1);\n    ensuref(anotherEqualPos == string::npos, \"More than one '=' sign found in the expression\");\n\n    string aStr = s.substr(0, plusPos);\n    string bStr = s.substr(plusPos + 1, equalPos - plusPos - 1);\n    string cStr = s.substr(equalPos + 1);\n\n    ensuref(!aStr.empty(), \"Number 'a' is empty\");\n    ensuref(!bStr.empty(), \"Number 'b' is empty\");\n    ensuref(!cStr.empty(), \"Number 'c' is empty\");\n\n    for (char c : aStr)\n        ensuref(isdigit(c), \"Invalid character in number 'a'\");\n    for (char c : bStr)\n        ensuref(isdigit(c), \"Invalid character in number 'b'\");\n    for (char c : cStr)\n        ensuref(isdigit(c), \"Invalid character in number 'c'\");\n\n    ensuref(aStr[0] >= '1' && aStr[0] <= '9', \"Number 'a' has leading zeros or is zero\");\n    ensuref(bStr[0] >= '1' && bStr[0] <= '9', \"Number 'b' has leading zeros or is zero\");\n    ensuref(cStr[0] >= '1' && cStr[0] <= '9', \"Number 'c' has leading zeros or is zero\");\n\n    long long a = stoll(aStr);\n    long long b = stoll(bStr);\n    long long c = stoll(cStr);\n\n    ensuref(a >= 1 && a <= 1000000, \"Number 'a' is not in the range [1, 1000000]\");\n    ensuref(b >= 1 && b <= 1000000, \"Number 'b' is not in the range [1, 1000000]\");\n    ensuref(c >= 1 && c <= 1000000, \"Number 'c' is not in the range [1, 1000000]\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine();\n    ensuref(!s.empty(), \"Input line is empty\");\n\n    size_t plusPos = s.find('+');\n    ensuref(plusPos != string::npos, \"No '+' sign found in the expression\");\n\n    size_t equalPos = s.find('=');\n    ensuref(equalPos != string::npos, \"No '=' sign found in the expression\");\n\n    ensuref(plusPos < equalPos, \"'+' sign must come before '=' sign\");\n\n    size_t anotherPlusPos = s.find('+', plusPos + 1);\n    ensuref(anotherPlusPos == string::npos, \"More than one '+' sign found in the expression\");\n\n    size_t anotherEqualPos = s.find('=', equalPos + 1);\n    ensuref(anotherEqualPos == string::npos, \"More than one '=' sign found in the expression\");\n\n    string aStr = s.substr(0, plusPos);\n    string bStr = s.substr(plusPos + 1, equalPos - plusPos - 1);\n    string cStr = s.substr(equalPos + 1);\n\n    ensuref(!aStr.empty(), \"Number 'a' is empty\");\n    ensuref(!bStr.empty(), \"Number 'b' is empty\");\n    ensuref(!cStr.empty(), \"Number 'c' is empty\");\n\n    for (char c : aStr)\n        ensuref(isdigit(c), \"Invalid character in number 'a'\");\n    for (char c : bStr)\n        ensuref(isdigit(c), \"Invalid character in number 'b'\");\n    for (char c : cStr)\n        ensuref(isdigit(c), \"Invalid character in number 'c'\");\n\n    ensuref(aStr[0] >= '1' && aStr[0] <= '9', \"Number 'a' has leading zeros or is zero\");\n    ensuref(bStr[0] >= '1' && bStr[0] <= '9', \"Number 'b' has leading zeros or is zero\");\n    ensuref(cStr[0] >= '1' && cStr[0] <= '9', \"Number 'c' has leading zeros or is zero\");\n\n    long long a = stoll(aStr);\n    long long b = stoll(bStr);\n    long long c = stoll(cStr);\n\n    ensuref(a >= 1 && a <= 1000000, \"Number 'a' is not in the range [1, 1000000]\");\n    ensuref(b >= 1 && b <= 1000000, \"Number 'b' is not in the range [1, 1000000]\");\n    ensuref(c >= 1 && c <= 1000000, \"Number 'c' is not in the range [1, 1000000]\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Checks if 'small' is a subsequence of 'large'.\nbool isSubsequence(const string &small, const string &large) {\n    int i = 0, j = 0;\n    while (i < (int)small.size() && j < (int)large.size()) {\n        if (small[i] == large[j]) i++;\n        j++;\n    }\n    return i == (int)small.size();\n}\n\n// Checks that 's' is a valid integer (no leading zero unless \"0\").\nbool isValidNumber(const string &s) {\n    if (s.empty()) return false;\n    if (s.size() > 1 && s[0] == '0') return false;\n    return all_of(s.begin(), s.end(), ::isdigit);\n}\n\n// Reads x+y=z from 'stream'.  If 'isJury' (true) -> on failure do quitf(_fail), else -> quitf(_wa).\n// Returns the total length of the expression if valid.\nlong long parseAndCheck(\n    InStream &stream,\n    const string &a, const string &b, const string &c,\n    bool isJury  // determines how we quitf on error\n) {\n    // Read a single token, e.g. \"1+1=2\".\n    // No second argument to avoid treating it as a pattern.\n    string expr = stream.readToken();\n\n    // Find '+' and '='.\n    int plusPos = -1, eqPos = -1;\n    for (int i = 0; i < (int)expr.size(); i++) {\n        if (expr[i] == '+') {\n            if (plusPos >= 0) {\n                if (isJury) stream.quitf(_fail, \"Multiple '+' in jury solution.\");\n                else        stream.quitf(_wa,   \"Multiple '+' in participant solution.\");\n            }\n            plusPos = i;\n        } else if (expr[i] == '=') {\n            if (eqPos >= 0) {\n                if (isJury) stream.quitf(_fail, \"Multiple '=' in jury solution.\");\n                else        stream.quitf(_wa,   \"Multiple '=' in participant solution.\");\n            }\n            eqPos = i;\n        }\n    }\n    // Must find exactly one '+' before exactly one '='.\n    if (plusPos < 0 || eqPos < 0 || plusPos >= eqPos) {\n        if (isJury) stream.quitf(_fail, \"Invalid expression format in jury solution (need 1 '+' and 1 '=').\");\n        else        stream.quitf(_wa,   \"Invalid expression format in participant solution (need 1 '+' and 1 '=').\");\n    }\n\n    string X = expr.substr(0, plusPos);\n    string Y = expr.substr(plusPos + 1, eqPos - (plusPos + 1));\n    string Z = expr.substr(eqPos + 1);\n\n    // Check each is a valid integer\n    auto checkNum = [&](const string &s, const char *label){\n        if (!isValidNumber(s)) {\n            if (isJury) stream.quitf(_fail, \"'%s' is not a valid integer in jury solution.\", label);\n            else        stream.quitf(_wa,   \"'%s' is not a valid integer in participant solution.\", label);\n        }\n    };\n    checkNum(X, \"x\");\n    checkNum(Y, \"y\");\n    checkNum(Z, \"z\");\n\n    long long xVal = stoll(X);\n    long long yVal = stoll(Y);\n    long long zVal = stoll(Z);\n    // Check arithmetic\n    if (xVal + yVal != zVal) {\n        if (isJury) stream.quitf(_fail, \"Arithmetic mismatch in jury solution: %lld + %lld != %lld\", xVal, yVal, zVal);\n        else        stream.quitf(_wa,   \"Arithmetic mismatch in participant solution: %lld + %lld != %lld\", xVal, yVal, zVal);\n    }\n\n    // Check subsequence constraints: a->X, b->Y, c->Z\n    auto checkSubseq = [&](const string &sub, const string &full, const char *subName, const char *fullName){\n        if (!isSubsequence(sub, full)) {\n            if (isJury) stream.quitf(_fail, \"'%s' is not a subsequence of '%s' in jury solution.\", subName, fullName);\n            else        stream.quitf(_wa,   \"'%s' is not a subsequence of '%s' in participant solution.\", subName, fullName);\n        }\n    };\n    checkSubseq(a, X, \"a\", \"x\");\n    checkSubseq(b, Y, \"b\", \"y\");\n    checkSubseq(c, Z, \"c\", \"z\");\n\n    return (long long)expr.size();\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Input file has a single token like \"1+1=2\".\n    string original = inf.readToken();\n\n    // Extract a, b, c from that single token.\n    int plusPos = (int)original.find('+');\n    int eqPos   = (int)original.find('=');\n    string a = original.substr(0, plusPos);\n    string b = original.substr(plusPos + 1, eqPos - (plusPos + 1));\n    string c = original.substr(eqPos + 1);\n\n    // Skip leading whitespace in .ans to see if empty.\n    ans.skipBlanks();\n    if (ans.eof()) {\n        // No official solution => only check participant's correctness\n        parseAndCheck(ouf, a, b, c, /*isJury=*/false);\n        quitf(_ok, \"Accepted (no official answer to compare).\");\n    } else {\n        // Compare length with official solution\n        long long ansLen = parseAndCheck(ans, a, b, c, /*isJury=*/true);\n        long long outLen = parseAndCheck(ouf, a, b, c, /*isJury=*/false);\n\n        if (outLen > ansLen) {\n            quitf(_wa,   \"Participant's solution length %lld > official's %lld.\", outLen, ansLen);\n        } else if (outLen < ansLen) {\n            quitf(_fail, \"Participant's solution length %lld < official's %lld (better than official?).\", outLen, ansLen);\n        } else {\n            quitf(_ok,   \"Accepted: same length %lld as official.\", outLen);\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1000000); // Max value for a, b, c\n    string type = opt<string>(\"type\", \"random_incorrect\");\n\n    int a, b, c;\n    if (type == \"random_correct\") {\n        // Generate random a, b, compute c\n        do {\n            a = rnd.next(1, n);\n            b = rnd.next(1, n);\n            c = a + b;\n        } while (c > n);\n    } else if (type == \"random_incorrect\") {\n        // Generate random a, b, c where a + b != c\n        do {\n            a = rnd.next(1, n);\n            b = rnd.next(1, n);\n            c = rnd.next(1, n);\n        } while (a + b == c);\n    } else if (type == \"max_values\") {\n        // Try to set a, b, c to maximum values\n        a = n;\n        b = n;\n        c = a + b;\n        if (c > n) {\n            // Adjust c to be within bounds\n            c = n;\n            if (a + b == c) {\n                // Make the expression incorrect\n                c = n - 1;\n            }\n        }\n    } else if (type == \"min_values\") {\n        a = 1;\n        b = 1;\n        c = 1;\n        if (a + b == c) {\n            // Make expression incorrect\n            c = 2;\n        }\n    } else if (type == \"edge_cases\") {\n        // Generate a, b, c with maximum allowed number of digits (6 digits)\n        int min6digit = 100000;\n        int max6digit = min(n, 999999);\n        a = rnd.next(min6digit, max6digit);\n        b = rnd.next(min6digit, max6digit);\n        c = a + b;\n        if (c > n) c = rnd.next(min6digit, max6digit);\n    } else if (type == \"same_digits\") {\n        int digit = rnd.next(1,9);\n        int length = rnd.next(1,6);\n        string digit_str(length, '0'+digit);\n        a = stoi(digit_str);\n        b = a;\n        c = a + b;\n        if(a > n || b > n || c > n) {\n            // Adjust to fit within n\n            a = rnd.next(1, n/2);\n            b = a;\n            c = a + b;\n        }\n    } else if (type == \"special_numbers\") {\n        a = 123456 % n + 1;\n        b = 654321 % n + 1;\n        c = a + b;\n        if (c > n) c = rnd.next(1, n);\n    } else {\n        // default to random_incorrect\n        do {\n            a = rnd.next(1, n);\n            b = rnd.next(1, n);\n            c = rnd.next(1, n);\n        } while (a + b == c);\n    }\n    // Ensure no leading zeros\n    printf(\"%d+%d=%d\\n\", a, b, c);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1000000); // Max value for a, b, c\n    string type = opt<string>(\"type\", \"random_incorrect\");\n\n    int a, b, c;\n    if (type == \"random_correct\") {\n        // Generate random a, b, compute c\n        do {\n            a = rnd.next(1, n);\n            b = rnd.next(1, n);\n            c = a + b;\n        } while (c > n);\n    } else if (type == \"random_incorrect\") {\n        // Generate random a, b, c where a + b != c\n        do {\n            a = rnd.next(1, n);\n            b = rnd.next(1, n);\n            c = rnd.next(1, n);\n        } while (a + b == c);\n    } else if (type == \"max_values\") {\n        // Try to set a, b, c to maximum values\n        a = n;\n        b = n;\n        c = a + b;\n        if (c > n) {\n            // Adjust c to be within bounds\n            c = n;\n            if (a + b == c) {\n                // Make the expression incorrect\n                c = n - 1;\n            }\n        }\n    } else if (type == \"min_values\") {\n        a = 1;\n        b = 1;\n        c = 1;\n        if (a + b == c) {\n            // Make expression incorrect\n            c = 2;\n        }\n    } else if (type == \"edge_cases\") {\n        // Generate a, b, c with maximum allowed number of digits (6 digits)\n        int min6digit = 100000;\n        int max6digit = min(n, 999999);\n        a = rnd.next(min6digit, max6digit);\n        b = rnd.next(min6digit, max6digit);\n        c = a + b;\n        if (c > n) c = rnd.next(min6digit, max6digit);\n    } else if (type == \"same_digits\") {\n        int digit = rnd.next(1,9);\n        int length = rnd.next(1,6);\n        string digit_str(length, '0'+digit);\n        a = stoi(digit_str);\n        b = a;\n        c = a + b;\n        if(a > n || b > n || c > n) {\n            // Adjust to fit within n\n            a = rnd.next(1, n/2);\n            b = a;\n            c = a + b;\n        }\n    } else if (type == \"special_numbers\") {\n        a = 123456 % n + 1;\n        b = 654321 % n + 1;\n        c = a + b;\n        if (c > n) c = rnd.next(1, n);\n    } else {\n        // default to random_incorrect\n        do {\n            a = rnd.next(1, n);\n            b = rnd.next(1, n);\n            c = rnd.next(1, n);\n        } while (a + b == c);\n    }\n    // Ensure no leading zeros\n    printf(\"%d+%d=%d\\n\", a, b, c);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1000000 -type random_correct\n./gen -n 1000000 -type random_correct\n./gen -n 1000000 -type random_correct\n./gen -n 1000000 -type random_correct\n./gen -n 1000 -type random_correct\n./gen -n 1000 -type random_correct\n\n./gen -n 1000000 -type random_incorrect\n./gen -n 1000000 -type random_incorrect\n./gen -n 1000000 -type random_incorrect\n./gen -n 1000 -type random_incorrect\n./gen -n 1000 -type random_incorrect\n\n./gen -n 1000000 -type max_values\n./gen -n 1000000 -type max_values\n\n./gen -n 1 -type min_values\n./gen -n 2 -type min_values\n\n./gen -n 1000000 -type edge_cases\n./gen -n 999999 -type edge_cases\n\n./gen -n 1000000 -type same_digits\n./gen -n 1000000 -type same_digits\n./gen -n 1000000 -type same_digits\n\n./gen -n 1000000 -type special_numbers\n./gen -n 1000000 -type special_numbers\n\n./gen -n 10 -type random_correct\n./gen -n 10 -type random_incorrect\n\n./gen -n 1000 -type random_incorrect\n\n./gen -n 1000000 -type random_incorrect\n./gen -n 1000000 -type random_incorrect\n./gen -n 1000000 -type random_correct\n./gen -n 1000000 -type random_correct\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:35.098459",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "580/A",
      "title": "A. Kefa and First Steps",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105).The second line contains n integers a1,  a2,  ...,  an (1 ≤ ai ≤ 109).",
      "output_spec": "OutputPrint a single integer — the length of the maximum non-decreasing subsegment of sequence a.",
      "sample_tests": "ExamplesInputCopy62 2 1 3 4 1OutputCopy3InputCopy32 2 9OutputCopy3",
      "description": "A. Kefa and First Steps\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 105).The second line contains n integers a1,  a2,  ...,  an (1 ≤ ai ≤ 109).\n\nOutputPrint a single integer — the length of the maximum non-decreasing subsegment of sequence a.\n\nInputCopy62 2 1 3 4 1OutputCopy3InputCopy32 2 9OutputCopy3\n\nInputCopy62 2 1 3 4 1\n\nOutputCopy3\n\nInputCopy32 2 9\n\nOutputCopy3\n\nNoteIn the first test the maximum non-decreasing subsegment is the numbers from the third to the fifth one.In the second test the maximum non-decreasing subsegment is the numbers from the first to the third one.",
      "solutions": [
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces",
          "content": "Good day to everybody!The next round for the participants of the second division will be held at September 22, 2015 at 19:30 MSK. Traditionally, the members of the first division may take part in the contest out of competition.I (Vladislav Vishnevski) and igdor99(Igor Doroshev) are the authors of the round. We would like to please Zlobober (Maxim Akhmedov) for the assistance in the preparation of tasks, Delinur(Maria Belova) for translating statements into English, MikeMirzayanov(Mike Mirzayanov) for remarkable systems Codeforces and Polygon, as well as our friends daksenik(Dmitry Aksenik) and irevt(Ivan Revt) for their assistance in the round preparation. This is our first round, and, we hope, it won't be the last one!You will be proposed 5 tasks and 2 hours for their solution.The protagonist of the round is the parrot Kefa, who likes money and restaurants.Good luck and high rating!UPD: The scores — 750-1250-1500-2000-2500.UPD: Editorial!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20376",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 953
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces",
          "content": "580A - Kefa and First StepsNote, that if the array has two intersecting continuous non-decreasing subsequence, they can be combined into one. Therefore, you can just pass the array from left to right. If the current subsequence can be continued using the i-th element, then we do it, otherwise we start a new one. The answer is the maximum subsequence of all the found ones.Asymptotics — O(n).Solution580B - Kefa and CompanyAt first we sort all friends in money ascending order. Now the answer is some array subsegment. Next, we use the method of two pointers for finding the required subsegment.Asymptotics — O(n log n).Solution580C - Kefa and ParkLet's go down the tree from the root, supporting additional parameter k — the number of vertices in a row met with cats. If k exceeds m, then leave. Then the answer is the number of leaves, which we were able to reach.Asymptotics — O(n).Solution580D - Kefa and DishesA two-dimensional DP will be used to solve the problem. The first dimention is the mask of already taken dishes, and the second — the number of the last taken dish. We will go through all the zero bits of the current mask for the transitions. We will try to put the one in them, and then update the answer for a new mask. The answer will consist of the answer of the old mask, a dish value, which conforms to the added bit and the rule, that can be used. The final answer is the maximum of all the values of DP, where mask contains exactly m ones.Asymptotics — O(2n * n2). Solution580E - Kefa and WatchAt first, we calculate the hash for all line elements depending on their positions. That is, the hash of the number k, standing on the i-th position will be equal to gi * k, where g is the base of the hash. We construct the segment tree of sums, which support a group modification, for all hashes. Thus, we can perform queries for modification in O(log n). It remains to deal with the queries of the second type. Let us assume, that we want to process the query 2 l r d. Obviously, the substring from l to r have a d-period, if a substring from l + d to r is equal to substring from l to r - d. We can find out the sum of hashes at the subsegment with the help of the sums tree, so we can compare the two strings in O(log n).Asymptotics — O(m log n).Solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 580\\s*A"
          },
          "content_length": 2276
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 1",
          "code": "adj[x].push_back(y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 2",
          "code": "adj[x].push_back(y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 3",
          "code": "adj[x].push_back(y);\nadj[y].push_back(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 4",
          "code": "adj[x].push_back(y);\nadj[y].push_back(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 5",
          "code": "if statment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 6",
          "code": "Validator 'valid.exe' returns exit code 3 [FAIL Expected EOLN (stdin)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 7",
          "code": "Validator 'valid.exe' returns exit code 3 [FAIL Expected EOLN (stdin)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 8",
          "code": "for (int i = 0; i < 100000; ++i) {\n  printf(\"%d\", i + 1);\n  if (i + 1 != 100000)\n     printf(\" \");\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 9",
          "code": "for (int i = 0; i < 100000; ++i) {\n  printf(\"%d\", i + 1);\n  if (i + 1 != 100000)\n     printf(\" \");\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 10",
          "code": "std::lower_bound(a + i, a + n, a[i] + d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 11",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 1",
          "code": "}\n    //cout<<friend_temp<<endl;\n    if(friend_temp>friends)\n    {\n\n    friends=friend_temp;\n\n}\n    if(j==n)\n    break;\n\n}\ncout<<friends;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 2",
          "code": "}\n    //cout<<friend_temp<<endl;\n    if(friend_temp>friends)\n    {\n\n    friends=friend_temp;\n\n}\n    if(j==n)\n    break;\n\n}\ncout<<friends;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 3",
          "code": "`test case: 04`, my compiler output\n10\n1 2 3 4 1 2 3 4 5 6\n`output: 6`",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 4",
          "code": "`test case: 04`, my compiler output\n10\n1 2 3 4 1 2 3 4 5 6\n`output: 6`",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 5",
          "code": "Verdict: WRONG_ANSWER",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 6",
          "code": "wrong answer 1st lines differ - expected: '6', found: '7 '",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a;\n\n    if (type == \"random\") {\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"increasing\") {\n        a.resize(n);\n        a[0] = rnd.next(1, 1000000000);\n        for(int i = 1; i < n; ++i) {\n            int max_increment = 1000000000 - a[i - 1];\n            int delta = rnd.next(0, min(max_increment, 1000)); // limit increment to prevent overflow\n            a[i] = a[i - 1] + delta;\n        }\n    } else if (type == \"decreasing\") {\n        a.resize(n);\n        a[0] = rnd.next(1, 1000000000);\n        for(int i = 1; i < n; ++i) {\n            int max_decrement = a[i - 1] - 1;\n            int delta = rnd.next(1, min(max_decrement, 1000)); // limit decrement\n            a[i] = a[i - 1] - delta;\n            if (a[i] < 1) a[i] = 1;\n        }\n    } else if (type == \"constant\") {\n        int v = rnd.next(1, 1000000000);\n        a.resize(n, v);\n    } else if (type == \"sawtooth\") {\n        a.resize(n);\n        bool up = true;\n        int current = rnd.next(1, 1000000000 - 1000);\n        a[0] = current;\n        for(int i = 1; i < n; ++i) {\n            int delta = rnd.next(1, 1000);\n            if(up) {\n                current = min(current + delta, 1000000000);\n            } else {\n                current = max(current - delta, 1);\n            }\n            a[i] = current;\n            up = !up;\n        }\n    } else if (type == \"max_at_start\") {\n        a.resize(n);\n        int len = rnd.next(1, n);\n        a[0] = rnd.next(1, 1000000000 - 1000);\n        for(int i = 1; i < len; ++i) {\n            int delta = rnd.next(0, 1000);\n            a[i] = min(a[i - 1] + delta, 1000000000);\n        }\n        for(int i = len; i < n; ++i) {\n            a[i] = rnd.next(1, a[len - 1]);\n        }\n    } else if (type == \"max_at_end\") {\n        a.resize(n);\n        int len = rnd.next(1, n);\n        int offset = n - len;\n        for(int i = 0; i < offset; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n            if(i > 0 && a[i] >= a[i - 1]) a[i] = max(1, a[i - 1] - 1); // ensure decreasing\n        }\n        a[offset] = rnd.next(1, 1000000000 - 1000);\n        for(int i = offset + 1; i < n; ++i) {\n            int delta = rnd.next(0, 1000);\n            a[i] = min(a[i - 1] + delta, 1000000000);\n        }\n    } else if (type == \"multiple_max\") {\n        a.resize(n);\n        int len = max(1, rnd.next(1, n / 2));\n        for(int i = 0; i < n; ) {\n            int segment_len = min(len, n - i);\n            a[i] = rnd.next(1, 1000000000 - 1000);\n            for(int j = 1; j < segment_len; ++j) {\n                int delta = rnd.next(0, 1000);\n                a[i + j] = min(a[i + j - 1] + delta, 1000000000);\n            }\n            i += segment_len;\n            if(i < n) {\n                a[i] = rnd.next(1, 1000000000);\n                if(a[i] >= a[i - 1]) a[i] = max(1, a[i - 1] - 1); // ensure decreasing\n                i++;\n            }\n        }\n    } else if (type == \"max_in_middle\") {\n        a.resize(n);\n        int len = rnd.next(1, n);\n        int start = rnd.next(0, n - len);\n        for(int i = 0; i < start; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n            if(i > 0 && a[i] >= a[i - 1]) a[i] = max(1, a[i - 1] - 1); // ensure decreasing\n        }\n        a[start] = rnd.next(1, 1000000000 - 1000);\n        for(int i = start + 1; i < start + len; ++i) {\n            int delta = rnd.next(0, 1000);\n            a[i] = min(a[i - 1] + delta, 1000000000);\n        }\n        for(int i = start + len; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n            if(a[i] >= a[i - 1]) a[i] = max(1, a[i - 1] - 1); // ensure decreasing\n        }\n    } else if (type == \"single_element\") {\n        n = 1;\n        a.resize(1);\n        a[0] = rnd.next(1, 1000000000);\n    } else if (type == \"max_value_elements\") {\n        a.resize(n, 1000000000);\n    } else if (type == \"min_value_elements\") {\n        a.resize(n, 1);\n    } else {\n        // Default to random\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1 ? '\\n' : ' '));\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a;\n\n    if (type == \"random\") {\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"increasing\") {\n        a.resize(n);\n        a[0] = rnd.next(1, 1000000000);\n        for(int i = 1; i < n; ++i) {\n            int max_increment = 1000000000 - a[i - 1];\n            int delta = rnd.next(0, min(max_increment, 1000)); // limit increment to prevent overflow\n            a[i] = a[i - 1] + delta;\n        }\n    } else if (type == \"decreasing\") {\n        a.resize(n);\n        a[0] = rnd.next(1, 1000000000);\n        for(int i = 1; i < n; ++i) {\n            int max_decrement = a[i - 1] - 1;\n            int delta = rnd.next(1, min(max_decrement, 1000)); // limit decrement\n            a[i] = a[i - 1] - delta;\n            if (a[i] < 1) a[i] = 1;\n        }\n    } else if (type == \"constant\") {\n        int v = rnd.next(1, 1000000000);\n        a.resize(n, v);\n    } else if (type == \"sawtooth\") {\n        a.resize(n);\n        bool up = true;\n        int current = rnd.next(1, 1000000000 - 1000);\n        a[0] = current;\n        for(int i = 1; i < n; ++i) {\n            int delta = rnd.next(1, 1000);\n            if(up) {\n                current = min(current + delta, 1000000000);\n            } else {\n                current = max(current - delta, 1);\n            }\n            a[i] = current;\n            up = !up;\n        }\n    } else if (type == \"max_at_start\") {\n        a.resize(n);\n        int len = rnd.next(1, n);\n        a[0] = rnd.next(1, 1000000000 - 1000);\n        for(int i = 1; i < len; ++i) {\n            int delta = rnd.next(0, 1000);\n            a[i] = min(a[i - 1] + delta, 1000000000);\n        }\n        for(int i = len; i < n; ++i) {\n            a[i] = rnd.next(1, a[len - 1]);\n        }\n    } else if (type == \"max_at_end\") {\n        a.resize(n);\n        int len = rnd.next(1, n);\n        int offset = n - len;\n        for(int i = 0; i < offset; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n            if(i > 0 && a[i] >= a[i - 1]) a[i] = max(1, a[i - 1] - 1); // ensure decreasing\n        }\n        a[offset] = rnd.next(1, 1000000000 - 1000);\n        for(int i = offset + 1; i < n; ++i) {\n            int delta = rnd.next(0, 1000);\n            a[i] = min(a[i - 1] + delta, 1000000000);\n        }\n    } else if (type == \"multiple_max\") {\n        a.resize(n);\n        int len = max(1, rnd.next(1, n / 2));\n        for(int i = 0; i < n; ) {\n            int segment_len = min(len, n - i);\n            a[i] = rnd.next(1, 1000000000 - 1000);\n            for(int j = 1; j < segment_len; ++j) {\n                int delta = rnd.next(0, 1000);\n                a[i + j] = min(a[i + j - 1] + delta, 1000000000);\n            }\n            i += segment_len;\n            if(i < n) {\n                a[i] = rnd.next(1, 1000000000);\n                if(a[i] >= a[i - 1]) a[i] = max(1, a[i - 1] - 1); // ensure decreasing\n                i++;\n            }\n        }\n    } else if (type == \"max_in_middle\") {\n        a.resize(n);\n        int len = rnd.next(1, n);\n        int start = rnd.next(0, n - len);\n        for(int i = 0; i < start; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n            if(i > 0 && a[i] >= a[i - 1]) a[i] = max(1, a[i - 1] - 1); // ensure decreasing\n        }\n        a[start] = rnd.next(1, 1000000000 - 1000);\n        for(int i = start + 1; i < start + len; ++i) {\n            int delta = rnd.next(0, 1000);\n            a[i] = min(a[i - 1] + delta, 1000000000);\n        }\n        for(int i = start + len; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n            if(a[i] >= a[i - 1]) a[i] = max(1, a[i - 1] - 1); // ensure decreasing\n        }\n    } else if (type == \"single_element\") {\n        n = 1;\n        a.resize(1);\n        a[0] = rnd.next(1, 1000000000);\n    } else if (type == \"max_value_elements\") {\n        a.resize(n, 1000000000);\n    } else if (type == \"min_value_elements\") {\n        a.resize(n, 1);\n    } else {\n        // Default to random\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1 ? '\\n' : ' '));\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type single_element\n\n./gen -n 10 -type random\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type constant\n./gen -n 10 -type sawtooth\n./gen -n 10 -type max_at_start\n./gen -n 10 -type max_at_end\n./gen -n 10 -type multiple_max\n./gen -n 10 -type max_in_middle\n./gen -n 10 -type max_value_elements\n./gen -n 10 -type min_value_elements\n\n./gen -n 100 -type random\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type constant\n./gen -n 100 -type sawtooth\n./gen -n 100 -type max_at_start\n./gen -n 100 -type max_at_end\n./gen -n 100 -type multiple_max\n./gen -n 100 -type max_in_middle\n./gen -n 100 -type max_value_elements\n./gen -n 100 -type min_value_elements\n\n./gen -n 1000 -type random\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type constant\n./gen -n 1000 -type sawtooth\n./gen -n 1000 -type max_at_start\n./gen -n 1000 -type max_at_end\n./gen -n 1000 -type multiple_max\n./gen -n 1000 -type max_in_middle\n./gen -n 1000 -type max_value_elements\n./gen -n 1000 -type min_value_elements\n\n./gen -n 100000 -type random\n./gen -n 100000 -type increasing\n./gen -n 100000 -type decreasing\n./gen -n 100000 -type constant\n./gen -n 100000 -type sawtooth\n./gen -n 100000 -type max_at_start\n./gen -n 100000 -type max_at_end\n./gen -n 100000 -type multiple_max\n./gen -n 100000 -type max_in_middle\n./gen -n 100000 -type max_value_elements\n./gen -n 100000 -type min_value_elements\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:37.173370",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "580/B",
      "title": "B. Kefa and Company",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two space-separated integers, n and d (1 ≤ n ≤ 105, ) — the number of Kefa's friends and the minimum difference between the amount of money in order to feel poor, respectively.Next n lines contain the descriptions of Kefa's friends, the (i + 1)-th line contains the description of the i-th friend of type mi, si (0 ≤ mi, si ≤ 109) — the amount of money and the friendship factor, respectively.",
      "output_spec": "OutputPrint the maximum total friendship factir that can be reached.",
      "sample_tests": "ExamplesInputCopy4 575 50 100150 2075 1OutputCopy100InputCopy5 1000 711 3299 1046 887 54OutputCopy111",
      "description": "B. Kefa and Company\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains two space-separated integers, n and d (1 ≤ n ≤ 105, ) — the number of Kefa's friends and the minimum difference between the amount of money in order to feel poor, respectively.Next n lines contain the descriptions of Kefa's friends, the (i + 1)-th line contains the description of the i-th friend of type mi, si (0 ≤ mi, si ≤ 109) — the amount of money and the friendship factor, respectively.\n\nOutputPrint the maximum total friendship factir that can be reached.\n\nInputCopy4 575 50 100150 2075 1OutputCopy100InputCopy5 1000 711 3299 1046 887 54OutputCopy111\n\nInputCopy4 575 50 100150 2075 1\n\nOutputCopy100\n\nInputCopy5 1000 711 3299 1046 887 54\n\nOutputCopy111\n\nNoteIn the first sample test the most profitable strategy is to form a company from only the second friend. At all other variants the total degree of friendship will be worse.In the second sample test we can take all the friends.",
      "solutions": [
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces",
          "content": "Good day to everybody!The next round for the participants of the second division will be held at September 22, 2015 at 19:30 MSK. Traditionally, the members of the first division may take part in the contest out of competition.I (Vladislav Vishnevski) and igdor99(Igor Doroshev) are the authors of the round. We would like to please Zlobober (Maxim Akhmedov) for the assistance in the preparation of tasks, Delinur(Maria Belova) for translating statements into English, MikeMirzayanov(Mike Mirzayanov) for remarkable systems Codeforces and Polygon, as well as our friends daksenik(Dmitry Aksenik) and irevt(Ivan Revt) for their assistance in the round preparation. This is our first round, and, we hope, it won't be the last one!You will be proposed 5 tasks and 2 hours for their solution.The protagonist of the round is the parrot Kefa, who likes money and restaurants.Good luck and high rating!UPD: The scores — 750-1250-1500-2000-2500.UPD: Editorial!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20376",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 953
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces",
          "content": "580A - Kefa and First StepsNote, that if the array has two intersecting continuous non-decreasing subsequence, they can be combined into one. Therefore, you can just pass the array from left to right. If the current subsequence can be continued using the i-th element, then we do it, otherwise we start a new one. The answer is the maximum subsequence of all the found ones.Asymptotics — O(n).Solution580B - Kefa and CompanyAt first we sort all friends in money ascending order. Now the answer is some array subsegment. Next, we use the method of two pointers for finding the required subsegment.Asymptotics — O(n log n).Solution580C - Kefa and ParkLet's go down the tree from the root, supporting additional parameter k — the number of vertices in a row met with cats. If k exceeds m, then leave. Then the answer is the number of leaves, which we were able to reach.Asymptotics — O(n).Solution580D - Kefa and DishesA two-dimensional DP will be used to solve the problem. The first dimention is the mask of already taken dishes, and the second — the number of the last taken dish. We will go through all the zero bits of the current mask for the transitions. We will try to put the one in them, and then update the answer for a new mask. The answer will consist of the answer of the old mask, a dish value, which conforms to the added bit and the rule, that can be used. The final answer is the maximum of all the values of DP, where mask contains exactly m ones.Asymptotics — O(2n * n2). Solution580E - Kefa and WatchAt first, we calculate the hash for all line elements depending on their positions. That is, the hash of the number k, standing on the i-th position will be equal to gi * k, where g is the base of the hash. We construct the segment tree of sums, which support a group modification, for all hashes. Thus, we can perform queries for modification in O(log n). It remains to deal with the queries of the second type. Let us assume, that we want to process the query 2 l r d. Obviously, the substring from l to r have a d-period, if a substring from l + d to r is equal to substring from l to r - d. We can find out the sum of hashes at the subsegment with the help of the sums tree, so we can compare the two strings in O(log n).Asymptotics — O(m log n).Solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 580\\s*B"
          },
          "content_length": 2276
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 1",
          "code": "adj[x].push_back(y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 2",
          "code": "adj[x].push_back(y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 3",
          "code": "adj[x].push_back(y);\nadj[y].push_back(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 4",
          "code": "adj[x].push_back(y);\nadj[y].push_back(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 5",
          "code": "if statment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 6",
          "code": "Validator 'valid.exe' returns exit code 3 [FAIL Expected EOLN (stdin)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 7",
          "code": "Validator 'valid.exe' returns exit code 3 [FAIL Expected EOLN (stdin)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 8",
          "code": "for (int i = 0; i < 100000; ++i) {\n  printf(\"%d\", i + 1);\n  if (i + 1 != 100000)\n     printf(\" \");\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 9",
          "code": "for (int i = 0; i < 100000; ++i) {\n  printf(\"%d\", i + 1);\n  if (i + 1 != 100000)\n     printf(\" \");\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 10",
          "code": "std::lower_bound(a + i, a + n, a[i] + d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 11",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 1",
          "code": "}\n    //cout<<friend_temp<<endl;\n    if(friend_temp>friends)\n    {\n\n    friends=friend_temp;\n\n}\n    if(j==n)\n    break;\n\n}\ncout<<friends;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 2",
          "code": "}\n    //cout<<friend_temp<<endl;\n    if(friend_temp>friends)\n    {\n\n    friends=friend_temp;\n\n}\n    if(j==n)\n    break;\n\n}\ncout<<friends;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 3",
          "code": "`test case: 04`, my compiler output\n10\n1 2 3 4 1 2 3 4 5 6\n`output: 6`",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 4",
          "code": "`test case: 04`, my compiler output\n10\n1 2 3 4 1 2 3 4 5 6\n`output: 6`",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 5",
          "code": "Verdict: WRONG_ANSWER",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 6",
          "code": "wrong answer 1st lines differ - expected: '6', found: '7 '",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    long long d = inf.readLong(1LL, 1000000000000000000LL, \"d\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        long long mi = inf.readLong(0LL, 1000000000LL, \"mi\");\n        inf.readSpace();\n        long long si = inf.readLong(0LL, 1000000000LL, \"si\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    long long d = inf.readLong(1LL, 1000000000000000000LL, \"d\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        long long mi = inf.readLong(0LL, 1000000000LL, \"mi\");\n        inf.readSpace();\n        long long si = inf.readLong(0LL, 1000000000LL, \"si\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    long long d = inf.readLong(1LL, 1000000000000000000LL, \"d\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        long long mi = inf.readLong(0LL, 1000000000LL, \"mi\");\n        inf.readSpace();\n        long long si = inf.readLong(0LL, 1000000000LL, \"si\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> mi;\n    vector<int> si;\n\n    if (type == \"max_n\") {\n        n = int(1e5);\n    } else if (type == \"min_n\") {\n        n = 1;\n    }\n\n    mi.resize(n);\n    si.resize(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            mi[i] = rnd.next(0, int(1e9));\n            si[i] = rnd.next(0, int(1e9));\n        }\n    } else if (type == \"same_mi\") {\n        int m = rnd.next(0, int(1e9));\n        for(int i = 0; i < n; ++i) {\n            mi[i] = m;\n            si[i] = rnd.next(0, int(1e9));\n        }\n    } else if (type == \"sequential_mi\") {\n        int m0 = rnd.next(0, int(1e9) - n);\n        for(int i = 0; i < n; ++i) {\n            mi[i] = m0 + i;\n            si[i] = rnd.next(0, int(1e9));\n        }\n    } else if (type == \"reverse_sequential_mi\") {\n        int m0 = rnd.next(n, int(1e9));\n        for(int i = 0; i < n; ++i) {\n            mi[i] = m0 - i;\n            si[i] = rnd.next(0, int(1e9));\n        }\n    } else if (type == \"max_si\") {\n        for(int i = 0; i < n; ++i) {\n            mi[i] = rnd.next(0, int(1e9));\n            si[i] = int(1e9);\n        }\n    } else if (type == \"min_si\") {\n        for(int i = 0; i < n; ++i) {\n            mi[i] = rnd.next(0, int(1e9));\n            si[i] = 0;\n        }\n    } else if (type == \"mi_equals_si\") {\n        for(int i = 0; i < n; ++i) {\n            int m = rnd.next(0, int(1e9));\n            mi[i] = m;\n            si[i] = m;\n        }\n    } else {\n        // default random\n        for(int i = 0; i < n; ++i) {\n            mi[i] = rnd.next(0, int(1e9));\n            si[i] = rnd.next(0, int(1e9));\n        }\n    }\n\n    printf(\"%d %d\\n\", n, d);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", mi[i], si[i]);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> mi;\n    vector<int> si;\n\n    if (type == \"max_n\") {\n        n = int(1e5);\n    } else if (type == \"min_n\") {\n        n = 1;\n    }\n\n    mi.resize(n);\n    si.resize(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            mi[i] = rnd.next(0, int(1e9));\n            si[i] = rnd.next(0, int(1e9));\n        }\n    } else if (type == \"same_mi\") {\n        int m = rnd.next(0, int(1e9));\n        for(int i = 0; i < n; ++i) {\n            mi[i] = m;\n            si[i] = rnd.next(0, int(1e9));\n        }\n    } else if (type == \"sequential_mi\") {\n        int m0 = rnd.next(0, int(1e9) - n);\n        for(int i = 0; i < n; ++i) {\n            mi[i] = m0 + i;\n            si[i] = rnd.next(0, int(1e9));\n        }\n    } else if (type == \"reverse_sequential_mi\") {\n        int m0 = rnd.next(n, int(1e9));\n        for(int i = 0; i < n; ++i) {\n            mi[i] = m0 - i;\n            si[i] = rnd.next(0, int(1e9));\n        }\n    } else if (type == \"max_si\") {\n        for(int i = 0; i < n; ++i) {\n            mi[i] = rnd.next(0, int(1e9));\n            si[i] = int(1e9);\n        }\n    } else if (type == \"min_si\") {\n        for(int i = 0; i < n; ++i) {\n            mi[i] = rnd.next(0, int(1e9));\n            si[i] = 0;\n        }\n    } else if (type == \"mi_equals_si\") {\n        for(int i = 0; i < n; ++i) {\n            int m = rnd.next(0, int(1e9));\n            mi[i] = m;\n            si[i] = m;\n        }\n    } else {\n        // default random\n        for(int i = 0; i < n; ++i) {\n            mi[i] = rnd.next(0, int(1e9));\n            si[i] = rnd.next(0, int(1e9));\n        }\n    }\n\n    printf(\"%d %d\\n\", n, d);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", mi[i], si[i]);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -d 5 -type random\n./gen -n 10 -d 5 -type same_mi\n./gen -n 10 -d 5 -type sequential_mi\n./gen -n 10 -d 5 -type reverse_sequential_mi\n./gen -n 10 -d 5 -type mi_equals_si\n./gen -n 10 -d 5 -type max_si\n./gen -n 10 -d 5 -type min_si\n\n./gen -n 100 -d 50 -type random\n./gen -n 100 -d 0 -type random\n./gen -n 100 -d 1 -type random\n./gen -n 100 -d 1000000000 -type random\n\n./gen -n 1000 -d 500 -type random\n./gen -n 1000 -d 500 -type same_mi\n./gen -n 1000 -d 500 -type sequential_mi\n./gen -n 1000 -d 500 -type reverse_sequential_mi\n./gen -n 1000 -d 500 -type mi_equals_si\n\n./gen -n 10000 -d 10000 -type random\n./gen -n 10000 -d 10000 -type same_mi\n./gen -n 10000 -d 10000 -type sequential_mi\n./gen -n 10000 -d 10000 -type mi_equals_si\n\n./gen -n 100000 -d 1000000 -type random\n./gen -n 100000 -d 1000000 -type sequential_mi\n./gen -n 100000 -d 1000000 -type reverse_sequential_mi\n./gen -n 100000 -d 1000000 -type mi_equals_si\n\n./gen -n 100000 -d 0 -type random\n\n./gen -n 50000 -d 1 -type random\n./gen -n 50000 -d 1 -type same_mi\n./gen -n 50000 -d 1 -type sequential_mi\n\n./gen -n 100000 -d 1000000000 -type random\n./gen -n 100000 -d 999999999 -type random\n./gen -n 100000 -d 1000000000 -type mi_equals_si\n\n./gen -n 1 -d 1 -type min_n\n./gen -n 100000 -d 1 -type max_n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:39.184965",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "580/C",
      "title": "C. Kefa and Park",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers, n and m (2 ≤ n ≤ 105, 1 ≤ m ≤ n) — the number of vertices of the tree and the maximum number of consecutive vertices with cats that is still ok for Kefa.The second line contains n integers a1, a2, ..., an, where each ai either equals to 0 (then vertex i has no cat), or equals to 1 (then vertex i has a cat).Next n - 1 lines contains the edges of the tree in the format \"xi yi\" (without the quotes) (1 ≤ xi, yi ≤ n, xi ≠ yi), where xi and yi are the vertices of the tree, connected by an edge. It is guaranteed that the given set of edges specifies a tree.",
      "output_spec": "OutputA single integer — the number of distinct leaves of a tree the path to which from Kefa's home contains at most m consecutive vertices with cats.",
      "sample_tests": "ExamplesInputCopy4 11 1 0 01 21 31 4OutputCopy2InputCopy7 11 0 1 1 0 0 01 21 32 42 53 63 7OutputCopy2",
      "description": "C. Kefa and Park\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers, n and m (2 ≤ n ≤ 105, 1 ≤ m ≤ n) — the number of vertices of the tree and the maximum number of consecutive vertices with cats that is still ok for Kefa.The second line contains n integers a1, a2, ..., an, where each ai either equals to 0 (then vertex i has no cat), or equals to 1 (then vertex i has a cat).Next n - 1 lines contains the edges of the tree in the format \"xi yi\" (without the quotes) (1 ≤ xi, yi ≤ n, xi ≠ yi), where xi and yi are the vertices of the tree, connected by an edge. It is guaranteed that the given set of edges specifies a tree.\n\nOutputA single integer — the number of distinct leaves of a tree the path to which from Kefa's home contains at most m consecutive vertices with cats.\n\nInputCopy4 11 1 0 01 21 31 4OutputCopy2InputCopy7 11 0 1 1 0 0 01 21 32 42 53 63 7OutputCopy2\n\nInputCopy4 11 1 0 01 21 31 4\n\nOutputCopy2\n\nInputCopy7 11 0 1 1 0 0 01 21 32 42 53 63 7\n\nOutputCopy2\n\nNoteLet us remind you that a tree is a connected graph on n vertices and n - 1 edge. A rooted tree is a tree with a special vertex called root. In a rooted tree among any two vertices connected by an edge, one vertex is a parent (the one closer to the root), and the other one is a child. A vertex is called a leaf, if it has no children.Note to the first sample test:  The vertices containing cats are marked red. The restaurants are at vertices 2, 3, 4. Kefa can't go only to the restaurant located at vertex 2.Note to the second sample test:  The restaurants are located at vertices 4, 5, 6, 7. Kefa can't go to restaurants 6, 7.",
      "solutions": [
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces",
          "content": "Good day to everybody!The next round for the participants of the second division will be held at September 22, 2015 at 19:30 MSK. Traditionally, the members of the first division may take part in the contest out of competition.I (Vladislav Vishnevski) and igdor99(Igor Doroshev) are the authors of the round. We would like to please Zlobober (Maxim Akhmedov) for the assistance in the preparation of tasks, Delinur(Maria Belova) for translating statements into English, MikeMirzayanov(Mike Mirzayanov) for remarkable systems Codeforces and Polygon, as well as our friends daksenik(Dmitry Aksenik) and irevt(Ivan Revt) for their assistance in the round preparation. This is our first round, and, we hope, it won't be the last one!You will be proposed 5 tasks and 2 hours for their solution.The protagonist of the round is the parrot Kefa, who likes money and restaurants.Good luck and high rating!UPD: The scores — 750-1250-1500-2000-2500.UPD: Editorial!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20376",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 953
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces",
          "content": "580A - Kefa and First StepsNote, that if the array has two intersecting continuous non-decreasing subsequence, they can be combined into one. Therefore, you can just pass the array from left to right. If the current subsequence can be continued using the i-th element, then we do it, otherwise we start a new one. The answer is the maximum subsequence of all the found ones.Asymptotics — O(n).Solution580B - Kefa and CompanyAt first we sort all friends in money ascending order. Now the answer is some array subsegment. Next, we use the method of two pointers for finding the required subsegment.Asymptotics — O(n log n).Solution580C - Kefa and ParkLet's go down the tree from the root, supporting additional parameter k — the number of vertices in a row met with cats. If k exceeds m, then leave. Then the answer is the number of leaves, which we were able to reach.Asymptotics — O(n).Solution580D - Kefa and DishesA two-dimensional DP will be used to solve the problem. The first dimention is the mask of already taken dishes, and the second — the number of the last taken dish. We will go through all the zero bits of the current mask for the transitions. We will try to put the one in them, and then update the answer for a new mask. The answer will consist of the answer of the old mask, a dish value, which conforms to the added bit and the rule, that can be used. The final answer is the maximum of all the values of DP, where mask contains exactly m ones.Asymptotics — O(2n * n2). Solution580E - Kefa and WatchAt first, we calculate the hash for all line elements depending on their positions. That is, the hash of the number k, standing on the i-th position will be equal to gi * k, where g is the base of the hash. We construct the segment tree of sums, which support a group modification, for all hashes. Thus, we can perform queries for modification in O(log n). It remains to deal with the queries of the second type. Let us assume, that we want to process the query 2 l r d. Obviously, the substring from l to r have a d-period, if a substring from l + d to r is equal to substring from l to r - d. We can find out the sum of hashes at the subsegment with the help of the sums tree, so we can compare the two strings in O(log n).Asymptotics — O(m log n).Solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 580\\s*C"
          },
          "content_length": 2276
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 1",
          "code": "adj[x].push_back(y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 2",
          "code": "adj[x].push_back(y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 3",
          "code": "adj[x].push_back(y);\nadj[y].push_back(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 4",
          "code": "adj[x].push_back(y);\nadj[y].push_back(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 5",
          "code": "if statment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 6",
          "code": "Validator 'valid.exe' returns exit code 3 [FAIL Expected EOLN (stdin)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 7",
          "code": "Validator 'valid.exe' returns exit code 3 [FAIL Expected EOLN (stdin)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 8",
          "code": "for (int i = 0; i < 100000; ++i) {\n  printf(\"%d\", i + 1);\n  if (i + 1 != 100000)\n     printf(\" \");\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 9",
          "code": "for (int i = 0; i < 100000; ++i) {\n  printf(\"%d\", i + 1);\n  if (i + 1 != 100000)\n     printf(\" \");\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 10",
          "code": "std::lower_bound(a + i, a + n, a[i] + d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 11",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 1",
          "code": "}\n    //cout<<friend_temp<<endl;\n    if(friend_temp>friends)\n    {\n\n    friends=friend_temp;\n\n}\n    if(j==n)\n    break;\n\n}\ncout<<friends;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 2",
          "code": "}\n    //cout<<friend_temp<<endl;\n    if(friend_temp>friends)\n    {\n\n    friends=friend_temp;\n\n}\n    if(j==n)\n    break;\n\n}\ncout<<friends;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 3",
          "code": "`test case: 04`, my compiler output\n10\n1 2 3 4 1 2 3 4 5 6\n`output: 6`",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 4",
          "code": "`test case: 04`, my compiler output\n10\n1 2 3 4 1 2 3 4 5 6\n`output: 6`",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 5",
          "code": "Verdict: WRONG_ANSWER",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 6",
          "code": "wrong answer 1st lines differ - expected: '6', found: '7 '",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nint parent[MAXN];\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    parent[find(u)] = find(v);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    int components = n;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n        ensuref(xi != yi, \"Edge cannot connect vertex to itself xi == yi == %d\", xi);\n        int pu = find(xi), pv = find(yi);\n        if (pu == pv)\n            ensuref(false, \"Cycle detected between vertices %d and %d\", xi, yi);\n        else {\n            parent[pu] = pv;\n            components--;\n        }\n    }\n\n    ensuref(components == 1, \"The graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nint parent[MAXN];\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    parent[find(u)] = find(v);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    int components = n;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n        ensuref(xi != yi, \"Edge cannot connect vertex to itself xi == yi == %d\", xi);\n        int pu = find(xi), pv = find(yi);\n        if (pu == pv)\n            ensuref(false, \"Cycle detected between vertices %d and %d\", xi, yi);\n        else {\n            parent[pu] = pv;\n            components--;\n        }\n    }\n\n    ensuref(components == 1, \"The graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nint parent[MAXN];\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    parent[find(u)] = find(v);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    int components = n;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n        ensuref(xi != yi, \"Edge cannot connect vertex to itself xi == yi == %d\", xi);\n        int pu = find(xi), pv = find(yi);\n        if (pu == pv)\n            ensuref(false, \"Cycle detected between vertices %d and %d\", xi, yi);\n        else {\n            parent[pu] = pv;\n            components--;\n        }\n    }\n\n    ensuref(components == 1, \"The graph is not connected\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    string cat = opt<string>(\"cat\", \"random\");\n\n    // Build tree\n    vector<int> parent(n + 1); // parent[i] is parent of node i\n    parent[1] = 0; // root has no parent\n    if (type == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n        }\n    } else if (type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n        }\n    } else if (type == \"binary\") {\n        // Build a balanced binary tree\n        queue<int> q;\n        q.push(1);\n        int node = 2;\n        while (node <= n && !q.empty()) {\n            int u = q.front(); q.pop();\n            for (int i = 0; i < 2 && node <= n; ++i) {\n                parent[node] = u;\n                q.push(node);\n                node++;\n            }\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n        }\n    }\n\n    // Assign cats\n    vector<int> has_cat(n + 1); // 1-indexed\n    if (cat == \"none\") {\n        // All zeros\n    } else if (cat == \"all\") {\n        for (int i = 1; i <= n; ++i) has_cat[i] = 1;\n    } else if (cat == \"random\") {\n        for (int i = 1; i <= n; ++i) has_cat[i] = rnd.next(0, 1);\n    } else if (cat == \"alternating\") {\n        for (int i = 1; i <= n; ++i) has_cat[i] = (i % 2);\n    } else if (cat == \"max_consecutive\") {\n        // Place cats to maximize the consecutive cats\n        // For example, set m nodes starting from root as cats\n        int consecutive = min(m, n);\n        int cur = 1;\n        while (consecutive > 0 && cur <= n) {\n            has_cat[cur] = 1;\n            // Go to any child\n            bool found = false;\n            for (int i = 2; i <= n; ++i) {\n                if (parent[i] == cur) {\n                    cur = i;\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) break; // No more children\n            consecutive--;\n        }\n    } else if (cat == \"min_consecutive\") {\n        // No two consecutive cats\n        function<void(int, int)> dfs = [&](int u, int from_cat) {\n            has_cat[u] = from_cat ^ 1;\n            for (int v = 2; v <= n; ++v) {\n                if (parent[v] == u) {\n                    dfs(v, has_cat[u]);\n                }\n            }\n        };\n        dfs(1, 0);\n    }\n\n    // Now shuffle node labels except the root\n    vector<int> permutation(n + 1);\n    for (int i = 1; i <= n; ++i) permutation[i] = i;\n    shuffle(permutation.begin() + 2, permutation.end());\n\n    // Adjust parents according to permutation\n    vector<int> new_parent(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        int u = permutation[i];\n        if (parent[i] != 0) {\n            int p = permutation[parent[i]];\n            new_parent[u] = p;\n        } else {\n            new_parent[u] = 0; // Root\n        }\n    }\n\n    // Build edge list\n    vector<pair<int, int>> edges;\n    for (int i = 1; i <= n; ++i) {\n        if (new_parent[i] != 0) {\n            edges.push_back({i, new_parent[i]});\n        }\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Randomly swap ends\n    for (auto& e : edges) {\n        if (rnd.next(0, 1)) swap(e.first, e.second);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output cats according to new labels\n    vector<int> new_has_cat(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        int u = permutation[i];\n        new_has_cat[u] = has_cat[i];\n    }\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", new_has_cat[i]);\n        if (i < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    string cat = opt<string>(\"cat\", \"random\");\n\n    // Build tree\n    vector<int> parent(n + 1); // parent[i] is parent of node i\n    parent[1] = 0; // root has no parent\n    if (type == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n        }\n    } else if (type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n        }\n    } else if (type == \"binary\") {\n        // Build a balanced binary tree\n        queue<int> q;\n        q.push(1);\n        int node = 2;\n        while (node <= n && !q.empty()) {\n            int u = q.front(); q.pop();\n            for (int i = 0; i < 2 && node <= n; ++i) {\n                parent[node] = u;\n                q.push(node);\n                node++;\n            }\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n        }\n    }\n\n    // Assign cats\n    vector<int> has_cat(n + 1); // 1-indexed\n    if (cat == \"none\") {\n        // All zeros\n    } else if (cat == \"all\") {\n        for (int i = 1; i <= n; ++i) has_cat[i] = 1;\n    } else if (cat == \"random\") {\n        for (int i = 1; i <= n; ++i) has_cat[i] = rnd.next(0, 1);\n    } else if (cat == \"alternating\") {\n        for (int i = 1; i <= n; ++i) has_cat[i] = (i % 2);\n    } else if (cat == \"max_consecutive\") {\n        // Place cats to maximize the consecutive cats\n        // For example, set m nodes starting from root as cats\n        int consecutive = min(m, n);\n        int cur = 1;\n        while (consecutive > 0 && cur <= n) {\n            has_cat[cur] = 1;\n            // Go to any child\n            bool found = false;\n            for (int i = 2; i <= n; ++i) {\n                if (parent[i] == cur) {\n                    cur = i;\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) break; // No more children\n            consecutive--;\n        }\n    } else if (cat == \"min_consecutive\") {\n        // No two consecutive cats\n        function<void(int, int)> dfs = [&](int u, int from_cat) {\n            has_cat[u] = from_cat ^ 1;\n            for (int v = 2; v <= n; ++v) {\n                if (parent[v] == u) {\n                    dfs(v, has_cat[u]);\n                }\n            }\n        };\n        dfs(1, 0);\n    }\n\n    // Now shuffle node labels except the root\n    vector<int> permutation(n + 1);\n    for (int i = 1; i <= n; ++i) permutation[i] = i;\n    shuffle(permutation.begin() + 2, permutation.end());\n\n    // Adjust parents according to permutation\n    vector<int> new_parent(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        int u = permutation[i];\n        if (parent[i] != 0) {\n            int p = permutation[parent[i]];\n            new_parent[u] = p;\n        } else {\n            new_parent[u] = 0; // Root\n        }\n    }\n\n    // Build edge list\n    vector<pair<int, int>> edges;\n    for (int i = 1; i <= n; ++i) {\n        if (new_parent[i] != 0) {\n            edges.push_back({i, new_parent[i]});\n        }\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Randomly swap ends\n    for (auto& e : edges) {\n        if (rnd.next(0, 1)) swap(e.first, e.second);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output cats according to new labels\n    vector<int> new_has_cat(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        int u = permutation[i];\n        new_has_cat[u] = has_cat[i];\n    }\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d\", new_has_cat[i]);\n        if (i < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n\n./gen -n 2 -m 1 -type chain -cat all\n./gen -n 2 -m 0 -type chain -cat none\n./gen -n 2 -m 1 -type star -cat random\n\n# Moderate n\n./gen -n 10 -m 1 -type chain -cat alternating\n./gen -n 10 -m 2 -type star -cat random\n./gen -n 10 -m 5 -type binary -cat max_consecutive\n./gen -n 10 -m 0 -type random -cat all\n./gen -n 10 -m 10 -type random -cat none\n\n# Larger n\n./gen -n 1000 -m 5 -type binary -cat random\n./gen -n 1000 -m 0 -type chain -cat all\n./gen -n 1000 -m 1000 -type star -cat none\n./gen -n 1000 -m 500 -type random -cat random\n\n# Edge cases\n./gen -n 100000 -m 1 -type chain -cat max_consecutive\n./gen -n 100000 -m 0 -type chain -cat all\n./gen -n 100000 -m 100000 -type chain -cat none\n./gen -n 100000 -m 50000 -type random -cat random\n\n# Special cats\n./gen -n 50000 -m 1 -type binary -cat min_consecutive\n./gen -n 50000 -m 0 -type binary -cat all\n./gen -n 50000 -m 50000 -type binary -cat none\n\n# Random trees\n./gen -n 100000 -m 1000 -type random -cat random\n./gen -n 100000 -m 0 -type random -cat all\n./gen -n 100000 -m 100000 -type random -cat none\n\n# All nodes are cats\n./gen -n 100000 -m 0 -type random -cat all\n\n# Alternating cats\n./gen -n 99999 -m 2 -type chain -cat alternating\n\n# Max consecutive cats\n./gen -n 100000 -m 0 -type random -cat max_consecutive\n\n# Min consecutive cats\n./gen -n 100000 -m 1 -type random -cat min_consecutive\n\n# Small m\n./gen -n 100000 -m 1 -type random -cat random\n\n# Large m\n./gen -n 100000 -m 100000 -type random -cat random\n\n# m = n / 2\n./gen -n 100000 -m 50000 -type random -cat random\n\n# m = 1\n./gen -n 100000 -m 1 -type random -cat random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:41.519293",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "580/D",
      "title": "D. Kefa and Dishes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains three space-separated numbers, n, m and k (1 ≤ m ≤ n ≤ 18, 0 ≤ k ≤ n * (n - 1)) — the number of dishes on the menu, the number of portions Kefa needs to eat to get full and the number of eating rules.The second line contains n space-separated numbers ai, (0 ≤ ai ≤ 109) — the satisfaction he gets from the i-th dish.Next k lines contain the rules. The i-th rule is described by the three numbers xi, yi and ci (1 ≤ xi, yi ≤ n, 0 ≤ ci ≤ 109). That means that if you eat dish xi right before dish yi, then the Kefa's satisfaction increases by ci. It is guaranteed that there are no such pairs of indexes i and j (1 ≤ i < j ≤ k), that xi = xj and yi = yj.",
      "output_spec": "OutputIn the single line of the output print the maximum satisfaction that Kefa can get from going to the restaurant.",
      "sample_tests": "ExamplesInputCopy2 2 11 12 1 1OutputCopy3InputCopy4 3 21 2 3 42 1 53 4 2OutputCopy12",
      "description": "D. Kefa and Dishes\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains three space-separated numbers, n, m and k (1 ≤ m ≤ n ≤ 18, 0 ≤ k ≤ n * (n - 1)) — the number of dishes on the menu, the number of portions Kefa needs to eat to get full and the number of eating rules.The second line contains n space-separated numbers ai, (0 ≤ ai ≤ 109) — the satisfaction he gets from the i-th dish.Next k lines contain the rules. The i-th rule is described by the three numbers xi, yi and ci (1 ≤ xi, yi ≤ n, 0 ≤ ci ≤ 109). That means that if you eat dish xi right before dish yi, then the Kefa's satisfaction increases by ci. It is guaranteed that there are no such pairs of indexes i and j (1 ≤ i < j ≤ k), that xi = xj and yi = yj.\n\nOutputIn the single line of the output print the maximum satisfaction that Kefa can get from going to the restaurant.\n\nInputCopy2 2 11 12 1 1OutputCopy3InputCopy4 3 21 2 3 42 1 53 4 2OutputCopy12\n\nInputCopy2 2 11 12 1 1\n\nOutputCopy3\n\nInputCopy4 3 21 2 3 42 1 53 4 2\n\nOutputCopy12\n\nNoteIn the first sample it is best to first eat the second dish, then the first one. Then we get one unit of satisfaction for each dish and plus one more for the rule.In the second test the fitting sequences of choice are 4 2 1 or 2 1 4. In both cases we get satisfaction 7 for dishes and also, if we fulfill rule 1, we get an additional satisfaction 5.",
      "solutions": [
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces",
          "content": "Good day to everybody!The next round for the participants of the second division will be held at September 22, 2015 at 19:30 MSK. Traditionally, the members of the first division may take part in the contest out of competition.I (Vladislav Vishnevski) and igdor99(Igor Doroshev) are the authors of the round. We would like to please Zlobober (Maxim Akhmedov) for the assistance in the preparation of tasks, Delinur(Maria Belova) for translating statements into English, MikeMirzayanov(Mike Mirzayanov) for remarkable systems Codeforces and Polygon, as well as our friends daksenik(Dmitry Aksenik) and irevt(Ivan Revt) for their assistance in the round preparation. This is our first round, and, we hope, it won't be the last one!You will be proposed 5 tasks and 2 hours for their solution.The protagonist of the round is the parrot Kefa, who likes money and restaurants.Good luck and high rating!UPD: The scores — 750-1250-1500-2000-2500.UPD: Editorial!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20376",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 953
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces",
          "content": "580A - Kefa and First StepsNote, that if the array has two intersecting continuous non-decreasing subsequence, they can be combined into one. Therefore, you can just pass the array from left to right. If the current subsequence can be continued using the i-th element, then we do it, otherwise we start a new one. The answer is the maximum subsequence of all the found ones.Asymptotics — O(n).Solution580B - Kefa and CompanyAt first we sort all friends in money ascending order. Now the answer is some array subsegment. Next, we use the method of two pointers for finding the required subsegment.Asymptotics — O(n log n).Solution580C - Kefa and ParkLet's go down the tree from the root, supporting additional parameter k — the number of vertices in a row met with cats. If k exceeds m, then leave. Then the answer is the number of leaves, which we were able to reach.Asymptotics — O(n).Solution580D - Kefa and DishesA two-dimensional DP will be used to solve the problem. The first dimention is the mask of already taken dishes, and the second — the number of the last taken dish. We will go through all the zero bits of the current mask for the transitions. We will try to put the one in them, and then update the answer for a new mask. The answer will consist of the answer of the old mask, a dish value, which conforms to the added bit and the rule, that can be used. The final answer is the maximum of all the values of DP, where mask contains exactly m ones.Asymptotics — O(2n * n2). Solution580E - Kefa and WatchAt first, we calculate the hash for all line elements depending on their positions. That is, the hash of the number k, standing on the i-th position will be equal to gi * k, where g is the base of the hash. We construct the segment tree of sums, which support a group modification, for all hashes. Thus, we can perform queries for modification in O(log n). It remains to deal with the queries of the second type. Let us assume, that we want to process the query 2 l r d. Obviously, the substring from l to r have a d-period, if a substring from l + d to r is equal to substring from l to r - d. We can find out the sum of hashes at the subsegment with the help of the sums tree, so we can compare the two strings in O(log n).Asymptotics — O(m log n).Solution",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 580\\s*D"
          },
          "content_length": 2276
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 1",
          "code": "adj[x].push_back(y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 2",
          "code": "adj[x].push_back(y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 3",
          "code": "adj[x].push_back(y);\nadj[y].push_back(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 4",
          "code": "adj[x].push_back(y);\nadj[y].push_back(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 5",
          "code": "if statment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 6",
          "code": "Validator 'valid.exe' returns exit code 3 [FAIL Expected EOLN (stdin)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 7",
          "code": "Validator 'valid.exe' returns exit code 3 [FAIL Expected EOLN (stdin)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 8",
          "code": "for (int i = 0; i < 100000; ++i) {\n  printf(\"%d\", i + 1);\n  if (i + 1 != 100000)\n     printf(\" \");\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 9",
          "code": "for (int i = 0; i < 100000; ++i) {\n  printf(\"%d\", i + 1);\n  if (i + 1 != 100000)\n     printf(\" \");\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 10",
          "code": "std::lower_bound(a + i, a + n, a[i] + d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 11",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 1",
          "code": "}\n    //cout<<friend_temp<<endl;\n    if(friend_temp>friends)\n    {\n\n    friends=friend_temp;\n\n}\n    if(j==n)\n    break;\n\n}\ncout<<friends;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 2",
          "code": "}\n    //cout<<friend_temp<<endl;\n    if(friend_temp>friends)\n    {\n\n    friends=friend_temp;\n\n}\n    if(j==n)\n    break;\n\n}\ncout<<friends;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 3",
          "code": "`test case: 04`, my compiler output\n10\n1 2 3 4 1 2 3 4 5 6\n`output: 6`",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 4",
          "code": "`test case: 04`, my compiler output\n10\n1 2 3 4 1 2 3 4 5 6\n`output: 6`",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 5",
          "code": "Verdict: WRONG_ANSWER",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 6",
          "code": "wrong answer 1st lines differ - expected: '6', found: '7 '",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 18, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * (n - 1), \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"ai\");\n    inf.readEoln();\n\n    set<pair<int, int>> rule_pairs;\n\n    for (int i = 0; i < k; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readSpace();\n        int ci = inf.readInt(0, 1000000000, \"ci\");\n        inf.readEoln();\n\n        pair<int, int> p = make_pair(xi, yi);\n        ensuref(rule_pairs.count(p) == 0, \"Duplicate rule (%d, %d) found.\", xi, yi);\n        rule_pairs.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 18, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * (n - 1), \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"ai\");\n    inf.readEoln();\n\n    set<pair<int, int>> rule_pairs;\n\n    for (int i = 0; i < k; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readSpace();\n        int ci = inf.readInt(0, 1000000000, \"ci\");\n        inf.readEoln();\n\n        pair<int, int> p = make_pair(xi, yi);\n        ensuref(rule_pairs.count(p) == 0, \"Duplicate rule (%d, %d) found.\", xi, yi);\n        rule_pairs.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 18, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * (n - 1), \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"ai\");\n    inf.readEoln();\n\n    set<pair<int, int>> rule_pairs;\n\n    for (int i = 0; i < k; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readSpace();\n        int ci = inf.readInt(0, 1000000000, \"ci\");\n        inf.readEoln();\n\n        pair<int, int> p = make_pair(xi, yi);\n        ensuref(rule_pairs.count(p) == 0, \"Duplicate rule (%d, %d) found.\", xi, yi);\n        rule_pairs.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    int m = opt<int>(\"m\", n);\n    int k = opt<int>(\"k\", 0);\n    std::string type = opt<std::string>(\"type\", \"random\");\n    \n    // Ensure constraints\n    ensure(1 <= n && n <= 18);\n    ensure(1 <= m && m <= n);\n    ensure(0 <= k && k <= n * (n - 1));\n\n    std::vector<long long> a(n); // a_i\n\n    // Generate a_i according to type\n    if (type == \"max_ai\")\n    {\n        for (int i = 0; i < n; ++i)\n        {\n            a[i] = 1000000000LL;\n        }\n    }\n    else if (type == \"zero_ai\")\n    {\n        for (int i = 0; i < n; ++i)\n        {\n            a[i] = 0LL;\n        }\n    }\n    else if (type == \"identical_ai\")\n    {\n        long long val = rnd.next(1000000001LL); // Random value between 0 and 1e9\n        for (int i = 0; i < n; ++i)\n        {\n            a[i] = val;\n        }\n    }\n    else\n    {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n        {\n            a[i] = rnd.next(1000000001LL);\n        }\n    }\n\n    // Adjust k according to type\n    if (type == \"all_rules\")\n    {\n        k = n * (n - 1);\n    }\n    else if (type == \"no_rules\")\n    {\n        k = 0;\n    }\n\n    // Ensure k is within bounds\n    if (k > n * (n - 1))\n        k = n * (n - 1);\n\n    // Generate all possible unique pairs (x_i, y_i), x_i != y_i\n    std::vector<std::pair<int, int> > pairs;\n    for (int x = 1; x <= n; ++x)\n    {\n        for (int y = 1; y <= n; ++y)\n        {\n            if (x != y)\n            {\n                pairs.push_back(std::make_pair(x, y));\n            }\n        }\n    }\n\n    // Shuffle and pick the first k pairs\n    shuffle(pairs.begin(), pairs.end());\n\n    pairs.resize(k);\n\n    std::vector<long long> c(k);\n\n    // Generate c_i according to type\n    if (type == \"max_ci\")\n    {\n        for (int i = 0; i < k; ++i)\n        {\n            c[i] = 1000000000LL;\n        }\n    }\n    else if (type == \"zero_ci\")\n    {\n        for (int i = 0; i < k; ++i)\n        {\n            c[i] = 0LL;\n        }\n    }\n    else\n    {\n        // Default to random c_i\n        for (int i = 0; i < k; ++i)\n        {\n            c[i] = rnd.next(1000000001LL);\n        }\n    }\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output a_i\n    for (int i = 0; i < n; ++i)\n    {\n        printf(\"%lld\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    // Output the rules\n    for (int i = 0; i < k; ++i)\n    {\n        printf(\"%d %d %lld\\n\", pairs[i].first, pairs[i].second, c[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    int m = opt<int>(\"m\", n);\n    int k = opt<int>(\"k\", 0);\n    std::string type = opt<std::string>(\"type\", \"random\");\n    \n    // Ensure constraints\n    ensure(1 <= n && n <= 18);\n    ensure(1 <= m && m <= n);\n    ensure(0 <= k && k <= n * (n - 1));\n\n    std::vector<long long> a(n); // a_i\n\n    // Generate a_i according to type\n    if (type == \"max_ai\")\n    {\n        for (int i = 0; i < n; ++i)\n        {\n            a[i] = 1000000000LL;\n        }\n    }\n    else if (type == \"zero_ai\")\n    {\n        for (int i = 0; i < n; ++i)\n        {\n            a[i] = 0LL;\n        }\n    }\n    else if (type == \"identical_ai\")\n    {\n        long long val = rnd.next(1000000001LL); // Random value between 0 and 1e9\n        for (int i = 0; i < n; ++i)\n        {\n            a[i] = val;\n        }\n    }\n    else\n    {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n        {\n            a[i] = rnd.next(1000000001LL);\n        }\n    }\n\n    // Adjust k according to type\n    if (type == \"all_rules\")\n    {\n        k = n * (n - 1);\n    }\n    else if (type == \"no_rules\")\n    {\n        k = 0;\n    }\n\n    // Ensure k is within bounds\n    if (k > n * (n - 1))\n        k = n * (n - 1);\n\n    // Generate all possible unique pairs (x_i, y_i), x_i != y_i\n    std::vector<std::pair<int, int> > pairs;\n    for (int x = 1; x <= n; ++x)\n    {\n        for (int y = 1; y <= n; ++y)\n        {\n            if (x != y)\n            {\n                pairs.push_back(std::make_pair(x, y));\n            }\n        }\n    }\n\n    // Shuffle and pick the first k pairs\n    shuffle(pairs.begin(), pairs.end());\n\n    pairs.resize(k);\n\n    std::vector<long long> c(k);\n\n    // Generate c_i according to type\n    if (type == \"max_ci\")\n    {\n        for (int i = 0; i < k; ++i)\n        {\n            c[i] = 1000000000LL;\n        }\n    }\n    else if (type == \"zero_ci\")\n    {\n        for (int i = 0; i < k; ++i)\n        {\n            c[i] = 0LL;\n        }\n    }\n    else\n    {\n        // Default to random c_i\n        for (int i = 0; i < k; ++i)\n        {\n            c[i] = rnd.next(1000000001LL);\n        }\n    }\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output a_i\n    for (int i = 0; i < n; ++i)\n    {\n        printf(\"%lld\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    // Output the rules\n    for (int i = 0; i < k; ++i)\n    {\n        printf(\"%d %d %lld\\n\", pairs[i].first, pairs[i].second, c[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, m, k\n./gen -n 1 -m 1 -k 0 -type random\n./gen -n 1 -m 1 -k 0 -type max_ai\n\n# Small n, max m\n./gen -n 2 -m 2 -k 1 -type random\n./gen -n 2 -m 2 -k 2 -type max_ai\n\n# Medium n\n./gen -n 10 -m 5 -k 0 -type random\n\n# Large n, small m\n./gen -n 18 -m 1 -k 10 -type random\n\n# Large n, m = n, k = max\n./gen -n 18 -m 18 -k 0 -type all_rules\n\n# Type: no_rules\n./gen -n 18 -m 9 -k 0 -type no_rules\n\n# Type: max_ai\n./gen -n 18 -m 9 -k 50 -type max_ai\n\n# Type: zero_ai\n./gen -n 18 -m 5 -k 50 -type zero_ai\n\n# Type: identical_ai\n./gen -n 18 -m 5 -k 50 -type identical_ai\n\n# Type: max_ci\n./gen -n 18 -m 9 -k 306 -type max_ci\n\n# Type: zero_ci\n./gen -n 18 -m 9 -k 50 -type zero_ci\n\n# Varying m\n./gen -n 18 -m 1 -k 50 -type random\n./gen -n 18 -m 9 -k 50 -type random\n./gen -n 18 -m 18 -k 50 -type random\n\n# Edge cases for m\n./gen -n 18 -m 1 -k 306 -type random\n./gen -n 18 -m 18 -k 0 -type random\n\n# Edge cases for k\n./gen -n 18 -m 9 -k 0 -type random\n./gen -n 18 -m 9 -k 306 -type random\n\n# Small n, maximum k\n./gen -n 5 -m 3 -k 20 -type all_rules\n\n# Small n, no rules\n./gen -n 5 -m 3 -k 0 -type no_rules\n\n# Small n, random\n./gen -n 5 -m 3 -k 5 -type random\n\n# Testing m > n (should handle gracefully)\n./gen -n 10 -m 10 -k 10 -type random\n\n# Testing invalid k (k > n*(n-1)) (should handle gracefully)\n./gen -n 10 -m 5 -k 90 -type random\n\n# Random tests\n./gen -n 14 -m 7 -k 7 -type random\n./gen -n 14 -m 7 -k 182 -type all_rules\n\n# Min n\n./gen -n 1 -m 1 -k 0 -type random\n./gen -n 1 -m 1 -k 0 -type max_ai\n\n# Alternative ai distributions\n./gen -n 16 -m 8 -k 50 -type identical_ai\n./gen -n 16 -m 8 -k 50 -type max_ai\n./gen -n 16 -m 8 -k 50 -type zero_ai\n\n# Additional tests with random parameters\n./gen -n 18 -m 1 -k 1 -type max_ci\n./gen -n 18 -m 2 -k 0 -type zero_ai\n./gen -n 18 -m 3 -k 3 -type identical_ai\n./gen -n 18 -m 4 -k 6 -type random\n./gen -n 18 -m 5 -k 15 -type random\n./gen -n 18 -m 6 -k 20 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:43.581314",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "580/E",
      "title": "E. Кефа и часы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1.5 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка ввода содержит три целых положительных числа n, m и k (1 ≤ n ≤ 105, 1 ≤ m + k ≤ 105) — длина серийного номера, количество изменений номера, произведенных Кефой, и количество проверок на подлинность.Вторая строка содержит серийный номер, состоящий из n цифр.Далее следует m + k строк, содержащих проверки либо изменения. Изменения задаются, как 1 l r с (1 ≤ l ≤ r ≤ n, 0 ≤ c ≤ 9). Это означает, что Кефа изменил все цифры с l-й по r-ю на c. Проверки задаются, как 2 l r d (1 ≤ l ≤ r ≤ n, 1 ≤ d ≤ r - l + 1).",
      "output_spec": "Выходные данныеДля каждой проверки на отдельной строке выведите «YES», если часы прошли её, иначе выведите «NO».",
      "sample_tests": "ПримерыВходные данныеСкопировать3 1 21122 2 3 11 1 3 82 1 2 1Выходные данныеСкопироватьNOYESВходные данныеСкопировать6 2 33349342 2 5 21 4 4 32 1 6 31 2 3 82 3 6 1Выходные данныеСкопироватьNOYESNO",
      "description": "E. Кефа и часы\n\nограничение по времени на тест1.5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка ввода содержит три целых положительных числа n, m и k (1 ≤ n ≤ 105, 1 ≤ m + k ≤ 105) — длина серийного номера, количество изменений номера, произведенных Кефой, и количество проверок на подлинность.Вторая строка содержит серийный номер, состоящий из n цифр.Далее следует m + k строк, содержащих проверки либо изменения. Изменения задаются, как 1 l r с (1 ≤ l ≤ r ≤ n, 0 ≤ c ≤ 9). Это означает, что Кефа изменил все цифры с l-й по r-ю на c. Проверки задаются, как 2 l r d (1 ≤ l ≤ r ≤ n, 1 ≤ d ≤ r - l + 1).\n\nВходные данные\n\nВыходные данныеДля каждой проверки на отдельной строке выведите «YES», если часы прошли её, иначе выведите «NO».\n\nВыходные данные\n\nВходные данныеСкопировать3 1 21122 2 3 11 1 3 82 1 2 1Выходные данныеСкопироватьNOYESВходные данныеСкопировать6 2 33349342 2 5 21 4 4 32 1 6 31 2 3 82 3 6 1Выходные данныеСкопироватьNOYESNO\n\nВходные данныеСкопировать3 1 21122 2 3 11 1 3 82 1 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNOYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 2 33349342 2 5 21 4 4 32 1 6 31 2 3 82 3 6 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNOYESNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте из условия будет произведено две проверки. В первой подстрока \"12\" проверяется на наличие периода 1, поэтому ответ — «NO». Во второй подстрока \"88\", проверяется на наличие периода 1, и у неё этот период есть, поэтому ответ — «YES».Во втором тесте из условия будет произведено три проверки. В первой рассматривается подстрока \"3493\", у которой нет периода 2. Перед второй проверкой строка приобретает вид \"334334\", поэтому на него ответ «YES». И наконец, в третьей проверке рассматривается подстрока \"8334\", у которой нет периода 1.",
      "solutions": [
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces",
          "content": "Всем доброго времени суток!22 сентября 2015 года в 19:30 MSK состоится очередной раунд для участников из второго дивизиона. Традиционно, участники из первого дивизиона могут участвовать в соревновании вне конкурса.Авторами раунда являются я (Владислав Вишневский) и igdor99(Игорь Дорошев). Хотелось бы сказать большое спасибо Zlobober(Максиму Ахмедову) за помощь в подготовке задач, Delinur(Марии Беловой) за перевод условий на английский, MikeMirzayanov(Михаилу Мирзаянову) за замечательные системы Codeforces и Polygon, а также нашим друзьям daksenik(Дмитрию Аксенику) и irevt(Ивану Ревту) за помощь в подготовке раунда. Это наш первый раунд, и надеемся, что не последний!Вам будет предложено 5 задач и 2 часа на их решение.Главным героем раунда является попугай Кефа, любящий деньги и рестораны.Всем удачи и высокого рейтинга!UPD: Разбалловка — 750-1250-1500-2000-2500.UPD: Разбор!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20376",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 884
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces",
          "content": "580A - Кефа и первые шагиЗаметим, что если в массиве есть две пересекающиеся непрерывные неубывающие подпоследовательности, то их можно объединить в одну. Поэтому можно просто проходиться по массиву слева направо. Если текущую подпоследовательность можно продолжить с помощью i-го элемента, то делаем это, иначе начинаем новую. Ответом будет максимальная из всех найденных подпоследовательностей.Асимптотика — O(n).Решение580B - Кефа и компанияСначала отсортируем всех друзей по возрастанию денег. Теперь ответом будет какой-то подотрезок массива. Далее будем использовать метод двух указателей для нахождения требуемого подотрезка. Асимптотика — O(n log n).Решение580C - Кефа и паркБудем спускаться по дереву от корня, поддерживая дополнительный параметр k — количество встреченных подряд вершин с котами. Если k превысило m, то выходим. Тогда ответ — это количество листьев, до которых мы смогли дойти.Асимптотика — O(n).Решение580D - Кефа и блюдаДля решения задачи будем использовать двумерное ДП. Первым измерением будет маска уже взятых блюд, а вторым — номер последнего взятого блюда. Для переходов будем перебирать все нулевые биты текущей маски. Будем пытаться поставить в них единицу, а затем обновлять ответ для новой маски. Ответ будет состоять из ответа для старой маски, ценности блюда, которому соответствует добавленный бит и правила, которое может быть использовано. Окончательным ответом будет максимум из всех значений ДП, где маска содержит ровно m единиц.Асимптотика — O(2n * n2). Решение580E - Кефа и часыДля начала посчитаем хэш для всех элементов строки в зависимости от их позиций. То есть хэш цифры k, стоящей на i-й позиции будет равен gi * k, где g — основание хэша. Для всех хэшей построим дерево отрезков сумм, поддерживающее групповую модификацию. Таким образом, запросы на модификацию мы можем выполнять за O(log n). Осталось разобраться с запросами второго типа. Допустим, нужно обработать запрос 2 l r d. Очевидно, что подстрока с l по r будет иметь период d, если подстрока с l + d по r равна подстроке с l по r - d. С помощью дерева сумм мы можем узнать сумму хэшей на подотрезке, а значит можем сравнить две строки за O(log n).Асимптотика — O(m log n).Решение",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 580\\s*E"
          },
          "content_length": 2195
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 1",
          "code": "adj[x].push_back(y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 2",
          "code": "adj[x].push_back(y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 3",
          "code": "adj[x].push_back(y);\nadj[y].push_back(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 4",
          "code": "adj[x].push_back(y);\nadj[y].push_back(x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 5",
          "code": "if statment",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 6",
          "code": "Validator 'valid.exe' returns exit code 3 [FAIL Expected EOLN (stdin)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 7",
          "code": "Validator 'valid.exe' returns exit code 3 [FAIL Expected EOLN (stdin)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 8",
          "code": "for (int i = 0; i < 100000; ++i) {\n  printf(\"%d\", i + 1);\n  if (i + 1 != 100000)\n     printf(\" \");\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 9",
          "code": "for (int i = 0; i < 100000; ++i) {\n  printf(\"%d\", i + 1);\n  if (i + 1 != 100000)\n     printf(\" \");\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 10",
          "code": "std::lower_bound(a + i, a + n, a[i] + d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 (Div. 2) - Codeforces - Code 11",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20376",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 1",
          "code": "}\n    //cout<<friend_temp<<endl;\n    if(friend_temp>friends)\n    {\n\n    friends=friend_temp;\n\n}\n    if(j==n)\n    break;\n\n}\ncout<<friends;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 2",
          "code": "}\n    //cout<<friend_temp<<endl;\n    if(friend_temp>friends)\n    {\n\n    friends=friend_temp;\n\n}\n    if(j==n)\n    break;\n\n}\ncout<<friends;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 3",
          "code": "`test case: 04`, my compiler output\n10\n1 2 3 4 1 2 3 4 5 6\n`output: 6`",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 4",
          "code": "`test case: 04`, my compiler output\n10\n1 2 3 4 1 2 3 4 5 6\n`output: 6`",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 5",
          "code": "Verdict: WRONG_ANSWER",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #321 Editorial - Codeforces - Code 6",
          "code": "wrong answer 1st lines differ - expected: '6', found: '7 '",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, k\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    ensuref(1 <= m + k && m + k <= 100000, \"1 <= m + k <= 1e5, but m + k = %d\", m + k);\n\n    // Read the serial number\n    string serialNumber = inf.readToken(format(\"[0-9]{%d}\", n), \"serial number\");\n    inf.readEoln();\n\n    // Process m + k operations\n    for (int i = 0; i < m + k; ++i) {\n        int t = inf.readInt(1, 2, \"operation type\");\n        inf.readSpace();\n        int l = inf.readInt(1, n, \"l\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r\"); // l <= r <= n\n        inf.readSpace();\n\n        if (t == 1) {\n            int c = inf.readInt(0, 9, \"c\");\n            // c ∈ [0,9]\n        } else {\n            int d = inf.readInt(1, r - l + 1, \"d\");\n            // d ∈ [1, r - l + 1]\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, k\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    ensuref(1 <= m + k && m + k <= 100000, \"1 <= m + k <= 1e5, but m + k = %d\", m + k);\n\n    // Read the serial number\n    string serialNumber = inf.readToken(format(\"[0-9]{%d}\", n), \"serial number\");\n    inf.readEoln();\n\n    // Process m + k operations\n    for (int i = 0; i < m + k; ++i) {\n        int t = inf.readInt(1, 2, \"operation type\");\n        inf.readSpace();\n        int l = inf.readInt(1, n, \"l\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r\"); // l <= r <= n\n        inf.readSpace();\n\n        if (t == 1) {\n            int c = inf.readInt(0, 9, \"c\");\n            // c ∈ [0,9]\n        } else {\n            int d = inf.readInt(1, r - l + 1, \"d\");\n            // d ∈ [1, r - l + 1]\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, k\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    ensuref(1 <= m + k && m + k <= 100000, \"1 <= m + k <= 1e5, but m + k = %d\", m + k);\n\n    // Read the serial number\n    string serialNumber = inf.readToken(format(\"[0-9]{%d}\", n), \"serial number\");\n    inf.readEoln();\n\n    // Process m + k operations\n    for (int i = 0; i < m + k; ++i) {\n        int t = inf.readInt(1, 2, \"operation type\");\n        inf.readSpace();\n        int l = inf.readInt(1, n, \"l\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r\"); // l <= r <= n\n        inf.readSpace();\n\n        if (t == 1) {\n            int c = inf.readInt(0, 9, \"c\");\n            // c ∈ [0,9]\n        } else {\n            int d = inf.readInt(1, r - l + 1, \"d\");\n            // d ∈ [1, r - l + 1]\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0);\n    int k = opt<int>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n    ensure(n >=1 && n <= 100000);\n    ensure(m >= 0 && k >= 0);\n    ensure(m + k >=1 && m + k <= 100000);\n    int total_ops = m + k;\n    string s(n, '0'); // Initialize s with zeros\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = '0' + rnd.next(10); // Random digit 0-9\n        }\n    } else if (type == \"periodic\") {\n        // Generate a periodic serial number\n        int period = rnd.next(1, n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = '0' + rnd.next(10);\n            if (i >= period) {\n                s[i] = s[i - period];\n            }\n        }\n    } else if (type == \"non_periodic\") {\n        // Generate a serial number unlikely to have periods\n        for (int i = 0; i < n; ++i) {\n            s[i] = '0' + ((i + rnd.next(1, 9)) % 10); // Randomized pattern\n        }\n    } else if (type == \"single\") {\n        ensure(n == 1);\n        s[0] = '0' + rnd.next(10);\n    } else if (type == \"max\") {\n        s = string(n, '9'); // Maximize digits\n    } else if (type == \"all_same\") {\n        char c = '0' + rnd.next(10);\n        s = string(n, c);\n    } else if (type == \"palindrome\") {\n        for (int i = 0; i < (n + 1) / 2; ++i) {\n            char c = '0' + rnd.next(10);\n            s[i] = s[n - 1 - i] = c;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            s[i] = '0' + rnd.next(10);\n        }\n    }\n    // Generate operations\n    vector<string> ops;\n    if (type == \"all_changing\") {\n        ensure(k == 0);\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int c = rnd.next(0, 9);\n            ops.push_back(\"1 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(c));\n        }\n    } else if (type == \"all_checking\") {\n        ensure(m == 0);\n        for (int i = 0; i < k; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int d = rnd.next(1, r - l + 1);\n            ops.push_back(\"2 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(d));\n        }\n    } else {\n        // First generate m changes and k checks\n        vector<string> changes, checks;\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int c = rnd.next(0, 9);\n            changes.push_back(\"1 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(c));\n        }\n        for (int i = 0; i < k; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int d = rnd.next(1, r - l + 1);\n            checks.push_back(\"2 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(d));\n        }\n        // Combine and shuffle\n        ops.reserve(m + k);\n        ops.insert(ops.end(), changes.begin(), changes.end());\n        ops.insert(ops.end(), checks.begin(), checks.end());\n        shuffle(ops.begin(), ops.end());\n    }\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n    // Output initial serial number\n    printf(\"%s\\n\", s.c_str());\n    // Output operations\n    for (const auto &op : ops) {\n        printf(\"%s\\n\", op.c_str());\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0);\n    int k = opt<int>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n    ensure(n >=1 && n <= 100000);\n    ensure(m >= 0 && k >= 0);\n    ensure(m + k >=1 && m + k <= 100000);\n    int total_ops = m + k;\n    string s(n, '0'); // Initialize s with zeros\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            s[i] = '0' + rnd.next(10); // Random digit 0-9\n        }\n    } else if (type == \"periodic\") {\n        // Generate a periodic serial number\n        int period = rnd.next(1, n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = '0' + rnd.next(10);\n            if (i >= period) {\n                s[i] = s[i - period];\n            }\n        }\n    } else if (type == \"non_periodic\") {\n        // Generate a serial number unlikely to have periods\n        for (int i = 0; i < n; ++i) {\n            s[i] = '0' + ((i + rnd.next(1, 9)) % 10); // Randomized pattern\n        }\n    } else if (type == \"single\") {\n        ensure(n == 1);\n        s[0] = '0' + rnd.next(10);\n    } else if (type == \"max\") {\n        s = string(n, '9'); // Maximize digits\n    } else if (type == \"all_same\") {\n        char c = '0' + rnd.next(10);\n        s = string(n, c);\n    } else if (type == \"palindrome\") {\n        for (int i = 0; i < (n + 1) / 2; ++i) {\n            char c = '0' + rnd.next(10);\n            s[i] = s[n - 1 - i] = c;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            s[i] = '0' + rnd.next(10);\n        }\n    }\n    // Generate operations\n    vector<string> ops;\n    if (type == \"all_changing\") {\n        ensure(k == 0);\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int c = rnd.next(0, 9);\n            ops.push_back(\"1 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(c));\n        }\n    } else if (type == \"all_checking\") {\n        ensure(m == 0);\n        for (int i = 0; i < k; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int d = rnd.next(1, r - l + 1);\n            ops.push_back(\"2 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(d));\n        }\n    } else {\n        // First generate m changes and k checks\n        vector<string> changes, checks;\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int c = rnd.next(0, 9);\n            changes.push_back(\"1 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(c));\n        }\n        for (int i = 0; i < k; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int d = rnd.next(1, r - l + 1);\n            checks.push_back(\"2 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(d));\n        }\n        // Combine and shuffle\n        ops.reserve(m + k);\n        ops.insert(ops.end(), changes.begin(), changes.end());\n        ops.insert(ops.end(), checks.begin(), checks.end());\n        shuffle(ops.begin(), ops.end());\n    }\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n    // Output initial serial number\n    printf(\"%s\\n\", s.c_str());\n    // Output operations\n    for (const auto &op : ops) {\n        printf(\"%s\\n\", op.c_str());\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal input\n./gen -n 1 -m 0 -k 1 -type single\n\n# Small random test cases\n./gen -n 10 -m 5 -k 5 -type random\n./gen -n 20 -m 10 -k 10 -type random\n\n# Small periodic test case\n./gen -n 15 -m 5 -k 10 -type periodic\n\n# Small non-periodic test case\n./gen -n 15 -m 5 -k 10 -type non_periodic\n\n# Edge case: n = 1e5, m + k = 1e5\n./gen -n 100000 -m 50000 -k 50000 -type max\n\n# All changing operations\n./gen -n 100000 -m 100000 -k 0 -type all_changing\n\n# All checking operations\n./gen -n 100000 -m 0 -k 100000 -type all_checking\n\n# Random large test case\n./gen -n 100000 -m 70000 -k 30000 -type random\n\n# Periodic large test case\n./gen -n 100000 -m 50000 -k 50000 -type periodic\n\n# Non-periodic large test case\n./gen -n 100000 -m 50000 -k 50000 -type non_periodic\n\n# Edge case: maximum n, minimal m + k\n./gen -n 100000 -m 1 -k 0 -type random\n\n# Edge case: minimal n, maximum m + k\n./gen -n 1 -m 0 -k 100000 -type all_checking\n\n# All same digits\n./gen -n 100000 -m 50000 -k 50000 -type all_same\n\n# Palindrome serial number\n./gen -n 99999 -m 1 -k 99999 -type palindrome\n\n# Test with period equals to length of substring\n./gen -n 5000 -m 0 -k 10000 -type random\n\n# Max digits serial number\n./gen -n 100000 -m 50000 -k 50000 -type max\n\n# Edge l = r in operations\n./gen -n 50000 -m 25000 -k 25000 -type random\n\n# Operation d = 1\n./gen -n 50000 -m 25000 -k 25000 -type random\n\n# Operation d = r - l + 1\n./gen -n 50000 -m 25000 -k 25000 -type random\n\n# Random small test cases\n./gen -n 50 -m 25 -k 25 -type random\n./gen -n 100 -m 50 -k 50 -type periodic\n./gen -n 200 -m 100 -k 100 -type non_periodic\n\n# Small all_same test case\n./gen -n 1000 -m 500 -k 500 -type all_same\n\n# Palindrome small serial number\n./gen -n 1001 -m 500 -k 500 -type palindrome\n\n# All changing at same position\n./gen -n 100000 -m 100000 -k 0 -type all_changing\n\n# All checking same substring\n./gen -n 100000 -m 0 -k 100000 -type all_checking\n\n# Random operations but changes cover entire serial number\n./gen -n 100000 -m 1000 -k 1000 -type random\n\n# Random operations but checks cover entire serial number\n./gen -n 100000 -m 1000 -k 1000 -type random\n\n# Edge case: l = r = n\n./gen -n 100000 -m 50000 -k 50000 -type random\n\n# Edge case: l = r = 1\n./gen -n 100000 -m 50000 -k 50000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:45.194660",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "581/A",
      "title": "A. Vasya the Hipster",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line of the input contains two positive integers a and b (1 ≤ a, b ≤ 100) — the number of red and blue socks that Vasya's got.",
      "output_spec": "OutputPrint two space-separated integers — the maximum number of days when Vasya can wear different socks and the number of days when he can wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.Keep in mind that at the end of the day Vasya throws away the socks that he's been wearing on that day.",
      "sample_tests": "ExamplesInputCopy3 1OutputCopy1 1InputCopy2 3OutputCopy2 0InputCopy7 3OutputCopy3 2",
      "description": "A. Vasya the Hipster\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe single line of the input contains two positive integers a and b (1 ≤ a, b ≤ 100) — the number of red and blue socks that Vasya's got.\n\nOutputPrint two space-separated integers — the maximum number of days when Vasya can wear different socks and the number of days when he can wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.Keep in mind that at the end of the day Vasya throws away the socks that he's been wearing on that day.\n\nInputCopy3 1OutputCopy1 1InputCopy2 3OutputCopy2 0InputCopy7 3OutputCopy3 2\n\nInputCopy3 1\n\nOutputCopy1 1\n\nInputCopy2 3\n\nOutputCopy2 0\n\nInputCopy7 3\n\nOutputCopy3 2\n\nNoteIn the first sample Vasya can first put on one pair of different socks, after that he has two red socks left to wear on the second day.",
      "solutions": [
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #322 (Div. 2). It'll be held on Monday, September 28 at 12:00 MSK and as usual Div. 1 participants can join out of competition. Note that round starts in the unusual time!This round is held on the tasks of the school stage All-Russian Olympiad of Informatics 2015/2016 year in city Saratov. They were prepared by me and recently returned from army Edvard Davtyan (Edvard). Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to Vladimir Petrov (vovuh) for writing solutions.It will be a little unusual round — you will be given six problems and two hours to solve them. The scoring distribution will be announced later. Good luck everyone! UPD The scoring distribution today will be 500-1000-1500-2000-3000-3000.UPD2 EditorialUPD3 Congratulations to the winners! Moe for_the_pride SakurakoujiRuna VNOI z123z123d",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20522",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1069
        },
        {
          "title": "Codeforces Round #322 (Div.2) Editorial - Codeforces",
          "content": "581A — Vasya the HipsterThe first number in answer (number of days which Vasya can dress fashionably) is min(a, b) because every from this day he will dress one red sock and one blue sock.After this Vasya will have either only red socks or only blue socks or socks do not remain at all. Because of that the second number in answer is max((a - min(a, b)) / 2, (b - min(a, b)) / 2).Asymptotic behavior of this solution — O(1).581B — Luxurious HousesThis problem can be solved in the following way. Let's iterate on given array from the right to the left and will store in variable maxH the maximal height if house which we have already considered.Then the answer to house number i is number max(0, maxH + 1 - hi), where hi number of floors in house number i.Asymptotic behavior of this solution — O(n), where n — number of houses.581C — Developing SkillsThis problem can be solved in many ways. Let's consider the most intuitive way that fits in the given time.In the beginning we need to sort given array in the following way — from two numbers to the left should be the number to which must be added fewer units of improvements to make it a multiple of 10. You must add at least one unit of energy to every of this numbers. For example, if given array is {45, 30, 87, 26} after the sort the array must be equal to {87, 26, 45, 30}.Now we iterate on the sorted array for i from 1 to n. Let's cur = 10 - (aimod10). If cur ≤ k assign ai = ai + cur and from k subtract cur else if cur > k break from cycle.The next step is to iterate on array in the same way.Now we need only to calculate answer ans — we iterate on array for i from 1 to n and assign ans = ans + (ai / 10).Asymptotic behavior of this solution — O(n * log(n)) where n is the number of hero skills.581D — Three LogosThis problem can be solved in many ways, let's consider one of them.The first step is to calculate sum of squares s of given rectangles. Then the side of a answer square is sqrt(s). If sqrt(s) is not integer print -1. Else we need to make the following.We brute the order in which we will add given rectangles in the answer square (we can do it with help of next_permutation()) and for every order we brute will we rotate current rectangle on 90 degrees or not (we can do it with help of bit masks). In the beginning on every iteration the answer square c in which we add the rectangles is empty.For every rectangle, which we add to the answer square we make the following — we need to find the uppermost and leftmost empty cell free in answer square c (recall that we also brute will we rotate the current rectangle on 90 degrees or not). Now we try to impose current rectangle in the answer square c and the top left corner must coinside with the cell free. If current rectangle fully placed in the answer square c and does not intersect with the some rectangle which has already been added, we need to fill by the required letter appropriate cells in the answer square c.If no one of the conditions did not disrupted after we added all three rectangles and all answer square c is fully filled by letters we found answer and we neeed only to print the answer square c.Else if we did not find answer after all iterations on the rectangles — print -1.For random number of the rectangles k asymptotic behavior — O(k! * 2k * s) where s — the sum of squares of the given rectangles.Also this problem with 3 rectangles can be solved with the analysis of the cases with asymptotic O(s) where s — the sum of squares of given rectangles.581E — Kojiro and FurrariLet's f — the position of start, and e — the position of finish. For convenience of implementation we add the gas-station in point e with type equals to 3.Note: there is never a sense go to the left of the starting point because we already stand with a full tank of the besr petrol. It is correct for every gas-station in which we can appear (if in optimal answer we must go to the left in some gas-station pv, why not throw out all the way from pv to current gas-station v and back and after that the answer will be better). Now let's say about algorithm when we are in some gas-station v.The first case: on distance no more than s there is the gas-station with quality of gasoline not worse, than in the current gas-station. Now we fix nearest from them nv (nearest to the right because go to the left as we understand makes no sense). In that case we refuel in such a way to can reach nv and go to nv.The second case: from the current gas-station we can reach only gas-station with the worst quality (the type of the current gas-station can be 2 or 3). If we are in the gas-station of type 2 we need to refuel on maximum possiblevalue and go in the last achievable gas-station. If we are in the gas-station with type 3, we need to go in the farthest gas-station with type 2, but if there is not such gas-station we need to go to the farthest gas-station with type 1. This reasoning are correct because we first need to minimze the count of fuel with type 1, and the second to minimize the count of fuel with type 2.This basic reasoning necessary to solve the problem. The next step — calc dynamic on all suffixes i of gas-stations — the answer to the problem if we start from the gas-station i with empty tank. We need to make updates, considering the above cases. For update the dynamic in v we need to take the value of dynamic in nv and make update in addiction of the case. If the case is equals to 1, we need to add to appropriate value the distance d from v to nv. If this case is equals to 2 and we are in the gas-station with type equals to 2 we need to add s to the second value of answer, and from the first value we need to substract s–d. If it is the case number 2 and we are in the gas-station with type equals to 3, we need to substract from the value, which determined by the type of the gas-station nv, s–d.Now to answer on specific query of the starting position we nned to find the first gas-station which is to the right of the startiong position, make one update and take the value of dynamic, which already calculated, and recalculate this value in accordance with the above.Asymptotic behavior — O(n logn) or O(n) in case how we find position in the list of gas-stations (the first in case of binary search, the second in case of two pointers).To this solution we need O(n) memory.581F — Zublicanes and MumocratesLet the number of leavs in tree (vertices with degree 1) is equal to c. It said in statement that c is even. If in given graph only 2 vertices the answer is equal to 1. Else we have vertex in graph which do not a leaf — we hang the three on this vertex.Now we need to count 2 dynamics. The first z1[v][cnt][col] — the least amount of colored edges in the subtree rooted at the vertex v, if vertex v already painted in color col (col equals to 0 or to 1), and among the top of the leaves of the subtree v must be exactly cnt vertices with color 0. If we are in the leaf, it is easy to count this value. If we are not in the leaf — we count value with help of dynamic z1[v][cnt][col]:  = z2[s][cnt][col], where s — the first child int the adjacency list of vertex v.We need the second dynamic z2[s][cnt][col] to spread cnt leaves with color 0 among subtrees of childs of vertex v. To calc z2[s][cnt][col] we brute the color of child s — ncol and the number of childs i with color 0, which will be locate in subtree of vertex s and calc the value in the following way — z2[s][cnt][col] = min(z2[s][cnt][col], z2[ns][cnt–a][col] + z1[s][a][ncol] + (ncol! = col)), where ns — the next child of vertex v after the child s. Note, that it is senselessly to take a more than the number of leaves in the subtree s and to take more than the number of vertices in subtree — sizes (because in that case it will not be enough leaves for painting).The upper bound of asymptotic for such dynamics O(n3). We show that in fact it works with asymptotic O(n2). Let's count the number of updates: . Note, that every pair of vertices (x, y) appears in the last sum (x, y) exactly once when v = lca(x, y). So we have no more than O(n2) updates.Asymptotic behavior of this solution: O(n2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20508",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 581\\s*A"
          },
          "content_length": 8135
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 1",
          "code": "0 1 2\nand\n0 0\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 2",
          "code": "0 1 2\nand\n0 0\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 3",
          "code": "(int)floor((double)skill[i].rat/10.0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 4",
          "code": "(int)floor((double)skill[i].rat/10.0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 5",
          "code": "skill[i].rat / 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 6",
          "code": "skill[i].rat / 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div.2) Editorial - Codeforces - Code 1",
          "code": "4999\n1 2\n2 3\n...\n2499 2500\n2500 2501\n2500 2502\n...\n2500 4999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div.2) Editorial - Codeforces - Code 2",
          "code": "4999\n1 2\n2 3\n...\n2499 2500\n2500 2501\n2500 2502\n...\n2500 4999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20508",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 100, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 100, \"b\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 100, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 100, \"b\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(1, 100, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 100, \"b\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n\n    if (a == -1 || b == -1) {\n        if (type == \"minimal\") {\n            a = 1;\n            b = 1;\n        } else if (type == \"maximal\") {\n            a = 100;\n            b = 100;\n        } else if (type == \"one_large\") {\n            if (rnd.next(2))\n                a = 100, b = 1;\n            else\n                a = 1, b = 100;\n        } else if (type == \"equal\") {\n            a = b = rnd.next(1, 100);\n        } else if (type == \"consecutive\") {\n            a = rnd.next(1, 99);\n            b = a + 1;\n            if (rnd.next(2)) swap(a, b);\n        } else if (type == \"random_small\") {\n            a = rnd.next(1, 10);\n            b = rnd.next(1, 10);\n        } else if (type == \"random_large\") {\n            a = rnd.next(90, 100);\n            b = rnd.next(90, 100);\n        } else { // random\n            a = rnd.next(1, 100);\n            b = rnd.next(1, 100);\n        }\n    }\n    printf(\"%d %d\\n\", a, b);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n\n    if (a == -1 || b == -1) {\n        if (type == \"minimal\") {\n            a = 1;\n            b = 1;\n        } else if (type == \"maximal\") {\n            a = 100;\n            b = 100;\n        } else if (type == \"one_large\") {\n            if (rnd.next(2))\n                a = 100, b = 1;\n            else\n                a = 1, b = 100;\n        } else if (type == \"equal\") {\n            a = b = rnd.next(1, 100);\n        } else if (type == \"consecutive\") {\n            a = rnd.next(1, 99);\n            b = a + 1;\n            if (rnd.next(2)) swap(a, b);\n        } else if (type == \"random_small\") {\n            a = rnd.next(1, 10);\n            b = rnd.next(1, 10);\n        } else if (type == \"random_large\") {\n            a = rnd.next(90, 100);\n            b = rnd.next(90, 100);\n        } else { // random\n            a = rnd.next(1, 100);\n            b = rnd.next(1, 100);\n        }\n    }\n    printf(\"%d %d\\n\", a, b);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type minimal\n./gen -type maximal\n./gen -type one_large\n\n./gen -type equal\n./gen -type equal\n./gen -type equal\n\n./gen -type consecutive\n./gen -type consecutive\n./gen -type consecutive\n\n./gen -type random_small\n./gen -type random_small\n./gen -type random_small\n\n./gen -type random_large\n./gen -type random_large\n./gen -type random_large\n\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -a 1 -b 1\n./gen -a 1 -b 100\n./gen -a 100 -b 1\n./gen -a 99 -b 100\n./gen -a 50 -b 51\n./gen -a 51 -b 50\n./gen -a 100 -b 100\n./gen -a 2 -b 1\n./gen -a 1 -b 2\n\n./gen -a 1 -b 3\n./gen -a 1 -b 99\n./gen -a 2 -b 2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:47.460017",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "581/B",
      "title": "B. Luxurious Houses",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains a single number n (1 ≤ n ≤ 105) — the number of houses in the capital of Berland.The second line contains n space-separated positive integers hi (1 ≤ hi ≤ 109), where hi equals the number of floors in the i-th house.",
      "output_spec": "OutputPrint n integers a1, a2, ..., an, where number ai is the number of floors that need to be added to the house number i to make it luxurious. If the house is already luxurious and nothing needs to be added to it, then ai should be equal to zero.All houses are numbered from left to right, starting from one.",
      "sample_tests": "ExamplesInputCopy51 2 3 1 2OutputCopy3 2 0 2 0 InputCopy43 2 1 4OutputCopy2 3 4 0",
      "description": "B. Luxurious Houses\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains a single number n (1 ≤ n ≤ 105) — the number of houses in the capital of Berland.The second line contains n space-separated positive integers hi (1 ≤ hi ≤ 109), where hi equals the number of floors in the i-th house.\n\nOutputPrint n integers a1, a2, ..., an, where number ai is the number of floors that need to be added to the house number i to make it luxurious. If the house is already luxurious and nothing needs to be added to it, then ai should be equal to zero.All houses are numbered from left to right, starting from one.\n\nInputCopy51 2 3 1 2OutputCopy3 2 0 2 0 InputCopy43 2 1 4OutputCopy2 3 4 0\n\nInputCopy51 2 3 1 2\n\nOutputCopy3 2 0 2 0\n\nInputCopy43 2 1 4\n\nOutputCopy2 3 4 0",
      "solutions": [
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #322 (Div. 2). It'll be held on Monday, September 28 at 12:00 MSK and as usual Div. 1 participants can join out of competition. Note that round starts in the unusual time!This round is held on the tasks of the school stage All-Russian Olympiad of Informatics 2015/2016 year in city Saratov. They were prepared by me and recently returned from army Edvard Davtyan (Edvard). Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to Vladimir Petrov (vovuh) for writing solutions.It will be a little unusual round — you will be given six problems and two hours to solve them. The scoring distribution will be announced later. Good luck everyone! UPD The scoring distribution today will be 500-1000-1500-2000-3000-3000.UPD2 EditorialUPD3 Congratulations to the winners! Moe for_the_pride SakurakoujiRuna VNOI z123z123d",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20522",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1069
        },
        {
          "title": "Codeforces Round #322 (Div.2) Editorial - Codeforces",
          "content": "581A — Vasya the HipsterThe first number in answer (number of days which Vasya can dress fashionably) is min(a, b) because every from this day he will dress one red sock and one blue sock.After this Vasya will have either only red socks or only blue socks or socks do not remain at all. Because of that the second number in answer is max((a - min(a, b)) / 2, (b - min(a, b)) / 2).Asymptotic behavior of this solution — O(1).581B — Luxurious HousesThis problem can be solved in the following way. Let's iterate on given array from the right to the left and will store in variable maxH the maximal height if house which we have already considered.Then the answer to house number i is number max(0, maxH + 1 - hi), where hi number of floors in house number i.Asymptotic behavior of this solution — O(n), where n — number of houses.581C — Developing SkillsThis problem can be solved in many ways. Let's consider the most intuitive way that fits in the given time.In the beginning we need to sort given array in the following way — from two numbers to the left should be the number to which must be added fewer units of improvements to make it a multiple of 10. You must add at least one unit of energy to every of this numbers. For example, if given array is {45, 30, 87, 26} after the sort the array must be equal to {87, 26, 45, 30}.Now we iterate on the sorted array for i from 1 to n. Let's cur = 10 - (aimod10). If cur ≤ k assign ai = ai + cur and from k subtract cur else if cur > k break from cycle.The next step is to iterate on array in the same way.Now we need only to calculate answer ans — we iterate on array for i from 1 to n and assign ans = ans + (ai / 10).Asymptotic behavior of this solution — O(n * log(n)) where n is the number of hero skills.581D — Three LogosThis problem can be solved in many ways, let's consider one of them.The first step is to calculate sum of squares s of given rectangles. Then the side of a answer square is sqrt(s). If sqrt(s) is not integer print -1. Else we need to make the following.We brute the order in which we will add given rectangles in the answer square (we can do it with help of next_permutation()) and for every order we brute will we rotate current rectangle on 90 degrees or not (we can do it with help of bit masks). In the beginning on every iteration the answer square c in which we add the rectangles is empty.For every rectangle, which we add to the answer square we make the following — we need to find the uppermost and leftmost empty cell free in answer square c (recall that we also brute will we rotate the current rectangle on 90 degrees or not). Now we try to impose current rectangle in the answer square c and the top left corner must coinside with the cell free. If current rectangle fully placed in the answer square c and does not intersect with the some rectangle which has already been added, we need to fill by the required letter appropriate cells in the answer square c.If no one of the conditions did not disrupted after we added all three rectangles and all answer square c is fully filled by letters we found answer and we neeed only to print the answer square c.Else if we did not find answer after all iterations on the rectangles — print -1.For random number of the rectangles k asymptotic behavior — O(k! * 2k * s) where s — the sum of squares of the given rectangles.Also this problem with 3 rectangles can be solved with the analysis of the cases with asymptotic O(s) where s — the sum of squares of given rectangles.581E — Kojiro and FurrariLet's f — the position of start, and e — the position of finish. For convenience of implementation we add the gas-station in point e with type equals to 3.Note: there is never a sense go to the left of the starting point because we already stand with a full tank of the besr petrol. It is correct for every gas-station in which we can appear (if in optimal answer we must go to the left in some gas-station pv, why not throw out all the way from pv to current gas-station v and back and after that the answer will be better). Now let's say about algorithm when we are in some gas-station v.The first case: on distance no more than s there is the gas-station with quality of gasoline not worse, than in the current gas-station. Now we fix nearest from them nv (nearest to the right because go to the left as we understand makes no sense). In that case we refuel in such a way to can reach nv and go to nv.The second case: from the current gas-station we can reach only gas-station with the worst quality (the type of the current gas-station can be 2 or 3). If we are in the gas-station of type 2 we need to refuel on maximum possiblevalue and go in the last achievable gas-station. If we are in the gas-station with type 3, we need to go in the farthest gas-station with type 2, but if there is not such gas-station we need to go to the farthest gas-station with type 1. This reasoning are correct because we first need to minimze the count of fuel with type 1, and the second to minimize the count of fuel with type 2.This basic reasoning necessary to solve the problem. The next step — calc dynamic on all suffixes i of gas-stations — the answer to the problem if we start from the gas-station i with empty tank. We need to make updates, considering the above cases. For update the dynamic in v we need to take the value of dynamic in nv and make update in addiction of the case. If the case is equals to 1, we need to add to appropriate value the distance d from v to nv. If this case is equals to 2 and we are in the gas-station with type equals to 2 we need to add s to the second value of answer, and from the first value we need to substract s–d. If it is the case number 2 and we are in the gas-station with type equals to 3, we need to substract from the value, which determined by the type of the gas-station nv, s–d.Now to answer on specific query of the starting position we nned to find the first gas-station which is to the right of the startiong position, make one update and take the value of dynamic, which already calculated, and recalculate this value in accordance with the above.Asymptotic behavior — O(n logn) or O(n) in case how we find position in the list of gas-stations (the first in case of binary search, the second in case of two pointers).To this solution we need O(n) memory.581F — Zublicanes and MumocratesLet the number of leavs in tree (vertices with degree 1) is equal to c. It said in statement that c is even. If in given graph only 2 vertices the answer is equal to 1. Else we have vertex in graph which do not a leaf — we hang the three on this vertex.Now we need to count 2 dynamics. The first z1[v][cnt][col] — the least amount of colored edges in the subtree rooted at the vertex v, if vertex v already painted in color col (col equals to 0 or to 1), and among the top of the leaves of the subtree v must be exactly cnt vertices with color 0. If we are in the leaf, it is easy to count this value. If we are not in the leaf — we count value with help of dynamic z1[v][cnt][col]:  = z2[s][cnt][col], where s — the first child int the adjacency list of vertex v.We need the second dynamic z2[s][cnt][col] to spread cnt leaves with color 0 among subtrees of childs of vertex v. To calc z2[s][cnt][col] we brute the color of child s — ncol and the number of childs i with color 0, which will be locate in subtree of vertex s and calc the value in the following way — z2[s][cnt][col] = min(z2[s][cnt][col], z2[ns][cnt–a][col] + z1[s][a][ncol] + (ncol! = col)), where ns — the next child of vertex v after the child s. Note, that it is senselessly to take a more than the number of leaves in the subtree s and to take more than the number of vertices in subtree — sizes (because in that case it will not be enough leaves for painting).The upper bound of asymptotic for such dynamics O(n3). We show that in fact it works with asymptotic O(n2). Let's count the number of updates: . Note, that every pair of vertices (x, y) appears in the last sum (x, y) exactly once when v = lca(x, y). So we have no more than O(n2) updates.Asymptotic behavior of this solution: O(n2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20508",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 581\\s*B"
          },
          "content_length": 8135
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 1",
          "code": "0 1 2\nand\n0 0\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 2",
          "code": "0 1 2\nand\n0 0\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 3",
          "code": "(int)floor((double)skill[i].rat/10.0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 4",
          "code": "(int)floor((double)skill[i].rat/10.0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 5",
          "code": "skill[i].rat / 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 6",
          "code": "skill[i].rat / 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div.2) Editorial - Codeforces - Code 1",
          "code": "4999\n1 2\n2 3\n...\n2499 2500\n2500 2501\n2500 2502\n...\n2500 4999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div.2) Editorial - Codeforces - Code 2",
          "code": "4999\n1 2\n2 3\n...\n2499 2500\n2500 2501\n2500 2502\n...\n2500 4999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20508",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    vector<int> hi = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    vector<int> hi = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    vector<int> hi = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int maxHeight = opt<int>(\"maxHeight\", 1000000000);\n    int k = opt<int>(\"k\", 1);\n\n    vector<int> h(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, maxHeight);\n        }\n    } else if (type == \"ascending\") {\n        int start = opt<int>(\"start\", 1);\n        int step = opt<int>(\"step\", 1);\n        h[0] = start;\n        for (int i = 1; i < n; ++i) {\n            h[i] = h[i - 1] + step;\n            if (h[i] > maxHeight) h[i] = maxHeight; // Ensure h_i doesn't exceed maxHeight\n        }\n    } else if (type == \"descending\") {\n        int start = opt<int>(\"start\", maxHeight);\n        int step = opt<int>(\"step\", 1);\n        h[0] = start;\n        for (int i = 1; i < n; ++i) {\n            h[i] = h[i - 1] - step;\n            if (h[i] < 1) h[i] = 1; // Ensure h_i doesn't go below 1\n        }\n    } else if (type == \"constant\") {\n        h.assign(n, k);\n    } else if (type == \"alternating\") {\n        int h1 = opt<int>(\"h1\", 1);\n        int h2 = opt<int>(\"h2\", maxHeight);\n        for (int i = 0; i < n; ++i) {\n            h[i] = (i % 2 == 0) ? h1 : h2;\n        }\n    } else if (type == \"max_height\") {\n        h.assign(n, maxHeight);\n    } else if (type == \"min_height\") {\n        h.assign(n, 1);\n    } else if (type == \"random_small\") {\n        int small_max = opt<int>(\"small_max\", 100);\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, small_max);\n        }\n    } else if (type == \"singleton\") {\n        h.resize(1);\n        h[0] = rnd.next(1, maxHeight);\n    } else if (type == \"plateau\") {\n        int num_plateaus = opt<int>(\"plateaus\", 10);\n        vector<int> plateau_heights;\n        for (int i = 0; i < num_plateaus; ++i) {\n            plateau_heights.push_back(rnd.next(1, maxHeight));\n        }\n        for (int i = 0; i < n; ++i) {\n            h[i] = plateau_heights[rnd.next(0, num_plateaus - 1)];\n        }\n    } else if (type == \"sawtooth\") {\n        int minH = opt<int>(\"minH\", 1);\n        int maxH = opt<int>(\"maxH\", maxHeight);\n        int period = opt<int>(\"period\", 10);\n        for (int i = 0; i < n; ++i) {\n            int pos = i % period;\n            h[i] = (pos * (maxH - minH) / (period - 1)) + minH;\n        }\n    } else {\n        // Default to random heights\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, maxHeight);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", (int)h.size());\n    // Output h_i\n    for (int i = 0; i < (int)h.size(); ++i) {\n        printf(\"%d\", h[i]);\n        if (i + 1 < (int)h.size()) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int maxHeight = opt<int>(\"maxHeight\", 1000000000);\n    int k = opt<int>(\"k\", 1);\n\n    vector<int> h(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, maxHeight);\n        }\n    } else if (type == \"ascending\") {\n        int start = opt<int>(\"start\", 1);\n        int step = opt<int>(\"step\", 1);\n        h[0] = start;\n        for (int i = 1; i < n; ++i) {\n            h[i] = h[i - 1] + step;\n            if (h[i] > maxHeight) h[i] = maxHeight; // Ensure h_i doesn't exceed maxHeight\n        }\n    } else if (type == \"descending\") {\n        int start = opt<int>(\"start\", maxHeight);\n        int step = opt<int>(\"step\", 1);\n        h[0] = start;\n        for (int i = 1; i < n; ++i) {\n            h[i] = h[i - 1] - step;\n            if (h[i] < 1) h[i] = 1; // Ensure h_i doesn't go below 1\n        }\n    } else if (type == \"constant\") {\n        h.assign(n, k);\n    } else if (type == \"alternating\") {\n        int h1 = opt<int>(\"h1\", 1);\n        int h2 = opt<int>(\"h2\", maxHeight);\n        for (int i = 0; i < n; ++i) {\n            h[i] = (i % 2 == 0) ? h1 : h2;\n        }\n    } else if (type == \"max_height\") {\n        h.assign(n, maxHeight);\n    } else if (type == \"min_height\") {\n        h.assign(n, 1);\n    } else if (type == \"random_small\") {\n        int small_max = opt<int>(\"small_max\", 100);\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, small_max);\n        }\n    } else if (type == \"singleton\") {\n        h.resize(1);\n        h[0] = rnd.next(1, maxHeight);\n    } else if (type == \"plateau\") {\n        int num_plateaus = opt<int>(\"plateaus\", 10);\n        vector<int> plateau_heights;\n        for (int i = 0; i < num_plateaus; ++i) {\n            plateau_heights.push_back(rnd.next(1, maxHeight));\n        }\n        for (int i = 0; i < n; ++i) {\n            h[i] = plateau_heights[rnd.next(0, num_plateaus - 1)];\n        }\n    } else if (type == \"sawtooth\") {\n        int minH = opt<int>(\"minH\", 1);\n        int maxH = opt<int>(\"maxH\", maxHeight);\n        int period = opt<int>(\"period\", 10);\n        for (int i = 0; i < n; ++i) {\n            int pos = i % period;\n            h[i] = (pos * (maxH - minH) / (period - 1)) + minH;\n        }\n    } else {\n        // Default to random heights\n        for (int i = 0; i < n; ++i) {\n            h[i] = rnd.next(1, maxHeight);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", (int)h.size());\n    // Output h_i\n    for (int i = 0; i < (int)h.size(); ++i) {\n        printf(\"%d\", h[i]);\n        if (i + 1 < (int)h.size()) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type singleton\n\n./gen -n 2 -type min_height\n\n./gen -n 2 -type max_height\n\n./gen -n 10 -type random\n\n./gen -n 10 -type ascending -start 1 -step 1\n\n./gen -n 10 -type descending -start 10 -step 1\n\n./gen -n 10 -type constant -k 1\n\n./gen -n 10 -type constant -k 1000000000\n\n./gen -n 10 -type alternating -h1 1 -h2 10\n\n./gen -n 10 -type alternating -h1 1000000000 -h2 1\n\n./gen -n 10 -type max_height\n\n./gen -n 10 -type min_height\n\n./gen -n 10 -type random_small -small_max 10\n\n./gen -n 100 -type random\n\n./gen -n 1000 -type random\n\n./gen -n 10000 -type random\n\n./gen -n 100000 -type random\n\n./gen -n 100000 -type ascending -start 1 -step 0\n\n./gen -n 100000 -type descending -start 1000000000 -step 1\n\n./gen -n 100000 -type constant -k 500000000\n\n./gen -n 100000 -type constant -k 1\n\n./gen -n 100000 -type constant -k 1000000000\n\n./gen -n 100000 -type alternating -h1 1 -h2 1000000000\n\n./gen -n 100000 -type plateau -plateaus 2\n\n./gen -n 100000 -type plateau -plateaus 100\n\n./gen -n 100000 -type sawtooth -minH 1 -maxH 1000000000 -period 2\n\n./gen -n 100000 -type sawtooth -minH 1 -maxH 1000000000 -period 100\n\n./gen -n 99999 -type random_small -small_max 10\n\n./gen -n 100000 -type random_small -small_max 1\n\n./gen -n 100000 -type max_height\n\n./gen -n 100000 -type min_height\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:49.163440",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "581/C",
      "title": "C. Развитие навыков",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных следуют два целых положительных числа n и k (1 ≤ n ≤ 105, 0 ≤ k ≤ 107) — количество навыков главного героя и количество единиц улучшений, имеющихся у Пети.Во второй строке входных данных следует последовательность из n целых чисел ai (0 ≤ ai ≤ 100), где ai характеризует уровень развитости i-го навыка главного героя.",
      "output_spec": "Выходные данныеВ единственной строке выходных данных должно содержаться целое неотрицательное число — максимальный суммарный рейтинг главного героя, который может получить Петя, используя k или менее единиц улучшения.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 47 9Выходные данныеСкопировать2Входные данныеСкопировать3 817 15 19Выходные данныеСкопировать5Входные данныеСкопировать2 299 100Выходные данныеСкопировать20",
      "description": "C. Развитие навыков\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных следуют два целых положительных числа n и k (1 ≤ n ≤ 105, 0 ≤ k ≤ 107) — количество навыков главного героя и количество единиц улучшений, имеющихся у Пети.Во второй строке входных данных следует последовательность из n целых чисел ai (0 ≤ ai ≤ 100), где ai характеризует уровень развитости i-го навыка главного героя.\n\nВходные данные\n\nВыходные данныеВ единственной строке выходных данных должно содержаться целое неотрицательное число — максимальный суммарный рейтинг главного героя, который может получить Петя, используя k или менее единиц улучшения.\n\nВыходные данные\n\nВходные данныеСкопировать2 47 9Выходные данныеСкопировать2Входные данныеСкопировать3 817 15 19Выходные данныеСкопировать5Входные данныеСкопировать2 299 100Выходные данныеСкопировать20\n\nВходные данныеСкопировать2 47 9\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 817 15 19\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 299 100\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать20\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере оптимальная стратегия следующая. Петя должен улучшить первый навык до 10, потратив 3 единицы улучшения, и второй навык до 10, потратив одну единицу улучшения. Таким образом, Петя потратит все свои единицы улучшения и суммарный рейтинг главного героя станет равен .Во втором тестовом примере оптимально для Пети улучшить первый навык до 20 (при этом потратить 3 единицы улучшения) и улучшить третий навык до 20 (при этом потратить 1 единицу улучшения). Таким образом, у Пети останется 4 единицы улучшения и он сможет увеличить второй навык лишь до 19 (что не изменит суммарный рейтинг, поэтому делать это Пете необязательно). Поэтому максимально возможный суммарный рейтинг в этом примере .В третьем тестовом примере оптимальная стратегия Пети — увеличить первый навык до 100, потратив 1 единицу улучшения. После этого оба навыка главного героя станут равны 100, поэтому Петя не сможет потратить оставшуюся единицу улучшения. Таким образом, ответ равен .",
      "solutions": [
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces",
          "content": "Привет, Codeforces!28 сентября 2015 года в 12:00 MSK состоится очередной раунд Codeforces #322 для участников из второго дивизиона. Традиционно, участники из первого дивизиона приглашаются поучаствовать в соревновании вне конкурса. Обратите внимание на необычное время начала раунда!Этот раунд проводится по задачам школьного этапа Всероссийской олимпиады школьников по информатике 2015/2016 года г. Саратова. Задачи для вас готовил я и недавно вернувшийся из армии Эдвард Давтян (Edvard).Хотелось бы сказать большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за перевод условий на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon, а также Владимиру Петрову (vovuh) за прорешивание задач.Участникам будет предложено шесть задач и два часа на их решение. Разбалловка будет объявлена позднее.UPD Разбалловка задач 500-1000-1500-2000-3000-3000. Всем удачи!UPD2 РазборUPD3 Поздравляем победителей! Moe for_the_pride SakurakoujiRuna VNOI z123z123d",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20522",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1034
        },
        {
          "title": "Разбор Codeforces Round #322 (Div. 2) - Codeforces",
          "content": "581A — Хипстер ВасяПервое ответное число (количество дней, которое Вася сможет быть одет по моде) это min(a, b), так как каждый из этих дней он будет надевать по одному красному и по одному синему носку.После этого у него останутся либо только красные носки, либо только синие носки, либо не останется носков вовсе. Поэтому второе ответное число это max((a - min(a, b)) / 2, (b - min(a, b)) / 2).Асимптотика решения — O(1).581B — Элитные домаДанная задача решается следующим образом. Пойдем по массиву справа налево и будем поддерживать в переменной maxH максимальную высоту дома, который мы уже рассмотрели. Тогда ответом для i-го дома будет число max(0, maxH + 1 - hi), где hi количество этажей в i-м доме.Асимптотика решения — O(n), где n — количество домов.581C — Развитие навыковДанную задачу можно решать несколькими способами. Рассмотрим самый понятный способ, который укладывается в заданное время.Отсортируем заданный массив следующим образом — из двух чисел левее должно стоять то, к которому нужно добавить меньше единиц улучшений, чтобы оно стало кратно 10. Обязательно добавлять хотя бы одну единицу энергии. Например, если исходный массив {45, 30, 87, 26}, то после сортировки он должен выглядеть следующим образом — {87, 26, 45, 30}.Теперь проитерируемся по отсортированному массиву слева направо по i от 1 до n. Пусть cur = 10 - (aimod10). Если cur ≤ k, присвоим ai = ai + cur, а из k вычтем cur, иначе, если cur > k выйдем из цикла.Следующим шагом проитерируемся по массиву аналогичным образом.Осталось посчитать ответ ans — проитерируемся по массиву по i от 1 до n и присвоим ans = ans + (ai / 10).Асимптотика решения — O(n * log(n)), где n количество заданных навыков героя.581D — Три логотипаДанная задача решается несколькими способами, рассмотрим один из них. Для начала подсчитаем суммарную площадь s данных нам прямоугольников. Тогда сторона ответного квадрата это sqrt(s). Если sqrt(s) не целое число, выводим -1. Иначе сделаем следующее. Переберем порядок, в котором будем добавлять заданные прямоугольники в квадрат (это можно сделать с помощью next_permutation()), а также для каждого порядка переберем будем ли мы переворачивать текущий прямоугольник на 90 градусов или нет (это можно сделать с помощью двоичных масок). Изначально на каждой итерации квадрат c, в который мы добавляем прямоугольники ничем не заполнен (пустой). Для каждого из добавляемых прямоугольников сделаем следующее — найдем самую верхнюю левую свободную клетку free в квадрате c (напомним, что мы также перебираем, поворачиваем ли мы прямоугольник на 90 градусов или нет). Попытаемся наложить текущий прямоугольник в квадрат c, причем его левый верхний угол должен совпадать с клеткой free. Если текущий прямоугольник полностью помещается в квадрат c и не накладывается на уже занятую каким-то другим прямоугольником клетку, заполним соответствующие клетки в квадрате c нужной буквой. Если после добавления всех трех прямоугольников не нарушилось ни одно из условий и весь квадрат c оказался заполненным мы нашли ответ — выводим квадрат c.Если ответ не нашелся ни для одной перестановки прямоугольников — выводим -1.Для произвольного количества прямоугольников k асимптотика решения — O(k! * 2k * s), где s — суммарная площадь заданных прямоугольников. Также данная задача для 3 прямоугольников имеет решение с разбором случаев с асимптотикой O(s), где s — суммарная площадь заданных прямоугольников. 581E — Кодзиро и FurrariПусть f — стартовая позиция, а e — конечная. Для удобства реализации и дальнейших рассуждений добавим заправку в точке e типа 3.Первое замечание: никогда нет смысла идти налево из стартовой точки ведь мы в ней уже стоит с полным баком лучшего бензина. Замечание верно и для любой заправки, в которой мы можем оказаться (если в оптимальном ответе мы должны пойти налево до некоторой заправки pv, то почему бы не выкинуть весь путь из pv в текущую заправку v и обратно и от этого ответ станет только лучше). Теперь поймем как нам следует действовать если мы находимся в некоторой заправке v.Первый случай: на расстоянии не более чем s находится заправка в качеством бензина не хуже, чем в нашей (можно считать, что в момент старта мы находимся на заправке типа 3, но добавлять такую заправку нельзя). Зафиксируем ближайшую из них nv (ближайшую справа, так как мы уже поняли, что идти влево нет смысла). В этом случае дозаправимся так, чтобы возможно было доехать до nv. И поедем в nv.Второй случай: из нас достижимы только заправки с худшим качеством. Заметим, что это возможно лишь в случае, если мы находимся в заправке типа 2 или 3. В случае заправки второго типа у нас нет никакого выбора кроме как заправиться на полную и поехать в самую последнюю достижимую вершину (то есть вершину на расстоянии не более чем s). Если же мы находимся в вершине типа 3, то нужно идти по возможности в самую дальнюю вершину типа 2, если же такой нет то идти в самую дальнюю типа 1. Эти рассуждения верны в силу того, что нам в первую очередь необходимо минимзировать бензин типа 1, а при равенстве типа — 2. Как можно дальше нужно идти потому, что бензин в нашей вершине строго лучше достижимых, а тип 2 нужно выбирать, поскольку если мы можем доехать до типа 1 и он находится правее заправки типа 2, то мы можем это сделать, проехав через заправку типа 2, возможно улучшив ответ.Это основные рассуждения необходимые для решения задачи. Далее будем считать диманику на всех суффиксах i заправок — ответ на задачу если мы стартуем из заправки i с пустым баком. Переходы мы должны сделать, рассматривая описанные выше случаи. Для пересчета динамики в v нам нужно взять значение динамики в nv и сделать пересчет в зависимости от случая. Если случай 1, то нужно просто к соответствующему значению прибавить расстояние d от v к nv. Если это случай 2 и мы в заправке типа 2 нужно ко второму значению ответа прибавить s, а из первого вычесть s–d. Если это случай 2 и мы в заправке типа 3, то нужно из значения, определяемого типом заправки nv вычесть s–d.Теперь, чтобы ответить на конкретный запрос стартовой позиции нужно найти первую завправку правее стартовой позиции, сделать один переход и взять уже посчитанное значение динамики (конечно, пересчитав это значение в соответствии с вышеописанным).Сложность решения по времени: O(n logn) или O(n) в зависимости от того как искать позицию в списке заправок (первое в случае бинпоиска, второе в случае двух указателей). Сложность решения по памяти: O(n).581F — Зубликанцы и мумократыПусть количество листьев дерева (вершин степени 1) равно c. По условию c четно. Если вершин всего 2, то ответ 1. Иначе в дереве есть вершина не лист, подвесим дерево за эту вершину.Теперь будем считать 2 динамики. Первая z1[v][cnt][col] — наименьшее количество разноцветных ребер в поддереве с корнем в вершине v, если вершина v уже покрашена в цвет col (col равен 0 либо 1), а среди листьев поддерева вершины v должно быть ровно cnt вершин цвета 0. Если мы в листе, то это значение легко посчитать. Если мы не в листе посчитаем значение с помощью вспомогательной динамики z1[v][cnt][col]:  = z2[s][cnt][col], где s — первый сын в списке смежности вершины v.Вторая динамика z2[s][cnt][col] нам нужна для того, чтобы распределить cnt листьев цвета 0 среди поддеревьев сыновей вершины v. Для подсчета z2[s][cnt][col] переберем цвет сына s — ncol и количество листьев i цвета 0, которые будут располагаться в поддереве вершины s и пересчитаем значение следующим образом z2[s][cnt][col] = min(z2[s][cnt][col], z2[ns][cnt–a][col] + z1[s][a][ncol] + (ncol! = col)), где ns — следующий после s сын вершины v. Заметим, что не имеет смысла брать a больше, чем количество листьев в поддереве s, ну и тем более — больше количества вершин в поддереве sizes (поскольку у нас просто не хватит листьев для покраски).Оценка сверху для такой динамики O(n3). Покажем, что в сумме решение будет работать за O(n2). Посчитаем количество переходов: . Заметим, что в последнюю сумму каждая пара вершин (x, y) войдет ровно один раз, именно при наименьшем общем предке v = lca(x, y). Таким образом переходов не более O(n2).Сложность решения по времени и памяти: O(n2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20508",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 581\\s*C"
          },
          "content_length": 8083
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 1",
          "code": "Информация о разбалловке появится к началу раунда.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 2",
          "code": "Информация о разбалловке появится к началу раунда.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 3",
          "code": "0 1 2\nand\n0 0\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 4",
          "code": "0 1 2\nand\n0 0\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 5",
          "code": "(int)floor((double)skill[i].rat/10.0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 6",
          "code": "(int)floor((double)skill[i].rat/10.0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 7",
          "code": "skill[i].rat / 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 8",
          "code": "skill[i].rat / 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #322 (Div. 2) - Codeforces - Code 1",
          "code": "2 10000\n99 99",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20508",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #322 (Div. 2) - Codeforces - Code 2",
          "code": "2 10000\n99 99",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20508",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #322 (Div. 2) - Codeforces - Code 3",
          "code": "4999\n1 2\n2 3\n...\n2499 2500\n2500 2501\n2500 2502\n...\n2500 4999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20508",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #322 (Div. 2) - Codeforces - Code 4",
          "code": "4999\n1 2\n2 3\n...\n2499 2500\n2500 2501\n2500 2502\n...\n2500 4999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20508",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 10000000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 10000000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 10000000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"random\") {\n        // Random ai between 0 and 100\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, 100);\n        }\n    } else if (type == \"min\") {\n        // ai are all 0\n        fill(ai.begin(), ai.end(), 0);\n    } else if (type == \"max\") {\n        // ai are all 100\n        fill(ai.begin(), ai.end(), 100);\n    } else if (type == \"just_below_multiple_of_10\") {\n        // ai are 9,19,29,...,99\n        for (int i = 0; i < n; ++i) {\n            int multiple = rnd.next(1, 10) * 10;\n            ai[i] = multiple - 1;\n        }\n    } else if (type == \"just_above_multiple_of_10\") {\n        // ai are 1,11,21,...,91\n        for (int i = 0; i < n; ++i) {\n            int multiple = rnd.next(0, 9) * 10;\n            ai[i] = multiple + 1;\n        }\n    } else if (type == \"descending\") {\n        // ai are in descending order from 100\n        int val = 100;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = max(0, val);\n            val -= rnd.next(0, 1);\n        }\n    } else if (type == \"ascending\") {\n        // ai are in ascending order from 0\n        int val = 0;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = min(100, val);\n            val += rnd.next(0, 1);\n        }\n    } else if (type == \"zeros_and_hundreds\") {\n        // ai are either 0 or 100\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0,1) * 100;\n        }\n    } else if (type == \"nines\") {\n        // ai are all 99\n        fill(ai.begin(), ai.end(), 99);\n    } else if (type == \"mix_near_multiples\") {\n        // ai are mixed around multiples of 10\n        for (int i = 0; i < n; ++i) {\n            int multiple = rnd.next(0, 10) * 10;\n            ai[i] = multiple + rnd.next(-1, 1);\n            ai[i] = max(0, min(100, ai[i]));\n        }\n    } else if (type == \"max_k\") {\n        // Random ai, maximal k\n        k = 10000000;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, 100);\n        }\n    } else if (type == \"zero_k\") {\n        // Random ai, k = 0\n        k = 0;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, 100);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, 100);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"random\") {\n        // Random ai between 0 and 100\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, 100);\n        }\n    } else if (type == \"min\") {\n        // ai are all 0\n        fill(ai.begin(), ai.end(), 0);\n    } else if (type == \"max\") {\n        // ai are all 100\n        fill(ai.begin(), ai.end(), 100);\n    } else if (type == \"just_below_multiple_of_10\") {\n        // ai are 9,19,29,...,99\n        for (int i = 0; i < n; ++i) {\n            int multiple = rnd.next(1, 10) * 10;\n            ai[i] = multiple - 1;\n        }\n    } else if (type == \"just_above_multiple_of_10\") {\n        // ai are 1,11,21,...,91\n        for (int i = 0; i < n; ++i) {\n            int multiple = rnd.next(0, 9) * 10;\n            ai[i] = multiple + 1;\n        }\n    } else if (type == \"descending\") {\n        // ai are in descending order from 100\n        int val = 100;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = max(0, val);\n            val -= rnd.next(0, 1);\n        }\n    } else if (type == \"ascending\") {\n        // ai are in ascending order from 0\n        int val = 0;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = min(100, val);\n            val += rnd.next(0, 1);\n        }\n    } else if (type == \"zeros_and_hundreds\") {\n        // ai are either 0 or 100\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0,1) * 100;\n        }\n    } else if (type == \"nines\") {\n        // ai are all 99\n        fill(ai.begin(), ai.end(), 99);\n    } else if (type == \"mix_near_multiples\") {\n        // ai are mixed around multiples of 10\n        for (int i = 0; i < n; ++i) {\n            int multiple = rnd.next(0, 10) * 10;\n            ai[i] = multiple + rnd.next(-1, 1);\n            ai[i] = max(0, min(100, ai[i]));\n        }\n    } else if (type == \"max_k\") {\n        // Random ai, maximal k\n        k = 10000000;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, 100);\n        }\n    } else if (type == \"zero_k\") {\n        // Random ai, k = 0\n        k = 0;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, 100);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, 100);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -k 0 -type random\n./gen -n 5 -k 10 -type random\n./gen -n 10 -k 100 -type min\n./gen -n 10 -k 100 -type max\n./gen -n 100 -k 1000 -type just_below_multiple_of_10\n./gen -n 100 -k 1000 -type just_above_multiple_of_10\n./gen -n 1000 -k 0 -type random\n./gen -n 1000 -k 100000 -type random\n./gen -n 1000 -k 100000 -type min\n./gen -n 1000 -k 100000 -type max\n./gen -n 10000 -k 500000 -type zeros_and_hundreds\n./gen -n 10000 -k 500000 -type nines\n./gen -n 100000 -k 1000000 -type mix_near_multiples\n./gen -n 100000 -k 0 -type random\n./gen -n 100000 -k 0 -type zero_k\n./gen -n 100000 -k 10000000 -type max_k\n./gen -n 100000 -k 10000000 -type just_below_multiple_of_10\n./gen -n 100000 -k 10000000 -type just_above_multiple_of_10\n./gen -n 100000 -k 10000000 -type mix_near_multiples\n./gen -n 100000 -k 0 -type just_below_multiple_of_10\n./gen -n 100000 -k 0 -type just_above_multiple_of_10\n./gen -n 100000 -k 5000000 -type descending\n./gen -n 100000 -k 5000000 -type ascending\n./gen -n 100000 -k 5000000 -type zeros_and_hundreds\n./gen -n 2 -k 100 -type random\n./gen -n 3 -k 8 -type just_below_multiple_of_10\n./gen -n 2 -k 2 -type nines\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:50.969722",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "581/D",
      "title": "D. Three Logos",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains six positive integers x1, y1, x2, y2, x3, y3 (1 ≤ x1, y1, x2, y2, x3, y3 ≤ 100), where xi and yi determine the length and width of the logo of the i-th company respectively.",
      "output_spec": "OutputIf it is impossible to place all the three logos on a square shield, print a single integer \"-1\" (without the quotes).If it is possible, print in the first line the length of a side of square n, where you can place all the three logos. Each of the next n lines should contain n uppercase English letters \"A\", \"B\" or \"C\". The sets of the same letters should form solid rectangles, provided that:  the sizes of the rectangle composed from letters \"A\" should be equal to the sizes of the logo of the first company,  the sizes of the rectangle composed from letters \"B\" should be equal to the sizes of the logo of the second company,  the sizes of the rectangle composed from letters \"C\" should be equal to the sizes of the logo of the third company, Note that the logos of the companies can be rotated for printing on the billboard. The billboard mustn't have any empty space. If a square billboard can be filled with the logos in multiple ways, you are allowed to print any of them.See the samples to better understand the statement.",
      "sample_tests": "ExamplesInputCopy5 1 2 5 5 2OutputCopy5AAAAABBBBBBBBBBCCCCCCCCCCInputCopy4 4 2 6 4 2OutputCopy6BBBBBBBBBBBBAAAACCAAAACCAAAACCAAAACC",
      "description": "D. Three Logos\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains six positive integers x1, y1, x2, y2, x3, y3 (1 ≤ x1, y1, x2, y2, x3, y3 ≤ 100), where xi and yi determine the length and width of the logo of the i-th company respectively.\n\nOutputIf it is impossible to place all the three logos on a square shield, print a single integer \"-1\" (without the quotes).If it is possible, print in the first line the length of a side of square n, where you can place all the three logos. Each of the next n lines should contain n uppercase English letters \"A\", \"B\" or \"C\". The sets of the same letters should form solid rectangles, provided that:  the sizes of the rectangle composed from letters \"A\" should be equal to the sizes of the logo of the first company,  the sizes of the rectangle composed from letters \"B\" should be equal to the sizes of the logo of the second company,  the sizes of the rectangle composed from letters \"C\" should be equal to the sizes of the logo of the third company, Note that the logos of the companies can be rotated for printing on the billboard. The billboard mustn't have any empty space. If a square billboard can be filled with the logos in multiple ways, you are allowed to print any of them.See the samples to better understand the statement.\n\nInputCopy5 1 2 5 5 2OutputCopy5AAAAABBBBBBBBBBCCCCCCCCCCInputCopy4 4 2 6 4 2OutputCopy6BBBBBBBBBBBBAAAACCAAAACCAAAACCAAAACC\n\nInputCopy5 1 2 5 5 2\n\nOutputCopy5AAAAABBBBBBBBBBCCCCCCCCCC\n\nInputCopy4 4 2 6 4 2\n\nOutputCopy6BBBBBBBBBBBBAAAACCAAAACCAAAACCAAAACC",
      "solutions": [
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #322 (Div. 2). It'll be held on Monday, September 28 at 12:00 MSK and as usual Div. 1 participants can join out of competition. Note that round starts in the unusual time!This round is held on the tasks of the school stage All-Russian Olympiad of Informatics 2015/2016 year in city Saratov. They were prepared by me and recently returned from army Edvard Davtyan (Edvard). Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to Vladimir Petrov (vovuh) for writing solutions.It will be a little unusual round — you will be given six problems and two hours to solve them. The scoring distribution will be announced later. Good luck everyone! UPD The scoring distribution today will be 500-1000-1500-2000-3000-3000.UPD2 EditorialUPD3 Congratulations to the winners! Moe for_the_pride SakurakoujiRuna VNOI z123z123d",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20522",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1069
        },
        {
          "title": "Codeforces Round #322 (Div.2) Editorial - Codeforces",
          "content": "581A — Vasya the HipsterThe first number in answer (number of days which Vasya can dress fashionably) is min(a, b) because every from this day he will dress one red sock and one blue sock.After this Vasya will have either only red socks or only blue socks or socks do not remain at all. Because of that the second number in answer is max((a - min(a, b)) / 2, (b - min(a, b)) / 2).Asymptotic behavior of this solution — O(1).581B — Luxurious HousesThis problem can be solved in the following way. Let's iterate on given array from the right to the left and will store in variable maxH the maximal height if house which we have already considered.Then the answer to house number i is number max(0, maxH + 1 - hi), where hi number of floors in house number i.Asymptotic behavior of this solution — O(n), where n — number of houses.581C — Developing SkillsThis problem can be solved in many ways. Let's consider the most intuitive way that fits in the given time.In the beginning we need to sort given array in the following way — from two numbers to the left should be the number to which must be added fewer units of improvements to make it a multiple of 10. You must add at least one unit of energy to every of this numbers. For example, if given array is {45, 30, 87, 26} after the sort the array must be equal to {87, 26, 45, 30}.Now we iterate on the sorted array for i from 1 to n. Let's cur = 10 - (aimod10). If cur ≤ k assign ai = ai + cur and from k subtract cur else if cur > k break from cycle.The next step is to iterate on array in the same way.Now we need only to calculate answer ans — we iterate on array for i from 1 to n and assign ans = ans + (ai / 10).Asymptotic behavior of this solution — O(n * log(n)) where n is the number of hero skills.581D — Three LogosThis problem can be solved in many ways, let's consider one of them.The first step is to calculate sum of squares s of given rectangles. Then the side of a answer square is sqrt(s). If sqrt(s) is not integer print -1. Else we need to make the following.We brute the order in which we will add given rectangles in the answer square (we can do it with help of next_permutation()) and for every order we brute will we rotate current rectangle on 90 degrees or not (we can do it with help of bit masks). In the beginning on every iteration the answer square c in which we add the rectangles is empty.For every rectangle, which we add to the answer square we make the following — we need to find the uppermost and leftmost empty cell free in answer square c (recall that we also brute will we rotate the current rectangle on 90 degrees or not). Now we try to impose current rectangle in the answer square c and the top left corner must coinside with the cell free. If current rectangle fully placed in the answer square c and does not intersect with the some rectangle which has already been added, we need to fill by the required letter appropriate cells in the answer square c.If no one of the conditions did not disrupted after we added all three rectangles and all answer square c is fully filled by letters we found answer and we neeed only to print the answer square c.Else if we did not find answer after all iterations on the rectangles — print -1.For random number of the rectangles k asymptotic behavior — O(k! * 2k * s) where s — the sum of squares of the given rectangles.Also this problem with 3 rectangles can be solved with the analysis of the cases with asymptotic O(s) where s — the sum of squares of given rectangles.581E — Kojiro and FurrariLet's f — the position of start, and e — the position of finish. For convenience of implementation we add the gas-station in point e with type equals to 3.Note: there is never a sense go to the left of the starting point because we already stand with a full tank of the besr petrol. It is correct for every gas-station in which we can appear (if in optimal answer we must go to the left in some gas-station pv, why not throw out all the way from pv to current gas-station v and back and after that the answer will be better). Now let's say about algorithm when we are in some gas-station v.The first case: on distance no more than s there is the gas-station with quality of gasoline not worse, than in the current gas-station. Now we fix nearest from them nv (nearest to the right because go to the left as we understand makes no sense). In that case we refuel in such a way to can reach nv and go to nv.The second case: from the current gas-station we can reach only gas-station with the worst quality (the type of the current gas-station can be 2 or 3). If we are in the gas-station of type 2 we need to refuel on maximum possiblevalue and go in the last achievable gas-station. If we are in the gas-station with type 3, we need to go in the farthest gas-station with type 2, but if there is not such gas-station we need to go to the farthest gas-station with type 1. This reasoning are correct because we first need to minimze the count of fuel with type 1, and the second to minimize the count of fuel with type 2.This basic reasoning necessary to solve the problem. The next step — calc dynamic on all suffixes i of gas-stations — the answer to the problem if we start from the gas-station i with empty tank. We need to make updates, considering the above cases. For update the dynamic in v we need to take the value of dynamic in nv and make update in addiction of the case. If the case is equals to 1, we need to add to appropriate value the distance d from v to nv. If this case is equals to 2 and we are in the gas-station with type equals to 2 we need to add s to the second value of answer, and from the first value we need to substract s–d. If it is the case number 2 and we are in the gas-station with type equals to 3, we need to substract from the value, which determined by the type of the gas-station nv, s–d.Now to answer on specific query of the starting position we nned to find the first gas-station which is to the right of the startiong position, make one update and take the value of dynamic, which already calculated, and recalculate this value in accordance with the above.Asymptotic behavior — O(n logn) or O(n) in case how we find position in the list of gas-stations (the first in case of binary search, the second in case of two pointers).To this solution we need O(n) memory.581F — Zublicanes and MumocratesLet the number of leavs in tree (vertices with degree 1) is equal to c. It said in statement that c is even. If in given graph only 2 vertices the answer is equal to 1. Else we have vertex in graph which do not a leaf — we hang the three on this vertex.Now we need to count 2 dynamics. The first z1[v][cnt][col] — the least amount of colored edges in the subtree rooted at the vertex v, if vertex v already painted in color col (col equals to 0 or to 1), and among the top of the leaves of the subtree v must be exactly cnt vertices with color 0. If we are in the leaf, it is easy to count this value. If we are not in the leaf — we count value with help of dynamic z1[v][cnt][col]:  = z2[s][cnt][col], where s — the first child int the adjacency list of vertex v.We need the second dynamic z2[s][cnt][col] to spread cnt leaves with color 0 among subtrees of childs of vertex v. To calc z2[s][cnt][col] we brute the color of child s — ncol and the number of childs i with color 0, which will be locate in subtree of vertex s and calc the value in the following way — z2[s][cnt][col] = min(z2[s][cnt][col], z2[ns][cnt–a][col] + z1[s][a][ncol] + (ncol! = col)), where ns — the next child of vertex v after the child s. Note, that it is senselessly to take a more than the number of leaves in the subtree s and to take more than the number of vertices in subtree — sizes (because in that case it will not be enough leaves for painting).The upper bound of asymptotic for such dynamics O(n3). We show that in fact it works with asymptotic O(n2). Let's count the number of updates: . Note, that every pair of vertices (x, y) appears in the last sum (x, y) exactly once when v = lca(x, y). So we have no more than O(n2) updates.Asymptotic behavior of this solution: O(n2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20508",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 581\\s*D"
          },
          "content_length": 8135
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 1",
          "code": "0 1 2\nand\n0 0\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 2",
          "code": "0 1 2\nand\n0 0\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 3",
          "code": "(int)floor((double)skill[i].rat/10.0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 4",
          "code": "(int)floor((double)skill[i].rat/10.0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 5",
          "code": "skill[i].rat / 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 6",
          "code": "skill[i].rat / 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div.2) Editorial - Codeforces - Code 1",
          "code": "4999\n1 2\n2 3\n...\n2499 2500\n2500 2501\n2500 2502\n...\n2500 4999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div.2) Editorial - Codeforces - Code 2",
          "code": "4999\n1 2\n2 3\n...\n2499 2500\n2500 2501\n2500 2502\n...\n2500 4999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20508",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x1 = inf.readInt(1, 100, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(1, 100, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(1, 100, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(1, 100, \"y2\");\n    inf.readSpace();\n    int x3 = inf.readInt(1, 100, \"x3\");\n    inf.readSpace();\n    int y3 = inf.readInt(1, 100, \"y3\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x1 = inf.readInt(1, 100, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(1, 100, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(1, 100, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(1, 100, \"y2\");\n    inf.readSpace();\n    int x3 = inf.readInt(1, 100, \"x3\");\n    inf.readSpace();\n    int y3 = inf.readInt(1, 100, \"y3\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x1 = inf.readInt(1, 100, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(1, 100, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(1, 100, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(1, 100, \"y2\");\n    inf.readSpace();\n    int x3 = inf.readInt(1, 100, \"x3\");\n    inf.readSpace();\n    int y3 = inf.readInt(1, 100, \"y3\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    // Read input from inf\n    int x[3], y[3];\n    x[0] = inf.readInt(1, 100);\n    y[0] = inf.readInt(1, 100);\n    x[1] = inf.readInt(1, 100);\n    y[1] = inf.readInt(1, 100);\n    x[2] = inf.readInt(1, 100);\n    y[2] = inf.readInt(1, 100);\n    \n    // Read participant's output\n    int n = ouf.readInt(-1, 300, \"n\");\n    if (n == -1) {\n        // Accept the answer\n        quitf(_ok, \"Participant outputs -1\");\n    } else if (n <= 0) {\n        quitf(_wa, \"n should be positive or -1\");\n    } else {\n        // Read n lines\n        vector<string> grid(n);\n        for (int i = 0; i < n; i++) {\n            grid[i] = ouf.readToken();\n            if ((int)grid[i].length() != n) {\n                quitf(_wa, \"Line %d length is not equal to n\", i+1);\n            }\n            for (char c : grid[i]) {\n                if (c != 'A' && c != 'B' && c != 'C') {\n                    quitf(_wa, \"Invalid character '%c' in grid\", c);\n                }\n            }\n        }\n        // Now process the grid\n        vector<vector<char>> g(n, vector<char>(n));\n        vector<vector<bool>> used(n, vector<bool>(n, false));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                g[i][j] = grid[i][j];\n            }\n        }\n        // Map letters to companies\n        char letters[3] = {'A', 'B', 'C'};\n        for (int k = 0; k < 3; k++) {\n            char letter = letters[k];\n            int minRow = n, maxRow = -1, minCol = n, maxCol = -1;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (g[i][j] == letter) {\n                        minRow = min(minRow, i);\n                        maxRow = max(maxRow, i);\n                        minCol = min(minCol, j);\n                        maxCol = max(maxCol, j);\n                    }\n                }\n            }\n            if (minRow > maxRow || minCol > maxCol) {\n                quitf(_wa, \"Letter '%c' does not appear in the grid\", letter);\n            }\n            int height = maxRow - minRow + 1;\n            int width = maxCol - minCol + 1;\n            bool found = false;\n            if ((height == x[k] && width == y[k]) || (height == y[k] && width == x[k])) {\n                found = true;\n            }\n            if (!found) {\n                quitf(_wa, \"Rectangle for letter '%c' has incorrect dimensions\", letter);\n            }\n            // Check that rectangle is filled with the same letter and doesn't overlap\n            for (int i = minRow; i <= maxRow; i++) {\n                for (int j = minCol; j <= maxCol; j++) {\n                    if (g[i][j] != letter) {\n                        quitf(_wa, \"Rectangle for letter '%c' is not solid\", letter);\n                    }\n                    if (used[i][j]) {\n                        quitf(_wa, \"Cell (%d,%d) is covered multiple times\", i+1, j+1);\n                    }\n                    used[i][j] = true;\n                }\n            }\n        }\n        // Check that all cells are covered\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!used[i][j]) {\n                    quitf(_wa, \"Cell (%d,%d) is not covered by any rectangle\", i+1, j+1);\n                }\n            }\n        }\n        // All checks passed\n        quitf(_ok, \"Participant's solution is correct\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\"); // possibleNoRotation, possibleRotation, impossible\n    int maxSize = opt<int>(\"maxSize\", 100);\n\n    if (type == \"possibleNoRotation\") {\n\n        // Generate N between 3 and min(100, maxSize)\n        int N_max = min(100, maxSize);\n        int N = rnd.next(3, N_max);\n\n        // Divide N into three positive integers w1, w2, w3 such that w1 + w2 + w3 = N\n        vector<int> widths(3);\n        int rem = N;\n\n        for (int i = 0; i < 2; ++i) {\n            widths[i] = rnd.next(1, rem - (2 - i)); // ensure that at least 1 is left for the remaining widths\n            rem -= widths[i];\n        }\n        widths[2] = rem;\n\n        // Heights are all N\n        int h1 = N, h2 = N, h3 = N;\n\n        // xi = wi, yi = hi\n        int x1 = widths[0], y1 = h1;\n        int x2 = widths[1], y2 = h2;\n        int x3 = widths[2], y3 = h3;\n\n        // Output xi yi\n        printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n\n    } else if (type == \"possibleRotation\") {\n\n        // Generate N between 3 and min(100, maxSize)\n        int N_max = min(100, maxSize);\n        int N = rnd.next(3, N_max);\n\n        // Generate heights\n        int h1 = rnd.next(1, N - 1);\n        int w1 = N;\n\n        int h2 = N - h1;\n        int h3 = h2;\n\n        // Widths w2 and w3 such that w2 + w3 = N\n        int w2 = rnd.next(1, N - 1);\n        int w3 = N - w2;\n\n        // Swap dimensions to require rotation for logo 2\n        int x1 = w1, y1 = h1;\n        int x2 = h2, y2 = w2; // Logo 2 needs to be rotated\n        int x3 = w3, y3 = h3;\n\n        // Output xi yi\n        printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n\n    } else if (type == \"impossible\") {\n\n        int x1 = rnd.next(1, maxSize);\n        int y1 = rnd.next(1, maxSize);\n        int x2 = rnd.next(1, maxSize);\n        int y2 = rnd.next(1, maxSize);\n        int x3 = rnd.next(1, maxSize);\n        int y3 = rnd.next(1, maxSize);\n\n        int area = x1 * y1 + x2 * y2 + x3 * y3;\n        int n = sqrt(area);\n        if (n * n == area) {\n            // Adjust to make area not a perfect square\n            x3 = min(x3 + 1, maxSize);\n        }\n\n        // Output xi yi\n        printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n\n    } else {\n        // Invalid type\n        fprintf(stderr, \"Invalid type specified\\n\");\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\"); // possibleNoRotation, possibleRotation, impossible\n    int maxSize = opt<int>(\"maxSize\", 100);\n\n    if (type == \"possibleNoRotation\") {\n\n        // Generate N between 3 and min(100, maxSize)\n        int N_max = min(100, maxSize);\n        int N = rnd.next(3, N_max);\n\n        // Divide N into three positive integers w1, w2, w3 such that w1 + w2 + w3 = N\n        vector<int> widths(3);\n        int rem = N;\n\n        for (int i = 0; i < 2; ++i) {\n            widths[i] = rnd.next(1, rem - (2 - i)); // ensure that at least 1 is left for the remaining widths\n            rem -= widths[i];\n        }\n        widths[2] = rem;\n\n        // Heights are all N\n        int h1 = N, h2 = N, h3 = N;\n\n        // xi = wi, yi = hi\n        int x1 = widths[0], y1 = h1;\n        int x2 = widths[1], y2 = h2;\n        int x3 = widths[2], y3 = h3;\n\n        // Output xi yi\n        printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n\n    } else if (type == \"possibleRotation\") {\n\n        // Generate N between 3 and min(100, maxSize)\n        int N_max = min(100, maxSize);\n        int N = rnd.next(3, N_max);\n\n        // Generate heights\n        int h1 = rnd.next(1, N - 1);\n        int w1 = N;\n\n        int h2 = N - h1;\n        int h3 = h2;\n\n        // Widths w2 and w3 such that w2 + w3 = N\n        int w2 = rnd.next(1, N - 1);\n        int w3 = N - w2;\n\n        // Swap dimensions to require rotation for logo 2\n        int x1 = w1, y1 = h1;\n        int x2 = h2, y2 = w2; // Logo 2 needs to be rotated\n        int x3 = w3, y3 = h3;\n\n        // Output xi yi\n        printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n\n    } else if (type == \"impossible\") {\n\n        int x1 = rnd.next(1, maxSize);\n        int y1 = rnd.next(1, maxSize);\n        int x2 = rnd.next(1, maxSize);\n        int y2 = rnd.next(1, maxSize);\n        int x3 = rnd.next(1, maxSize);\n        int y3 = rnd.next(1, maxSize);\n\n        int area = x1 * y1 + x2 * y2 + x3 * y3;\n        int n = sqrt(area);\n        if (n * n == area) {\n            // Adjust to make area not a perfect square\n            x3 = min(x3 + 1, maxSize);\n        }\n\n        // Output xi yi\n        printf(\"%d %d %d %d %d %d\\n\", x1, y1, x2, y2, x3, y3);\n\n    } else {\n        // Invalid type\n        fprintf(stderr, \"Invalid type specified\\n\");\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type possibleNoRotation -maxSize 5\n./gen -type possibleNoRotation -maxSize 10\n./gen -type possibleNoRotation -maxSize 20\n./gen -type possibleNoRotation -maxSize 50\n./gen -type possibleNoRotation -maxSize 100\n\n./gen -type possibleRotation -maxSize 5\n./gen -type possibleRotation -maxSize 10\n./gen -type possibleRotation -maxSize 20\n./gen -type possibleRotation -maxSize 50\n./gen -type possibleRotation -maxSize 100\n\n./gen -type impossible -maxSize 5\n./gen -type impossible -maxSize 10\n./gen -type impossible -maxSize 20\n./gen -type impossible -maxSize 50\n./gen -type impossible -maxSize 100\n\n./gen -type possibleNoRotation -maxSize 25\n./gen -type possibleRotation -maxSize 25\n./gen -type impossible -maxSize 25\n\n./gen -type possibleNoRotation -maxSize 75\n./gen -type possibleRotation -maxSize 75\n./gen -type impossible -maxSize 75\n\n./gen -type possibleNoRotation -maxSize 30\n./gen -type possibleRotation -maxSize 30\n./gen -type impossible -maxSize 30\n\n./gen -type possibleNoRotation -maxSize 15\n./gen -type possibleRotation -maxSize 15\n./gen -type impossible -maxSize 15\n\n./gen -type possibleNoRotation -maxSize 3\n./gen -type possibleNoRotation -maxSize 4\n\n./gen -type possibleRotation -maxSize 3\n./gen -type possibleRotation -maxSize 4\n\n./gen -type impossible -maxSize 3\n./gen -type impossible -maxSize 4\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:52.702076",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "581/E",
      "title": "E. Kojiro and Furrari",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains four positive integers e, s, n, m (1 ≤ e, s ≤ 109, 1 ≤ n, m ≤ 2·105) — the coordinate of the point where Johanna is, the capacity of a Furrari tank, the number of gas stations and the number of starting points. Next n lines contain two integers each ti, xi (1 ≤ ti ≤ 3,  - 109 ≤ xi ≤ 109), representing the type of the i-th gas station (1 represents Regular-92, 2 — Premium-95 and 3 — Super-98) and the position on a coordinate line of the i-th gas station. Gas stations don't necessarily follow in order from left to right.The last line contains m integers fi ( - 109 ≤ fi < e). Start positions don't necessarily follow in order from left to right.No point of the coordinate line contains more than one gas station. It is possible that some of points fi or point e coincide with a gas station.",
      "output_spec": "OutputPrint exactly m lines. The i-th of them should contain two integers — the minimum amount of gas of type Regular-92 and type Premium-95, if Kojiro starts at point fi. First you need to minimize the first value. If there are multiple ways to do it, you need to also minimize the second value.If there is no way to get to Johanna from point fi, the i-th line should look like that \"-1 -1\" (two numbers minus one without the quotes).",
      "sample_tests": "ExamplesInputCopy8 4 1 12 40OutputCopy0 4InputCopy9 3 2 32 31 6-1 0 1OutputCopy-1 -13 33 2InputCopy20 9 2 41 52 10-1 0 1 2OutputCopy-1 -1-1 -1-1 -1-1 -1",
      "description": "E. Kojiro and Furrari\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains four positive integers e, s, n, m (1 ≤ e, s ≤ 109, 1 ≤ n, m ≤ 2·105) — the coordinate of the point where Johanna is, the capacity of a Furrari tank, the number of gas stations and the number of starting points. Next n lines contain two integers each ti, xi (1 ≤ ti ≤ 3,  - 109 ≤ xi ≤ 109), representing the type of the i-th gas station (1 represents Regular-92, 2 — Premium-95 and 3 — Super-98) and the position on a coordinate line of the i-th gas station. Gas stations don't necessarily follow in order from left to right.The last line contains m integers fi ( - 109 ≤ fi < e). Start positions don't necessarily follow in order from left to right.No point of the coordinate line contains more than one gas station. It is possible that some of points fi or point e coincide with a gas station.\n\nOutputPrint exactly m lines. The i-th of them should contain two integers — the minimum amount of gas of type Regular-92 and type Premium-95, if Kojiro starts at point fi. First you need to minimize the first value. If there are multiple ways to do it, you need to also minimize the second value.If there is no way to get to Johanna from point fi, the i-th line should look like that \"-1 -1\" (two numbers minus one without the quotes).\n\nInputCopy8 4 1 12 40OutputCopy0 4InputCopy9 3 2 32 31 6-1 0 1OutputCopy-1 -13 33 2InputCopy20 9 2 41 52 10-1 0 1 2OutputCopy-1 -1-1 -1-1 -1-1 -1\n\nInputCopy8 4 1 12 40\n\nOutputCopy0 4\n\nInputCopy9 3 2 32 31 6-1 0 1\n\nOutputCopy-1 -13 33 2\n\nInputCopy20 9 2 41 52 10-1 0 1 2\n\nOutputCopy-1 -1-1 -1-1 -1-1 -1",
      "solutions": [
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #322 (Div. 2). It'll be held on Monday, September 28 at 12:00 MSK and as usual Div. 1 participants can join out of competition. Note that round starts in the unusual time!This round is held on the tasks of the school stage All-Russian Olympiad of Informatics 2015/2016 year in city Saratov. They were prepared by me and recently returned from army Edvard Davtyan (Edvard). Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to Vladimir Petrov (vovuh) for writing solutions.It will be a little unusual round — you will be given six problems and two hours to solve them. The scoring distribution will be announced later. Good luck everyone! UPD The scoring distribution today will be 500-1000-1500-2000-3000-3000.UPD2 EditorialUPD3 Congratulations to the winners! Moe for_the_pride SakurakoujiRuna VNOI z123z123d",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20522",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1069
        },
        {
          "title": "Codeforces Round #322 (Div.2) Editorial - Codeforces",
          "content": "581A — Vasya the HipsterThe first number in answer (number of days which Vasya can dress fashionably) is min(a, b) because every from this day he will dress one red sock and one blue sock.After this Vasya will have either only red socks or only blue socks or socks do not remain at all. Because of that the second number in answer is max((a - min(a, b)) / 2, (b - min(a, b)) / 2).Asymptotic behavior of this solution — O(1).581B — Luxurious HousesThis problem can be solved in the following way. Let's iterate on given array from the right to the left and will store in variable maxH the maximal height if house which we have already considered.Then the answer to house number i is number max(0, maxH + 1 - hi), where hi number of floors in house number i.Asymptotic behavior of this solution — O(n), where n — number of houses.581C — Developing SkillsThis problem can be solved in many ways. Let's consider the most intuitive way that fits in the given time.In the beginning we need to sort given array in the following way — from two numbers to the left should be the number to which must be added fewer units of improvements to make it a multiple of 10. You must add at least one unit of energy to every of this numbers. For example, if given array is {45, 30, 87, 26} after the sort the array must be equal to {87, 26, 45, 30}.Now we iterate on the sorted array for i from 1 to n. Let's cur = 10 - (aimod10). If cur ≤ k assign ai = ai + cur and from k subtract cur else if cur > k break from cycle.The next step is to iterate on array in the same way.Now we need only to calculate answer ans — we iterate on array for i from 1 to n and assign ans = ans + (ai / 10).Asymptotic behavior of this solution — O(n * log(n)) where n is the number of hero skills.581D — Three LogosThis problem can be solved in many ways, let's consider one of them.The first step is to calculate sum of squares s of given rectangles. Then the side of a answer square is sqrt(s). If sqrt(s) is not integer print -1. Else we need to make the following.We brute the order in which we will add given rectangles in the answer square (we can do it with help of next_permutation()) and for every order we brute will we rotate current rectangle on 90 degrees or not (we can do it with help of bit masks). In the beginning on every iteration the answer square c in which we add the rectangles is empty.For every rectangle, which we add to the answer square we make the following — we need to find the uppermost and leftmost empty cell free in answer square c (recall that we also brute will we rotate the current rectangle on 90 degrees or not). Now we try to impose current rectangle in the answer square c and the top left corner must coinside with the cell free. If current rectangle fully placed in the answer square c and does not intersect with the some rectangle which has already been added, we need to fill by the required letter appropriate cells in the answer square c.If no one of the conditions did not disrupted after we added all three rectangles and all answer square c is fully filled by letters we found answer and we neeed only to print the answer square c.Else if we did not find answer after all iterations on the rectangles — print -1.For random number of the rectangles k asymptotic behavior — O(k! * 2k * s) where s — the sum of squares of the given rectangles.Also this problem with 3 rectangles can be solved with the analysis of the cases with asymptotic O(s) where s — the sum of squares of given rectangles.581E — Kojiro and FurrariLet's f — the position of start, and e — the position of finish. For convenience of implementation we add the gas-station in point e with type equals to 3.Note: there is never a sense go to the left of the starting point because we already stand with a full tank of the besr petrol. It is correct for every gas-station in which we can appear (if in optimal answer we must go to the left in some gas-station pv, why not throw out all the way from pv to current gas-station v and back and after that the answer will be better). Now let's say about algorithm when we are in some gas-station v.The first case: on distance no more than s there is the gas-station with quality of gasoline not worse, than in the current gas-station. Now we fix nearest from them nv (nearest to the right because go to the left as we understand makes no sense). In that case we refuel in such a way to can reach nv and go to nv.The second case: from the current gas-station we can reach only gas-station with the worst quality (the type of the current gas-station can be 2 or 3). If we are in the gas-station of type 2 we need to refuel on maximum possiblevalue and go in the last achievable gas-station. If we are in the gas-station with type 3, we need to go in the farthest gas-station with type 2, but if there is not such gas-station we need to go to the farthest gas-station with type 1. This reasoning are correct because we first need to minimze the count of fuel with type 1, and the second to minimize the count of fuel with type 2.This basic reasoning necessary to solve the problem. The next step — calc dynamic on all suffixes i of gas-stations — the answer to the problem if we start from the gas-station i with empty tank. We need to make updates, considering the above cases. For update the dynamic in v we need to take the value of dynamic in nv and make update in addiction of the case. If the case is equals to 1, we need to add to appropriate value the distance d from v to nv. If this case is equals to 2 and we are in the gas-station with type equals to 2 we need to add s to the second value of answer, and from the first value we need to substract s–d. If it is the case number 2 and we are in the gas-station with type equals to 3, we need to substract from the value, which determined by the type of the gas-station nv, s–d.Now to answer on specific query of the starting position we nned to find the first gas-station which is to the right of the startiong position, make one update and take the value of dynamic, which already calculated, and recalculate this value in accordance with the above.Asymptotic behavior — O(n logn) or O(n) in case how we find position in the list of gas-stations (the first in case of binary search, the second in case of two pointers).To this solution we need O(n) memory.581F — Zublicanes and MumocratesLet the number of leavs in tree (vertices with degree 1) is equal to c. It said in statement that c is even. If in given graph only 2 vertices the answer is equal to 1. Else we have vertex in graph which do not a leaf — we hang the three on this vertex.Now we need to count 2 dynamics. The first z1[v][cnt][col] — the least amount of colored edges in the subtree rooted at the vertex v, if vertex v already painted in color col (col equals to 0 or to 1), and among the top of the leaves of the subtree v must be exactly cnt vertices with color 0. If we are in the leaf, it is easy to count this value. If we are not in the leaf — we count value with help of dynamic z1[v][cnt][col]:  = z2[s][cnt][col], where s — the first child int the adjacency list of vertex v.We need the second dynamic z2[s][cnt][col] to spread cnt leaves with color 0 among subtrees of childs of vertex v. To calc z2[s][cnt][col] we brute the color of child s — ncol and the number of childs i with color 0, which will be locate in subtree of vertex s and calc the value in the following way — z2[s][cnt][col] = min(z2[s][cnt][col], z2[ns][cnt–a][col] + z1[s][a][ncol] + (ncol! = col)), where ns — the next child of vertex v after the child s. Note, that it is senselessly to take a more than the number of leaves in the subtree s and to take more than the number of vertices in subtree — sizes (because in that case it will not be enough leaves for painting).The upper bound of asymptotic for such dynamics O(n3). We show that in fact it works with asymptotic O(n2). Let's count the number of updates: . Note, that every pair of vertices (x, y) appears in the last sum (x, y) exactly once when v = lca(x, y). So we have no more than O(n2) updates.Asymptotic behavior of this solution: O(n2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20508",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 581\\s*E"
          },
          "content_length": 8135
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 1",
          "code": "0 1 2\nand\n0 0\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 2",
          "code": "0 1 2\nand\n0 0\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 3",
          "code": "(int)floor((double)skill[i].rat/10.0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 4",
          "code": "(int)floor((double)skill[i].rat/10.0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 5",
          "code": "skill[i].rat / 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 6",
          "code": "skill[i].rat / 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div.2) Editorial - Codeforces - Code 1",
          "code": "4999\n1 2\n2 3\n...\n2499 2500\n2500 2501\n2500 2502\n...\n2500 4999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div.2) Editorial - Codeforces - Code 2",
          "code": "4999\n1 2\n2 3\n...\n2499 2500\n2500 2501\n2500 2502\n...\n2500 4999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20508",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long e = inf.readLong(1LL, 1000000000LL, \"e\");\n    inf.readSpace();\n    long long s = inf.readLong(1LL, 1000000000LL, \"s\");\n    inf.readSpace();\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    set<long long> station_positions;\n\n    for (int i = 0; i < n; ++i) {\n        int ti = inf.readInt(1, 3, \"ti\");\n        inf.readSpace();\n        long long xi = inf.readLong(-1000000000LL, 1000000000LL, \"xi\");\n        inf.readEoln();\n\n        ensuref(station_positions.count(xi) == 0, \"Gas station at position %lld occurs more than once\", xi);\n        station_positions.insert(xi);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        long long fi = inf.readLong(-1000000000LL, e - 1, \"fi\");\n    }\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long e = inf.readLong(1LL, 1000000000LL, \"e\");\n    inf.readSpace();\n    long long s = inf.readLong(1LL, 1000000000LL, \"s\");\n    inf.readSpace();\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    set<long long> station_positions;\n\n    for (int i = 0; i < n; ++i) {\n        int ti = inf.readInt(1, 3, \"ti\");\n        inf.readSpace();\n        long long xi = inf.readLong(-1000000000LL, 1000000000LL, \"xi\");\n        inf.readEoln();\n\n        ensuref(station_positions.count(xi) == 0, \"Gas station at position %lld occurs more than once\", xi);\n        station_positions.insert(xi);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        long long fi = inf.readLong(-1000000000LL, e - 1, \"fi\");\n    }\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long e = inf.readLong(1LL, 1000000000LL, \"e\");\n    inf.readSpace();\n    long long s = inf.readLong(1LL, 1000000000LL, \"s\");\n    inf.readSpace();\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    set<long long> station_positions;\n\n    for (int i = 0; i < n; ++i) {\n        int ti = inf.readInt(1, 3, \"ti\");\n        inf.readSpace();\n        long long xi = inf.readLong(-1000000000LL, 1000000000LL, \"xi\");\n        inf.readEoln();\n\n        ensuref(station_positions.count(xi) == 0, \"Gas station at position %lld occurs more than once\", xi);\n        station_positions.insert(xi);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        long long fi = inf.readLong(-1000000000LL, e - 1, \"fi\");\n    }\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_COORD = (int)1e9;\n\nvoid generateGasStations(int n, vector<int> &xi, vector<int> &ti, string gas_type, set<int> &positions_used) {\n    xi.resize(n);\n    ti.resize(n);\n    for (int i = 0; i < n; ++i) {\n        int pos;\n        do {\n            pos = rnd.next(-MAX_COORD, MAX_COORD);\n        } while (positions_used.count(pos));\n        positions_used.insert(pos);\n        xi[i] = pos;\n        if (gas_type == \"all_regular\") {\n            ti[i] = 1;\n        } else if (gas_type == \"all_premium\") {\n            ti[i] = 2;\n        } else if (gas_type == \"all_super\") {\n            ti[i] = 3;\n        } else { // \"random\"\n            ti[i] = rnd.next(1, 3);\n        }\n    }\n}\n\nvoid generateStartingPositions(int m, vector<int> &fi, string position_type, set<int> &positions_used, int e) {\n    fi.resize(m);\n    for (int i = 0; i < m; ++i) {\n        if (position_type == \"random\") {\n            fi[i] = rnd.next(-MAX_COORD, e - 1);\n        } else if (position_type == \"start_at_gas_station\") {\n            // Positions are same as gas station positions\n            vector<int> gas_positions(positions_used.begin(), positions_used.end());\n            gas_positions.erase(remove(gas_positions.begin(), gas_positions.end(), e), gas_positions.end());\n            fi[i] = gas_positions[rnd.next(0, (int)gas_positions.size() - 1)];\n        } else if (position_type == \"negative_positions\") {\n            fi[i] = rnd.next(-MAX_COORD, min(-1, e - 1));\n        } else if (position_type == \"near_e\") {\n            fi[i] = rnd.next(max(-MAX_COORD, e - 100), e - 1);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int e = opt<int>(\"e\", rnd.next(1, MAX_COORD));\n    int s = opt<int>(\"s\", rnd.next(1, MAX_COORD));\n    int n = opt<int>(\"n\", rnd.next(1, 200000));\n    int m = opt<int>(\"m\", rnd.next(1, 200000));\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi;\n    vector<int> ti;\n    vector<int> fi;\n    set<int> positions_used;\n    positions_used.insert(e);\n\n    if (type == \"random\") {\n        generateGasStations(n, xi, ti, \"random\", positions_used);\n        generateStartingPositions(m, fi, \"random\", positions_used, e);\n    } else if (type == \"all_regular\") {\n        generateGasStations(n, xi, ti, \"all_regular\", positions_used);\n        generateStartingPositions(m, fi, \"random\", positions_used, e);\n    } else if (type == \"all_premium\") {\n        generateGasStations(n, xi, ti, \"all_premium\", positions_used);\n        generateStartingPositions(m, fi, \"random\", positions_used, e);\n    } else if (type == \"all_super\") {\n        generateGasStations(n, xi, ti, \"all_super\", positions_used);\n        generateStartingPositions(m, fi, \"random\", positions_used, e);\n    } else if (type == \"path_force_regular\") {\n        e = 1000;\n        s = 500;\n        n = 1;\n        xi.resize(n);\n        ti.resize(n);\n        xi[0] = 500;\n        ti[0] = 1; // Regular-92\n        positions_used.insert(xi[0]);\n        fi.resize(1);\n        fi[0] = 0;\n        m = 1;\n    } else if (type == \"no_gas_stations\") {\n        n = 0;\n        xi.clear();\n        ti.clear();\n        generateStartingPositions(m, fi, \"random\", positions_used, e);\n    } else if (type == \"start_at_gas_station\") {\n        generateGasStations(n, xi, ti, \"random\", positions_used);\n        generateStartingPositions(m, fi, \"start_at_gas_station\", positions_used, e);\n    } else if (type == \"negative_positions\") {\n        generateGasStations(n, xi, ti, \"random\", positions_used);\n        for (int &pos : xi) {\n            if (pos >= 0) pos = -pos - 1; // Ensure negative positions\n        }\n        generateStartingPositions(m, fi, \"negative_positions\", positions_used, e);\n    } else if (type == \"gas_stations_at_limits\") {\n        e = 100;\n        s = 10;\n        m = 1;\n        fi.resize(1);\n        fi[0] = 0;\n        n = 9;\n        xi.resize(n);\n        ti.resize(n);\n        for (int i = 0; i < n; ++i) {\n            xi[i] = (i + 1) * 10;\n            positions_used.insert(xi[i]);\n            ti[i] = rnd.next(1, 3);\n        }\n    } else if (type == \"max_n_m\") {\n        n = 200000;\n        m = 200000;\n        e = MAX_COORD;\n        s = MAX_COORD;\n        generateGasStations(n, xi, ti, \"random\", positions_used);\n        generateStartingPositions(m, fi, \"random\", positions_used, e);\n    } else {\n        // Default is random\n        generateGasStations(n, xi, ti, \"random\", positions_used);\n        generateStartingPositions(m, fi, \"random\", positions_used, e);\n    }\n\n    printf(\"%d %d %d %d\\n\", e, s, n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", ti[i], xi[i]);\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", fi[i]);\n        if (i < m - 1) putchar(' ');\n    }\n    putchar('\\n');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_COORD = (int)1e9;\n\nvoid generateGasStations(int n, vector<int> &xi, vector<int> &ti, string gas_type, set<int> &positions_used) {\n    xi.resize(n);\n    ti.resize(n);\n    for (int i = 0; i < n; ++i) {\n        int pos;\n        do {\n            pos = rnd.next(-MAX_COORD, MAX_COORD);\n        } while (positions_used.count(pos));\n        positions_used.insert(pos);\n        xi[i] = pos;\n        if (gas_type == \"all_regular\") {\n            ti[i] = 1;\n        } else if (gas_type == \"all_premium\") {\n            ti[i] = 2;\n        } else if (gas_type == \"all_super\") {\n            ti[i] = 3;\n        } else { // \"random\"\n            ti[i] = rnd.next(1, 3);\n        }\n    }\n}\n\nvoid generateStartingPositions(int m, vector<int> &fi, string position_type, set<int> &positions_used, int e) {\n    fi.resize(m);\n    for (int i = 0; i < m; ++i) {\n        if (position_type == \"random\") {\n            fi[i] = rnd.next(-MAX_COORD, e - 1);\n        } else if (position_type == \"start_at_gas_station\") {\n            // Positions are same as gas station positions\n            vector<int> gas_positions(positions_used.begin(), positions_used.end());\n            gas_positions.erase(remove(gas_positions.begin(), gas_positions.end(), e), gas_positions.end());\n            fi[i] = gas_positions[rnd.next(0, (int)gas_positions.size() - 1)];\n        } else if (position_type == \"negative_positions\") {\n            fi[i] = rnd.next(-MAX_COORD, min(-1, e - 1));\n        } else if (position_type == \"near_e\") {\n            fi[i] = rnd.next(max(-MAX_COORD, e - 100), e - 1);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int e = opt<int>(\"e\", rnd.next(1, MAX_COORD));\n    int s = opt<int>(\"s\", rnd.next(1, MAX_COORD));\n    int n = opt<int>(\"n\", rnd.next(1, 200000));\n    int m = opt<int>(\"m\", rnd.next(1, 200000));\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi;\n    vector<int> ti;\n    vector<int> fi;\n    set<int> positions_used;\n    positions_used.insert(e);\n\n    if (type == \"random\") {\n        generateGasStations(n, xi, ti, \"random\", positions_used);\n        generateStartingPositions(m, fi, \"random\", positions_used, e);\n    } else if (type == \"all_regular\") {\n        generateGasStations(n, xi, ti, \"all_regular\", positions_used);\n        generateStartingPositions(m, fi, \"random\", positions_used, e);\n    } else if (type == \"all_premium\") {\n        generateGasStations(n, xi, ti, \"all_premium\", positions_used);\n        generateStartingPositions(m, fi, \"random\", positions_used, e);\n    } else if (type == \"all_super\") {\n        generateGasStations(n, xi, ti, \"all_super\", positions_used);\n        generateStartingPositions(m, fi, \"random\", positions_used, e);\n    } else if (type == \"path_force_regular\") {\n        e = 1000;\n        s = 500;\n        n = 1;\n        xi.resize(n);\n        ti.resize(n);\n        xi[0] = 500;\n        ti[0] = 1; // Regular-92\n        positions_used.insert(xi[0]);\n        fi.resize(1);\n        fi[0] = 0;\n        m = 1;\n    } else if (type == \"no_gas_stations\") {\n        n = 0;\n        xi.clear();\n        ti.clear();\n        generateStartingPositions(m, fi, \"random\", positions_used, e);\n    } else if (type == \"start_at_gas_station\") {\n        generateGasStations(n, xi, ti, \"random\", positions_used);\n        generateStartingPositions(m, fi, \"start_at_gas_station\", positions_used, e);\n    } else if (type == \"negative_positions\") {\n        generateGasStations(n, xi, ti, \"random\", positions_used);\n        for (int &pos : xi) {\n            if (pos >= 0) pos = -pos - 1; // Ensure negative positions\n        }\n        generateStartingPositions(m, fi, \"negative_positions\", positions_used, e);\n    } else if (type == \"gas_stations_at_limits\") {\n        e = 100;\n        s = 10;\n        m = 1;\n        fi.resize(1);\n        fi[0] = 0;\n        n = 9;\n        xi.resize(n);\n        ti.resize(n);\n        for (int i = 0; i < n; ++i) {\n            xi[i] = (i + 1) * 10;\n            positions_used.insert(xi[i]);\n            ti[i] = rnd.next(1, 3);\n        }\n    } else if (type == \"max_n_m\") {\n        n = 200000;\n        m = 200000;\n        e = MAX_COORD;\n        s = MAX_COORD;\n        generateGasStations(n, xi, ti, \"random\", positions_used);\n        generateStartingPositions(m, fi, \"random\", positions_used, e);\n    } else {\n        // Default is random\n        generateGasStations(n, xi, ti, \"random\", positions_used);\n        generateStartingPositions(m, fi, \"random\", positions_used, e);\n    }\n\n    printf(\"%d %d %d %d\\n\", e, s, n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", ti[i], xi[i]);\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", fi[i]);\n        if (i < m - 1) putchar(' ');\n    }\n    putchar('\\n');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases\n./gen -n 5 -m 5 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 1000 -m 1000 -type random\n./gen -n 10000 -m 10000 -type random\n./gen -n 200000 -m 200000 -type random\n\n# All gas stations are Regular-92\n./gen -n 1000 -m 1000 -type all_regular\n\n# All gas stations are Premium-95\n./gen -n 1000 -m 1000 -type all_premium\n\n# All gas stations are Super-98\n./gen -n 1000 -m 1000 -type all_super\n\n# Test case where route must use Regular-92\n./gen -type path_force_regular\n\n# No gas stations\n./gen -m 5 -type no_gas_stations\n\n# Starting positions coincide with gas stations\n./gen -n 1000 -type start_at_gas_station\n\n# Gas stations and starting positions at negative coordinates\n./gen -n 1000 -m 1000 -type negative_positions\n\n# Gas stations at limits of tank capacity\n./gen -type gas_stations_at_limits\n\n# Max n and m\n./gen -type max_n_m\n\n# Random small test cases\n./gen -n 1 -m 1 -type random\n./gen -n 2 -m 2 -type random\n./gen -n 10 -m 10 -type random\n\n# Test case with e and s set to minimal values\n./gen -e 1 -s 1 -n 1 -m 1 -type random\n\n# Test case where starting positions are near e\n./gen -n 1000 -m 1000 -type random -e 1000000000\n./gen -n 1000 -m 1000 -type random -e 1 -s 1\n\n# Test case with only Regular-92 and Premium-95 gas stations\n./gen -n 1000 -m 1000 -type all_regular_premium\n\n# Test case with only Premium-95 and Super-98 gas stations\n./gen -n 1000 -m 1000 -type all_premium_super\n\n# Test case with repeated starting positions\n./gen -n 1000 -m 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:54.726419",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "581/F",
      "title": "F. Zublicanes and Mumocrates",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line of the input contains a single integer n (2 ≤ n ≤ 5000) — the number of squares in the capital of Berland.Next n - 1 lines contain the pairs of integers x, y (1 ≤ x, y ≤ n, x ≠ y) — the numbers of the squares connected by the road. All squares are numbered with integers from 1 to n. It is guaranteed that the number of dead end squares of the city is even.",
      "output_spec": "OutputPrint a single number — the minimum number of roads connecting the squares with demonstrations of different parties.",
      "sample_tests": "ExamplesInputCopy81 42 43 46 57 58 54 5OutputCopy1InputCopy51 21 31 41 5OutputCopy2",
      "description": "F. Zublicanes and Mumocrates\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains a single integer n (2 ≤ n ≤ 5000) — the number of squares in the capital of Berland.Next n - 1 lines contain the pairs of integers x, y (1 ≤ x, y ≤ n, x ≠ y) — the numbers of the squares connected by the road. All squares are numbered with integers from 1 to n. It is guaranteed that the number of dead end squares of the city is even.\n\nOutputPrint a single number — the minimum number of roads connecting the squares with demonstrations of different parties.\n\nInputCopy81 42 43 46 57 58 54 5OutputCopy1InputCopy51 21 31 41 5OutputCopy2\n\nInputCopy81 42 43 46 57 58 54 5\n\nOutputCopy1\n\nInputCopy51 21 31 41 5\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #322 (Div. 2). It'll be held on Monday, September 28 at 12:00 MSK and as usual Div. 1 participants can join out of competition. Note that round starts in the unusual time!This round is held on the tasks of the school stage All-Russian Olympiad of Informatics 2015/2016 year in city Saratov. They were prepared by me and recently returned from army Edvard Davtyan (Edvard). Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to Vladimir Petrov (vovuh) for writing solutions.It will be a little unusual round — you will be given six problems and two hours to solve them. The scoring distribution will be announced later. Good luck everyone! UPD The scoring distribution today will be 500-1000-1500-2000-3000-3000.UPD2 EditorialUPD3 Congratulations to the winners! Moe for_the_pride SakurakoujiRuna VNOI z123z123d",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20522",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1069
        },
        {
          "title": "Codeforces Round #322 (Div.2) Editorial - Codeforces",
          "content": "581A — Vasya the HipsterThe first number in answer (number of days which Vasya can dress fashionably) is min(a, b) because every from this day he will dress one red sock and one blue sock.After this Vasya will have either only red socks or only blue socks or socks do not remain at all. Because of that the second number in answer is max((a - min(a, b)) / 2, (b - min(a, b)) / 2).Asymptotic behavior of this solution — O(1).581B — Luxurious HousesThis problem can be solved in the following way. Let's iterate on given array from the right to the left and will store in variable maxH the maximal height if house which we have already considered.Then the answer to house number i is number max(0, maxH + 1 - hi), where hi number of floors in house number i.Asymptotic behavior of this solution — O(n), where n — number of houses.581C — Developing SkillsThis problem can be solved in many ways. Let's consider the most intuitive way that fits in the given time.In the beginning we need to sort given array in the following way — from two numbers to the left should be the number to which must be added fewer units of improvements to make it a multiple of 10. You must add at least one unit of energy to every of this numbers. For example, if given array is {45, 30, 87, 26} after the sort the array must be equal to {87, 26, 45, 30}.Now we iterate on the sorted array for i from 1 to n. Let's cur = 10 - (aimod10). If cur ≤ k assign ai = ai + cur and from k subtract cur else if cur > k break from cycle.The next step is to iterate on array in the same way.Now we need only to calculate answer ans — we iterate on array for i from 1 to n and assign ans = ans + (ai / 10).Asymptotic behavior of this solution — O(n * log(n)) where n is the number of hero skills.581D — Three LogosThis problem can be solved in many ways, let's consider one of them.The first step is to calculate sum of squares s of given rectangles. Then the side of a answer square is sqrt(s). If sqrt(s) is not integer print -1. Else we need to make the following.We brute the order in which we will add given rectangles in the answer square (we can do it with help of next_permutation()) and for every order we brute will we rotate current rectangle on 90 degrees or not (we can do it with help of bit masks). In the beginning on every iteration the answer square c in which we add the rectangles is empty.For every rectangle, which we add to the answer square we make the following — we need to find the uppermost and leftmost empty cell free in answer square c (recall that we also brute will we rotate the current rectangle on 90 degrees or not). Now we try to impose current rectangle in the answer square c and the top left corner must coinside with the cell free. If current rectangle fully placed in the answer square c and does not intersect with the some rectangle which has already been added, we need to fill by the required letter appropriate cells in the answer square c.If no one of the conditions did not disrupted after we added all three rectangles and all answer square c is fully filled by letters we found answer and we neeed only to print the answer square c.Else if we did not find answer after all iterations on the rectangles — print -1.For random number of the rectangles k asymptotic behavior — O(k! * 2k * s) where s — the sum of squares of the given rectangles.Also this problem with 3 rectangles can be solved with the analysis of the cases with asymptotic O(s) where s — the sum of squares of given rectangles.581E — Kojiro and FurrariLet's f — the position of start, and e — the position of finish. For convenience of implementation we add the gas-station in point e with type equals to 3.Note: there is never a sense go to the left of the starting point because we already stand with a full tank of the besr petrol. It is correct for every gas-station in which we can appear (if in optimal answer we must go to the left in some gas-station pv, why not throw out all the way from pv to current gas-station v and back and after that the answer will be better). Now let's say about algorithm when we are in some gas-station v.The first case: on distance no more than s there is the gas-station with quality of gasoline not worse, than in the current gas-station. Now we fix nearest from them nv (nearest to the right because go to the left as we understand makes no sense). In that case we refuel in such a way to can reach nv and go to nv.The second case: from the current gas-station we can reach only gas-station with the worst quality (the type of the current gas-station can be 2 or 3). If we are in the gas-station of type 2 we need to refuel on maximum possiblevalue and go in the last achievable gas-station. If we are in the gas-station with type 3, we need to go in the farthest gas-station with type 2, but if there is not such gas-station we need to go to the farthest gas-station with type 1. This reasoning are correct because we first need to minimze the count of fuel with type 1, and the second to minimize the count of fuel with type 2.This basic reasoning necessary to solve the problem. The next step — calc dynamic on all suffixes i of gas-stations — the answer to the problem if we start from the gas-station i with empty tank. We need to make updates, considering the above cases. For update the dynamic in v we need to take the value of dynamic in nv and make update in addiction of the case. If the case is equals to 1, we need to add to appropriate value the distance d from v to nv. If this case is equals to 2 and we are in the gas-station with type equals to 2 we need to add s to the second value of answer, and from the first value we need to substract s–d. If it is the case number 2 and we are in the gas-station with type equals to 3, we need to substract from the value, which determined by the type of the gas-station nv, s–d.Now to answer on specific query of the starting position we nned to find the first gas-station which is to the right of the startiong position, make one update and take the value of dynamic, which already calculated, and recalculate this value in accordance with the above.Asymptotic behavior — O(n logn) or O(n) in case how we find position in the list of gas-stations (the first in case of binary search, the second in case of two pointers).To this solution we need O(n) memory.581F — Zublicanes and MumocratesLet the number of leavs in tree (vertices with degree 1) is equal to c. It said in statement that c is even. If in given graph only 2 vertices the answer is equal to 1. Else we have vertex in graph which do not a leaf — we hang the three on this vertex.Now we need to count 2 dynamics. The first z1[v][cnt][col] — the least amount of colored edges in the subtree rooted at the vertex v, if vertex v already painted in color col (col equals to 0 or to 1), and among the top of the leaves of the subtree v must be exactly cnt vertices with color 0. If we are in the leaf, it is easy to count this value. If we are not in the leaf — we count value with help of dynamic z1[v][cnt][col]:  = z2[s][cnt][col], where s — the first child int the adjacency list of vertex v.We need the second dynamic z2[s][cnt][col] to spread cnt leaves with color 0 among subtrees of childs of vertex v. To calc z2[s][cnt][col] we brute the color of child s — ncol and the number of childs i with color 0, which will be locate in subtree of vertex s and calc the value in the following way — z2[s][cnt][col] = min(z2[s][cnt][col], z2[ns][cnt–a][col] + z1[s][a][ncol] + (ncol! = col)), where ns — the next child of vertex v after the child s. Note, that it is senselessly to take a more than the number of leaves in the subtree s and to take more than the number of vertices in subtree — sizes (because in that case it will not be enough leaves for painting).The upper bound of asymptotic for such dynamics O(n3). We show that in fact it works with asymptotic O(n2). Let's count the number of updates: . Note, that every pair of vertices (x, y) appears in the last sum (x, y) exactly once when v = lca(x, y). So we have no more than O(n2) updates.Asymptotic behavior of this solution: O(n2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20508",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 581\\s*F"
          },
          "content_length": 8135
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 1",
          "code": "0 1 2\nand\n0 0\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 2",
          "code": "0 1 2\nand\n0 0\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 3",
          "code": "(int)floor((double)skill[i].rat/10.0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 4",
          "code": "(int)floor((double)skill[i].rat/10.0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 5",
          "code": "skill[i].rat / 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div. 2) - Codeforces - Code 6",
          "code": "skill[i].rat / 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20522",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div.2) Editorial - Codeforces - Code 1",
          "code": "4999\n1 2\n2 3\n...\n2499 2500\n2500 2501\n2500 2502\n...\n2500 4999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #322 (Div.2) Editorial - Codeforces - Code 2",
          "code": "4999\n1 2\n2 3\n...\n2499 2500\n2500 2501\n2500 2502\n...\n2500 4999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20508",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readEoln();\n\n    vector<int> deg(n + 1, 0);\n    vector<vector<int>> adj(n + 1);\n\n    for (int i = 0; i < n - 1; i++) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n\n        ensuref(x != y, \"Edge %d connects a node to itself: %d\", i + 1, x);\n\n        deg[x]++;\n        deg[y]++;\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n\n    // Check connectedness\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n    int visitedCount = 1;\n\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n                visitedCount++;\n            }\n        }\n    }\n\n    ensuref(visitedCount == n, \"The graph is not connected\");\n\n    // Count number of leaf nodes\n    int leaves = 0;\n    for (int i = 1; i <= n; i++) {\n        if (deg[i] == 1)\n            leaves++;\n    }\n\n    ensuref(leaves % 2 == 0, \"The number of dead end squares (leaves) must be even, but is %d\", leaves);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readEoln();\n\n    vector<int> deg(n + 1, 0);\n    vector<vector<int>> adj(n + 1);\n\n    for (int i = 0; i < n - 1; i++) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n\n        ensuref(x != y, \"Edge %d connects a node to itself: %d\", i + 1, x);\n\n        deg[x]++;\n        deg[y]++;\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n\n    // Check connectedness\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n    int visitedCount = 1;\n\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n                visitedCount++;\n            }\n        }\n    }\n\n    ensuref(visitedCount == n, \"The graph is not connected\");\n\n    // Count number of leaf nodes\n    int leaves = 0;\n    for (int i = 1; i <= n; i++) {\n        if (deg[i] == 1)\n            leaves++;\n    }\n\n    ensuref(leaves % 2 == 0, \"The number of dead end squares (leaves) must be even, but is %d\", leaves);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 5000, \"n\");\n    inf.readEoln();\n\n    vector<int> deg(n + 1, 0);\n    vector<vector<int>> adj(n + 1);\n\n    for (int i = 0; i < n - 1; i++) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n\n        ensuref(x != y, \"Edge %d connects a node to itself: %d\", i + 1, x);\n\n        deg[x]++;\n        deg[y]++;\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n\n    // Check connectedness\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n    int visitedCount = 1;\n\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n                visitedCount++;\n            }\n        }\n    }\n\n    ensuref(visitedCount == n, \"The graph is not connected\");\n\n    // Count number of leaf nodes\n    int leaves = 0;\n    for (int i = 1; i <= n; i++) {\n        if (deg[i] == 1)\n            leaves++;\n    }\n\n    ensuref(leaves % 2 == 0, \"The number of dead end squares (leaves) must be even, but is %d\", leaves);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint node_id;\n\nvoid generate_chain(int n) {\n    for (int i = 1; i < n; ++i) {\n        printf(\"%d %d\\n\", i, i + 1);\n    }\n}\n\nvoid generate_star(int n) {\n    if ((n - 1) % 2 != 0) {\n        fprintf(stderr, \"Error: For star tree, n - 1 must be even to ensure an even number of leaves.\\n\");\n        exit(1);\n    }\n    for (int i = 2; i <= n; ++i) {\n        printf(\"%d %d\\n\", 1, i);\n    }\n}\n\nvoid generate_double_star(int n) {\n    if (n % 2 != 0) {\n        fprintf(stderr, \"Error: For double star, n must be even to ensure an even number of leaves.\\n\");\n        exit(1);\n    }\n    int center1 = 1;\n    int center2 = 2;\n    printf(\"%d %d\\n\", center1, center2);\n    int leaf_id = 3;\n    for (; leaf_id <= n; ++leaf_id) {\n        if (leaf_id % 2 == 1) {\n            printf(\"%d %d\\n\", center1, leaf_id);\n        } else {\n            printf(\"%d %d\\n\", center2, leaf_id);\n        }\n    }\n}\n\nvoid generate_complete_binary_tree_util(int parent, int level, int max_level) {\n    int current_node = node_id++;\n    if (parent != -1) {\n        printf(\"%d %d\\n\", parent, current_node);\n    }\n    if (level == max_level) return;\n    generate_complete_binary_tree_util(current_node, level + 1, max_level);\n    generate_complete_binary_tree_util(current_node, level + 1, max_level);\n}\n\nvoid generate_complete_binary_tree(int n) {\n    // Find h such that n = 2^h -1\n    int h = 0;\n    int temp_n = n + 1;\n    while (temp_n % 2 == 0) {\n        temp_n /= 2;\n        h++;\n    }\n    if (temp_n != 1 || h < 1) {\n        fprintf(stderr, \"Error: n must be of the form 2^h -1 for complete_binary.\\n\");\n        exit(1);\n    }\n    int num_leaves = 1 << (h - 1);\n    if (num_leaves % 2 != 0) {\n        fprintf(stderr, \"Error: Number of leaves in complete binary tree is not even.\\n\");\n        exit(1);\n    }\n    node_id = 1;\n    generate_complete_binary_tree_util(-1, 1, h);\n}\n\nvoid generate_random_tree(int n) {\n    while (true) {\n        vector<int> prufer_sequence;\n        vector<int> degree(n + 1, 1);\n        prufer_sequence.reserve(n - 2);\n        for (int i = 0; i < n - 2; ++i) {\n            prufer_sequence.push_back(rnd.next(1, n));\n        }\n        for (int x : prufer_sequence) {\n            degree[x]++;\n        }\n        int num_leaves = 0;\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1) {\n                num_leaves++;\n            }\n        }\n        if (num_leaves % 2 == 0) {\n            // Build the tree\n            multiset<int> s;\n            for (int i = 1; i <= n; ++i) {\n                if (degree[i] == 1) {\n                    s.insert(i);\n                }\n            }\n            for (int x : prufer_sequence) {\n                int leaf = *s.begin();\n                s.erase(s.begin());\n                printf(\"%d %d\\n\", leaf, x);\n                degree[leaf]--;\n                degree[x]--;\n                if (degree[x] == 1) {\n                    s.insert(x);\n                }\n            }\n            vector<int> last_two;\n            for (int i = 1; i <= n; ++i)\n                if (degree[i] == 1)\n                    last_two.push_back(i);\n            printf(\"%d %d\\n\", last_two[0], last_two[1]);\n            break;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"chain\") {\n        generate_chain(n);\n    } else if (type == \"star\") {\n        generate_star(n);\n    } else if (type == \"double_star\") {\n        generate_double_star(n);\n    } else if (type == \"complete_binary\") {\n        generate_complete_binary_tree(n);\n    } else if (type == \"random\") {\n        generate_random_tree(n);\n    } else {\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint node_id;\n\nvoid generate_chain(int n) {\n    for (int i = 1; i < n; ++i) {\n        printf(\"%d %d\\n\", i, i + 1);\n    }\n}\n\nvoid generate_star(int n) {\n    if ((n - 1) % 2 != 0) {\n        fprintf(stderr, \"Error: For star tree, n - 1 must be even to ensure an even number of leaves.\\n\");\n        exit(1);\n    }\n    for (int i = 2; i <= n; ++i) {\n        printf(\"%d %d\\n\", 1, i);\n    }\n}\n\nvoid generate_double_star(int n) {\n    if (n % 2 != 0) {\n        fprintf(stderr, \"Error: For double star, n must be even to ensure an even number of leaves.\\n\");\n        exit(1);\n    }\n    int center1 = 1;\n    int center2 = 2;\n    printf(\"%d %d\\n\", center1, center2);\n    int leaf_id = 3;\n    for (; leaf_id <= n; ++leaf_id) {\n        if (leaf_id % 2 == 1) {\n            printf(\"%d %d\\n\", center1, leaf_id);\n        } else {\n            printf(\"%d %d\\n\", center2, leaf_id);\n        }\n    }\n}\n\nvoid generate_complete_binary_tree_util(int parent, int level, int max_level) {\n    int current_node = node_id++;\n    if (parent != -1) {\n        printf(\"%d %d\\n\", parent, current_node);\n    }\n    if (level == max_level) return;\n    generate_complete_binary_tree_util(current_node, level + 1, max_level);\n    generate_complete_binary_tree_util(current_node, level + 1, max_level);\n}\n\nvoid generate_complete_binary_tree(int n) {\n    // Find h such that n = 2^h -1\n    int h = 0;\n    int temp_n = n + 1;\n    while (temp_n % 2 == 0) {\n        temp_n /= 2;\n        h++;\n    }\n    if (temp_n != 1 || h < 1) {\n        fprintf(stderr, \"Error: n must be of the form 2^h -1 for complete_binary.\\n\");\n        exit(1);\n    }\n    int num_leaves = 1 << (h - 1);\n    if (num_leaves % 2 != 0) {\n        fprintf(stderr, \"Error: Number of leaves in complete binary tree is not even.\\n\");\n        exit(1);\n    }\n    node_id = 1;\n    generate_complete_binary_tree_util(-1, 1, h);\n}\n\nvoid generate_random_tree(int n) {\n    while (true) {\n        vector<int> prufer_sequence;\n        vector<int> degree(n + 1, 1);\n        prufer_sequence.reserve(n - 2);\n        for (int i = 0; i < n - 2; ++i) {\n            prufer_sequence.push_back(rnd.next(1, n));\n        }\n        for (int x : prufer_sequence) {\n            degree[x]++;\n        }\n        int num_leaves = 0;\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1) {\n                num_leaves++;\n            }\n        }\n        if (num_leaves % 2 == 0) {\n            // Build the tree\n            multiset<int> s;\n            for (int i = 1; i <= n; ++i) {\n                if (degree[i] == 1) {\n                    s.insert(i);\n                }\n            }\n            for (int x : prufer_sequence) {\n                int leaf = *s.begin();\n                s.erase(s.begin());\n                printf(\"%d %d\\n\", leaf, x);\n                degree[leaf]--;\n                degree[x]--;\n                if (degree[x] == 1) {\n                    s.insert(x);\n                }\n            }\n            vector<int> last_two;\n            for (int i = 1; i <= n; ++i)\n                if (degree[i] == 1)\n                    last_two.push_back(i);\n            printf(\"%d %d\\n\", last_two[0], last_two[1]);\n            break;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"chain\") {\n        generate_chain(n);\n    } else if (type == \"star\") {\n        generate_star(n);\n    } else if (type == \"double_star\") {\n        generate_double_star(n);\n    } else if (type == \"complete_binary\") {\n        generate_complete_binary_tree(n);\n    } else if (type == \"random\") {\n        generate_random_tree(n);\n    } else {\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type chain\n./gen -n 3 -type chain\n./gen -n 4 -type chain\n./gen -n 5 -type chain\n./gen -n 10 -type chain\n./gen -n 100 -type chain\n./gen -n 500 -type chain\n./gen -n 1000 -type chain\n./gen -n 5000 -type chain\n\n./gen -n 3 -type star\n./gen -n 5 -type star\n./gen -n 7 -type star\n./gen -n 9 -type star\n./gen -n 1001 -type star\n./gen -n 1003 -type star\n\n./gen -n 2 -type double_star\n./gen -n 4 -type double_star\n./gen -n 6 -type double_star\n./gen -n 8 -type double_star\n./gen -n 5000 -type double_star\n\n./gen -n 3 -type complete_binary\n./gen -n 7 -type complete_binary\n./gen -n 15 -type complete_binary\n./gen -n 31 -type complete_binary\n./gen -n 63 -type complete_binary\n./gen -n 127 -type complete_binary\n./gen -n 255 -type complete_binary\n./gen -n 511 -type complete_binary\n./gen -n 1023 -type complete_binary\n./gen -n 2047 -type complete_binary\n./gen -n 4095 -type complete_binary\n\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 500 -type random\n./gen -n 1000 -type random\n./gen -n 5000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:57.013508",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "582/A",
      "title": "A. GCD Table",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains number n (1 ≤ n ≤ 500) — the length of array a. The second line contains n2 space-separated numbers — the elements of the GCD table of G for array a. All the numbers in the table are positive integers, not exceeding 109. Note that the elements are given in an arbitrary order. It is guaranteed that the set of the input data corresponds to some array a.",
      "output_spec": "OutputIn the single line print n positive integers — the elements of array a. If there are multiple possible solutions, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy42 1 2 3 4 3 2 6 1 1 2 2 1 2 3 2OutputCopy4 3 6 2InputCopy142OutputCopy42 InputCopy21 1 1 1OutputCopy1 1",
      "description": "A. GCD Table\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains number n (1 ≤ n ≤ 500) — the length of array a. The second line contains n2 space-separated numbers — the elements of the GCD table of G for array a. All the numbers in the table are positive integers, not exceeding 109. Note that the elements are given in an arbitrary order. It is guaranteed that the set of the input data corresponds to some array a.\n\nOutputIn the single line print n positive integers — the elements of array a. If there are multiple possible solutions, you are allowed to print any of them.\n\nInputCopy42 1 2 3 4 3 2 6 1 1 2 2 1 2 3 2OutputCopy4 3 6 2InputCopy142OutputCopy42 InputCopy21 1 1 1OutputCopy1 1\n\nInputCopy42 1 2 3 4 3 2 6 1 1 2 2 1 2 3 2\n\nOutputCopy4 3 6 2\n\nInputCopy142\n\nOutputCopy42\n\nInputCopy21 1 1 1\n\nOutputCopy1 1",
      "solutions": [
        {
          "title": "Codeforces Round #323 - Codeforces",
          "content": "Greetings, Codeforces!My name is Danil Sagunov, and I used to be red... Anyway, I wish to congratulate you with the Second Revolution!I am glad to introduce that this Saturday, 3rd October at 19:30 MSK Codeforces Round #323 for both divisions will take place. Problemset has been prepared for you by me and Vitaly gridnevvvit Gridnev. This is not the first round we are authors of and I'm sure that it's not the last.Special thanks to our friends Maxim Neon Mescheryakov, Vladimir vovuh Petrov and Roman Roms Glazov for helping us preparing the round. I would like to thank Max Zlobober Akhmedov for his coordinator activity, Michael MikeMirzayanov Mirzayanov for creating and supporting Codeforces and Polygon systems, making this round possible, and Maria Delinur Belova for translating problem statements into English.Thanks to Vladislav winger Isenbaev and Alex AlexFetisov Fetisov for testing the round problemset!Both division participants will be given five problems and two hours to solve them. I hope that everyone will find the problems interesting and many of you will return your colors.UPD The round duration was written incorrectly in the e-mail announcement, the correct duration is 2 hours, not 2.5 hours.UPD2 Round have been successfully finished! Thank you all for participating.Congratulations to 1 division winners! ecnerwala ikatanic uwi PavelKunyavskiy sd0061 And the second division: wrong_order ahwhlzz kefaa My gratitude to fotiIe96, one to solve problem D!UPD3 Editorial can be found here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20657",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1514
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces",
          "content": "Adiv2To solve the problem one could just store two arrays hused[j] and vused[j] sized n and filled with false initially. Then process intersections one by one from 1 to n, and if for i-th intersections both hused[hi] and vused[vi] are false, add i to answer and set both hused[hi] and vused[vi] with true meaning that hi-th horizontal and vi-th vertical roads are now asphalted, and skip asphalting the intersection roads otherwise.Such solution has O(n2) complexity.Jury's solution: 13390628Bdiv2It is always optimal to pass all the computers in the row, starting from 1-st to n-th, then from n-th to first, then again from first to n-th, etc. and collecting the information parts as possible, while not all of them are collected. Such way gives robot maximal use of every direction change. O(n2) solution using this approach must have been passed system tests.Jury's solution: 13390612Adiv1Let the answer be a1 ≤ a2 ≤ ... ≤ an. We will use the fact that gcd(ai, aj) ≤ amin(i, j). It is true that gcd(an, an) = an ≥ ai ≥ gcd(ai, aj) for every 1 ≤ i, j ≤ n. That means that an is equal to maximum element in the table. Let set an to maximal element in the table and delete it from table elements set. We've deleted gcd(an, an), so the set now contains all gcd(ai, aj), for every 1 ≤ i, j ≤ n and 1 ≤ min(i, j) ≤ n - 1. By the last two inequalities gcd(ai, aj) ≤ amin(i, j) ≤ an - 1 = gcd(an - 1, an - 1). As soon as set contains gcd(an - 1, an - 1), the maximum element in current element set is equal to an - 1. As far as we already know an, let's delete the gcd(an - 1, an - 1), gcd(an - 1, an), gcd(an, an - 1) from the element set. Now set contains all the gcd(ai, aj), for every 1 ≤ i, j ≤ n and 1 ≤ min(i, j) ≤ n - 2.We're repeating that operation for every k from n - 2 to 1, setting ak to maximum element in the set and deleting the gcd(ak, ak), gcd(ai, ak), gcd(ak, ai) for every k < i ≤ n from the set.One could prove correctness of this algorithm by mathematical induction. For performing deleting and getting maximum element operations one could use multiset or map structure, so solution has complexity .Jury's solution: 13390679Bdiv1One could calculate matrix sized n × n mt[i][j] — the length of the longest non-decreasing subsequence in array a1, a2, ..., an, starting at element, greater-or-equal to ai and ending strictly in aj element with j-th index.One could prove that if we have two matrices sized n × n A[i][j] (the answer for a1, a2, ..., apn starting at element, greater-or-equal to ai and ending strictly in aj element with j-th index inside last block (a(p - 1)n + 1, ..., apn) and B[i][j] (the answer for a1, a2, ..., aqn ), then the multiplication of this matrices in a waywill give the same matrix but for length p + q. As soon as such multiplication is associative, next we will use fast matrix exponentiation algorithm to calculate M[i][j] (the answer for a1, a2, ..., anT) — matrix mt[i][j] raised in power T. The answer is the maximum in matrix M. Such solution has complexity .Jury's solution (with matrices): 13390660There's an alternative solution. As soon as a1, a2, ..., anT contains maximum n distinct elements, it's any non-decreasing subsequence has a maximum of n - 1 increasing consequtive element pairs. Using that fact, one could calculate standard longest non-decreasing subsequence dynamic programming on first n array blocks (a1, ..., an2) and longest non-decreasing subsequence DP on the last n array blocks (anT - n + 1, ..., anT). All other T - 2n blocks between them will make subsegment of consequtive equal elements in longest non-decreasing subsequence.So, for fixed ai, in which longest non-decreasing subsequence of length p on first n blocks array ends, and for fixed aj ≥ ai, in which longest non-decreasing subsequence of length s on last n blocks array starts, we must update the answer with p + (T - 2n)count(ai) + s, where count(x) is the number of occurences of x in a1, ..., an array. This gives us solution.Jury's solution (with suffix and prefix): 13390666Cdiv1Let's fix s for every (l, s) pair. One could easily prove, that if subarray contains ai element, than ai must be greater-or-equal than aj for every j such that . Let's use this idea and fix g = gcd(n, s) (it must be a divisor of n). To check if ai can be in subarray with such constraints, let's for every 0 ≤ r < g calculate .It's true that every good subarray must consist of and only of . For finding all such subarrays we will use two pointers approach and for every good ai, such that is not good we will find aj such that are good and is not good. Let has k elements . Any it's subarray is superior, so it gives us arrays of length 1, 2, ..., k with count k, k - 1, ..., 1. As soon as sum of all k is not greater than n, we could just increase counts straightforward. There's a case when all ai are good, in which we must do another increases. Next we must add to the answer only counts of length x, such that gcd(x, n) = g.Solution described above has complexity O(d(n)n), where d(n) is the number of divisors of n.Jury's solution: 13390645Ddiv1It is a common fact that for a prime p and integer n maximum α, such that pα|n! is calculated as , where pw ≤ n < pw + 1. As soon as , the maximum α for is calculated as .One could see, that if we consider numbers n, k and n - k in p-th based numeric system, rounded-down division by px means dropping last x digits of its p-th based representation. As soon as k + (n - k) = n, every i-th summand in α corresponds to carry in adding k to n - k in p-th numeric system from i - 1-th to i-th digit position and is to be 0 or 1.First, let convert A given in statement from 10 to p-th numeric system. In case, if α is greater than number of digits in A in p-th numeric system, the answer is 0. Next we will calculate dynamic programming on A p-th based representation.dp[i][x][e][r] — the answer for prefix of length i possible equal to prefix of A representation (indicator e), x-th power of p was already calculated, and there must be carry equal to r from current to previous position. One could calculate it by bruteforcing all of p2 variants of placing i-th digits in n and k according to r and e and i-th digit of A, and make a translation to next state. It can be avoided by noticing that the number of variants of placing digits is always a sum of arithmetic progression and can be calculated in O(1).It's highly recommended to examine jury's solution with complexity O(|A|2 + |A|min(|A|, α)).Jury's solution: 13390698Ediv1One could prove that the number of binary functions on 4 variables is equal to 224, and can be coded by storing a 24-bit binary mask, in which every bit is storing function value for corresponding variable set. It is true, that if maskf and maskg are correspond to functions f(A, B, C, D) and g(A, B, C, D), then function (f&g)(A, B, C, D) corresponds to maskf&maskg bitmask.Now, we could parse expression given input into binary tree. I should notice that the number of non-list nodes of such tree is about . Now, let's calculate dynamic programming on every vertex v — dp[v][mask] is the number of ways to place symbols in expression in the way that subtree of vertex v will correspond to function representing by mask. For list nodes such dynamic is calculated pretty straightforward by considering all possible mask values and matching it with the variable. One could easily recalculate it for one node using calculated answers for left and right subtree in 416 operations: dp[v][lmask|rmask] +  = dp[l][lmask] * dp[r][rmask].But all the task is how to make it faster. One could calculate s[mask], where s[mask] is equal to sum of all its submasks (the masks containing 1-bits only in positions where mask contains 1-bits) in 24·224 operations using following code: for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n for (int mask = 0; mask < (1 << 16); ++mask)\n if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];Let's calculate sl[mask] and sr[mask] for dp[l][mask] and dp[r][mask] respectively. If we will find s[mask] = sl[mask] * sr[mask], s[mask] will contain multiplications of values of pairs of masks from left and right dp's, which are submasks of mask. As soon as we need pairs, which in bitwise OR will give us exactly mask, we should exclude pairs, which in bitwise OR gives a submask of mask, not equal to mask. This gives us exclusion-inclusion principle idea. The formula of this will be, where p is the parity of number of bits in mask^submask.Such sum could be calculated with approach above, but subtracting instead of adding for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n for (int mask = 0; mask < (1 << 16); ++mask)\n if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];In such way we will recalculate dynamic for one vertex in about 3·24·216 operations.Jury's solution: 13390713",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20692",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 8922
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #323 - Codeforces - Code 1",
          "code": "gcd(A, A) = A",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 2",
          "code": "gcd(A, B) <= min(A, B)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 3",
          "code": "gcd(A, B) <= B",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 4",
          "code": "gcd(B, B) = B",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 5",
          "code": "int fun(multiset st) {  multiset :: iterator it = st.end();  it--;  return it; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 6",
          "code": "int fun(multiset &st) {  multiset :: iterator it = st.end();  it--;  return it; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 7",
          "code": "multiset<...>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 8",
          "code": "vertical = vector<bool> (n, false);\n horizontal = vector<bool> (n, false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 9",
          "code": "vertical = vector<bool> (n, false);\n horizontal = vector<bool> (n, false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 1",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 2",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 3",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 4",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 5",
          "code": "(x[0], x[1], ..., x[7]) @ (y[0], y[1], ..., y[7]) = (z[0], z[1], ..., z[7])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 6",
          "code": "(x[0]+x[4], x[1]+x[5], x[2]+x[6], x[3]+x[7]) @ (y[0]+y[4], y[1]+y[5], y[2]+y[6], y[3]+y[7]) = (a, b, c, d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 7",
          "code": "(x[0], x[1], x[2], x[3]) @ (y[0], y[1], y[2], y[3]) = (e, f, g, h)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 8",
          "code": "z[4] = a - e",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 9",
          "code": "z[5] = b - f",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 10",
          "code": "z[6] = c - g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 11",
          "code": "z[7] = d - h",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 12",
          "code": "ans.pb(a[i]);\n    cnt++;\n    if(cnt==n) break;\n    for(int l=0;l<ans.size();l++)\n    {\n        //if(a[i]==274199512) cout<<__gcd(a[i],ans[l])<<\" \"<<i<<\" \"<<l<<\"\\n\";\n        gcds.push(__gcd(a[i],ans[l]))\n        gcds.push(__gcd(a[i],ans[l]));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 13",
          "code": "ans.pb(a[i]);\n    cnt++;\n    if(cnt==n) break;\n    for(int l=0;l<ans.size();l++)\n    {\n        //if(a[i]==274199512) cout<<__gcd(a[i],ans[l])<<\" \"<<i<<\" \"<<l<<\"\\n\";\n        gcds.push(__gcd(a[i],ans[l]))\n        gcds.push(__gcd(a[i],ans[l]));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 14",
          "code": "5        \n    12 1 1 2 1\n     1 7 1 1 1\n     1 1 5 1 1\n     2 1 1 2 1\n     1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 15",
          "code": "5        \n    12 1 1 2 1\n     1 7 1 1 1\n     1 1 5 1 1\n     2 1 1 2 1\n     1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readEoln();\n    vector<int> G = inf.readInts(n * n, 1, 1000000000, \"G\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readEoln();\n    vector<int> G = inf.readInts(n * n, 1, 1000000000, \"G\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readEoln();\n    vector<int> G = inf.readInts(n * n, 1, 1000000000, \"G\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n from the input file\n    int n = inf.readInt();\n\n    // Read n^2 numbers from the input GCD table, store in multiset G_input\n    multiset<int> G_input;\n    for (int i = 0; i < n * n; ++i) {\n        int x = inf.readInt();\n        G_input.insert(x);\n    }\n\n    // Read the contestant's output array a[1..n]\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = ouf.readInt(1, 1000000000, format(\"a[%d]\", i + 1).c_str());\n    }\n\n    // Build G_output multiset from contestant's array\n    multiset<int> G_output;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            int g = __gcd(a[i], a[j]);\n            G_output.insert(g);\n        }\n    }\n\n    // Compare G_input and G_output\n    if (G_input == G_output) {\n        quitf(_ok, \"Correct\");\n    } else {\n        quitf(_wa, \"The GCD table computed from the output does not match the input GCD table.\");\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a(n);\n\n    if (type == \"all_ones\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"all_equal\") {\n        int k = 1000000000; // Fixed large number\n        for (int i = 0; i < n; ++i) {\n            a[i] = k;\n        }\n    } else if (type == \"distinct_primes\") {\n        vector<int> primes;\n        const int MAX_N = 10000; // Sufficient for n up to 500\n        vector<bool> is_prime(MAX_N, true);\n        for (int i = 2; i < MAX_N && primes.size() < n; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                for (int j = i * 2; j < MAX_N; j += i)\n                    is_prime[j] = false;\n            }\n        }\n        for (int i = 0; i < n; ++i)\n            a[i] = primes[i];\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2) + 1; // 1 and 2 alternating\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"powers_two\") {\n        for (int i = 0; i < n; ++i) {\n            int exp = rnd.next(0, 29); // 2^0 to 2^29\n            a[i] = 1 << exp;\n        }\n    } else if (type == \"common_factor\") {\n        int k = rnd.next(2, 1000000); // Common factor\n        for (int i = 0; i < n; ++i) {\n            int mult = rnd.next(1, 1000);\n            a[i] = k * mult;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Compute GCD table G\n    vector<int> G;\n    G.reserve(n * n);\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            G.push_back(__gcd(a[i], a[j]));\n\n    // Shuffle G\n    shuffle(G.begin(), G.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output G\n    for (size_t i = 0; i < G.size(); ++i) {\n        printf(\"%d\", G[i]);\n        if (i + 1 < G.size())\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a(n);\n\n    if (type == \"all_ones\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"all_equal\") {\n        int k = 1000000000; // Fixed large number\n        for (int i = 0; i < n; ++i) {\n            a[i] = k;\n        }\n    } else if (type == \"distinct_primes\") {\n        vector<int> primes;\n        const int MAX_N = 10000; // Sufficient for n up to 500\n        vector<bool> is_prime(MAX_N, true);\n        for (int i = 2; i < MAX_N && primes.size() < n; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                for (int j = i * 2; j < MAX_N; j += i)\n                    is_prime[j] = false;\n            }\n        }\n        for (int i = 0; i < n; ++i)\n            a[i] = primes[i];\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2) + 1; // 1 and 2 alternating\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"powers_two\") {\n        for (int i = 0; i < n; ++i) {\n            int exp = rnd.next(0, 29); // 2^0 to 2^29\n            a[i] = 1 << exp;\n        }\n    } else if (type == \"common_factor\") {\n        int k = rnd.next(2, 1000000); // Common factor\n        for (int i = 0; i < n; ++i) {\n            int mult = rnd.next(1, 1000);\n            a[i] = k * mult;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Compute GCD table G\n    vector<int> G;\n    G.reserve(n * n);\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            G.push_back(__gcd(a[i], a[j]));\n\n    // Shuffle G\n    shuffle(G.begin(), G.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output G\n    for (size_t i = 0; i < G.size(); ++i) {\n        printf(\"%d\", G[i]);\n        if (i + 1 < G.size())\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_ones\n./gen -n 2 -type all_ones\n./gen -n 500 -type all_ones\n\n./gen -n 1 -type all_equal\n./gen -n 2 -type all_equal\n./gen -n 500 -type all_equal\n\n./gen -n 1 -type distinct_primes\n./gen -n 2 -type distinct_primes\n./gen -n 10 -type distinct_primes\n./gen -n 100 -type distinct_primes\n./gen -n 500 -type distinct_primes\n\n./gen -n 1 -type alternating\n./gen -n 2 -type alternating\n./gen -n 500 -type alternating\n\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 500 -type random\n\n./gen -n 1 -type powers_two\n./gen -n 2 -type powers_two\n./gen -n 10 -type powers_two\n./gen -n 100 -type powers_two\n./gen -n 500 -type powers_two\n\n./gen -n 1 -type common_factor\n./gen -n 2 -type common_factor\n./gen -n 10 -type common_factor\n./gen -n 100 -type common_factor\n./gen -n 500 -type common_factor\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:52:58.669342",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "582/B",
      "title": "B. Once Again...",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers: n, T (1 ≤ n ≤ 100, 1 ≤ T ≤ 107). The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 300).",
      "output_spec": "OutputPrint a single number — the length of a sought sequence.",
      "sample_tests": "ExamplesInputCopy4 33 1 4 2OutputCopy5",
      "description": "B. Once Again...\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two space-separated integers: n, T (1 ≤ n ≤ 100, 1 ≤ T ≤ 107). The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 300).\n\nOutputPrint a single number — the length of a sought sequence.\n\nInputCopy4 33 1 4 2OutputCopy5\n\nInputCopy4 33 1 4 2\n\nOutputCopy5\n\nNoteThe array given in the sample looks like that: 3, 1, 4, 2, 3, 1, 4, 2, 3, 1, 4, 2. The elements in bold form the largest non-decreasing subsequence.",
      "solutions": [
        {
          "title": "Codeforces Round #323 - Codeforces",
          "content": "Greetings, Codeforces!My name is Danil Sagunov, and I used to be red... Anyway, I wish to congratulate you with the Second Revolution!I am glad to introduce that this Saturday, 3rd October at 19:30 MSK Codeforces Round #323 for both divisions will take place. Problemset has been prepared for you by me and Vitaly gridnevvvit Gridnev. This is not the first round we are authors of and I'm sure that it's not the last.Special thanks to our friends Maxim Neon Mescheryakov, Vladimir vovuh Petrov and Roman Roms Glazov for helping us preparing the round. I would like to thank Max Zlobober Akhmedov for his coordinator activity, Michael MikeMirzayanov Mirzayanov for creating and supporting Codeforces and Polygon systems, making this round possible, and Maria Delinur Belova for translating problem statements into English.Thanks to Vladislav winger Isenbaev and Alex AlexFetisov Fetisov for testing the round problemset!Both division participants will be given five problems and two hours to solve them. I hope that everyone will find the problems interesting and many of you will return your colors.UPD The round duration was written incorrectly in the e-mail announcement, the correct duration is 2 hours, not 2.5 hours.UPD2 Round have been successfully finished! Thank you all for participating.Congratulations to 1 division winners! ecnerwala ikatanic uwi PavelKunyavskiy sd0061 And the second division: wrong_order ahwhlzz kefaa My gratitude to fotiIe96, one to solve problem D!UPD3 Editorial can be found here",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/20657",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1514
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces",
          "content": "Adiv2To solve the problem one could just store two arrays hused[j] and vused[j] sized n and filled with false initially. Then process intersections one by one from 1 to n, and if for i-th intersections both hused[hi] and vused[vi] are false, add i to answer and set both hused[hi] and vused[vi] with true meaning that hi-th horizontal and vi-th vertical roads are now asphalted, and skip asphalting the intersection roads otherwise.Such solution has O(n2) complexity.Jury's solution: 13390628Bdiv2It is always optimal to pass all the computers in the row, starting from 1-st to n-th, then from n-th to first, then again from first to n-th, etc. and collecting the information parts as possible, while not all of them are collected. Such way gives robot maximal use of every direction change. O(n2) solution using this approach must have been passed system tests.Jury's solution: 13390612Adiv1Let the answer be a1 ≤ a2 ≤ ... ≤ an. We will use the fact that gcd(ai, aj) ≤ amin(i, j). It is true that gcd(an, an) = an ≥ ai ≥ gcd(ai, aj) for every 1 ≤ i, j ≤ n. That means that an is equal to maximum element in the table. Let set an to maximal element in the table and delete it from table elements set. We've deleted gcd(an, an), so the set now contains all gcd(ai, aj), for every 1 ≤ i, j ≤ n and 1 ≤ min(i, j) ≤ n - 1. By the last two inequalities gcd(ai, aj) ≤ amin(i, j) ≤ an - 1 = gcd(an - 1, an - 1). As soon as set contains gcd(an - 1, an - 1), the maximum element in current element set is equal to an - 1. As far as we already know an, let's delete the gcd(an - 1, an - 1), gcd(an - 1, an), gcd(an, an - 1) from the element set. Now set contains all the gcd(ai, aj), for every 1 ≤ i, j ≤ n and 1 ≤ min(i, j) ≤ n - 2.We're repeating that operation for every k from n - 2 to 1, setting ak to maximum element in the set and deleting the gcd(ak, ak), gcd(ai, ak), gcd(ak, ai) for every k < i ≤ n from the set.One could prove correctness of this algorithm by mathematical induction. For performing deleting and getting maximum element operations one could use multiset or map structure, so solution has complexity .Jury's solution: 13390679Bdiv1One could calculate matrix sized n × n mt[i][j] — the length of the longest non-decreasing subsequence in array a1, a2, ..., an, starting at element, greater-or-equal to ai and ending strictly in aj element with j-th index.One could prove that if we have two matrices sized n × n A[i][j] (the answer for a1, a2, ..., apn starting at element, greater-or-equal to ai and ending strictly in aj element with j-th index inside last block (a(p - 1)n + 1, ..., apn) and B[i][j] (the answer for a1, a2, ..., aqn ), then the multiplication of this matrices in a waywill give the same matrix but for length p + q. As soon as such multiplication is associative, next we will use fast matrix exponentiation algorithm to calculate M[i][j] (the answer for a1, a2, ..., anT) — matrix mt[i][j] raised in power T. The answer is the maximum in matrix M. Such solution has complexity .Jury's solution (with matrices): 13390660There's an alternative solution. As soon as a1, a2, ..., anT contains maximum n distinct elements, it's any non-decreasing subsequence has a maximum of n - 1 increasing consequtive element pairs. Using that fact, one could calculate standard longest non-decreasing subsequence dynamic programming on first n array blocks (a1, ..., an2) and longest non-decreasing subsequence DP on the last n array blocks (anT - n + 1, ..., anT). All other T - 2n blocks between them will make subsegment of consequtive equal elements in longest non-decreasing subsequence.So, for fixed ai, in which longest non-decreasing subsequence of length p on first n blocks array ends, and for fixed aj ≥ ai, in which longest non-decreasing subsequence of length s on last n blocks array starts, we must update the answer with p + (T - 2n)count(ai) + s, where count(x) is the number of occurences of x in a1, ..., an array. This gives us solution.Jury's solution (with suffix and prefix): 13390666Cdiv1Let's fix s for every (l, s) pair. One could easily prove, that if subarray contains ai element, than ai must be greater-or-equal than aj for every j such that . Let's use this idea and fix g = gcd(n, s) (it must be a divisor of n). To check if ai can be in subarray with such constraints, let's for every 0 ≤ r < g calculate .It's true that every good subarray must consist of and only of . For finding all such subarrays we will use two pointers approach and for every good ai, such that is not good we will find aj such that are good and is not good. Let has k elements . Any it's subarray is superior, so it gives us arrays of length 1, 2, ..., k with count k, k - 1, ..., 1. As soon as sum of all k is not greater than n, we could just increase counts straightforward. There's a case when all ai are good, in which we must do another increases. Next we must add to the answer only counts of length x, such that gcd(x, n) = g.Solution described above has complexity O(d(n)n), where d(n) is the number of divisors of n.Jury's solution: 13390645Ddiv1It is a common fact that for a prime p and integer n maximum α, such that pα|n! is calculated as , where pw ≤ n < pw + 1. As soon as , the maximum α for is calculated as .One could see, that if we consider numbers n, k and n - k in p-th based numeric system, rounded-down division by px means dropping last x digits of its p-th based representation. As soon as k + (n - k) = n, every i-th summand in α corresponds to carry in adding k to n - k in p-th numeric system from i - 1-th to i-th digit position and is to be 0 or 1.First, let convert A given in statement from 10 to p-th numeric system. In case, if α is greater than number of digits in A in p-th numeric system, the answer is 0. Next we will calculate dynamic programming on A p-th based representation.dp[i][x][e][r] — the answer for prefix of length i possible equal to prefix of A representation (indicator e), x-th power of p was already calculated, and there must be carry equal to r from current to previous position. One could calculate it by bruteforcing all of p2 variants of placing i-th digits in n and k according to r and e and i-th digit of A, and make a translation to next state. It can be avoided by noticing that the number of variants of placing digits is always a sum of arithmetic progression and can be calculated in O(1).It's highly recommended to examine jury's solution with complexity O(|A|2 + |A|min(|A|, α)).Jury's solution: 13390698Ediv1One could prove that the number of binary functions on 4 variables is equal to 224, and can be coded by storing a 24-bit binary mask, in which every bit is storing function value for corresponding variable set. It is true, that if maskf and maskg are correspond to functions f(A, B, C, D) and g(A, B, C, D), then function (f&g)(A, B, C, D) corresponds to maskf&maskg bitmask.Now, we could parse expression given input into binary tree. I should notice that the number of non-list nodes of such tree is about . Now, let's calculate dynamic programming on every vertex v — dp[v][mask] is the number of ways to place symbols in expression in the way that subtree of vertex v will correspond to function representing by mask. For list nodes such dynamic is calculated pretty straightforward by considering all possible mask values and matching it with the variable. One could easily recalculate it for one node using calculated answers for left and right subtree in 416 operations: dp[v][lmask|rmask] +  = dp[l][lmask] * dp[r][rmask].But all the task is how to make it faster. One could calculate s[mask], where s[mask] is equal to sum of all its submasks (the masks containing 1-bits only in positions where mask contains 1-bits) in 24·224 operations using following code: for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n for (int mask = 0; mask < (1 << 16); ++mask)\n if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];Let's calculate sl[mask] and sr[mask] for dp[l][mask] and dp[r][mask] respectively. If we will find s[mask] = sl[mask] * sr[mask], s[mask] will contain multiplications of values of pairs of masks from left and right dp's, which are submasks of mask. As soon as we need pairs, which in bitwise OR will give us exactly mask, we should exclude pairs, which in bitwise OR gives a submask of mask, not equal to mask. This gives us exclusion-inclusion principle idea. The formula of this will be, where p is the parity of number of bits in mask^submask.Such sum could be calculated with approach above, but subtracting instead of adding for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n for (int mask = 0; mask < (1 << 16); ++mask)\n if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];In such way we will recalculate dynamic for one vertex in about 3·24·216 operations.Jury's solution: 13390713",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/20692",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 8922
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #323 - Codeforces - Code 1",
          "code": "gcd(A, A) = A",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 2",
          "code": "gcd(A, B) <= min(A, B)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 3",
          "code": "gcd(A, B) <= B",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 4",
          "code": "gcd(B, B) = B",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 5",
          "code": "int fun(multiset st) {  multiset :: iterator it = st.end();  it--;  return it; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 6",
          "code": "int fun(multiset &st) {  multiset :: iterator it = st.end();  it--;  return it; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 7",
          "code": "multiset<...>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 8",
          "code": "vertical = vector<bool> (n, false);\n horizontal = vector<bool> (n, false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 9",
          "code": "vertical = vector<bool> (n, false);\n horizontal = vector<bool> (n, false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 1",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 2",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 3",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 4",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 5",
          "code": "(x[0], x[1], ..., x[7]) @ (y[0], y[1], ..., y[7]) = (z[0], z[1], ..., z[7])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 6",
          "code": "(x[0]+x[4], x[1]+x[5], x[2]+x[6], x[3]+x[7]) @ (y[0]+y[4], y[1]+y[5], y[2]+y[6], y[3]+y[7]) = (a, b, c, d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 7",
          "code": "(x[0], x[1], x[2], x[3]) @ (y[0], y[1], y[2], y[3]) = (e, f, g, h)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 8",
          "code": "z[4] = a - e",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 9",
          "code": "z[5] = b - f",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 10",
          "code": "z[6] = c - g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 11",
          "code": "z[7] = d - h",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 12",
          "code": "ans.pb(a[i]);\n    cnt++;\n    if(cnt==n) break;\n    for(int l=0;l<ans.size();l++)\n    {\n        //if(a[i]==274199512) cout<<__gcd(a[i],ans[l])<<\" \"<<i<<\" \"<<l<<\"\\n\";\n        gcds.push(__gcd(a[i],ans[l]))\n        gcds.push(__gcd(a[i],ans[l]));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 13",
          "code": "ans.pb(a[i]);\n    cnt++;\n    if(cnt==n) break;\n    for(int l=0;l<ans.size();l++)\n    {\n        //if(a[i]==274199512) cout<<__gcd(a[i],ans[l])<<\" \"<<i<<\" \"<<l<<\"\\n\";\n        gcds.push(__gcd(a[i],ans[l]))\n        gcds.push(__gcd(a[i],ans[l]));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 14",
          "code": "5        \n    12 1 1 2 1\n     1 7 1 1 1\n     1 1 5 1 1\n     2 1 1 2 1\n     1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 15",
          "code": "5        \n    12 1 1 2 1\n     1 7 1 1 1\n     1 1 5 1 1\n     2 1 1 2 1\n     1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int T = inf.readInt(1, 10000000, \"T\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 300, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int T = inf.readInt(1, 10000000, \"T\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 300, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int T = inf.readInt(1, 10000000, \"T\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 300, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int T = opt<int>(\"T\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = min(i + 1, 300);\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = min(n - i, 300);\n    } else if (type == \"constant\") {\n        int k = opt<int>(\"k\", rnd.next(1, 300)); // Optionally can pass k\n        for (int i = 0; i < n; ++i)\n            a[i] = k;\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 300);\n    } else if (type == \"wave\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? rnd.next(1, 150) : rnd.next(151, 300);\n    } else if (type == \"alternating\") {\n        int k1 = 1;\n        int k2 = 300;\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? k1 : k2;\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 300);\n    }\n\n    // Output n and T\n    printf(\"%d %d\\n\", n, T);\n    // Output a[1..n]\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n -1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int T = opt<int>(\"T\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = min(i + 1, 300);\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = min(n - i, 300);\n    } else if (type == \"constant\") {\n        int k = opt<int>(\"k\", rnd.next(1, 300)); // Optionally can pass k\n        for (int i = 0; i < n; ++i)\n            a[i] = k;\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 300);\n    } else if (type == \"wave\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? rnd.next(1, 150) : rnd.next(151, 300);\n    } else if (type == \"alternating\") {\n        int k1 = 1;\n        int k2 = 300;\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? k1 : k2;\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 300);\n    }\n\n    // Output n and T\n    printf(\"%d %d\\n\", n, T);\n    // Output a[1..n]\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n -1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -T 1 -type constant\n./gen -n 1 -T 10000000 -type constant\n./gen -n 1 -T 10000000 -type random\n\n./gen -n 2 -T 1 -type increasing\n./gen -n 2 -T 1 -type decreasing\n./gen -n 2 -T 10000000 -type increasing\n./gen -n 2 -T 10000000 -type decreasing\n\n./gen -n 5 -T 10 -type random\n./gen -n 10 -T 10000 -type random\n./gen -n 50 -T 5000000 -type random\n\n./gen -n 100 -T 1 -type increasing\n./gen -n 100 -T 1 -type decreasing\n./gen -n 100 -T 1 -type random\n\n./gen -n 100 -T 10000000 -type increasing\n./gen -n 100 -T 10000000 -type decreasing\n./gen -n 100 -T 10000000 -type random\n\n./gen -n 100 -T 10000000 -type wave\n./gen -n 100 -T 10000000 -type alternating\n\n./gen -n 100 -T 10000000 -type constant -k 1\n./gen -n 100 -T 10000000 -type constant -k 300\n\n./gen -n 100 -T 10000000 -type random\n./gen -n 1 -T 10000000 -type increasing\n./gen -n 1 -T 10000000 -type decreasing\n./gen -n 100 -T 10000000 -type wave\n./gen -n 100 -T 10000000 -type random\n\n./gen -n 100 -T 10000000 -type constant -k 42\n\n./gen -n 50 -T 5000000 -type random\n./gen -n 50 -T 10000000 -type increasing\n./gen -n 50 -T 10000000 -type decreasing\n\n./gen -n 1 -T 10000000 -type constant -k 300\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:00.730670",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "582/C",
      "title": "C. Superior Periodic Subarrays",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains number n (1 ≤ n ≤ 2·105). The second line contains n numbers a0, a1, ..., an - 1 (1 ≤ ai ≤ 106), separated by a space.",
      "output_spec": "OutputPrint a single integer — the sought number of pairs.",
      "sample_tests": "ExamplesInputCopy47 1 2 3OutputCopy2InputCopy22 1OutputCopy1InputCopy31 1 1OutputCopy6",
      "description": "C. Superior Periodic Subarrays\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains number n (1 ≤ n ≤ 2·105). The second line contains n numbers a0, a1, ..., an - 1 (1 ≤ ai ≤ 106), separated by a space.\n\nOutputPrint a single integer — the sought number of pairs.\n\nInputCopy47 1 2 3OutputCopy2InputCopy22 1OutputCopy1InputCopy31 1 1OutputCopy6\n\nInputCopy47 1 2 3\n\nOutputCopy2\n\nInputCopy22 1\n\nOutputCopy1\n\nInputCopy31 1 1\n\nOutputCopy6\n\nNoteIn the first sample the superior subarrays are (0, 1) and (3, 2).Subarray (0, 1) is superior, as a0 ≥ a0, a0 ≥ a1, a0 ≥ a2, a0 ≥ a3, a0 ≥ a0, ...Subarray (3, 2) is superior a3 ≥ a3, a0 ≥ a0, a3 ≥ a1, a0 ≥ a2, a3 ≥ a3, ...In the third sample any pair of (l, s) corresponds to a superior subarray as all the elements of an array are distinct.",
      "solutions": [
        {
          "title": "Codeforces Round #323 - Codeforces",
          "content": "Greetings, Codeforces!My name is Danil Sagunov, and I used to be red... Anyway, I wish to congratulate you with the Second Revolution!I am glad to introduce that this Saturday, 3rd October at 19:30 MSK Codeforces Round #323 for both divisions will take place. Problemset has been prepared for you by me and Vitaly gridnevvvit Gridnev. This is not the first round we are authors of and I'm sure that it's not the last.Special thanks to our friends Maxim Neon Mescheryakov, Vladimir vovuh Petrov and Roman Roms Glazov for helping us preparing the round. I would like to thank Max Zlobober Akhmedov for his coordinator activity, Michael MikeMirzayanov Mirzayanov for creating and supporting Codeforces and Polygon systems, making this round possible, and Maria Delinur Belova for translating problem statements into English.Thanks to Vladislav winger Isenbaev and Alex AlexFetisov Fetisov for testing the round problemset!Both division participants will be given five problems and two hours to solve them. I hope that everyone will find the problems interesting and many of you will return your colors.UPD The round duration was written incorrectly in the e-mail announcement, the correct duration is 2 hours, not 2.5 hours.UPD2 Round have been successfully finished! Thank you all for participating.Congratulations to 1 division winners! ecnerwala ikatanic uwi PavelKunyavskiy sd0061 And the second division: wrong_order ahwhlzz kefaa My gratitude to fotiIe96, one to solve problem D!UPD3 Editorial can be found here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20657",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1514
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces",
          "content": "Adiv2To solve the problem one could just store two arrays hused[j] and vused[j] sized n and filled with false initially. Then process intersections one by one from 1 to n, and if for i-th intersections both hused[hi] and vused[vi] are false, add i to answer and set both hused[hi] and vused[vi] with true meaning that hi-th horizontal and vi-th vertical roads are now asphalted, and skip asphalting the intersection roads otherwise.Such solution has O(n2) complexity.Jury's solution: 13390628Bdiv2It is always optimal to pass all the computers in the row, starting from 1-st to n-th, then from n-th to first, then again from first to n-th, etc. and collecting the information parts as possible, while not all of them are collected. Such way gives robot maximal use of every direction change. O(n2) solution using this approach must have been passed system tests.Jury's solution: 13390612Adiv1Let the answer be a1 ≤ a2 ≤ ... ≤ an. We will use the fact that gcd(ai, aj) ≤ amin(i, j). It is true that gcd(an, an) = an ≥ ai ≥ gcd(ai, aj) for every 1 ≤ i, j ≤ n. That means that an is equal to maximum element in the table. Let set an to maximal element in the table and delete it from table elements set. We've deleted gcd(an, an), so the set now contains all gcd(ai, aj), for every 1 ≤ i, j ≤ n and 1 ≤ min(i, j) ≤ n - 1. By the last two inequalities gcd(ai, aj) ≤ amin(i, j) ≤ an - 1 = gcd(an - 1, an - 1). As soon as set contains gcd(an - 1, an - 1), the maximum element in current element set is equal to an - 1. As far as we already know an, let's delete the gcd(an - 1, an - 1), gcd(an - 1, an), gcd(an, an - 1) from the element set. Now set contains all the gcd(ai, aj), for every 1 ≤ i, j ≤ n and 1 ≤ min(i, j) ≤ n - 2.We're repeating that operation for every k from n - 2 to 1, setting ak to maximum element in the set and deleting the gcd(ak, ak), gcd(ai, ak), gcd(ak, ai) for every k < i ≤ n from the set.One could prove correctness of this algorithm by mathematical induction. For performing deleting and getting maximum element operations one could use multiset or map structure, so solution has complexity .Jury's solution: 13390679Bdiv1One could calculate matrix sized n × n mt[i][j] — the length of the longest non-decreasing subsequence in array a1, a2, ..., an, starting at element, greater-or-equal to ai and ending strictly in aj element with j-th index.One could prove that if we have two matrices sized n × n A[i][j] (the answer for a1, a2, ..., apn starting at element, greater-or-equal to ai and ending strictly in aj element with j-th index inside last block (a(p - 1)n + 1, ..., apn) and B[i][j] (the answer for a1, a2, ..., aqn ), then the multiplication of this matrices in a waywill give the same matrix but for length p + q. As soon as such multiplication is associative, next we will use fast matrix exponentiation algorithm to calculate M[i][j] (the answer for a1, a2, ..., anT) — matrix mt[i][j] raised in power T. The answer is the maximum in matrix M. Such solution has complexity .Jury's solution (with matrices): 13390660There's an alternative solution. As soon as a1, a2, ..., anT contains maximum n distinct elements, it's any non-decreasing subsequence has a maximum of n - 1 increasing consequtive element pairs. Using that fact, one could calculate standard longest non-decreasing subsequence dynamic programming on first n array blocks (a1, ..., an2) and longest non-decreasing subsequence DP on the last n array blocks (anT - n + 1, ..., anT). All other T - 2n blocks between them will make subsegment of consequtive equal elements in longest non-decreasing subsequence.So, for fixed ai, in which longest non-decreasing subsequence of length p on first n blocks array ends, and for fixed aj ≥ ai, in which longest non-decreasing subsequence of length s on last n blocks array starts, we must update the answer with p + (T - 2n)count(ai) + s, where count(x) is the number of occurences of x in a1, ..., an array. This gives us solution.Jury's solution (with suffix and prefix): 13390666Cdiv1Let's fix s for every (l, s) pair. One could easily prove, that if subarray contains ai element, than ai must be greater-or-equal than aj for every j such that . Let's use this idea and fix g = gcd(n, s) (it must be a divisor of n). To check if ai can be in subarray with such constraints, let's for every 0 ≤ r < g calculate .It's true that every good subarray must consist of and only of . For finding all such subarrays we will use two pointers approach and for every good ai, such that is not good we will find aj such that are good and is not good. Let has k elements . Any it's subarray is superior, so it gives us arrays of length 1, 2, ..., k with count k, k - 1, ..., 1. As soon as sum of all k is not greater than n, we could just increase counts straightforward. There's a case when all ai are good, in which we must do another increases. Next we must add to the answer only counts of length x, such that gcd(x, n) = g.Solution described above has complexity O(d(n)n), where d(n) is the number of divisors of n.Jury's solution: 13390645Ddiv1It is a common fact that for a prime p and integer n maximum α, such that pα|n! is calculated as , where pw ≤ n < pw + 1. As soon as , the maximum α for is calculated as .One could see, that if we consider numbers n, k and n - k in p-th based numeric system, rounded-down division by px means dropping last x digits of its p-th based representation. As soon as k + (n - k) = n, every i-th summand in α corresponds to carry in adding k to n - k in p-th numeric system from i - 1-th to i-th digit position and is to be 0 or 1.First, let convert A given in statement from 10 to p-th numeric system. In case, if α is greater than number of digits in A in p-th numeric system, the answer is 0. Next we will calculate dynamic programming on A p-th based representation.dp[i][x][e][r] — the answer for prefix of length i possible equal to prefix of A representation (indicator e), x-th power of p was already calculated, and there must be carry equal to r from current to previous position. One could calculate it by bruteforcing all of p2 variants of placing i-th digits in n and k according to r and e and i-th digit of A, and make a translation to next state. It can be avoided by noticing that the number of variants of placing digits is always a sum of arithmetic progression and can be calculated in O(1).It's highly recommended to examine jury's solution with complexity O(|A|2 + |A|min(|A|, α)).Jury's solution: 13390698Ediv1One could prove that the number of binary functions on 4 variables is equal to 224, and can be coded by storing a 24-bit binary mask, in which every bit is storing function value for corresponding variable set. It is true, that if maskf and maskg are correspond to functions f(A, B, C, D) and g(A, B, C, D), then function (f&g)(A, B, C, D) corresponds to maskf&maskg bitmask.Now, we could parse expression given input into binary tree. I should notice that the number of non-list nodes of such tree is about . Now, let's calculate dynamic programming on every vertex v — dp[v][mask] is the number of ways to place symbols in expression in the way that subtree of vertex v will correspond to function representing by mask. For list nodes such dynamic is calculated pretty straightforward by considering all possible mask values and matching it with the variable. One could easily recalculate it for one node using calculated answers for left and right subtree in 416 operations: dp[v][lmask|rmask] +  = dp[l][lmask] * dp[r][rmask].But all the task is how to make it faster. One could calculate s[mask], where s[mask] is equal to sum of all its submasks (the masks containing 1-bits only in positions where mask contains 1-bits) in 24·224 operations using following code: for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n for (int mask = 0; mask < (1 << 16); ++mask)\n if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];Let's calculate sl[mask] and sr[mask] for dp[l][mask] and dp[r][mask] respectively. If we will find s[mask] = sl[mask] * sr[mask], s[mask] will contain multiplications of values of pairs of masks from left and right dp's, which are submasks of mask. As soon as we need pairs, which in bitwise OR will give us exactly mask, we should exclude pairs, which in bitwise OR gives a submask of mask, not equal to mask. This gives us exclusion-inclusion principle idea. The formula of this will be, where p is the parity of number of bits in mask^submask.Such sum could be calculated with approach above, but subtracting instead of adding for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n for (int mask = 0; mask < (1 << 16); ++mask)\n if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];In such way we will recalculate dynamic for one vertex in about 3·24·216 operations.Jury's solution: 13390713",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20692",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 8922
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #323 - Codeforces - Code 1",
          "code": "gcd(A, A) = A",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 2",
          "code": "gcd(A, B) <= min(A, B)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 3",
          "code": "gcd(A, B) <= B",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 4",
          "code": "gcd(B, B) = B",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 5",
          "code": "int fun(multiset st) {  multiset :: iterator it = st.end();  it--;  return it; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 6",
          "code": "int fun(multiset &st) {  multiset :: iterator it = st.end();  it--;  return it; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 7",
          "code": "multiset<...>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 8",
          "code": "vertical = vector<bool> (n, false);\n horizontal = vector<bool> (n, false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 9",
          "code": "vertical = vector<bool> (n, false);\n horizontal = vector<bool> (n, false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 1",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 2",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 3",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 4",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 5",
          "code": "(x[0], x[1], ..., x[7]) @ (y[0], y[1], ..., y[7]) = (z[0], z[1], ..., z[7])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 6",
          "code": "(x[0]+x[4], x[1]+x[5], x[2]+x[6], x[3]+x[7]) @ (y[0]+y[4], y[1]+y[5], y[2]+y[6], y[3]+y[7]) = (a, b, c, d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 7",
          "code": "(x[0], x[1], x[2], x[3]) @ (y[0], y[1], y[2], y[3]) = (e, f, g, h)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 8",
          "code": "z[4] = a - e",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 9",
          "code": "z[5] = b - f",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 10",
          "code": "z[6] = c - g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 11",
          "code": "z[7] = d - h",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 12",
          "code": "ans.pb(a[i]);\n    cnt++;\n    if(cnt==n) break;\n    for(int l=0;l<ans.size();l++)\n    {\n        //if(a[i]==274199512) cout<<__gcd(a[i],ans[l])<<\" \"<<i<<\" \"<<l<<\"\\n\";\n        gcds.push(__gcd(a[i],ans[l]))\n        gcds.push(__gcd(a[i],ans[l]));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 13",
          "code": "ans.pb(a[i]);\n    cnt++;\n    if(cnt==n) break;\n    for(int l=0;l<ans.size();l++)\n    {\n        //if(a[i]==274199512) cout<<__gcd(a[i],ans[l])<<\" \"<<i<<\" \"<<l<<\"\\n\";\n        gcds.push(__gcd(a[i],ans[l]))\n        gcds.push(__gcd(a[i],ans[l]));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 14",
          "code": "5        \n    12 1 1 2 1\n     1 7 1 1 1\n     1 1 5 1 1\n     2 1 1 2 1\n     1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 15",
          "code": "5        \n    12 1 1 2 1\n     1 7 1 1 1\n     1 1 5 1 1\n     2 1 1 2 1\n     1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate random numbers between 1 and 1e6\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1'000'000);\n        }\n    } \n    else if (type == \"increasing\") {\n        // Generate an increasing sequence\n        int start = rnd.next(1, 1'000'000 - n + 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n    } \n    else if (type == \"decreasing\") {\n        // Generate a decreasing sequence\n        int start = rnd.next(n, 1'000'000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start - i;\n        }\n    } \n    else if (type == \"constant\") {\n        // All elements are the same\n        int val = rnd.next(1, 1'000'000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } \n    else if (type == \"max_at_beginning\") {\n        // First element is maximum\n        a[0] = 1'000'000;\n        for (int i = 1; i < n; ++i) {\n            a[i] = rnd.next(1, 999'999);\n        }\n    } \n    else if (type == \"min_at_beginning\") {\n        // First element is minimum\n        a[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            a[i] = rnd.next(2, 1'000'000);\n        }\n    } \n    else if (type == \"alternating\") {\n        // Alternating high and low values\n        int high = rnd.next(500'001, 1'000'000);\n        int low = rnd.next(1, 500'000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? high : low;\n        }\n    } \n    else if (type == \"periodic\") {\n        // Periodic sequence with a given period length\n        int period = opt<int>(\"period\", 1);\n        ensure(1 <= period && period < n); // Ensure period is valid\n        vector<int> p(period);\n        for (int i = 0; i < period; ++i) {\n            p[i] = rnd.next(1, 1'000'000);\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = p[i % period];\n        }\n    } \n    else if (type == \"peak\") {\n        // Sequence with a peak in the middle\n        int peak_pos = n / 2;\n        int peak_val = 1'000'000;\n        for (int i = 0; i < n; ++i) {\n            if (i == peak_pos) {\n                a[i] = peak_val;\n            } else {\n                a[i] = rnd.next(1, peak_val - 1);\n            }\n        }\n    } \n    else {\n        // Default to random if type is unknown\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1'000'000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the array elements\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate random numbers between 1 and 1e6\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1'000'000);\n        }\n    } \n    else if (type == \"increasing\") {\n        // Generate an increasing sequence\n        int start = rnd.next(1, 1'000'000 - n + 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + i;\n        }\n    } \n    else if (type == \"decreasing\") {\n        // Generate a decreasing sequence\n        int start = rnd.next(n, 1'000'000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start - i;\n        }\n    } \n    else if (type == \"constant\") {\n        // All elements are the same\n        int val = rnd.next(1, 1'000'000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } \n    else if (type == \"max_at_beginning\") {\n        // First element is maximum\n        a[0] = 1'000'000;\n        for (int i = 1; i < n; ++i) {\n            a[i] = rnd.next(1, 999'999);\n        }\n    } \n    else if (type == \"min_at_beginning\") {\n        // First element is minimum\n        a[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            a[i] = rnd.next(2, 1'000'000);\n        }\n    } \n    else if (type == \"alternating\") {\n        // Alternating high and low values\n        int high = rnd.next(500'001, 1'000'000);\n        int low = rnd.next(1, 500'000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? high : low;\n        }\n    } \n    else if (type == \"periodic\") {\n        // Periodic sequence with a given period length\n        int period = opt<int>(\"period\", 1);\n        ensure(1 <= period && period < n); // Ensure period is valid\n        vector<int> p(period);\n        for (int i = 0; i < period; ++i) {\n            p[i] = rnd.next(1, 1'000'000);\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = p[i % period];\n        }\n    } \n    else if (type == \"peak\") {\n        // Sequence with a peak in the middle\n        int peak_pos = n / 2;\n        int peak_val = 1'000'000;\n        for (int i = 0; i < n; ++i) {\n            if (i == peak_pos) {\n                a[i] = peak_val;\n            } else {\n                a[i] = rnd.next(1, peak_val - 1);\n            }\n        }\n    } \n    else {\n        // Default to random if type is unknown\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1'000'000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the array elements\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n with different types\n./gen -n 1 -type random\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 3 -type constant\n./gen -n 3 -type max_at_beginning\n./gen -n 3 -type min_at_beginning\n./gen -n 3 -type alternating\n./gen -n 3 -type periodic -period 2\n./gen -n 3 -type peak\n\n# Medium n with different types\n./gen -n 1000 -type random\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type constant\n./gen -n 1000 -type max_at_beginning\n./gen -n 1000 -type min_at_beginning\n./gen -n 1000 -type alternating\n./gen -n 1000 -type periodic -period 50\n./gen -n 1000 -type peak\n\n# Large n with different types\n./gen -n 200000 -type random\n./gen -n 200000 -type increasing\n./gen -n 200000 -type decreasing\n./gen -n 200000 -type constant\n./gen -n 200000 -type max_at_beginning\n./gen -n 200000 -type min_at_beginning\n./gen -n 200000 -type alternating\n./gen -n 200000 -type periodic -period 1000\n./gen -n 200000 -type peak\n\n# Edge cases\n./gen -n 1 -type constant\n./gen -n 2 -type periodic -period 1\n./gen -n 200000 -type periodic -period 1\n./gen -n 200000 -type periodic -period 199999\n./gen -n 200000 -type periodic -period 99999\n./gen -n 200000 -type increasing\n./gen -n 200000 -type decreasing\n./gen -n 200000 -type alternating\n./gen -n 200000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:02.578368",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "582/D",
      "title": "D. Number of Binominal Coefficients",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers, p and α (1 ≤ p, α ≤ 109, p is prime). The second line contains the decimal record of integer A (0 ≤ A < 101000) without leading zeroes.",
      "output_spec": "OutputIn the single line print the answer to the problem.",
      "sample_tests": "ExamplesInputCopy2 27OutputCopy3InputCopy3 19OutputCopy17InputCopy3 39OutputCopy0InputCopy2 45000OutputCopy8576851",
      "description": "D. Number of Binominal Coefficients\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers, p and α (1 ≤ p, α ≤ 109, p is prime). The second line contains the decimal record of integer A (0 ≤ A < 101000) without leading zeroes.\n\nOutputIn the single line print the answer to the problem.\n\nInputCopy2 27OutputCopy3InputCopy3 19OutputCopy17InputCopy3 39OutputCopy0InputCopy2 45000OutputCopy8576851\n\nInputCopy2 27\n\nOutputCopy3\n\nInputCopy3 19\n\nOutputCopy17\n\nInputCopy3 39\n\nOutputCopy0\n\nInputCopy2 45000\n\nOutputCopy8576851\n\nNoteIn the first sample three binominal coefficients divisible by 4 are ,  and .",
      "solutions": [
        {
          "title": "Codeforces Round #323 - Codeforces",
          "content": "Greetings, Codeforces!My name is Danil Sagunov, and I used to be red... Anyway, I wish to congratulate you with the Second Revolution!I am glad to introduce that this Saturday, 3rd October at 19:30 MSK Codeforces Round #323 for both divisions will take place. Problemset has been prepared for you by me and Vitaly gridnevvvit Gridnev. This is not the first round we are authors of and I'm sure that it's not the last.Special thanks to our friends Maxim Neon Mescheryakov, Vladimir vovuh Petrov and Roman Roms Glazov for helping us preparing the round. I would like to thank Max Zlobober Akhmedov for his coordinator activity, Michael MikeMirzayanov Mirzayanov for creating and supporting Codeforces and Polygon systems, making this round possible, and Maria Delinur Belova for translating problem statements into English.Thanks to Vladislav winger Isenbaev and Alex AlexFetisov Fetisov for testing the round problemset!Both division participants will be given five problems and two hours to solve them. I hope that everyone will find the problems interesting and many of you will return your colors.UPD The round duration was written incorrectly in the e-mail announcement, the correct duration is 2 hours, not 2.5 hours.UPD2 Round have been successfully finished! Thank you all for participating.Congratulations to 1 division winners! ecnerwala ikatanic uwi PavelKunyavskiy sd0061 And the second division: wrong_order ahwhlzz kefaa My gratitude to fotiIe96, one to solve problem D!UPD3 Editorial can be found here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20657",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1514
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces",
          "content": "Adiv2To solve the problem one could just store two arrays hused[j] and vused[j] sized n and filled with false initially. Then process intersections one by one from 1 to n, and if for i-th intersections both hused[hi] and vused[vi] are false, add i to answer and set both hused[hi] and vused[vi] with true meaning that hi-th horizontal and vi-th vertical roads are now asphalted, and skip asphalting the intersection roads otherwise.Such solution has O(n2) complexity.Jury's solution: 13390628Bdiv2It is always optimal to pass all the computers in the row, starting from 1-st to n-th, then from n-th to first, then again from first to n-th, etc. and collecting the information parts as possible, while not all of them are collected. Such way gives robot maximal use of every direction change. O(n2) solution using this approach must have been passed system tests.Jury's solution: 13390612Adiv1Let the answer be a1 ≤ a2 ≤ ... ≤ an. We will use the fact that gcd(ai, aj) ≤ amin(i, j). It is true that gcd(an, an) = an ≥ ai ≥ gcd(ai, aj) for every 1 ≤ i, j ≤ n. That means that an is equal to maximum element in the table. Let set an to maximal element in the table and delete it from table elements set. We've deleted gcd(an, an), so the set now contains all gcd(ai, aj), for every 1 ≤ i, j ≤ n and 1 ≤ min(i, j) ≤ n - 1. By the last two inequalities gcd(ai, aj) ≤ amin(i, j) ≤ an - 1 = gcd(an - 1, an - 1). As soon as set contains gcd(an - 1, an - 1), the maximum element in current element set is equal to an - 1. As far as we already know an, let's delete the gcd(an - 1, an - 1), gcd(an - 1, an), gcd(an, an - 1) from the element set. Now set contains all the gcd(ai, aj), for every 1 ≤ i, j ≤ n and 1 ≤ min(i, j) ≤ n - 2.We're repeating that operation for every k from n - 2 to 1, setting ak to maximum element in the set and deleting the gcd(ak, ak), gcd(ai, ak), gcd(ak, ai) for every k < i ≤ n from the set.One could prove correctness of this algorithm by mathematical induction. For performing deleting and getting maximum element operations one could use multiset or map structure, so solution has complexity .Jury's solution: 13390679Bdiv1One could calculate matrix sized n × n mt[i][j] — the length of the longest non-decreasing subsequence in array a1, a2, ..., an, starting at element, greater-or-equal to ai and ending strictly in aj element with j-th index.One could prove that if we have two matrices sized n × n A[i][j] (the answer for a1, a2, ..., apn starting at element, greater-or-equal to ai and ending strictly in aj element with j-th index inside last block (a(p - 1)n + 1, ..., apn) and B[i][j] (the answer for a1, a2, ..., aqn ), then the multiplication of this matrices in a waywill give the same matrix but for length p + q. As soon as such multiplication is associative, next we will use fast matrix exponentiation algorithm to calculate M[i][j] (the answer for a1, a2, ..., anT) — matrix mt[i][j] raised in power T. The answer is the maximum in matrix M. Such solution has complexity .Jury's solution (with matrices): 13390660There's an alternative solution. As soon as a1, a2, ..., anT contains maximum n distinct elements, it's any non-decreasing subsequence has a maximum of n - 1 increasing consequtive element pairs. Using that fact, one could calculate standard longest non-decreasing subsequence dynamic programming on first n array blocks (a1, ..., an2) and longest non-decreasing subsequence DP on the last n array blocks (anT - n + 1, ..., anT). All other T - 2n blocks between them will make subsegment of consequtive equal elements in longest non-decreasing subsequence.So, for fixed ai, in which longest non-decreasing subsequence of length p on first n blocks array ends, and for fixed aj ≥ ai, in which longest non-decreasing subsequence of length s on last n blocks array starts, we must update the answer with p + (T - 2n)count(ai) + s, where count(x) is the number of occurences of x in a1, ..., an array. This gives us solution.Jury's solution (with suffix and prefix): 13390666Cdiv1Let's fix s for every (l, s) pair. One could easily prove, that if subarray contains ai element, than ai must be greater-or-equal than aj for every j such that . Let's use this idea and fix g = gcd(n, s) (it must be a divisor of n). To check if ai can be in subarray with such constraints, let's for every 0 ≤ r < g calculate .It's true that every good subarray must consist of and only of . For finding all such subarrays we will use two pointers approach and for every good ai, such that is not good we will find aj such that are good and is not good. Let has k elements . Any it's subarray is superior, so it gives us arrays of length 1, 2, ..., k with count k, k - 1, ..., 1. As soon as sum of all k is not greater than n, we could just increase counts straightforward. There's a case when all ai are good, in which we must do another increases. Next we must add to the answer only counts of length x, such that gcd(x, n) = g.Solution described above has complexity O(d(n)n), where d(n) is the number of divisors of n.Jury's solution: 13390645Ddiv1It is a common fact that for a prime p and integer n maximum α, such that pα|n! is calculated as , where pw ≤ n < pw + 1. As soon as , the maximum α for is calculated as .One could see, that if we consider numbers n, k and n - k in p-th based numeric system, rounded-down division by px means dropping last x digits of its p-th based representation. As soon as k + (n - k) = n, every i-th summand in α corresponds to carry in adding k to n - k in p-th numeric system from i - 1-th to i-th digit position and is to be 0 or 1.First, let convert A given in statement from 10 to p-th numeric system. In case, if α is greater than number of digits in A in p-th numeric system, the answer is 0. Next we will calculate dynamic programming on A p-th based representation.dp[i][x][e][r] — the answer for prefix of length i possible equal to prefix of A representation (indicator e), x-th power of p was already calculated, and there must be carry equal to r from current to previous position. One could calculate it by bruteforcing all of p2 variants of placing i-th digits in n and k according to r and e and i-th digit of A, and make a translation to next state. It can be avoided by noticing that the number of variants of placing digits is always a sum of arithmetic progression and can be calculated in O(1).It's highly recommended to examine jury's solution with complexity O(|A|2 + |A|min(|A|, α)).Jury's solution: 13390698Ediv1One could prove that the number of binary functions on 4 variables is equal to 224, and can be coded by storing a 24-bit binary mask, in which every bit is storing function value for corresponding variable set. It is true, that if maskf and maskg are correspond to functions f(A, B, C, D) and g(A, B, C, D), then function (f&g)(A, B, C, D) corresponds to maskf&maskg bitmask.Now, we could parse expression given input into binary tree. I should notice that the number of non-list nodes of such tree is about . Now, let's calculate dynamic programming on every vertex v — dp[v][mask] is the number of ways to place symbols in expression in the way that subtree of vertex v will correspond to function representing by mask. For list nodes such dynamic is calculated pretty straightforward by considering all possible mask values and matching it with the variable. One could easily recalculate it for one node using calculated answers for left and right subtree in 416 operations: dp[v][lmask|rmask] +  = dp[l][lmask] * dp[r][rmask].But all the task is how to make it faster. One could calculate s[mask], where s[mask] is equal to sum of all its submasks (the masks containing 1-bits only in positions where mask contains 1-bits) in 24·224 operations using following code: for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n for (int mask = 0; mask < (1 << 16); ++mask)\n if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];Let's calculate sl[mask] and sr[mask] for dp[l][mask] and dp[r][mask] respectively. If we will find s[mask] = sl[mask] * sr[mask], s[mask] will contain multiplications of values of pairs of masks from left and right dp's, which are submasks of mask. As soon as we need pairs, which in bitwise OR will give us exactly mask, we should exclude pairs, which in bitwise OR gives a submask of mask, not equal to mask. This gives us exclusion-inclusion principle idea. The formula of this will be, where p is the parity of number of bits in mask^submask.Such sum could be calculated with approach above, but subtracting instead of adding for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n for (int mask = 0; mask < (1 << 16); ++mask)\n if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];In such way we will recalculate dynamic for one vertex in about 3·24·216 operations.Jury's solution: 13390713",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20692",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 8922
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #323 - Codeforces - Code 1",
          "code": "gcd(A, A) = A",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 2",
          "code": "gcd(A, B) <= min(A, B)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 3",
          "code": "gcd(A, B) <= B",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 4",
          "code": "gcd(B, B) = B",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 5",
          "code": "int fun(multiset st) {  multiset :: iterator it = st.end();  it--;  return it; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 6",
          "code": "int fun(multiset &st) {  multiset :: iterator it = st.end();  it--;  return it; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 7",
          "code": "multiset<...>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 8",
          "code": "vertical = vector<bool> (n, false);\n horizontal = vector<bool> (n, false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 9",
          "code": "vertical = vector<bool> (n, false);\n horizontal = vector<bool> (n, false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 1",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 2",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 3",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 4",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 5",
          "code": "(x[0], x[1], ..., x[7]) @ (y[0], y[1], ..., y[7]) = (z[0], z[1], ..., z[7])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 6",
          "code": "(x[0]+x[4], x[1]+x[5], x[2]+x[6], x[3]+x[7]) @ (y[0]+y[4], y[1]+y[5], y[2]+y[6], y[3]+y[7]) = (a, b, c, d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 7",
          "code": "(x[0], x[1], x[2], x[3]) @ (y[0], y[1], y[2], y[3]) = (e, f, g, h)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 8",
          "code": "z[4] = a - e",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 9",
          "code": "z[5] = b - f",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 10",
          "code": "z[6] = c - g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 11",
          "code": "z[7] = d - h",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 12",
          "code": "ans.pb(a[i]);\n    cnt++;\n    if(cnt==n) break;\n    for(int l=0;l<ans.size();l++)\n    {\n        //if(a[i]==274199512) cout<<__gcd(a[i],ans[l])<<\" \"<<i<<\" \"<<l<<\"\\n\";\n        gcds.push(__gcd(a[i],ans[l]))\n        gcds.push(__gcd(a[i],ans[l]));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 13",
          "code": "ans.pb(a[i]);\n    cnt++;\n    if(cnt==n) break;\n    for(int l=0;l<ans.size();l++)\n    {\n        //if(a[i]==274199512) cout<<__gcd(a[i],ans[l])<<\" \"<<i<<\" \"<<l<<\"\\n\";\n        gcds.push(__gcd(a[i],ans[l]))\n        gcds.push(__gcd(a[i],ans[l]));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 14",
          "code": "5        \n    12 1 1 2 1\n     1 7 1 1 1\n     1 1 5 1 1\n     2 1 1 2 1\n     1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 15",
          "code": "5        \n    12 1 1 2 1\n     1 7 1 1 1\n     1 1 5 1 1\n     2 1 1 2 1\n     1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n// Computes (a * b) % mod\nll mulmod(ll a, ll b, ll mod) {\n    return (a % mod) * (b % mod) % mod;\n}\n\n// Computes (base ^ exponent) % mod\nll binpower(ll base, ll e, ll mod) {\n    ll result = 1;\n    base %= mod;\n    while (e > 0) {\n        if (e & 1)\n            result = mulmod(result, base, mod);\n        base = mulmod(base, base, mod);\n        e >>= 1;\n    }\n    return result % mod;\n}\n\n// Checks whether n is a composite number using witness a\nbool check_composite(ll n, ll a, ll d, int s) {\n    ll x = binpower(a, d, n);\n    if (x == 1 || x == n - 1)\n        return false;\n    for (int r = 1; r < s; r++) {\n        x = mulmod(x, x, n);\n        if (x == n - 1)\n            return false;\n    }\n    return true;\n}\n\n// Miller-Rabin primality test for n < 2^32\nbool MillerRabin(ll n) {\n    if (n < 2)\n        return false;\n    int r = 0;\n    ll d = n - 1;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        r++;\n    }\n    // Witnesses for n < 2^32\n    for (ll a : {2, 7, 61}) {\n        if (a % n == 0)\n            continue;\n        if (check_composite(n, a, d, r))\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int p = inf.readInt(1, 1000000000, \"p\");\n    inf.readSpace();\n    int alpha = inf.readInt(1, 1000000000, \"alpha\");\n    inf.readEoln();\n\n    ensuref(MillerRabin(p), \"p must be a prime number\");\n\n    string A = inf.readToken(\"0|[1-9][0-9]{0,999}\", \"A\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n// Computes (a * b) % mod\nll mulmod(ll a, ll b, ll mod) {\n    return (a % mod) * (b % mod) % mod;\n}\n\n// Computes (base ^ exponent) % mod\nll binpower(ll base, ll e, ll mod) {\n    ll result = 1;\n    base %= mod;\n    while (e > 0) {\n        if (e & 1)\n            result = mulmod(result, base, mod);\n        base = mulmod(base, base, mod);\n        e >>= 1;\n    }\n    return result % mod;\n}\n\n// Checks whether n is a composite number using witness a\nbool check_composite(ll n, ll a, ll d, int s) {\n    ll x = binpower(a, d, n);\n    if (x == 1 || x == n - 1)\n        return false;\n    for (int r = 1; r < s; r++) {\n        x = mulmod(x, x, n);\n        if (x == n - 1)\n            return false;\n    }\n    return true;\n}\n\n// Miller-Rabin primality test for n < 2^32\nbool MillerRabin(ll n) {\n    if (n < 2)\n        return false;\n    int r = 0;\n    ll d = n - 1;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        r++;\n    }\n    // Witnesses for n < 2^32\n    for (ll a : {2, 7, 61}) {\n        if (a % n == 0)\n            continue;\n        if (check_composite(n, a, d, r))\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int p = inf.readInt(1, 1000000000, \"p\");\n    inf.readSpace();\n    int alpha = inf.readInt(1, 1000000000, \"alpha\");\n    inf.readEoln();\n\n    ensuref(MillerRabin(p), \"p must be a prime number\");\n\n    string A = inf.readToken(\"0|[1-9][0-9]{0,999}\", \"A\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n// Computes (a * b) % mod\nll mulmod(ll a, ll b, ll mod) {\n    return (a % mod) * (b % mod) % mod;\n}\n\n// Computes (base ^ exponent) % mod\nll binpower(ll base, ll e, ll mod) {\n    ll result = 1;\n    base %= mod;\n    while (e > 0) {\n        if (e & 1)\n            result = mulmod(result, base, mod);\n        base = mulmod(base, base, mod);\n        e >>= 1;\n    }\n    return result % mod;\n}\n\n// Checks whether n is a composite number using witness a\nbool check_composite(ll n, ll a, ll d, int s) {\n    ll x = binpower(a, d, n);\n    if (x == 1 || x == n - 1)\n        return false;\n    for (int r = 1; r < s; r++) {\n        x = mulmod(x, x, n);\n        if (x == n - 1)\n            return false;\n    }\n    return true;\n}\n\n// Miller-Rabin primality test for n < 2^32\nbool MillerRabin(ll n) {\n    if (n < 2)\n        return false;\n    int r = 0;\n    ll d = n - 1;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        r++;\n    }\n    // Witnesses for n < 2^32\n    for (ll a : {2, 7, 61}) {\n        if (a % n == 0)\n            continue;\n        if (check_composite(n, a, d, r))\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int p = inf.readInt(1, 1000000000, \"p\");\n    inf.readSpace();\n    int alpha = inf.readInt(1, 1000000000, \"alpha\");\n    inf.readEoln();\n\n    ensuref(MillerRabin(p), \"p must be a prime number\");\n\n    string A = inf.readToken(\"0|[1-9][0-9]{0,999}\", \"A\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to perform modular multiplication (to avoid overflow)\nlong long modular_mul(long long a, long long b, long long mod) {\n    return (__int128)a * b % mod;\n}\n\n// Function to perform modular exponentiation\nlong long modular_pow(long long base, long long exponent, long long mod) {\n    long long result = 1;\n    base %= mod;\n    while (exponent) {\n        if (exponent & 1)\n            result = modular_mul(result, base, mod);\n        base = modular_mul(base, base, mod);\n        exponent >>= 1;\n    }\n    return result;\n}\n\n// Deterministic Miller-Rabin primality test for n < 2e9\nbool isPrime(int n) {\n    if (n <= 1)\n        return false;\n    int d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>=1;\n        s++;\n    }\n    int bases[] = {2,3,5,7,11};\n    for(int a : bases) {\n        if(a >= n)\n            continue;\n        long long x = modular_pow(a, d, n);\n        if (x == 1 || x == n - 1)\n            continue;\n        bool continue_outer = false;\n        for(int r = 1; r < s; r++) {\n            x = modular_mul(x, x, n);\n            if(x == n - 1) {\n                continue_outer = true;\n                break;\n            }\n        }\n        if(continue_outer)\n            continue;\n        return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string ptype = opt<string>(\"ptype\", \"random\");\n    int pvalue = opt<int>(\"pvalue\", 0);\n    string alphatype = opt<string>(\"alphatype\", \"random\");\n    int alphavalue = opt<int>(\"alphavalue\", 0);\n    string Atype = opt<string>(\"Atype\", \"random\");\n    int Alen = opt<int>(\"Alen\", 1);\n    string Avalue = opt<string>(\"Avalue\", \"\");\n\n    int p = 0;\n    int alpha = 0;\n    string A = \"\";\n\n    // Generate p\n    if(ptype == \"min\") {\n        p = 2;\n    } else if(ptype == \"max\") {\n        p = 999999937; // Largest prime less than 1e9\n    } else if(ptype == \"value\") {\n        p = pvalue;\n    } else if(ptype == \"random\") {\n        // Generate random prime between 2 and 1e9\n        while(true) {\n            p = rnd.next(2, 1000000000);\n            if(isPrime(p))\n                break;\n        }\n    } else {\n        // Default to p = 2 if incorrect ptype\n        p = 2;\n    }\n\n    // Generate alpha\n    if(alphatype == \"min\") {\n        alpha = 1;\n    } else if(alphatype == \"max\") {\n        alpha = 1000000000;\n    } else if(alphatype == \"value\") {\n        alpha = alphavalue;\n    } else if(alphatype == \"random\") {\n        alpha = rnd.next(1, 1000000000);\n    } else {\n        alpha = 1;\n    }\n\n    // Generate A\n    if(Atype == \"zero\") {\n        A = \"0\";\n    } else if(Atype == \"one\") {\n        A = \"1\";\n    } else if(Atype == \"max\") {\n        A = string(1000, '9');\n    } else if(Atype == \"value\") {\n        A = Avalue;\n    } else if(Atype == \"random\") {\n        if(Alen <= 0 || Alen > 1000)\n            Alen = 1;\n        if(Alen == 1) {\n            A = rnd.next(0,9) + '0';\n        } else {\n            A = \"\";\n            A += rnd.next('1','9'); // First digit cannot be '0'\n            for(int i = 1; i < Alen; ++i) {\n                A += rnd.next('0','9');\n            }\n        }\n    } else {\n        A = \"0\";\n    }\n\n    // Output p and alpha\n    printf(\"%d %d\\n\", p, alpha);\n    // Output A\n    printf(\"%s\\n\", A.c_str());\n\n    return 0;\n}\n\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to perform modular multiplication (to avoid overflow)\nlong long modular_mul(long long a, long long b, long long mod) {\n    return (__int128)a * b % mod;\n}\n\n// Function to perform modular exponentiation\nlong long modular_pow(long long base, long long exponent, long long mod) {\n    long long result = 1;\n    base %= mod;\n    while (exponent) {\n        if (exponent & 1)\n            result = modular_mul(result, base, mod);\n        base = modular_mul(base, base, mod);\n        exponent >>= 1;\n    }\n    return result;\n}\n\n// Deterministic Miller-Rabin primality test for n < 2e9\nbool isPrime(int n) {\n    if (n <= 1)\n        return false;\n    int d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>=1;\n        s++;\n    }\n    int bases[] = {2,3,5,7,11};\n    for(int a : bases) {\n        if(a >= n)\n            continue;\n        long long x = modular_pow(a, d, n);\n        if (x == 1 || x == n - 1)\n            continue;\n        bool continue_outer = false;\n        for(int r = 1; r < s; r++) {\n            x = modular_mul(x, x, n);\n            if(x == n - 1) {\n                continue_outer = true;\n                break;\n            }\n        }\n        if(continue_outer)\n            continue;\n        return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string ptype = opt<string>(\"ptype\", \"random\");\n    int pvalue = opt<int>(\"pvalue\", 0);\n    string alphatype = opt<string>(\"alphatype\", \"random\");\n    int alphavalue = opt<int>(\"alphavalue\", 0);\n    string Atype = opt<string>(\"Atype\", \"random\");\n    int Alen = opt<int>(\"Alen\", 1);\n    string Avalue = opt<string>(\"Avalue\", \"\");\n\n    int p = 0;\n    int alpha = 0;\n    string A = \"\";\n\n    // Generate p\n    if(ptype == \"min\") {\n        p = 2;\n    } else if(ptype == \"max\") {\n        p = 999999937; // Largest prime less than 1e9\n    } else if(ptype == \"value\") {\n        p = pvalue;\n    } else if(ptype == \"random\") {\n        // Generate random prime between 2 and 1e9\n        while(true) {\n            p = rnd.next(2, 1000000000);\n            if(isPrime(p))\n                break;\n        }\n    } else {\n        // Default to p = 2 if incorrect ptype\n        p = 2;\n    }\n\n    // Generate alpha\n    if(alphatype == \"min\") {\n        alpha = 1;\n    } else if(alphatype == \"max\") {\n        alpha = 1000000000;\n    } else if(alphatype == \"value\") {\n        alpha = alphavalue;\n    } else if(alphatype == \"random\") {\n        alpha = rnd.next(1, 1000000000);\n    } else {\n        alpha = 1;\n    }\n\n    // Generate A\n    if(Atype == \"zero\") {\n        A = \"0\";\n    } else if(Atype == \"one\") {\n        A = \"1\";\n    } else if(Atype == \"max\") {\n        A = string(1000, '9');\n    } else if(Atype == \"value\") {\n        A = Avalue;\n    } else if(Atype == \"random\") {\n        if(Alen <= 0 || Alen > 1000)\n            Alen = 1;\n        if(Alen == 1) {\n            A = rnd.next(0,9) + '0';\n        } else {\n            A = \"\";\n            A += rnd.next('1','9'); // First digit cannot be '0'\n            for(int i = 1; i < Alen; ++i) {\n                A += rnd.next('0','9');\n            }\n        }\n    } else {\n        A = \"0\";\n    }\n\n    // Output p and alpha\n    printf(\"%d %d\\n\", p, alpha);\n    // Output A\n    printf(\"%s\\n\", A.c_str());\n\n    return 0;\n}\n\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen\n./gen -ptype min -alphatype min -Atype zero\n./gen -ptype min -alphatype min -Atype one\n./gen -ptype min -alphatype min -Atype max\n./gen -ptype min -alphatype min -Atype value -Avalue 7\n./gen -ptype min -alphatype min -Atype random -Alen 1\n\n./gen -ptype max -alphatype max -Atype max\n./gen -ptype max -alphatype max -Atype random -Alen 1000\n\n./gen -ptype value -pvalue 2 -alphatype value -alphavalue 2 -Atype value -Avalue 7\n./gen -ptype value -pvalue 3 -alphatype value -alphavalue 1 -Atype value -Avalue 9\n./gen -ptype value -pvalue 3 -alphatype value -alphavalue 3 -Atype value -Avalue 9\n./gen -ptype value -pvalue 2 -alphatype value -alphavalue 4 -Atype value -Avalue 5000\n\n./gen -ptype random -alphatype random -Atype random -Alen 10\n./gen -ptype random -alphatype random -Atype random -Alen 100\n./gen -ptype random -alphatype random -Atype random -Alen 1000\n\n./gen -ptype random -alphatype max -Atype random -Alen 1000\n./gen -ptype random -alphatype min -Atype random -Alen 1000\n\n./gen -ptype random -alphatype random -Atype zero\n./gen -ptype random -alphatype random -Atype one\n./gen -ptype random -alphatype random -Atype max\n\n./gen -ptype random -alphatype random -Atype value -Avalue 12345678901234567890\n./gen -ptype random -alphatype random -Atype value -Avalue 98765432109876543210\n\n./gen -ptype value -pvalue 2 -alphatype random -Atype random -Alen 100\n./gen -ptype value -pvalue 3 -alphatype random -Atype random -Alen 100\n\n./gen -ptype value -pvalue 999999937 -alphatype value -alphavalue 1000000000 -Atype max\n\n./gen -ptype min -alphatype max -Atype random -Alen 500\n\n./gen -ptype random -alphatype value -alphavalue 1 -Atype random -Alen 200\n\n./gen -ptype random -alphatype value -alphavalue 1000000000 -Atype random -Alen 300\n\n./gen -ptype max -alphatype min -Atype random -Alen 400\n\n./gen -ptype max -alphatype max -Atype zero\n\n./gen -ptype max -alphatype max -Atype one\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:04.772150",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "582/E",
      "title": "E. Булева функция",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится выражение s (1 ≤ |s| ≤ 500), в котором некоторые символы операторов и/или переменных заменены знаком '?'. Во второй строке содержится число n (0 ≤ n ≤ 24) — количество наборов переменных, для которых известно значение функции f(A, B, C, D). В следующих n строках содержатся описания наборов: в i-й из них содержатся пять целых чисел ai, bi, ci, di, ei (0 ≤ ai, bi, ci, di, ei ≤ 1), разделенных пробелами и означающих, что f(ai, bi, ci, di) = ei. Гарантируется, что все четверки (ai, bi, ci, di) различны.",
      "output_spec": "Выходные данныеВ единственной строке выведите ответ на задачу.",
      "sample_tests": "ПримерыВходные данныеСкопировать?21 0 1 0 10 1 1 0 1Выходные данныеСкопировать2Входные данныеСкопировать(A)?(?)11 1 0 0 0Выходные данныеСкопировать4Входные данныеСкопировать((?)&(?))|((?)&(?))0Выходные данныеСкопировать4096Входные данныеСкопироватьb11 0 1 1 1Выходные данныеСкопировать1",
      "description": "E. Булева функция\n\nограничение по времени на тест4 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке содержится выражение s (1 ≤ |s| ≤ 500), в котором некоторые символы операторов и/или переменных заменены знаком '?'. Во второй строке содержится число n (0 ≤ n ≤ 24) — количество наборов переменных, для которых известно значение функции f(A, B, C, D). В следующих n строках содержатся описания наборов: в i-й из них содержатся пять целых чисел ai, bi, ci, di, ei (0 ≤ ai, bi, ci, di, ei ≤ 1), разделенных пробелами и означающих, что f(ai, bi, ci, di) = ei. Гарантируется, что все четверки (ai, bi, ci, di) различны.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите ответ на задачу.\n\nВыходные данные\n\nВходные данныеСкопировать?21 0 1 0 10 1 1 0 1Выходные данныеСкопировать2Входные данныеСкопировать(A)?(?)11 1 0 0 0Выходные данныеСкопировать4Входные данныеСкопировать((?)&(?))|((?)&(?))0Выходные данныеСкопировать4096Входные данныеСкопироватьb11 0 1 1 1Выходные данныеСкопировать1\n\nВходные данныеСкопировать?21 0 1 0 10 1 1 0 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать(A)?(?)11 1 0 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать((?)&(?))|((?)&(?))0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4096\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьb11 0 1 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере двумя подходящими выражением являются 'C' и 'd'.Во втором примере выражения выглядят так: '(A)&(a)', '(A)&(b)', '(A)&(C)', '(A)&(D)'.",
      "solutions": [
        {
          "title": "Codeforces Round #323 - Codeforces",
          "content": "Здравствуй, Codeforces!Меня зовут Данил Сагунов, и когда-то я был красным... Впрочем, поздравляю всех со Второй Революцией!Рад сообщить, что в эту субботу, 3 октября в 19:30 MSK состоится Codeforces Round #323 для обоих дивизионов. Задачи для вас придумывали и готовили я и Виталий gridnevvvit Гриднев. Это не первый раунд, в котором мы являемся авторами, и я уверен, что не последний.В подготовке задач нам помогали мои друзья Максим Neon Мещеряков, Владимир vovuh Петров и Роман Roms Глазов, за что отдельное им спасибо. Благодарю Макса Zlobober Ахмедова за координаторскую деятельность, Михаила MikeMirzayanov Мирзаянова за создание и поддержку систем Codeforces и Polygon, благодаря которым проведение раунда стало возможным, и Марию Delinur Белову за перевод условий задач на английский язык.Спасибо Владиславу winger Исенбаеву и Александру AlexFetisov Фетисову за прорешивание задач раунда!Участникам обоих дивизионов будет предложено по 5 задач и 2 часа на их решение. Надеюсь, задачи покажутся вам интересными, а многие из вас сумеют вернуть свой цвет.UPD В e-mail рассылке была указана неправильная продолжительность раунда. Соревнование будет длиться 2 часа.UPD2 Раунд успешно завершен! Благодарим всех за участие.Поздравляем победителей первого дивизиона: ecnerwala ikatanic uwi PavelKunyavskiy sd0061 И второго дивизиона: wrong_order ahwhlzz kefaa Мои поздравления fotiIe96, единственному решившему задачу D!UPD3 Разбор можно найти здесь",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20657",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1449
        },
        {
          "title": "Разбор Codeforces Round #323 - Codeforces",
          "content": "Adiv2Для решения задачи будем хранить два массива hused[j] и vused[j] размера n, изначально заполненных false. Будем обрабатывать перекрестки в списке от 1-го к n-му, и если для i-го перекрестка оба значения hused[hi] и vused[vi] равны false , i-ый день нужно добавить к ответу и установить значения hused[hi] и vused[vi] в true, означающих, что hi-ая горизонтальная и vi-ая вертикальная теперь заасфальтирована, а в противном случае нужно просто пропустить очередной перекресток.Такое решение работает за O(n2).Авторское решение: 13390628Bdiv2Чтобы получить оптимальный ответ, роботу нужно двигаться от первого компьютера к последнему, затем от последнего к первому, потом опять от первого к последнему, и т.д., попутно собирая те части информации, которые он может собрать на момент нахождения рядом с компьютером. Таким образом робот будет по максимуму использовать ресурсы, затраченные на смену направления движения. Несмотря на наличие более быстрых решений, от участников требовалось лишь решение с асимптотикой O(n2).Авторское решение: 13390612Adiv1Пусть ответ представляет собой массив a1 ≤ a2 ≤ ... ≤ an. Далее будем пользоваться тем, что gcd(ai, aj) ≤ amin(i, j). Верно, что gcd(an, an) = an ≥ ai ≥ gcd(ai, aj) для любых 1 ≤ i, j ≤ n. Это значит, что an равен максимальному элементу таблицы. Запишем в ответ an максимальный ответ и удалим его из текущего набора элементов. После удаления gcd(an, an) в наборе будут содержаться gcd(ai, aj) для любых 1 ≤ i, j ≤ n, таких, что 1 ≤ min(i, j) ≤ n - 1. Из последних двух неравенств следует, что gcd(ai, aj) ≤ amin(i, j) ≤ an - 1 = gcd(an - 1, an - 1). Поскольку в наборе содержится gcd(an - 1, an - 1), максимальный элемент в наборе равен an - 1. Поскольку an уже известен, удалим из набора gcd(an - 1, an - 1), gcd(an - 1, an), gcd(an, an - 1) . Теперь в наборе содержатся gcd(ai, aj), для любых 1 ≤ i, j ≤ n таких, что 1 ≤ min(i, j) ≤ n - 2.Далее повторим это операцию для каждого k from n - 2 to 1, устанавливая ak равным максимальному элементу в оставшемся наборе и удаляя gcd(ak, ak), gcd(ai, ak), gcd(ak, ai) для всех k < i ≤ n из набора.С помощью математической индукции нетрудно доказать корректность такого алгоритма. Чтобы быстро выполнять удаление и получение максимального элемента в наборе, можно использовать, например, структуры map или set, что позволит реализовать решение с асимптотикой .Авторское решение: 13390679Bdiv1Можно посчитать матрицу размера n × n mt[i][j] — длина наибольшей неубывающей подпоследовательности в массиве a1, a2, ..., an, начинающейся с элемента, не меньшего ai и заканчивающейся непосредственно в элементе aj.Теперь, если мы имеем две матрицы размера n × n A[i][j] (ответ для массива a1, a2, ..., apn начинающегося с элемента, не меньшего ai и заканчивающейся элементом aj в последнем блоке массива (a(p - 1)n + 1, ..., apn) и B[i][j] (ответ для массива a1, a2, ..., aqn ), то произведение этих матрицдаст подобную матрицу, но для массива из p + q блоков. Так как такое произведение матриц является ассоциативным, воспользуемся быстрым возведением матрицы в степень для подсчета M[i][j] (ответ для массива a1, a2, ..., anT) — матрица mt[i][j] в степени T. Ответ на задачу — максимум матрицы M. Такое решение имеет асимптотику .Авторское решение (с матрицами): 13390660Существует альтернативное решение. Так как a1, a2, ..., anT содержит максимум n различных элементов, любая его неубывающая подпоследовательность содержит максимум n - 1 последовательных возрастающих соседних элементов. Пользуясь этим фактом, будем считать стандартное динамическое программирование на первых n блоках массива (a1, ..., an2) и на n последних блоках массива (anT - n + 1, ..., anT). Все остальные блоки (а их T - 2n) между ними будут порождать равные элементы в результирующей неубывающей подпоследовательности.Таким образом, для фиксированного ai, в котором заканчивается неубывающая подпоследовательность длины p массива из первых n блоков, и для фиксированного aj ≥ ai, в котором аналогичная подпоследовательность длины s на последних n блоках массива начинается, нужно обновить ответ величиной p + (T - 2n)count(ai) + s, где count(x) — количество вхождений x в массив a1, ..., an. Получаем решение за .Авторское решение ( с динамикой): 13390666Cdiv1Зафиксируем s и рассмотрим каждую пару (l, s). Тогда, если превосходящий подмассива содержит ai, то ai должен быть не меньше каждого aj такого, что . Будем использовать этот факт и решать задачу для фиксированного g = gcd(n, s) (g|n). Для последующей проверки того, что ai может содержаться в превосходящем подмассиве, посчитаем для каждого 0 ≤ r < g.Каждый периодический подмассив состоит из и только из них. Для нахождения количества таких подмассивов будем пользоваться методом двух указателей и для каждого подходящего ai такого, что не является подходящим, найдем такое aj, что являются подходящими и не является подходящим. Пусть представляет подотрезок из k элементов, т.е. . Любой подотрезок этого подотрезка так же является превосходящим, поэтому к отрезкам длины 1, 2, ..., k мы должны прибавить k, k - 1, ..., 1 соответственно. Так как сумма всех k не превосходит n, можно циклом увеличивать нужные значения. Случай, когда все ai являются подходящими, нужно обрабатывать отдельно. После подсчета всех необходимых величин, мы должны добавить лишь те количества подотрезков длины x, для которых gcd(x, n) = g.Описанное решение имеет асимптотику O(d(n)n), где d(n) — количество делителей n.Авторское решение: 13390645Ddiv1Известно, что для простого p и натурального n максимальное α такое, что pα|n!, вычисляется по формуле , где pw ≤ n < pw + 1. Так как , максимальное α для вычисляется по формуле .Примечательно, что если представить n, k и n - k в p-ичной системе счисления, деление числа с округлением вниз на px соответствует отбрасыванию последних x цифр в его p-ичном представлении. Поскольку k + (n - k) = n, i-ое слагаемое в формуле для α соответствует величине переноса разряда с i - 1-ой к i-ой цифре в сложении k и n - k в p-ичной системе счисления и может принимать значения ноль или один.Переведем A в p-ичную систему счисления и будем далее работать только с этим его представлением. В случае, если α превышает количество цифр в представлении A то, как описано выше, ответ равен 0. Далее будем считать динамическое программирование на представлении числа A.dp[i][x][e][r] — ответ, если мы рассмотрели первые i цифр числа n и k, при этом эти цифры в n могут равняться первым цифрам A (булева e), x-ая степень p уже была набрана, и величина переноса с текущего в следующий разряд равна r . Переходы будем осуществлять вперед, имея, таким образом, не более p2 вариантов расстановки цифр в n и k. Поскольку перебор всех таких вариантов невозможен, нужно заметить, что для перехода в фиксированное состояние (его первый параметр равен i + 1) количество вариантов расстановки цифр равняется сумме арифметической прогрессии, поэтому переход с помощью умножения на сумму прогрессии можно осуществлять за O(1).Крайне рекомендуется ознакомиться с авторским решением за O(|A|2 + |A|min(|A|, α)).Авторское решение: 13390698Ediv1Количество бинарных функций на 4 переменных равняется 224, и каждую из них можно закодировать двоичным числом из 24 бит , где значение каждого бита соответствует значению функций в наборе переменных, соответствующему номеру бита. Верно, что если maskf и maskg соответствуют функциям f(A, B, C, D) и g(A, B, C, D), то функции (f|g)(A, B, C, D) соответствует maskf|maskg bitmask.Построим бинарное дерево разбора выражения. Замечу, что количество нелистовых вершин в нем равно . Будем считать динамическое программирование для каждой вершины v дерева разбора — dp[v][mask] равно количеству способов вставить символы в выражение, образованное поддеревом вершины v так, чтобы оно соответствовало функции, задающейся маской mask. Для листовых вершин значения динамики вычисляются ``в лоб'' перебором каждой из 16 функций и подстановкой переменной в функцию. Для нелистовых вершин существует способ перебирать все пары варинтов функций в сыновьях за 416: dp[v][lmask|rmask] +  = dp[l][lmask] * dp[r][rmask].Однако вся задача в том, чтобы делать это быстрее. Давайте посчитаем s[mask], где s[mask] равняется сумме ответов динамики для всех подмасок mask (submask&mask = submask) за 24·224 операций с помощью следующего кода: for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n for (int mask = 0; mask < (1 << 16); ++mask)\n if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];Посчитаем sl[mask] и sr[mask] для dp[l][mask] и dp[r][mask] соответственно. Если приравнять s[mask] = sl[mask] * sr[mask], s[mask] будет хранить сумму произведений пар значений масок левого и правого сына, таких, что обе эти маски являются подмасками mask. Так как нам нужны пары, побитовый OR которых даст ровно mask, нужно исключить пары, побитовый OR которых дает подмаску mask, не равную mask. Для этого будем пользоваться формулой включений-исключений:, где p равно количеству единичных бит в mask^submask.Такую сумму можно посчитать аналогичному выше образом, но используя вычитание вместо сложения: for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n for (int mask = 0; mask < (1 << 16); ++mask)\n if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];Таким образом можно пересчитывать значения динамики в вершине за 3·24·216 операций.Авторское решение: 13390713",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20692",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 9409
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #323 - Codeforces - Code 1",
          "code": "4\n2 2 2 2 2 2 2 2 2 2 2 2 4 4 4 4\nОтвет: 2 2 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 2",
          "code": "4\n2 2 2 2 2 2 2 2 2 2 2 2 4 4 4 4\nОтвет: 2 2 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 3",
          "code": "T1 = n и T2 = n + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 4",
          "code": "diff = ans2 - ans1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 5",
          "code": "(T - T1) * diff + ans1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 6",
          "code": "gcd(A, A) = A",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 7",
          "code": "gcd(A, B) <= min(A, B)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 8",
          "code": "gcd(A, B) <= B",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 9",
          "code": "gcd(B, B) = B",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 10",
          "code": "int fun(multiset st) {  multiset :: iterator it = st.end();  it--;  return it; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 11",
          "code": "int fun(multiset &st) {  multiset :: iterator it = st.end();  it--;  return it; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 12",
          "code": "multiset<...>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 13",
          "code": "vertical = vector<bool> (n, false);\n horizontal = vector<bool> (n, false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 14",
          "code": "vertical = vector<bool> (n, false);\n horizontal = vector<bool> (n, false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #323 - Codeforces - Code 1",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #323 - Codeforces - Code 2",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #323 - Codeforces - Code 3",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #323 - Codeforces - Code 4",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #323 - Codeforces - Code 5",
          "code": "(x[0], x[1], ..., x[7]) @ (y[0], y[1], ..., y[7]) = (z[0], z[1], ..., z[7])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #323 - Codeforces - Code 6",
          "code": "(x[0]+x[4], x[1]+x[5], x[2]+x[6], x[3]+x[7]) @ (y[0]+y[4], y[1]+y[5], y[2]+y[6], y[3]+y[7]) = (a, b, c, d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #323 - Codeforces - Code 7",
          "code": "(x[0], x[1], x[2], x[3]) @ (y[0], y[1], y[2], y[3]) = (e, f, g, h)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #323 - Codeforces - Code 8",
          "code": "z[4] = a - e",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #323 - Codeforces - Code 9",
          "code": "z[5] = b - f",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #323 - Codeforces - Code 10",
          "code": "z[6] = c - g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #323 - Codeforces - Code 11",
          "code": "z[7] = d - h",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #323 - Codeforces - Code 12",
          "code": "ans.pb(a[i]);\n    cnt++;\n    if(cnt==n) break;\n    for(int l=0;l<ans.size();l++)\n    {\n        //if(a[i]==274199512) cout<<__gcd(a[i],ans[l])<<\" \"<<i<<\" \"<<l<<\"\\n\";\n        gcds.push(__gcd(a[i],ans[l]))\n        gcds.push(__gcd(a[i],ans[l]));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #323 - Codeforces - Code 13",
          "code": "ans.pb(a[i]);\n    cnt++;\n    if(cnt==n) break;\n    for(int l=0;l<ans.size();l++)\n    {\n        //if(a[i]==274199512) cout<<__gcd(a[i],ans[l])<<\" \"<<i<<\" \"<<l<<\"\\n\";\n        gcds.push(__gcd(a[i],ans[l]))\n        gcds.push(__gcd(a[i],ans[l]));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #323 - Codeforces - Code 14",
          "code": "5        \n    12 1 1 2 1\n     1 7 1 1 1\n     1 1 5 1 1\n     2 1 1 2 1\n     1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #323 - Codeforces - Code 15",
          "code": "5        \n    12 1 1 2 1\n     1 7 1 1 1\n     1 1 5 1 1\n     2 1 1 2 1\n     1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #323 - Codeforces - Code 16",
          "code": "Поскольку перебор всех таких вариантов невозможен, нужно заметить, что для перехода в фиксированное состояние (его первый параметр равен i + 1) количество вариантов расстановки цифр равняется сумме арифметической прогрессии, поэтому переход с помощью умножения на сумму прогрессии можно осуществлять за O(1).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #323 - Codeforces - Code 17",
          "code": "Поскольку перебор всех таких вариантов невозможен, нужно заметить, что для перехода в фиксированное состояние (его первый параметр равен i + 1) количество вариантов расстановки цифр равняется сумме арифметической прогрессии, поэтому переход с помощью умножения на сумму прогрессии можно осуществлять за O(1).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 500, \"Length of s must be between 1 and 500 inclusive\");\n\n    // Ensure s contains only allowed characters\n    for (char c : s) {\n        ensuref(c == 'A' || c == 'B' || c == 'C' || c == 'D' || \n                c == 'a' || c == 'b' || c == 'c' || c == 'd' || \n                c == '(' || c == ')' || c == '&' || c == '|' || \n                c == '?', \"Invalid character '%c' in s\", c);\n    }\n\n    int n = inf.readInt(0, 24, \"n\");\n    inf.readEoln();\n\n    set<int> variableSet;\n\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(0, 1, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(0, 1, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(0, 1, \"ci\");\n        inf.readSpace();\n        int di = inf.readInt(0, 1, \"di\");\n        inf.readSpace();\n        int ei = inf.readInt(0, 1, \"ei\");\n        inf.readEoln();\n\n        int key = (ai << 3) | (bi << 2) | (ci << 1) | di;\n        ensuref(variableSet.count(key) == 0, \"Duplicate variable assignments found\");\n        variableSet.insert(key);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 500, \"Length of s must be between 1 and 500 inclusive\");\n\n    // Ensure s contains only allowed characters\n    for (char c : s) {\n        ensuref(c == 'A' || c == 'B' || c == 'C' || c == 'D' || \n                c == 'a' || c == 'b' || c == 'c' || c == 'd' || \n                c == '(' || c == ')' || c == '&' || c == '|' || \n                c == '?', \"Invalid character '%c' in s\", c);\n    }\n\n    int n = inf.readInt(0, 24, \"n\");\n    inf.readEoln();\n\n    set<int> variableSet;\n\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(0, 1, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(0, 1, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(0, 1, \"ci\");\n        inf.readSpace();\n        int di = inf.readInt(0, 1, \"di\");\n        inf.readSpace();\n        int ei = inf.readInt(0, 1, \"ei\");\n        inf.readEoln();\n\n        int key = (ai << 3) | (bi << 2) | (ci << 1) | di;\n        ensuref(variableSet.count(key) == 0, \"Duplicate variable assignments found\");\n        variableSet.insert(key);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 500, \"Length of s must be between 1 and 500 inclusive\");\n\n    // Ensure s contains only allowed characters\n    for (char c : s) {\n        ensuref(c == 'A' || c == 'B' || c == 'C' || c == 'D' || \n                c == 'a' || c == 'b' || c == 'c' || c == 'd' || \n                c == '(' || c == ')' || c == '&' || c == '|' || \n                c == '?', \"Invalid character '%c' in s\", c);\n    }\n\n    int n = inf.readInt(0, 24, \"n\");\n    inf.readEoln();\n\n    set<int> variableSet;\n\n    for (int i = 0; i < n; i++) {\n        int ai = inf.readInt(0, 1, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(0, 1, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(0, 1, \"ci\");\n        inf.readSpace();\n        int di = inf.readInt(0, 1, \"di\");\n        inf.readSpace();\n        int ei = inf.readInt(0, 1, \"ei\");\n        inf.readEoln();\n\n        int key = (ai << 3) | (bi << 2) | (ci << 1) | di;\n        ensuref(variableSet.count(key) == 0, \"Duplicate variable assignments found\");\n        variableSet.insert(key);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to parse and evaluate the expression\nint parse_expression(const string &expr, int &pos, const array<int,4> &vars) {\n    if (pos >= (int)expr.length()) {\n        // Error in parsing\n        cerr << \"Unexpected end of expression at position \" << pos << endl;\n        exit(1);\n    }\n    if (expr[pos] == '(') {\n        // Parse left expression\n        ++pos; // Skip '('\n        int left = parse_expression(expr, pos, vars);\n        if (pos >= (int)expr.length() || expr[pos] != ')') {\n            cerr << \"Expected ')' at position \" << pos << endl;\n            exit(1);\n        }\n        ++pos; // Skip ')'\n        if (pos >= (int)expr.length()) {\n            cerr << \"Expected operator at position \" << pos << endl;\n            exit(1);\n        }\n        char op = expr[pos];\n        if (op != '&' && op != '|') {\n            cerr << \"Expected operator '&' or '|' at position \" << pos << endl;\n            exit(1);\n        }\n        ++pos; // Skip operator\n        if (pos >= (int)expr.length() || expr[pos] != '(') {\n            cerr << \"Expected '(' at position \" << pos << endl;\n            exit(1);\n        }\n        ++pos; // Skip '('\n        int right = parse_expression(expr, pos, vars);\n        if (pos >= (int)expr.length() || expr[pos] != ')') {\n            cerr << \"Expected ')' at position \" << pos << endl;\n            exit(1);\n        }\n        ++pos; // Skip ')'\n\n        int result;\n        if (op == '&') {\n            result = left & right;\n        } else {\n            result = left | right;\n        }\n        return result;\n\n    } else {\n        // Should be a variable\n        char c = expr[pos];\n        ++pos; // Move to next character\n        int val = 0;\n        if (c == 'A') val = vars[0];\n        else if (c == 'a') val = vars[0] ^ 1;\n        else if (c == 'B') val = vars[1];\n        else if (c == 'b') val = vars[1] ^ 1;\n        else if (c == 'C') val = vars[2];\n        else if (c == 'c') val = vars[2] ^ 1;\n        else if (c == 'D') val = vars[3];\n        else if (c == 'd') val = vars[3] ^ 1;\n        else {\n            cerr << \"Unexpected character '\" << c << \"' at position \" << pos - 1 << endl;\n            exit(1);\n        }\n        return val;\n    }\n}\n\nint evaluate_expression(const string &expr, const array<int,4> &vars) {\n    int pos = 0;\n    int result = parse_expression(expr, pos, vars);\n    if (pos != (int)expr.length()) {\n        cerr << \"Unexpected extra characters at position \" << pos << endl;\n        exit(1);\n    }\n    return result;\n}\n\nstring generate_expression(int maxlen) {\n    // Base case\n    if (maxlen == 1) {\n        // Return a variable\n        char vars[] = {'A','B','C','D','a','b','c','d'};\n        char var = vars[rnd.next(8)];\n        return string(1, var);\n    }\n\n    if (maxlen < 7) {\n        // Cannot fit an operator expression, so return a variable\n        char vars[] = {'A','B','C','D','a','b','c','d'};\n        char var = vars[rnd.next(8)];\n        return string(1, var);\n    }\n\n    // Now, we can attempt to generate a composite expression\n\n    // len_left + len_right + 5 <= maxlen\n\n    int min_len = 1; // Minimum length of left or right expression\n\n    int max_total_expr_len = maxlen - 5;\n\n    int len_left = rnd.next(min_len, max_total_expr_len - min_len);\n    int len_right = max_total_expr_len - len_left;\n\n    string left = generate_expression(len_left);\n    string right = generate_expression(len_right);\n\n    char ops[] = {'&', '|'};\n    char op = ops[rnd.next(2)];\n\n    string expr = \"(\" + left + \")\" + op + \"(\" + right + \")\";\n\n    return expr;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int maxlen = opt<int>(\"maxlen\", 100);\n    int n = opt<int>(\"n\", -1); // If n == -1, we'll choose randomly\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\" || type == \"max_question_marks\" || type == \"min_question_marks\") {\n        // Generate a complete expression s_complete\n        int len = rnd.next(1, maxlen);\n        string s_complete = generate_expression(len);\n\n        // Compute function values for all variable assignments\n        map<array<int,4>, int> func_values;\n\n        // For all 16 variable assignments\n        vector<array<int,4>> all_assignments;\n        for (int a = 0; a <=1; ++a) {\n            for (int b = 0; b <=1; ++b) {\n                for (int c = 0; c <=1; ++c) {\n                    for (int d = 0; d <=1; ++d) {\n                        all_assignments.push_back({a,b,c,d});\n                    }\n                }\n            }\n        }\n\n        // Evaluate s_complete on all assignments\n        for (auto vars : all_assignments) {\n            int val = evaluate_expression(s_complete, vars);\n            func_values[vars] = val;\n        }\n\n        // Produce s by replacing characters in s_complete with '?'\n        string s = s_complete;\n\n        if (type == \"random\") {\n            // Randomly replace some characters with '?'\n            int num_question_marks = rnd.next(0, (int)s.length());\n            vector<int> positions(s.length());\n            iota(positions.begin(), positions.end(), 0);\n            shuffle(positions.begin(), positions.end());\n\n            for (int i = 0; i < num_question_marks; ++i) {\n                s[positions[i]] = '?';\n            }\n        } else if (type == \"max_question_marks\") {\n            // Replace as many characters as possible with '?', except parentheses\n            for (int i = 0; i < (int)s.length(); ++i) {\n                if (s[i] != '(' && s[i] != ')') {\n                    s[i] = '?';\n                }\n            }\n        } else if (type == \"min_question_marks\") {\n            // Replace as few characters as possible with '?'\n            // Let's randomly replace a few characters\n            int num_question_marks = rnd.next(0, 2);\n            vector<int> positions(s.length());\n            iota(positions.begin(), positions.end(), 0);\n            shuffle(positions.begin(), positions.end());\n            for (int i = 0; i < num_question_marks; ++i) {\n                if (s[positions[i]] != '(' && s[positions[i]] != ')') {\n                    s[positions[i]] = '?';\n                }\n            }\n        }\n\n        // Now, pick n variable assignments randomly\n        if (n == -1) n = rnd.next(0, 16);\n        shuffle(all_assignments.begin(), all_assignments.end());\n        vector<array<int,5>> assignments;\n\n        for (int i = 0; i < n; ++i) {\n            auto vars = all_assignments[i];\n            int val = func_values[vars];\n            assignments.push_back({vars[0], vars[1], vars[2], vars[3], val});\n        }\n\n        // Output s, n, assignments\n        cout << s << endl;\n        cout << n << endl;\n        for (auto a : assignments) {\n            cout << a[0] << ' ' << a[1] << ' ' << a[2] << ' ' << a[3] << ' ' << a[4] << endl;\n        }\n    }\n    else if (type == \"nested\") {\n        // Generate a deeply nested expression\n        int depth = min(maxlen / 7, 50); // Each nested expression has length at least 7\n        string s = \"\";\n        for (int i = 0; i < depth; ++i) {\n            s += \"(\";\n        }\n        s += \"A\";\n        for (int i = 0; i < depth; ++i) {\n            s += \")\";\n            s += \"&\";\n            s += \"(\";\n            s += \"B\";\n            s += \")\";\n        }\n\n        if ((int)s.length() > maxlen) {\n            s = s.substr(0, maxlen);\n        }\n\n        // Since the expression is complete, no '?'\n\n        // Compute function values for all variable assignments\n        map<array<int,4>, int> func_values;\n\n        // For all 16 variable assignments\n        vector<array<int,4>> all_assignments;\n        for (int a = 0; a <=1; ++a) {\n            for (int b = 0; b <=1; ++b) {\n                for (int c = 0; c <=1; ++c) {\n                    for (int d = 0; d <=1; ++d) {\n                        all_assignments.push_back({a,b,c,d});\n                    }\n                }\n            }\n        }\n\n        // Evaluate s on all assignments\n        for (auto vars : all_assignments) {\n            int val = evaluate_expression(s, vars);\n            func_values[vars] = val;\n        }\n\n        // Now, pick n variable assignments randomly\n        if (n == -1) n = rnd.next(0, 16);\n        shuffle(all_assignments.begin(), all_assignments.end());\n        vector<array<int,5>> assignments;\n\n        for (int i = 0; i < n; ++i) {\n            auto vars = all_assignments[i];\n            int val = func_values[vars];\n            assignments.push_back({vars[0], vars[1], vars[2], vars[3], val});\n        }\n\n        // Output s, n, assignments\n        cout << s << endl;\n        cout << n << endl;\n        for (auto a : assignments) {\n            cout << a[0] << ' ' << a[1] << ' ' << a[2] << ' ' << a[3] << ' ' << a[4] << endl;\n        }\n    }\n    else if (type == \"all_question_marks\") {\n        // Generate a complete expression\n        int len = rnd.next(1, maxlen);\n        string s_complete = generate_expression(len);\n\n        // Compute function values for all variable assignments\n        map<array<int,4>, int> func_values;\n\n        // For all 16 variable assignments\n        vector<array<int,4>> all_assignments;\n        for (int a = 0; a <=1; ++a) {\n            for (int b = 0; b <=1; ++b) {\n                for (int c = 0; c <=1; ++c) {\n                    for (int d = 0; d <=1; ++d) {\n                        all_assignments.push_back({a,b,c,d});\n                    }\n                }\n            }\n        }\n\n        // Evaluate s_complete on all assignments\n        for (auto vars : all_assignments) {\n            int val = evaluate_expression(s_complete, vars);\n            func_values[vars] = val;\n        }\n\n        // Now, produce s by replacing all characters with '?'\n        string s(s_complete.length(), '?');\n\n        // Now, pick n variable assignments randomly\n        if (n == -1) n = rnd.next(0, 16);\n        shuffle(all_assignments.begin(), all_assignments.end());\n        vector<array<int,5>> assignments;\n\n        for (int i = 0; i < n; ++i) {\n            auto vars = all_assignments[i];\n            int val = func_values[vars];\n            assignments.push_back({vars[0], vars[1], vars[2], vars[3], val});\n        }\n\n        // Output s, n, assignments\n        cout << s << endl;\n        cout << n << endl;\n        for (auto a : assignments) {\n            cout << a[0] << ' ' << a[1] << ' ' << a[2] << ' ' << a[3] << ' ' << a[4] << endl;\n        }\n    }\n    else {\n        // Default case\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to parse and evaluate the expression\nint parse_expression(const string &expr, int &pos, const array<int,4> &vars) {\n    if (pos >= (int)expr.length()) {\n        // Error in parsing\n        cerr << \"Unexpected end of expression at position \" << pos << endl;\n        exit(1);\n    }\n    if (expr[pos] == '(') {\n        // Parse left expression\n        ++pos; // Skip '('\n        int left = parse_expression(expr, pos, vars);\n        if (pos >= (int)expr.length() || expr[pos] != ')') {\n            cerr << \"Expected ')' at position \" << pos << endl;\n            exit(1);\n        }\n        ++pos; // Skip ')'\n        if (pos >= (int)expr.length()) {\n            cerr << \"Expected operator at position \" << pos << endl;\n            exit(1);\n        }\n        char op = expr[pos];\n        if (op != '&' && op != '|') {\n            cerr << \"Expected operator '&' or '|' at position \" << pos << endl;\n            exit(1);\n        }\n        ++pos; // Skip operator\n        if (pos >= (int)expr.length() || expr[pos] != '(') {\n            cerr << \"Expected '(' at position \" << pos << endl;\n            exit(1);\n        }\n        ++pos; // Skip '('\n        int right = parse_expression(expr, pos, vars);\n        if (pos >= (int)expr.length() || expr[pos] != ')') {\n            cerr << \"Expected ')' at position \" << pos << endl;\n            exit(1);\n        }\n        ++pos; // Skip ')'\n\n        int result;\n        if (op == '&') {\n            result = left & right;\n        } else {\n            result = left | right;\n        }\n        return result;\n\n    } else {\n        // Should be a variable\n        char c = expr[pos];\n        ++pos; // Move to next character\n        int val = 0;\n        if (c == 'A') val = vars[0];\n        else if (c == 'a') val = vars[0] ^ 1;\n        else if (c == 'B') val = vars[1];\n        else if (c == 'b') val = vars[1] ^ 1;\n        else if (c == 'C') val = vars[2];\n        else if (c == 'c') val = vars[2] ^ 1;\n        else if (c == 'D') val = vars[3];\n        else if (c == 'd') val = vars[3] ^ 1;\n        else {\n            cerr << \"Unexpected character '\" << c << \"' at position \" << pos - 1 << endl;\n            exit(1);\n        }\n        return val;\n    }\n}\n\nint evaluate_expression(const string &expr, const array<int,4> &vars) {\n    int pos = 0;\n    int result = parse_expression(expr, pos, vars);\n    if (pos != (int)expr.length()) {\n        cerr << \"Unexpected extra characters at position \" << pos << endl;\n        exit(1);\n    }\n    return result;\n}\n\nstring generate_expression(int maxlen) {\n    // Base case\n    if (maxlen == 1) {\n        // Return a variable\n        char vars[] = {'A','B','C','D','a','b','c','d'};\n        char var = vars[rnd.next(8)];\n        return string(1, var);\n    }\n\n    if (maxlen < 7) {\n        // Cannot fit an operator expression, so return a variable\n        char vars[] = {'A','B','C','D','a','b','c','d'};\n        char var = vars[rnd.next(8)];\n        return string(1, var);\n    }\n\n    // Now, we can attempt to generate a composite expression\n\n    // len_left + len_right + 5 <= maxlen\n\n    int min_len = 1; // Minimum length of left or right expression\n\n    int max_total_expr_len = maxlen - 5;\n\n    int len_left = rnd.next(min_len, max_total_expr_len - min_len);\n    int len_right = max_total_expr_len - len_left;\n\n    string left = generate_expression(len_left);\n    string right = generate_expression(len_right);\n\n    char ops[] = {'&', '|'};\n    char op = ops[rnd.next(2)];\n\n    string expr = \"(\" + left + \")\" + op + \"(\" + right + \")\";\n\n    return expr;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int maxlen = opt<int>(\"maxlen\", 100);\n    int n = opt<int>(\"n\", -1); // If n == -1, we'll choose randomly\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\" || type == \"max_question_marks\" || type == \"min_question_marks\") {\n        // Generate a complete expression s_complete\n        int len = rnd.next(1, maxlen);\n        string s_complete = generate_expression(len);\n\n        // Compute function values for all variable assignments\n        map<array<int,4>, int> func_values;\n\n        // For all 16 variable assignments\n        vector<array<int,4>> all_assignments;\n        for (int a = 0; a <=1; ++a) {\n            for (int b = 0; b <=1; ++b) {\n                for (int c = 0; c <=1; ++c) {\n                    for (int d = 0; d <=1; ++d) {\n                        all_assignments.push_back({a,b,c,d});\n                    }\n                }\n            }\n        }\n\n        // Evaluate s_complete on all assignments\n        for (auto vars : all_assignments) {\n            int val = evaluate_expression(s_complete, vars);\n            func_values[vars] = val;\n        }\n\n        // Produce s by replacing characters in s_complete with '?'\n        string s = s_complete;\n\n        if (type == \"random\") {\n            // Randomly replace some characters with '?'\n            int num_question_marks = rnd.next(0, (int)s.length());\n            vector<int> positions(s.length());\n            iota(positions.begin(), positions.end(), 0);\n            shuffle(positions.begin(), positions.end());\n\n            for (int i = 0; i < num_question_marks; ++i) {\n                s[positions[i]] = '?';\n            }\n        } else if (type == \"max_question_marks\") {\n            // Replace as many characters as possible with '?', except parentheses\n            for (int i = 0; i < (int)s.length(); ++i) {\n                if (s[i] != '(' && s[i] != ')') {\n                    s[i] = '?';\n                }\n            }\n        } else if (type == \"min_question_marks\") {\n            // Replace as few characters as possible with '?'\n            // Let's randomly replace a few characters\n            int num_question_marks = rnd.next(0, 2);\n            vector<int> positions(s.length());\n            iota(positions.begin(), positions.end(), 0);\n            shuffle(positions.begin(), positions.end());\n            for (int i = 0; i < num_question_marks; ++i) {\n                if (s[positions[i]] != '(' && s[positions[i]] != ')') {\n                    s[positions[i]] = '?';\n                }\n            }\n        }\n\n        // Now, pick n variable assignments randomly\n        if (n == -1) n = rnd.next(0, 16);\n        shuffle(all_assignments.begin(), all_assignments.end());\n        vector<array<int,5>> assignments;\n\n        for (int i = 0; i < n; ++i) {\n            auto vars = all_assignments[i];\n            int val = func_values[vars];\n            assignments.push_back({vars[0], vars[1], vars[2], vars[3], val});\n        }\n\n        // Output s, n, assignments\n        cout << s << endl;\n        cout << n << endl;\n        for (auto a : assignments) {\n            cout << a[0] << ' ' << a[1] << ' ' << a[2] << ' ' << a[3] << ' ' << a[4] << endl;\n        }\n    }\n    else if (type == \"nested\") {\n        // Generate a deeply nested expression\n        int depth = min(maxlen / 7, 50); // Each nested expression has length at least 7\n        string s = \"\";\n        for (int i = 0; i < depth; ++i) {\n            s += \"(\";\n        }\n        s += \"A\";\n        for (int i = 0; i < depth; ++i) {\n            s += \")\";\n            s += \"&\";\n            s += \"(\";\n            s += \"B\";\n            s += \")\";\n        }\n\n        if ((int)s.length() > maxlen) {\n            s = s.substr(0, maxlen);\n        }\n\n        // Since the expression is complete, no '?'\n\n        // Compute function values for all variable assignments\n        map<array<int,4>, int> func_values;\n\n        // For all 16 variable assignments\n        vector<array<int,4>> all_assignments;\n        for (int a = 0; a <=1; ++a) {\n            for (int b = 0; b <=1; ++b) {\n                for (int c = 0; c <=1; ++c) {\n                    for (int d = 0; d <=1; ++d) {\n                        all_assignments.push_back({a,b,c,d});\n                    }\n                }\n            }\n        }\n\n        // Evaluate s on all assignments\n        for (auto vars : all_assignments) {\n            int val = evaluate_expression(s, vars);\n            func_values[vars] = val;\n        }\n\n        // Now, pick n variable assignments randomly\n        if (n == -1) n = rnd.next(0, 16);\n        shuffle(all_assignments.begin(), all_assignments.end());\n        vector<array<int,5>> assignments;\n\n        for (int i = 0; i < n; ++i) {\n            auto vars = all_assignments[i];\n            int val = func_values[vars];\n            assignments.push_back({vars[0], vars[1], vars[2], vars[3], val});\n        }\n\n        // Output s, n, assignments\n        cout << s << endl;\n        cout << n << endl;\n        for (auto a : assignments) {\n            cout << a[0] << ' ' << a[1] << ' ' << a[2] << ' ' << a[3] << ' ' << a[4] << endl;\n        }\n    }\n    else if (type == \"all_question_marks\") {\n        // Generate a complete expression\n        int len = rnd.next(1, maxlen);\n        string s_complete = generate_expression(len);\n\n        // Compute function values for all variable assignments\n        map<array<int,4>, int> func_values;\n\n        // For all 16 variable assignments\n        vector<array<int,4>> all_assignments;\n        for (int a = 0; a <=1; ++a) {\n            for (int b = 0; b <=1; ++b) {\n                for (int c = 0; c <=1; ++c) {\n                    for (int d = 0; d <=1; ++d) {\n                        all_assignments.push_back({a,b,c,d});\n                    }\n                }\n            }\n        }\n\n        // Evaluate s_complete on all assignments\n        for (auto vars : all_assignments) {\n            int val = evaluate_expression(s_complete, vars);\n            func_values[vars] = val;\n        }\n\n        // Now, produce s by replacing all characters with '?'\n        string s(s_complete.length(), '?');\n\n        // Now, pick n variable assignments randomly\n        if (n == -1) n = rnd.next(0, 16);\n        shuffle(all_assignments.begin(), all_assignments.end());\n        vector<array<int,5>> assignments;\n\n        for (int i = 0; i < n; ++i) {\n            auto vars = all_assignments[i];\n            int val = func_values[vars];\n            assignments.push_back({vars[0], vars[1], vars[2], vars[3], val});\n        }\n\n        // Output s, n, assignments\n        cout << s << endl;\n        cout << n << endl;\n        for (auto a : assignments) {\n            cout << a[0] << ' ' << a[1] << ' ' << a[2] << ' ' << a[3] << ' ' << a[4] << endl;\n        }\n    }\n    else {\n        // Default case\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -maxlen 10 -type random\n./gen -maxlen 50 -type random -n 5\n./gen -maxlen 100 -type random -n 10\n./gen -maxlen 500 -type random -n 16\n\n./gen -maxlen 10 -type max_question_marks\n./gen -maxlen 50 -type max_question_marks -n 5\n./gen -maxlen 100 -type max_question_marks -n 10\n./gen -maxlen 500 -type max_question_marks -n 16\n\n./gen -maxlen 10 -type min_question_marks\n./gen -maxlen 50 -type min_question_marks -n 5\n./gen -maxlen 100 -type min_question_marks -n 10\n./gen -maxlen 500 -type min_question_marks -n 16\n\n./gen -maxlen 10 -type nested -n 0\n./gen -maxlen 50 -type nested -n 5\n./gen -maxlen 100 -type nested -n 10\n./gen -maxlen 500 -type nested -n 16\n\n./gen -maxlen 500 -type all_question_marks -n 0\n./gen -maxlen 500 -type all_question_marks -n 5\n./gen -maxlen 500 -type all_question_marks -n 10\n./gen -maxlen 500 -type all_question_marks -n 16\n\n./gen -maxlen 1 -type random -n 0\n./gen -maxlen 1 -type random -n 1\n\n./gen -maxlen 500 -type random -n 0\n./gen -maxlen 500 -type random -n 24\n\n./gen -maxlen 500 -type max_question_marks -n 24\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:06.437579",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "583/A",
      "title": "A. Asphalting Roads",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 50) — the number of vertical and horizontal roads in the city. Next n2 lines contain the order of intersections in the schedule. The i-th of them contains two numbers hi, vi (1 ≤ hi, vi ≤ n), separated by a space, and meaning that the intersection that goes i-th in the timetable is at the intersection of the hi-th horizontal and vi-th vertical roads. It is guaranteed that all the intersections in the timetable are distinct.",
      "output_spec": "OutputIn the single line print the numbers of the days when road works will be in progress in ascending order. The days are numbered starting from 1.",
      "sample_tests": "ExamplesInputCopy21 11 22 12 2OutputCopy1 4 InputCopy11 1OutputCopy1",
      "description": "A. Asphalting Roads\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 50) — the number of vertical and horizontal roads in the city. Next n2 lines contain the order of intersections in the schedule. The i-th of them contains two numbers hi, vi (1 ≤ hi, vi ≤ n), separated by a space, and meaning that the intersection that goes i-th in the timetable is at the intersection of the hi-th horizontal and vi-th vertical roads. It is guaranteed that all the intersections in the timetable are distinct.\n\nOutputIn the single line print the numbers of the days when road works will be in progress in ascending order. The days are numbered starting from 1.\n\nInputCopy21 11 22 12 2OutputCopy1 4 InputCopy11 1OutputCopy1\n\nInputCopy21 11 22 12 2\n\nOutputCopy1 4\n\nInputCopy11 1\n\nOutputCopy1\n\nNoteIn the sample the brigade acts like that:  On the first day the brigade comes to the intersection of the 1-st horizontal and the 1-st vertical road. As none of them has been asphalted, the workers asphalt the 1-st vertical and the 1-st horizontal road;  On the second day the brigade of the workers comes to the intersection of the 1-st horizontal and the 2-nd vertical road. The 2-nd vertical road hasn't been asphalted, but as the 1-st horizontal road has been asphalted on the first day, the workers leave and do not asphalt anything;  On the third day the brigade of the workers come to the intersection of the 2-nd horizontal and the 1-st vertical road. The 2-nd horizontal road hasn't been asphalted but as the 1-st vertical road has been asphalted on the first day, the workers leave and do not asphalt anything;  On the fourth day the brigade come to the intersection formed by the intersection of the 2-nd horizontal and 2-nd vertical road. As none of them has been asphalted, the workers asphalt the 2-nd vertical and the 2-nd horizontal road.",
      "solutions": [
        {
          "title": "Codeforces Round #323 - Codeforces",
          "content": "Greetings, Codeforces!My name is Danil Sagunov, and I used to be red... Anyway, I wish to congratulate you with the Second Revolution!I am glad to introduce that this Saturday, 3rd October at 19:30 MSK Codeforces Round #323 for both divisions will take place. Problemset has been prepared for you by me and Vitaly gridnevvvit Gridnev. This is not the first round we are authors of and I'm sure that it's not the last.Special thanks to our friends Maxim Neon Mescheryakov, Vladimir vovuh Petrov and Roman Roms Glazov for helping us preparing the round. I would like to thank Max Zlobober Akhmedov for his coordinator activity, Michael MikeMirzayanov Mirzayanov for creating and supporting Codeforces and Polygon systems, making this round possible, and Maria Delinur Belova for translating problem statements into English.Thanks to Vladislav winger Isenbaev and Alex AlexFetisov Fetisov for testing the round problemset!Both division participants will be given five problems and two hours to solve them. I hope that everyone will find the problems interesting and many of you will return your colors.UPD The round duration was written incorrectly in the e-mail announcement, the correct duration is 2 hours, not 2.5 hours.UPD2 Round have been successfully finished! Thank you all for participating.Congratulations to 1 division winners! ecnerwala ikatanic uwi PavelKunyavskiy sd0061 And the second division: wrong_order ahwhlzz kefaa My gratitude to fotiIe96, one to solve problem D!UPD3 Editorial can be found here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20657",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1514
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces",
          "content": "Adiv2To solve the problem one could just store two arrays hused[j] and vused[j] sized n and filled with false initially. Then process intersections one by one from 1 to n, and if for i-th intersections both hused[hi] and vused[vi] are false, add i to answer and set both hused[hi] and vused[vi] with true meaning that hi-th horizontal and vi-th vertical roads are now asphalted, and skip asphalting the intersection roads otherwise.Such solution has O(n2) complexity.Jury's solution: 13390628Bdiv2It is always optimal to pass all the computers in the row, starting from 1-st to n-th, then from n-th to first, then again from first to n-th, etc. and collecting the information parts as possible, while not all of them are collected. Such way gives robot maximal use of every direction change. O(n2) solution using this approach must have been passed system tests.Jury's solution: 13390612Adiv1Let the answer be a1 ≤ a2 ≤ ... ≤ an. We will use the fact that gcd(ai, aj) ≤ amin(i, j). It is true that gcd(an, an) = an ≥ ai ≥ gcd(ai, aj) for every 1 ≤ i, j ≤ n. That means that an is equal to maximum element in the table. Let set an to maximal element in the table and delete it from table elements set. We've deleted gcd(an, an), so the set now contains all gcd(ai, aj), for every 1 ≤ i, j ≤ n and 1 ≤ min(i, j) ≤ n - 1. By the last two inequalities gcd(ai, aj) ≤ amin(i, j) ≤ an - 1 = gcd(an - 1, an - 1). As soon as set contains gcd(an - 1, an - 1), the maximum element in current element set is equal to an - 1. As far as we already know an, let's delete the gcd(an - 1, an - 1), gcd(an - 1, an), gcd(an, an - 1) from the element set. Now set contains all the gcd(ai, aj), for every 1 ≤ i, j ≤ n and 1 ≤ min(i, j) ≤ n - 2.We're repeating that operation for every k from n - 2 to 1, setting ak to maximum element in the set and deleting the gcd(ak, ak), gcd(ai, ak), gcd(ak, ai) for every k < i ≤ n from the set.One could prove correctness of this algorithm by mathematical induction. For performing deleting and getting maximum element operations one could use multiset or map structure, so solution has complexity .Jury's solution: 13390679Bdiv1One could calculate matrix sized n × n mt[i][j] — the length of the longest non-decreasing subsequence in array a1, a2, ..., an, starting at element, greater-or-equal to ai and ending strictly in aj element with j-th index.One could prove that if we have two matrices sized n × n A[i][j] (the answer for a1, a2, ..., apn starting at element, greater-or-equal to ai and ending strictly in aj element with j-th index inside last block (a(p - 1)n + 1, ..., apn) and B[i][j] (the answer for a1, a2, ..., aqn ), then the multiplication of this matrices in a waywill give the same matrix but for length p + q. As soon as such multiplication is associative, next we will use fast matrix exponentiation algorithm to calculate M[i][j] (the answer for a1, a2, ..., anT) — matrix mt[i][j] raised in power T. The answer is the maximum in matrix M. Such solution has complexity .Jury's solution (with matrices): 13390660There's an alternative solution. As soon as a1, a2, ..., anT contains maximum n distinct elements, it's any non-decreasing subsequence has a maximum of n - 1 increasing consequtive element pairs. Using that fact, one could calculate standard longest non-decreasing subsequence dynamic programming on first n array blocks (a1, ..., an2) and longest non-decreasing subsequence DP on the last n array blocks (anT - n + 1, ..., anT). All other T - 2n blocks between them will make subsegment of consequtive equal elements in longest non-decreasing subsequence.So, for fixed ai, in which longest non-decreasing subsequence of length p on first n blocks array ends, and for fixed aj ≥ ai, in which longest non-decreasing subsequence of length s on last n blocks array starts, we must update the answer with p + (T - 2n)count(ai) + s, where count(x) is the number of occurences of x in a1, ..., an array. This gives us solution.Jury's solution (with suffix and prefix): 13390666Cdiv1Let's fix s for every (l, s) pair. One could easily prove, that if subarray contains ai element, than ai must be greater-or-equal than aj for every j such that . Let's use this idea and fix g = gcd(n, s) (it must be a divisor of n). To check if ai can be in subarray with such constraints, let's for every 0 ≤ r < g calculate .It's true that every good subarray must consist of and only of . For finding all such subarrays we will use two pointers approach and for every good ai, such that is not good we will find aj such that are good and is not good. Let has k elements . Any it's subarray is superior, so it gives us arrays of length 1, 2, ..., k with count k, k - 1, ..., 1. As soon as sum of all k is not greater than n, we could just increase counts straightforward. There's a case when all ai are good, in which we must do another increases. Next we must add to the answer only counts of length x, such that gcd(x, n) = g.Solution described above has complexity O(d(n)n), where d(n) is the number of divisors of n.Jury's solution: 13390645Ddiv1It is a common fact that for a prime p and integer n maximum α, such that pα|n! is calculated as , where pw ≤ n < pw + 1. As soon as , the maximum α for is calculated as .One could see, that if we consider numbers n, k and n - k in p-th based numeric system, rounded-down division by px means dropping last x digits of its p-th based representation. As soon as k + (n - k) = n, every i-th summand in α corresponds to carry in adding k to n - k in p-th numeric system from i - 1-th to i-th digit position and is to be 0 or 1.First, let convert A given in statement from 10 to p-th numeric system. In case, if α is greater than number of digits in A in p-th numeric system, the answer is 0. Next we will calculate dynamic programming on A p-th based representation.dp[i][x][e][r] — the answer for prefix of length i possible equal to prefix of A representation (indicator e), x-th power of p was already calculated, and there must be carry equal to r from current to previous position. One could calculate it by bruteforcing all of p2 variants of placing i-th digits in n and k according to r and e and i-th digit of A, and make a translation to next state. It can be avoided by noticing that the number of variants of placing digits is always a sum of arithmetic progression and can be calculated in O(1).It's highly recommended to examine jury's solution with complexity O(|A|2 + |A|min(|A|, α)).Jury's solution: 13390698Ediv1One could prove that the number of binary functions on 4 variables is equal to 224, and can be coded by storing a 24-bit binary mask, in which every bit is storing function value for corresponding variable set. It is true, that if maskf and maskg are correspond to functions f(A, B, C, D) and g(A, B, C, D), then function (f&g)(A, B, C, D) corresponds to maskf&maskg bitmask.Now, we could parse expression given input into binary tree. I should notice that the number of non-list nodes of such tree is about . Now, let's calculate dynamic programming on every vertex v — dp[v][mask] is the number of ways to place symbols in expression in the way that subtree of vertex v will correspond to function representing by mask. For list nodes such dynamic is calculated pretty straightforward by considering all possible mask values and matching it with the variable. One could easily recalculate it for one node using calculated answers for left and right subtree in 416 operations: dp[v][lmask|rmask] +  = dp[l][lmask] * dp[r][rmask].But all the task is how to make it faster. One could calculate s[mask], where s[mask] is equal to sum of all its submasks (the masks containing 1-bits only in positions where mask contains 1-bits) in 24·224 operations using following code: for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n for (int mask = 0; mask < (1 << 16); ++mask)\n if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];Let's calculate sl[mask] and sr[mask] for dp[l][mask] and dp[r][mask] respectively. If we will find s[mask] = sl[mask] * sr[mask], s[mask] will contain multiplications of values of pairs of masks from left and right dp's, which are submasks of mask. As soon as we need pairs, which in bitwise OR will give us exactly mask, we should exclude pairs, which in bitwise OR gives a submask of mask, not equal to mask. This gives us exclusion-inclusion principle idea. The formula of this will be, where p is the parity of number of bits in mask^submask.Such sum could be calculated with approach above, but subtracting instead of adding for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n for (int mask = 0; mask < (1 << 16); ++mask)\n if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];In such way we will recalculate dynamic for one vertex in about 3·24·216 operations.Jury's solution: 13390713",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20692",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 8922
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #323 - Codeforces - Code 1",
          "code": "gcd(A, A) = A",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 2",
          "code": "gcd(A, B) <= min(A, B)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 3",
          "code": "gcd(A, B) <= B",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 4",
          "code": "gcd(B, B) = B",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 5",
          "code": "int fun(multiset st) {  multiset :: iterator it = st.end();  it--;  return it; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 6",
          "code": "int fun(multiset &st) {  multiset :: iterator it = st.end();  it--;  return it; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 7",
          "code": "multiset<...>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 8",
          "code": "vertical = vector<bool> (n, false);\n horizontal = vector<bool> (n, false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 9",
          "code": "vertical = vector<bool> (n, false);\n horizontal = vector<bool> (n, false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 1",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 2",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 3",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 4",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 5",
          "code": "(x[0], x[1], ..., x[7]) @ (y[0], y[1], ..., y[7]) = (z[0], z[1], ..., z[7])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 6",
          "code": "(x[0]+x[4], x[1]+x[5], x[2]+x[6], x[3]+x[7]) @ (y[0]+y[4], y[1]+y[5], y[2]+y[6], y[3]+y[7]) = (a, b, c, d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 7",
          "code": "(x[0], x[1], x[2], x[3]) @ (y[0], y[1], y[2], y[3]) = (e, f, g, h)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 8",
          "code": "z[4] = a - e",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 9",
          "code": "z[5] = b - f",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 10",
          "code": "z[6] = c - g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 11",
          "code": "z[7] = d - h",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 12",
          "code": "ans.pb(a[i]);\n    cnt++;\n    if(cnt==n) break;\n    for(int l=0;l<ans.size();l++)\n    {\n        //if(a[i]==274199512) cout<<__gcd(a[i],ans[l])<<\" \"<<i<<\" \"<<l<<\"\\n\";\n        gcds.push(__gcd(a[i],ans[l]))\n        gcds.push(__gcd(a[i],ans[l]));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 13",
          "code": "ans.pb(a[i]);\n    cnt++;\n    if(cnt==n) break;\n    for(int l=0;l<ans.size();l++)\n    {\n        //if(a[i]==274199512) cout<<__gcd(a[i],ans[l])<<\" \"<<i<<\" \"<<l<<\"\\n\";\n        gcds.push(__gcd(a[i],ans[l]))\n        gcds.push(__gcd(a[i],ans[l]));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 14",
          "code": "5        \n    12 1 1 2 1\n     1 7 1 1 1\n     1 1 5 1 1\n     2 1 1 2 1\n     1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 15",
          "code": "5        \n    12 1 1 2 1\n     1 7 1 1 1\n     1 1 5 1 1\n     2 1 1 2 1\n     1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    set<pair<int, int>> intersections;\n    for (int i = 0; i < n * n; i++) {\n        int hi = inf.readInt(1, n, \"hi\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        pair<int, int> intersection = make_pair(hi, vi);\n        ensuref(intersections.insert(intersection).second, \"Intersections must be distinct, found duplicate at line %d\", i + 2);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    set<pair<int, int>> intersections;\n    for (int i = 0; i < n * n; i++) {\n        int hi = inf.readInt(1, n, \"hi\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        pair<int, int> intersection = make_pair(hi, vi);\n        ensuref(intersections.insert(intersection).second, \"Intersections must be distinct, found duplicate at line %d\", i + 2);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    set<pair<int, int>> intersections;\n    for (int i = 0; i < n * n; i++) {\n        int hi = inf.readInt(1, n, \"hi\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        pair<int, int> intersection = make_pair(hi, vi);\n        ensuref(intersections.insert(intersection).second, \"Intersections must be distinct, found duplicate at line %d\", i + 2);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    ensure(1 <= n && n <= 50);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> intersections;\n\n    // Generate all possible intersections\n    for (int h = 1; h <= n; ++h) {\n        for (int v = 1; v <= n; ++v) {\n            intersections.push_back({h, v});\n        }\n    }\n\n    if (type == \"random\") {\n        shuffle(intersections.begin(), intersections.end());\n    } else if (type == \"max_asphalt\") {\n        // Ensure that for first n days, both h and v are unique\n        intersections.clear();\n        for (int i = 1; i <= n; ++i) {\n            intersections.push_back({i, i});\n        }\n        vector<pair<int,int>> rest;\n        for (int h = 1; h <= n; ++h) {\n            for (int v = 1; v <= n; ++v) {\n                if (h != v) {\n                    rest.push_back({h, v});\n                }\n            }\n        }\n        shuffle(rest.begin(), rest.end());\n        for (auto p : rest) {\n            intersections.push_back(p);\n        }\n    } else if (type == \"min_asphalt\") {\n        // First intersection is (1, 1)\n        intersections.clear();\n        intersections.push_back({1, 1});\n        for (int i = 2; i <= n; ++i) {\n            intersections.push_back({1, i});\n        }\n        for (int i = 2; i <= n; ++i) {\n            intersections.push_back({i, 1});\n        }\n        vector<pair<int,int>> rest;\n        for (int h = 2; h <= n; ++h) {\n            for (int v = 2; v <= n; ++v) {\n                if (h != 1 && v != 1) {\n                    rest.push_back({h, v});\n                }\n            }\n        }\n        shuffle(rest.begin(), rest.end());\n        for (auto p : rest) {\n            intersections.push_back(p);\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the schedule\n    for (auto p : intersections) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    ensure(1 <= n && n <= 50);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> intersections;\n\n    // Generate all possible intersections\n    for (int h = 1; h <= n; ++h) {\n        for (int v = 1; v <= n; ++v) {\n            intersections.push_back({h, v});\n        }\n    }\n\n    if (type == \"random\") {\n        shuffle(intersections.begin(), intersections.end());\n    } else if (type == \"max_asphalt\") {\n        // Ensure that for first n days, both h and v are unique\n        intersections.clear();\n        for (int i = 1; i <= n; ++i) {\n            intersections.push_back({i, i});\n        }\n        vector<pair<int,int>> rest;\n        for (int h = 1; h <= n; ++h) {\n            for (int v = 1; v <= n; ++v) {\n                if (h != v) {\n                    rest.push_back({h, v});\n                }\n            }\n        }\n        shuffle(rest.begin(), rest.end());\n        for (auto p : rest) {\n            intersections.push_back(p);\n        }\n    } else if (type == \"min_asphalt\") {\n        // First intersection is (1, 1)\n        intersections.clear();\n        intersections.push_back({1, 1});\n        for (int i = 2; i <= n; ++i) {\n            intersections.push_back({1, i});\n        }\n        for (int i = 2; i <= n; ++i) {\n            intersections.push_back({i, 1});\n        }\n        vector<pair<int,int>> rest;\n        for (int h = 2; h <= n; ++h) {\n            for (int v = 2; v <= n; ++v) {\n                if (h != 1 && v != 1) {\n                    rest.push_back({h, v});\n                }\n            }\n        }\n        shuffle(rest.begin(), rest.end());\n        for (auto p : rest) {\n            intersections.push_back(p);\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the schedule\n    for (auto p : intersections) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type max_asphalt\n./gen -n 1 -type min_asphalt\n\n./gen -n 2 -type random\n./gen -n 2 -type max_asphalt\n./gen -n 2 -type min_asphalt\n\n./gen -n 3 -type random\n./gen -n 3 -type max_asphalt\n./gen -n 3 -type min_asphalt\n\n./gen -n 4 -type random\n./gen -n 4 -type max_asphalt\n./gen -n 4 -type min_asphalt\n\n./gen -n 5 -type random\n./gen -n 5 -type max_asphalt\n./gen -n 5 -type min_asphalt\n\n./gen -n 10 -type random\n./gen -n 10 -type max_asphalt\n./gen -n 10 -type min_asphalt\n\n./gen -n 20 -type random\n./gen -n 20 -type max_asphalt\n./gen -n 20 -type min_asphalt\n\n./gen -n 30 -type random\n./gen -n 30 -type max_asphalt\n./gen -n 30 -type min_asphalt\n\n./gen -n 40 -type random\n./gen -n 40 -type max_asphalt\n./gen -n 40 -type min_asphalt\n\n./gen -n 50 -type random\n./gen -n 50 -type max_asphalt\n./gen -n 50 -type min_asphalt\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:08.206835",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "583/B",
      "title": "B. Robot's Task",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains number n (1 ≤ n ≤ 1000). The second line contains n non-negative integers a1, a2, ..., an (0 ≤ ai < n), separated by a space. It is guaranteed that there exists a way for robot to collect all pieces of the information.",
      "output_spec": "OutputPrint a single number — the minimum number of changes in direction that the robot will have to make in order to collect all n parts of information.",
      "sample_tests": "ExamplesInputCopy30 2 0OutputCopy1InputCopy54 2 3 0 1OutputCopy3InputCopy70 3 1 0 5 2 6OutputCopy2",
      "description": "B. Robot's Task\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains number n (1 ≤ n ≤ 1000). The second line contains n non-negative integers a1, a2, ..., an (0 ≤ ai < n), separated by a space. It is guaranteed that there exists a way for robot to collect all pieces of the information.\n\nOutputPrint a single number — the minimum number of changes in direction that the robot will have to make in order to collect all n parts of information.\n\nInputCopy30 2 0OutputCopy1InputCopy54 2 3 0 1OutputCopy3InputCopy70 3 1 0 5 2 6OutputCopy2\n\nInputCopy30 2 0\n\nOutputCopy1\n\nInputCopy54 2 3 0 1\n\nOutputCopy3\n\nInputCopy70 3 1 0 5 2 6\n\nOutputCopy2\n\nNoteIn the first sample you can assemble all the pieces of information in the optimal manner by assembling first the piece of information in the first computer, then in the third one, then change direction and move to the second one, and then, having 2 pieces of information, collect the last piece.In the second sample to collect all the pieces of information in the optimal manner, Doc can go to the fourth computer and get the piece of information, then go to the fifth computer with one piece and get another one, then go to the second computer in the same manner, then to the third one and finally, to the first one. Changes of direction will take place before moving from the fifth to the second computer, then from the second to the third computer, then from the third to the first computer.In the third sample the optimal order of collecting parts from computers can look like that: 1->3->4->6->2->5->7.",
      "solutions": [
        {
          "title": "Codeforces Round #323 - Codeforces",
          "content": "Greetings, Codeforces!My name is Danil Sagunov, and I used to be red... Anyway, I wish to congratulate you with the Second Revolution!I am glad to introduce that this Saturday, 3rd October at 19:30 MSK Codeforces Round #323 for both divisions will take place. Problemset has been prepared for you by me and Vitaly gridnevvvit Gridnev. This is not the first round we are authors of and I'm sure that it's not the last.Special thanks to our friends Maxim Neon Mescheryakov, Vladimir vovuh Petrov and Roman Roms Glazov for helping us preparing the round. I would like to thank Max Zlobober Akhmedov for his coordinator activity, Michael MikeMirzayanov Mirzayanov for creating and supporting Codeforces and Polygon systems, making this round possible, and Maria Delinur Belova for translating problem statements into English.Thanks to Vladislav winger Isenbaev and Alex AlexFetisov Fetisov for testing the round problemset!Both division participants will be given five problems and two hours to solve them. I hope that everyone will find the problems interesting and many of you will return your colors.UPD The round duration was written incorrectly in the e-mail announcement, the correct duration is 2 hours, not 2.5 hours.UPD2 Round have been successfully finished! Thank you all for participating.Congratulations to 1 division winners! ecnerwala ikatanic uwi PavelKunyavskiy sd0061 And the second division: wrong_order ahwhlzz kefaa My gratitude to fotiIe96, one to solve problem D!UPD3 Editorial can be found here",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/20657",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1514
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces",
          "content": "Adiv2To solve the problem one could just store two arrays hused[j] and vused[j] sized n and filled with false initially. Then process intersections one by one from 1 to n, and if for i-th intersections both hused[hi] and vused[vi] are false, add i to answer and set both hused[hi] and vused[vi] with true meaning that hi-th horizontal and vi-th vertical roads are now asphalted, and skip asphalting the intersection roads otherwise.Such solution has O(n2) complexity.Jury's solution: 13390628Bdiv2It is always optimal to pass all the computers in the row, starting from 1-st to n-th, then from n-th to first, then again from first to n-th, etc. and collecting the information parts as possible, while not all of them are collected. Such way gives robot maximal use of every direction change. O(n2) solution using this approach must have been passed system tests.Jury's solution: 13390612Adiv1Let the answer be a1 ≤ a2 ≤ ... ≤ an. We will use the fact that gcd(ai, aj) ≤ amin(i, j). It is true that gcd(an, an) = an ≥ ai ≥ gcd(ai, aj) for every 1 ≤ i, j ≤ n. That means that an is equal to maximum element in the table. Let set an to maximal element in the table and delete it from table elements set. We've deleted gcd(an, an), so the set now contains all gcd(ai, aj), for every 1 ≤ i, j ≤ n and 1 ≤ min(i, j) ≤ n - 1. By the last two inequalities gcd(ai, aj) ≤ amin(i, j) ≤ an - 1 = gcd(an - 1, an - 1). As soon as set contains gcd(an - 1, an - 1), the maximum element in current element set is equal to an - 1. As far as we already know an, let's delete the gcd(an - 1, an - 1), gcd(an - 1, an), gcd(an, an - 1) from the element set. Now set contains all the gcd(ai, aj), for every 1 ≤ i, j ≤ n and 1 ≤ min(i, j) ≤ n - 2.We're repeating that operation for every k from n - 2 to 1, setting ak to maximum element in the set and deleting the gcd(ak, ak), gcd(ai, ak), gcd(ak, ai) for every k < i ≤ n from the set.One could prove correctness of this algorithm by mathematical induction. For performing deleting and getting maximum element operations one could use multiset or map structure, so solution has complexity .Jury's solution: 13390679Bdiv1One could calculate matrix sized n × n mt[i][j] — the length of the longest non-decreasing subsequence in array a1, a2, ..., an, starting at element, greater-or-equal to ai and ending strictly in aj element with j-th index.One could prove that if we have two matrices sized n × n A[i][j] (the answer for a1, a2, ..., apn starting at element, greater-or-equal to ai and ending strictly in aj element with j-th index inside last block (a(p - 1)n + 1, ..., apn) and B[i][j] (the answer for a1, a2, ..., aqn ), then the multiplication of this matrices in a waywill give the same matrix but for length p + q. As soon as such multiplication is associative, next we will use fast matrix exponentiation algorithm to calculate M[i][j] (the answer for a1, a2, ..., anT) — matrix mt[i][j] raised in power T. The answer is the maximum in matrix M. Such solution has complexity .Jury's solution (with matrices): 13390660There's an alternative solution. As soon as a1, a2, ..., anT contains maximum n distinct elements, it's any non-decreasing subsequence has a maximum of n - 1 increasing consequtive element pairs. Using that fact, one could calculate standard longest non-decreasing subsequence dynamic programming on first n array blocks (a1, ..., an2) and longest non-decreasing subsequence DP on the last n array blocks (anT - n + 1, ..., anT). All other T - 2n blocks between them will make subsegment of consequtive equal elements in longest non-decreasing subsequence.So, for fixed ai, in which longest non-decreasing subsequence of length p on first n blocks array ends, and for fixed aj ≥ ai, in which longest non-decreasing subsequence of length s on last n blocks array starts, we must update the answer with p + (T - 2n)count(ai) + s, where count(x) is the number of occurences of x in a1, ..., an array. This gives us solution.Jury's solution (with suffix and prefix): 13390666Cdiv1Let's fix s for every (l, s) pair. One could easily prove, that if subarray contains ai element, than ai must be greater-or-equal than aj for every j such that . Let's use this idea and fix g = gcd(n, s) (it must be a divisor of n). To check if ai can be in subarray with such constraints, let's for every 0 ≤ r < g calculate .It's true that every good subarray must consist of and only of . For finding all such subarrays we will use two pointers approach and for every good ai, such that is not good we will find aj such that are good and is not good. Let has k elements . Any it's subarray is superior, so it gives us arrays of length 1, 2, ..., k with count k, k - 1, ..., 1. As soon as sum of all k is not greater than n, we could just increase counts straightforward. There's a case when all ai are good, in which we must do another increases. Next we must add to the answer only counts of length x, such that gcd(x, n) = g.Solution described above has complexity O(d(n)n), where d(n) is the number of divisors of n.Jury's solution: 13390645Ddiv1It is a common fact that for a prime p and integer n maximum α, such that pα|n! is calculated as , where pw ≤ n < pw + 1. As soon as , the maximum α for is calculated as .One could see, that if we consider numbers n, k and n - k in p-th based numeric system, rounded-down division by px means dropping last x digits of its p-th based representation. As soon as k + (n - k) = n, every i-th summand in α corresponds to carry in adding k to n - k in p-th numeric system from i - 1-th to i-th digit position and is to be 0 or 1.First, let convert A given in statement from 10 to p-th numeric system. In case, if α is greater than number of digits in A in p-th numeric system, the answer is 0. Next we will calculate dynamic programming on A p-th based representation.dp[i][x][e][r] — the answer for prefix of length i possible equal to prefix of A representation (indicator e), x-th power of p was already calculated, and there must be carry equal to r from current to previous position. One could calculate it by bruteforcing all of p2 variants of placing i-th digits in n and k according to r and e and i-th digit of A, and make a translation to next state. It can be avoided by noticing that the number of variants of placing digits is always a sum of arithmetic progression and can be calculated in O(1).It's highly recommended to examine jury's solution with complexity O(|A|2 + |A|min(|A|, α)).Jury's solution: 13390698Ediv1One could prove that the number of binary functions on 4 variables is equal to 224, and can be coded by storing a 24-bit binary mask, in which every bit is storing function value for corresponding variable set. It is true, that if maskf and maskg are correspond to functions f(A, B, C, D) and g(A, B, C, D), then function (f&g)(A, B, C, D) corresponds to maskf&maskg bitmask.Now, we could parse expression given input into binary tree. I should notice that the number of non-list nodes of such tree is about . Now, let's calculate dynamic programming on every vertex v — dp[v][mask] is the number of ways to place symbols in expression in the way that subtree of vertex v will correspond to function representing by mask. For list nodes such dynamic is calculated pretty straightforward by considering all possible mask values and matching it with the variable. One could easily recalculate it for one node using calculated answers for left and right subtree in 416 operations: dp[v][lmask|rmask] +  = dp[l][lmask] * dp[r][rmask].But all the task is how to make it faster. One could calculate s[mask], where s[mask] is equal to sum of all its submasks (the masks containing 1-bits only in positions where mask contains 1-bits) in 24·224 operations using following code: for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n for (int mask = 0; mask < (1 << 16); ++mask)\n if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];Let's calculate sl[mask] and sr[mask] for dp[l][mask] and dp[r][mask] respectively. If we will find s[mask] = sl[mask] * sr[mask], s[mask] will contain multiplications of values of pairs of masks from left and right dp's, which are submasks of mask. As soon as we need pairs, which in bitwise OR will give us exactly mask, we should exclude pairs, which in bitwise OR gives a submask of mask, not equal to mask. This gives us exclusion-inclusion principle idea. The formula of this will be, where p is the parity of number of bits in mask^submask.Such sum could be calculated with approach above, but subtracting instead of adding for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n for (int mask = 0; mask < (1 << 16); ++mask)\n if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];In such way we will recalculate dynamic for one vertex in about 3·24·216 operations.Jury's solution: 13390713",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/20692",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 8922
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #323 - Codeforces - Code 1",
          "code": "gcd(A, A) = A",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 2",
          "code": "gcd(A, B) <= min(A, B)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 3",
          "code": "gcd(A, B) <= B",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 4",
          "code": "gcd(B, B) = B",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 5",
          "code": "int fun(multiset st) {  multiset :: iterator it = st.end();  it--;  return it; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 6",
          "code": "int fun(multiset &st) {  multiset :: iterator it = st.end();  it--;  return it; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 7",
          "code": "multiset<...>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 8",
          "code": "vertical = vector<bool> (n, false);\n horizontal = vector<bool> (n, false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 9",
          "code": "vertical = vector<bool> (n, false);\n horizontal = vector<bool> (n, false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 1",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 2",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 3",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 4",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 5",
          "code": "(x[0], x[1], ..., x[7]) @ (y[0], y[1], ..., y[7]) = (z[0], z[1], ..., z[7])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 6",
          "code": "(x[0]+x[4], x[1]+x[5], x[2]+x[6], x[3]+x[7]) @ (y[0]+y[4], y[1]+y[5], y[2]+y[6], y[3]+y[7]) = (a, b, c, d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 7",
          "code": "(x[0], x[1], x[2], x[3]) @ (y[0], y[1], y[2], y[3]) = (e, f, g, h)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 8",
          "code": "z[4] = a - e",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 9",
          "code": "z[5] = b - f",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 10",
          "code": "z[6] = c - g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 11",
          "code": "z[7] = d - h",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 12",
          "code": "ans.pb(a[i]);\n    cnt++;\n    if(cnt==n) break;\n    for(int l=0;l<ans.size();l++)\n    {\n        //if(a[i]==274199512) cout<<__gcd(a[i],ans[l])<<\" \"<<i<<\" \"<<l<<\"\\n\";\n        gcds.push(__gcd(a[i],ans[l]))\n        gcds.push(__gcd(a[i],ans[l]));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 13",
          "code": "ans.pb(a[i]);\n    cnt++;\n    if(cnt==n) break;\n    for(int l=0;l<ans.size();l++)\n    {\n        //if(a[i]==274199512) cout<<__gcd(a[i],ans[l])<<\" \"<<i<<\" \"<<l<<\"\\n\";\n        gcds.push(__gcd(a[i],ans[l]))\n        gcds.push(__gcd(a[i],ans[l]));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 14",
          "code": "5        \n    12 1 1 2 1\n     1 7 1 1 1\n     1 1 5 1 1\n     2 1 1 2 1\n     1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 15",
          "code": "5        \n    12 1 1 2 1\n     1 7 1 1 1\n     1 1 5 1 1\n     2 1 1 2 1\n     1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, n - 1, \"a\");\n    inf.readEoln();\n\n    ensuref(a[0] == 0, \"a1 must be 0, since robot starts with 0 pieces of information but a1=%d\", a[0]);\n\n    int current_pieces = 1; // Collected first piece\n    vector<bool> collected(n, false);\n    collected[0] = true;\n\n    while (true) {\n        bool collected_any = false;\n        for (int i = 0; i < n; ++i) {\n            if (!collected[i] && a[i] <= current_pieces - 1) {\n                collected[i] = true;\n                current_pieces += 1;\n                collected_any = true;\n            }\n        }\n        if (!collected_any) {\n            break;\n        }\n    }\n\n    ensuref(current_pieces >= n, \"Cannot collect all pieces of information\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, n - 1, \"a\");\n    inf.readEoln();\n\n    ensuref(a[0] == 0, \"a1 must be 0, since robot starts with 0 pieces of information but a1=%d\", a[0]);\n\n    int current_pieces = 1; // Collected first piece\n    vector<bool> collected(n, false);\n    collected[0] = true;\n\n    while (true) {\n        bool collected_any = false;\n        for (int i = 0; i < n; ++i) {\n            if (!collected[i] && a[i] <= current_pieces - 1) {\n                collected[i] = true;\n                current_pieces += 1;\n                collected_any = true;\n            }\n        }\n        if (!collected_any) {\n            break;\n        }\n    }\n\n    ensuref(current_pieces >= n, \"Cannot collect all pieces of information\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, n - 1, \"a\");\n    inf.readEoln();\n\n    ensuref(a[0] == 0, \"a1 must be 0, since robot starts with 0 pieces of information but a1=%d\", a[0]);\n\n    int current_pieces = 1; // Collected first piece\n    vector<bool> collected(n, false);\n    collected[0] = true;\n\n    while (true) {\n        bool collected_any = false;\n        for (int i = 0; i < n; ++i) {\n            if (!collected[i] && a[i] <= current_pieces - 1) {\n                collected[i] = true;\n                current_pieces += 1;\n                collected_any = true;\n            }\n        }\n        if (!collected_any) {\n            break;\n        }\n    }\n\n    ensuref(current_pieces >= n, \"Cannot collect all pieces of information\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_zero\") {\n        // ai = 0 for all i\n        for (int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"increasing\") {\n        // ai[i] = i\n        for (int i = 0; i < n; ++i)\n            a[i] = i;\n    } else if (type == \"decreasing\") {\n        // ai[i] = n - i - 1\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i - 1;\n    } else if (type == \"random_valid\") {\n        // Generate ai such that ai[i] <= i\n        a[0] = 0; // The robot can collect from the first computer immediately\n        for (int i = 1; i < n; ++i)\n            a[i] = rnd.next(0, i); // ai[i] between 0 and i\n    } else if (type == \"zigzag\") {\n        // ai alternates between 0 and n - 1\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? 0 : n - 1;\n        a[0] = 0;\n    } else if (type == \"max_ai\") {\n        // ai = n - 1 for all i except first few\n        for (int i = 0; i < n; ++i)\n            a[i] = n - 1;\n        // Ensure solvability by setting some ai to lower values\n        int k = min(n, 3);\n        for (int i = 0; i < k; ++i)\n            a[i] = i;\n    } else {\n        // Default: random ai, ensure solvability\n        a[0] = 0;\n        for (int i = 1; i < n; ++i)\n            a[i] = rnd.next(0, min(n - 1, i));\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_zero\") {\n        // ai = 0 for all i\n        for (int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"increasing\") {\n        // ai[i] = i\n        for (int i = 0; i < n; ++i)\n            a[i] = i;\n    } else if (type == \"decreasing\") {\n        // ai[i] = n - i - 1\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i - 1;\n    } else if (type == \"random_valid\") {\n        // Generate ai such that ai[i] <= i\n        a[0] = 0; // The robot can collect from the first computer immediately\n        for (int i = 1; i < n; ++i)\n            a[i] = rnd.next(0, i); // ai[i] between 0 and i\n    } else if (type == \"zigzag\") {\n        // ai alternates between 0 and n - 1\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? 0 : n - 1;\n        a[0] = 0;\n    } else if (type == \"max_ai\") {\n        // ai = n - 1 for all i except first few\n        for (int i = 0; i < n; ++i)\n            a[i] = n - 1;\n        // Ensure solvability by setting some ai to lower values\n        int k = min(n, 3);\n        for (int i = 0; i < k; ++i)\n            a[i] = i;\n    } else {\n        // Default: random ai, ensure solvability\n        a[0] = 0;\n        for (int i = 1; i < n; ++i)\n            a[i] = rnd.next(0, min(n - 1, i));\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_zero\n./gen -n 1 -type increasing\n./gen -n 1 -type decreasing\n./gen -n 1 -type random_valid\n\n./gen -n 10 -type all_zero\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type random_valid\n\n./gen -n 100 -type all_zero\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type random_valid\n\n./gen -n 500 -type all_zero\n./gen -n 500 -type increasing\n./gen -n 500 -type decreasing\n./gen -n 500 -type random_valid\n\n./gen -n 1000 -type all_zero\n./gen -n 1000 -type increasing\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type random_valid\n\n./gen -n 1000 -type zigzag\n./gen -n 1000 -type max_ai\n\n./gen -n 1000 -type random_valid\n./gen -n 1000 -type random_valid\n./gen -n 1000 -type random_valid\n\n./gen -n 1000 -type random_valid\n./gen -n 950 -type random_valid\n./gen -n 900 -type random_valid\n./gen -n 850 -type random_valid\n./gen -n 800 -type random_valid\n./gen -n 750 -type random_valid\n./gen -n 700 -type random_valid\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:10.284500",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "583/C",
      "title": "C. GCD Table",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains number n (1 ≤ n ≤ 500) — the length of array a. The second line contains n2 space-separated numbers — the elements of the GCD table of G for array a. All the numbers in the table are positive integers, not exceeding 109. Note that the elements are given in an arbitrary order. It is guaranteed that the set of the input data corresponds to some array a.",
      "output_spec": "OutputIn the single line print n positive integers — the elements of array a. If there are multiple possible solutions, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy42 1 2 3 4 3 2 6 1 1 2 2 1 2 3 2OutputCopy4 3 6 2InputCopy142OutputCopy42 InputCopy21 1 1 1OutputCopy1 1",
      "description": "C. GCD Table\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains number n (1 ≤ n ≤ 500) — the length of array a. The second line contains n2 space-separated numbers — the elements of the GCD table of G for array a. All the numbers in the table are positive integers, not exceeding 109. Note that the elements are given in an arbitrary order. It is guaranteed that the set of the input data corresponds to some array a.\n\nOutputIn the single line print n positive integers — the elements of array a. If there are multiple possible solutions, you are allowed to print any of them.\n\nInputCopy42 1 2 3 4 3 2 6 1 1 2 2 1 2 3 2OutputCopy4 3 6 2InputCopy142OutputCopy42 InputCopy21 1 1 1OutputCopy1 1\n\nInputCopy42 1 2 3 4 3 2 6 1 1 2 2 1 2 3 2\n\nOutputCopy4 3 6 2\n\nInputCopy142\n\nOutputCopy42\n\nInputCopy21 1 1 1\n\nOutputCopy1 1",
      "solutions": [
        {
          "title": "Codeforces Round #323 - Codeforces",
          "content": "Greetings, Codeforces!My name is Danil Sagunov, and I used to be red... Anyway, I wish to congratulate you with the Second Revolution!I am glad to introduce that this Saturday, 3rd October at 19:30 MSK Codeforces Round #323 for both divisions will take place. Problemset has been prepared for you by me and Vitaly gridnevvvit Gridnev. This is not the first round we are authors of and I'm sure that it's not the last.Special thanks to our friends Maxim Neon Mescheryakov, Vladimir vovuh Petrov and Roman Roms Glazov for helping us preparing the round. I would like to thank Max Zlobober Akhmedov for his coordinator activity, Michael MikeMirzayanov Mirzayanov for creating and supporting Codeforces and Polygon systems, making this round possible, and Maria Delinur Belova for translating problem statements into English.Thanks to Vladislav winger Isenbaev and Alex AlexFetisov Fetisov for testing the round problemset!Both division participants will be given five problems and two hours to solve them. I hope that everyone will find the problems interesting and many of you will return your colors.UPD The round duration was written incorrectly in the e-mail announcement, the correct duration is 2 hours, not 2.5 hours.UPD2 Round have been successfully finished! Thank you all for participating.Congratulations to 1 division winners! ecnerwala ikatanic uwi PavelKunyavskiy sd0061 And the second division: wrong_order ahwhlzz kefaa My gratitude to fotiIe96, one to solve problem D!UPD3 Editorial can be found here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20657",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1514
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces",
          "content": "Adiv2To solve the problem one could just store two arrays hused[j] and vused[j] sized n and filled with false initially. Then process intersections one by one from 1 to n, and if for i-th intersections both hused[hi] and vused[vi] are false, add i to answer and set both hused[hi] and vused[vi] with true meaning that hi-th horizontal and vi-th vertical roads are now asphalted, and skip asphalting the intersection roads otherwise.Such solution has O(n2) complexity.Jury's solution: 13390628Bdiv2It is always optimal to pass all the computers in the row, starting from 1-st to n-th, then from n-th to first, then again from first to n-th, etc. and collecting the information parts as possible, while not all of them are collected. Such way gives robot maximal use of every direction change. O(n2) solution using this approach must have been passed system tests.Jury's solution: 13390612Adiv1Let the answer be a1 ≤ a2 ≤ ... ≤ an. We will use the fact that gcd(ai, aj) ≤ amin(i, j). It is true that gcd(an, an) = an ≥ ai ≥ gcd(ai, aj) for every 1 ≤ i, j ≤ n. That means that an is equal to maximum element in the table. Let set an to maximal element in the table and delete it from table elements set. We've deleted gcd(an, an), so the set now contains all gcd(ai, aj), for every 1 ≤ i, j ≤ n and 1 ≤ min(i, j) ≤ n - 1. By the last two inequalities gcd(ai, aj) ≤ amin(i, j) ≤ an - 1 = gcd(an - 1, an - 1). As soon as set contains gcd(an - 1, an - 1), the maximum element in current element set is equal to an - 1. As far as we already know an, let's delete the gcd(an - 1, an - 1), gcd(an - 1, an), gcd(an, an - 1) from the element set. Now set contains all the gcd(ai, aj), for every 1 ≤ i, j ≤ n and 1 ≤ min(i, j) ≤ n - 2.We're repeating that operation for every k from n - 2 to 1, setting ak to maximum element in the set and deleting the gcd(ak, ak), gcd(ai, ak), gcd(ak, ai) for every k < i ≤ n from the set.One could prove correctness of this algorithm by mathematical induction. For performing deleting and getting maximum element operations one could use multiset or map structure, so solution has complexity .Jury's solution: 13390679Bdiv1One could calculate matrix sized n × n mt[i][j] — the length of the longest non-decreasing subsequence in array a1, a2, ..., an, starting at element, greater-or-equal to ai and ending strictly in aj element with j-th index.One could prove that if we have two matrices sized n × n A[i][j] (the answer for a1, a2, ..., apn starting at element, greater-or-equal to ai and ending strictly in aj element with j-th index inside last block (a(p - 1)n + 1, ..., apn) and B[i][j] (the answer for a1, a2, ..., aqn ), then the multiplication of this matrices in a waywill give the same matrix but for length p + q. As soon as such multiplication is associative, next we will use fast matrix exponentiation algorithm to calculate M[i][j] (the answer for a1, a2, ..., anT) — matrix mt[i][j] raised in power T. The answer is the maximum in matrix M. Such solution has complexity .Jury's solution (with matrices): 13390660There's an alternative solution. As soon as a1, a2, ..., anT contains maximum n distinct elements, it's any non-decreasing subsequence has a maximum of n - 1 increasing consequtive element pairs. Using that fact, one could calculate standard longest non-decreasing subsequence dynamic programming on first n array blocks (a1, ..., an2) and longest non-decreasing subsequence DP on the last n array blocks (anT - n + 1, ..., anT). All other T - 2n blocks between them will make subsegment of consequtive equal elements in longest non-decreasing subsequence.So, for fixed ai, in which longest non-decreasing subsequence of length p on first n blocks array ends, and for fixed aj ≥ ai, in which longest non-decreasing subsequence of length s on last n blocks array starts, we must update the answer with p + (T - 2n)count(ai) + s, where count(x) is the number of occurences of x in a1, ..., an array. This gives us solution.Jury's solution (with suffix and prefix): 13390666Cdiv1Let's fix s for every (l, s) pair. One could easily prove, that if subarray contains ai element, than ai must be greater-or-equal than aj for every j such that . Let's use this idea and fix g = gcd(n, s) (it must be a divisor of n). To check if ai can be in subarray with such constraints, let's for every 0 ≤ r < g calculate .It's true that every good subarray must consist of and only of . For finding all such subarrays we will use two pointers approach and for every good ai, such that is not good we will find aj such that are good and is not good. Let has k elements . Any it's subarray is superior, so it gives us arrays of length 1, 2, ..., k with count k, k - 1, ..., 1. As soon as sum of all k is not greater than n, we could just increase counts straightforward. There's a case when all ai are good, in which we must do another increases. Next we must add to the answer only counts of length x, such that gcd(x, n) = g.Solution described above has complexity O(d(n)n), where d(n) is the number of divisors of n.Jury's solution: 13390645Ddiv1It is a common fact that for a prime p and integer n maximum α, such that pα|n! is calculated as , where pw ≤ n < pw + 1. As soon as , the maximum α for is calculated as .One could see, that if we consider numbers n, k and n - k in p-th based numeric system, rounded-down division by px means dropping last x digits of its p-th based representation. As soon as k + (n - k) = n, every i-th summand in α corresponds to carry in adding k to n - k in p-th numeric system from i - 1-th to i-th digit position and is to be 0 or 1.First, let convert A given in statement from 10 to p-th numeric system. In case, if α is greater than number of digits in A in p-th numeric system, the answer is 0. Next we will calculate dynamic programming on A p-th based representation.dp[i][x][e][r] — the answer for prefix of length i possible equal to prefix of A representation (indicator e), x-th power of p was already calculated, and there must be carry equal to r from current to previous position. One could calculate it by bruteforcing all of p2 variants of placing i-th digits in n and k according to r and e and i-th digit of A, and make a translation to next state. It can be avoided by noticing that the number of variants of placing digits is always a sum of arithmetic progression and can be calculated in O(1).It's highly recommended to examine jury's solution with complexity O(|A|2 + |A|min(|A|, α)).Jury's solution: 13390698Ediv1One could prove that the number of binary functions on 4 variables is equal to 224, and can be coded by storing a 24-bit binary mask, in which every bit is storing function value for corresponding variable set. It is true, that if maskf and maskg are correspond to functions f(A, B, C, D) and g(A, B, C, D), then function (f&g)(A, B, C, D) corresponds to maskf&maskg bitmask.Now, we could parse expression given input into binary tree. I should notice that the number of non-list nodes of such tree is about . Now, let's calculate dynamic programming on every vertex v — dp[v][mask] is the number of ways to place symbols in expression in the way that subtree of vertex v will correspond to function representing by mask. For list nodes such dynamic is calculated pretty straightforward by considering all possible mask values and matching it with the variable. One could easily recalculate it for one node using calculated answers for left and right subtree in 416 operations: dp[v][lmask|rmask] +  = dp[l][lmask] * dp[r][rmask].But all the task is how to make it faster. One could calculate s[mask], where s[mask] is equal to sum of all its submasks (the masks containing 1-bits only in positions where mask contains 1-bits) in 24·224 operations using following code: for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n for (int mask = 0; mask < (1 << 16); ++mask)\n if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];Let's calculate sl[mask] and sr[mask] for dp[l][mask] and dp[r][mask] respectively. If we will find s[mask] = sl[mask] * sr[mask], s[mask] will contain multiplications of values of pairs of masks from left and right dp's, which are submasks of mask. As soon as we need pairs, which in bitwise OR will give us exactly mask, we should exclude pairs, which in bitwise OR gives a submask of mask, not equal to mask. This gives us exclusion-inclusion principle idea. The formula of this will be, where p is the parity of number of bits in mask^submask.Such sum could be calculated with approach above, but subtracting instead of adding for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n for (int mask = 0; mask < (1 << 16); ++mask)\n if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];In such way we will recalculate dynamic for one vertex in about 3·24·216 operations.Jury's solution: 13390713",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20692",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 8922
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #323 - Codeforces - Code 1",
          "code": "gcd(A, A) = A",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 2",
          "code": "gcd(A, B) <= min(A, B)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 3",
          "code": "gcd(A, B) <= B",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 4",
          "code": "gcd(B, B) = B",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 5",
          "code": "int fun(multiset st) {  multiset :: iterator it = st.end();  it--;  return it; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 6",
          "code": "int fun(multiset &st) {  multiset :: iterator it = st.end();  it--;  return it; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 7",
          "code": "multiset<...>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 8",
          "code": "vertical = vector<bool> (n, false);\n horizontal = vector<bool> (n, false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 9",
          "code": "vertical = vector<bool> (n, false);\n horizontal = vector<bool> (n, false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 1",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 2",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 3",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 4",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 5",
          "code": "(x[0], x[1], ..., x[7]) @ (y[0], y[1], ..., y[7]) = (z[0], z[1], ..., z[7])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 6",
          "code": "(x[0]+x[4], x[1]+x[5], x[2]+x[6], x[3]+x[7]) @ (y[0]+y[4], y[1]+y[5], y[2]+y[6], y[3]+y[7]) = (a, b, c, d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 7",
          "code": "(x[0], x[1], x[2], x[3]) @ (y[0], y[1], y[2], y[3]) = (e, f, g, h)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 8",
          "code": "z[4] = a - e",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 9",
          "code": "z[5] = b - f",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 10",
          "code": "z[6] = c - g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 11",
          "code": "z[7] = d - h",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 12",
          "code": "ans.pb(a[i]);\n    cnt++;\n    if(cnt==n) break;\n    for(int l=0;l<ans.size();l++)\n    {\n        //if(a[i]==274199512) cout<<__gcd(a[i],ans[l])<<\" \"<<i<<\" \"<<l<<\"\\n\";\n        gcds.push(__gcd(a[i],ans[l]))\n        gcds.push(__gcd(a[i],ans[l]));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 13",
          "code": "ans.pb(a[i]);\n    cnt++;\n    if(cnt==n) break;\n    for(int l=0;l<ans.size();l++)\n    {\n        //if(a[i]==274199512) cout<<__gcd(a[i],ans[l])<<\" \"<<i<<\" \"<<l<<\"\\n\";\n        gcds.push(__gcd(a[i],ans[l]))\n        gcds.push(__gcd(a[i],ans[l]));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 14",
          "code": "5        \n    12 1 1 2 1\n     1 7 1 1 1\n     1 1 5 1 1\n     2 1 1 2 1\n     1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 15",
          "code": "5        \n    12 1 1 2 1\n     1 7 1 1 1\n     1 1 5 1 1\n     2 1 1 2 1\n     1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500);\n    inf.readEoln();\n\n    int totalNumbers = n * n;\n    std::vector<int> numbers = inf.readInts(totalNumbers, 1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500);\n    inf.readEoln();\n\n    int totalNumbers = n * n;\n    std::vector<int> numbers = inf.readInts(totalNumbers, 1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500);\n    inf.readEoln();\n\n    int totalNumbers = n * n;\n    std::vector<int> numbers = inf.readInts(totalNumbers, 1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read n from input file\n    int n = inf.readInt(1, 500, \"n\");\n    // Read n^2 numbers from input file, store in multiset\n    multiset<int> Gorig;\n    for (int i = 0; i < n * n; i++) {\n        int g = inf.readInt(1, int(1e9), \"G[i]\");\n        Gorig.insert(g);\n    }\n    // Read participant's output\n    vector<int> a;\n    for (int i = 0; i < n; i++) {\n        int ai = ouf.readInt(1, int(1e9), format(\"a[%d]\", i + 1).c_str());\n        a.push_back(ai);\n    }\n    // Ensure no extra output\n    if (!ouf.seekEof())\n        ouf.quitf(_wa, \"Extra output after reading n integers\");\n    // Compute GCDs from participant's array, store in multiset\n    multiset<int> Gp;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            int g = __gcd(a[i], a[j]);\n            Gp.insert(g);\n        }\n    }\n    // Compare the two multisets\n    if (Gorig == Gp) {\n        quitf(_ok, \"Correct answer\");\n    } else {\n        quitf(_wa, \"Wrong answer: computed GCD table does not match input GCD table\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to compute gcd\nint compute_gcd(int a, int b) {\n    while (b) {\n        int tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\"); // default to \"random\" if not provided\n\n    vector<int> a(n);\n\n    if (type == \"all_ones\") {\n        // All elements are 1\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"all_equal\") {\n        int k = opt<int>(\"k\", rnd.next(1, int(1e9)));\n        for (int i = 0; i < n; ++i)\n            a[i] = k;\n    } else if (type == \"small_numbers\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 10);\n    } else if (type == \"large_numbers\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(int(1e9) - int(1e5), int(1e9));\n    } else if (type == \"primes\") {\n        // Generate n distinct small primes\n        vector<int> primes;\n        int limit = 10000;\n        vector<bool> is_prime(limit + 1, true);\n        for (int i = 2; i <= limit && primes.size() < n; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                for (int j = i * 2; j <= limit; j += i)\n                    is_prime[j] = false;\n            }\n        }\n        if (n > primes.size()) {\n            printf(\"Not enough primes for n = %d\\n\", n);\n            return 1;\n        }\n        shuffle(primes.begin(), primes.end());\n        for (int i = 0; i < n; ++i)\n            a[i] = primes[i];\n    } else if (type == \"pairwise_coprime\") {\n        // Generate n distinct small primes\n        vector<int> primes;\n        int limit = 10000;\n        vector<bool> is_prime(limit + 1, true);\n        for (int i = 2; i <= limit && primes.size() < n; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                for (int j = i * 2; j <= limit; j += i)\n                    is_prime[j] = false;\n            }\n        }\n        if (n > primes.size()) {\n            printf(\"Not enough primes for n = %d\\n\", n);\n            return 1;\n        }\n        shuffle(primes.begin(), primes.end());\n        for (int i = 0; i < n; ++i)\n            a[i] = primes[i];\n    } else if (type == \"equal_pairs\") {\n        if (n % 2 != 0) {\n            printf(\"n must be even for equal_pairs type\\n\");\n            return 1;\n        }\n        for (int i = 0; i < n; i += 2) {\n            int val = rnd.next(1, int(1e9));\n            a[i] = a[i + 1] = val;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"repeats\") {\n        int num_distinct = rnd.next(1, n);\n        vector<int> vals(num_distinct);\n        for (int i = 0; i < num_distinct; ++i)\n            vals[i] = rnd.next(1, int(1e9));\n        for (int i = 0; i < n; ++i)\n            a[i] = vals[rnd.next(0, num_distinct - 1)];\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, int(1e9));\n    } else {\n        printf(\"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Compute GCD table\n    vector<int> G_list;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j) {\n            int g = compute_gcd(a[i], a[j]);\n            G_list.push_back(g);\n        }\n\n    // Shuffle G_list\n    shuffle(G_list.begin(), G_list.end());\n\n    // Output n and G_list\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < G_list.size(); ++i) {\n        printf(\"%d\", G_list[i]);\n        if (i + 1 < G_list.size())\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to compute gcd\nint compute_gcd(int a, int b) {\n    while (b) {\n        int tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\"); // default to \"random\" if not provided\n\n    vector<int> a(n);\n\n    if (type == \"all_ones\") {\n        // All elements are 1\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"all_equal\") {\n        int k = opt<int>(\"k\", rnd.next(1, int(1e9)));\n        for (int i = 0; i < n; ++i)\n            a[i] = k;\n    } else if (type == \"small_numbers\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 10);\n    } else if (type == \"large_numbers\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(int(1e9) - int(1e5), int(1e9));\n    } else if (type == \"primes\") {\n        // Generate n distinct small primes\n        vector<int> primes;\n        int limit = 10000;\n        vector<bool> is_prime(limit + 1, true);\n        for (int i = 2; i <= limit && primes.size() < n; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                for (int j = i * 2; j <= limit; j += i)\n                    is_prime[j] = false;\n            }\n        }\n        if (n > primes.size()) {\n            printf(\"Not enough primes for n = %d\\n\", n);\n            return 1;\n        }\n        shuffle(primes.begin(), primes.end());\n        for (int i = 0; i < n; ++i)\n            a[i] = primes[i];\n    } else if (type == \"pairwise_coprime\") {\n        // Generate n distinct small primes\n        vector<int> primes;\n        int limit = 10000;\n        vector<bool> is_prime(limit + 1, true);\n        for (int i = 2; i <= limit && primes.size() < n; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                for (int j = i * 2; j <= limit; j += i)\n                    is_prime[j] = false;\n            }\n        }\n        if (n > primes.size()) {\n            printf(\"Not enough primes for n = %d\\n\", n);\n            return 1;\n        }\n        shuffle(primes.begin(), primes.end());\n        for (int i = 0; i < n; ++i)\n            a[i] = primes[i];\n    } else if (type == \"equal_pairs\") {\n        if (n % 2 != 0) {\n            printf(\"n must be even for equal_pairs type\\n\");\n            return 1;\n        }\n        for (int i = 0; i < n; i += 2) {\n            int val = rnd.next(1, int(1e9));\n            a[i] = a[i + 1] = val;\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"repeats\") {\n        int num_distinct = rnd.next(1, n);\n        vector<int> vals(num_distinct);\n        for (int i = 0; i < num_distinct; ++i)\n            vals[i] = rnd.next(1, int(1e9));\n        for (int i = 0; i < n; ++i)\n            a[i] = vals[rnd.next(0, num_distinct - 1)];\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, int(1e9));\n    } else {\n        printf(\"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Compute GCD table\n    vector<int> G_list;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j) {\n            int g = compute_gcd(a[i], a[j]);\n            G_list.push_back(g);\n        }\n\n    // Shuffle G_list\n    shuffle(G_list.begin(), G_list.end());\n\n    // Output n and G_list\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < G_list.size(); ++i) {\n        printf(\"%d\", G_list[i]);\n        if (i + 1 < G_list.size())\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_ones\n./gen -n 1 -type all_equal\n./gen -n 1 -type small_numbers\n./gen -n 1 -type large_numbers\n./gen -n 1 -type random\n./gen -n 1 -type repeats\n\n./gen -n 2 -type all_ones\n./gen -n 2 -type all_equal -k 42\n./gen -n 2 -type small_numbers\n./gen -n 2 -type large_numbers\n./gen -n 2 -type primes\n./gen -n 2 -type pairwise_coprime\n./gen -n 2 -type repeats\n\n./gen -n 3 -type all_ones\n./gen -n 3 -type random\n./gen -n 3 -type repeats\n\n./gen -n 4 -type repeats\n\n./gen -n 10 -type repeats\n\n./gen -n 100 -type all_ones\n./gen -n 100 -type all_equal -k 100\n./gen -n 100 -type small_numbers\n./gen -n 100 -type large_numbers\n./gen -n 100 -type primes\n./gen -n 100 -type pairwise_coprime\n./gen -n 100 -type repeats\n\n./gen -n 200 -type equal_pairs\n\n./gen -n 250 -type random\n./gen -n 250 -type repeats\n\n./gen -n 300 -type primes\n./gen -n 300 -type pairwise_coprime\n\n./gen -n 500 -type all_ones\n./gen -n 500 -type all_equal\n./gen -n 500 -type all_equal -k 999999937\n./gen -n 500 -type small_numbers\n./gen -n 500 -type large_numbers\n./gen -n 500 -type random\n./gen -n 500 -type repeats\n./gen -n 500 -type equal_pairs\n./gen -n 500 -type primes\n./gen -n 500 -type pairwise_coprime\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:12.198004",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "583/D",
      "title": "D. Once Again...",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers: n, T (1 ≤ n ≤ 100, 1 ≤ T ≤ 107). The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 300).",
      "output_spec": "OutputPrint a single number — the length of a sought sequence.",
      "sample_tests": "ExamplesInputCopy4 33 1 4 2OutputCopy5",
      "description": "D. Once Again...\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two space-separated integers: n, T (1 ≤ n ≤ 100, 1 ≤ T ≤ 107). The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 300).\n\nOutputPrint a single number — the length of a sought sequence.\n\nInputCopy4 33 1 4 2OutputCopy5\n\nInputCopy4 33 1 4 2\n\nOutputCopy5\n\nNoteThe array given in the sample looks like that: 3, 1, 4, 2, 3, 1, 4, 2, 3, 1, 4, 2. The elements in bold form the largest non-decreasing subsequence.",
      "solutions": [
        {
          "title": "Codeforces Round #323 - Codeforces",
          "content": "Greetings, Codeforces!My name is Danil Sagunov, and I used to be red... Anyway, I wish to congratulate you with the Second Revolution!I am glad to introduce that this Saturday, 3rd October at 19:30 MSK Codeforces Round #323 for both divisions will take place. Problemset has been prepared for you by me and Vitaly gridnevvvit Gridnev. This is not the first round we are authors of and I'm sure that it's not the last.Special thanks to our friends Maxim Neon Mescheryakov, Vladimir vovuh Petrov and Roman Roms Glazov for helping us preparing the round. I would like to thank Max Zlobober Akhmedov for his coordinator activity, Michael MikeMirzayanov Mirzayanov for creating and supporting Codeforces and Polygon systems, making this round possible, and Maria Delinur Belova for translating problem statements into English.Thanks to Vladislav winger Isenbaev and Alex AlexFetisov Fetisov for testing the round problemset!Both division participants will be given five problems and two hours to solve them. I hope that everyone will find the problems interesting and many of you will return your colors.UPD The round duration was written incorrectly in the e-mail announcement, the correct duration is 2 hours, not 2.5 hours.UPD2 Round have been successfully finished! Thank you all for participating.Congratulations to 1 division winners! ecnerwala ikatanic uwi PavelKunyavskiy sd0061 And the second division: wrong_order ahwhlzz kefaa My gratitude to fotiIe96, one to solve problem D!UPD3 Editorial can be found here",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/20657",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1514
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces",
          "content": "Adiv2To solve the problem one could just store two arrays hused[j] and vused[j] sized n and filled with false initially. Then process intersections one by one from 1 to n, and if for i-th intersections both hused[hi] and vused[vi] are false, add i to answer and set both hused[hi] and vused[vi] with true meaning that hi-th horizontal and vi-th vertical roads are now asphalted, and skip asphalting the intersection roads otherwise.Such solution has O(n2) complexity.Jury's solution: 13390628Bdiv2It is always optimal to pass all the computers in the row, starting from 1-st to n-th, then from n-th to first, then again from first to n-th, etc. and collecting the information parts as possible, while not all of them are collected. Such way gives robot maximal use of every direction change. O(n2) solution using this approach must have been passed system tests.Jury's solution: 13390612Adiv1Let the answer be a1 ≤ a2 ≤ ... ≤ an. We will use the fact that gcd(ai, aj) ≤ amin(i, j). It is true that gcd(an, an) = an ≥ ai ≥ gcd(ai, aj) for every 1 ≤ i, j ≤ n. That means that an is equal to maximum element in the table. Let set an to maximal element in the table and delete it from table elements set. We've deleted gcd(an, an), so the set now contains all gcd(ai, aj), for every 1 ≤ i, j ≤ n and 1 ≤ min(i, j) ≤ n - 1. By the last two inequalities gcd(ai, aj) ≤ amin(i, j) ≤ an - 1 = gcd(an - 1, an - 1). As soon as set contains gcd(an - 1, an - 1), the maximum element in current element set is equal to an - 1. As far as we already know an, let's delete the gcd(an - 1, an - 1), gcd(an - 1, an), gcd(an, an - 1) from the element set. Now set contains all the gcd(ai, aj), for every 1 ≤ i, j ≤ n and 1 ≤ min(i, j) ≤ n - 2.We're repeating that operation for every k from n - 2 to 1, setting ak to maximum element in the set and deleting the gcd(ak, ak), gcd(ai, ak), gcd(ak, ai) for every k < i ≤ n from the set.One could prove correctness of this algorithm by mathematical induction. For performing deleting and getting maximum element operations one could use multiset or map structure, so solution has complexity .Jury's solution: 13390679Bdiv1One could calculate matrix sized n × n mt[i][j] — the length of the longest non-decreasing subsequence in array a1, a2, ..., an, starting at element, greater-or-equal to ai and ending strictly in aj element with j-th index.One could prove that if we have two matrices sized n × n A[i][j] (the answer for a1, a2, ..., apn starting at element, greater-or-equal to ai and ending strictly in aj element with j-th index inside last block (a(p - 1)n + 1, ..., apn) and B[i][j] (the answer for a1, a2, ..., aqn ), then the multiplication of this matrices in a waywill give the same matrix but for length p + q. As soon as such multiplication is associative, next we will use fast matrix exponentiation algorithm to calculate M[i][j] (the answer for a1, a2, ..., anT) — matrix mt[i][j] raised in power T. The answer is the maximum in matrix M. Such solution has complexity .Jury's solution (with matrices): 13390660There's an alternative solution. As soon as a1, a2, ..., anT contains maximum n distinct elements, it's any non-decreasing subsequence has a maximum of n - 1 increasing consequtive element pairs. Using that fact, one could calculate standard longest non-decreasing subsequence dynamic programming on first n array blocks (a1, ..., an2) and longest non-decreasing subsequence DP on the last n array blocks (anT - n + 1, ..., anT). All other T - 2n blocks between them will make subsegment of consequtive equal elements in longest non-decreasing subsequence.So, for fixed ai, in which longest non-decreasing subsequence of length p on first n blocks array ends, and for fixed aj ≥ ai, in which longest non-decreasing subsequence of length s on last n blocks array starts, we must update the answer with p + (T - 2n)count(ai) + s, where count(x) is the number of occurences of x in a1, ..., an array. This gives us solution.Jury's solution (with suffix and prefix): 13390666Cdiv1Let's fix s for every (l, s) pair. One could easily prove, that if subarray contains ai element, than ai must be greater-or-equal than aj for every j such that . Let's use this idea and fix g = gcd(n, s) (it must be a divisor of n). To check if ai can be in subarray with such constraints, let's for every 0 ≤ r < g calculate .It's true that every good subarray must consist of and only of . For finding all such subarrays we will use two pointers approach and for every good ai, such that is not good we will find aj such that are good and is not good. Let has k elements . Any it's subarray is superior, so it gives us arrays of length 1, 2, ..., k with count k, k - 1, ..., 1. As soon as sum of all k is not greater than n, we could just increase counts straightforward. There's a case when all ai are good, in which we must do another increases. Next we must add to the answer only counts of length x, such that gcd(x, n) = g.Solution described above has complexity O(d(n)n), where d(n) is the number of divisors of n.Jury's solution: 13390645Ddiv1It is a common fact that for a prime p and integer n maximum α, such that pα|n! is calculated as , where pw ≤ n < pw + 1. As soon as , the maximum α for is calculated as .One could see, that if we consider numbers n, k and n - k in p-th based numeric system, rounded-down division by px means dropping last x digits of its p-th based representation. As soon as k + (n - k) = n, every i-th summand in α corresponds to carry in adding k to n - k in p-th numeric system from i - 1-th to i-th digit position and is to be 0 or 1.First, let convert A given in statement from 10 to p-th numeric system. In case, if α is greater than number of digits in A in p-th numeric system, the answer is 0. Next we will calculate dynamic programming on A p-th based representation.dp[i][x][e][r] — the answer for prefix of length i possible equal to prefix of A representation (indicator e), x-th power of p was already calculated, and there must be carry equal to r from current to previous position. One could calculate it by bruteforcing all of p2 variants of placing i-th digits in n and k according to r and e and i-th digit of A, and make a translation to next state. It can be avoided by noticing that the number of variants of placing digits is always a sum of arithmetic progression and can be calculated in O(1).It's highly recommended to examine jury's solution with complexity O(|A|2 + |A|min(|A|, α)).Jury's solution: 13390698Ediv1One could prove that the number of binary functions on 4 variables is equal to 224, and can be coded by storing a 24-bit binary mask, in which every bit is storing function value for corresponding variable set. It is true, that if maskf and maskg are correspond to functions f(A, B, C, D) and g(A, B, C, D), then function (f&g)(A, B, C, D) corresponds to maskf&maskg bitmask.Now, we could parse expression given input into binary tree. I should notice that the number of non-list nodes of such tree is about . Now, let's calculate dynamic programming on every vertex v — dp[v][mask] is the number of ways to place symbols in expression in the way that subtree of vertex v will correspond to function representing by mask. For list nodes such dynamic is calculated pretty straightforward by considering all possible mask values and matching it with the variable. One could easily recalculate it for one node using calculated answers for left and right subtree in 416 operations: dp[v][lmask|rmask] +  = dp[l][lmask] * dp[r][rmask].But all the task is how to make it faster. One could calculate s[mask], where s[mask] is equal to sum of all its submasks (the masks containing 1-bits only in positions where mask contains 1-bits) in 24·224 operations using following code: for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n for (int mask = 0; mask < (1 << 16); ++mask)\n if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];Let's calculate sl[mask] and sr[mask] for dp[l][mask] and dp[r][mask] respectively. If we will find s[mask] = sl[mask] * sr[mask], s[mask] will contain multiplications of values of pairs of masks from left and right dp's, which are submasks of mask. As soon as we need pairs, which in bitwise OR will give us exactly mask, we should exclude pairs, which in bitwise OR gives a submask of mask, not equal to mask. This gives us exclusion-inclusion principle idea. The formula of this will be, where p is the parity of number of bits in mask^submask.Such sum could be calculated with approach above, but subtracting instead of adding for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n for (int mask = 0; mask < (1 << 16); ++mask)\n if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];In such way we will recalculate dynamic for one vertex in about 3·24·216 operations.Jury's solution: 13390713",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/20692",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 8922
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #323 - Codeforces - Code 1",
          "code": "gcd(A, A) = A",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 2",
          "code": "gcd(A, B) <= min(A, B)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 3",
          "code": "gcd(A, B) <= B",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 4",
          "code": "gcd(B, B) = B",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 5",
          "code": "int fun(multiset st) {  multiset :: iterator it = st.end();  it--;  return it; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 6",
          "code": "int fun(multiset &st) {  multiset :: iterator it = st.end();  it--;  return it; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 7",
          "code": "multiset<...>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 8",
          "code": "vertical = vector<bool> (n, false);\n horizontal = vector<bool> (n, false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 - Codeforces - Code 9",
          "code": "vertical = vector<bool> (n, false);\n horizontal = vector<bool> (n, false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20657",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 1",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 2",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = dp[x][mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] += s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 3",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 4",
          "code": "for (int mask = 0; mask < (1 << 16); ++mask) s[mask] = sl[mask] * sr[mask];\nfor (int i = 0; i < 16; ++i)\n    for (int mask = 0; mask < (1 << 16); ++mask)\n        if (!(mask & (1 << i))) s[mask ^ (1 << i)] -= s[mask];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 5",
          "code": "(x[0], x[1], ..., x[7]) @ (y[0], y[1], ..., y[7]) = (z[0], z[1], ..., z[7])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 6",
          "code": "(x[0]+x[4], x[1]+x[5], x[2]+x[6], x[3]+x[7]) @ (y[0]+y[4], y[1]+y[5], y[2]+y[6], y[3]+y[7]) = (a, b, c, d)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 7",
          "code": "(x[0], x[1], x[2], x[3]) @ (y[0], y[1], y[2], y[3]) = (e, f, g, h)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 8",
          "code": "z[4] = a - e",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 9",
          "code": "z[5] = b - f",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 10",
          "code": "z[6] = c - g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 11",
          "code": "z[7] = d - h",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 12",
          "code": "ans.pb(a[i]);\n    cnt++;\n    if(cnt==n) break;\n    for(int l=0;l<ans.size();l++)\n    {\n        //if(a[i]==274199512) cout<<__gcd(a[i],ans[l])<<\" \"<<i<<\" \"<<l<<\"\\n\";\n        gcds.push(__gcd(a[i],ans[l]))\n        gcds.push(__gcd(a[i],ans[l]));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 13",
          "code": "ans.pb(a[i]);\n    cnt++;\n    if(cnt==n) break;\n    for(int l=0;l<ans.size();l++)\n    {\n        //if(a[i]==274199512) cout<<__gcd(a[i],ans[l])<<\" \"<<i<<\" \"<<l<<\"\\n\";\n        gcds.push(__gcd(a[i],ans[l]))\n        gcds.push(__gcd(a[i],ans[l]));\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 14",
          "code": "5        \n    12 1 1 2 1\n     1 7 1 1 1\n     1 1 5 1 1\n     2 1 1 2 1\n     1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #323 Editorial - Codeforces - Code 15",
          "code": "5        \n    12 1 1 2 1\n     1 7 1 1 1\n     1 1 5 1 1\n     2 1 1 2 1\n     1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20692",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int T = inf.readInt(1, 10000000, \"T\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 300, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int T = inf.readInt(1, 10000000, \"T\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 300, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int T = inf.readInt(1, 10000000, \"T\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 300, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int T = opt<int>(\"T\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 300);\n        }\n    } else if (type == \"increasing\") {\n        int value = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n            if (value < 300) ++value;\n        }\n    } else if (type == \"decreasing\") {\n        int value = 300;\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n            if (value > 1) --value;\n        }\n    } else if (type == \"constant\") {\n        int value = rnd.next(1, 300);\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (type == \"wave\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 1 : 300;\n        }\n    } else if (type == \"staggered\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = rnd.next(1, 150);\n            else\n                a[i] = rnd.next(151, 300);\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 300);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, T);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int T = opt<int>(\"T\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 300);\n        }\n    } else if (type == \"increasing\") {\n        int value = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n            if (value < 300) ++value;\n        }\n    } else if (type == \"decreasing\") {\n        int value = 300;\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n            if (value > 1) --value;\n        }\n    } else if (type == \"constant\") {\n        int value = rnd.next(1, 300);\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n        }\n    } else if (type == \"wave\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 1 : 300;\n        }\n    } else if (type == \"staggered\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = rnd.next(1, 150);\n            else\n                a[i] = rnd.next(151, 300);\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 300);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, T);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -T 1 -type random\n./gen -n 1 -T 10000000 -type random\n\n./gen -n 100 -T 1 -type random\n./gen -n 100 -T 10000000 -type random\n\n./gen -n 1 -T 1 -type increasing\n./gen -n 1 -T 10000000 -type increasing\n\n./gen -n 100 -T 1 -type increasing\n./gen -n 100 -T 10000000 -type increasing\n\n./gen -n 1 -T 1 -type decreasing\n./gen -n 1 -T 10000000 -type decreasing\n\n./gen -n 100 -T 1 -type decreasing\n./gen -n 100 -T 10000000 -type decreasing\n\n./gen -n 50 -T 10000000 -type constant\n\n./gen -n 50 -T 10000000 -type wave\n\n./gen -n 100 -T 10000000 -type staggered\n\n./gen -n 100 -T 100 -type random\n./gen -n 100 -T 1000 -type random\n./gen -n 100 -T 100000 -type random\n./gen -n 100 -T 1000000 -type random\n\n./gen -n 1 -T 50 -type random\n./gen -n 2 -T 9999999 -type wave\n./gen -n 3 -T 9999999 -type staggered\n\n./gen -n 1 -T 5000000 -type constant\n./gen -n 100 -T 5000000 -type constant\n\n./gen -n 100 -T 10000000 -type wave\n./gen -n 100 -T 10000000 -type staggered\n\n# Edge cases\n./gen -n 1 -T 1 -type constant\n./gen -n 1 -T 10000000 -type constant\n./gen -n 100 -T 1 -type constant\n\n# Maximum values\n./gen -n 100 -T 10000000 -type increasing\n./gen -n 100 -T 10000000 -type decreasing\n\n# Additional random cases\n./gen -n 100 -T 9999999 -type random\n./gen -n 100 -T 9999999 -type constant\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:14.140981",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "583/E",
      "title": "Problem 583/E",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_same\") {\n        int val = rnd.next(1, 1000000);\n        fill(a.begin(), a.end(), val);\n    } else if (type == \"increasing\") {\n        int val = rnd.next(1, max(1, 1000000 - n));\n        for (int i = 0; i < n; ++i) {\n            a[i] = val + i;\n        }\n    } else if (type == \"decreasing\") {\n        int val = rnd.next(n, 1000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val - i;\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"small_values\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"large_values\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(999990, 1000000);\n        }\n    } else if (type == \"alternating\") {\n        int val1 = rnd.next(1, 10);\n        int val2 = rnd.next(999990, 1000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else if (type == \"periodic\") {\n        int s = opt<int>(\"s\", 1);\n        s = min(max(s, 1), n);\n        vector<int> period(s);\n        for (int i = 0; i < s; ++i) {\n            period[i] = rnd.next(1, 1000000);\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = period[i % s];\n        }\n    } else if (type == \"half_half\") {\n        int val1 = rnd.next(1, 500000);\n        int val2 = rnd.next(500001, 1000000);\n        for (int i = 0; i < n; ++i) {\n            if (i < n / 2) {\n                a[i] = val1;\n            } else {\n                a[i] = val2;\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_same\") {\n        int val = rnd.next(1, 1000000);\n        fill(a.begin(), a.end(), val);\n    } else if (type == \"increasing\") {\n        int val = rnd.next(1, max(1, 1000000 - n));\n        for (int i = 0; i < n; ++i) {\n            a[i] = val + i;\n        }\n    } else if (type == \"decreasing\") {\n        int val = rnd.next(n, 1000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val - i;\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    } else if (type == \"small_values\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"large_values\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(999990, 1000000);\n        }\n    } else if (type == \"alternating\") {\n        int val1 = rnd.next(1, 10);\n        int val2 = rnd.next(999990, 1000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else if (type == \"periodic\") {\n        int s = opt<int>(\"s\", 1);\n        s = min(max(s, 1), n);\n        vector<int> period(s);\n        for (int i = 0; i < s; ++i) {\n            period[i] = rnd.next(1, 1000000);\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = period[i % s];\n        }\n    } else if (type == \"half_half\") {\n        int val1 = rnd.next(1, 500000);\n        int val2 = rnd.next(500001, 1000000);\n        for (int i = 0; i < n; ++i) {\n            if (i < n / 2) {\n                a[i] = val1;\n            } else {\n                a[i] = val2;\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_same\n./gen -n 1 -type increasing\n./gen -n 1 -type decreasing\n./gen -n 1 -type random\n\n./gen -n 2 -type all_same\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type random\n\n./gen -n 10 -type small_values\n./gen -n 10 -type large_values\n./gen -n 10 -type alternating\n./gen -n 10 -type random\n\n./gen -n 10 -type periodic -s 1\n./gen -n 10 -type periodic -s 2\n./gen -n 10 -type periodic -s 5\n./gen -n 10 -type periodic -s 10\n\n./gen -n 100 -type all_same\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type random\n./gen -n 100 -type half_half\n\n./gen -n 1000 -type small_values\n./gen -n 1000 -type large_values\n./gen -n 1000 -type alternating\n./gen -n 1000 -type random\n./gen -n 1000 -type periodic -s 7\n./gen -n 1000 -type periodic -s 1000\n\n./gen -n 10000 -type increasing\n./gen -n 10000 -type decreasing\n./gen -n 10000 -type random\n./gen -n 10000 -type half_half\n\n./gen -n 100000 -type all_same\n./gen -n 100000 -type small_values\n./gen -n 100000 -type random\n./gen -n 100000 -type periodic -s 100\n\n./gen -n 200000 -type random\n./gen -n 200000 -type large_values\n./gen -n 200000 -type alternating\n./gen -n 200000 -type half_half\n./gen -n 200000 -type periodic -s 200000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:16.103571",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "584/A",
      "title": "A. Олеся и Родион",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записаны два числа n и t (1 ≤ n ≤ 100, 2 ≤ t ≤ 10) — длина числа и на что оно должно делиться.",
      "output_spec": "Выходные данныеВыведите одно целое положительное число без ведущих нулей, являющееся ответом на задачу, или  - 1, если такого числа не существует. Если возможных ответов несколько, разрешается вывести любой.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 2Выходные данныеСкопировать712",
      "description": "A. Олеся и Родион\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ единственной строке записаны два числа n и t (1 ≤ n ≤ 100, 2 ≤ t ≤ 10) — длина числа и на что оно должно делиться.\n\nВходные данные\n\nВыходные данныеВыведите одно целое положительное число без ведущих нулей, являющееся ответом на задачу, или  - 1, если такого числа не существует. Если возможных ответов несколько, разрешается вывести любой.\n\nВыходные данные\n\nВходные данныеСкопировать3 2Выходные данныеСкопировать712\n\nВходные данныеСкопировать3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать712\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces",
          "content": "Задача АРазберем два случая t = 10 и t ≠ 10.Если t = 10, то либо n = 1, и тогда ответ  - 1 (очевидно, что среди чисел от 1 до 9 нет делящихся на 10), либо n > 1, и тогда первые n - 1 цифр можно заполнить как угодно, а в конце дописать 0.Если t < 10, то просто заполним все число цифрами t и оно, очевидно, будет делиться на t.Задача B Количество способов рассадить всех гномов — 33n. Посчитаем количество способов рассадить гномов так, чтобы в любом треугольнике гномы получили 6 монет, а потом вычтем это число из всех способов. Заметим, что все гномы однозначно разбиваются на треугольники вида i — (i + n) — (i + 2n),  i < n. Поэтому можно посчитать количество способов независимо по каждому треугольнику, а потом перемножить результаты. Чтобы получить ответ для треугольника, осталось заметить, что существует ровно 7 способов взять гномов с 6 монетами (это все перестановки 1, 2, 3 и 2, 2, 2)Итого ответ — 33n - 7n. Посчитать степени можно за O(n).Задача СПостроим строку, которая не отличается на t, а совпадает в k = n - t символах. Пусть строки s1 и s2 совпадают в q символах. Тогда если k ≤ q, то возьмем любые k позиций, в которых s1 и s2 совпадают, и поставим в ответ такие же символы. Во все остальные n - k позиций поставим символы, отличающиеся от соответствующих в s1 и s2 (мы всегда можем так сделать, так у нас 26 букв).Теперь k > q. Тогда, если есть ответ, в котором в какой-то из этих q позиций в ответе стоит не такой же символ, как в s1 и s2, то сделаем его равным им, а в каких-нибудь позициях, где s1i ≠ s2i, s1i = ansi (и наоборот) поставим в ansi символ, отличный от s1i и s2i(это можно сделать, так как k > q). Тогда можно сразу в эти q позиций поставить символы, равный соответствующим в s1 и s2. Теперь у нас есть строки s1 и s2 длины n - q, отличные в каждой позиции, и надо предъявить строку ans такую, что f(ans, s1) = f(ans, s2) = k - q. Так как строки s1 и s2 отличаются во всех позициях, то любой символ из ans равен либо соответствующему в s1, либо соответствующему в s2, либо ни одному из них. Поэтому, нам надо хотя бы 2(k - q) символов в ответе, чтобы сделать f(s1, ans) = k - q и f(s2, ans) = k - q. Следовательно, если n - q < 2(k - q), то решения не существует. Иначе просто жадно в первые k - q символов ответа поставим символы из s1, в следующие k - q символы из s2, а остальные заполним символами не из s1 и не из s2. Асимптотика — O(n).Задача DОбщеизвестно, что между двумя соседними простыми числами, которые меньше 109, расстояние не очень большое. На самом деле для n = 109 максимальное из этих расстояний равно 282. Поэтому будем делать так: найдем наибольшее число p, такое что p < n - 1 и p — простое. По нашему утверждению n - p < 300. Скажем, что p входит в разложение n и теперь надо разложить четное(так n — нечетное и p — нечетное(если не 2)) n - p на сумму двух простых. Так как n - p маленькое, то сделаем это, просто перебрав два простых. То, что для всех четных, меньших 300, существует разложение на не более чем два простых, можно было проверить просто написав перебор.Задача EБудем считать, что все мы платим за обмен не |i - j|, а 2|i - j|. Тогда можно считать, что мы платим |i - j| за перемещение pi и |i - j| за перемещение pj. Тогда, если x изначально был на позиции i, а потом пришел на позицию j, то мы заплатим за него хотя бы |i - j|. Поэтому ответ это хотя бы (pp — позиция k в перестановке p, а ps — позиция k в перестановке s). Докажем, что это и есть ответ конструктивно, предъявив алгоритм.Будем считать, что перестановка s отсортирована (нашу задачу легко свести к этой). Тогда будем последовательно(сначала n, потом n - 1 и так далее) переставлять числа на свои позиции. Как поставить n на свою позицию? Пусть оно стоит на позиции pos. Докажем, что среди чисел, стоящих справа от n, есть число, меньшее или равное pos(дальше поменяем его местами с n — от этого оба числа сдвинутся к своим итоговым позициям, и при этом n сдвинется хотя бы на 1 вправо, поэтому можно дальше делать так же). Заметим, что всего справа от n ровно n - pos чисел. При этом сколько из них могут быть больше pos. Казалось бы, тоже n - pos, но это не так, так как число n, большее pos, стоит не правее, чем n :). Поэтому, по принципу Дирихле, найдется число, которое меньше или равно pos, и стоит справа от n.Как теперь реализовать этот алгоритм за O(n2), а не за куб? Вот мы хотим поставить n на свое место. Идем направо указателем, пока не встретим число, меньшее или равное pos, а потом поменяем n с этим числом. Дальше указатель надо пускать уже от новой позиции n, поэтому указатель всегда двигается только вправо, и суммарно пройдет не больше n. Итак, каждое из n чисел мы ставим на свою позицию за O(n), поэтому получаем O(n2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20766",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4687
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 1",
          "code": "if is_prime(n) or is_prime(n - 2)\n  answer 1: n or answer 2: 2, n - 2\nelse\n  for prime in primes(до 10^6)\n    if (n - prime) % 2 == 0 and is_prime((n - prime) / 2) // Причем такой prime встречается рано\n      answer 3: prime, (n - prime)/2, (n - prime) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 2",
          "code": "if is_prime(n) or is_prime(n - 2)\n  answer 1: n or answer 2: 2, n - 2\nelse\n  for prime in primes(до 10^6)\n    if (n - prime) % 2 == 0 and is_prime((n - prime) / 2) // Причем такой prime встречается рано\n      answer 3: prime, (n - prime)/2, (n - prime) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 3",
          "code": "\"a third string, different from them in exactly t **characters**\" whatever the positions(see example)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 4",
          "code": "\"a third string, different from them in exactly t **characters**\" whatever the positions(see example)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 5",
          "code": "\"a third string, different from them in exactly t **positions**\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 6",
          "code": "\"a third string, different from them in exactly t **positions**\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 7",
          "code": "sum_c(abs(cnt1[c] - cnt2[c]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 8",
          "code": "sum_c(abs(cnt1[c] - cnt2[c]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 9",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 10",
          "code": "cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 11",
          "code": "One record from this search is that 3325581707333960528 is the smallest number that has no Goldbach partition with a prime below 9781.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(2, 10, \"t\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(2, 10, \"t\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(2, 10, \"t\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <string>\n\nusing namespace std;\n\nbool isPossible(int n, int t) {\n    if (t == 10) {\n        return n >= 2;\n    } else {\n        return true;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt(1, 100);\n    int t = inf.readInt(2, 10);\n\n    string participant_output = ouf.readToken();\n\n    if (participant_output == \"-1\") {\n        if (isPossible(n, t))\n            quitf(_wa, \"Participant output -1, but a valid number exists for n = %d and t = %d\", n, t);\n        else\n            quitf(_ok, \"-1, correct, no valid number exists for n = %d and t = %d\", n, t);\n    } else {\n        if ((int)participant_output.size() != n)\n            quitf(_wa, \"Output number does not have n digits (expected %d digits, found %d digits)\", n, participant_output.size());\n        if (participant_output[0] == '0')\n            quitf(_wa, \"Output number has leading zero\");\n\n        for (size_t i = 0; i < participant_output.size(); ++i) {\n            if (!isdigit(participant_output[i]))\n                quitf(_wa, \"Output contains non-digit character '%c' at position %d\", participant_output[i], i + 1);\n        }\n\n        int mod = 0;\n        for (char c : participant_output) {\n            mod = (mod * 10 + (c - '0')) % t;\n        }\n\n        if (mod != 0)\n            quitf(_wa, \"Output number is not divisible by t (remainder is %d)\", mod);\n\n        quitf(_ok, \"Output is correct\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n_min = opt<int>(\"nmin\", 1);\n    int n_max = opt<int>(\"nmax\", 100);\n    int t_min = opt<int>(\"tmin\", 2);\n    int t_max = opt<int>(\"tmax\", 10);\n\n    string type = opt<string>(\"type\", \"random\"); // Default type is \"random\"\n\n    int n, t;\n\n    if (type == \"min_n\") {\n        // Minimal n (n = n_min)\n        n = n_min;\n        t = rnd.next(t_min, t_max);\n    } else if (type == \"max_n\") {\n        // Maximal n (n = n_max)\n        n = n_max;\n        t = rnd.next(t_min, t_max);\n    } else if (type == \"t10_n1\") {\n        // n = 1, t = 10 (no solution case)\n        n = 1;\n        t = 10;\n    } else if (type == \"n_t_equal\") {\n        // n and t are equal\n        n = rnd.next(n_min, n_max);\n        t = n;\n        if (t < t_min) t = t_min;\n        if (t > t_max) t = t_max;\n    } else if (type == \"t_is_10\") {\n        // t = 10, n is random\n        n = rnd.next(n_min, n_max);\n        t = 10;\n    } else if (type == \"max_n_t10\") {\n        // Maximal n, t = 10\n        n = n_max;\n        t = 10;\n    } else if (type == \"n1_t_odd\") {\n        // n = 1, t is an odd number between 3 and 9\n        n = 1;\n        t = rnd.next(3, 9) | 1; // Ensure t is odd\n    } else if (type == \"no_solution\") {\n        // Designed to produce no solution\n        n = 1;\n        t = 10; // Since no 1-digit number is divisible by 10\n    } else {\n        // Random test case\n        n = rnd.next(n_min, n_max);\n        t = rnd.next(t_min, t_max);\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, t);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n_min = opt<int>(\"nmin\", 1);\n    int n_max = opt<int>(\"nmax\", 100);\n    int t_min = opt<int>(\"tmin\", 2);\n    int t_max = opt<int>(\"tmax\", 10);\n\n    string type = opt<string>(\"type\", \"random\"); // Default type is \"random\"\n\n    int n, t;\n\n    if (type == \"min_n\") {\n        // Minimal n (n = n_min)\n        n = n_min;\n        t = rnd.next(t_min, t_max);\n    } else if (type == \"max_n\") {\n        // Maximal n (n = n_max)\n        n = n_max;\n        t = rnd.next(t_min, t_max);\n    } else if (type == \"t10_n1\") {\n        // n = 1, t = 10 (no solution case)\n        n = 1;\n        t = 10;\n    } else if (type == \"n_t_equal\") {\n        // n and t are equal\n        n = rnd.next(n_min, n_max);\n        t = n;\n        if (t < t_min) t = t_min;\n        if (t > t_max) t = t_max;\n    } else if (type == \"t_is_10\") {\n        // t = 10, n is random\n        n = rnd.next(n_min, n_max);\n        t = 10;\n    } else if (type == \"max_n_t10\") {\n        // Maximal n, t = 10\n        n = n_max;\n        t = 10;\n    } else if (type == \"n1_t_odd\") {\n        // n = 1, t is an odd number between 3 and 9\n        n = 1;\n        t = rnd.next(3, 9) | 1; // Ensure t is odd\n    } else if (type == \"no_solution\") {\n        // Designed to produce no solution\n        n = 1;\n        t = 10; // Since no 1-digit number is divisible by 10\n    } else {\n        // Random test case\n        n = rnd.next(n_min, n_max);\n        t = rnd.next(t_min, t_max);\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, t);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_n -nmin 1 -nmax 1 -tmin 2 -tmax 10\n./gen -type min_n -nmin 1 -nmax 1 -tmin 3 -tmax 10\n./gen -type max_n -nmin 100 -nmax 100 -tmin 2 -tmax 10\n./gen -type max_n -nmin 100 -nmax 100 -tmin 5 -tmax 10\n./gen -type t10_n1\n./gen -type n_t_equal -nmin 2 -nmax 10\n./gen -type t_is_10 -nmin 2 -nmax 100\n./gen -type max_n_t10 -nmin 100 -nmax 100\n./gen -type n1_t_odd\n./gen -type no_solution\n./gen -type random -nmin 1 -nmax 5 -tmin 2 -tmax 10\n./gen -type random -nmin 6 -nmax 20 -tmin 2 -tmax 10\n./gen -type random -nmin 21 -nmax 50 -tmin 2 -tmax 10\n./gen -type random -nmin 51 -nmax 100 -tmin 2 -tmax 10\n./gen -type random -nmin 1 -nmax 100 -tmin 2 -tmax 10\n./gen -type random -nmin 1 -nmax 50 -tmin 2 -tmax 5\n./gen -type random -nmin 1 -nmax 100 -tmin 6 -tmax 10\n./gen -type random -nmin 1 -nmax 1 -tmin 10 -tmax 10\n./gen -type random -nmin 100 -nmax 100 -tmin 2 -tmax 2\n./gen -type random -nmin 100 -nmax 100 -tmin 3 -tmax 3\n./gen -type random -nmin 50 -nmax 50 -tmin 7 -tmax 7\n./gen -type random -nmin 1 -nmax 100 -tmin 2 -tmax 10\n./gen -type random -nmin 1 -nmax 1 -tmin 2 -tmax 2\n./gen -type random -nmin 1 -nmax 1 -tmin 3 -tmax 3\n./gen -type random -nmin 1 -nmax 1 -tmin 5 -tmax 5\n./gen -type random -nmin 5 -nmax 5 -tmin 10 -tmax 10\n./gen -type random -nmin 99 -nmax 99 -tmin 9 -tmax 9\n./gen -type random -nmin 98 -nmax 98 -tmin 8 -tmax 8\n./gen -type random -nmin 10 -nmax 10 -tmin 2 -tmax 2\n./gen -type random -nmin 10 -nmax 10 -tmin 5 -tmax 5\n./gen -type random -nmin 15 -nmax 15 -tmin 7 -tmax 7\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:17.765478",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "584/B",
      "title": "B. Kolya and Tanya",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains number n (1 ≤ n ≤ 105) — the number of the gnomes divided by three.",
      "output_spec": "OutputPrint a single number — the remainder of the number of variants of distributing coins that satisfy Tanya modulo 109 + 7.",
      "sample_tests": "ExamplesInputCopy1OutputCopy20InputCopy2OutputCopy680",
      "description": "B. Kolya and Tanya\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputA single line contains number n (1 ≤ n ≤ 105) — the number of the gnomes divided by three.\n\nOutputPrint a single number — the remainder of the number of variants of distributing coins that satisfy Tanya modulo 109 + 7.\n\nInputCopy1OutputCopy20InputCopy2OutputCopy680\n\nOutputCopy20\n\nOutputCopy680\n\nNote20 ways for n = 1 (gnome with index 0 sits on the top of the triangle, gnome 1 on the right vertex, gnome 2 on the left vertex):",
      "solutions": [
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces",
          "content": "584A - Olesya and RodionTwo cases: t = 10 and t ≠ 10.If t = 10 then there are two cases again :). If n = 1 then answer is  - 1 (because there is not any digit divisible by t). If n > 1, then answer, for example, is '1111...110' (contains n - 1 ones).If t < 10 then answer, for example, is 'tttttttt' (it, obviously, divisible by t).584B - Kolya and Tanya The number of ways to choose ai (without any conditions) — 33n. Let A be the number of ways to choose ai with condition that in every triangle gnomes have 6 coins. Then answer is 33n - A.Note that we can separate all gnomes on n independent triangles (i-th triangle contains of ai, ai + n, ai + 2n, i < n). So we can count answer for one triangle and then multiply the results. To count answer for one triangle, we can note that there are 7 ways to choose gnomes with 6 coins (all permutations 1, 2, 3 and 2, 2, 2).So answer is — 33n - 7n. We count it in O(n).584C - Marina and VasyaLet's find a string that will be equal to s1 in k = n - t positions and equal to s2 in k = n - t positions. Let's denote q = quantity of i that s1i = s2i. If k ≤ q, then let's take k positions such that s1pos = s2pos and put in answer the same symbols. Then put in other n - k positions symbols, which are not equal to corresponding in s1 and s2 (we can do it, because we have 26 letters).Now k > q. So, if there is an answer, where exists pos such that s1pos = s2pos, s1pos ≠ anspos, let's denote ansi = s1i, and then in any position such that s1i ≠ s2i = ansi and s1i = ansi (and in the same position in s2) we will choose ai, such that ai ≠ s1i and ai ≠ s2i (we can do it because k > q). So, for every position from q we can put symbols, equal to corresponding symbols in s1 and s2. Now we have strings s1, s2 of length n - q (such that s1i ≠ s2i for every i) and we should find string ans such that f(ans, s1) = f(ans, s2). We know that s1i ≠ s2i, so ansi may be equal to corresponding in s1 or to corresponding in s2 or not equal to s1i and to s2i. So, we need, at least, 2(k - q) symbols in answer to make f(s1, ans) = k - q and f(s2, ans) = k - q. Consequently, if n - q < 2(k - q), the answer is  - 1, and else just put first k - q symbols in answer from s1, next k - q symbols from s2, and others won't be equal to corresponding in s1 and s2.Solution works in O(n).584D - Dima and LisaThere is a fact that the distance between adjacent prime numbers isn't big. For n = 109 maximal distanse is 282. So let's find maximal prime p, such that p < n - 1 (we can just decrease n while it's not prime(we can check it in )). We know that n - p < 300. Now we have even (because n and p are odd) number n - p and we should divide it into a sum of two primes. As n - p < 300, we can just iterate over small primes P and check if P is prime and n - p - P is prime. You can check that there is a solution for all even numbers less than 300 by bruteforce.584E - Anton and IraWe can consider that we pay 2|i - j| coins for swap (we can divide answer in the end). Then we can consider that we pay |i - j| coins for moving pi and |i - j| for moving pj. So, if x was on position i and then came to position j, then we will pay at least |i - j| coins. Then the answer is at least (pp — position k in permutation p, and ps — position k in permutation s). Let's prove that this is the answer by showing the algorithm of making swaps.Let's consider that permutation s is sorted (our task is equal to it). Then we will put numbers from n to 1 on their positions.How we can put n on its position? Denote ppos = n. Let's prove that there exists a position pos2 such that pos < pos2 and ppos2 ≤ pos(then we will swap ppos2 with n (and both numbers will move to their final positions and n will move to the right, so we can repeat this process until n returns to its position)). We can note that there are only n - pos positions that are bigger than pos. And how many numbers on these positions can be bigger than pos? We can say that answer is n - pos, but it's incorrect, because n is bigger than pos, but posn ≤ pos. Now we can use Pigeonhole principle and say that position x, such that x > pos and px ≤ pos exists.But now our algorithm is O(n3). How we can put n in its position in O(n) operations? Let's move the pointer to the right while number is bigger than pos. Then swap n with found number. After we can move pointer from new n's position, so pointer always moves to the right and will not do more then n steps.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20766",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 584\\s*B"
          },
          "content_length": 4444
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 1",
          "code": "\"a third string, different from them in exactly t **characters**\" whatever the positions(see example)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 2",
          "code": "\"a third string, different from them in exactly t **characters**\" whatever the positions(see example)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 3",
          "code": "\"a third string, different from them in exactly t **positions**\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 4",
          "code": "\"a third string, different from them in exactly t **positions**\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 5",
          "code": "sum_c(abs(cnt1[c] - cnt2[c]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 6",
          "code": "sum_c(abs(cnt1[c] - cnt2[c]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 8",
          "code": "cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 9",
          "code": "One record from this search is that 3325581707333960528 is the smallest number that has no Goldbach partition with a prime below 9781.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n;\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"small\") {\n        n = rnd.next(1, 10);\n    } else if (type == \"mid\") {\n        n = rnd.next(10000, 100000);\n    } else if (type == \"max\") {\n        n = 100000;\n    } else if (type == \"random\") {\n        n = rnd.next(1, 100000);\n    } else if (type == \"specific\") {\n        n = opt<int>(\"n\");\n    } else {\n        // default to random\n        n = rnd.next(1, 100000);\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n;\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"small\") {\n        n = rnd.next(1, 10);\n    } else if (type == \"mid\") {\n        n = rnd.next(10000, 100000);\n    } else if (type == \"max\") {\n        n = 100000;\n    } else if (type == \"random\") {\n        n = rnd.next(1, 100000);\n    } else if (type == \"specific\") {\n        n = opt<int>(\"n\");\n    } else {\n        // default to random\n        n = rnd.next(1, 100000);\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min                                  # n = 1\n\n./gen -type specific -n 2\n./gen -type specific -n 3\n./gen -type specific -n 4\n./gen -type specific -n 5\n./gen -type specific -n 6\n\n./gen -type small                                # Random n between 1 and 10\n./gen -type small\n./gen -type small\n./gen -type small\n./gen -type small\n\n./gen -type mid                                  # Random n between 10000 and 100000\n./gen -type mid\n./gen -type mid\n./gen -type mid\n./gen -type mid\n\n./gen -type max                                  # n = 100000\n./gen -type max\n\n./gen -type random                               # Random n between 1 and 100000\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type specific -n 99999\n./gen -type specific -n 100000\n./gen -type specific -n 50000\n./gen -type specific -n 75000\n./gen -type specific -n 25000\n\n./gen -type specific -n 12345\n./gen -type specific -n 54321\n./gen -type specific -n 100\n./gen -type specific -n 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:19.841407",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "584/C",
      "title": "C. Marina and Vasya",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and t (1 ≤ n ≤ 105, 0 ≤ t ≤ n).The second line contains string s1 of length n, consisting of lowercase English letters.The third line contain string s2 of length n, consisting of lowercase English letters.",
      "output_spec": "OutputPrint a string of length n, differing from string s1 and from s2 in exactly t characters. Your string should consist only from lowercase English letters. If such string doesn't exist, print -1.",
      "sample_tests": "ExamplesInputCopy3 2abcxycOutputCopyaydInputCopy1 0cbOutputCopy-1",
      "description": "C. Marina and Vasya\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n and t (1 ≤ n ≤ 105, 0 ≤ t ≤ n).The second line contains string s1 of length n, consisting of lowercase English letters.The third line contain string s2 of length n, consisting of lowercase English letters.\n\nOutputPrint a string of length n, differing from string s1 and from s2 in exactly t characters. Your string should consist only from lowercase English letters. If such string doesn't exist, print -1.\n\nInputCopy3 2abcxycOutputCopyaydInputCopy1 0cbOutputCopy-1\n\nInputCopy3 2abcxyc\n\nOutputCopyayd\n\nInputCopy1 0cb\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces",
          "content": "584A - Olesya and RodionTwo cases: t = 10 and t ≠ 10.If t = 10 then there are two cases again :). If n = 1 then answer is  - 1 (because there is not any digit divisible by t). If n > 1, then answer, for example, is '1111...110' (contains n - 1 ones).If t < 10 then answer, for example, is 'tttttttt' (it, obviously, divisible by t).584B - Kolya and Tanya The number of ways to choose ai (without any conditions) — 33n. Let A be the number of ways to choose ai with condition that in every triangle gnomes have 6 coins. Then answer is 33n - A.Note that we can separate all gnomes on n independent triangles (i-th triangle contains of ai, ai + n, ai + 2n, i < n). So we can count answer for one triangle and then multiply the results. To count answer for one triangle, we can note that there are 7 ways to choose gnomes with 6 coins (all permutations 1, 2, 3 and 2, 2, 2).So answer is — 33n - 7n. We count it in O(n).584C - Marina and VasyaLet's find a string that will be equal to s1 in k = n - t positions and equal to s2 in k = n - t positions. Let's denote q = quantity of i that s1i = s2i. If k ≤ q, then let's take k positions such that s1pos = s2pos and put in answer the same symbols. Then put in other n - k positions symbols, which are not equal to corresponding in s1 and s2 (we can do it, because we have 26 letters).Now k > q. So, if there is an answer, where exists pos such that s1pos = s2pos, s1pos ≠ anspos, let's denote ansi = s1i, and then in any position such that s1i ≠ s2i = ansi and s1i = ansi (and in the same position in s2) we will choose ai, such that ai ≠ s1i and ai ≠ s2i (we can do it because k > q). So, for every position from q we can put symbols, equal to corresponding symbols in s1 and s2. Now we have strings s1, s2 of length n - q (such that s1i ≠ s2i for every i) and we should find string ans such that f(ans, s1) = f(ans, s2). We know that s1i ≠ s2i, so ansi may be equal to corresponding in s1 or to corresponding in s2 or not equal to s1i and to s2i. So, we need, at least, 2(k - q) symbols in answer to make f(s1, ans) = k - q and f(s2, ans) = k - q. Consequently, if n - q < 2(k - q), the answer is  - 1, and else just put first k - q symbols in answer from s1, next k - q symbols from s2, and others won't be equal to corresponding in s1 and s2.Solution works in O(n).584D - Dima and LisaThere is a fact that the distance between adjacent prime numbers isn't big. For n = 109 maximal distanse is 282. So let's find maximal prime p, such that p < n - 1 (we can just decrease n while it's not prime(we can check it in )). We know that n - p < 300. Now we have even (because n and p are odd) number n - p and we should divide it into a sum of two primes. As n - p < 300, we can just iterate over small primes P and check if P is prime and n - p - P is prime. You can check that there is a solution for all even numbers less than 300 by bruteforce.584E - Anton and IraWe can consider that we pay 2|i - j| coins for swap (we can divide answer in the end). Then we can consider that we pay |i - j| coins for moving pi and |i - j| for moving pj. So, if x was on position i and then came to position j, then we will pay at least |i - j| coins. Then the answer is at least (pp — position k in permutation p, and ps — position k in permutation s). Let's prove that this is the answer by showing the algorithm of making swaps.Let's consider that permutation s is sorted (our task is equal to it). Then we will put numbers from n to 1 on their positions.How we can put n on its position? Denote ppos = n. Let's prove that there exists a position pos2 such that pos < pos2 and ppos2 ≤ pos(then we will swap ppos2 with n (and both numbers will move to their final positions and n will move to the right, so we can repeat this process until n returns to its position)). We can note that there are only n - pos positions that are bigger than pos. And how many numbers on these positions can be bigger than pos? We can say that answer is n - pos, but it's incorrect, because n is bigger than pos, but posn ≤ pos. Now we can use Pigeonhole principle and say that position x, such that x > pos and px ≤ pos exists.But now our algorithm is O(n3). How we can put n in its position in O(n) operations? Let's move the pointer to the right while number is bigger than pos. Then swap n with found number. After we can move pointer from new n's position, so pointer always moves to the right and will not do more then n steps.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20766",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 584\\s*C"
          },
          "content_length": 4444
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 1",
          "code": "\"a third string, different from them in exactly t **characters**\" whatever the positions(see example)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 2",
          "code": "\"a third string, different from them in exactly t **characters**\" whatever the positions(see example)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 3",
          "code": "\"a third string, different from them in exactly t **positions**\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 4",
          "code": "\"a third string, different from them in exactly t **positions**\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 5",
          "code": "sum_c(abs(cnt1[c] - cnt2[c]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 6",
          "code": "sum_c(abs(cnt1[c] - cnt2[c]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 8",
          "code": "cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 9",
          "code": "One record from this search is that 3325581707333960528 is the smallest number that has no Goldbach partition with a prime below 9781.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(0, n, \"t\");\n    inf.readEoln();\n\n    string s1 = inf.readLine();\n    ensuref(int(s1.length()) == n, \"Length of s1 must be %d, but it is %d\", n, int(s1.length()));\n    for (int i = 0; i < n; i++) {\n        ensuref('a' <= s1[i] && s1[i] <= 'z', \"s1 contains invalid character at position %d\", i+1);\n    }\n\n    string s2 = inf.readLine();\n    ensuref(int(s2.length()) == n, \"Length of s2 must be %d, but it is %d\", n, int(s2.length()));\n    for (int i = 0; i < n; i++) {\n        ensuref('a' <= s2[i] && s2[i] <= 'z', \"s2 contains invalid character at position %d\", i+1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(0, n, \"t\");\n    inf.readEoln();\n\n    string s1 = inf.readLine();\n    ensuref(int(s1.length()) == n, \"Length of s1 must be %d, but it is %d\", n, int(s1.length()));\n    for (int i = 0; i < n; i++) {\n        ensuref('a' <= s1[i] && s1[i] <= 'z', \"s1 contains invalid character at position %d\", i+1);\n    }\n\n    string s2 = inf.readLine();\n    ensuref(int(s2.length()) == n, \"Length of s2 must be %d, but it is %d\", n, int(s2.length()));\n    for (int i = 0; i < n; i++) {\n        ensuref('a' <= s2[i] && s2[i] <= 'z', \"s2 contains invalid character at position %d\", i+1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(0, n, \"t\");\n    inf.readEoln();\n\n    string s1 = inf.readLine();\n    ensuref(int(s1.length()) == n, \"Length of s1 must be %d, but it is %d\", n, int(s1.length()));\n    for (int i = 0; i < n; i++) {\n        ensuref('a' <= s1[i] && s1[i] <= 'z', \"s1 contains invalid character at position %d\", i+1);\n    }\n\n    string s2 = inf.readLine();\n    ensuref(int(s2.length()) == n, \"Length of s2 must be %d, but it is %d\", n, int(s2.length()));\n    for (int i = 0; i < n; i++) {\n        ensuref('a' <= s2[i] && s2[i] <= 'z', \"s2 contains invalid character at position %d\", i+1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt();\n    int t = inf.readInt();\n    inf.readEoln();\n    string s1 = inf.readLine();\n    string s2 = inf.readLine();\n\n    if ((int)s1.length() != n)\n        quitf(_fail, \"Length of s1 is not equal to n.\");\n    if ((int)s2.length() != n)\n        quitf(_fail, \"Length of s2 is not equal to n.\");\n\n    string s3 = ouf.readLine();\n\n    int d = 0; // number of positions where s1[i] != s2[i]\n    for (int i = 0; i < n; i++) {\n        if (s1[i] != s2[i])\n            d++;\n    }\n    int min_t = (d + 1) / 2;\n    if (t > n || t < 0)\n        quitf(_fail, \"Invalid t value: t = %d\", t);\n\n    bool impossible = t < (d + 1) / 2;\n\n    if (s3 == \"-1\") {\n        if (impossible)\n            quitf(_ok, \"Correctly reported no solution.\");\n        else\n            quitf(_wa, \"Contestant reported no solution, but solution exists.\");\n    } else {\n        if ((int)s3.length() != n)\n            quitf(_wa, \"Output string length is not equal to n.\");\n        for (int i = 0; i < n; i++) {\n            if (!islower(s3[i]))\n                quitf(_wa, \"Output string contains invalid character at position %d.\", i + 1);\n        }\n        int t1 = 0; // Differences between s1 and s3\n        int t2 = 0; // Differences between s2 and s3\n        for (int i = 0; i < n; i++) {\n            if (s1[i] != s3[i])\n                t1++;\n            if (s2[i] != s3[i])\n                t2++;\n        }\n        if (t1 != t)\n            quitf(_wa, \"Number of differences between s1 and s3 is %d instead of %d.\", t1, t);\n        if (t2 != t)\n            quitf(_wa, \"Number of differences between s2 and s3 is %d instead of %d.\", t2, t);\n        if (impossible)\n            quitf(_fail, \"Contestant found a solution when none should exist.\");\n        quitf(_ok, \"Correct solution.\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test case of the form:\n    n t\n    s1\n    s2\n  where\n    1 <= n <= 100000\n    0 <= t <= n\n    s1, s2 are strings of length n consisting of lowercase English letters.\n  \n  Command-line usage example:\n    ./gen -n 10 -t 3 -type random\n\n  It supports several \"type\" modes:\n    1. same:        s2 is exactly the same as s1.\n    2. all_diff:    s2 differs from s1 in every position (if possible).\n    3. partial_diff: s2 differs from s1 in about n/2 positions.\n    4. random:      s1 and s2 are generated randomly, independently.\n\n  Note that for some combinations of (n, t, type), the correct answer to the\n  problem can be \"-1\". For others, a valid s3 may exist. This variation helps\n  catch incorrect solutions from contestants.\n*/\n\nstatic const int ALPH = 26; // number of lowercase letters\n\n// Generate a single random lowercase letter.\nchar randomLetter() {\n    return char('a' + rnd.next(ALPH));\n}\n\n// Generate a random string of length n (all lowercase letters).\nstring randomString(int n) {\n    string s;\n    s.reserve(n);\n    for(int i = 0; i < n; i++){\n        s.push_back(randomLetter());\n    }\n    return s;\n}\n\n// Generate a random letter different from a given character c.\nchar randomLetterDifferent(char c) {\n    char x;\n    do {\n        x = randomLetter();\n    } while (x == c);\n    return x;\n}\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Make sure n and t satisfy the problem constraints.\n    // (1 <= n <= 100000, 0 <= t <= n).\n    // We rely on the user to provide valid input here;\n    // but you could add checks if desired.\n\n    // Generate s1, s2.\n    string s1, s2;\n    s1 = randomString(n);\n\n    if (type == \"same\") {\n        // s2 exactly equals s1\n        s2 = s1;\n    }\n    else if (type == \"all_diff\") {\n        // Attempt to differ from s1 in every position\n        // If n is large, there's still enough letters to pick from.\n        // We do random but always ensure s2[i] != s1[i].\n        s2.resize(n);\n        for(int i = 0; i < n; i++){\n            s2[i] = randomLetterDifferent(s1[i]);\n        }\n    }\n    else if (type == \"partial_diff\") {\n        // s2 differs from s1 in about half of the positions\n        // (or at least as close as we can to n/2).\n        // We first copy s1, then in ~n/2 positions, pick a different letter.\n        s2 = s1;\n        int d = n / 2;   // number of positions to differ\n        // Randomly choose d distinct positions to differ\n        vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        shuffle(idx.begin(), idx.end());\n        d = min(d, n); // just in case\n        for(int i = 0; i < d; i++){\n            int pos = idx[i];\n            s2[pos] = randomLetterDifferent(s1[pos]);\n        }\n    }\n    else {\n        // type == \"random\" or any other unrecognized type\n        s2 = randomString(n);\n    }\n\n    // Print one test case:\n    // 1) n t\n    // 2) s1\n    // 3) s2\n    cout << n << \" \" << t << \"\\n\";\n    cout << s1 << \"\\n\";\n    cout << s2 << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test case of the form:\n    n t\n    s1\n    s2\n  where\n    1 <= n <= 100000\n    0 <= t <= n\n    s1, s2 are strings of length n consisting of lowercase English letters.\n  \n  Command-line usage example:\n    ./gen -n 10 -t 3 -type random\n\n  It supports several \"type\" modes:\n    1. same:        s2 is exactly the same as s1.\n    2. all_diff:    s2 differs from s1 in every position (if possible).\n    3. partial_diff: s2 differs from s1 in about n/2 positions.\n    4. random:      s1 and s2 are generated randomly, independently.\n\n  Note that for some combinations of (n, t, type), the correct answer to the\n  problem can be \"-1\". For others, a valid s3 may exist. This variation helps\n  catch incorrect solutions from contestants.\n*/\n\nstatic const int ALPH = 26; // number of lowercase letters\n\n// Generate a single random lowercase letter.\nchar randomLetter() {\n    return char('a' + rnd.next(ALPH));\n}\n\n// Generate a random string of length n (all lowercase letters).\nstring randomString(int n) {\n    string s;\n    s.reserve(n);\n    for(int i = 0; i < n; i++){\n        s.push_back(randomLetter());\n    }\n    return s;\n}\n\n// Generate a random letter different from a given character c.\nchar randomLetterDifferent(char c) {\n    char x;\n    do {\n        x = randomLetter();\n    } while (x == c);\n    return x;\n}\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Make sure n and t satisfy the problem constraints.\n    // (1 <= n <= 100000, 0 <= t <= n).\n    // We rely on the user to provide valid input here;\n    // but you could add checks if desired.\n\n    // Generate s1, s2.\n    string s1, s2;\n    s1 = randomString(n);\n\n    if (type == \"same\") {\n        // s2 exactly equals s1\n        s2 = s1;\n    }\n    else if (type == \"all_diff\") {\n        // Attempt to differ from s1 in every position\n        // If n is large, there's still enough letters to pick from.\n        // We do random but always ensure s2[i] != s1[i].\n        s2.resize(n);\n        for(int i = 0; i < n; i++){\n            s2[i] = randomLetterDifferent(s1[i]);\n        }\n    }\n    else if (type == \"partial_diff\") {\n        // s2 differs from s1 in about half of the positions\n        // (or at least as close as we can to n/2).\n        // We first copy s1, then in ~n/2 positions, pick a different letter.\n        s2 = s1;\n        int d = n / 2;   // number of positions to differ\n        // Randomly choose d distinct positions to differ\n        vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        shuffle(idx.begin(), idx.end());\n        d = min(d, n); // just in case\n        for(int i = 0; i < d; i++){\n            int pos = idx[i];\n            s2[pos] = randomLetterDifferent(s1[pos]);\n        }\n    }\n    else {\n        // type == \"random\" or any other unrecognized type\n        s2 = randomString(n);\n    }\n\n    // Print one test case:\n    // 1) n t\n    // 2) s1\n    // 3) s2\n    cout << n << \" \" << t << \"\\n\";\n    cout << s1 << \"\\n\";\n    cout << s2 << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are sample commands showing how to invoke this generator\n# to produce a variety of test cases. Each command prints exactly\n# one test case to standard output. You can redirect them at will,\n# but here we simply list them without redirection.\n\n# Small n, corner cases of t\n./gen -n 1 -t 0 -type same\n./gen -n 1 -t 0 -type random\n./gen -n 1 -t 1 -type same\n./gen -n 1 -t 1 -type all_diff\n\n# Slightly bigger n, with t=0 or t=n\n./gen -n 5 -t 0 -type same\n./gen -n 5 -t 5 -type same\n./gen -n 5 -t 0 -type all_diff\n./gen -n 5 -t 5 -type all_diff\n\n# Partial difference with small n\n./gen -n 5 -t 2 -type partial_diff\n\n# Medium n, typical random\n./gen -n 10 -t 0 -type random\n./gen -n 10 -t 5 -type random\n./gen -n 10 -t 10 -type random\n./gen -n 10 -t 3 -type all_diff\n./gen -n 10 -t 3 -type partial_diff\n\n# Larger n, variety\n./gen -n 50 -t 0 -type random\n./gen -n 50 -t 25 -type partial_diff\n./gen -n 50 -t 50 -type same\n./gen -n 50 -t 20 -type all_diff\n./gen -n 50 -t 30 -type random\n\n# Even larger (stress tests)\n./gen -n 1000 -t 500 -type random\n./gen -n 1000 -t 1000 -type all_diff\n./gen -n 1000 -t 0 -type same\n./gen -n 1000 -t 300 -type partial_diff\n\n# Very large (max constraints)\n./gen -n 100000 -t 0 -type same\n./gen -n 100000 -t 100000 -type all_diff\n./gen -n 100000 -t 50000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:21.625175",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "584/D",
      "title": "D. Дима и Лиза",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записано нечетное число n (3 ≤ n < 109).",
      "output_spec": "Выходные данныеВ первой строке выведите k (1 ≤ k ≤ 3) - количество чисел в найденном вами представлении.Во второй строке выведите сами числа pi в любом порядке. Если возможных ответов несколько, разрешается вывести любой.",
      "sample_tests": "ПримерыВходные данныеСкопировать27Выходные данныеСкопировать35 11 11",
      "description": "D. Дима и Лиза\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ единственной строке записано нечетное число n (3 ≤ n < 109).\n\nВходные данные\n\nВыходные данныеВ первой строке выведите k (1 ≤ k ≤ 3) - количество чисел в найденном вами представлении.Во второй строке выведите сами числа pi в любом порядке. Если возможных ответов несколько, разрешается вывести любой.\n\nВыходные данные\n\nВходные данныеСкопировать27Выходные данныеСкопировать35 11 11\n\nВходные данныеСкопировать27\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать35 11 11\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПростое число — это целое число, строго большее единицы, которое делится только на единицу и на само себя.",
      "solutions": [
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces",
          "content": "Задача АРазберем два случая t = 10 и t ≠ 10.Если t = 10, то либо n = 1, и тогда ответ  - 1 (очевидно, что среди чисел от 1 до 9 нет делящихся на 10), либо n > 1, и тогда первые n - 1 цифр можно заполнить как угодно, а в конце дописать 0.Если t < 10, то просто заполним все число цифрами t и оно, очевидно, будет делиться на t.Задача B Количество способов рассадить всех гномов — 33n. Посчитаем количество способов рассадить гномов так, чтобы в любом треугольнике гномы получили 6 монет, а потом вычтем это число из всех способов. Заметим, что все гномы однозначно разбиваются на треугольники вида i — (i + n) — (i + 2n),  i < n. Поэтому можно посчитать количество способов независимо по каждому треугольнику, а потом перемножить результаты. Чтобы получить ответ для треугольника, осталось заметить, что существует ровно 7 способов взять гномов с 6 монетами (это все перестановки 1, 2, 3 и 2, 2, 2)Итого ответ — 33n - 7n. Посчитать степени можно за O(n).Задача СПостроим строку, которая не отличается на t, а совпадает в k = n - t символах. Пусть строки s1 и s2 совпадают в q символах. Тогда если k ≤ q, то возьмем любые k позиций, в которых s1 и s2 совпадают, и поставим в ответ такие же символы. Во все остальные n - k позиций поставим символы, отличающиеся от соответствующих в s1 и s2 (мы всегда можем так сделать, так у нас 26 букв).Теперь k > q. Тогда, если есть ответ, в котором в какой-то из этих q позиций в ответе стоит не такой же символ, как в s1 и s2, то сделаем его равным им, а в каких-нибудь позициях, где s1i ≠ s2i, s1i = ansi (и наоборот) поставим в ansi символ, отличный от s1i и s2i(это можно сделать, так как k > q). Тогда можно сразу в эти q позиций поставить символы, равный соответствующим в s1 и s2. Теперь у нас есть строки s1 и s2 длины n - q, отличные в каждой позиции, и надо предъявить строку ans такую, что f(ans, s1) = f(ans, s2) = k - q. Так как строки s1 и s2 отличаются во всех позициях, то любой символ из ans равен либо соответствующему в s1, либо соответствующему в s2, либо ни одному из них. Поэтому, нам надо хотя бы 2(k - q) символов в ответе, чтобы сделать f(s1, ans) = k - q и f(s2, ans) = k - q. Следовательно, если n - q < 2(k - q), то решения не существует. Иначе просто жадно в первые k - q символов ответа поставим символы из s1, в следующие k - q символы из s2, а остальные заполним символами не из s1 и не из s2. Асимптотика — O(n).Задача DОбщеизвестно, что между двумя соседними простыми числами, которые меньше 109, расстояние не очень большое. На самом деле для n = 109 максимальное из этих расстояний равно 282. Поэтому будем делать так: найдем наибольшее число p, такое что p < n - 1 и p — простое. По нашему утверждению n - p < 300. Скажем, что p входит в разложение n и теперь надо разложить четное(так n — нечетное и p — нечетное(если не 2)) n - p на сумму двух простых. Так как n - p маленькое, то сделаем это, просто перебрав два простых. То, что для всех четных, меньших 300, существует разложение на не более чем два простых, можно было проверить просто написав перебор.Задача EБудем считать, что все мы платим за обмен не |i - j|, а 2|i - j|. Тогда можно считать, что мы платим |i - j| за перемещение pi и |i - j| за перемещение pj. Тогда, если x изначально был на позиции i, а потом пришел на позицию j, то мы заплатим за него хотя бы |i - j|. Поэтому ответ это хотя бы (pp — позиция k в перестановке p, а ps — позиция k в перестановке s). Докажем, что это и есть ответ конструктивно, предъявив алгоритм.Будем считать, что перестановка s отсортирована (нашу задачу легко свести к этой). Тогда будем последовательно(сначала n, потом n - 1 и так далее) переставлять числа на свои позиции. Как поставить n на свою позицию? Пусть оно стоит на позиции pos. Докажем, что среди чисел, стоящих справа от n, есть число, меньшее или равное pos(дальше поменяем его местами с n — от этого оба числа сдвинутся к своим итоговым позициям, и при этом n сдвинется хотя бы на 1 вправо, поэтому можно дальше делать так же). Заметим, что всего справа от n ровно n - pos чисел. При этом сколько из них могут быть больше pos. Казалось бы, тоже n - pos, но это не так, так как число n, большее pos, стоит не правее, чем n :). Поэтому, по принципу Дирихле, найдется число, которое меньше или равно pos, и стоит справа от n.Как теперь реализовать этот алгоритм за O(n2), а не за куб? Вот мы хотим поставить n на свое место. Идем направо указателем, пока не встретим число, меньшее или равное pos, а потом поменяем n с этим числом. Дальше указатель надо пускать уже от новой позиции n, поэтому указатель всегда двигается только вправо, и суммарно пройдет не больше n. Итак, каждое из n чисел мы ставим на свою позицию за O(n), поэтому получаем O(n2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20766",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4687
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 1",
          "code": "if is_prime(n) or is_prime(n - 2)\n  answer 1: n or answer 2: 2, n - 2\nelse\n  for prime in primes(до 10^6)\n    if (n - prime) % 2 == 0 and is_prime((n - prime) / 2) // Причем такой prime встречается рано\n      answer 3: prime, (n - prime)/2, (n - prime) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 2",
          "code": "if is_prime(n) or is_prime(n - 2)\n  answer 1: n or answer 2: 2, n - 2\nelse\n  for prime in primes(до 10^6)\n    if (n - prime) % 2 == 0 and is_prime((n - prime) / 2) // Причем такой prime встречается рано\n      answer 3: prime, (n - prime)/2, (n - prime) / 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 3",
          "code": "\"a third string, different from them in exactly t **characters**\" whatever the positions(see example)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 4",
          "code": "\"a third string, different from them in exactly t **characters**\" whatever the positions(see example)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 5",
          "code": "\"a third string, different from them in exactly t **positions**\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 6",
          "code": "\"a third string, different from them in exactly t **positions**\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 7",
          "code": "sum_c(abs(cnt1[c] - cnt2[c]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 8",
          "code": "sum_c(abs(cnt1[c] - cnt2[c]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 9",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 10",
          "code": "cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 11",
          "code": "One record from this search is that 3325581707333960528 is the smallest number that has no Goldbach partition with a prime below 9781.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 999999999, \"n\");\n    ensuref(n % 2 == 1, \"n must be odd, but n modulo 2 is %d\", n % 2);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 999999999, \"n\");\n    ensuref(n % 2 == 1, \"n must be odd, but n modulo 2 is %d\", n % 2);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 999999999, \"n\");\n    ensuref(n % 2 == 1, \"n must be odd, but n modulo 2 is %d\", n % 2);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2)  return true;\n    if (n % 2 == 0) return false;\n    int sqrt_n = sqrt(n);\n    for (int i = 3; i <= sqrt_n; i += 2) {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(3, 1000000000, \"n\");\n    // n is guaranteed to be odd\n\n    int k = ouf.readInt(1, 3, \"k\");\n    vector<int> pi = ouf.readInts(k, 2, n, \"pi\");\n\n    long long sum = 0;\n    for (int i = 0; i < k; ++i) {\n        int p = pi[i];\n        if (!is_prime(p)) {\n            ouf.quitf(_wa, \"%d is not a prime number\", p);\n        }\n        sum += p;\n    }\n\n    if (sum != n) {\n        ouf.quitf(_wa, \"sum of the primes is %lld, expected %d\", sum, n);\n    }\n\n    ouf.quitf(_ok, \"Correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n\nint64 mulmod(int64 a, int64 b, int64 mod) {\n    return (a * b) % mod;\n}\n\nint64 powmod(int64 a, int64 b, int64 mod) {\n    int64 result = 1;\n    a %= mod;\n    while(b > 0) {\n        if (b & 1) {\n            result = mulmod(result, a, mod);\n        }\n        a = mulmod(a, a, mod);\n        b >>= 1;\n    }\n    return result;\n}\n\nbool is_composite(int64 n, int64 a, int64 d, int s) {\n    int64 x = powmod(a, d, n);\n    if (x == 1 || x == n -1)\n        return false;\n    for (int r = 1; r < s; ++r) {\n        x = mulmod(x, x, n);\n        if (x == n -1)\n            return false;\n    }\n    return true;\n}\n\nbool is_prime(int64 n) {\n    if (n < 2) return false;\n    int r = 0;\n    int64 d = n -1;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        r++;\n    }\n    int64 bases[] = {2, 3, 5, 7};\n    for (int64 a : bases) {\n        if (a >= n) continue;\n        if (is_composite(n, a, d, r))\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int min_n = opt<int>(\"min_n\", 3);\n    int max_n = opt<int>(\"max_n\", 1000000000 - 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Correct min_n and max_n\n    if (min_n % 2 == 0) min_n++; // Ensure min_n is odd\n    if (max_n % 2 == 0) max_n--; // Ensure max_n is odd\n    if (min_n < 3) min_n = 3;\n    if (max_n > 1000000000 -1) max_n = 1000000000 -1;\n\n    if (min_n > max_n) {\n        fprintf(stderr, \"Error: min_n > max_n after adjustments\\n\");\n        exit(1);\n    }\n\n    if (n != -1) {\n        // n is given directly\n        // Check if n is within constraints\n        if (n < 3 || n >= 1000000000 || n % 2 == 0) {\n            fprintf(stderr, \"Error: n must be an odd integer between 3 and 10^9 -1\\n\");\n            exit(1);\n        }\n        printf(\"%d\\n\", n);\n    } else {\n        // Generate n based on type\n        int generated_n = -1;\n        if (type == \"min\") {\n            generated_n = 3;\n        } else if (type == \"max\") {\n            generated_n = 999999999; // 1e9 - 1\n        } else if (type == \"small_odd\") {\n            // Generate n ∈ [3, 10], odd\n            vector<int> small_odds;\n            for (int i = 3; i <= 10; i += 2) {\n                small_odds.push_back(i);\n            }\n            generated_n = rnd.any(small_odds);\n        } else if (type == \"large_odd\") {\n            // Generate n ∈ [1e9 - 10, 1e9 - 1], odd\n            vector<int> large_odds;\n            for (int i = 999999989; i <= 999999999; i += 2) {\n                large_odds.push_back(i);\n            }\n            generated_n = rnd.any(large_odds);\n        } else if (type == \"prime_odd\") {\n            // Generate a random odd prime n\n            // Generate random odd numbers in range and test if prime\n            // Due to time constraints, limit number of attempts\n            const int max_attempts = 1000000;\n            for (int attempt = 0; attempt < max_attempts; attempt++) {\n                int candidate = rnd.next(min_n, max_n);\n                if (candidate % 2 == 0) candidate++;\n                if (candidate > max_n) candidate = min_n;\n                if (is_prime(candidate)) {\n                    generated_n = candidate;\n                    break;\n                }\n            }\n            if (generated_n == -1) {\n                fprintf(stderr, \"Error: Could not find an odd prime in the given range\\n\");\n                exit(1);\n            }\n        } else if (type == \"composite_odd\") {\n            // Generate a random odd composite n\n            const int max_attempts = 1000000;\n            for (int attempt = 0; attempt < max_attempts; attempt++) {\n                int candidate = rnd.next(min_n, max_n);\n                if (candidate % 2 == 0) candidate++;\n                if (candidate > max_n) candidate = min_n;\n                if (!is_prime(candidate)) {\n                    generated_n = candidate;\n                    break;\n                }\n            }\n            if (generated_n == -1) {\n                fprintf(stderr, \"Error: Could not find an odd composite in the given range\\n\");\n                exit(1);\n            }\n        } else if (type == \"random\") {\n            generated_n = rnd.next(min_n, max_n);\n            if (generated_n % 2 == 0) generated_n++;\n            if (generated_n > max_n) generated_n = min_n;\n        } else {\n            fprintf(stderr, \"Error: Unknown type '%s'\\n\", type.c_str());\n            exit(1);\n        }\n        printf(\"%d\\n\", generated_n);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n\nint64 mulmod(int64 a, int64 b, int64 mod) {\n    return (a * b) % mod;\n}\n\nint64 powmod(int64 a, int64 b, int64 mod) {\n    int64 result = 1;\n    a %= mod;\n    while(b > 0) {\n        if (b & 1) {\n            result = mulmod(result, a, mod);\n        }\n        a = mulmod(a, a, mod);\n        b >>= 1;\n    }\n    return result;\n}\n\nbool is_composite(int64 n, int64 a, int64 d, int s) {\n    int64 x = powmod(a, d, n);\n    if (x == 1 || x == n -1)\n        return false;\n    for (int r = 1; r < s; ++r) {\n        x = mulmod(x, x, n);\n        if (x == n -1)\n            return false;\n    }\n    return true;\n}\n\nbool is_prime(int64 n) {\n    if (n < 2) return false;\n    int r = 0;\n    int64 d = n -1;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        r++;\n    }\n    int64 bases[] = {2, 3, 5, 7};\n    for (int64 a : bases) {\n        if (a >= n) continue;\n        if (is_composite(n, a, d, r))\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int min_n = opt<int>(\"min_n\", 3);\n    int max_n = opt<int>(\"max_n\", 1000000000 - 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Correct min_n and max_n\n    if (min_n % 2 == 0) min_n++; // Ensure min_n is odd\n    if (max_n % 2 == 0) max_n--; // Ensure max_n is odd\n    if (min_n < 3) min_n = 3;\n    if (max_n > 1000000000 -1) max_n = 1000000000 -1;\n\n    if (min_n > max_n) {\n        fprintf(stderr, \"Error: min_n > max_n after adjustments\\n\");\n        exit(1);\n    }\n\n    if (n != -1) {\n        // n is given directly\n        // Check if n is within constraints\n        if (n < 3 || n >= 1000000000 || n % 2 == 0) {\n            fprintf(stderr, \"Error: n must be an odd integer between 3 and 10^9 -1\\n\");\n            exit(1);\n        }\n        printf(\"%d\\n\", n);\n    } else {\n        // Generate n based on type\n        int generated_n = -1;\n        if (type == \"min\") {\n            generated_n = 3;\n        } else if (type == \"max\") {\n            generated_n = 999999999; // 1e9 - 1\n        } else if (type == \"small_odd\") {\n            // Generate n ∈ [3, 10], odd\n            vector<int> small_odds;\n            for (int i = 3; i <= 10; i += 2) {\n                small_odds.push_back(i);\n            }\n            generated_n = rnd.any(small_odds);\n        } else if (type == \"large_odd\") {\n            // Generate n ∈ [1e9 - 10, 1e9 - 1], odd\n            vector<int> large_odds;\n            for (int i = 999999989; i <= 999999999; i += 2) {\n                large_odds.push_back(i);\n            }\n            generated_n = rnd.any(large_odds);\n        } else if (type == \"prime_odd\") {\n            // Generate a random odd prime n\n            // Generate random odd numbers in range and test if prime\n            // Due to time constraints, limit number of attempts\n            const int max_attempts = 1000000;\n            for (int attempt = 0; attempt < max_attempts; attempt++) {\n                int candidate = rnd.next(min_n, max_n);\n                if (candidate % 2 == 0) candidate++;\n                if (candidate > max_n) candidate = min_n;\n                if (is_prime(candidate)) {\n                    generated_n = candidate;\n                    break;\n                }\n            }\n            if (generated_n == -1) {\n                fprintf(stderr, \"Error: Could not find an odd prime in the given range\\n\");\n                exit(1);\n            }\n        } else if (type == \"composite_odd\") {\n            // Generate a random odd composite n\n            const int max_attempts = 1000000;\n            for (int attempt = 0; attempt < max_attempts; attempt++) {\n                int candidate = rnd.next(min_n, max_n);\n                if (candidate % 2 == 0) candidate++;\n                if (candidate > max_n) candidate = min_n;\n                if (!is_prime(candidate)) {\n                    generated_n = candidate;\n                    break;\n                }\n            }\n            if (generated_n == -1) {\n                fprintf(stderr, \"Error: Could not find an odd composite in the given range\\n\");\n                exit(1);\n            }\n        } else if (type == \"random\") {\n            generated_n = rnd.next(min_n, max_n);\n            if (generated_n % 2 == 0) generated_n++;\n            if (generated_n > max_n) generated_n = min_n;\n        } else {\n            fprintf(stderr, \"Error: Unknown type '%s'\\n\", type.c_str());\n            exit(1);\n        }\n        printf(\"%d\\n\", generated_n);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n\n./gen -type small_odd\n./gen -type small_odd\n./gen -type small_odd\n\n./gen -type large_odd\n./gen -type large_odd\n./gen -type large_odd\n\n./gen -type prime_odd\n./gen -type prime_odd\n./gen -type prime_odd\n\n./gen -type composite_odd\n./gen -type composite_odd\n./gen -type composite_odd\n\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type random -min_n 3 -max_n 100\n./gen -type random -min_n 100000000 -max_n 200000000\n\n./gen -n 3\n./gen -n 5\n./gen -n 999999999\n./gen -n 999999981\n\n./gen -type random -min_n 999999900 -max_n 999999999\n./gen -type random -min_n 3 -max_n 11\n\n./gen -type prime_odd -min_n 999999000 -max_n 999999999\n./gen -type prime_odd -min_n 1000003 -max_n 1000009\n\n./gen -type composite_odd -min_n 999999000 -max_n 999999999\n./gen -type composite_odd -min_n 1000001 -max_n 1000009\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:23.582595",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "584/E",
      "title": "E. Anton and Ira",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single number n (1 ≤ n ≤ 2000) — the length of the permutations.The second line contains a sequence of n numbers from 1 to n — permutation p. Each number from 1 to n occurs exactly once in this line.The third line contains a sequence of n numbers from 1 to n — permutation s. Each number from 1 to n occurs once in this line.",
      "output_spec": "OutputIn the first line print the minimum number of coins that you need to spend to transform permutation p into permutation s.In the second line print number k (0 ≤ k ≤ 2·106) — the number of operations needed to get the solution.In the next k lines print the operations. Each line must contain two numbers i and j (1 ≤ i, j ≤ n, i ≠ j), which means that you need to swap pi and pj.It is guaranteed that the solution exists.",
      "sample_tests": "ExamplesInputCopy44 2 1 33 2 4 1OutputCopy324 33 1",
      "description": "E. Anton and Ira\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single number n (1 ≤ n ≤ 2000) — the length of the permutations.The second line contains a sequence of n numbers from 1 to n — permutation p. Each number from 1 to n occurs exactly once in this line.The third line contains a sequence of n numbers from 1 to n — permutation s. Each number from 1 to n occurs once in this line.\n\nOutputIn the first line print the minimum number of coins that you need to spend to transform permutation p into permutation s.In the second line print number k (0 ≤ k ≤ 2·106) — the number of operations needed to get the solution.In the next k lines print the operations. Each line must contain two numbers i and j (1 ≤ i, j ≤ n, i ≠ j), which means that you need to swap pi and pj.It is guaranteed that the solution exists.\n\nInputCopy44 2 1 33 2 4 1OutputCopy324 33 1\n\nInputCopy44 2 1 33 2 4 1\n\nOutputCopy324 33 1\n\nNoteIn the first sample test we swap numbers on positions 3 and 4 and permutation p becomes 4 2 3 1. We pay |3 - 4| = 1 coins for that. On second turn we swap numbers on positions 1 and 3 and get permutation 3241 equal to s. We pay |3 - 1| = 2 coins for that. In total we pay three coins.",
      "solutions": [
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces",
          "content": "584A - Olesya and RodionTwo cases: t = 10 and t ≠ 10.If t = 10 then there are two cases again :). If n = 1 then answer is  - 1 (because there is not any digit divisible by t). If n > 1, then answer, for example, is '1111...110' (contains n - 1 ones).If t < 10 then answer, for example, is 'tttttttt' (it, obviously, divisible by t).584B - Kolya and Tanya The number of ways to choose ai (without any conditions) — 33n. Let A be the number of ways to choose ai with condition that in every triangle gnomes have 6 coins. Then answer is 33n - A.Note that we can separate all gnomes on n independent triangles (i-th triangle contains of ai, ai + n, ai + 2n, i < n). So we can count answer for one triangle and then multiply the results. To count answer for one triangle, we can note that there are 7 ways to choose gnomes with 6 coins (all permutations 1, 2, 3 and 2, 2, 2).So answer is — 33n - 7n. We count it in O(n).584C - Marina and VasyaLet's find a string that will be equal to s1 in k = n - t positions and equal to s2 in k = n - t positions. Let's denote q = quantity of i that s1i = s2i. If k ≤ q, then let's take k positions such that s1pos = s2pos and put in answer the same symbols. Then put in other n - k positions symbols, which are not equal to corresponding in s1 and s2 (we can do it, because we have 26 letters).Now k > q. So, if there is an answer, where exists pos such that s1pos = s2pos, s1pos ≠ anspos, let's denote ansi = s1i, and then in any position such that s1i ≠ s2i = ansi and s1i = ansi (and in the same position in s2) we will choose ai, such that ai ≠ s1i and ai ≠ s2i (we can do it because k > q). So, for every position from q we can put symbols, equal to corresponding symbols in s1 and s2. Now we have strings s1, s2 of length n - q (such that s1i ≠ s2i for every i) and we should find string ans such that f(ans, s1) = f(ans, s2). We know that s1i ≠ s2i, so ansi may be equal to corresponding in s1 or to corresponding in s2 or not equal to s1i and to s2i. So, we need, at least, 2(k - q) symbols in answer to make f(s1, ans) = k - q and f(s2, ans) = k - q. Consequently, if n - q < 2(k - q), the answer is  - 1, and else just put first k - q symbols in answer from s1, next k - q symbols from s2, and others won't be equal to corresponding in s1 and s2.Solution works in O(n).584D - Dima and LisaThere is a fact that the distance between adjacent prime numbers isn't big. For n = 109 maximal distanse is 282. So let's find maximal prime p, such that p < n - 1 (we can just decrease n while it's not prime(we can check it in )). We know that n - p < 300. Now we have even (because n and p are odd) number n - p and we should divide it into a sum of two primes. As n - p < 300, we can just iterate over small primes P and check if P is prime and n - p - P is prime. You can check that there is a solution for all even numbers less than 300 by bruteforce.584E - Anton and IraWe can consider that we pay 2|i - j| coins for swap (we can divide answer in the end). Then we can consider that we pay |i - j| coins for moving pi and |i - j| for moving pj. So, if x was on position i and then came to position j, then we will pay at least |i - j| coins. Then the answer is at least (pp — position k in permutation p, and ps — position k in permutation s). Let's prove that this is the answer by showing the algorithm of making swaps.Let's consider that permutation s is sorted (our task is equal to it). Then we will put numbers from n to 1 on their positions.How we can put n on its position? Denote ppos = n. Let's prove that there exists a position pos2 such that pos < pos2 and ppos2 ≤ pos(then we will swap ppos2 with n (and both numbers will move to their final positions and n will move to the right, so we can repeat this process until n returns to its position)). We can note that there are only n - pos positions that are bigger than pos. And how many numbers on these positions can be bigger than pos? We can say that answer is n - pos, but it's incorrect, because n is bigger than pos, but posn ≤ pos. Now we can use Pigeonhole principle and say that position x, such that x > pos and px ≤ pos exists.But now our algorithm is O(n3). How we can put n in its position in O(n) operations? Let's move the pointer to the right while number is bigger than pos. Then swap n with found number. After we can move pointer from new n's position, so pointer always moves to the right and will not do more then n steps.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20766",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 584\\s*E"
          },
          "content_length": 4444
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 1",
          "code": "\"a third string, different from them in exactly t **characters**\" whatever the positions(see example)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 2",
          "code": "\"a third string, different from them in exactly t **characters**\" whatever the positions(see example)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 3",
          "code": "\"a third string, different from them in exactly t **positions**\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 4",
          "code": "\"a third string, different from them in exactly t **positions**\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 5",
          "code": "sum_c(abs(cnt1[c] - cnt2[c]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 6",
          "code": "sum_c(abs(cnt1[c] - cnt2[c]))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 8",
          "code": "cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #324 (Div. 2) - Codeforces - Code 9",
          "code": "One record from this search is that 3325581707333960528 is the smallest number that has no Goldbach partition with a prime below 9781.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20766",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n);\n    inf.readEoln();\n\n    // Check that p is a permutation of numbers from 1 to n\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == n, \"p must be a permutation of numbers from 1 to n\");\n\n    vector<int> s = inf.readInts(n, 1, n);\n    inf.readEoln();\n\n    // Check that s is a permutation of numbers from 1 to n\n    set<int> s_set(s.begin(), s.end());\n    ensuref((int)s_set.size() == n, \"s must be a permutation of numbers from 1 to n\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n);\n    inf.readEoln();\n\n    // Check that p is a permutation of numbers from 1 to n\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == n, \"p must be a permutation of numbers from 1 to n\");\n\n    vector<int> s = inf.readInts(n, 1, n);\n    inf.readEoln();\n\n    // Check that s is a permutation of numbers from 1 to n\n    set<int> s_set(s.begin(), s.end());\n    ensuref((int)s_set.size() == n, \"s must be a permutation of numbers from 1 to n\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln();\n\n    vector<int> p = inf.readInts(n, 1, n);\n    inf.readEoln();\n\n    // Check that p is a permutation of numbers from 1 to n\n    set<int> p_set(p.begin(), p.end());\n    ensuref((int)p_set.size() == n, \"p must be a permutation of numbers from 1 to n\");\n\n    vector<int> s = inf.readInts(n, 1, n);\n    inf.readEoln();\n\n    // Check that s is a permutation of numbers from 1 to n\n    set<int> s_set(s.begin(), s.end());\n    ensuref((int)s_set.size() == n, \"s must be a permutation of numbers from 1 to n\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> p, s;\n\n// Reads total cost from the jury's answer file.\nlong long readTotalCost(InStream& stream) {\n    return stream.readLong(0, LLONG_MAX, \"total cost\");\n}\n\n// Reads and validates the contestant's output.\nlong long readAndValidateContestantOutput(InStream& stream) {\n    long long totalCost = stream.readLong(0, LLONG_MAX, \"total cost\");\n    int k = stream.readInt(0, 2000000, \"number of swaps\");\n    \n    vector<pair<int, int>> swaps;\n    for (int i = 0; i < k; i++) {\n        int x = stream.readInt(1, n, format(\"swap #%d position i\", i + 1).c_str());\n        int y = stream.readInt(1, n, format(\"swap #%d position j\", i + 1).c_str());\n        if (x == y) {\n            stream.quitf(_wa, \"swap #%d has the same indices: %d %d\", i + 1, x, y);\n        }\n        swaps.push_back({x - 1, y - 1}); // Convert to 0-based indexing\n    }\n    \n    vector<int> perm = p;\n    long long computedCost = 0;\n    for (int i = 0; i < k; i++) {\n        int x = swaps[i].first;\n        int y = swaps[i].second;\n        swap(perm[x], perm[y]);\n        computedCost += abs(x - y);\n    }\n    \n    if (computedCost != totalCost) {\n        stream.quitf(_wa, \"Computed total cost %lld doesn't match claimed total cost %lld\", computedCost, totalCost);\n    }\n    if (perm != s) {\n        stream.quitf(_wa, \"Final permutation doesn't match target permutation\");\n    }\n    \n    return totalCost;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    n = inf.readInt(1, 2000);\n    p.resize(n);\n    s.resize(n);\n    set<int> used_nums;\n    for (int i = 0; i < n; i++) {\n        p[i] = inf.readInt(1, n, format(\"p[%d]\", i + 1).c_str());\n        if (used_nums.count(p[i])) {\n            quitf(_fail, \"Input permutation 'p' has duplicate element %d at position %d\", p[i], i + 1);\n        }\n        used_nums.insert(p[i]);\n    }\n    used_nums.clear();\n    for (int i = 0; i < n; i++) {\n        s[i] = inf.readInt(1, n, format(\"s[%d]\", i + 1).c_str());\n        if (used_nums.count(s[i])) {\n            quitf(_fail, \"Input permutation 's' has duplicate element %d at position %d\", s[i], i + 1);\n        }\n        used_nums.insert(s[i]);\n    }\n    \n    long long jans = readTotalCost(ans);\n    long long pans = readAndValidateContestantOutput(ouf);\n    \n    if (pans > jans) {\n        quitf(_wa, \"Participant's total cost %lld is greater than jury's minimal total cost %lld\", pans, jans);\n    } else if (pans == jans) {\n        quitf(_ok, \"Participant's total cost %lld matches jury's minimal total cost\", pans);\n    } else { // pans < jans\n        quitf(_fail, \"Participant's total cost %lld is less than jury's minimal total cost %lld\", pans, jans);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> p(n), s(n);\n    if (type == \"equal\") {\n        /* p and s are the same sorted permutation */\n        for (int i = 0; i < n; ++i) {\n            p[i] = i + 1;\n            s[i] = i + 1;\n        }\n    } else if (type == \"reverse\") {\n        /* p is sorted, s is reversed */\n        for (int i = 0; i < n; ++i) {\n            p[i] = i + 1;\n            s[i] = n - i;\n        }\n    } else if (type == \"oneswap\") {\n        /* p is sorted, s is p with two elements swapped */\n        for (int i = 0; i < n; ++i) {\n            p[i] = i + 1;\n            s[i] = i + 1;\n        }\n        int i = rnd.next(0, n - 1);\n        int j = rnd.next(0, n - 1);\n        while (j == i) {\n            j = rnd.next(0, n - 1);\n        }\n        swap(s[i], s[j]);\n    } else if (type == \"swapends\") {\n        /* p is sorted, s is p with first and last elements swapped */\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        s = p;\n        if (n > 1)\n            swap(s[0], s[n - 1]);\n    } else if (type == \"random\") {\n        /* p and s are random permutations */\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n        for (int i = 0; i < n; ++i)\n            s[i] = i + 1;\n        shuffle(s.begin(), s.end());\n    } else {\n        /* Default to random if unknown type */\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n        for (int i = 0; i < n; ++i)\n            s[i] = i + 1;\n        shuffle(s.begin(), s.end());\n    }\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output permutation p */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", p[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n    /* Output permutation s */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", s[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> p(n), s(n);\n    if (type == \"equal\") {\n        /* p and s are the same sorted permutation */\n        for (int i = 0; i < n; ++i) {\n            p[i] = i + 1;\n            s[i] = i + 1;\n        }\n    } else if (type == \"reverse\") {\n        /* p is sorted, s is reversed */\n        for (int i = 0; i < n; ++i) {\n            p[i] = i + 1;\n            s[i] = n - i;\n        }\n    } else if (type == \"oneswap\") {\n        /* p is sorted, s is p with two elements swapped */\n        for (int i = 0; i < n; ++i) {\n            p[i] = i + 1;\n            s[i] = i + 1;\n        }\n        int i = rnd.next(0, n - 1);\n        int j = rnd.next(0, n - 1);\n        while (j == i) {\n            j = rnd.next(0, n - 1);\n        }\n        swap(s[i], s[j]);\n    } else if (type == \"swapends\") {\n        /* p is sorted, s is p with first and last elements swapped */\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        s = p;\n        if (n > 1)\n            swap(s[0], s[n - 1]);\n    } else if (type == \"random\") {\n        /* p and s are random permutations */\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n        for (int i = 0; i < n; ++i)\n            s[i] = i + 1;\n        shuffle(s.begin(), s.end());\n    } else {\n        /* Default to random if unknown type */\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n        for (int i = 0; i < n; ++i)\n            s[i] = i + 1;\n        shuffle(s.begin(), s.end());\n    }\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output permutation p */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", p[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n    /* Output permutation s */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", s[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type equal\n./gen -n 1 -type reverse\n./gen -n 2 -type oneswap\n./gen -n 2 -type swapends\n./gen -n 2 -type random\n./gen -n 3 -type equal\n./gen -n 3 -type oneswap\n./gen -n 3 -type swapends\n./gen -n 3 -type random\n./gen -n 10 -type equal\n./gen -n 10 -type reverse\n./gen -n 10 -type oneswap\n./gen -n 10 -type swapends\n./gen -n 10 -type random\n./gen -n 50 -type reverse\n./gen -n 50 -type oneswap\n./gen -n 50 -type swapends\n./gen -n 50 -type random\n./gen -n 100 -type equal\n./gen -n 100 -type reverse\n./gen -n 100 -type oneswap\n./gen -n 100 -type swapends\n./gen -n 100 -type random\n./gen -n 500 -type reverse\n./gen -n 500 -type oneswap\n./gen -n 500 -type swapends\n./gen -n 500 -type random\n./gen -n 1000 -type reverse\n./gen -n 1000 -type oneswap\n./gen -n 1000 -type swapends\n./gen -n 1000 -type random\n./gen -n 2000 -type reverse\n./gen -n 2000 -type oneswap\n./gen -n 2000 -type swapends\n./gen -n 2000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:25.268598",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "585/A",
      "title": "A. Gennady the Dentist",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains a positive integer n (1 ≤ n ≤ 4000) — the number of kids in the line. Next n lines contain three integers each vi, di, pi (1 ≤ vi, di, pi ≤ 106) — the volume of the cry in the doctor's office, the volume of the cry in the hall and the confidence of the i-th child.",
      "output_spec": "OutputIn the first line print number k — the number of children whose teeth Gennady will cure.In the second line print k integers — the numbers of the children who will make it to the end of the line in the increasing order.",
      "sample_tests": "ExamplesInputCopy54 2 24 1 25 2 43 3 55 1 2OutputCopy21 3 InputCopy54 5 15 3 94 1 22 1 84 1 9OutputCopy41 2 4 5",
      "description": "A. Gennady the Dentist\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains a positive integer n (1 ≤ n ≤ 4000) — the number of kids in the line. Next n lines contain three integers each vi, di, pi (1 ≤ vi, di, pi ≤ 106) — the volume of the cry in the doctor's office, the volume of the cry in the hall and the confidence of the i-th child.\n\nOutputIn the first line print number k — the number of children whose teeth Gennady will cure.In the second line print k integers — the numbers of the children who will make it to the end of the line in the increasing order.\n\nInputCopy54 2 24 1 25 2 43 3 55 1 2OutputCopy21 3 InputCopy54 5 15 3 94 1 22 1 84 1 9OutputCopy41 2 4 5\n\nInputCopy54 2 24 1 25 2 43 3 55 1 2\n\nOutputCopy21 3\n\nInputCopy54 5 15 3 94 1 22 1 84 1 9\n\nOutputCopy41 2 4 5\n\nNoteIn the first example, Gennady first treats the teeth of the first child who will cry with volume 4. The confidences of the remaining children will get equal to  - 2, 1, 3, 1, respectively. Thus, the second child also cries at the volume of 1 and run to the exit. The confidence of the remaining children will be equal to 0, 2, 0. Then the third child will go to the office, and cry with volume 5. The other children won't bear this, and with a loud cry they will run to the exit.In the second sample, first the first child goes into the office, he will cry with volume 4. The confidence of the remaining children will be equal to 5,  - 1, 6, 8. Thus, the third child will cry with the volume of 1 and run to the exit. The confidence of the remaining children will be equal to 5, 5, 7. After that, the second child goes to the office and cry with the volume of 5. The confidences of the remaining children will be equal to 0, 3. Then the fourth child will go into the office and cry with the volume of 2. Because of this the confidence of the fifth child will be 1, and he will go into the office last.",
      "solutions": [
        {
          "title": "Codeforces Round #325 - Codeforces",
          "content": "Hi, Codeforces!Codeforces Round #325 will take place on October 12, 2015 at 09:00 UTC for the first and second divisions. Please note that the round will start at unusual time!The problems of this round are taken from the Regional stage of the All-Russian school team programming olympiad that will be at the same time in Saratov, Russia. Lets wish school teams good luck on competition!The problemset for school olympiad differs from problems that will be on round. In addition in problemset for school olympiad there will be some problems, which are not included in the round and vice versa. So don't be frightened by the difficulty of problems given for school teams :-)The process of problems preapring was very interesting: we were reworking problem statements many times, adding tests, changing limits, even managed to change fully prepared problem with another (we had to stop the conveyor already printing problem statements :-)) Let's thank all who were preparing, helping in preparing, reading the problem statements, writing solutions: Adilbek adedalic Dalabaev, Roman Roms Glazov, Vladimir vovuh Petrov, Oleg Oleg_Smirnov Smirnov, Alexey Perforator Ripinen, Maxim Neon Mescheryakov, Ilya IlyaLos Los, Vitaliy gridnevvvit Gridnev, Danil danilka.pro Sagunov, Alexander fcspartakm Frolov, Pavel HolkinPV Kholkin, Igor Igor_Kudryashov Kudryashov, Elena elena Rogacheva, Dmitriy Nerevar Matov, Vitaliy kuviman Kudasov. Chairman of the jury of the Olympiad is Mikhail MikeMirzayanov Mirzayanov (also he is the author of some of tasks). I (Edvard Edvard Davtyan) prepared some tasks and coordinated the work of the authors. So we are a large team of writers (I hope I did not forget anyone)!Also let's thank Max Akhmedov (Zlobober), The-One-Who-Must-Not-Be-Named (if I am not wrong, he or she is right now solving the round problems) for their help in problems preparing, Maria Belova (Delinur) for translating problems in English and again Mikhail Mirzayanov (MikeMirzayanov) for the Codeforces and Polygon systems.You will have only two hours to solve six problems. The scoring distribution will be anounced a little before the round. I wish high rating to all participants! Good luck and have fun!P.S.: Also I want to wish good luck to the participants of the ACM ICPC Southern Subregional Programming Contest that will be held on Wednesday.UPD Due to technical reasons round is delayed by 10 minutes.UPD: In problem Subway roller there were tests with trains of length one. At this moment authors are discussing how much it troubled the round results. We are apologize to participants who had problems with that. We will announce our decision about this problem soon.UPD2: There were trains with length equal to one in tests for problem Subway Roller. Jury decided to accept the first right solution of each user that passed all tests except the wrong, also other submissions were ignored. In addition we accept all successed hacks, although the hack is not correct and the hacked solution passed all other tests. Contest will be rated, but any user who think that this situation is cardinally affected to his/her result can send me in 24 hours a message and jury will discuss the question to make round unrated only for that participant. We are apologize to participants one more time for this situation.UPD3: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20889",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3329
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces",
          "content": "586A - Alena's ScheduleThe problem has been prepared by adedalic.To solve this problem one should remove all leading and trailing zeroes from array and then calculate the number of ones and number of zeroes neighboured by ones. The sum of this values is the answer for the problem.Complexity: O(n).586B - Laurenty and ShopThe problem has been prepared by Oleg_Smirnov.Let's call some path ith if we start it by going i times left, then we cross the prospect and go left n - 1 - i times again. Let di be equal to the time we should wait on traffic lights while following i-th path. If we consider any way from the shop to home, it is equal (but reversed) to only path from home to the shop, meaning that we need to find two distinct paths from home to the shop. So the answer to the problem is the sum of the smallest and the second smallest values among di. One could easily calculate di using calculated di - 1, so di could be found in one for cycle.If we will consider only two minimum values among di, solution complexity will be O(n).Complexity: O(n).585A - Gennady the DentistThe problem has been prepared by Neon.Let's store for each child his current confidence value and a boolean indicating whether child had left the queue (or visited the dentist office) or not. Then one could easily process children one by one, considering only children who still are in the queue (using boolean array), and changing stored values.Such solution has complexity O(n2) and requires author's attention much, especially the case with possible confidence value overflowing. Of course there are much faster solutions not required in our case.585B - Phillip and TrainsThe problem has been prepared by IlyaLos.One could consider a graph with vertices corresponding to every (x, y) position. I should notice that train positions for each Phillip position are fully restorable from his y coordinate. Edge between vertices u and v means that we could get from position corresponding to u to position corresponding by v in one turn without moving onto a train cell or moving in a cell which will be occupied by some train before the next turn. All we need next is to find whether any finishing position is reachable from the only starting position (using BFS or DFS, or, as soon as graph is a DAG, dynamic programming).As soon as graph has O(n) vertices and O(n) edges, solution complexity equals to O(n).585C - Alice, Bob, Oranges and ApplesThe problem has been prepared by Edvard.Firstly, let's understand the process described in problem statement. If one would write a tree of a sum-pairs (x, y) with letters and , he would get the Stern–Brocot tree. Let the number of oranges be enumerator and the number of apples be denumerator of fraction. At every step we have two fractions (at first step they are ) and should replace exactly one of them with their mediant. In such way first fraction is first parent to the left from mediant while second fraction is parent to the right. The process described in statement is, this way, a process of finding a fraction in the Stern-Brocot tree, finishing when the current mediant is equal to current node in the tree and (x, y) pair is the fraction we are searching. This means that if , (x, y) does not correspond to any correct fraction and the answer is \"Impossible\". Other way, we could find it in the tree. If x > y, we should firstly go in the right subtree. Moreover, we could then consider we are searching from the root. If x < y, we should go left and next consider from the root. This gives us Euclidian algorithm, which could be realized to work in complexity.Complexity: O(logn).585D - Lizard Era: BeginningThe problem has been prepared by danilka.pro.To solve the problem we will use meet-in-the-middle approach. For we should consider all variants. Let in some variant approval values of three companions are a, b, c respectively. If we will consider some variant from other half (there are of them) and a', b', c' approval values, then to ``merge'' such two parts correctly, two conditions a - b = b' - a' и b - c = c' - b' must be true (a + a' = b + b' = c + c' is true), and the value we are maximizing is a + a'.This way, to solve the task one could consider every variant from the first half and store for every possible pair (a - b, b - c) the maximum a value achievable (using, for example, the structure or any fast sorting algorithm). If one would then consider every variant from the second half, he just need to find (b' - a', c' - b') pair in the structure to get the maximum a value if possible and update answer with a + a' value. Answer restoring is pretty same to the algorithm above.Such solution has complexity.585E - Present for Vitalik the Philatelist The problem has been prepared by gridnevvvit.Let's calculate the number of subsets with gcd equal to 1 — value A. Let's do that using principle of inclusions-exclusions: firstly we say that all subsets is good. The total number of subsets is equal to 2n. Now let's subtract subsets with gcd divisible by 2. The number of that subsets is equal to 2cnt2 - 1 (cnti is the number of numbers that is divisable by i). Next we should subtract 2cnt3 - 1. Subsets with gcd divisible by 4 we already counted with number two. Next we should subtract 2cnt5 - 1. Now we should notice that subsets with gcd divisible by 6 we already processed twice: firstly with number 2, then with — 3, so let's add the number of these subsets 2cnt6 - 1. If we continue this process we will get, that for all numbers d we should add the value μ(d)(2cntd - 1), where μ(d) is equals to 0, if d is divisible by square of some prime, 1, if the number of primes in factorization of d is even and  - 1 in other case. So the numbers that is divisible by square of some prime we can ignore, because they have coefficient 0. To calculate values cnti we should factorize all numbers and iterate over 2k divisors with value μ(d) ≠ 0. Now it's easy to see, that the number of subsets with gcd greater than 1 equals to B = 2n - A. To solve the problem let's fix the stamp that Vitaliy will buy ai. Let's recalculate the number B for array a without element ai. To do that we should only subtract those terms that was affected by number ai. We can do that in 2k, where k is the number of primes in factorization of the number ai. It's easy to see that only the subsets with gcd greater than 1, but not divisible by any divisor of ai, should we counted in answer. To calculate number of those subsets let's again use the principle of inclusions-exclusions. For every divisor d of ai let's subtract the value μ (2cntd - 1) from B. So now we got Bi — the number of subsets with gcd greater than 1, but coprime with ai. The answer to problem is the sum over all Bi. The maximum number of primes in factorization of number not greater than 107 is equal to 8. We can factorize all numbers from 1 to n in linear time by algorithm for finding the smallest divisors for all intergers from 1 to n, or by sieve of Eratosthenes in O(nloglogn) time.Complexity: O(C + n2K), where , K — is the largest number of primes in factorization of ai.585F - Digits of Number PiThe problem has been prepared by Edvard.Consider all substrings of string s with length . Let's add them all to trie data structure, calculate failure links and build automata by digits. We can do that in linear time using Aho-Korasik algorithm. Now to solve the problem we should calculate dp zi, v, b1, b2, b. State of dp is described by five numbers: i — number of digits, that we already put to our number, v — in which vertex of trie we are, b1 — equals to one if the prefix that we built is equals to prefix of x, b2 — equals to one if the prefix that we built is equals to prefix of y, b — equals to one if we already have some substring with length on the prexif that we built. The value of dp is the number of ways to built prefix with the given set of properties. To update dp we should iterate over the digit that we want to add to prefix, check that we still is in segment [x, y], go from vertex v to the next vertex in automata. So the answer is the sum by all v, b1, b2 zb, v, v1, v2, 1.Complexity: O(nd2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20898",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 585\\s*A"
          },
          "content_length": 8145
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #325 - Codeforces - Code 1",
          "code": "int n = 4000;\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        cout << \"1000000 1000000 1\\n\";\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 2",
          "code": "int n = 4000;\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        cout << \"1000000 1000000 1\\n\";\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 3",
          "code": "Input\n6\n3 1 1\n1 3 2\n10 4 6\n1 1 2\n1 1 2\n1 1 14\nOutput \n2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 4",
          "code": "Input\n6\n3 1 1\n1 3 2\n10 4 6\n1 1 2\n1 1 2\n1 1 14\nOutput \n2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 5",
          "code": "string num;\n\t\twhile(ans0[i].ss > 0) {\n\t\t\tnum +=('0'+ans0[i].ss%10);\n\t\t\tans0[i].ss /=10;}\n\t\tans +=num;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 6",
          "code": "string num;\n\t\twhile(ans0[i].ss > 0) {\n\t\t\tnum +=('0'+ans0[i].ss%10);\n\t\t\tans0[i].ss /=10;}\n\t\tans +=num;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 7",
          "code": "1\n5 3\n..A..\ns.B..\n..C..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 8",
          "code": "1\n5 3\n..A..\ns.B..\n..C..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 9",
          "code": "while(true)\n    {\n        ll mi = min(x,y),ma = max(x,y);\n        if(ma%mi == 0)\n        {\n            ll times = ma/mi - 1;\n            cout<<to_string(times);\n            if(x>y)\n                cout<<\"A\";\n            else\n                cout<<\"B\";\n            return 0;\n        }\n        ll times = ma/mi;\n        cout<<to_string(times);\n        if(x>y)\n            cout<<\"A\";\n        else\n            cout<<\"B\";\n        ma = ma%mi;\n        if(x>y) {\n            x = ma;\n            y = mi;\n        }\n        else {\n            x = mi;\n            y = ma;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 10",
          "code": "while(true)\n    {\n        ll mi = min(x,y),ma = max(x,y);\n        if(ma%mi == 0)\n        {\n            ll times = ma/mi - 1;\n            cout<<to_string(times);\n            if(x>y)\n                cout<<\"A\";\n            else\n                cout<<\"B\";\n            return 0;\n        }\n        ll times = ma/mi;\n        cout<<to_string(times);\n        if(x>y)\n            cout<<\"A\";\n        else\n            cout<<\"B\";\n        ma = ma%mi;\n        if(x>y) {\n            x = ma;\n            y = mi;\n        }\n        else {\n            x = mi;\n            y = ma;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 11",
          "code": "long sum_d = 0; /* be careful, don't let it overflow */\nfor (int j = i+1; j < N; j++) {\n    if (gone[j]) continue;\n\n    p[j] -= sum_d;\n    if (p[j] < 0) {\n        gone[j] = 1;\n        sum_d += d[j];\n        if (sum_d > maxV)\n            sum_d = maxV + 1; /* XXX p == 0 won't make the kid run */\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 12",
          "code": "long sum_d = 0; /* be careful, don't let it overflow */\nfor (int j = i+1; j < N; j++) {\n    if (gone[j]) continue;\n\n    p[j] -= sum_d;\n    if (p[j] < 0) {\n        gone[j] = 1;\n        sum_d += d[j];\n        if (sum_d > maxV)\n            sum_d = maxV + 1; /* XXX p == 0 won't make the kid run */\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 13",
          "code": "5\n3 1 10\n3 1 10\n1 5 1\n1 1 5\n1 1 8\n\noutput\n2\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 14",
          "code": "5\n3 1 10\n3 1 10\n1 5 1\n1 1 5\n1 1 8\n\noutput\n2\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 1",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 2",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 3",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 4",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 4000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int vi = inf.readInt(1, 1000000, format(\"v[%d]\", i + 1));\n        inf.readSpace();\n        int di = inf.readInt(1, 1000000, format(\"d[%d]\", i + 1));\n        inf.readSpace();\n        int pi = inf.readInt(1, 1000000, format(\"p[%d]\", i + 1));\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 4000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int vi = inf.readInt(1, 1000000, format(\"v[%d]\", i + 1));\n        inf.readSpace();\n        int di = inf.readInt(1, 1000000, format(\"d[%d]\", i + 1));\n        inf.readSpace();\n        int pi = inf.readInt(1, 1000000, format(\"p[%d]\", i + 1));\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 4000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int vi = inf.readInt(1, 1000000, format(\"v[%d]\", i + 1));\n        inf.readSpace();\n        int di = inf.readInt(1, 1000000, format(\"d[%d]\", i + 1));\n        inf.readSpace();\n        int pi = inf.readInt(1, 1000000, format(\"p[%d]\", i + 1));\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 4000;\nconst int MAX_VAL = 1000000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    if (type == \"random\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int vi = rnd.next(1, MAX_VAL);\n            int di = rnd.next(1, MAX_VAL);\n            int pi = rnd.next(1, MAX_VAL);\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else if (type == \"max\") {\n        n = MAX_N; // Override n to maximum value\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int vi = MAX_VAL;\n            int di = MAX_VAL;\n            int pi = MAX_VAL;\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else if (type == \"min\") {\n        n = 1; // Override n to minimum value\n        printf(\"%d\\n\", n);\n        int vi = 1;\n        int di = 1;\n        int pi = 1;\n        printf(\"%d %d %d\\n\", vi, di, pi);\n    } else if (type == \"chain_reaction\") {\n        // Generate a test case where chain reactions happen\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int vi, di, pi;\n            if (i == 0) {\n                vi = MAX_VAL; // First child cries loudly\n                di = 1;\n                pi = 1; // His pi doesn't matter much\n            } else {\n                vi = 1;\n                di = 1;\n                pi = 0; // So any decrease causes him to cry\n            }\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else if (type == \"no_cries\") {\n        // Generate a test case where no child ever cries\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int vi = 1; // Minimal effect\n            int di = 1;\n            int pi = MAX_VAL; // High confidence\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else if (type == \"all_cries\") {\n        // Generate a test case where no child gets treated because they all cry before treatment\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int vi = 1;\n            int di = MAX_VAL; // Their crying has maximum effect\n            int pi = 0; // Their confidence is zero, they immediately cry\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else if (type == \"edge_case_1\") {\n        // Children with pi at boundary values\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int vi = rnd.next(1, MAX_VAL);\n            int di = rnd.next(1, MAX_VAL);\n            int pi = 1; // Minimal pi\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else {\n        // Default case: random data\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int vi = rnd.next(1, MAX_VAL);\n            int di = rnd.next(1, MAX_VAL);\n            int pi = rnd.next(1, MAX_VAL);\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 4000;\nconst int MAX_VAL = 1000000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    if (type == \"random\") {\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int vi = rnd.next(1, MAX_VAL);\n            int di = rnd.next(1, MAX_VAL);\n            int pi = rnd.next(1, MAX_VAL);\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else if (type == \"max\") {\n        n = MAX_N; // Override n to maximum value\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int vi = MAX_VAL;\n            int di = MAX_VAL;\n            int pi = MAX_VAL;\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else if (type == \"min\") {\n        n = 1; // Override n to minimum value\n        printf(\"%d\\n\", n);\n        int vi = 1;\n        int di = 1;\n        int pi = 1;\n        printf(\"%d %d %d\\n\", vi, di, pi);\n    } else if (type == \"chain_reaction\") {\n        // Generate a test case where chain reactions happen\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int vi, di, pi;\n            if (i == 0) {\n                vi = MAX_VAL; // First child cries loudly\n                di = 1;\n                pi = 1; // His pi doesn't matter much\n            } else {\n                vi = 1;\n                di = 1;\n                pi = 0; // So any decrease causes him to cry\n            }\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else if (type == \"no_cries\") {\n        // Generate a test case where no child ever cries\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int vi = 1; // Minimal effect\n            int di = 1;\n            int pi = MAX_VAL; // High confidence\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else if (type == \"all_cries\") {\n        // Generate a test case where no child gets treated because they all cry before treatment\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int vi = 1;\n            int di = MAX_VAL; // Their crying has maximum effect\n            int pi = 0; // Their confidence is zero, they immediately cry\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else if (type == \"edge_case_1\") {\n        // Children with pi at boundary values\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int vi = rnd.next(1, MAX_VAL);\n            int di = rnd.next(1, MAX_VAL);\n            int pi = 1; // Minimal pi\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else {\n        // Default case: random data\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            int vi = rnd.next(1, MAX_VAL);\n            int di = rnd.next(1, MAX_VAL);\n            int pi = rnd.next(1, MAX_VAL);\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n\n./gen -n 1 -type min\n./gen -n 1 -type random\n./gen -n 1 -type max\n\n# Medium n\n./gen -n 10 -type random\n./gen -n 10 -type chain_reaction\n./gen -n 10 -type no_cries\n./gen -n 10 -type all_cries\n\n# Larger n\n./gen -n 100 -type random\n./gen -n 100 -type chain_reaction\n./gen -n 100 -type no_cries\n./gen -n 100 -type all_cries\n\n# Edge cases with maximum n\n./gen -n 4000 -type random\n./gen -n 4000 -type max\n./gen -n 4000 -type min\n./gen -n 4000 -type chain_reaction\n./gen -n 4000 -type no_cries\n./gen -n 4000 -type all_cries\n\n# Edge case with minimal pi\n./gen -n 4000 -type edge_case_1\n\n# Additional random cases with different sizes\n./gen -n 500 -type random\n./gen -n 1000 -type random\n./gen -n 2000 -type random\n./gen -n 3000 -type random\n\n# Additional random cases with maximum n\n./gen -n 4000 -type random\n./gen -n 4000 -type random\n\n# Corner cases with specific n\n./gen -n 3999 -type chain_reaction\n./gen -n 2 -type chain_reaction\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:27.648114",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "585/B",
      "title": "B. Phillip and Trains",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputEach test contains from one to ten sets of the input data. The first line of the test contains a single integer t (1 ≤ t ≤ 10 for pretests and tests or t = 1 for hacks; see the Notes section for details) — the number of sets.Then follows the description of t sets of the input data. The first line of the description of each set contains two integers n, k (2 ≤ n ≤ 100, 1 ≤ k ≤ 26) — the number of columns on the field and the number of trains. Each of the following three lines contains the sequence of n character, representing the row of the field where the game is on. Philip's initial position is marked as 's', he is in the leftmost column. Each of the k trains is marked by some sequence of identical uppercase letters of the English alphabet, located in one line. Distinct trains are represented by distinct letters. Character '.' represents an empty cell, that is, the cell that doesn't contain either Philip or the trains.",
      "output_spec": "OutputFor each set of the input data print on a single line word YES, if it is possible to win the game and word NO otherwise.",
      "sample_tests": "ExamplesInputCopy216 4...AAAAA........s.BBB......CCCCC........DDDDD...16 4...AAAAA........s.BBB....CCCCC.........DDDDD....OutputCopyYESNOInputCopy210 4s.ZZ...........AAABB.YYYYYY...10 4s.ZZ..........AAAABB.YYYYYY...OutputCopyYESNO",
      "description": "B. Phillip and Trains\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputEach test contains from one to ten sets of the input data. The first line of the test contains a single integer t (1 ≤ t ≤ 10 for pretests and tests or t = 1 for hacks; see the Notes section for details) — the number of sets.Then follows the description of t sets of the input data. The first line of the description of each set contains two integers n, k (2 ≤ n ≤ 100, 1 ≤ k ≤ 26) — the number of columns on the field and the number of trains. Each of the following three lines contains the sequence of n character, representing the row of the field where the game is on. Philip's initial position is marked as 's', he is in the leftmost column. Each of the k trains is marked by some sequence of identical uppercase letters of the English alphabet, located in one line. Distinct trains are represented by distinct letters. Character '.' represents an empty cell, that is, the cell that doesn't contain either Philip or the trains.\n\nOutputFor each set of the input data print on a single line word YES, if it is possible to win the game and word NO otherwise.\n\nInputCopy216 4...AAAAA........s.BBB......CCCCC........DDDDD...16 4...AAAAA........s.BBB....CCCCC.........DDDDD....OutputCopyYESNOInputCopy210 4s.ZZ...........AAABB.YYYYYY...10 4s.ZZ..........AAAABB.YYYYYY...OutputCopyYESNO\n\nInputCopy216 4...AAAAA........s.BBB......CCCCC........DDDDD...16 4...AAAAA........s.BBB....CCCCC.........DDDDD....\n\nOutputCopyYESNO\n\nInputCopy210 4s.ZZ...........AAABB.YYYYYY...10 4s.ZZ..........AAAABB.YYYYYY...\n\nOutputCopyYESNO\n\nNoteIn the first set of the input of the first sample Philip must first go forward and go down to the third row of the field, then go only forward, then go forward and climb to the second row, go forward again and go up to the first row. After that way no train blocks Philip's path, so he can go straight to the end of the tunnel.Note that in this problem the challenges are restricted to tests that contain only one testset.",
      "solutions": [
        {
          "title": "Codeforces Round #325 - Codeforces",
          "content": "Hi, Codeforces!Codeforces Round #325 will take place on October 12, 2015 at 09:00 UTC for the first and second divisions. Please note that the round will start at unusual time!The problems of this round are taken from the Regional stage of the All-Russian school team programming olympiad that will be at the same time in Saratov, Russia. Lets wish school teams good luck on competition!The problemset for school olympiad differs from problems that will be on round. In addition in problemset for school olympiad there will be some problems, which are not included in the round and vice versa. So don't be frightened by the difficulty of problems given for school teams :-)The process of problems preapring was very interesting: we were reworking problem statements many times, adding tests, changing limits, even managed to change fully prepared problem with another (we had to stop the conveyor already printing problem statements :-)) Let's thank all who were preparing, helping in preparing, reading the problem statements, writing solutions: Adilbek adedalic Dalabaev, Roman Roms Glazov, Vladimir vovuh Petrov, Oleg Oleg_Smirnov Smirnov, Alexey Perforator Ripinen, Maxim Neon Mescheryakov, Ilya IlyaLos Los, Vitaliy gridnevvvit Gridnev, Danil danilka.pro Sagunov, Alexander fcspartakm Frolov, Pavel HolkinPV Kholkin, Igor Igor_Kudryashov Kudryashov, Elena elena Rogacheva, Dmitriy Nerevar Matov, Vitaliy kuviman Kudasov. Chairman of the jury of the Olympiad is Mikhail MikeMirzayanov Mirzayanov (also he is the author of some of tasks). I (Edvard Edvard Davtyan) prepared some tasks and coordinated the work of the authors. So we are a large team of writers (I hope I did not forget anyone)!Also let's thank Max Akhmedov (Zlobober), The-One-Who-Must-Not-Be-Named (if I am not wrong, he or she is right now solving the round problems) for their help in problems preparing, Maria Belova (Delinur) for translating problems in English and again Mikhail Mirzayanov (MikeMirzayanov) for the Codeforces and Polygon systems.You will have only two hours to solve six problems. The scoring distribution will be anounced a little before the round. I wish high rating to all participants! Good luck and have fun!P.S.: Also I want to wish good luck to the participants of the ACM ICPC Southern Subregional Programming Contest that will be held on Wednesday.UPD Due to technical reasons round is delayed by 10 minutes.UPD: In problem Subway roller there were tests with trains of length one. At this moment authors are discussing how much it troubled the round results. We are apologize to participants who had problems with that. We will announce our decision about this problem soon.UPD2: There were trains with length equal to one in tests for problem Subway Roller. Jury decided to accept the first right solution of each user that passed all tests except the wrong, also other submissions were ignored. In addition we accept all successed hacks, although the hack is not correct and the hacked solution passed all other tests. Contest will be rated, but any user who think that this situation is cardinally affected to his/her result can send me in 24 hours a message and jury will discuss the question to make round unrated only for that participant. We are apologize to participants one more time for this situation.UPD3: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20889",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3329
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces",
          "content": "586A - Alena's ScheduleThe problem has been prepared by adedalic.To solve this problem one should remove all leading and trailing zeroes from array and then calculate the number of ones and number of zeroes neighboured by ones. The sum of this values is the answer for the problem.Complexity: O(n).586B - Laurenty and ShopThe problem has been prepared by Oleg_Smirnov.Let's call some path ith if we start it by going i times left, then we cross the prospect and go left n - 1 - i times again. Let di be equal to the time we should wait on traffic lights while following i-th path. If we consider any way from the shop to home, it is equal (but reversed) to only path from home to the shop, meaning that we need to find two distinct paths from home to the shop. So the answer to the problem is the sum of the smallest and the second smallest values among di. One could easily calculate di using calculated di - 1, so di could be found in one for cycle.If we will consider only two minimum values among di, solution complexity will be O(n).Complexity: O(n).585A - Gennady the DentistThe problem has been prepared by Neon.Let's store for each child his current confidence value and a boolean indicating whether child had left the queue (or visited the dentist office) or not. Then one could easily process children one by one, considering only children who still are in the queue (using boolean array), and changing stored values.Such solution has complexity O(n2) and requires author's attention much, especially the case with possible confidence value overflowing. Of course there are much faster solutions not required in our case.585B - Phillip and TrainsThe problem has been prepared by IlyaLos.One could consider a graph with vertices corresponding to every (x, y) position. I should notice that train positions for each Phillip position are fully restorable from his y coordinate. Edge between vertices u and v means that we could get from position corresponding to u to position corresponding by v in one turn without moving onto a train cell or moving in a cell which will be occupied by some train before the next turn. All we need next is to find whether any finishing position is reachable from the only starting position (using BFS or DFS, or, as soon as graph is a DAG, dynamic programming).As soon as graph has O(n) vertices and O(n) edges, solution complexity equals to O(n).585C - Alice, Bob, Oranges and ApplesThe problem has been prepared by Edvard.Firstly, let's understand the process described in problem statement. If one would write a tree of a sum-pairs (x, y) with letters and , he would get the Stern–Brocot tree. Let the number of oranges be enumerator and the number of apples be denumerator of fraction. At every step we have two fractions (at first step they are ) and should replace exactly one of them with their mediant. In such way first fraction is first parent to the left from mediant while second fraction is parent to the right. The process described in statement is, this way, a process of finding a fraction in the Stern-Brocot tree, finishing when the current mediant is equal to current node in the tree and (x, y) pair is the fraction we are searching. This means that if , (x, y) does not correspond to any correct fraction and the answer is \"Impossible\". Other way, we could find it in the tree. If x > y, we should firstly go in the right subtree. Moreover, we could then consider we are searching from the root. If x < y, we should go left and next consider from the root. This gives us Euclidian algorithm, which could be realized to work in complexity.Complexity: O(logn).585D - Lizard Era: BeginningThe problem has been prepared by danilka.pro.To solve the problem we will use meet-in-the-middle approach. For we should consider all variants. Let in some variant approval values of three companions are a, b, c respectively. If we will consider some variant from other half (there are of them) and a', b', c' approval values, then to ``merge'' such two parts correctly, two conditions a - b = b' - a' и b - c = c' - b' must be true (a + a' = b + b' = c + c' is true), and the value we are maximizing is a + a'.This way, to solve the task one could consider every variant from the first half and store for every possible pair (a - b, b - c) the maximum a value achievable (using, for example, the structure or any fast sorting algorithm). If one would then consider every variant from the second half, he just need to find (b' - a', c' - b') pair in the structure to get the maximum a value if possible and update answer with a + a' value. Answer restoring is pretty same to the algorithm above.Such solution has complexity.585E - Present for Vitalik the Philatelist The problem has been prepared by gridnevvvit.Let's calculate the number of subsets with gcd equal to 1 — value A. Let's do that using principle of inclusions-exclusions: firstly we say that all subsets is good. The total number of subsets is equal to 2n. Now let's subtract subsets with gcd divisible by 2. The number of that subsets is equal to 2cnt2 - 1 (cnti is the number of numbers that is divisable by i). Next we should subtract 2cnt3 - 1. Subsets with gcd divisible by 4 we already counted with number two. Next we should subtract 2cnt5 - 1. Now we should notice that subsets with gcd divisible by 6 we already processed twice: firstly with number 2, then with — 3, so let's add the number of these subsets 2cnt6 - 1. If we continue this process we will get, that for all numbers d we should add the value μ(d)(2cntd - 1), where μ(d) is equals to 0, if d is divisible by square of some prime, 1, if the number of primes in factorization of d is even and  - 1 in other case. So the numbers that is divisible by square of some prime we can ignore, because they have coefficient 0. To calculate values cnti we should factorize all numbers and iterate over 2k divisors with value μ(d) ≠ 0. Now it's easy to see, that the number of subsets with gcd greater than 1 equals to B = 2n - A. To solve the problem let's fix the stamp that Vitaliy will buy ai. Let's recalculate the number B for array a without element ai. To do that we should only subtract those terms that was affected by number ai. We can do that in 2k, where k is the number of primes in factorization of the number ai. It's easy to see that only the subsets with gcd greater than 1, but not divisible by any divisor of ai, should we counted in answer. To calculate number of those subsets let's again use the principle of inclusions-exclusions. For every divisor d of ai let's subtract the value μ (2cntd - 1) from B. So now we got Bi — the number of subsets with gcd greater than 1, but coprime with ai. The answer to problem is the sum over all Bi. The maximum number of primes in factorization of number not greater than 107 is equal to 8. We can factorize all numbers from 1 to n in linear time by algorithm for finding the smallest divisors for all intergers from 1 to n, or by sieve of Eratosthenes in O(nloglogn) time.Complexity: O(C + n2K), where , K — is the largest number of primes in factorization of ai.585F - Digits of Number PiThe problem has been prepared by Edvard.Consider all substrings of string s with length . Let's add them all to trie data structure, calculate failure links and build automata by digits. We can do that in linear time using Aho-Korasik algorithm. Now to solve the problem we should calculate dp zi, v, b1, b2, b. State of dp is described by five numbers: i — number of digits, that we already put to our number, v — in which vertex of trie we are, b1 — equals to one if the prefix that we built is equals to prefix of x, b2 — equals to one if the prefix that we built is equals to prefix of y, b — equals to one if we already have some substring with length on the prexif that we built. The value of dp is the number of ways to built prefix with the given set of properties. To update dp we should iterate over the digit that we want to add to prefix, check that we still is in segment [x, y], go from vertex v to the next vertex in automata. So the answer is the sum by all v, b1, b2 zb, v, v1, v2, 1.Complexity: O(nd2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20898",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 585\\s*B"
          },
          "content_length": 8145
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #325 - Codeforces - Code 1",
          "code": "int n = 4000;\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        cout << \"1000000 1000000 1\\n\";\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 2",
          "code": "int n = 4000;\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        cout << \"1000000 1000000 1\\n\";\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 3",
          "code": "Input\n6\n3 1 1\n1 3 2\n10 4 6\n1 1 2\n1 1 2\n1 1 14\nOutput \n2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 4",
          "code": "Input\n6\n3 1 1\n1 3 2\n10 4 6\n1 1 2\n1 1 2\n1 1 14\nOutput \n2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 5",
          "code": "string num;\n\t\twhile(ans0[i].ss > 0) {\n\t\t\tnum +=('0'+ans0[i].ss%10);\n\t\t\tans0[i].ss /=10;}\n\t\tans +=num;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 6",
          "code": "string num;\n\t\twhile(ans0[i].ss > 0) {\n\t\t\tnum +=('0'+ans0[i].ss%10);\n\t\t\tans0[i].ss /=10;}\n\t\tans +=num;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 7",
          "code": "1\n5 3\n..A..\ns.B..\n..C..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 8",
          "code": "1\n5 3\n..A..\ns.B..\n..C..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 9",
          "code": "while(true)\n    {\n        ll mi = min(x,y),ma = max(x,y);\n        if(ma%mi == 0)\n        {\n            ll times = ma/mi - 1;\n            cout<<to_string(times);\n            if(x>y)\n                cout<<\"A\";\n            else\n                cout<<\"B\";\n            return 0;\n        }\n        ll times = ma/mi;\n        cout<<to_string(times);\n        if(x>y)\n            cout<<\"A\";\n        else\n            cout<<\"B\";\n        ma = ma%mi;\n        if(x>y) {\n            x = ma;\n            y = mi;\n        }\n        else {\n            x = mi;\n            y = ma;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 10",
          "code": "while(true)\n    {\n        ll mi = min(x,y),ma = max(x,y);\n        if(ma%mi == 0)\n        {\n            ll times = ma/mi - 1;\n            cout<<to_string(times);\n            if(x>y)\n                cout<<\"A\";\n            else\n                cout<<\"B\";\n            return 0;\n        }\n        ll times = ma/mi;\n        cout<<to_string(times);\n        if(x>y)\n            cout<<\"A\";\n        else\n            cout<<\"B\";\n        ma = ma%mi;\n        if(x>y) {\n            x = ma;\n            y = mi;\n        }\n        else {\n            x = mi;\n            y = ma;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 11",
          "code": "long sum_d = 0; /* be careful, don't let it overflow */\nfor (int j = i+1; j < N; j++) {\n    if (gone[j]) continue;\n\n    p[j] -= sum_d;\n    if (p[j] < 0) {\n        gone[j] = 1;\n        sum_d += d[j];\n        if (sum_d > maxV)\n            sum_d = maxV + 1; /* XXX p == 0 won't make the kid run */\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 12",
          "code": "long sum_d = 0; /* be careful, don't let it overflow */\nfor (int j = i+1; j < N; j++) {\n    if (gone[j]) continue;\n\n    p[j] -= sum_d;\n    if (p[j] < 0) {\n        gone[j] = 1;\n        sum_d += d[j];\n        if (sum_d > maxV)\n            sum_d = maxV + 1; /* XXX p == 0 won't make the kid run */\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 13",
          "code": "5\n3 1 10\n3 1 10\n1 5 1\n1 1 5\n1 1 8\n\noutput\n2\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 14",
          "code": "5\n3 1 10\n3 1 10\n1 5 1\n1 1 5\n1 1 8\n\noutput\n2\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 1",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 2",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 3",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 4",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 10, \"t\");\n    inf.readEoln();\n\n    for (int test = 0; test < t; test++) {\n        int n = inf.readInt(2, 100, \"n\");\n        inf.readSpace();\n        int k = inf.readInt(1, 26, \"k\");\n        inf.readEoln();\n\n        int s_count = 0;\n        int s_row = -1, s_col = -1;\n\n        struct LetterInfo {\n            int row;\n            vector<int> positions;\n            LetterInfo() : row(-1) {}\n        };\n\n        LetterInfo letterInfo[26]; // for letters 'A' to 'Z'\n\n        for (int row = 0; row < 3; row++) {\n            string line = inf.readToken(\"[.sA-Z]{\" + to_string(n) + \"}\", \"row\");\n            inf.readEoln();\n\n            for (int col = 0; col < n; col++) {\n                char ch = line[col];\n                if (ch == 's') {\n                    s_count++;\n                    s_row = row;\n                    s_col = col;\n                } else if (ch >= 'A' && ch <= 'Z') {\n                    int letter_index = ch - 'A';\n                    if (letterInfo[letter_index].row == -1) {\n                        // First occurrence\n                        letterInfo[letter_index].row = row;\n                    } else {\n                        // Check if letter appears in multiple rows\n                        ensuref(letterInfo[letter_index].row == row, \"Letter %c appears in multiple rows\", ch);\n                    }\n                    letterInfo[letter_index].positions.push_back(col);\n                } else if (ch == '.') {\n                    // Do nothing\n                } else {\n                    ensuref(false, \"Invalid character '%c' in input\", ch);\n                }\n            }\n        }\n\n        // After processing all rows\n\n        ensuref(s_count == 1, \"There must be exactly one 's' in the input\");\n        ensuref(s_col == 0, \"'s' must be in the leftmost column\");\n\n        int train_count = 0;\n        for (int i = 0; i < 26; i++) {\n            if (letterInfo[i].row != -1) {\n                // Letter appeared\n                train_count++;\n\n                vector<int>& positions = letterInfo[i].positions;\n\n                ensuref(positions.size() >= 2, \"Train '%c' must consist of at least two cells\", char('A'+i));\n\n                // Check that positions are contiguous\n                sort(positions.begin(), positions.end());\n\n                for (size_t j = 1; j < positions.size(); j++) {\n                    ensuref(positions[j] == positions[j-1] + 1, \"Train '%c' must be in contiguous positions\", char('A'+i));\n                }\n            }\n        }\n\n        ensuref(train_count == k, \"Number of trains (%d) does not match k (%d)\", train_count, k);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 10, \"t\");\n    inf.readEoln();\n\n    for (int test = 0; test < t; test++) {\n        int n = inf.readInt(2, 100, \"n\");\n        inf.readSpace();\n        int k = inf.readInt(1, 26, \"k\");\n        inf.readEoln();\n\n        int s_count = 0;\n        int s_row = -1, s_col = -1;\n\n        struct LetterInfo {\n            int row;\n            vector<int> positions;\n            LetterInfo() : row(-1) {}\n        };\n\n        LetterInfo letterInfo[26]; // for letters 'A' to 'Z'\n\n        for (int row = 0; row < 3; row++) {\n            string line = inf.readToken(\"[.sA-Z]{\" + to_string(n) + \"}\", \"row\");\n            inf.readEoln();\n\n            for (int col = 0; col < n; col++) {\n                char ch = line[col];\n                if (ch == 's') {\n                    s_count++;\n                    s_row = row;\n                    s_col = col;\n                } else if (ch >= 'A' && ch <= 'Z') {\n                    int letter_index = ch - 'A';\n                    if (letterInfo[letter_index].row == -1) {\n                        // First occurrence\n                        letterInfo[letter_index].row = row;\n                    } else {\n                        // Check if letter appears in multiple rows\n                        ensuref(letterInfo[letter_index].row == row, \"Letter %c appears in multiple rows\", ch);\n                    }\n                    letterInfo[letter_index].positions.push_back(col);\n                } else if (ch == '.') {\n                    // Do nothing\n                } else {\n                    ensuref(false, \"Invalid character '%c' in input\", ch);\n                }\n            }\n        }\n\n        // After processing all rows\n\n        ensuref(s_count == 1, \"There must be exactly one 's' in the input\");\n        ensuref(s_col == 0, \"'s' must be in the leftmost column\");\n\n        int train_count = 0;\n        for (int i = 0; i < 26; i++) {\n            if (letterInfo[i].row != -1) {\n                // Letter appeared\n                train_count++;\n\n                vector<int>& positions = letterInfo[i].positions;\n\n                ensuref(positions.size() >= 2, \"Train '%c' must consist of at least two cells\", char('A'+i));\n\n                // Check that positions are contiguous\n                sort(positions.begin(), positions.end());\n\n                for (size_t j = 1; j < positions.size(); j++) {\n                    ensuref(positions[j] == positions[j-1] + 1, \"Train '%c' must be in contiguous positions\", char('A'+i));\n                }\n            }\n        }\n\n        ensuref(train_count == k, \"Number of trains (%d) does not match k (%d)\", train_count, k);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 10, \"t\");\n    inf.readEoln();\n\n    for (int test = 0; test < t; test++) {\n        int n = inf.readInt(2, 100, \"n\");\n        inf.readSpace();\n        int k = inf.readInt(1, 26, \"k\");\n        inf.readEoln();\n\n        int s_count = 0;\n        int s_row = -1, s_col = -1;\n\n        struct LetterInfo {\n            int row;\n            vector<int> positions;\n            LetterInfo() : row(-1) {}\n        };\n\n        LetterInfo letterInfo[26]; // for letters 'A' to 'Z'\n\n        for (int row = 0; row < 3; row++) {\n            string line = inf.readToken(\"[.sA-Z]{\" + to_string(n) + \"}\", \"row\");\n            inf.readEoln();\n\n            for (int col = 0; col < n; col++) {\n                char ch = line[col];\n                if (ch == 's') {\n                    s_count++;\n                    s_row = row;\n                    s_col = col;\n                } else if (ch >= 'A' && ch <= 'Z') {\n                    int letter_index = ch - 'A';\n                    if (letterInfo[letter_index].row == -1) {\n                        // First occurrence\n                        letterInfo[letter_index].row = row;\n                    } else {\n                        // Check if letter appears in multiple rows\n                        ensuref(letterInfo[letter_index].row == row, \"Letter %c appears in multiple rows\", ch);\n                    }\n                    letterInfo[letter_index].positions.push_back(col);\n                } else if (ch == '.') {\n                    // Do nothing\n                } else {\n                    ensuref(false, \"Invalid character '%c' in input\", ch);\n                }\n            }\n        }\n\n        // After processing all rows\n\n        ensuref(s_count == 1, \"There must be exactly one 's' in the input\");\n        ensuref(s_col == 0, \"'s' must be in the leftmost column\");\n\n        int train_count = 0;\n        for (int i = 0; i < 26; i++) {\n            if (letterInfo[i].row != -1) {\n                // Letter appeared\n                train_count++;\n\n                vector<int>& positions = letterInfo[i].positions;\n\n                ensuref(positions.size() >= 2, \"Train '%c' must consist of at least two cells\", char('A'+i));\n\n                // Check that positions are contiguous\n                sort(positions.begin(), positions.end());\n\n                for (size_t j = 1; j < positions.size(); j++) {\n                    ensuref(positions[j] == positions[j-1] + 1, \"Train '%c' must be in contiguous positions\", char('A'+i));\n                }\n            }\n        }\n\n        ensuref(train_count == k, \"Number of trains (%d) does not match k (%d)\", train_count, k);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int t = opt<int>(\"t\", 1);\n    int n_max = opt<int>(\"n\");\n    int k_max = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", t);\n    \n    for (int tt = 0; tt < t; ++tt) {\n        // For each test case\n        int n = n_max;\n        int k = k_max;\n        if (type == \"random\") {\n            n = rnd.next(2,n_max);\n            k = rnd.next(1,min(26,n));\n        }\n        else if (type == \"max\") {\n            n = n_max;\n            k = min(k_max, 26);\n        }\n        else if (type == \"easy\") {\n            n = min(n_max, 10);\n            k = min(k_max, 5);\n        } else if (type == \"blocked\") {\n            n = max(n_max, 10); // Ensure n is at least 10\n            k = min(k_max, 26);\n        }\n        else if (type == \"tricky\") {\n            n = n_max;\n            k = min(k_max, 26);\n        }\n\n        // Now generate the grid\n        char grid[3][n];\n\n        // Initialize grid with '.'\n        for (int i=0; i<3; ++i)\n            for (int j=0; j<n; ++j)\n                grid[i][j] = '.';\n\n        // Place 's' in leftmost column, in a specific row based on type\n        int s_row;\n        if (type == \"blocked\") {\n            // For blocked cases, place 's' in the middle row\n            s_row = 1;\n            grid[s_row][0] = 's';\n        } else if (type == \"tricky\") {\n            s_row = 0;\n            grid[s_row][0] = 's';\n        } else if (type == \"bottom\") {\n            s_row = 2;\n            grid[s_row][0] = 's';\n        } else {\n            s_row = rnd.next(0,2);\n            grid[s_row][0] = 's';\n        }\n\n        // For each row, maintain an occupied array\n        bool occupied[3][n];\n        memset(occupied, 0, sizeof(occupied));\n        // Mark 's' position as occupied\n        occupied[s_row][0] = true;\n\n        // Prepare list of letters for trains\n        vector<char> letters;\n        for (char c = 'A'; c <= 'Z'; ++c)\n            letters.push_back(c);\n        shuffle(letters.begin(), letters.end());\n\n        // Prepare the trains\n        int trains_added = 0;\n\n        for (int train = 0; train < k && trains_added < 26; ++train) {\n            char train_char = letters[train];\n            bool placed = false;\n            int max_attempts = 100;\n            while (!placed && max_attempts--) {\n                int row;\n                if (type == \"blocked\") {\n                    // Try to block 's' path\n                    // Place train in s_row or adjacent rows\n                    row = s_row;\n                } else {\n                    row = rnd.next(0,2);\n                }\n\n                // Decide length\n                int len = rnd.next(2, n);\n                // Decide possible start columns\n                vector<int> possible_starts;\n                for (int start=0; start<=n-len; ++start) {\n                    bool conflict = false;\n                    for (int col=start; col<start+len; ++col) {\n                        if (occupied[row][col]) {\n                            conflict = true;\n                            break;\n                        }\n                    }\n                    if (!conflict) {\n                        possible_starts.push_back(start);\n                    }\n                }\n                if (possible_starts.empty()) continue;\n                int start_col = rnd.any(possible_starts);\n                // Place the train\n                for (int col=start_col; col<start_col+len; ++col) {\n                    grid[row][col] = train_char;\n                    occupied[row][col] = true;\n                }\n                placed = true;\n                ++trains_added;\n            }\n        }\n\n        // Output n and k (number of trains actually placed)\n        printf(\"%d %d\\n\", n, trains_added);\n\n        // Output the grid\n        for (int i=0; i<3; ++i) {\n            for (int j=0; j<n; ++j) {\n                printf(\"%c\", grid[i][j]);\n            }\n            printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int t = opt<int>(\"t\", 1);\n    int n_max = opt<int>(\"n\");\n    int k_max = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", t);\n    \n    for (int tt = 0; tt < t; ++tt) {\n        // For each test case\n        int n = n_max;\n        int k = k_max;\n        if (type == \"random\") {\n            n = rnd.next(2,n_max);\n            k = rnd.next(1,min(26,n));\n        }\n        else if (type == \"max\") {\n            n = n_max;\n            k = min(k_max, 26);\n        }\n        else if (type == \"easy\") {\n            n = min(n_max, 10);\n            k = min(k_max, 5);\n        } else if (type == \"blocked\") {\n            n = max(n_max, 10); // Ensure n is at least 10\n            k = min(k_max, 26);\n        }\n        else if (type == \"tricky\") {\n            n = n_max;\n            k = min(k_max, 26);\n        }\n\n        // Now generate the grid\n        char grid[3][n];\n\n        // Initialize grid with '.'\n        for (int i=0; i<3; ++i)\n            for (int j=0; j<n; ++j)\n                grid[i][j] = '.';\n\n        // Place 's' in leftmost column, in a specific row based on type\n        int s_row;\n        if (type == \"blocked\") {\n            // For blocked cases, place 's' in the middle row\n            s_row = 1;\n            grid[s_row][0] = 's';\n        } else if (type == \"tricky\") {\n            s_row = 0;\n            grid[s_row][0] = 's';\n        } else if (type == \"bottom\") {\n            s_row = 2;\n            grid[s_row][0] = 's';\n        } else {\n            s_row = rnd.next(0,2);\n            grid[s_row][0] = 's';\n        }\n\n        // For each row, maintain an occupied array\n        bool occupied[3][n];\n        memset(occupied, 0, sizeof(occupied));\n        // Mark 's' position as occupied\n        occupied[s_row][0] = true;\n\n        // Prepare list of letters for trains\n        vector<char> letters;\n        for (char c = 'A'; c <= 'Z'; ++c)\n            letters.push_back(c);\n        shuffle(letters.begin(), letters.end());\n\n        // Prepare the trains\n        int trains_added = 0;\n\n        for (int train = 0; train < k && trains_added < 26; ++train) {\n            char train_char = letters[train];\n            bool placed = false;\n            int max_attempts = 100;\n            while (!placed && max_attempts--) {\n                int row;\n                if (type == \"blocked\") {\n                    // Try to block 's' path\n                    // Place train in s_row or adjacent rows\n                    row = s_row;\n                } else {\n                    row = rnd.next(0,2);\n                }\n\n                // Decide length\n                int len = rnd.next(2, n);\n                // Decide possible start columns\n                vector<int> possible_starts;\n                for (int start=0; start<=n-len; ++start) {\n                    bool conflict = false;\n                    for (int col=start; col<start+len; ++col) {\n                        if (occupied[row][col]) {\n                            conflict = true;\n                            break;\n                        }\n                    }\n                    if (!conflict) {\n                        possible_starts.push_back(start);\n                    }\n                }\n                if (possible_starts.empty()) continue;\n                int start_col = rnd.any(possible_starts);\n                // Place the train\n                for (int col=start_col; col<start_col+len; ++col) {\n                    grid[row][col] = train_char;\n                    occupied[row][col] = true;\n                }\n                placed = true;\n                ++trains_added;\n            }\n        }\n\n        // Output n and k (number of trains actually placed)\n        printf(\"%d %d\\n\", n, trains_added);\n\n        // Output the grid\n        for (int i=0; i<3; ++i) {\n            for (int j=0; j<n; ++j) {\n                printf(\"%c\", grid[i][j]);\n            }\n            printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Generate test cases with t=1 and random data\n./gen -t 1 -n 10 -k 2 -type random\n./gen -t 1 -n 20 -k 5 -type random\n./gen -t 1 -n 50 -k 10 -type random\n./gen -t 1 -n 100 -k 15 -type random\n\n# Generate test cases with maximum values\n./gen -t 1 -n 100 -k 26 -type max\n\n# Generate test cases with t=5 and random data\n./gen -t 5 -n 20 -k 5 -type random\n./gen -t 5 -n 100 -k 10 -type random\n\n# Generate test cases with t=10 and random data\n./gen -t 10 -n 50 -k 8 -type random\n./gen -t 10 -n 100 -k 20 -type max\n\n# Generate easy test cases\n./gen -t 1 -n 5 -k 2 -type easy\n./gen -t 1 -n 5 -k 3 -type easy\n\n# Generate blocked test cases\n./gen -t 1 -n 10 -k 3 -type blocked\n./gen -t 1 -n 20 -k 5 -type blocked\n\n# Generate tricky test cases\n./gen -t 1 -n 100 -k 10 -type tricky\n./gen -t 1 -n 100 -k 26 -type tricky\n\n# Generate edge case with minimum n and k\n./gen -t 1 -n 2 -k 1 -type random\n\n# Generate edge case with maximum n and minimum k\n./gen -t 1 -n 100 -k 1 -type random\n\n# Generate test cases for hacks (t=1)\n./gen -t 1 -n 10 -k 2 -type random\n\n# Generate multiple test cases with different types\n./gen -t 5 -n 50 -k 10 -type random\n./gen -t 5 -n 50 -k 10 -type blocked\n\n# Generate test cases to cover contestant's errors\n./gen -t 1 -n 10 -k 3 -type tricky\n./gen -t 1 -n 20 -k 4 -type tricky\n\n# Generate test cases with Philip starting in top row\n./gen -t 1 -n 10 -k 3 -type random\n\n# Generate test cases with Philip starting in bottom row\n./gen -t 1 -n 10 -k 3 -type bottom\n\n# Generate test case with overlapping trains (should not happen)\n./gen -t 1 -n 10 -k 20 -type random\n\n# Generate test cases with maximum trains possible\n./gen -t 1 -n 100 -k 26 -type max\n\n# Generate test cases to check movement and collision\n./gen -t 1 -n 15 -k 5 -type blocked\n./gen -t 1 -n 15 -k 5 -type tricky\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:29.352729",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "585/C",
      "title": "C. Алиса, Боб, Апельсины и Яблоки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных находится два целых числа x, y (1 ≤ x, y ≤ 1018, xy > 1) — количество апельсинов и яблок, которые изначально были в мешке.",
      "output_spec": "Выходные данныеВыведите любую последовательность карточек, удовлетворяющую условиям задачи в виде строки из символов 'A' и 'B' в сжатом виде. Это значит, что вам нужно заменить отрезки одинаковых подряд идущих символов на количество повторений символа и сам символ. Например, строку AAABAABBB нужно заменить на строку 3A1B2A3B, но нельзя заменить на 2A1A1B2A3B или на 3AB2A3B. Смотрите примеры для уточнения формата вывода. выведенная вами строка должна состоять из не более, чем 106 символов. Гарантируется, что если ответ существует, то существует его представление в сжатом виде, состоящее из не более чем 106 символов. Если возможных ответов несколько, разрешается вывести любой из них.Если последовательности карточек, удовлетворяющей условию задачи, не существует, выведите одно слово Impossible.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 4Выходные данныеСкопировать3BВходные данныеСкопировать2 2Выходные данныеСкопироватьImpossibleВходные данныеСкопировать3 2Выходные данныеСкопировать1A1B",
      "description": "C. Алиса, Боб, Апельсины и Яблоки\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных находится два целых числа x, y (1 ≤ x, y ≤ 1018, xy > 1) — количество апельсинов и яблок, которые изначально были в мешке.\n\nВходные данные\n\nВыходные данныеВыведите любую последовательность карточек, удовлетворяющую условиям задачи в виде строки из символов 'A' и 'B' в сжатом виде. Это значит, что вам нужно заменить отрезки одинаковых подряд идущих символов на количество повторений символа и сам символ. Например, строку AAABAABBB нужно заменить на строку 3A1B2A3B, но нельзя заменить на 2A1A1B2A3B или на 3AB2A3B. Смотрите примеры для уточнения формата вывода. выведенная вами строка должна состоять из не более, чем 106 символов. Гарантируется, что если ответ существует, то существует его представление в сжатом виде, состоящее из не более чем 106 символов. Если возможных ответов несколько, разрешается вывести любой из них.Если последовательности карточек, удовлетворяющей условию задачи, не существует, выведите одно слово Impossible.\n\nВыходные данные\n\nВходные данныеСкопировать1 4Выходные данныеСкопировать3BВходные данныеСкопировать2 2Выходные данныеСкопироватьImpossibleВходные данныеСкопировать3 2Выходные данныеСкопировать1A1B\n\nВходные данныеСкопировать1 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3B\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьImpossible\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1A1B\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере, если в ряду находились три карточки с буквой 'B', то Бобу пришлось бы три раза отдать Алисе по одному яблоку. Таким образом, в итоге у Алисы был бы один апельсин и три яблока, а у Боба одно яблоко. Значит в мешке изначально был один апельсин и четыре яблока.Во втором примере, ответа не существует, так как одной карточки было бы недостаточно для завершения игры, если же карточек было хотя бы две, то это значило бы, что в мешке изначально было хотя бы три яблока или апельсина.В третьем примере, на карточках были записаны буквы 'AB', поэтому после убирания первой карточки у Боба был бы один апельсин и одно яблоко, а после убирания второй карточки у Алисы было бы два апельсина и одно яблоко. Таким образом, изначально в мешке было три апельсина и два яблока.",
      "solutions": [
        {
          "title": "Codeforces Round #325 - Codeforces",
          "content": "Привет, Codeforces!12 октября 2015 года в 12:00 MSK состоится очередной раунд Codeforces #325 для участников из первого и второго дивизионов. Обратите внимание на необычное время начала раунда!Этот раунд проводится по задачам Регионального этапа всероссийской командной олимпиады школьников по программированию 2015, который пройдет в то же время в городе Саратове. Пожелаем школьным командам удачи на соревновании!Набор задач школьной олимпиады немного отличается от задач, которые будут предложены вам на раунде. В том числе в комплекте задач на школьную присутствуют задачи, которых нет в раунде и наоборот. Поэтому не стоит пугаться того, что мы предложили школьникам слишком сложные задачи :-)Процесс подготовки задач был интересным: мы много раз переделывали условия, переписывали решения, добавляли тесты, изменяли ограничения, даже успели поменять полностью готовую задачу (пришлось останавливать конвейер типографии, который уже печатал условия :-)). Поблагодарим всех кто готовил, помогал готовить задачи, вычитывал условия, писал перекрестные решения: Адилбек adedalic Далабаев, Роман Roms Глазов, Владимир vovuh Петров, Олег Oleg_Smirnov Смирнов, Алексей Perforator Рипинен, Максим Neon Мещеряков, Илья IlyaLos Лось, Виталий gridnevvvit Гриднев, Данил danilka.pro Сагунов, Александр fcspartakm Фролов, Павел HolkinPV Холкин, Игорь Igor_Kudryashov Кудряшов, Елена elena Рогачева, Дмитрий Nerevar Матов, Виталий kuviman Кудасов. Председателем жюри олимпиады является Михаил MikeMirzayanov Мирзаянов (также автором некоторых задач из комплекта). Я же (Эдвард Edvard Давтян) готовил некоторые задачи и координировал работу авторов. Вот такая большая команда авторов получилась (надеюсь я никого не забыл)!Также, конечно, поблагодарим Максима Ахмедова (Zlobober), Того-Чьё-Имя-Пока-Нельзя-Называть (если не ошибаюсь он/она прямо сейчас пишет дополнительные решения по задачам раунда) за помощь в подготовке задач, Марию Белову (Delinur) за перевод условий на английский язык и снова Михаила Мирзаянова (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Участникам будет предложено шесть задач и два часа на их решение. Разбалловка будет объявлена незадолго до начала раунда. Всем высокого рейтинга! Good luck and have fun!P.S.: Также хочется пожелать удачи участникам четвертьфинала чемпионата мира по программированию южного региона, который пройдет в эту среду.По техническим причинам раунд перенесен на 10 минутUPD: По задаче Subway roller в наборе тестов присутствовали тесты с поездами длины 1. В данный момент проводится обсуждение того, насколько сильно это повлияло на результаты раунда. Приносим извинения всем участникам, которых затронула эта проблема. В скором времени будет сделано объявление о принятом решении.UPD2: При подготовке задачи Subway Roller у одного из авторов было ошибочное понимание условия. Из-за этого валидатор допускал существование поездов длины 1, а так же присутствовали тесты с поездами длины 1. Жюри приняло решение, что если участник посылал в течении контеста верное решение, то оно должно быть ему зачтено. Для этого у каждого участника было выбрано первое отправленное решение, проходящее итоговый тестсет (если таковое решение имелось), а остальные решения были пропущены. Так же баллы за все взломы во время соревнования остались без изменения, включая ситуацию, когда взломанное решение считается правильным на новом тестсете (в этом случае взломщик получает свой балл, а решение участника считается полным). Контест будет признан рейтинговым, однако если вы считаете, что данная проблема сильно повлияла на ваш результат, напишите мне в течении 24 часов и мы рассмотрим возможность сделать его нерейтинговым лично для вас.UPD3: Разбор задач",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20889",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3705
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces",
          "content": "586A - Расписание АлёныЗадачу подготовил adedalic.В этой задаче сначала нужно было выкинуть все нули на префиксе и суффиксе строки, после чего ответ был равен количеству единиц плюс количество нулей с двух сторон от которых стоят единицы. Асимптотическая сложность решения: O(n).586B - Лаврентий и магазинЗадачу подготовил Oleg_Smirnov.Назовем путь i-м (0 ≤ i ≤ n - 1), если мы, выходя из дома, сначала i раз идем налево, потом переходим проспект и снова n - 1 - i раз идем налево. Введем обозначение di — время, которое нам придется ждать на светофорах на i-м пути. Если рассмотреть путь из магазина домой с конца, то получится пути из дома в магазиг, поэтому искомый путь есть два разных пути из дома в магазин. Значит ответом на задачу является сумма наименьшего и второго по величине значения di. Значение di легко пересчитывается из значения di - 1, таким образом все di можно посчитать за один проход.Асимптотическая сложность решения: O(n).585A - Стоматолог ГеннадийЗадачу подготовил Neon.Заведем очередь в которой, будут находится дети. На каждой итерации решения пройдем по всем детям, если есть ребенок с отрицательной решимостью удалим его из очереди, а из решимостей детей с большими номерами вычтем di. Если все дети в очереди имеют решимость не меньше нуля, возьмем первого ребенка из очереди, а от решимостей остальных вычтем арифметическую прогрессию, как это описывается в условии.Асимптотическая сложность решения: O(n2).585B - Филипп и поездаЗадачу подготовил IlyaLos.В задаче требовалось просто промоделировать игру. Это можно сделать с помощью обхода в глубину, ширину или динамического программирования. Состоянием является пара чисел x, y — позиция Филиппа в туннеле, а значением или в зависимости от того, можем ли мы попасть из стартовой позиции в x, y. Положения поездов в каждый момент времени определяются однозначно.Асимптотическая сложность решения: O(n).585C - Алиса, Боб, Апельсины и ЯблокиЗадачу подготовил Edvard.Поймем для начала, что означает процесс описанный в условии. Если нарисовать дерево переходов по буквам и , то получится дерево Штерна-Броко. Пусть апельсины это значения знаменателя дроби, а яблоки — числителя. На каждом шагу у нас есть две дроби (изначально ) и мы заменяем либо первую дробь на их медианту, либо вторую. Таким образом, первая дробь есть первый предок влево от медианты, а вторая — первый предок вправо. Таким образом, искомый процесс это просто процесс поиска дроби в дереве Штерна-Броко, который завершается тем, что текущая медианта совпадает с дробью, которую мы ищем (момент окончания игры, описанный в условии). Значит, числа x, y заданные в условии это просто дробь, которую мы ищем. Отсюда следует, что ответа не существует, если x не взаимнопросто с y (поскольку таким дробей нет в дереве Штерна-Броко). Пусть теперь мы хотим найти дробь в дереве. Понятно, что если x > y, то мы сначала перейдем в правую ветку. Более того мы можем считать, что теперь ищем дробь и никуда не спускались. Если же x < y, то нам нужно спуситься в левую ветку и можно считать, что мы ищем дробь и пока никуда не спускались. Эти рассуждения легко формализовать, чтобы получить строгое доказательство. Таким образом, решение задачи сводится к выполнению алгоритма Евклида для пары чисел x, y. Как известно время работы алгоритма Евклида O(logn) (дольше всего алгоритм Евклида работает на двух последовательных числах Фибоначчи), значит длина ответа тоже растет как логарифм.Асимптотическая сложность решения: O(logn).585D - Lizard Era: BeginningЗадачу подготовил danilka.pro.Для решения этой задачи воспользуемся приемом . А именно переберем для первых (первая половина) заданий с какими спутницами главный герой будет путешествовать. Пусть при этом симпатия первой спутницы оказалась равна a, второй — b, а третьей c. Пусть существует способ выбрать спутниц для последующих (вторая половина) заданий так и пусть симпатии при этом будут равны a', b', c'. Тогда, чтобы по всем заданиям суммы симпатий были одинаковы необходимо и достаточно, чтобы a - b = b' - a' и b - c = c' - b'. Теперь для решения задачи достаточно перебрать первую половину и сохранить в некоторой структуре данных тройки чисел a - b, b - c, a (третье число нужно для максимизации ответа в случае равенства). Далее нужно перебрать вторую половину и найти в структуре данных значения b' - a', c' - b', m, где m — максимальное третье значение которое есть в структуре данных. В качестве структуры данных можно использовать map < pair < int, int > , int >  в языке C++, первые два числа это значение a - b, b - c, а третье — максимальное a соответствующее первым двум. Также можно все тройки сложить в один большой массив, отсортировать его и бинарным поиском находить необходимые значения.Асимптотическая сложность решения: , где logC — константа, появляющаяся вместе со структурой данных.585E - Подарок для филателиста ВиталикаЗадачу подготовил gridnevvvit.Пусть мы хотим посчитать количество подмножеств с НОД равным 1 — число A. Посчитаем это количество с помощью формулы включений-исключений: сначала скажем, что все подмножества нам подходят. Таких подмножеств 2n. Теперь вычтем подмножества с НОД кратным 2. Количество таких множеств 2cnt2 - 1, где cnti — количество чисел, делящихся на i. Далее вычитаем 2cnt3 - 1. Подмножества с НОД кратным 4 мы учли вместе с двойкой. Далее вычитаем 2cnt5 - 1. Теперь заметим, что подмножества с НОД кратным 6 мы вычли уже дважды: сначала с двойкой, затем с тройкой, поэтому давайте прибавим количество таких подмножеств 2cnt6 - 1. Продолжая этот процесс получаем, что для числа d, к ответу нужно прибавить величину μ(d)(2cntd - 1), где μ(d) равно 0, если d делится на полный квадрат, 1, если количество простых в факторизации d четно и  - 1 в противном случае. Значит числа, делящиеся на полный квадрат мы можем не суммировать, поскольку они входят с коэффициентом 0. Для подсчета значений cnti достаточно факторизовать все числа и для каждого за 2k перебрать делитель, со значением μ(d) ≠ 0. Теперь легко понять, что количество подмножеств с НОД большим 1 равно B = 2n - A. Теперь для решения задачи давайте переберем марку, которую купит Виталик ai. Пересчитаем число B так, как если бы числа ai не было в множестве. Для этого нужно просто вычесть те слагаемые на которые повлияло число ai. Это можно сделать за 2k, где k — количество простых в факторизации числа ai (снова нужно перебрать делители ai со значением μ(d) ≠ 0). Теперь поймем какие подмножества дадут НОД равный 1 вместе с выбранной маркой. Понятно это те подмножества НОД которых больше 1, но при этом не делится ни на один делитель ai. Для этого снова воспользуемся формулой включений-исключений. Для каждого делителя d числа ai вычтем из B значение μ(d)(2cntd - 1). Таким образом, мы получим количество способов Bi выбрать подмножество c НОД большим 1, но при это взаимнопростым с ai. Ответом на задачу является сумма всех Bi. Наибольшее количество простых в факторизации числа не превосходящего 107 равно 8. Факторизацию чисел можно выполнить с помощью линейного алгоритма поиска минимального делителя чисел от 1 до n, либо с помощью решета Эратосфена за время O(nloglogn).Асимптотическая сложность решения: O(C + n2K), где , а K — наибольшее количество простых в факторизации чисел ai.585F - Знаки числа ПиЗадачу подготовил Edvard.Расмотрим все подстроки строки s длины . Сложим все эти строки в бор, посчитаем суффиксные ссылки и построим автомат по цифрам. Это можно сделать за линейное время с помощью алгоритма Ахо-Корасик. Теперь для решения задачи посчитаем динамику zi, v, b1, b2, b в котором состояние описывается пятеркой чисел: i — количество цифр которые мы уже поставили в искомом числе, которое встречается , v — в какой вершине бора мы находимся, b1 — равен ли префикс числа, которое мы набираем префиксу числа x, b2 — равен ли префикс числа, которое мы набираем префиксу числа y, b — находится ли некоторая подстрока длина на уже набранном префиксе в боре (значения b1, b2, b — равны либо 0, либо 1). Значением динамики является количество способов набрать префикс с заданным набором свойств. Для того, чтобы сделать переход нужно перебрать цифру, проверить что мы не вышли за границы отрезка [x, y], перейти от вершины v к следующей вершине по автомату и заданной цифре. Ответом является сумма по всем v, b1, b2 zb, v, v1, v2, 1.Асимптотическая сложность решения: O(nd2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20898",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 585\\s*C"
          },
          "content_length": 8320
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #325 - Codeforces - Code 1",
          "code": "int n = 4000;\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        cout << \"1000000 1000000 1\\n\";\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 2",
          "code": "int n = 4000;\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        cout << \"1000000 1000000 1\\n\";\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 3",
          "code": "Input\n6\n3 1 1\n1 3 2\n10 4 6\n1 1 2\n1 1 2\n1 1 14\nOutput \n2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 4",
          "code": "Input\n6\n3 1 1\n1 3 2\n10 4 6\n1 1 2\n1 1 2\n1 1 14\nOutput \n2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 5",
          "code": "string num;\n\t\twhile(ans0[i].ss > 0) {\n\t\t\tnum +=('0'+ans0[i].ss%10);\n\t\t\tans0[i].ss /=10;}\n\t\tans +=num;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 6",
          "code": "string num;\n\t\twhile(ans0[i].ss > 0) {\n\t\t\tnum +=('0'+ans0[i].ss%10);\n\t\t\tans0[i].ss /=10;}\n\t\tans +=num;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 7",
          "code": "1\n5 3\n..A..\ns.B..\n..C..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 8",
          "code": "1\n5 3\n..A..\ns.B..\n..C..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 9",
          "code": "Каждый поезд представляет собой две или более клетки, находящиеся непосредственно друг за другом в некоторой строке поля",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 10",
          "code": "Каждый поезд представляет собой две или более клетки, находящиеся непосредственно друг за другом в некоторой строке поля",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 11",
          "code": "while(true)\n    {\n        ll mi = min(x,y),ma = max(x,y);\n        if(ma%mi == 0)\n        {\n            ll times = ma/mi - 1;\n            cout<<to_string(times);\n            if(x>y)\n                cout<<\"A\";\n            else\n                cout<<\"B\";\n            return 0;\n        }\n        ll times = ma/mi;\n        cout<<to_string(times);\n        if(x>y)\n            cout<<\"A\";\n        else\n            cout<<\"B\";\n        ma = ma%mi;\n        if(x>y) {\n            x = ma;\n            y = mi;\n        }\n        else {\n            x = mi;\n            y = ma;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 12",
          "code": "while(true)\n    {\n        ll mi = min(x,y),ma = max(x,y);\n        if(ma%mi == 0)\n        {\n            ll times = ma/mi - 1;\n            cout<<to_string(times);\n            if(x>y)\n                cout<<\"A\";\n            else\n                cout<<\"B\";\n            return 0;\n        }\n        ll times = ma/mi;\n        cout<<to_string(times);\n        if(x>y)\n            cout<<\"A\";\n        else\n            cout<<\"B\";\n        ma = ma%mi;\n        if(x>y) {\n            x = ma;\n            y = mi;\n        }\n        else {\n            x = mi;\n            y = ma;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 13",
          "code": "long sum_d = 0; /* be careful, don't let it overflow */\nfor (int j = i+1; j < N; j++) {\n    if (gone[j]) continue;\n\n    p[j] -= sum_d;\n    if (p[j] < 0) {\n        gone[j] = 1;\n        sum_d += d[j];\n        if (sum_d > maxV)\n            sum_d = maxV + 1; /* XXX p == 0 won't make the kid run */\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 14",
          "code": "long sum_d = 0; /* be careful, don't let it overflow */\nfor (int j = i+1; j < N; j++) {\n    if (gone[j]) continue;\n\n    p[j] -= sum_d;\n    if (p[j] < 0) {\n        gone[j] = 1;\n        sum_d += d[j];\n        if (sum_d > maxV)\n            sum_d = maxV + 1; /* XXX p == 0 won't make the kid run */\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 15",
          "code": "5\n3 1 10\n3 1 10\n1 5 1\n1 1 5\n1 1 8\n\noutput\n2\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 16",
          "code": "5\n3 1 10\n3 1 10\n1 5 1\n1 1 5\n1 1 8\n\noutput\n2\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 1",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 2",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 3",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 4",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long x = inf.readLong(1LL, 1e18, \"x\");\n    inf.readSpace();\n    long long y = inf.readLong(1LL, 1e18, \"y\");\n    inf.readEoln();\n    ensuref(!(x == 1 && y ==1), \"x*y must be greater than 1, but x=%lld and y=%lld\", x, y);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long x = inf.readLong(1LL, 1e18, \"x\");\n    inf.readSpace();\n    long long y = inf.readLong(1LL, 1e18, \"y\");\n    inf.readEoln();\n    ensuref(!(x == 1 && y ==1), \"x*y must be greater than 1, but x=%lld and y=%lld\", x, y);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long x = inf.readLong(1LL, 1e18, \"x\");\n    inf.readSpace();\n    long long y = inf.readLong(1LL, 1e18, \"y\");\n    inf.readEoln();\n    ensuref(!(x == 1 && y ==1), \"x*y must be greater than 1, but x=%lld and y=%lld\", x, y);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  We must check that the participant's output is either \"Impossible\"\n  (only acceptable if the jury's solution is also \"Impossible\"), or\n  it is a valid compressed sequence of 'A' and 'B' moves that exactly\n  uses up x oranges and y apples from the bag. The rules are:\n\n  1) Initially, the bag has x oranges and y apples. \n  2) Alice starts with (1 orange, 0 apples), Bob with (0 oranges, 1 apple).\n     That effectively means we reduce the bag to (x-1, y-1) at the start.\n  3) Each move is either 'A' or 'B':\n     - If it is 'A': \n         We check if the bag has at least (Alice's oranges, Alice's apples).\n         If not, invalid. Otherwise:\n            bag -= (aOrange, aApple)\n            Bob gains (aOrange, aApple)\n         [Alice's own fruit doesn't change]\n     - If it is 'B':\n         We check if the bag has at least (bOrange, bApple).\n         If not, invalid. Otherwise:\n            bag -= (bOrange, bApple)\n            Alice gains (bOrange, bApple)\n         [Bob's own fruit doesn't change]\n  4) In the end, the bag must be exactly (0,0).\n  5) The compressed format is blocks of the form: <count><letter>, \n     where <count> is a positive integer, and <letter> is 'A' or 'B'. \n     All blocks are concatenated without spaces (e.g. 3A2B10A, etc.).\n  6) The entire output string must not exceed 10^6 characters.\n  7) If the jury's answer is \"Impossible\", that means there should be no valid solution;\n     a participant solution that claims a valid sequence must cause _fail, \n     since it contradicts the jury's official solution.\n  8) If the jury's answer is a valid sequence, then any valid sequence by the participant is accepted,\n     \"Impossible\" by the participant would be wrong.\n*/\n\nstatic const long long MAX_LEN = 1000000; // max length of the compressed string\n\n// We'll parse and check one answer (either jury's or participant's).\n// If it is invalid, we call stream.quitf(...) with an appropriate verdict.\n// If it is \"Impossible\", we return true in impossibleFlag, otherwise false.\n// If it is a valid sequence that consumes the entire bag, we return false in impossibleFlag.\nbool readAndCheckAnswer(InStream &stream, long long x, long long y, bool isJury)\n{\n    // isJury == true  => if invalid, stream.quitf(_fail, ...)\n    // isJury == false => if invalid, stream.quitf(_wa, ...)\n\n    // convenience macro for quitting with the correct verdict\n    auto quitBad = [&](const char* format, auto... args) {\n        if (isJury) stream.quitf(_fail, format, args...);\n        else        stream.quitf(_wa,   format, args...);\n    };\n\n    // read the entire solution line\n    string ansLine = stream.readLine();\n\n    // Trim possible extra spaces (though typically not expected).\n    // But if the line is exactly \"Impossible\", that's valid in full.\n    // We'll do a simple check:\n    if(ansLine.size() <= 10) {\n        // check if it is exactly \"Impossible\" (case-sensitive as per statement)\n        if(ansLine == \"Impossible\") {\n            // We do not verify correctness of \"Impossible\" here,\n            // the calling logic will compare with the jury's solution\n            return true; // means answer says \"Impossible\"\n        }\n    }\n\n    // If not \"Impossible\", we must parse a sequence of <count><letter> blocks.\n    // Also verify the total length does not exceed 10^6 characters.\n    if((long long)ansLine.size() > MAX_LEN) {\n        quitBad(\"Output exceeds %lld characters\", MAX_LEN);\n    }\n\n    // We'll simulate the game:\n    // bag = (X, Y), but note we already remove (1 orange) for Alice and (1 apple) for Bob.\n    // So effectively:\n    long long bagOrange = x - 1;\n    long long bagApple  = y - 1;\n\n    // If bagOrange < 0 or bagApple < 0 immediately, it's invalid.\n    if(bagOrange < 0 || bagApple < 0) {\n        quitBad(\"Not enough fruit in the bag even for initial distribution (x=%lld, y=%lld)\", x, y);\n    }\n\n    // Alice has (1, 0) initially, Bob has (0, 1).\n    long long aOrange = 1, aApple = 0;\n    long long bOrange = 0, bApple = 1;\n\n    // parse ansLine in form  { <count><letter> }+\n    // We'll do a simple pointer approach:\n    // Each <count> is a positive integer, each <letter> is either 'A' or 'B'.\n    // We keep reading until we exhaust ansLine.\n\n    int pos = 0, n = (int)ansLine.size();\n    while(pos < n) {\n        // parse integer (count)\n        if(!isdigit(ansLine[pos])) {\n            quitBad(\"Expected digit at position %d of the compressed string\", pos+1);\n        }\n        long long count = 0;\n        // read all digits\n        while(pos < n && isdigit(ansLine[pos])) {\n            int d = (ansLine[pos] - '0');\n            // safely accumulate in 64-bit\n            // we check for overflow bigger than 2e18, but that's well beyond problem range\n            if(count > (LLONG_MAX - d) / 10) {\n                quitBad(\"Count number too large at position %d\", pos+1);\n            }\n            count = count*10 + d;\n            pos++;\n        }\n        if(count <= 0) {\n            quitBad(\"Count must be a positive integer\");\n        }\n        if(pos >= n) {\n            quitBad(\"Expected letter 'A' or 'B' after count, but reached end of line\");\n        }\n        // parse letter\n        char c = ansLine[pos++];\n        if(c != 'A' && c != 'B') {\n            quitBad(\"Expected letter 'A' or 'B' after count, found '%c'\", c);\n        }\n\n        // apply 'count' times the move, but in aggregated form\n        if(c == 'A') {\n            // We need bagOrange >= count * aOrange, bagApple >= count * aApple\n            // Then Bob gains (count*aOrange, count*aApple).\n            if(aOrange > 0) {\n                long long needOrange = count * aOrange;\n                if(needOrange > bagOrange) {\n                    quitBad(\"Not enough oranges in the bag for repeated 'A' moves\");\n                }\n                bagOrange -= needOrange;\n                bOrange += needOrange;\n            }\n            if(aApple > 0) {\n                long long needApple = count * aApple;\n                if(needApple > bagApple) {\n                    quitBad(\"Not enough apples in the bag for repeated 'A' moves\");\n                }\n                bagApple -= needApple;\n                bApple += needApple;\n            }\n            // aOrange, aApple remain unchanged\n        } else {\n            // c == 'B'\n            // We need bagOrange >= count * bOrange, bagApple >= count * bApple\n            // Then Alice gains (count*bOrange, count*bApple).\n            if(bOrange > 0) {\n                long long needOrange = count * bOrange;\n                if(needOrange > bagOrange) {\n                    quitBad(\"Not enough oranges in the bag for repeated 'B' moves\");\n                }\n                bagOrange -= needOrange;\n                aOrange += needOrange;\n            }\n            if(bApple > 0) {\n                long long needApple = count * bApple;\n                if(needApple > bagApple) {\n                    quitBad(\"Not enough apples in the bag for repeated 'B' moves\");\n                }\n                bagApple -= needApple;\n                aApple += needApple;\n            }\n            // bOrange, bApple remain unchanged\n        }\n    }\n\n    // after reading the entire compressed sequence, check if bag is empty\n    if(bagOrange != 0 || bagApple != 0) {\n        quitBad(\"After applying all moves, the bag is not fully used up (remaining oranges=%lld, apples=%lld)\",\n                bagOrange, bagApple);\n    }\n\n    // If we are here, it is valid\n    return false;  // means not \"Impossible\"\n}\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // read x, y\n    long long x = inf.readLong(1, (long long)1e18, \"x\");\n    long long y = inf.readLong(1, (long long)1e18, \"y\");\n    // The problem states x*y > 1, so let's ensure x*y > 1.\n    // But we won't fail if the input doesn't satisfy, because the input presumably is valid.\n    // If needed, we can check:\n    if(x * y <= 1) {\n        // That would be out of problem constraints, but let's just accept it as is.\n        // Not a standard approach to fail in a checker if input is invalid in the statement,\n        // usually the input is assumed correct in official environment.\n    }\n\n    // read the jury's answer\n    bool juryImpossible = false;\n    {\n        // We'll parse the jury's answer. If it's invalid, we call _fail immediately.\n        // If it's \"Impossible\", juryImpossible = true, else false.\n        // We do everything in a try-catch style or we mimic the sample solution approach:\n        string ansLine = ans.readLine();\n\n        // we must parse. A quick local function:\n        auto quitBadJury = [&](const char* format, auto... args) {\n            ans.quitf(_fail, format, args...);\n        };\n\n        if(ansLine == \"Impossible\") {\n            // We'll assume the jury verified there's no valid solution. This is the official solution.\n            // So juryImpossible=true, and we do not check further.\n            juryImpossible = true;\n        } else {\n            // If it's not \"Impossible\", we must parse it similarly, but carefully.\n            if((long long)ansLine.size() > (long long)MAX_LEN) {\n                quitBadJury(\"Jury's output exceeds %lld characters\", MAX_LEN);\n            }\n            // Simulate\n            long long bagOrange = x - 1;\n            long long bagApple  = y - 1;\n            if(bagOrange < 0 || bagApple < 0) {\n                quitBadJury(\"Not enough fruit for the initial distribution in jury's output\");\n            }\n            long long aOrange = 1, aApple = 0;\n            long long bOrange = 0, bApple = 1;\n\n            int pos = 0, n = (int)ansLine.size();\n            while(pos < n) {\n                if(!isdigit(ansLine[pos])) {\n                    quitBadJury(\"Expected digit in jury's solution at position %d\", pos+1);\n                }\n                long long count = 0;\n                while(pos < n && isdigit(ansLine[pos])) {\n                    int d = ansLine[pos] - '0';\n                    if(count > (LLONG_MAX - d) / 10) {\n                        quitBadJury(\"Count number too large in jury's solution at position %d\", pos+1);\n                    }\n                    count = count*10 + d;\n                    pos++;\n                }\n                if(count <= 0) {\n                    quitBadJury(\"Count must be a positive integer in jury's solution\");\n                }\n                if(pos >= n) {\n                    quitBadJury(\"Expected letter after count in jury's solution\");\n                }\n                char c = ansLine[pos++];\n                if(c != 'A' && c != 'B') {\n                    quitBadJury(\"Expected letter 'A' or 'B' in jury's solution, found '%c'\", c);\n                }\n\n                if(c == 'A') {\n                    long long needOrange = count * aOrange;\n                    long long needApple  = count * aApple;\n                    if(needOrange > bagOrange) {\n                        quitBadJury(\"Not enough oranges for repeated 'A' in jury's solution\");\n                    }\n                    if(needApple > bagApple) {\n                        quitBadJury(\"Not enough apples for repeated 'A' in jury's solution\");\n                    }\n                    bagOrange -= needOrange;\n                    bagApple  -= needApple;\n                    bOrange   += needOrange;\n                    bApple    += needApple;\n                } else {\n                    long long needOrange = count * bOrange;\n                    long long needApple  = count * bApple;\n                    if(needOrange > bagOrange) {\n                        quitBadJury(\"Not enough oranges for repeated 'B' in jury's solution\");\n                    }\n                    if(needApple > bagApple) {\n                        quitBadJury(\"Not enough apples for repeated 'B' in jury's solution\");\n                    }\n                    bagOrange -= needOrange;\n                    bagApple  -= needApple;\n                    aOrange   += needOrange;\n                    aApple    += needApple;\n                }\n            }\n            if(bagOrange != 0 || bagApple != 0) {\n                quitBadJury(\"Jury's solution does not use up all fruits\");\n            }\n        }\n    }\n\n    // Now read the participant's answer and check\n    bool participantImpossible = false;\n    {\n        // We'll parse similarly, but if invalid => _wa\n        // If \"Impossible\", store participantImpossible=true, otherwise we check correctness\n        // Then handle final logic.\n        // We'll do this in a function for brevity:\n        auto parseParticipant = [&](void) {\n            // we do a quick read with readLine:\n            string pansLine = ouf.readLine();\n            // function to quit with WA\n            auto quitBadPart = [&](const char* format, auto... args) {\n                ouf.quitf(_wa, format, args...);\n            };\n\n            if(pansLine == \"Impossible\") {\n                participantImpossible = true;\n                return; \n            }\n            // else parse\n            if((long long)pansLine.size() > MAX_LEN) {\n                quitBadPart(\"Output exceeds %lld characters\", MAX_LEN);\n            }\n            long long bagOrange = x - 1;\n            long long bagApple  = y - 1;\n            if(bagOrange < 0 || bagApple < 0) {\n                quitBadPart(\"Not enough fruit for initial distribution\");\n            }\n            long long aOrange = 1, aApple = 0;\n            long long bOrange = 0, bApple = 1;\n\n            int pos = 0, n = (int)pansLine.size();\n            while(pos < n) {\n                if(!isdigit(pansLine[pos])) {\n                    quitBadPart(\"Expected digit at position %d of solution\", pos+1);\n                }\n                long long count = 0;\n                while(pos < n && isdigit(pansLine[pos])) {\n                    int d = pansLine[pos] - '0';\n                    if(count > (LLONG_MAX - d) / 10) {\n                        quitBadPart(\"Count number too large near position %d\", pos+1);\n                    }\n                    count = count*10 + d;\n                    pos++;\n                }\n                if(count <= 0) {\n                    quitBadPart(\"Count must be a positive integer\");\n                }\n                if(pos >= n) {\n                    quitBadPart(\"Expected letter 'A' or 'B' after count\");\n                }\n                char c = pansLine[pos++];\n                if(c != 'A' && c != 'B') {\n                    quitBadPart(\"Expected letter 'A' or 'B', found '%c'\", c);\n                }\n                if(c == 'A') {\n                    long long needOrange = count * aOrange;\n                    long long needApple  = count * aApple;\n                    if(needOrange > bagOrange) {\n                        quitBadPart(\"Not enough oranges for repeated 'A'\");\n                    }\n                    if(needApple > bagApple) {\n                        quitBadPart(\"Not enough apples for repeated 'A'\");\n                    }\n                    bagOrange -= needOrange;\n                    bagApple  -= needApple;\n                    bOrange   += needOrange;\n                    bApple    += needApple;\n                } else {\n                    long long needOrange = count * bOrange;\n                    long long needApple  = count * bApple;\n                    if(needOrange > bagOrange) {\n                        quitBadPart(\"Not enough oranges for repeated 'B'\");\n                    }\n                    if(needApple > bagApple) {\n                        quitBadPart(\"Not enough apples for repeated 'B'\");\n                    }\n                    bagOrange -= needOrange;\n                    bagApple  -= needApple;\n                    aOrange   += needOrange;\n                    aApple    += needApple;\n                }\n            }\n            // check bag\n            if(bagOrange != 0 || bagApple != 0) {\n                quitBadPart(\"After applying all moves, the bag is not fully used up (remaining oranges=%lld, apples=%lld)\",\n                            bagOrange, bagApple);\n            }\n        };\n\n        // call parse\n        // but we must have read the participant's output line with testlib's readLine() once\n        // in readAndCheckAnswer we did 2 reads. We'll replicate logic carefully.\n        // However, we already read jury's line with ans. So for participant, we do parseParticipant now:\n        // We won't read again from ouf, we do parseParticipant that calls ouf.readLine() exactly once.\n        parseParticipant();\n    }\n\n    // final logic\n    // If juryImpossible = true => official says \"Impossible\". Then a valid solution from participant is contradictory => _fail\n    // if participantImpossible = true but juryImpossible = false => must be _wa\n    if(juryImpossible) {\n        // official says \"Impossible\"\n        if(participantImpossible) {\n            // participant also says \"Impossible\" => OK\n            quitf(_ok, \"Both printed Impossible\");\n        } else {\n            // participant found a valid sequence => contradiction\n            quitf(_fail, \"Participant found a solution, but jury's answer is Impossible\");\n        }\n    } else {\n        // official says there is some valid solution\n        if(participantImpossible) {\n            // participant says Impossible => WA\n            quitf(_wa, \"Participant printed Impossible but there is a valid solution\");\n        } else {\n            // participant provided a valid solution => OK\n            quitf(_ok, \"OK\");\n        }\n    }\n    return 0; \n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Apple and Orange counts\n    ll x = 0, y = 0;\n    // Max value for x and y\n    ll MAXN = 1000000000000000000LL; // 1e18\n\n    string sequence;\n\n    // Starting fruits for Alice and Bob\n    ll alice_oranges = 1, alice_apples = 0;\n    ll bob_oranges = 0, bob_apples = 1;\n\n    ll bag_oranges = 0, bag_apples = 0;\n\n    // Simulate different types of sequences\n    if (type == \"allA\") {\n        sequence = string(len, 'A');\n    } else if (type == \"allB\") {\n        sequence = string(len, 'B');\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < len; ++i) {\n            sequence += (i % 2 == 0) ? 'A' : 'B';\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < len; ++i) {\n            sequence += rnd.next(2) ? 'A' : 'B';\n        }\n    } else if (type == \"impossible\") {\n        // Generate impossible test case\n        x = y = rnd.next(2LL, MAXN);\n        cout << x << \" \" << y << endl;\n        return 0;\n    } else {\n        // Default: random\n        for (int i = 0; i < len; ++i) {\n            sequence += rnd.next(2) ? 'A' : 'B';\n        }\n    }\n\n    // Initialize bag with placeholder counts; we'll compute the required totals\n    bag_oranges = 0;\n    bag_apples = 0;\n\n    // Simulate the game\n    ll max_value = 1000000000000000000LL;\n    bool invalid = false;\n    for (char c : sequence) {\n        if (c == 'A') {\n            // Bob receives Alice's fruits\n            bob_oranges += alice_oranges;\n            bob_apples += alice_apples;\n\n            // Bag loses Alice's fruits (she replenishes her own fruits)\n            bag_oranges += alice_oranges;\n            bag_apples += alice_apples;\n\n            // Check for overflow or exceeding MAXN\n            if (bob_oranges > max_value || bob_apples > max_value ||\n                bag_oranges > max_value || bag_apples > max_value) {\n                invalid = true;\n                break;\n            }\n        } else if (c == 'B') {\n            // Alice receives Bob's fruits\n            alice_oranges += bob_oranges;\n            alice_apples += bob_apples;\n\n            // Bag loses Bob's fruits (Bob replenishes his own fruits)\n            bag_oranges += bob_oranges;\n            bag_apples += bob_apples;\n\n            // Check for overflow or exceeding MAXN\n            if (alice_oranges > max_value || alice_apples > max_value ||\n                bag_oranges > max_value || bag_apples > max_value) {\n                invalid = true;\n                break;\n            }\n        }\n    }\n\n    if (invalid || bag_oranges > max_value || bag_apples > max_value) {\n        // Output impossible case\n        x = y = rnd.next(2LL, MAXN);\n        cout << x << \" \" << y << endl;\n    } else {\n        // Total fruits\n        x = bag_oranges + alice_oranges + bob_oranges;\n        y = bag_apples + alice_apples + bob_apples;\n\n        // Ensure x and y are within constraints\n        if (x < 1 || y < 1 || x > MAXN || y > MAXN || x * y <= 1) {\n            // Output impossible case\n            x = y = rnd.next(2LL, MAXN);\n            cout << x << \" \" << y << endl;\n        } else {\n            cout << x << \" \" << y << endl;\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Apple and Orange counts\n    ll x = 0, y = 0;\n    // Max value for x and y\n    ll MAXN = 1000000000000000000LL; // 1e18\n\n    string sequence;\n\n    // Starting fruits for Alice and Bob\n    ll alice_oranges = 1, alice_apples = 0;\n    ll bob_oranges = 0, bob_apples = 1;\n\n    ll bag_oranges = 0, bag_apples = 0;\n\n    // Simulate different types of sequences\n    if (type == \"allA\") {\n        sequence = string(len, 'A');\n    } else if (type == \"allB\") {\n        sequence = string(len, 'B');\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < len; ++i) {\n            sequence += (i % 2 == 0) ? 'A' : 'B';\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < len; ++i) {\n            sequence += rnd.next(2) ? 'A' : 'B';\n        }\n    } else if (type == \"impossible\") {\n        // Generate impossible test case\n        x = y = rnd.next(2LL, MAXN);\n        cout << x << \" \" << y << endl;\n        return 0;\n    } else {\n        // Default: random\n        for (int i = 0; i < len; ++i) {\n            sequence += rnd.next(2) ? 'A' : 'B';\n        }\n    }\n\n    // Initialize bag with placeholder counts; we'll compute the required totals\n    bag_oranges = 0;\n    bag_apples = 0;\n\n    // Simulate the game\n    ll max_value = 1000000000000000000LL;\n    bool invalid = false;\n    for (char c : sequence) {\n        if (c == 'A') {\n            // Bob receives Alice's fruits\n            bob_oranges += alice_oranges;\n            bob_apples += alice_apples;\n\n            // Bag loses Alice's fruits (she replenishes her own fruits)\n            bag_oranges += alice_oranges;\n            bag_apples += alice_apples;\n\n            // Check for overflow or exceeding MAXN\n            if (bob_oranges > max_value || bob_apples > max_value ||\n                bag_oranges > max_value || bag_apples > max_value) {\n                invalid = true;\n                break;\n            }\n        } else if (c == 'B') {\n            // Alice receives Bob's fruits\n            alice_oranges += bob_oranges;\n            alice_apples += bob_apples;\n\n            // Bag loses Bob's fruits (Bob replenishes his own fruits)\n            bag_oranges += bob_oranges;\n            bag_apples += bob_apples;\n\n            // Check for overflow or exceeding MAXN\n            if (alice_oranges > max_value || alice_apples > max_value ||\n                bag_oranges > max_value || bag_apples > max_value) {\n                invalid = true;\n                break;\n            }\n        }\n    }\n\n    if (invalid || bag_oranges > max_value || bag_apples > max_value) {\n        // Output impossible case\n        x = y = rnd.next(2LL, MAXN);\n        cout << x << \" \" << y << endl;\n    } else {\n        // Total fruits\n        x = bag_oranges + alice_oranges + bob_oranges;\n        y = bag_apples + alice_apples + bob_apples;\n\n        // Ensure x and y are within constraints\n        if (x < 1 || y < 1 || x > MAXN || y > MAXN || x * y <= 1) {\n            // Output impossible case\n            x = y = rnd.next(2LL, MAXN);\n            cout << x << \" \" << y << endl;\n        } else {\n            cout << x << \" \" << y << endl;\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small sequences\n./gen -len 1 -type random\n./gen -len 2 -type random\n./gen -len 5 -type random\n./gen -len 10 -type random\n\n# Alternating sequences\n./gen -len 20 -type alternating\n./gen -len 100 -type alternating\n./gen -len 1000 -type alternating\n\n# All 'A's sequences\n./gen -len 10 -type allA\n./gen -len 100 -type allA\n./gen -len 1000 -type allA\n\n# All 'B's sequences\n./gen -len 10 -type allB\n./gen -len 100 -type allB\n./gen -len 1000 -type allB\n\n# Large random sequences\n./gen -len 100000 -type random\n./gen -len 500000 -type random\n./gen -len 1000000 -type random\n\n# Impossible cases\n./gen -len 0 -type impossible\n./gen -len 100 -type impossible\n./gen -len 1000 -type impossible\n\n# Maximal values\n./gen -len 1000000 -type allA\n./gen -len 1000000 -type allB\n\n# Edge cases\n./gen -len 1 -type allA\n./gen -len 1 -type allB\n./gen -len 2 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:31.627905",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "585/D",
      "title": "D. Lizard Era: Beginning",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится целое положительное число n (1 ≤ n ≤ 25) — количество заданий, обязательных для выполнения. Следующие n строк содержат описание заданий — i-я строка содержит три числа li, mi, wi — величины, на которые изменятся отношения к главному герою Линн, Мелианы или Ворриган соответственно, в случае, если герой возьмет их с собой на выполнение i-го задания. Все числа во входных данных целые и не превышают по абсолютному значению 107.",
      "output_spec": "Выходные данныеВ случае, если решения не существует, в первой строке выведите \"Impossible\".В противном случае выведите n строк, в каждой из них по два символа — в i-й строке выводите первые буквы имен спутниц, которых герой должен взять с собой на выполнение i-ого задания ('L' — Линн, 'M' — Мелиана, 'W' — Ворриган). Буквы выводите в любом порядке. Если решений несколько, выведите любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать31 0 00 1 00 0 1Выходные данныеСкопироватьLMMWMWВходные данныеСкопировать70 8 95 9 -26 -8 -79 4 5-4 -9 9-4 5 2-6 8 -7Выходные данныеСкопироватьLMMWLMLWMWLMLWВходные данныеСкопировать21 0 01 1 0Выходные данныеСкопироватьImpossible",
      "description": "D. Lizard Era: Beginning\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке содержится целое положительное число n (1 ≤ n ≤ 25) — количество заданий, обязательных для выполнения. Следующие n строк содержат описание заданий — i-я строка содержит три числа li, mi, wi — величины, на которые изменятся отношения к главному герою Линн, Мелианы или Ворриган соответственно, в случае, если герой возьмет их с собой на выполнение i-го задания. Все числа во входных данных целые и не превышают по абсолютному значению 107.\n\nВходные данные\n\nВыходные данныеВ случае, если решения не существует, в первой строке выведите \"Impossible\".В противном случае выведите n строк, в каждой из них по два символа — в i-й строке выводите первые буквы имен спутниц, которых герой должен взять с собой на выполнение i-ого задания ('L' — Линн, 'M' — Мелиана, 'W' — Ворриган). Буквы выводите в любом порядке. Если решений несколько, выведите любое.\n\nВыходные данные\n\nВходные данныеСкопировать31 0 00 1 00 0 1Выходные данныеСкопироватьLMMWMWВходные данныеСкопировать70 8 95 9 -26 -8 -79 4 5-4 -9 9-4 5 2-6 8 -7Выходные данныеСкопироватьLMMWLMLWMWLMLWВходные данныеСкопировать21 0 01 1 0Выходные данныеСкопироватьImpossible\n\nВходные данныеСкопировать31 0 00 1 00 0 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьLMMWMW\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать70 8 95 9 -26 -8 -79 4 5-4 -9 9-4 5 2-6 8 -7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьLMMWLMLWMWLMLW\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать21 0 01 1 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьImpossible\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #325 - Codeforces",
          "content": "Привет, Codeforces!12 октября 2015 года в 12:00 MSK состоится очередной раунд Codeforces #325 для участников из первого и второго дивизионов. Обратите внимание на необычное время начала раунда!Этот раунд проводится по задачам Регионального этапа всероссийской командной олимпиады школьников по программированию 2015, который пройдет в то же время в городе Саратове. Пожелаем школьным командам удачи на соревновании!Набор задач школьной олимпиады немного отличается от задач, которые будут предложены вам на раунде. В том числе в комплекте задач на школьную присутствуют задачи, которых нет в раунде и наоборот. Поэтому не стоит пугаться того, что мы предложили школьникам слишком сложные задачи :-)Процесс подготовки задач был интересным: мы много раз переделывали условия, переписывали решения, добавляли тесты, изменяли ограничения, даже успели поменять полностью готовую задачу (пришлось останавливать конвейер типографии, который уже печатал условия :-)). Поблагодарим всех кто готовил, помогал готовить задачи, вычитывал условия, писал перекрестные решения: Адилбек adedalic Далабаев, Роман Roms Глазов, Владимир vovuh Петров, Олег Oleg_Smirnov Смирнов, Алексей Perforator Рипинен, Максим Neon Мещеряков, Илья IlyaLos Лось, Виталий gridnevvvit Гриднев, Данил danilka.pro Сагунов, Александр fcspartakm Фролов, Павел HolkinPV Холкин, Игорь Igor_Kudryashov Кудряшов, Елена elena Рогачева, Дмитрий Nerevar Матов, Виталий kuviman Кудасов. Председателем жюри олимпиады является Михаил MikeMirzayanov Мирзаянов (также автором некоторых задач из комплекта). Я же (Эдвард Edvard Давтян) готовил некоторые задачи и координировал работу авторов. Вот такая большая команда авторов получилась (надеюсь я никого не забыл)!Также, конечно, поблагодарим Максима Ахмедова (Zlobober), Того-Чьё-Имя-Пока-Нельзя-Называть (если не ошибаюсь он/она прямо сейчас пишет дополнительные решения по задачам раунда) за помощь в подготовке задач, Марию Белову (Delinur) за перевод условий на английский язык и снова Михаила Мирзаянова (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Участникам будет предложено шесть задач и два часа на их решение. Разбалловка будет объявлена незадолго до начала раунда. Всем высокого рейтинга! Good luck and have fun!P.S.: Также хочется пожелать удачи участникам четвертьфинала чемпионата мира по программированию южного региона, который пройдет в эту среду.По техническим причинам раунд перенесен на 10 минутUPD: По задаче Subway roller в наборе тестов присутствовали тесты с поездами длины 1. В данный момент проводится обсуждение того, насколько сильно это повлияло на результаты раунда. Приносим извинения всем участникам, которых затронула эта проблема. В скором времени будет сделано объявление о принятом решении.UPD2: При подготовке задачи Subway Roller у одного из авторов было ошибочное понимание условия. Из-за этого валидатор допускал существование поездов длины 1, а так же присутствовали тесты с поездами длины 1. Жюри приняло решение, что если участник посылал в течении контеста верное решение, то оно должно быть ему зачтено. Для этого у каждого участника было выбрано первое отправленное решение, проходящее итоговый тестсет (если таковое решение имелось), а остальные решения были пропущены. Так же баллы за все взломы во время соревнования остались без изменения, включая ситуацию, когда взломанное решение считается правильным на новом тестсете (в этом случае взломщик получает свой балл, а решение участника считается полным). Контест будет признан рейтинговым, однако если вы считаете, что данная проблема сильно повлияла на ваш результат, напишите мне в течении 24 часов и мы рассмотрим возможность сделать его нерейтинговым лично для вас.UPD3: Разбор задач",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20889",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3705
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces",
          "content": "586A - Расписание АлёныЗадачу подготовил adedalic.В этой задаче сначала нужно было выкинуть все нули на префиксе и суффиксе строки, после чего ответ был равен количеству единиц плюс количество нулей с двух сторон от которых стоят единицы. Асимптотическая сложность решения: O(n).586B - Лаврентий и магазинЗадачу подготовил Oleg_Smirnov.Назовем путь i-м (0 ≤ i ≤ n - 1), если мы, выходя из дома, сначала i раз идем налево, потом переходим проспект и снова n - 1 - i раз идем налево. Введем обозначение di — время, которое нам придется ждать на светофорах на i-м пути. Если рассмотреть путь из магазина домой с конца, то получится пути из дома в магазиг, поэтому искомый путь есть два разных пути из дома в магазин. Значит ответом на задачу является сумма наименьшего и второго по величине значения di. Значение di легко пересчитывается из значения di - 1, таким образом все di можно посчитать за один проход.Асимптотическая сложность решения: O(n).585A - Стоматолог ГеннадийЗадачу подготовил Neon.Заведем очередь в которой, будут находится дети. На каждой итерации решения пройдем по всем детям, если есть ребенок с отрицательной решимостью удалим его из очереди, а из решимостей детей с большими номерами вычтем di. Если все дети в очереди имеют решимость не меньше нуля, возьмем первого ребенка из очереди, а от решимостей остальных вычтем арифметическую прогрессию, как это описывается в условии.Асимптотическая сложность решения: O(n2).585B - Филипп и поездаЗадачу подготовил IlyaLos.В задаче требовалось просто промоделировать игру. Это можно сделать с помощью обхода в глубину, ширину или динамического программирования. Состоянием является пара чисел x, y — позиция Филиппа в туннеле, а значением или в зависимости от того, можем ли мы попасть из стартовой позиции в x, y. Положения поездов в каждый момент времени определяются однозначно.Асимптотическая сложность решения: O(n).585C - Алиса, Боб, Апельсины и ЯблокиЗадачу подготовил Edvard.Поймем для начала, что означает процесс описанный в условии. Если нарисовать дерево переходов по буквам и , то получится дерево Штерна-Броко. Пусть апельсины это значения знаменателя дроби, а яблоки — числителя. На каждом шагу у нас есть две дроби (изначально ) и мы заменяем либо первую дробь на их медианту, либо вторую. Таким образом, первая дробь есть первый предок влево от медианты, а вторая — первый предок вправо. Таким образом, искомый процесс это просто процесс поиска дроби в дереве Штерна-Броко, который завершается тем, что текущая медианта совпадает с дробью, которую мы ищем (момент окончания игры, описанный в условии). Значит, числа x, y заданные в условии это просто дробь, которую мы ищем. Отсюда следует, что ответа не существует, если x не взаимнопросто с y (поскольку таким дробей нет в дереве Штерна-Броко). Пусть теперь мы хотим найти дробь в дереве. Понятно, что если x > y, то мы сначала перейдем в правую ветку. Более того мы можем считать, что теперь ищем дробь и никуда не спускались. Если же x < y, то нам нужно спуситься в левую ветку и можно считать, что мы ищем дробь и пока никуда не спускались. Эти рассуждения легко формализовать, чтобы получить строгое доказательство. Таким образом, решение задачи сводится к выполнению алгоритма Евклида для пары чисел x, y. Как известно время работы алгоритма Евклида O(logn) (дольше всего алгоритм Евклида работает на двух последовательных числах Фибоначчи), значит длина ответа тоже растет как логарифм.Асимптотическая сложность решения: O(logn).585D - Lizard Era: BeginningЗадачу подготовил danilka.pro.Для решения этой задачи воспользуемся приемом . А именно переберем для первых (первая половина) заданий с какими спутницами главный герой будет путешествовать. Пусть при этом симпатия первой спутницы оказалась равна a, второй — b, а третьей c. Пусть существует способ выбрать спутниц для последующих (вторая половина) заданий так и пусть симпатии при этом будут равны a', b', c'. Тогда, чтобы по всем заданиям суммы симпатий были одинаковы необходимо и достаточно, чтобы a - b = b' - a' и b - c = c' - b'. Теперь для решения задачи достаточно перебрать первую половину и сохранить в некоторой структуре данных тройки чисел a - b, b - c, a (третье число нужно для максимизации ответа в случае равенства). Далее нужно перебрать вторую половину и найти в структуре данных значения b' - a', c' - b', m, где m — максимальное третье значение которое есть в структуре данных. В качестве структуры данных можно использовать map < pair < int, int > , int >  в языке C++, первые два числа это значение a - b, b - c, а третье — максимальное a соответствующее первым двум. Также можно все тройки сложить в один большой массив, отсортировать его и бинарным поиском находить необходимые значения.Асимптотическая сложность решения: , где logC — константа, появляющаяся вместе со структурой данных.585E - Подарок для филателиста ВиталикаЗадачу подготовил gridnevvvit.Пусть мы хотим посчитать количество подмножеств с НОД равным 1 — число A. Посчитаем это количество с помощью формулы включений-исключений: сначала скажем, что все подмножества нам подходят. Таких подмножеств 2n. Теперь вычтем подмножества с НОД кратным 2. Количество таких множеств 2cnt2 - 1, где cnti — количество чисел, делящихся на i. Далее вычитаем 2cnt3 - 1. Подмножества с НОД кратным 4 мы учли вместе с двойкой. Далее вычитаем 2cnt5 - 1. Теперь заметим, что подмножества с НОД кратным 6 мы вычли уже дважды: сначала с двойкой, затем с тройкой, поэтому давайте прибавим количество таких подмножеств 2cnt6 - 1. Продолжая этот процесс получаем, что для числа d, к ответу нужно прибавить величину μ(d)(2cntd - 1), где μ(d) равно 0, если d делится на полный квадрат, 1, если количество простых в факторизации d четно и  - 1 в противном случае. Значит числа, делящиеся на полный квадрат мы можем не суммировать, поскольку они входят с коэффициентом 0. Для подсчета значений cnti достаточно факторизовать все числа и для каждого за 2k перебрать делитель, со значением μ(d) ≠ 0. Теперь легко понять, что количество подмножеств с НОД большим 1 равно B = 2n - A. Теперь для решения задачи давайте переберем марку, которую купит Виталик ai. Пересчитаем число B так, как если бы числа ai не было в множестве. Для этого нужно просто вычесть те слагаемые на которые повлияло число ai. Это можно сделать за 2k, где k — количество простых в факторизации числа ai (снова нужно перебрать делители ai со значением μ(d) ≠ 0). Теперь поймем какие подмножества дадут НОД равный 1 вместе с выбранной маркой. Понятно это те подмножества НОД которых больше 1, но при этом не делится ни на один делитель ai. Для этого снова воспользуемся формулой включений-исключений. Для каждого делителя d числа ai вычтем из B значение μ(d)(2cntd - 1). Таким образом, мы получим количество способов Bi выбрать подмножество c НОД большим 1, но при это взаимнопростым с ai. Ответом на задачу является сумма всех Bi. Наибольшее количество простых в факторизации числа не превосходящего 107 равно 8. Факторизацию чисел можно выполнить с помощью линейного алгоритма поиска минимального делителя чисел от 1 до n, либо с помощью решета Эратосфена за время O(nloglogn).Асимптотическая сложность решения: O(C + n2K), где , а K — наибольшее количество простых в факторизации чисел ai.585F - Знаки числа ПиЗадачу подготовил Edvard.Расмотрим все подстроки строки s длины . Сложим все эти строки в бор, посчитаем суффиксные ссылки и построим автомат по цифрам. Это можно сделать за линейное время с помощью алгоритма Ахо-Корасик. Теперь для решения задачи посчитаем динамику zi, v, b1, b2, b в котором состояние описывается пятеркой чисел: i — количество цифр которые мы уже поставили в искомом числе, которое встречается , v — в какой вершине бора мы находимся, b1 — равен ли префикс числа, которое мы набираем префиксу числа x, b2 — равен ли префикс числа, которое мы набираем префиксу числа y, b — находится ли некоторая подстрока длина на уже набранном префиксе в боре (значения b1, b2, b — равны либо 0, либо 1). Значением динамики является количество способов набрать префикс с заданным набором свойств. Для того, чтобы сделать переход нужно перебрать цифру, проверить что мы не вышли за границы отрезка [x, y], перейти от вершины v к следующей вершине по автомату и заданной цифре. Ответом является сумма по всем v, b1, b2 zb, v, v1, v2, 1.Асимптотическая сложность решения: O(nd2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20898",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 585\\s*D"
          },
          "content_length": 8320
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #325 - Codeforces - Code 1",
          "code": "int n = 4000;\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        cout << \"1000000 1000000 1\\n\";\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 2",
          "code": "int n = 4000;\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        cout << \"1000000 1000000 1\\n\";\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 3",
          "code": "Input\n6\n3 1 1\n1 3 2\n10 4 6\n1 1 2\n1 1 2\n1 1 14\nOutput \n2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 4",
          "code": "Input\n6\n3 1 1\n1 3 2\n10 4 6\n1 1 2\n1 1 2\n1 1 14\nOutput \n2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 5",
          "code": "string num;\n\t\twhile(ans0[i].ss > 0) {\n\t\t\tnum +=('0'+ans0[i].ss%10);\n\t\t\tans0[i].ss /=10;}\n\t\tans +=num;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 6",
          "code": "string num;\n\t\twhile(ans0[i].ss > 0) {\n\t\t\tnum +=('0'+ans0[i].ss%10);\n\t\t\tans0[i].ss /=10;}\n\t\tans +=num;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 7",
          "code": "1\n5 3\n..A..\ns.B..\n..C..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 8",
          "code": "1\n5 3\n..A..\ns.B..\n..C..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 9",
          "code": "Каждый поезд представляет собой две или более клетки, находящиеся непосредственно друг за другом в некоторой строке поля",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 10",
          "code": "Каждый поезд представляет собой две или более клетки, находящиеся непосредственно друг за другом в некоторой строке поля",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 11",
          "code": "while(true)\n    {\n        ll mi = min(x,y),ma = max(x,y);\n        if(ma%mi == 0)\n        {\n            ll times = ma/mi - 1;\n            cout<<to_string(times);\n            if(x>y)\n                cout<<\"A\";\n            else\n                cout<<\"B\";\n            return 0;\n        }\n        ll times = ma/mi;\n        cout<<to_string(times);\n        if(x>y)\n            cout<<\"A\";\n        else\n            cout<<\"B\";\n        ma = ma%mi;\n        if(x>y) {\n            x = ma;\n            y = mi;\n        }\n        else {\n            x = mi;\n            y = ma;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 12",
          "code": "while(true)\n    {\n        ll mi = min(x,y),ma = max(x,y);\n        if(ma%mi == 0)\n        {\n            ll times = ma/mi - 1;\n            cout<<to_string(times);\n            if(x>y)\n                cout<<\"A\";\n            else\n                cout<<\"B\";\n            return 0;\n        }\n        ll times = ma/mi;\n        cout<<to_string(times);\n        if(x>y)\n            cout<<\"A\";\n        else\n            cout<<\"B\";\n        ma = ma%mi;\n        if(x>y) {\n            x = ma;\n            y = mi;\n        }\n        else {\n            x = mi;\n            y = ma;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 13",
          "code": "long sum_d = 0; /* be careful, don't let it overflow */\nfor (int j = i+1; j < N; j++) {\n    if (gone[j]) continue;\n\n    p[j] -= sum_d;\n    if (p[j] < 0) {\n        gone[j] = 1;\n        sum_d += d[j];\n        if (sum_d > maxV)\n            sum_d = maxV + 1; /* XXX p == 0 won't make the kid run */\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 14",
          "code": "long sum_d = 0; /* be careful, don't let it overflow */\nfor (int j = i+1; j < N; j++) {\n    if (gone[j]) continue;\n\n    p[j] -= sum_d;\n    if (p[j] < 0) {\n        gone[j] = 1;\n        sum_d += d[j];\n        if (sum_d > maxV)\n            sum_d = maxV + 1; /* XXX p == 0 won't make the kid run */\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 15",
          "code": "5\n3 1 10\n3 1 10\n1 5 1\n1 1 5\n1 1 8\n\noutput\n2\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 16",
          "code": "5\n3 1 10\n3 1 10\n1 5 1\n1 1 5\n1 1 8\n\noutput\n2\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 1",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 2",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 3",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 4",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 25, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int li = inf.readInt(-10000000, 10000000, \"li\");\n        inf.readSpace();\n        int mi = inf.readInt(-10000000, 10000000, \"mi\");\n        inf.readSpace();\n        int wi = inf.readInt(-10000000, 10000000, \"wi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 25, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int li = inf.readInt(-10000000, 10000000, \"li\");\n        inf.readSpace();\n        int mi = inf.readInt(-10000000, 10000000, \"mi\");\n        inf.readSpace();\n        int wi = inf.readInt(-10000000, 10000000, \"wi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 25, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int li = inf.readInt(-10000000, 10000000, \"li\");\n        inf.readSpace();\n        int mi = inf.readInt(-10000000, 10000000, \"mi\");\n        inf.readSpace();\n        int wi = inf.readInt(-10000000, 10000000, \"wi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> li, mi, wi;\n\nvoid readAns(InStream &stream, bool &impossible, int &final_attitude) {\n    string firstLine = stream.readLine();\n    if (firstLine == \"Impossible\") {\n        impossible = true;\n        return;\n    } else {\n        impossible = false;\n        vector<int> att(3, 0); // Attitudes of L, M, W\n        vector<string> selections;\n        selections.push_back(firstLine);\n        for (int i = 1; i < n; ++i) {\n            selections.push_back(stream.readLine());\n        }\n        for (int i = 0; i < n; ++i) {\n            string sel = selections[i];\n            if (sel.length() != 2) {\n                stream.quitf(_wa, \"Quest %d: Expected 2 characters, but got '%s'\", i+1, sel.c_str());\n            }\n            bool selected[3] = {false, false, false};\n            for (char c : sel) {\n                if (c == 'L') selected[0] = true;\n                else if (c == 'M') selected[1] = true;\n                else if (c == 'W') selected[2] = true;\n                else {\n                    stream.quitf(_wa, \"Quest %d: Invalid character '%c'\", i+1, c);\n                }\n            }\n            int cnt = selected[0] + selected[1] + selected[2];\n            if (cnt != 2) {\n                stream.quitf(_wa, \"Quest %d: Expected 2 companions, but found %d\", i+1, cnt);\n            }\n            if (selected[0]) att[0] += li[i];\n            if (selected[1]) att[1] += mi[i];\n            if (selected[2]) att[2] += wi[i];\n        }\n        if (att[0] != att[1] || att[1] != att[2]) {\n            stream.quitf(_wa, \"Final attitudes are not equal: Lynn=%d, Meliana=%d, Worrigan=%d\", att[0], att[1], att[2]);\n        }\n        final_attitude = att[0]; // All are equal\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    n = inf.readInt();\n    li.resize(n);\n    mi.resize(n);\n    wi.resize(n);\n    for (int i = 0; i < n; ++i) {\n        li[i] = inf.readInt();\n        mi[i] = inf.readInt();\n        wi[i] = inf.readInt();\n    }\n\n    bool jury_impossible = false;\n    int jury_attitude = -1;\n    readAns(ans, jury_impossible, jury_attitude);\n\n    bool participant_impossible = false;\n    int participant_attitude = -1;\n    readAns(ouf, participant_impossible, participant_attitude);\n\n    if (participant_impossible) {\n        if (jury_impossible) {\n            quitf(_ok, \"Both solutions impossible\");\n        } else {\n            quitf(_wa, \"Participant claimed impossible but jury found possible solution\");\n        }\n    } else {\n        if (jury_impossible) {\n            quitf(_fail, \"Participant found solution but jury did not\");\n        } else {\n            if (participant_attitude < jury_attitude) {\n                quitf(_wa, \"Participant's final attitude %d is less than jury's %d\", participant_attitude, jury_attitude);\n            } else if (participant_attitude == jury_attitude) {\n                quitf(_ok, \"Correct solution with final attitude %d\", participant_attitude);\n            } else {\n                quitf(_fail, \"Participant's final attitude %d greater than jury's %d\", participant_attitude, jury_attitude);\n            }\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Adjust n for edge cases\n    if (type == \"edge_n1\") {\n        n = 1;\n    } else if (type == \"edge_n25\") {\n        n = 25;\n    } else {\n        n = max(1, min(n, 25)); // Ensure n is within [1,25]\n    }\n\n    printf(\"%d\\n\", n);\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int li = rnd.next(-10000000, 10000000);\n            int mi = rnd.next(-10000000, 10000000);\n            int wi = rnd.next(-10000000, 10000000);\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    } else if (type == \"impossible\") {\n        // Generate tasks where it's impossible to balance the attitudes\n        vector<int> li(n), mi(n), wi(n);\n\n        int sum_diff_LM = 0;\n        int sum_diff_LW = 0;\n\n        for (int i = 0; i < n; ++i) {\n            int choice = rnd.next(0, 2);\n            if (choice == 0) {\n                // LM choice\n                li[i] = rnd.next(-10000000, 10000000);\n                mi[i] = li[i] + rnd.next(1, 100);\n                wi[i] = rnd.next(-10000000, 10000000);\n                sum_diff_LM += li[i] - mi[i];\n                sum_diff_LW += li[i];\n            } else if (choice == 1) {\n                // LW choice\n                li[i] = rnd.next(-10000000, 10000000);\n                wi[i] = li[i] + rnd.next(1, 100);\n                mi[i] = rnd.next(-10000000, 10000000);\n                sum_diff_LM += li[i];\n                sum_diff_LW += li[i] - wi[i];\n            } else {\n                // MW choice\n                mi[i] = rnd.next(-10000000, 10000000);\n                wi[i] = mi[i] + rnd.next(1,100);\n                li[i] = rnd.next(-10000000, 10000000);\n                sum_diff_LM += -mi[i];\n                sum_diff_LW += -wi[i];\n            }\n        }\n\n        // Offset the sums to make them impossible to balance\n        // For example, add a non-zero constant to sum_diff_LM and sum_diff_LW\n        sum_diff_LM += rnd.next(1, 1000);\n        sum_diff_LW += rnd.next(1, 1000);\n\n        // Output the tasks\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d %d\\n\", li[i], mi[i], wi[i]);\n        }\n\n    } else if (type == \"zero\") {\n        for (int i = 0; i < n; ++i) {\n            printf(\"0 0 0\\n\");\n        }\n    } else if (type == \"edge_n1\") {\n        for (int i = 0; i < n; ++i) {\n            int li = rnd.next(-10000000, 10000000);\n            int mi = rnd.next(-10000000, 10000000);\n            int wi = rnd.next(-10000000, 10000000);\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    } else if (type == \"edge_n25\") {\n        for (int i = 0; i < n; ++i) {\n            int li = rnd.next(-10000000, 10000000);\n            int mi = rnd.next(-10000000, 10000000);\n            int wi = rnd.next(-10000000, 10000000);\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    } else if (type == \"maximum_attitude\") {\n        // Generate tasks where maximum final attitude is maximized\n        // We'll set the tasks so that choosing LM every time leads to maximum attitude\n        for (int i = 0; i < n; ++i) {\n            int li = 10000000;\n            int mi = 10000000;\n            int wi = -10000000;\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    } else if (type == \"negative_attitude\") {\n        // Generate tasks where maximum final attitude is negative\n        // We'll set the tasks so that choosing MW every time leads to negative attitude\n        for (int i = 0; i < n; ++i) {\n            int li = -10000000;\n            int mi = -10000000;\n            int wi = -10000000;\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int li = rnd.next(-10000000, 10000000);\n            int mi = rnd.next(-10000000, 10000000);\n            int wi = rnd.next(-10000000, 10000000);\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Adjust n for edge cases\n    if (type == \"edge_n1\") {\n        n = 1;\n    } else if (type == \"edge_n25\") {\n        n = 25;\n    } else {\n        n = max(1, min(n, 25)); // Ensure n is within [1,25]\n    }\n\n    printf(\"%d\\n\", n);\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int li = rnd.next(-10000000, 10000000);\n            int mi = rnd.next(-10000000, 10000000);\n            int wi = rnd.next(-10000000, 10000000);\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    } else if (type == \"impossible\") {\n        // Generate tasks where it's impossible to balance the attitudes\n        vector<int> li(n), mi(n), wi(n);\n\n        int sum_diff_LM = 0;\n        int sum_diff_LW = 0;\n\n        for (int i = 0; i < n; ++i) {\n            int choice = rnd.next(0, 2);\n            if (choice == 0) {\n                // LM choice\n                li[i] = rnd.next(-10000000, 10000000);\n                mi[i] = li[i] + rnd.next(1, 100);\n                wi[i] = rnd.next(-10000000, 10000000);\n                sum_diff_LM += li[i] - mi[i];\n                sum_diff_LW += li[i];\n            } else if (choice == 1) {\n                // LW choice\n                li[i] = rnd.next(-10000000, 10000000);\n                wi[i] = li[i] + rnd.next(1, 100);\n                mi[i] = rnd.next(-10000000, 10000000);\n                sum_diff_LM += li[i];\n                sum_diff_LW += li[i] - wi[i];\n            } else {\n                // MW choice\n                mi[i] = rnd.next(-10000000, 10000000);\n                wi[i] = mi[i] + rnd.next(1,100);\n                li[i] = rnd.next(-10000000, 10000000);\n                sum_diff_LM += -mi[i];\n                sum_diff_LW += -wi[i];\n            }\n        }\n\n        // Offset the sums to make them impossible to balance\n        // For example, add a non-zero constant to sum_diff_LM and sum_diff_LW\n        sum_diff_LM += rnd.next(1, 1000);\n        sum_diff_LW += rnd.next(1, 1000);\n\n        // Output the tasks\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d %d\\n\", li[i], mi[i], wi[i]);\n        }\n\n    } else if (type == \"zero\") {\n        for (int i = 0; i < n; ++i) {\n            printf(\"0 0 0\\n\");\n        }\n    } else if (type == \"edge_n1\") {\n        for (int i = 0; i < n; ++i) {\n            int li = rnd.next(-10000000, 10000000);\n            int mi = rnd.next(-10000000, 10000000);\n            int wi = rnd.next(-10000000, 10000000);\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    } else if (type == \"edge_n25\") {\n        for (int i = 0; i < n; ++i) {\n            int li = rnd.next(-10000000, 10000000);\n            int mi = rnd.next(-10000000, 10000000);\n            int wi = rnd.next(-10000000, 10000000);\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    } else if (type == \"maximum_attitude\") {\n        // Generate tasks where maximum final attitude is maximized\n        // We'll set the tasks so that choosing LM every time leads to maximum attitude\n        for (int i = 0; i < n; ++i) {\n            int li = 10000000;\n            int mi = 10000000;\n            int wi = -10000000;\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    } else if (type == \"negative_attitude\") {\n        // Generate tasks where maximum final attitude is negative\n        // We'll set the tasks so that choosing MW every time leads to negative attitude\n        for (int i = 0; i < n; ++i) {\n            int li = -10000000;\n            int mi = -10000000;\n            int wi = -10000000;\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int li = rnd.next(-10000000, 10000000);\n            int mi = rnd.next(-10000000, 10000000);\n            int wi = rnd.next(-10000000, 10000000);\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type impossible\n./gen -n 1 -type zero\n./gen -n 1 -type maximum_attitude\n./gen -n 1 -type negative_attitude\n\n./gen -n 5 -type random\n./gen -n 5 -type impossible\n./gen -n 5 -type zero\n./gen -n 5 -type maximum_attitude\n./gen -n 5 -type negative_attitude\n\n./gen -n 10 -type random\n./gen -n 10 -type impossible\n./gen -n 10 -type zero\n./gen -n 10 -type maximum_attitude\n./gen -n 10 -type negative_attitude\n\n./gen -n 15 -type random\n./gen -n 15 -type impossible\n./gen -n 15 -type zero\n./gen -n 15 -type maximum_attitude\n./gen -n 15 -type negative_attitude\n\n./gen -n 20 -type random\n./gen -n 20 -type impossible\n./gen -n 20 -type zero\n./gen -n 20 -type maximum_attitude\n./gen -n 20 -type negative_attitude\n\n./gen -n 25 -type random\n./gen -n 25 -type impossible\n./gen -n 25 -type zero\n./gen -n 25 -type maximum_attitude\n./gen -n 25 -type negative_attitude\n\n./gen -n 10 -type edge_n1\n./gen -n 10 -type edge_n25\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:33.487509",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "585/E",
      "title": "E. Подарок для филателиста Виталика",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест5 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных содержится целое число n (2 ≤ n ≤ 5·105) — количество различных марок, имеющихся в продаже в магазине «Робин Бобин». Вторая строка содержит последовательность целых чисел a1, a2, ..., an (2 ≤ ai ≤ 107), где ai — цена i-й марки.",
      "output_spec": "Выходные данныеВыведите одно целое число — остаток от деления искомого количества ситуаций на число 109 + 7.",
      "sample_tests": "ПримерыВходные данныеСкопировать32 3 2Выходные данныеСкопировать5Входные данныеСкопировать29 6Выходные данныеСкопировать0",
      "description": "E. Подарок для филателиста Виталика\n\nограничение по времени на тест5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных содержится целое число n (2 ≤ n ≤ 5·105) — количество различных марок, имеющихся в продаже в магазине «Робин Бобин». Вторая строка содержит последовательность целых чисел a1, a2, ..., an (2 ≤ ai ≤ 107), где ai — цена i-й марки.\n\nВходные данные\n\nВыходные данныеВыведите одно целое число — остаток от деления искомого количества ситуаций на число 109 + 7.\n\nВыходные данные\n\nВходные данныеСкопировать32 3 2Выходные данныеСкопировать5Входные данныеСкопировать29 6Выходные данныеСкопировать0\n\nВходные данныеСкопировать32 3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать29 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере возможны следующие ситуации:   Виталик покупает 1-ю марку, магазин дарит 2-ю марку;  Виталик покупает 3-ю марку, магазин дарит 2-ю марку;  Виталик покупает 2-ю марку, магазин дарит 1-ю марку;  Виталик покупает 2-ю марку, магазин дарит 3-ю марку;  Виталик покупает 2-ю марку, магазин дарит 1-ю и 3-ю марки.",
      "solutions": [
        {
          "title": "Codeforces Round #325 - Codeforces",
          "content": "Привет, Codeforces!12 октября 2015 года в 12:00 MSK состоится очередной раунд Codeforces #325 для участников из первого и второго дивизионов. Обратите внимание на необычное время начала раунда!Этот раунд проводится по задачам Регионального этапа всероссийской командной олимпиады школьников по программированию 2015, который пройдет в то же время в городе Саратове. Пожелаем школьным командам удачи на соревновании!Набор задач школьной олимпиады немного отличается от задач, которые будут предложены вам на раунде. В том числе в комплекте задач на школьную присутствуют задачи, которых нет в раунде и наоборот. Поэтому не стоит пугаться того, что мы предложили школьникам слишком сложные задачи :-)Процесс подготовки задач был интересным: мы много раз переделывали условия, переписывали решения, добавляли тесты, изменяли ограничения, даже успели поменять полностью готовую задачу (пришлось останавливать конвейер типографии, который уже печатал условия :-)). Поблагодарим всех кто готовил, помогал готовить задачи, вычитывал условия, писал перекрестные решения: Адилбек adedalic Далабаев, Роман Roms Глазов, Владимир vovuh Петров, Олег Oleg_Smirnov Смирнов, Алексей Perforator Рипинен, Максим Neon Мещеряков, Илья IlyaLos Лось, Виталий gridnevvvit Гриднев, Данил danilka.pro Сагунов, Александр fcspartakm Фролов, Павел HolkinPV Холкин, Игорь Igor_Kudryashov Кудряшов, Елена elena Рогачева, Дмитрий Nerevar Матов, Виталий kuviman Кудасов. Председателем жюри олимпиады является Михаил MikeMirzayanov Мирзаянов (также автором некоторых задач из комплекта). Я же (Эдвард Edvard Давтян) готовил некоторые задачи и координировал работу авторов. Вот такая большая команда авторов получилась (надеюсь я никого не забыл)!Также, конечно, поблагодарим Максима Ахмедова (Zlobober), Того-Чьё-Имя-Пока-Нельзя-Называть (если не ошибаюсь он/она прямо сейчас пишет дополнительные решения по задачам раунда) за помощь в подготовке задач, Марию Белову (Delinur) за перевод условий на английский язык и снова Михаила Мирзаянова (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Участникам будет предложено шесть задач и два часа на их решение. Разбалловка будет объявлена незадолго до начала раунда. Всем высокого рейтинга! Good luck and have fun!P.S.: Также хочется пожелать удачи участникам четвертьфинала чемпионата мира по программированию южного региона, который пройдет в эту среду.По техническим причинам раунд перенесен на 10 минутUPD: По задаче Subway roller в наборе тестов присутствовали тесты с поездами длины 1. В данный момент проводится обсуждение того, насколько сильно это повлияло на результаты раунда. Приносим извинения всем участникам, которых затронула эта проблема. В скором времени будет сделано объявление о принятом решении.UPD2: При подготовке задачи Subway Roller у одного из авторов было ошибочное понимание условия. Из-за этого валидатор допускал существование поездов длины 1, а так же присутствовали тесты с поездами длины 1. Жюри приняло решение, что если участник посылал в течении контеста верное решение, то оно должно быть ему зачтено. Для этого у каждого участника было выбрано первое отправленное решение, проходящее итоговый тестсет (если таковое решение имелось), а остальные решения были пропущены. Так же баллы за все взломы во время соревнования остались без изменения, включая ситуацию, когда взломанное решение считается правильным на новом тестсете (в этом случае взломщик получает свой балл, а решение участника считается полным). Контест будет признан рейтинговым, однако если вы считаете, что данная проблема сильно повлияла на ваш результат, напишите мне в течении 24 часов и мы рассмотрим возможность сделать его нерейтинговым лично для вас.UPD3: Разбор задач",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20889",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3705
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces",
          "content": "586A - Расписание АлёныЗадачу подготовил adedalic.В этой задаче сначала нужно было выкинуть все нули на префиксе и суффиксе строки, после чего ответ был равен количеству единиц плюс количество нулей с двух сторон от которых стоят единицы. Асимптотическая сложность решения: O(n).586B - Лаврентий и магазинЗадачу подготовил Oleg_Smirnov.Назовем путь i-м (0 ≤ i ≤ n - 1), если мы, выходя из дома, сначала i раз идем налево, потом переходим проспект и снова n - 1 - i раз идем налево. Введем обозначение di — время, которое нам придется ждать на светофорах на i-м пути. Если рассмотреть путь из магазина домой с конца, то получится пути из дома в магазиг, поэтому искомый путь есть два разных пути из дома в магазин. Значит ответом на задачу является сумма наименьшего и второго по величине значения di. Значение di легко пересчитывается из значения di - 1, таким образом все di можно посчитать за один проход.Асимптотическая сложность решения: O(n).585A - Стоматолог ГеннадийЗадачу подготовил Neon.Заведем очередь в которой, будут находится дети. На каждой итерации решения пройдем по всем детям, если есть ребенок с отрицательной решимостью удалим его из очереди, а из решимостей детей с большими номерами вычтем di. Если все дети в очереди имеют решимость не меньше нуля, возьмем первого ребенка из очереди, а от решимостей остальных вычтем арифметическую прогрессию, как это описывается в условии.Асимптотическая сложность решения: O(n2).585B - Филипп и поездаЗадачу подготовил IlyaLos.В задаче требовалось просто промоделировать игру. Это можно сделать с помощью обхода в глубину, ширину или динамического программирования. Состоянием является пара чисел x, y — позиция Филиппа в туннеле, а значением или в зависимости от того, можем ли мы попасть из стартовой позиции в x, y. Положения поездов в каждый момент времени определяются однозначно.Асимптотическая сложность решения: O(n).585C - Алиса, Боб, Апельсины и ЯблокиЗадачу подготовил Edvard.Поймем для начала, что означает процесс описанный в условии. Если нарисовать дерево переходов по буквам и , то получится дерево Штерна-Броко. Пусть апельсины это значения знаменателя дроби, а яблоки — числителя. На каждом шагу у нас есть две дроби (изначально ) и мы заменяем либо первую дробь на их медианту, либо вторую. Таким образом, первая дробь есть первый предок влево от медианты, а вторая — первый предок вправо. Таким образом, искомый процесс это просто процесс поиска дроби в дереве Штерна-Броко, который завершается тем, что текущая медианта совпадает с дробью, которую мы ищем (момент окончания игры, описанный в условии). Значит, числа x, y заданные в условии это просто дробь, которую мы ищем. Отсюда следует, что ответа не существует, если x не взаимнопросто с y (поскольку таким дробей нет в дереве Штерна-Броко). Пусть теперь мы хотим найти дробь в дереве. Понятно, что если x > y, то мы сначала перейдем в правую ветку. Более того мы можем считать, что теперь ищем дробь и никуда не спускались. Если же x < y, то нам нужно спуситься в левую ветку и можно считать, что мы ищем дробь и пока никуда не спускались. Эти рассуждения легко формализовать, чтобы получить строгое доказательство. Таким образом, решение задачи сводится к выполнению алгоритма Евклида для пары чисел x, y. Как известно время работы алгоритма Евклида O(logn) (дольше всего алгоритм Евклида работает на двух последовательных числах Фибоначчи), значит длина ответа тоже растет как логарифм.Асимптотическая сложность решения: O(logn).585D - Lizard Era: BeginningЗадачу подготовил danilka.pro.Для решения этой задачи воспользуемся приемом . А именно переберем для первых (первая половина) заданий с какими спутницами главный герой будет путешествовать. Пусть при этом симпатия первой спутницы оказалась равна a, второй — b, а третьей c. Пусть существует способ выбрать спутниц для последующих (вторая половина) заданий так и пусть симпатии при этом будут равны a', b', c'. Тогда, чтобы по всем заданиям суммы симпатий были одинаковы необходимо и достаточно, чтобы a - b = b' - a' и b - c = c' - b'. Теперь для решения задачи достаточно перебрать первую половину и сохранить в некоторой структуре данных тройки чисел a - b, b - c, a (третье число нужно для максимизации ответа в случае равенства). Далее нужно перебрать вторую половину и найти в структуре данных значения b' - a', c' - b', m, где m — максимальное третье значение которое есть в структуре данных. В качестве структуры данных можно использовать map < pair < int, int > , int >  в языке C++, первые два числа это значение a - b, b - c, а третье — максимальное a соответствующее первым двум. Также можно все тройки сложить в один большой массив, отсортировать его и бинарным поиском находить необходимые значения.Асимптотическая сложность решения: , где logC — константа, появляющаяся вместе со структурой данных.585E - Подарок для филателиста ВиталикаЗадачу подготовил gridnevvvit.Пусть мы хотим посчитать количество подмножеств с НОД равным 1 — число A. Посчитаем это количество с помощью формулы включений-исключений: сначала скажем, что все подмножества нам подходят. Таких подмножеств 2n. Теперь вычтем подмножества с НОД кратным 2. Количество таких множеств 2cnt2 - 1, где cnti — количество чисел, делящихся на i. Далее вычитаем 2cnt3 - 1. Подмножества с НОД кратным 4 мы учли вместе с двойкой. Далее вычитаем 2cnt5 - 1. Теперь заметим, что подмножества с НОД кратным 6 мы вычли уже дважды: сначала с двойкой, затем с тройкой, поэтому давайте прибавим количество таких подмножеств 2cnt6 - 1. Продолжая этот процесс получаем, что для числа d, к ответу нужно прибавить величину μ(d)(2cntd - 1), где μ(d) равно 0, если d делится на полный квадрат, 1, если количество простых в факторизации d четно и  - 1 в противном случае. Значит числа, делящиеся на полный квадрат мы можем не суммировать, поскольку они входят с коэффициентом 0. Для подсчета значений cnti достаточно факторизовать все числа и для каждого за 2k перебрать делитель, со значением μ(d) ≠ 0. Теперь легко понять, что количество подмножеств с НОД большим 1 равно B = 2n - A. Теперь для решения задачи давайте переберем марку, которую купит Виталик ai. Пересчитаем число B так, как если бы числа ai не было в множестве. Для этого нужно просто вычесть те слагаемые на которые повлияло число ai. Это можно сделать за 2k, где k — количество простых в факторизации числа ai (снова нужно перебрать делители ai со значением μ(d) ≠ 0). Теперь поймем какие подмножества дадут НОД равный 1 вместе с выбранной маркой. Понятно это те подмножества НОД которых больше 1, но при этом не делится ни на один делитель ai. Для этого снова воспользуемся формулой включений-исключений. Для каждого делителя d числа ai вычтем из B значение μ(d)(2cntd - 1). Таким образом, мы получим количество способов Bi выбрать подмножество c НОД большим 1, но при это взаимнопростым с ai. Ответом на задачу является сумма всех Bi. Наибольшее количество простых в факторизации числа не превосходящего 107 равно 8. Факторизацию чисел можно выполнить с помощью линейного алгоритма поиска минимального делителя чисел от 1 до n, либо с помощью решета Эратосфена за время O(nloglogn).Асимптотическая сложность решения: O(C + n2K), где , а K — наибольшее количество простых в факторизации чисел ai.585F - Знаки числа ПиЗадачу подготовил Edvard.Расмотрим все подстроки строки s длины . Сложим все эти строки в бор, посчитаем суффиксные ссылки и построим автомат по цифрам. Это можно сделать за линейное время с помощью алгоритма Ахо-Корасик. Теперь для решения задачи посчитаем динамику zi, v, b1, b2, b в котором состояние описывается пятеркой чисел: i — количество цифр которые мы уже поставили в искомом числе, которое встречается , v — в какой вершине бора мы находимся, b1 — равен ли префикс числа, которое мы набираем префиксу числа x, b2 — равен ли префикс числа, которое мы набираем префиксу числа y, b — находится ли некоторая подстрока длина на уже набранном префиксе в боре (значения b1, b2, b — равны либо 0, либо 1). Значением динамики является количество способов набрать префикс с заданным набором свойств. Для того, чтобы сделать переход нужно перебрать цифру, проверить что мы не вышли за границы отрезка [x, y], перейти от вершины v к следующей вершине по автомату и заданной цифре. Ответом является сумма по всем v, b1, b2 zb, v, v1, v2, 1.Асимптотическая сложность решения: O(nd2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20898",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 585\\s*E"
          },
          "content_length": 8320
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #325 - Codeforces - Code 1",
          "code": "int n = 4000;\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        cout << \"1000000 1000000 1\\n\";\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 2",
          "code": "int n = 4000;\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        cout << \"1000000 1000000 1\\n\";\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 3",
          "code": "Input\n6\n3 1 1\n1 3 2\n10 4 6\n1 1 2\n1 1 2\n1 1 14\nOutput \n2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 4",
          "code": "Input\n6\n3 1 1\n1 3 2\n10 4 6\n1 1 2\n1 1 2\n1 1 14\nOutput \n2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 5",
          "code": "string num;\n\t\twhile(ans0[i].ss > 0) {\n\t\t\tnum +=('0'+ans0[i].ss%10);\n\t\t\tans0[i].ss /=10;}\n\t\tans +=num;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 6",
          "code": "string num;\n\t\twhile(ans0[i].ss > 0) {\n\t\t\tnum +=('0'+ans0[i].ss%10);\n\t\t\tans0[i].ss /=10;}\n\t\tans +=num;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 7",
          "code": "1\n5 3\n..A..\ns.B..\n..C..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 8",
          "code": "1\n5 3\n..A..\ns.B..\n..C..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 9",
          "code": "Каждый поезд представляет собой две или более клетки, находящиеся непосредственно друг за другом в некоторой строке поля",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 10",
          "code": "Каждый поезд представляет собой две или более клетки, находящиеся непосредственно друг за другом в некоторой строке поля",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 11",
          "code": "while(true)\n    {\n        ll mi = min(x,y),ma = max(x,y);\n        if(ma%mi == 0)\n        {\n            ll times = ma/mi - 1;\n            cout<<to_string(times);\n            if(x>y)\n                cout<<\"A\";\n            else\n                cout<<\"B\";\n            return 0;\n        }\n        ll times = ma/mi;\n        cout<<to_string(times);\n        if(x>y)\n            cout<<\"A\";\n        else\n            cout<<\"B\";\n        ma = ma%mi;\n        if(x>y) {\n            x = ma;\n            y = mi;\n        }\n        else {\n            x = mi;\n            y = ma;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 12",
          "code": "while(true)\n    {\n        ll mi = min(x,y),ma = max(x,y);\n        if(ma%mi == 0)\n        {\n            ll times = ma/mi - 1;\n            cout<<to_string(times);\n            if(x>y)\n                cout<<\"A\";\n            else\n                cout<<\"B\";\n            return 0;\n        }\n        ll times = ma/mi;\n        cout<<to_string(times);\n        if(x>y)\n            cout<<\"A\";\n        else\n            cout<<\"B\";\n        ma = ma%mi;\n        if(x>y) {\n            x = ma;\n            y = mi;\n        }\n        else {\n            x = mi;\n            y = ma;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 13",
          "code": "long sum_d = 0; /* be careful, don't let it overflow */\nfor (int j = i+1; j < N; j++) {\n    if (gone[j]) continue;\n\n    p[j] -= sum_d;\n    if (p[j] < 0) {\n        gone[j] = 1;\n        sum_d += d[j];\n        if (sum_d > maxV)\n            sum_d = maxV + 1; /* XXX p == 0 won't make the kid run */\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 14",
          "code": "long sum_d = 0; /* be careful, don't let it overflow */\nfor (int j = i+1; j < N; j++) {\n    if (gone[j]) continue;\n\n    p[j] -= sum_d;\n    if (p[j] < 0) {\n        gone[j] = 1;\n        sum_d += d[j];\n        if (sum_d > maxV)\n            sum_d = maxV + 1; /* XXX p == 0 won't make the kid run */\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 15",
          "code": "5\n3 1 10\n3 1 10\n1 5 1\n1 1 5\n1 1 8\n\noutput\n2\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 16",
          "code": "5\n3 1 10\n3 1 10\n1 5 1\n1 1 5\n1 1 8\n\noutput\n2\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 1",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 2",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 3",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 4",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 500000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 2, 10000000, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 500000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 2, 10000000, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 500000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 2, 10000000, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int max_price = opt<int>(\"max_price\", 10000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_same\") {\n        int price = rnd.next(2, max_price);\n        for (int i = 0; i < n; ++i) {\n            a[i] = price;\n        }\n    } else if (type == \"primes\") {\n        // Generate n primes starting from 2\n        int limit = 10000000;\n        vector<bool> is_prime(limit+1, true);\n        vector<int> primes;\n        is_prime[0]=is_prime[1]=false;\n        for (int i = 2; i <= limit && (int)primes.size() < n; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                if (i <= limit / i) { // avoid integer overflow\n                    for (int j = i*i; j <= limit; j+=i) {\n                        is_prime[j] = false;\n                    }\n                } else {\n                    for (int j = 2*i; j <= limit; j+=i) {\n                        is_prime[j] = false;\n                    }\n                }\n            }\n        }\n        if ((int)primes.size() < n) {\n            // Not enough primes in the limit, fill the rest with random primes\n            for (int i = primes.back() + 1; (int)primes.size() < n; ++i) {\n                bool is_p = true;\n                for (int p : primes) {\n                    if (p * p > i) break;\n                    if (i % p == 0) {\n                        is_p = false;\n                        break;\n                    }\n                }\n                if (is_p) primes.push_back(i);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = primes[i];\n        }\n    } else if (type == \"all_even\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 2 * rnd.next(1, max_price/2);\n        }\n    } else if (type == \"two_primes\") {\n        int p = 2;\n        int q = 3;\n        for (int i = 0; i < n; ++i) {\n            if (i%2 == 0)\n                a[i] = p;\n            else\n                a[i] = q;\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(2, max_price);\n        }\n    } else if (type == \"half_same\") {\n        int price = rnd.next(2, max_price);\n        for (int i = 0; i < n/2; ++i) {\n            a[i] = price;\n        }\n        for (int i = n/2; i < n; ++i) {\n            a[i] = rnd.next(2, max_price);\n        }\n    } else if (type == \"max_varied\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 2 + i % (max_price - 2);\n        }\n    } else {\n        // default random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(2, max_price);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i+1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int max_price = opt<int>(\"max_price\", 10000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_same\") {\n        int price = rnd.next(2, max_price);\n        for (int i = 0; i < n; ++i) {\n            a[i] = price;\n        }\n    } else if (type == \"primes\") {\n        // Generate n primes starting from 2\n        int limit = 10000000;\n        vector<bool> is_prime(limit+1, true);\n        vector<int> primes;\n        is_prime[0]=is_prime[1]=false;\n        for (int i = 2; i <= limit && (int)primes.size() < n; ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                if (i <= limit / i) { // avoid integer overflow\n                    for (int j = i*i; j <= limit; j+=i) {\n                        is_prime[j] = false;\n                    }\n                } else {\n                    for (int j = 2*i; j <= limit; j+=i) {\n                        is_prime[j] = false;\n                    }\n                }\n            }\n        }\n        if ((int)primes.size() < n) {\n            // Not enough primes in the limit, fill the rest with random primes\n            for (int i = primes.back() + 1; (int)primes.size() < n; ++i) {\n                bool is_p = true;\n                for (int p : primes) {\n                    if (p * p > i) break;\n                    if (i % p == 0) {\n                        is_p = false;\n                        break;\n                    }\n                }\n                if (is_p) primes.push_back(i);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = primes[i];\n        }\n    } else if (type == \"all_even\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 2 * rnd.next(1, max_price/2);\n        }\n    } else if (type == \"two_primes\") {\n        int p = 2;\n        int q = 3;\n        for (int i = 0; i < n; ++i) {\n            if (i%2 == 0)\n                a[i] = p;\n            else\n                a[i] = q;\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(2, max_price);\n        }\n    } else if (type == \"half_same\") {\n        int price = rnd.next(2, max_price);\n        for (int i = 0; i < n/2; ++i) {\n            a[i] = price;\n        }\n        for (int i = n/2; i < n; ++i) {\n            a[i] = rnd.next(2, max_price);\n        }\n    } else if (type == \"max_varied\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 2 + i % (max_price - 2);\n        }\n    } else {\n        // default random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(2, max_price);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i+1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type all_same\n./gen -n 2 -type primes\n./gen -n 2 -type all_even\n./gen -n 2 -type two_primes\n./gen -n 2 -type random\n./gen -n 10 -type all_same\n./gen -n 10 -type primes\n./gen -n 10 -type all_even\n./gen -n 10 -type two_primes\n./gen -n 10 -type random\n./gen -n 100 -type all_same\n./gen -n 100 -type primes\n./gen -n 100 -type all_even\n./gen -n 100 -type two_primes\n./gen -n 100 -type random\n./gen -n 1000 -type all_same\n./gen -n 1000 -type primes\n./gen -n 1000 -type all_even\n./gen -n 1000 -type two_primes\n./gen -n 1000 -type random\n./gen -n 10000 -type all_same\n./gen -n 10000 -type primes\n./gen -n 10000 -type all_even\n./gen -n 10000 -type two_primes\n./gen -n 10000 -type random\n./gen -n 500000 -type all_same\n./gen -n 500000 -type primes\n./gen -n 500000 -type all_even\n./gen -n 500000 -type two_primes\n./gen -n 500000 -type random\n./gen -n 500000 -type half_same\n./gen -n 500000 -type max_varied\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:35.221826",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "585/F",
      "title": "F. Digits of Number Pi",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains string s consisting of decimal digits (1 ≤ |s| ≤ 1000) that Vasily will use to search substrings in. According to hypothesis, this sequence of digis indeed occurs in the decimal representation of π, although we can't guarantee that.The second and third lines contain two positive integers x, y of the same length d (x ≤ y, 2 ≤ d ≤ 50). Numbers x, y do not contain leading zeroes.",
      "output_spec": "OutputPrint how many numbers in the segment from x to y that are half-occurrences in s modulo 109 + 7.",
      "sample_tests": "ExamplesInputCopy021019OutputCopy2InputCopy0234567891019OutputCopy9InputCopy314159265351029OutputCopy20",
      "description": "F. Digits of Number Pi\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains string s consisting of decimal digits (1 ≤ |s| ≤ 1000) that Vasily will use to search substrings in. According to hypothesis, this sequence of digis indeed occurs in the decimal representation of π, although we can't guarantee that.The second and third lines contain two positive integers x, y of the same length d (x ≤ y, 2 ≤ d ≤ 50). Numbers x, y do not contain leading zeroes.\n\nOutputPrint how many numbers in the segment from x to y that are half-occurrences in s modulo 109 + 7.\n\nInputCopy021019OutputCopy2InputCopy0234567891019OutputCopy9InputCopy314159265351029OutputCopy20\n\nInputCopy021019\n\nOutputCopy2\n\nInputCopy0234567891019\n\nOutputCopy9\n\nInputCopy314159265351029\n\nOutputCopy20",
      "solutions": [
        {
          "title": "Codeforces Round #325 - Codeforces",
          "content": "Hi, Codeforces!Codeforces Round #325 will take place on October 12, 2015 at 09:00 UTC for the first and second divisions. Please note that the round will start at unusual time!The problems of this round are taken from the Regional stage of the All-Russian school team programming olympiad that will be at the same time in Saratov, Russia. Lets wish school teams good luck on competition!The problemset for school olympiad differs from problems that will be on round. In addition in problemset for school olympiad there will be some problems, which are not included in the round and vice versa. So don't be frightened by the difficulty of problems given for school teams :-)The process of problems preapring was very interesting: we were reworking problem statements many times, adding tests, changing limits, even managed to change fully prepared problem with another (we had to stop the conveyor already printing problem statements :-)) Let's thank all who were preparing, helping in preparing, reading the problem statements, writing solutions: Adilbek adedalic Dalabaev, Roman Roms Glazov, Vladimir vovuh Petrov, Oleg Oleg_Smirnov Smirnov, Alexey Perforator Ripinen, Maxim Neon Mescheryakov, Ilya IlyaLos Los, Vitaliy gridnevvvit Gridnev, Danil danilka.pro Sagunov, Alexander fcspartakm Frolov, Pavel HolkinPV Kholkin, Igor Igor_Kudryashov Kudryashov, Elena elena Rogacheva, Dmitriy Nerevar Matov, Vitaliy kuviman Kudasov. Chairman of the jury of the Olympiad is Mikhail MikeMirzayanov Mirzayanov (also he is the author of some of tasks). I (Edvard Edvard Davtyan) prepared some tasks and coordinated the work of the authors. So we are a large team of writers (I hope I did not forget anyone)!Also let's thank Max Akhmedov (Zlobober), The-One-Who-Must-Not-Be-Named (if I am not wrong, he or she is right now solving the round problems) for their help in problems preparing, Maria Belova (Delinur) for translating problems in English and again Mikhail Mirzayanov (MikeMirzayanov) for the Codeforces and Polygon systems.You will have only two hours to solve six problems. The scoring distribution will be anounced a little before the round. I wish high rating to all participants! Good luck and have fun!P.S.: Also I want to wish good luck to the participants of the ACM ICPC Southern Subregional Programming Contest that will be held on Wednesday.UPD Due to technical reasons round is delayed by 10 minutes.UPD: In problem Subway roller there were tests with trains of length one. At this moment authors are discussing how much it troubled the round results. We are apologize to participants who had problems with that. We will announce our decision about this problem soon.UPD2: There were trains with length equal to one in tests for problem Subway Roller. Jury decided to accept the first right solution of each user that passed all tests except the wrong, also other submissions were ignored. In addition we accept all successed hacks, although the hack is not correct and the hacked solution passed all other tests. Contest will be rated, but any user who think that this situation is cardinally affected to his/her result can send me in 24 hours a message and jury will discuss the question to make round unrated only for that participant. We are apologize to participants one more time for this situation.UPD3: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20889",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3329
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces",
          "content": "586A - Alena's ScheduleThe problem has been prepared by adedalic.To solve this problem one should remove all leading and trailing zeroes from array and then calculate the number of ones and number of zeroes neighboured by ones. The sum of this values is the answer for the problem.Complexity: O(n).586B - Laurenty and ShopThe problem has been prepared by Oleg_Smirnov.Let's call some path ith if we start it by going i times left, then we cross the prospect and go left n - 1 - i times again. Let di be equal to the time we should wait on traffic lights while following i-th path. If we consider any way from the shop to home, it is equal (but reversed) to only path from home to the shop, meaning that we need to find two distinct paths from home to the shop. So the answer to the problem is the sum of the smallest and the second smallest values among di. One could easily calculate di using calculated di - 1, so di could be found in one for cycle.If we will consider only two minimum values among di, solution complexity will be O(n).Complexity: O(n).585A - Gennady the DentistThe problem has been prepared by Neon.Let's store for each child his current confidence value and a boolean indicating whether child had left the queue (or visited the dentist office) or not. Then one could easily process children one by one, considering only children who still are in the queue (using boolean array), and changing stored values.Such solution has complexity O(n2) and requires author's attention much, especially the case with possible confidence value overflowing. Of course there are much faster solutions not required in our case.585B - Phillip and TrainsThe problem has been prepared by IlyaLos.One could consider a graph with vertices corresponding to every (x, y) position. I should notice that train positions for each Phillip position are fully restorable from his y coordinate. Edge between vertices u and v means that we could get from position corresponding to u to position corresponding by v in one turn without moving onto a train cell or moving in a cell which will be occupied by some train before the next turn. All we need next is to find whether any finishing position is reachable from the only starting position (using BFS or DFS, or, as soon as graph is a DAG, dynamic programming).As soon as graph has O(n) vertices and O(n) edges, solution complexity equals to O(n).585C - Alice, Bob, Oranges and ApplesThe problem has been prepared by Edvard.Firstly, let's understand the process described in problem statement. If one would write a tree of a sum-pairs (x, y) with letters and , he would get the Stern–Brocot tree. Let the number of oranges be enumerator and the number of apples be denumerator of fraction. At every step we have two fractions (at first step they are ) and should replace exactly one of them with their mediant. In such way first fraction is first parent to the left from mediant while second fraction is parent to the right. The process described in statement is, this way, a process of finding a fraction in the Stern-Brocot tree, finishing when the current mediant is equal to current node in the tree and (x, y) pair is the fraction we are searching. This means that if , (x, y) does not correspond to any correct fraction and the answer is \"Impossible\". Other way, we could find it in the tree. If x > y, we should firstly go in the right subtree. Moreover, we could then consider we are searching from the root. If x < y, we should go left and next consider from the root. This gives us Euclidian algorithm, which could be realized to work in complexity.Complexity: O(logn).585D - Lizard Era: BeginningThe problem has been prepared by danilka.pro.To solve the problem we will use meet-in-the-middle approach. For we should consider all variants. Let in some variant approval values of three companions are a, b, c respectively. If we will consider some variant from other half (there are of them) and a', b', c' approval values, then to ``merge'' such two parts correctly, two conditions a - b = b' - a' и b - c = c' - b' must be true (a + a' = b + b' = c + c' is true), and the value we are maximizing is a + a'.This way, to solve the task one could consider every variant from the first half and store for every possible pair (a - b, b - c) the maximum a value achievable (using, for example, the structure or any fast sorting algorithm). If one would then consider every variant from the second half, he just need to find (b' - a', c' - b') pair in the structure to get the maximum a value if possible and update answer with a + a' value. Answer restoring is pretty same to the algorithm above.Such solution has complexity.585E - Present for Vitalik the Philatelist The problem has been prepared by gridnevvvit.Let's calculate the number of subsets with gcd equal to 1 — value A. Let's do that using principle of inclusions-exclusions: firstly we say that all subsets is good. The total number of subsets is equal to 2n. Now let's subtract subsets with gcd divisible by 2. The number of that subsets is equal to 2cnt2 - 1 (cnti is the number of numbers that is divisable by i). Next we should subtract 2cnt3 - 1. Subsets with gcd divisible by 4 we already counted with number two. Next we should subtract 2cnt5 - 1. Now we should notice that subsets with gcd divisible by 6 we already processed twice: firstly with number 2, then with — 3, so let's add the number of these subsets 2cnt6 - 1. If we continue this process we will get, that for all numbers d we should add the value μ(d)(2cntd - 1), where μ(d) is equals to 0, if d is divisible by square of some prime, 1, if the number of primes in factorization of d is even and  - 1 in other case. So the numbers that is divisible by square of some prime we can ignore, because they have coefficient 0. To calculate values cnti we should factorize all numbers and iterate over 2k divisors with value μ(d) ≠ 0. Now it's easy to see, that the number of subsets with gcd greater than 1 equals to B = 2n - A. To solve the problem let's fix the stamp that Vitaliy will buy ai. Let's recalculate the number B for array a without element ai. To do that we should only subtract those terms that was affected by number ai. We can do that in 2k, where k is the number of primes in factorization of the number ai. It's easy to see that only the subsets with gcd greater than 1, but not divisible by any divisor of ai, should we counted in answer. To calculate number of those subsets let's again use the principle of inclusions-exclusions. For every divisor d of ai let's subtract the value μ (2cntd - 1) from B. So now we got Bi — the number of subsets with gcd greater than 1, but coprime with ai. The answer to problem is the sum over all Bi. The maximum number of primes in factorization of number not greater than 107 is equal to 8. We can factorize all numbers from 1 to n in linear time by algorithm for finding the smallest divisors for all intergers from 1 to n, or by sieve of Eratosthenes in O(nloglogn) time.Complexity: O(C + n2K), where , K — is the largest number of primes in factorization of ai.585F - Digits of Number PiThe problem has been prepared by Edvard.Consider all substrings of string s with length . Let's add them all to trie data structure, calculate failure links and build automata by digits. We can do that in linear time using Aho-Korasik algorithm. Now to solve the problem we should calculate dp zi, v, b1, b2, b. State of dp is described by five numbers: i — number of digits, that we already put to our number, v — in which vertex of trie we are, b1 — equals to one if the prefix that we built is equals to prefix of x, b2 — equals to one if the prefix that we built is equals to prefix of y, b — equals to one if we already have some substring with length on the prexif that we built. The value of dp is the number of ways to built prefix with the given set of properties. To update dp we should iterate over the digit that we want to add to prefix, check that we still is in segment [x, y], go from vertex v to the next vertex in automata. So the answer is the sum by all v, b1, b2 zb, v, v1, v2, 1.Complexity: O(nd2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20898",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 585\\s*F"
          },
          "content_length": 8145
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #325 - Codeforces - Code 1",
          "code": "int n = 4000;\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        cout << \"1000000 1000000 1\\n\";\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 2",
          "code": "int n = 4000;\n    cout << n << \"\\n\";\n    for (int i = 0; i < n; ++i) {\n        cout << \"1000000 1000000 1\\n\";\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 3",
          "code": "Input\n6\n3 1 1\n1 3 2\n10 4 6\n1 1 2\n1 1 2\n1 1 14\nOutput \n2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 4",
          "code": "Input\n6\n3 1 1\n1 3 2\n10 4 6\n1 1 2\n1 1 2\n1 1 14\nOutput \n2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 5",
          "code": "string num;\n\t\twhile(ans0[i].ss > 0) {\n\t\t\tnum +=('0'+ans0[i].ss%10);\n\t\t\tans0[i].ss /=10;}\n\t\tans +=num;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 6",
          "code": "string num;\n\t\twhile(ans0[i].ss > 0) {\n\t\t\tnum +=('0'+ans0[i].ss%10);\n\t\t\tans0[i].ss /=10;}\n\t\tans +=num;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 7",
          "code": "1\n5 3\n..A..\ns.B..\n..C..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 8",
          "code": "1\n5 3\n..A..\ns.B..\n..C..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 9",
          "code": "while(true)\n    {\n        ll mi = min(x,y),ma = max(x,y);\n        if(ma%mi == 0)\n        {\n            ll times = ma/mi - 1;\n            cout<<to_string(times);\n            if(x>y)\n                cout<<\"A\";\n            else\n                cout<<\"B\";\n            return 0;\n        }\n        ll times = ma/mi;\n        cout<<to_string(times);\n        if(x>y)\n            cout<<\"A\";\n        else\n            cout<<\"B\";\n        ma = ma%mi;\n        if(x>y) {\n            x = ma;\n            y = mi;\n        }\n        else {\n            x = mi;\n            y = ma;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 10",
          "code": "while(true)\n    {\n        ll mi = min(x,y),ma = max(x,y);\n        if(ma%mi == 0)\n        {\n            ll times = ma/mi - 1;\n            cout<<to_string(times);\n            if(x>y)\n                cout<<\"A\";\n            else\n                cout<<\"B\";\n            return 0;\n        }\n        ll times = ma/mi;\n        cout<<to_string(times);\n        if(x>y)\n            cout<<\"A\";\n        else\n            cout<<\"B\";\n        ma = ma%mi;\n        if(x>y) {\n            x = ma;\n            y = mi;\n        }\n        else {\n            x = mi;\n            y = ma;\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 11",
          "code": "long sum_d = 0; /* be careful, don't let it overflow */\nfor (int j = i+1; j < N; j++) {\n    if (gone[j]) continue;\n\n    p[j] -= sum_d;\n    if (p[j] < 0) {\n        gone[j] = 1;\n        sum_d += d[j];\n        if (sum_d > maxV)\n            sum_d = maxV + 1; /* XXX p == 0 won't make the kid run */\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 12",
          "code": "long sum_d = 0; /* be careful, don't let it overflow */\nfor (int j = i+1; j < N; j++) {\n    if (gone[j]) continue;\n\n    p[j] -= sum_d;\n    if (p[j] < 0) {\n        gone[j] = 1;\n        sum_d += d[j];\n        if (sum_d > maxV)\n            sum_d = maxV + 1; /* XXX p == 0 won't make the kid run */\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 13",
          "code": "5\n3 1 10\n3 1 10\n1 5 1\n1 1 5\n1 1 8\n\noutput\n2\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #325 - Codeforces - Code 14",
          "code": "5\n3 1 10\n3 1 10\n1 5 1\n1 1 5\n1 1 8\n\noutput\n2\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20889",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 1",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 2",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 3",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 4",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readToken(\"[0-9]+\", \"s\");\n    inf.readEoln();\n    ensuref((int)s.length() >= 1 && (int)s.length() <= 1000, \"Length of s must be between 1 and 1000, but is %d\", (int)s.length());\n\n    string x = inf.readToken(\"[0-9]+\", \"x\");\n    inf.readEoln();\n    ensuref((int)x.length() >= 1, \"Length of x must be at least 1\");\n    ensuref(x[0] != '0', \"x must not have leading zeros\");\n\n    string y = inf.readToken(\"[0-9]+\", \"y\");\n    inf.readEoln();\n    ensuref((int)y.length() >= 1, \"Length of y must be at least 1\");\n    ensuref(y[0] != '0', \"y must not have leading zeros\");\n\n    ensuref(x.length() == y.length(), \"x and y must have the same length\");\n    int d = x.length();\n    ensuref(d >= 2 && d <= 50, \"Length of x and y must be between 2 and 50, but is %d\", d);\n\n    ensuref(x <= y, \"x must be less than or equal to y\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readToken(\"[0-9]+\", \"s\");\n    inf.readEoln();\n    ensuref((int)s.length() >= 1 && (int)s.length() <= 1000, \"Length of s must be between 1 and 1000, but is %d\", (int)s.length());\n\n    string x = inf.readToken(\"[0-9]+\", \"x\");\n    inf.readEoln();\n    ensuref((int)x.length() >= 1, \"Length of x must be at least 1\");\n    ensuref(x[0] != '0', \"x must not have leading zeros\");\n\n    string y = inf.readToken(\"[0-9]+\", \"y\");\n    inf.readEoln();\n    ensuref((int)y.length() >= 1, \"Length of y must be at least 1\");\n    ensuref(y[0] != '0', \"y must not have leading zeros\");\n\n    ensuref(x.length() == y.length(), \"x and y must have the same length\");\n    int d = x.length();\n    ensuref(d >= 2 && d <= 50, \"Length of x and y must be between 2 and 50, but is %d\", d);\n\n    ensuref(x <= y, \"x must be less than or equal to y\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readToken(\"[0-9]+\", \"s\");\n    inf.readEoln();\n    ensuref((int)s.length() >= 1 && (int)s.length() <= 1000, \"Length of s must be between 1 and 1000, but is %d\", (int)s.length());\n\n    string x = inf.readToken(\"[0-9]+\", \"x\");\n    inf.readEoln();\n    ensuref((int)x.length() >= 1, \"Length of x must be at least 1\");\n    ensuref(x[0] != '0', \"x must not have leading zeros\");\n\n    string y = inf.readToken(\"[0-9]+\", \"y\");\n    inf.readEoln();\n    ensuref((int)y.length() >= 1, \"Length of y must be at least 1\");\n    ensuref(y[0] != '0', \"y must not have leading zeros\");\n\n    ensuref(x.length() == y.length(), \"x and y must have the same length\");\n    int d = x.length();\n    ensuref(d >= 2 && d <= 50, \"Length of x and y must be between 2 and 50, but is %d\", d);\n\n    ensuref(x <= y, \"x must be less than or equal to y\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generateRandomNumber(int length) {\n    string s = \"\";\n    for (int i = 0; i < length; ++i){\n        s += '0' + rnd.next(10);\n    }\n    // Ensure no leading zeros\n    if (s[0] == '0') s[0] = '1' + rnd.next(9);\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int sLength = opt<int>(\"sLength\", rnd.next(1, 1000));\n    int d = opt<int>(\"d\", rnd.next(2, 50));\n    string type = opt<string>(\"type\", \"random\");\n\n    string s, x, y;\n\n    if (type == \"random\") {\n        s = \"\";\n        for(int i = 0; i < sLength; ++i)\n            s += '0' + rnd.next(10);\n        x = generateRandomNumber(d);\n        y = generateRandomNumber(d);\n        if (x > y) swap(x, y);\n    } else if (type == \"max_s\") {\n        sLength = 1000;\n        s = \"\";\n        for(int i = 0; i < sLength; ++i)\n            s += '0' + rnd.next(10);\n        x = generateRandomNumber(d);\n        y = generateRandomNumber(d);\n        if (x > y) swap(x, y);\n    } else if (type == \"min_s\") {\n        sLength = 1;\n        s = \"\";\n        s += '0' + rnd.next(10);\n        x = generateRandomNumber(d);\n        y = generateRandomNumber(d);\n        if (x > y) swap(x, y);\n    } else if (type == \"x_in_s\") {\n        x = generateRandomNumber(d);\n        int substringLength = (d + 1) / 2; // ceil(d/2)\n        int pos = rnd.next(0, max(0, sLength - substringLength));\n        s = \"\";\n        for(int i = 0; i < sLength; ++i) {\n            if (i == pos) {\n                s += x.substr(0, substringLength);\n                i += substringLength - 1;\n            } else {\n                s += '0' + rnd.next(10);\n            }\n        }\n        y = generateRandomNumber(d);\n        if (x > y) swap(x, y);\n    } else if (type == \"x_not_in_s\") {\n        x = generateRandomNumber(d);\n        int substringLength = (d + 1) / 2; // ceil(d/2)\n        // Generate s that does not contain any substring of length substringLength from x\n        s = \"\";\n        set<string> forbiddenSubstrings;\n        for (int i = 0; i + substringLength <= d; ++i) {\n            forbiddenSubstrings.insert(x.substr(i, substringLength));\n        }\n        for(int i = 0; i < sLength; ++i) {\n            char digit;\n            do {\n                digit = '0' + rnd.next(10);\n            } while (i >= substringLength - 1 &&\n                     forbiddenSubstrings.count(s.substr(i - substringLength + 1, substringLength -1) + digit));\n            s += digit;\n        }\n        y = generateRandomNumber(d);\n        if (x > y) swap(x, y);\n    } else if (type == \"x_equal_y\") {\n        x = generateRandomNumber(d);\n        y = x;\n        s = \"\";\n        for(int i = 0; i < sLength; ++i)\n            s += '0' + rnd.next(10);\n    } else if (type == \"max_d\") {\n        d = 50;\n        x = generateRandomNumber(d);\n        y = generateRandomNumber(d);\n        if (x > y) swap(x, y);\n        sLength = rnd.next(1, 1000);\n        s = \"\";\n        for(int i = 0; i < sLength; ++i)\n            s += '0' + rnd.next(10);\n    } else if (type == \"min_d\") {\n        d = 2;\n        x = generateRandomNumber(d);\n        y = generateRandomNumber(d);\n        if (x > y) swap(x, y);\n        sLength = rnd.next(1, 1000);\n        s = \"\";\n        for(int i = 0; i < sLength; ++i)\n            s += '0' + rnd.next(10);\n    } else if (type == \"zeros\") {\n        s = string(sLength, '0');\n        x = generateRandomNumber(d);\n        y = generateRandomNumber(d);\n        if (x > y) swap(x, y);\n    } else if (type == \"nines\") {\n        s = string(sLength, '9');\n        x = generateRandomNumber(d);\n        y = generateRandomNumber(d);\n        if (x > y) swap(x, y);\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n    // Output x and y, each on its own line\n    printf(\"%s\\n\", x.c_str());\n    printf(\"%s\\n\", y.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generateRandomNumber(int length) {\n    string s = \"\";\n    for (int i = 0; i < length; ++i){\n        s += '0' + rnd.next(10);\n    }\n    // Ensure no leading zeros\n    if (s[0] == '0') s[0] = '1' + rnd.next(9);\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int sLength = opt<int>(\"sLength\", rnd.next(1, 1000));\n    int d = opt<int>(\"d\", rnd.next(2, 50));\n    string type = opt<string>(\"type\", \"random\");\n\n    string s, x, y;\n\n    if (type == \"random\") {\n        s = \"\";\n        for(int i = 0; i < sLength; ++i)\n            s += '0' + rnd.next(10);\n        x = generateRandomNumber(d);\n        y = generateRandomNumber(d);\n        if (x > y) swap(x, y);\n    } else if (type == \"max_s\") {\n        sLength = 1000;\n        s = \"\";\n        for(int i = 0; i < sLength; ++i)\n            s += '0' + rnd.next(10);\n        x = generateRandomNumber(d);\n        y = generateRandomNumber(d);\n        if (x > y) swap(x, y);\n    } else if (type == \"min_s\") {\n        sLength = 1;\n        s = \"\";\n        s += '0' + rnd.next(10);\n        x = generateRandomNumber(d);\n        y = generateRandomNumber(d);\n        if (x > y) swap(x, y);\n    } else if (type == \"x_in_s\") {\n        x = generateRandomNumber(d);\n        int substringLength = (d + 1) / 2; // ceil(d/2)\n        int pos = rnd.next(0, max(0, sLength - substringLength));\n        s = \"\";\n        for(int i = 0; i < sLength; ++i) {\n            if (i == pos) {\n                s += x.substr(0, substringLength);\n                i += substringLength - 1;\n            } else {\n                s += '0' + rnd.next(10);\n            }\n        }\n        y = generateRandomNumber(d);\n        if (x > y) swap(x, y);\n    } else if (type == \"x_not_in_s\") {\n        x = generateRandomNumber(d);\n        int substringLength = (d + 1) / 2; // ceil(d/2)\n        // Generate s that does not contain any substring of length substringLength from x\n        s = \"\";\n        set<string> forbiddenSubstrings;\n        for (int i = 0; i + substringLength <= d; ++i) {\n            forbiddenSubstrings.insert(x.substr(i, substringLength));\n        }\n        for(int i = 0; i < sLength; ++i) {\n            char digit;\n            do {\n                digit = '0' + rnd.next(10);\n            } while (i >= substringLength - 1 &&\n                     forbiddenSubstrings.count(s.substr(i - substringLength + 1, substringLength -1) + digit));\n            s += digit;\n        }\n        y = generateRandomNumber(d);\n        if (x > y) swap(x, y);\n    } else if (type == \"x_equal_y\") {\n        x = generateRandomNumber(d);\n        y = x;\n        s = \"\";\n        for(int i = 0; i < sLength; ++i)\n            s += '0' + rnd.next(10);\n    } else if (type == \"max_d\") {\n        d = 50;\n        x = generateRandomNumber(d);\n        y = generateRandomNumber(d);\n        if (x > y) swap(x, y);\n        sLength = rnd.next(1, 1000);\n        s = \"\";\n        for(int i = 0; i < sLength; ++i)\n            s += '0' + rnd.next(10);\n    } else if (type == \"min_d\") {\n        d = 2;\n        x = generateRandomNumber(d);\n        y = generateRandomNumber(d);\n        if (x > y) swap(x, y);\n        sLength = rnd.next(1, 1000);\n        s = \"\";\n        for(int i = 0; i < sLength; ++i)\n            s += '0' + rnd.next(10);\n    } else if (type == \"zeros\") {\n        s = string(sLength, '0');\n        x = generateRandomNumber(d);\n        y = generateRandomNumber(d);\n        if (x > y) swap(x, y);\n    } else if (type == \"nines\") {\n        s = string(sLength, '9');\n        x = generateRandomNumber(d);\n        y = generateRandomNumber(d);\n        if (x > y) swap(x, y);\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n    // Output x and y, each on its own line\n    printf(\"%s\\n\", x.c_str());\n    printf(\"%s\\n\", y.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen\n./gen -sLength 100 -d 10\n./gen -sLength 500 -d 20\n./gen -sLength 1000 -d 50\n./gen -type max_s -d 25\n./gen -type min_s -d 25\n./gen -type x_in_s -sLength 100 -d 10\n./gen -type x_not_in_s -sLength 100 -d 10\n./gen -type x_equal_y -sLength 100 -d 10\n./gen -type max_d -sLength 500\n./gen -type min_d -sLength 500\n./gen -sLength 1 -d 2\n./gen -sLength 10 -d 5\n./gen -sLength 100 -d 10\n./gen -sLength 1000 -d 20\n./gen -type x_equal_y -sLength 100 -d 15\n./gen -sLength 200 -d 11\n./gen -sLength 200 -d 12\n./gen -sLength 500 -d 50\n./gen -type random -sLength 1000 -d 30\n./gen -type zeros -sLength 100 -d 10\n./gen -type nines -sLength 100 -d 10\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:37.304394",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "586/A",
      "title": "A. Расписание Алёны",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных находится целое положительное число n (1 ≤ n ≤ 100) — количество пар в университете. Во второй строке находятся n чисел ai (0 ≤ ai ≤ 1). Число ai равно 0, если у Алёны нет i-го занятия, и равно 1 в противном случае. Числа a1, a2, ..., an разделены пробелами.",
      "output_spec": "Выходные данныеВыведите одно число — количество пар, во время которых Алёна будет находиться в университете.",
      "sample_tests": "ПримерыВходные данныеСкопировать50 1 0 1 1Выходные данныеСкопировать4Входные данныеСкопировать71 0 1 0 0 1 0Выходные данныеСкопировать4Входные данныеСкопировать10Выходные данныеСкопировать0",
      "description": "A. Расписание Алёны\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных находится целое положительное число n (1 ≤ n ≤ 100) — количество пар в университете. Во второй строке находятся n чисел ai (0 ≤ ai ≤ 1). Число ai равно 0, если у Алёны нет i-го занятия, и равно 1 в противном случае. Числа a1, a2, ..., an разделены пробелами.\n\nВходные данные\n\nВыходные данныеВыведите одно число — количество пар, во время которых Алёна будет находиться в университете.\n\nВыходные данные\n\nВходные данныеСкопировать50 1 0 1 1Выходные данныеСкопировать4Входные данныеСкопировать71 0 1 0 0 1 0Выходные данныеСкопировать4Входные данныеСкопировать10Выходные данныеСкопировать0\n\nВходные данныеСкопировать50 1 0 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать71 0 1 0 0 1 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Алёна будет находиться в университете со второй по пятую пару включительно, причем во время третьей пары она будет находиться в университете в ожидании следующего занятия.В последнем примере у Алены нет ни одного занятия, поэтому она проведёт всё время дома.",
      "solutions": [
        {
          "title": "Разбор Codeforces Round #325 - Codeforces",
          "content": "586A - Расписание АлёныЗадачу подготовил adedalic.В этой задаче сначала нужно было выкинуть все нули на префиксе и суффиксе строки, после чего ответ был равен количеству единиц плюс количество нулей с двух сторон от которых стоят единицы. Асимптотическая сложность решения: O(n).586B - Лаврентий и магазинЗадачу подготовил Oleg_Smirnov.Назовем путь i-м (0 ≤ i ≤ n - 1), если мы, выходя из дома, сначала i раз идем налево, потом переходим проспект и снова n - 1 - i раз идем налево. Введем обозначение di — время, которое нам придется ждать на светофорах на i-м пути. Если рассмотреть путь из магазина домой с конца, то получится пути из дома в магазиг, поэтому искомый путь есть два разных пути из дома в магазин. Значит ответом на задачу является сумма наименьшего и второго по величине значения di. Значение di легко пересчитывается из значения di - 1, таким образом все di можно посчитать за один проход.Асимптотическая сложность решения: O(n).585A - Стоматолог ГеннадийЗадачу подготовил Neon.Заведем очередь в которой, будут находится дети. На каждой итерации решения пройдем по всем детям, если есть ребенок с отрицательной решимостью удалим его из очереди, а из решимостей детей с большими номерами вычтем di. Если все дети в очереди имеют решимость не меньше нуля, возьмем первого ребенка из очереди, а от решимостей остальных вычтем арифметическую прогрессию, как это описывается в условии.Асимптотическая сложность решения: O(n2).585B - Филипп и поездаЗадачу подготовил IlyaLos.В задаче требовалось просто промоделировать игру. Это можно сделать с помощью обхода в глубину, ширину или динамического программирования. Состоянием является пара чисел x, y — позиция Филиппа в туннеле, а значением или в зависимости от того, можем ли мы попасть из стартовой позиции в x, y. Положения поездов в каждый момент времени определяются однозначно.Асимптотическая сложность решения: O(n).585C - Алиса, Боб, Апельсины и ЯблокиЗадачу подготовил Edvard.Поймем для начала, что означает процесс описанный в условии. Если нарисовать дерево переходов по буквам и , то получится дерево Штерна-Броко. Пусть апельсины это значения знаменателя дроби, а яблоки — числителя. На каждом шагу у нас есть две дроби (изначально ) и мы заменяем либо первую дробь на их медианту, либо вторую. Таким образом, первая дробь есть первый предок влево от медианты, а вторая — первый предок вправо. Таким образом, искомый процесс это просто процесс поиска дроби в дереве Штерна-Броко, который завершается тем, что текущая медианта совпадает с дробью, которую мы ищем (момент окончания игры, описанный в условии). Значит, числа x, y заданные в условии это просто дробь, которую мы ищем. Отсюда следует, что ответа не существует, если x не взаимнопросто с y (поскольку таким дробей нет в дереве Штерна-Броко). Пусть теперь мы хотим найти дробь в дереве. Понятно, что если x > y, то мы сначала перейдем в правую ветку. Более того мы можем считать, что теперь ищем дробь и никуда не спускались. Если же x < y, то нам нужно спуситься в левую ветку и можно считать, что мы ищем дробь и пока никуда не спускались. Эти рассуждения легко формализовать, чтобы получить строгое доказательство. Таким образом, решение задачи сводится к выполнению алгоритма Евклида для пары чисел x, y. Как известно время работы алгоритма Евклида O(logn) (дольше всего алгоритм Евклида работает на двух последовательных числах Фибоначчи), значит длина ответа тоже растет как логарифм.Асимптотическая сложность решения: O(logn).585D - Lizard Era: BeginningЗадачу подготовил danilka.pro.Для решения этой задачи воспользуемся приемом . А именно переберем для первых (первая половина) заданий с какими спутницами главный герой будет путешествовать. Пусть при этом симпатия первой спутницы оказалась равна a, второй — b, а третьей c. Пусть существует способ выбрать спутниц для последующих (вторая половина) заданий так и пусть симпатии при этом будут равны a', b', c'. Тогда, чтобы по всем заданиям суммы симпатий были одинаковы необходимо и достаточно, чтобы a - b = b' - a' и b - c = c' - b'. Теперь для решения задачи достаточно перебрать первую половину и сохранить в некоторой структуре данных тройки чисел a - b, b - c, a (третье число нужно для максимизации ответа в случае равенства). Далее нужно перебрать вторую половину и найти в структуре данных значения b' - a', c' - b', m, где m — максимальное третье значение которое есть в структуре данных. В качестве структуры данных можно использовать map < pair < int, int > , int >  в языке C++, первые два числа это значение a - b, b - c, а третье — максимальное a соответствующее первым двум. Также можно все тройки сложить в один большой массив, отсортировать его и бинарным поиском находить необходимые значения.Асимптотическая сложность решения: , где logC — константа, появляющаяся вместе со структурой данных.585E - Подарок для филателиста ВиталикаЗадачу подготовил gridnevvvit.Пусть мы хотим посчитать количество подмножеств с НОД равным 1 — число A. Посчитаем это количество с помощью формулы включений-исключений: сначала скажем, что все подмножества нам подходят. Таких подмножеств 2n. Теперь вычтем подмножества с НОД кратным 2. Количество таких множеств 2cnt2 - 1, где cnti — количество чисел, делящихся на i. Далее вычитаем 2cnt3 - 1. Подмножества с НОД кратным 4 мы учли вместе с двойкой. Далее вычитаем 2cnt5 - 1. Теперь заметим, что подмножества с НОД кратным 6 мы вычли уже дважды: сначала с двойкой, затем с тройкой, поэтому давайте прибавим количество таких подмножеств 2cnt6 - 1. Продолжая этот процесс получаем, что для числа d, к ответу нужно прибавить величину μ(d)(2cntd - 1), где μ(d) равно 0, если d делится на полный квадрат, 1, если количество простых в факторизации d четно и  - 1 в противном случае. Значит числа, делящиеся на полный квадрат мы можем не суммировать, поскольку они входят с коэффициентом 0. Для подсчета значений cnti достаточно факторизовать все числа и для каждого за 2k перебрать делитель, со значением μ(d) ≠ 0. Теперь легко понять, что количество подмножеств с НОД большим 1 равно B = 2n - A. Теперь для решения задачи давайте переберем марку, которую купит Виталик ai. Пересчитаем число B так, как если бы числа ai не было в множестве. Для этого нужно просто вычесть те слагаемые на которые повлияло число ai. Это можно сделать за 2k, где k — количество простых в факторизации числа ai (снова нужно перебрать делители ai со значением μ(d) ≠ 0). Теперь поймем какие подмножества дадут НОД равный 1 вместе с выбранной маркой. Понятно это те подмножества НОД которых больше 1, но при этом не делится ни на один делитель ai. Для этого снова воспользуемся формулой включений-исключений. Для каждого делителя d числа ai вычтем из B значение μ(d)(2cntd - 1). Таким образом, мы получим количество способов Bi выбрать подмножество c НОД большим 1, но при это взаимнопростым с ai. Ответом на задачу является сумма всех Bi. Наибольшее количество простых в факторизации числа не превосходящего 107 равно 8. Факторизацию чисел можно выполнить с помощью линейного алгоритма поиска минимального делителя чисел от 1 до n, либо с помощью решета Эратосфена за время O(nloglogn).Асимптотическая сложность решения: O(C + n2K), где , а K — наибольшее количество простых в факторизации чисел ai.585F - Знаки числа ПиЗадачу подготовил Edvard.Расмотрим все подстроки строки s длины . Сложим все эти строки в бор, посчитаем суффиксные ссылки и построим автомат по цифрам. Это можно сделать за линейное время с помощью алгоритма Ахо-Корасик. Теперь для решения задачи посчитаем динамику zi, v, b1, b2, b в котором состояние описывается пятеркой чисел: i — количество цифр которые мы уже поставили в искомом числе, которое встречается , v — в какой вершине бора мы находимся, b1 — равен ли префикс числа, которое мы набираем префиксу числа x, b2 — равен ли префикс числа, которое мы набираем префиксу числа y, b — находится ли некоторая подстрока длина на уже набранном префиксе в боре (значения b1, b2, b — равны либо 0, либо 1). Значением динамики является количество способов набрать префикс с заданным набором свойств. Для того, чтобы сделать переход нужно перебрать цифру, проверить что мы не вышли за границы отрезка [x, y], перейти от вершины v к следующей вершине по автомату и заданной цифре. Ответом является сумма по всем v, b1, b2 zb, v, v1, v2, 1.Асимптотическая сложность решения: O(nd2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20898",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 586\\s*A"
          },
          "content_length": 8320
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 1",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 2",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 3",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 4",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"all_zero\") {\n        /* All ai = 0 */\n        for(int i = 0; i < n; ++i)\n            ai[i] = 0;\n    } else if (type == \"all_one\") {\n        /* All ai = 1 */\n        for(int i = 0; i < n; ++i)\n            ai[i] = 1;\n    } else if (type == \"one_break\") {\n        /* One break of at least two zeros somewhere in the schedule */\n        /* Randomly decide where to put the break */\n        int break_start = rnd.next(1, n-2); // So that at least two zeros fit\n        int break_length = rnd.next(2, n - break_start);\n\n        for(int i = 0; i < n; ++i)\n            ai[i] = 1;\n\n        for(int i = break_start; i < break_start + break_length; ++i)\n            ai[i] = 0;\n\n    } else if (type == \"multiple_breaks\") {\n        /* Multiple breaks with varying lengths */\n        for(int i = 0; i < n; ++i)\n            ai[i] = 1;\n\n        int num_breaks = rnd.next(1, n / 2);\n        set<int> break_positions;\n        for(int b = 0; b < num_breaks; ++b) {\n            int break_start = rnd.next(1, n - 2);\n            int break_length = rnd.next(2, min(5, n - break_start));\n\n            for(int i = break_start; i < break_start + break_length; ++i)\n                if (i < n)\n                    ai[i] = 0;\n        }\n    } else if (type == \"starting_break\") {\n        /* zeros at the beginning */\n        int break_length = rnd.next(1, n-1);\n        for(int i = 0; i < n; ++i)\n            ai[i] = 1;\n        for(int i = 0; i < break_length; ++i)\n            ai[i] = 0;\n    } else if (type == \"ending_break\") {\n        /* zeros at the end */\n        int break_length = rnd.next(1, n-1);\n        for(int i = 0; i < n; ++i)\n            ai[i] = 1;\n        for(int i = n - break_length; i < n; ++i)\n            ai[i] = 0;\n    } else if (type == \"single_one\") {\n        /* Only one ai == 1 */\n        for(int i = 0; i < n; ++i)\n            ai[i] = 0;\n        int idx = rnd.next(0, n-1);\n        ai[idx] = 1;\n    } else if (type == \"alternating\") {\n        /* ai = [0,1,0,1,...] or [1,0,1,0,...] */\n        int start = rnd.next(0,1);\n        for(int i = 0; i < n; ++i)\n            ai[i] = (i + start) % 2;\n    } else {\n        /* Random ai */\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(0,1);\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output ai */\n    for(int i = 0; i < n; ++i) {\n        if(i > 0) printf(\" \");\n        printf(\"%d\", ai[i]);\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"all_zero\") {\n        /* All ai = 0 */\n        for(int i = 0; i < n; ++i)\n            ai[i] = 0;\n    } else if (type == \"all_one\") {\n        /* All ai = 1 */\n        for(int i = 0; i < n; ++i)\n            ai[i] = 1;\n    } else if (type == \"one_break\") {\n        /* One break of at least two zeros somewhere in the schedule */\n        /* Randomly decide where to put the break */\n        int break_start = rnd.next(1, n-2); // So that at least two zeros fit\n        int break_length = rnd.next(2, n - break_start);\n\n        for(int i = 0; i < n; ++i)\n            ai[i] = 1;\n\n        for(int i = break_start; i < break_start + break_length; ++i)\n            ai[i] = 0;\n\n    } else if (type == \"multiple_breaks\") {\n        /* Multiple breaks with varying lengths */\n        for(int i = 0; i < n; ++i)\n            ai[i] = 1;\n\n        int num_breaks = rnd.next(1, n / 2);\n        set<int> break_positions;\n        for(int b = 0; b < num_breaks; ++b) {\n            int break_start = rnd.next(1, n - 2);\n            int break_length = rnd.next(2, min(5, n - break_start));\n\n            for(int i = break_start; i < break_start + break_length; ++i)\n                if (i < n)\n                    ai[i] = 0;\n        }\n    } else if (type == \"starting_break\") {\n        /* zeros at the beginning */\n        int break_length = rnd.next(1, n-1);\n        for(int i = 0; i < n; ++i)\n            ai[i] = 1;\n        for(int i = 0; i < break_length; ++i)\n            ai[i] = 0;\n    } else if (type == \"ending_break\") {\n        /* zeros at the end */\n        int break_length = rnd.next(1, n-1);\n        for(int i = 0; i < n; ++i)\n            ai[i] = 1;\n        for(int i = n - break_length; i < n; ++i)\n            ai[i] = 0;\n    } else if (type == \"single_one\") {\n        /* Only one ai == 1 */\n        for(int i = 0; i < n; ++i)\n            ai[i] = 0;\n        int idx = rnd.next(0, n-1);\n        ai[idx] = 1;\n    } else if (type == \"alternating\") {\n        /* ai = [0,1,0,1,...] or [1,0,1,0,...] */\n        int start = rnd.next(0,1);\n        for(int i = 0; i < n; ++i)\n            ai[i] = (i + start) % 2;\n    } else {\n        /* Random ai */\n        for(int i = 0; i < n; ++i)\n            ai[i] = rnd.next(0,1);\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output ai */\n    for(int i = 0; i < n; ++i) {\n        if(i > 0) printf(\" \");\n        printf(\"%d\", ai[i]);\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_zero\n./gen -n 1 -type all_one\n\n./gen -n 1 -type single_one\n\n./gen -n 2 -type random\n./gen -n 2 -type single_one\n\n./gen -n 3 -type starting_break\n./gen -n 3 -type ending_break\n\n./gen -n 5 -type alternating\n\n./gen -n 10 -type all_zero\n./gen -n 10 -type all_one\n./gen -n 10 -type random\n\n./gen -n 20 -type single_one\n\n./gen -n 50 -type random\n./gen -n 50 -type one_break\n./gen -n 50 -type multiple_breaks\n./gen -n 50 -type starting_break\n./gen -n 50 -type ending_break\n./gen -n 50 -type alternating\n\n./gen -n 99 -type multiple_breaks\n./gen -n 100 -type multiple_breaks\n\n./gen -n 100 -type all_zero\n./gen -n 100 -type all_one\n\n./gen -n 100 -type random\n./gen -n 100 -type random\n\n./gen -n 100 -type one_break\n./gen -n 100 -type multiple_breaks\n./gen -n 100 -type starting_break\n./gen -n 100 -type ending_break\n./gen -n 100 -type single_one\n./gen -n 100 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:39.401346",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "586/B",
      "title": "B. Laurenty and Shop",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (2 ≤ n ≤ 50) — the number of houses in each row. Each of the next two lines contains n - 1 space-separated integer — values aij (1 ≤ aij ≤ 100). The last line contains n space-separated integers bj (1 ≤ bj ≤ 100).",
      "output_spec": "OutputPrint a single integer — the least total time Laurenty needs to wait at the crossroads, given that he crosses the avenue only once both on his way to the store and on his way back home.",
      "sample_tests": "ExamplesInputCopy41 2 33 2 13 2 2 3OutputCopy12InputCopy31 23 32 1 3OutputCopy11InputCopy2111 1OutputCopy4",
      "description": "B. Laurenty and Shop\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains integer n (2 ≤ n ≤ 50) — the number of houses in each row. Each of the next two lines contains n - 1 space-separated integer — values aij (1 ≤ aij ≤ 100). The last line contains n space-separated integers bj (1 ≤ bj ≤ 100).\n\nOutputPrint a single integer — the least total time Laurenty needs to wait at the crossroads, given that he crosses the avenue only once both on his way to the store and on his way back home.\n\nInputCopy41 2 33 2 13 2 2 3OutputCopy12InputCopy31 23 32 1 3OutputCopy11InputCopy2111 1OutputCopy4\n\nInputCopy41 2 33 2 13 2 2 3\n\nOutputCopy12\n\nInputCopy31 23 32 1 3\n\nOutputCopy11\n\nInputCopy2111 1\n\nOutputCopy4\n\nNoteThe first sample is shown on the figure above. In the second sample, Laurenty's path can look as follows:   Laurenty crosses the avenue, the waiting time is 3;  Laurenty uses the second crossing in the first row, the waiting time is 2;  Laurenty uses the first crossing in the first row, the waiting time is 1;  Laurenty uses the first crossing in the first row, the waiting time is 1;  Laurenty crosses the avenue, the waiting time is 1;  Laurenty uses the second crossing in the second row, the waiting time is 3.  In total we get that the answer equals 11.In the last sample Laurenty visits all the crossings, so the answer is 4.",
      "solutions": [
        {
          "title": "Разбор Codeforces Round #325 - Codeforces",
          "content": "586A - Alena's ScheduleThe problem has been prepared by adedalic.To solve this problem one should remove all leading and trailing zeroes from array and then calculate the number of ones and number of zeroes neighboured by ones. The sum of this values is the answer for the problem.Complexity: O(n).586B - Laurenty and ShopThe problem has been prepared by Oleg_Smirnov.Let's call some path ith if we start it by going i times left, then we cross the prospect and go left n - 1 - i times again. Let di be equal to the time we should wait on traffic lights while following i-th path. If we consider any way from the shop to home, it is equal (but reversed) to only path from home to the shop, meaning that we need to find two distinct paths from home to the shop. So the answer to the problem is the sum of the smallest and the second smallest values among di. One could easily calculate di using calculated di - 1, so di could be found in one for cycle.If we will consider only two minimum values among di, solution complexity will be O(n).Complexity: O(n).585A - Gennady the DentistThe problem has been prepared by Neon.Let's store for each child his current confidence value and a boolean indicating whether child had left the queue (or visited the dentist office) or not. Then one could easily process children one by one, considering only children who still are in the queue (using boolean array), and changing stored values.Such solution has complexity O(n2) and requires author's attention much, especially the case with possible confidence value overflowing. Of course there are much faster solutions not required in our case.585B - Phillip and TrainsThe problem has been prepared by IlyaLos.One could consider a graph with vertices corresponding to every (x, y) position. I should notice that train positions for each Phillip position are fully restorable from his y coordinate. Edge between vertices u and v means that we could get from position corresponding to u to position corresponding by v in one turn without moving onto a train cell or moving in a cell which will be occupied by some train before the next turn. All we need next is to find whether any finishing position is reachable from the only starting position (using BFS or DFS, or, as soon as graph is a DAG, dynamic programming).As soon as graph has O(n) vertices and O(n) edges, solution complexity equals to O(n).585C - Alice, Bob, Oranges and ApplesThe problem has been prepared by Edvard.Firstly, let's understand the process described in problem statement. If one would write a tree of a sum-pairs (x, y) with letters and , he would get the Stern–Brocot tree. Let the number of oranges be enumerator and the number of apples be denumerator of fraction. At every step we have two fractions (at first step they are ) and should replace exactly one of them with their mediant. In such way first fraction is first parent to the left from mediant while second fraction is parent to the right. The process described in statement is, this way, a process of finding a fraction in the Stern-Brocot tree, finishing when the current mediant is equal to current node in the tree and (x, y) pair is the fraction we are searching. This means that if , (x, y) does not correspond to any correct fraction and the answer is \"Impossible\". Other way, we could find it in the tree. If x > y, we should firstly go in the right subtree. Moreover, we could then consider we are searching from the root. If x < y, we should go left and next consider from the root. This gives us Euclidian algorithm, which could be realized to work in complexity.Complexity: O(logn).585D - Lizard Era: BeginningThe problem has been prepared by danilka.pro.To solve the problem we will use meet-in-the-middle approach. For we should consider all variants. Let in some variant approval values of three companions are a, b, c respectively. If we will consider some variant from other half (there are of them) and a', b', c' approval values, then to ``merge'' such two parts correctly, two conditions a - b = b' - a' и b - c = c' - b' must be true (a + a' = b + b' = c + c' is true), and the value we are maximizing is a + a'.This way, to solve the task one could consider every variant from the first half and store for every possible pair (a - b, b - c) the maximum a value achievable (using, for example, the structure or any fast sorting algorithm). If one would then consider every variant from the second half, he just need to find (b' - a', c' - b') pair in the structure to get the maximum a value if possible and update answer with a + a' value. Answer restoring is pretty same to the algorithm above.Such solution has complexity.585E - Present for Vitalik the Philatelist The problem has been prepared by gridnevvvit.Let's calculate the number of subsets with gcd equal to 1 — value A. Let's do that using principle of inclusions-exclusions: firstly we say that all subsets is good. The total number of subsets is equal to 2n. Now let's subtract subsets with gcd divisible by 2. The number of that subsets is equal to 2cnt2 - 1 (cnti is the number of numbers that is divisable by i). Next we should subtract 2cnt3 - 1. Subsets with gcd divisible by 4 we already counted with number two. Next we should subtract 2cnt5 - 1. Now we should notice that subsets with gcd divisible by 6 we already processed twice: firstly with number 2, then with — 3, so let's add the number of these subsets 2cnt6 - 1. If we continue this process we will get, that for all numbers d we should add the value μ(d)(2cntd - 1), where μ(d) is equals to 0, if d is divisible by square of some prime, 1, if the number of primes in factorization of d is even and  - 1 in other case. So the numbers that is divisible by square of some prime we can ignore, because they have coefficient 0. To calculate values cnti we should factorize all numbers and iterate over 2k divisors with value μ(d) ≠ 0. Now it's easy to see, that the number of subsets with gcd greater than 1 equals to B = 2n - A. To solve the problem let's fix the stamp that Vitaliy will buy ai. Let's recalculate the number B for array a without element ai. To do that we should only subtract those terms that was affected by number ai. We can do that in 2k, where k is the number of primes in factorization of the number ai. It's easy to see that only the subsets with gcd greater than 1, but not divisible by any divisor of ai, should we counted in answer. To calculate number of those subsets let's again use the principle of inclusions-exclusions. For every divisor d of ai let's subtract the value μ (2cntd - 1) from B. So now we got Bi — the number of subsets with gcd greater than 1, but coprime with ai. The answer to problem is the sum over all Bi. The maximum number of primes in factorization of number not greater than 107 is equal to 8. We can factorize all numbers from 1 to n in linear time by algorithm for finding the smallest divisors for all intergers from 1 to n, or by sieve of Eratosthenes in O(nloglogn) time.Complexity: O(C + n2K), where , K — is the largest number of primes in factorization of ai.585F - Digits of Number PiThe problem has been prepared by Edvard.Consider all substrings of string s with length . Let's add them all to trie data structure, calculate failure links and build automata by digits. We can do that in linear time using Aho-Korasik algorithm. Now to solve the problem we should calculate dp zi, v, b1, b2, b. State of dp is described by five numbers: i — number of digits, that we already put to our number, v — in which vertex of trie we are, b1 — equals to one if the prefix that we built is equals to prefix of x, b2 — equals to one if the prefix that we built is equals to prefix of y, b — equals to one if we already have some substring with length on the prexif that we built. The value of dp is the number of ways to built prefix with the given set of properties. To update dp we should iterate over the digit that we want to add to prefix, check that we still is in segment [x, y], go from vertex v to the next vertex in automata. So the answer is the sum by all v, b1, b2 zb, v, v1, v2, 1.Complexity: O(nd2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20898",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 586\\s*B"
          },
          "content_length": 8145
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 1",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 2",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 3",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 4",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readEoln();\n\n    vector<int> a1 = inf.readInts(n - 1, 1, 100, \"a1\");\n    inf.readEoln();\n\n    vector<int> a2 = inf.readInts(n - 1, 1, 100, \"a2\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 100, \"b\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readEoln();\n\n    vector<int> a1 = inf.readInts(n - 1, 1, 100, \"a1\");\n    inf.readEoln();\n\n    vector<int> a2 = inf.readInts(n - 1, 1, 100, \"a2\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 100, \"b\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readEoln();\n\n    vector<int> a1 = inf.readInts(n - 1, 1, 100, \"a1\");\n    inf.readEoln();\n\n    vector<int> a2 = inf.readInts(n - 1, 1, 100, \"a2\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 100, \"b\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv);\n\n    int n = opt<int>(\"n\", 5); // Default n=5 for 'special_path' type\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a1, a2, b;\n\n    if (type == \"special_path\") {\n        // For 'special_path', we set n=5 and hardcode the arrays\n        n = 5;\n        printf(\"%d\\n\", n);\n\n        a1 = {3, 1, 2, 4};\n        a2 = {2, 4, 1, 3};\n        b = {1, 5, 3, 2, 4};\n\n    } else {\n        printf(\"%d\\n\", n);\n\n        a1.resize(n - 1);\n        a2.resize(n - 1);\n        b.resize(n);\n\n        if (type == \"small_random\" || type == \"random\") {\n            for (int i = 0; i < n - 1; ++i) {\n                a1[i] = rnd.next(1, 100);\n                a2[i] = rnd.next(1, 100);\n            }\n            for (int i = 0; i < n; ++i) {\n                b[i] = rnd.next(1, 100);\n            }\n        } else if (type == \"large_random\") {\n            for (int i = 0; i < n - 1; ++i) {\n                a1[i] = rnd.next(1, 100);\n                a2[i] = rnd.next(1, 100);\n            }\n            for (int i = 0; i < n; ++i) {\n                b[i] = rnd.next(1, 100);\n            }\n        } else if (type == \"all_ones\") {\n            for (int i = 0; i < n - 1; ++i) {\n                a1[i] = 1;\n                a2[i] = 1;\n            }\n            for (int i = 0; i < n; ++i) {\n                b[i] = 1;\n            }\n        } else if (type == \"all_hundred\") {\n            for (int i = 0; i < n - 1; ++i) {\n                a1[i] = 100;\n                a2[i] = 100;\n            }\n            for (int i = 0; i < n; ++i) {\n                b[i] = 100;\n            }\n        } else if (type == \"increasing\") {\n            for (int i = 0; i < n - 1; ++i) {\n                a1[i] = 1 + (99 * i) / (n - 2);\n                a2[i] = 1 + (99 * i) / (n - 2);\n            }\n            for (int i = 0; i < n; ++i) {\n                b[i] = 1 + (99 * i) / (n - 1);\n            }\n        } else if (type == \"decreasing\") {\n            for (int i = 0; i < n - 1; ++i) {\n                a1[i] = 100 - (99 * i) / (n - 2);\n                a2[i] = 100 - (99 * i) / (n - 2);\n            }\n            for (int i = 0; i < n; ++i) {\n                b[i] = 100 - (99 * i) / (n - 1);\n            }\n        } else if (type == \"maximal_wait_times\") {\n            int pos = rnd.next(0, 2 * (n - 1) + n - 1);\n            for (int i = 0; i < n - 1; ++i) {\n                a1[i] = 1;\n                a2[i] = 1;\n            }\n            for (int i = 0; i < n; ++i) {\n                b[i] = 1;\n            }\n            if (pos < n - 1) {\n                a1[pos] = 100;\n            } else if (pos < 2 * (n - 1)) {\n                a2[pos - (n - 1)] = 100;\n            } else {\n                b[pos - 2 * (n - 1)] = 100;\n            }\n        } else if (type == \"path_equals\") {\n            int val = rnd.next(1, 100);\n            for (int i = 0; i < n - 1; ++i) {\n                a1[i] = val;\n                a2[i] = val;\n            }\n            for (int i = 0; i < n; ++i) {\n                b[i] = val;\n            }\n        } else {\n            // default to random\n            for (int i = 0; i < n - 1; ++i) {\n                a1[i] = rnd.next(1, 100);\n                a2[i] = rnd.next(1, 100);\n            }\n            for (int i = 0; i < n; ++i) {\n                b[i] = rnd.next(1, 100);\n            }\n        }\n    }\n\n    // Output second line: a1j\n    for (int i = 0; i < n - 1; ++i) {\n        printf(\"%d%c\", a1[i], (i == n - 2) ? '\\n' : ' ');\n    }\n\n    // Output third line: a2j\n    for (int i = 0; i < n - 1; ++i) {\n        printf(\"%d%c\", a2[i], (i == n - 2) ? '\\n' : ' ');\n    }\n\n    // Output fourth line: bj\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", b[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv);\n\n    int n = opt<int>(\"n\", 5); // Default n=5 for 'special_path' type\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a1, a2, b;\n\n    if (type == \"special_path\") {\n        // For 'special_path', we set n=5 and hardcode the arrays\n        n = 5;\n        printf(\"%d\\n\", n);\n\n        a1 = {3, 1, 2, 4};\n        a2 = {2, 4, 1, 3};\n        b = {1, 5, 3, 2, 4};\n\n    } else {\n        printf(\"%d\\n\", n);\n\n        a1.resize(n - 1);\n        a2.resize(n - 1);\n        b.resize(n);\n\n        if (type == \"small_random\" || type == \"random\") {\n            for (int i = 0; i < n - 1; ++i) {\n                a1[i] = rnd.next(1, 100);\n                a2[i] = rnd.next(1, 100);\n            }\n            for (int i = 0; i < n; ++i) {\n                b[i] = rnd.next(1, 100);\n            }\n        } else if (type == \"large_random\") {\n            for (int i = 0; i < n - 1; ++i) {\n                a1[i] = rnd.next(1, 100);\n                a2[i] = rnd.next(1, 100);\n            }\n            for (int i = 0; i < n; ++i) {\n                b[i] = rnd.next(1, 100);\n            }\n        } else if (type == \"all_ones\") {\n            for (int i = 0; i < n - 1; ++i) {\n                a1[i] = 1;\n                a2[i] = 1;\n            }\n            for (int i = 0; i < n; ++i) {\n                b[i] = 1;\n            }\n        } else if (type == \"all_hundred\") {\n            for (int i = 0; i < n - 1; ++i) {\n                a1[i] = 100;\n                a2[i] = 100;\n            }\n            for (int i = 0; i < n; ++i) {\n                b[i] = 100;\n            }\n        } else if (type == \"increasing\") {\n            for (int i = 0; i < n - 1; ++i) {\n                a1[i] = 1 + (99 * i) / (n - 2);\n                a2[i] = 1 + (99 * i) / (n - 2);\n            }\n            for (int i = 0; i < n; ++i) {\n                b[i] = 1 + (99 * i) / (n - 1);\n            }\n        } else if (type == \"decreasing\") {\n            for (int i = 0; i < n - 1; ++i) {\n                a1[i] = 100 - (99 * i) / (n - 2);\n                a2[i] = 100 - (99 * i) / (n - 2);\n            }\n            for (int i = 0; i < n; ++i) {\n                b[i] = 100 - (99 * i) / (n - 1);\n            }\n        } else if (type == \"maximal_wait_times\") {\n            int pos = rnd.next(0, 2 * (n - 1) + n - 1);\n            for (int i = 0; i < n - 1; ++i) {\n                a1[i] = 1;\n                a2[i] = 1;\n            }\n            for (int i = 0; i < n; ++i) {\n                b[i] = 1;\n            }\n            if (pos < n - 1) {\n                a1[pos] = 100;\n            } else if (pos < 2 * (n - 1)) {\n                a2[pos - (n - 1)] = 100;\n            } else {\n                b[pos - 2 * (n - 1)] = 100;\n            }\n        } else if (type == \"path_equals\") {\n            int val = rnd.next(1, 100);\n            for (int i = 0; i < n - 1; ++i) {\n                a1[i] = val;\n                a2[i] = val;\n            }\n            for (int i = 0; i < n; ++i) {\n                b[i] = val;\n            }\n        } else {\n            // default to random\n            for (int i = 0; i < n - 1; ++i) {\n                a1[i] = rnd.next(1, 100);\n                a2[i] = rnd.next(1, 100);\n            }\n            for (int i = 0; i < n; ++i) {\n                b[i] = rnd.next(1, 100);\n            }\n        }\n    }\n\n    // Output second line: a1j\n    for (int i = 0; i < n - 1; ++i) {\n        printf(\"%d%c\", a1[i], (i == n - 2) ? '\\n' : ' ');\n    }\n\n    // Output third line: a2j\n    for (int i = 0; i < n - 1; ++i) {\n        printf(\"%d%c\", a2[i], (i == n - 2) ? '\\n' : ' ');\n    }\n\n    // Output fourth line: bj\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", b[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random tests\n./gen -n 2 -type small_random\n./gen -n 3 -type small_random\n./gen -n 4 -type small_random\n./gen -n 5 -type small_random\n\n# Medium random tests\n./gen -n 10 -type small_random\n./gen -n 20 -type small_random\n\n# Large random tests\n./gen -n 50 -type large_random\n\n# All ones tests\n./gen -n 2 -type all_ones\n./gen -n 50 -type all_ones\n\n# All hundreds tests\n./gen -n 2 -type all_hundred\n./gen -n 50 -type all_hundred\n\n# Increasing tests\n./gen -n 5 -type increasing\n./gen -n 50 -type increasing\n\n# Decreasing tests\n./gen -n 5 -type decreasing\n./gen -n 50 -type decreasing\n\n# Maximal wait times\n./gen -n 5 -type maximal_wait_times\n./gen -n 50 -type maximal_wait_times\n\n# Path equals tests\n./gen -n 5 -type path_equals\n./gen -n 50 -type path_equals\n./gen -n 2 -type path_equals\n./gen -n 10 -type path_equals\n\n# Special path test (n is set within generator)\n./gen -type special_path\n\n# Additional random tests\n./gen -n 10 -type random\n./gen -n 20 -type random\n./gen -n 30 -type random\n./gen -n 49 -type random\n./gen -n 50 -type random\n./gen -n 2 -type random\n./gen -n 25 -type random\n./gen -n 30 -type random\n\n# Edge cases\n./gen -n 2 -type maximal_wait_times\n\n# Random maximal_wait_times with random position\n./gen -n 10 -type maximal_wait_times\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:41.180102",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "586/C",
      "title": "C. Gennady the Dentist",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains a positive integer n (1 ≤ n ≤ 4000) — the number of kids in the line. Next n lines contain three integers each vi, di, pi (1 ≤ vi, di, pi ≤ 106) — the volume of the cry in the doctor's office, the volume of the cry in the hall and the confidence of the i-th child.",
      "output_spec": "OutputIn the first line print number k — the number of children whose teeth Gennady will cure.In the second line print k integers — the numbers of the children who will make it to the end of the line in the increasing order.",
      "sample_tests": "ExamplesInputCopy54 2 24 1 25 2 43 3 55 1 2OutputCopy21 3 InputCopy54 5 15 3 94 1 22 1 84 1 9OutputCopy41 2 4 5",
      "description": "C. Gennady the Dentist\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains a positive integer n (1 ≤ n ≤ 4000) — the number of kids in the line. Next n lines contain three integers each vi, di, pi (1 ≤ vi, di, pi ≤ 106) — the volume of the cry in the doctor's office, the volume of the cry in the hall and the confidence of the i-th child.\n\nOutputIn the first line print number k — the number of children whose teeth Gennady will cure.In the second line print k integers — the numbers of the children who will make it to the end of the line in the increasing order.\n\nInputCopy54 2 24 1 25 2 43 3 55 1 2OutputCopy21 3 InputCopy54 5 15 3 94 1 22 1 84 1 9OutputCopy41 2 4 5\n\nInputCopy54 2 24 1 25 2 43 3 55 1 2\n\nOutputCopy21 3\n\nInputCopy54 5 15 3 94 1 22 1 84 1 9\n\nOutputCopy41 2 4 5\n\nNoteIn the first example, Gennady first treats the teeth of the first child who will cry with volume 4. The confidences of the remaining children will get equal to  - 2, 1, 3, 1, respectively. Thus, the second child also cries at the volume of 1 and run to the exit. The confidence of the remaining children will be equal to 0, 2, 0. Then the third child will go to the office, and cry with volume 5. The other children won't bear this, and with a loud cry they will run to the exit.In the second sample, first the first child goes into the office, he will cry with volume 4. The confidence of the remaining children will be equal to 5,  - 1, 6, 8. Thus, the third child will cry with the volume of 1 and run to the exit. The confidence of the remaining children will be equal to 5, 5, 7. After that, the second child goes to the office and cry with the volume of 5. The confidences of the remaining children will be equal to 0, 3. Then the fourth child will go into the office and cry with the volume of 2. Because of this the confidence of the fifth child will be 1, and he will go into the office last.",
      "solutions": [
        {
          "title": "Разбор Codeforces Round #325 - Codeforces",
          "content": "586A - Alena's ScheduleThe problem has been prepared by adedalic.To solve this problem one should remove all leading and trailing zeroes from array and then calculate the number of ones and number of zeroes neighboured by ones. The sum of this values is the answer for the problem.Complexity: O(n).586B - Laurenty and ShopThe problem has been prepared by Oleg_Smirnov.Let's call some path ith if we start it by going i times left, then we cross the prospect and go left n - 1 - i times again. Let di be equal to the time we should wait on traffic lights while following i-th path. If we consider any way from the shop to home, it is equal (but reversed) to only path from home to the shop, meaning that we need to find two distinct paths from home to the shop. So the answer to the problem is the sum of the smallest and the second smallest values among di. One could easily calculate di using calculated di - 1, so di could be found in one for cycle.If we will consider only two minimum values among di, solution complexity will be O(n).Complexity: O(n).585A - Gennady the DentistThe problem has been prepared by Neon.Let's store for each child his current confidence value and a boolean indicating whether child had left the queue (or visited the dentist office) or not. Then one could easily process children one by one, considering only children who still are in the queue (using boolean array), and changing stored values.Such solution has complexity O(n2) and requires author's attention much, especially the case with possible confidence value overflowing. Of course there are much faster solutions not required in our case.585B - Phillip and TrainsThe problem has been prepared by IlyaLos.One could consider a graph with vertices corresponding to every (x, y) position. I should notice that train positions for each Phillip position are fully restorable from his y coordinate. Edge between vertices u and v means that we could get from position corresponding to u to position corresponding by v in one turn without moving onto a train cell or moving in a cell which will be occupied by some train before the next turn. All we need next is to find whether any finishing position is reachable from the only starting position (using BFS or DFS, or, as soon as graph is a DAG, dynamic programming).As soon as graph has O(n) vertices and O(n) edges, solution complexity equals to O(n).585C - Alice, Bob, Oranges and ApplesThe problem has been prepared by Edvard.Firstly, let's understand the process described in problem statement. If one would write a tree of a sum-pairs (x, y) with letters and , he would get the Stern–Brocot tree. Let the number of oranges be enumerator and the number of apples be denumerator of fraction. At every step we have two fractions (at first step they are ) and should replace exactly one of them with their mediant. In such way first fraction is first parent to the left from mediant while second fraction is parent to the right. The process described in statement is, this way, a process of finding a fraction in the Stern-Brocot tree, finishing when the current mediant is equal to current node in the tree and (x, y) pair is the fraction we are searching. This means that if , (x, y) does not correspond to any correct fraction and the answer is \"Impossible\". Other way, we could find it in the tree. If x > y, we should firstly go in the right subtree. Moreover, we could then consider we are searching from the root. If x < y, we should go left and next consider from the root. This gives us Euclidian algorithm, which could be realized to work in complexity.Complexity: O(logn).585D - Lizard Era: BeginningThe problem has been prepared by danilka.pro.To solve the problem we will use meet-in-the-middle approach. For we should consider all variants. Let in some variant approval values of three companions are a, b, c respectively. If we will consider some variant from other half (there are of them) and a', b', c' approval values, then to ``merge'' such two parts correctly, two conditions a - b = b' - a' и b - c = c' - b' must be true (a + a' = b + b' = c + c' is true), and the value we are maximizing is a + a'.This way, to solve the task one could consider every variant from the first half and store for every possible pair (a - b, b - c) the maximum a value achievable (using, for example, the structure or any fast sorting algorithm). If one would then consider every variant from the second half, he just need to find (b' - a', c' - b') pair in the structure to get the maximum a value if possible and update answer with a + a' value. Answer restoring is pretty same to the algorithm above.Such solution has complexity.585E - Present for Vitalik the Philatelist The problem has been prepared by gridnevvvit.Let's calculate the number of subsets with gcd equal to 1 — value A. Let's do that using principle of inclusions-exclusions: firstly we say that all subsets is good. The total number of subsets is equal to 2n. Now let's subtract subsets with gcd divisible by 2. The number of that subsets is equal to 2cnt2 - 1 (cnti is the number of numbers that is divisable by i). Next we should subtract 2cnt3 - 1. Subsets with gcd divisible by 4 we already counted with number two. Next we should subtract 2cnt5 - 1. Now we should notice that subsets with gcd divisible by 6 we already processed twice: firstly with number 2, then with — 3, so let's add the number of these subsets 2cnt6 - 1. If we continue this process we will get, that for all numbers d we should add the value μ(d)(2cntd - 1), where μ(d) is equals to 0, if d is divisible by square of some prime, 1, if the number of primes in factorization of d is even and  - 1 in other case. So the numbers that is divisible by square of some prime we can ignore, because they have coefficient 0. To calculate values cnti we should factorize all numbers and iterate over 2k divisors with value μ(d) ≠ 0. Now it's easy to see, that the number of subsets with gcd greater than 1 equals to B = 2n - A. To solve the problem let's fix the stamp that Vitaliy will buy ai. Let's recalculate the number B for array a without element ai. To do that we should only subtract those terms that was affected by number ai. We can do that in 2k, where k is the number of primes in factorization of the number ai. It's easy to see that only the subsets with gcd greater than 1, but not divisible by any divisor of ai, should we counted in answer. To calculate number of those subsets let's again use the principle of inclusions-exclusions. For every divisor d of ai let's subtract the value μ (2cntd - 1) from B. So now we got Bi — the number of subsets with gcd greater than 1, but coprime with ai. The answer to problem is the sum over all Bi. The maximum number of primes in factorization of number not greater than 107 is equal to 8. We can factorize all numbers from 1 to n in linear time by algorithm for finding the smallest divisors for all intergers from 1 to n, or by sieve of Eratosthenes in O(nloglogn) time.Complexity: O(C + n2K), where , K — is the largest number of primes in factorization of ai.585F - Digits of Number PiThe problem has been prepared by Edvard.Consider all substrings of string s with length . Let's add them all to trie data structure, calculate failure links and build automata by digits. We can do that in linear time using Aho-Korasik algorithm. Now to solve the problem we should calculate dp zi, v, b1, b2, b. State of dp is described by five numbers: i — number of digits, that we already put to our number, v — in which vertex of trie we are, b1 — equals to one if the prefix that we built is equals to prefix of x, b2 — equals to one if the prefix that we built is equals to prefix of y, b — equals to one if we already have some substring with length on the prexif that we built. The value of dp is the number of ways to built prefix with the given set of properties. To update dp we should iterate over the digit that we want to add to prefix, check that we still is in segment [x, y], go from vertex v to the next vertex in automata. So the answer is the sum by all v, b1, b2 zb, v, v1, v2, 1.Complexity: O(nd2).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/20898",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 586 和字母"
          },
          "content_length": 8145
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 1",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 2",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 3",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 4",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 4000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int vi = inf.readInt(1, 1000000, \"vi\");\n        inf.readSpace();\n        int di = inf.readInt(1, 1000000, \"di\");\n        inf.readSpace();\n        int pi = inf.readInt(1, 1000000, \"pi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 4000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int vi = inf.readInt(1, 1000000, \"vi\");\n        inf.readSpace();\n        int di = inf.readInt(1, 1000000, \"di\");\n        inf.readSpace();\n        int pi = inf.readInt(1, 1000000, \"pi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 4000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int vi = inf.readInt(1, 1000000, \"vi\");\n        inf.readSpace();\n        int di = inf.readInt(1, 1000000, \"di\");\n        inf.readSpace();\n        int pi = inf.readInt(1, 1000000, \"pi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            int vi = rnd.next(1, 1000000);\n            int di = rnd.next(1, 1000000);\n            int pi = rnd.next(1, 1000000);\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else if (type == \"chain_reaction\") {\n        // Chain reaction test case: the first child crying causes all others to cry and leave\n        printf(\"%d\\n\", n);\n        vector<int> vi(n);\n        vector<int> di(n);\n        vector<int> pi(n);\n\n        vi[0] = min(n, 1000000); // First child's crying affects as many children as possible\n        di[0] = 1;\n        pi[0] = 1000000; // Large confidence for the first child\n\n        int affect_range = vi[0];\n\n        for(int i = 1; i < n; ++i) {\n            if(i < affect_range) {\n                int reduction = vi[0] - (i - 1);\n                pi[i] = rnd.next(0, reduction); // Will become negative after first child's cry\n            } else {\n                pi[i] = rnd.next(1, 1000000); // Won't be affected by first child's cry\n            }\n            vi[i] = 1;\n            di[i] = 1000000; // Large di to affect subsequent children\n        }\n\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d %d\\n\", vi[i], di[i], pi[i]);\n        }\n    } else if (type == \"no_chain_reaction\") {\n        // No chain reaction: children's confidences are high enough to not be affected\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            int vi = rnd.next(1, 1000000);\n            int di = rnd.next(1, 1000000);\n            int pi = 1000000;\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else if (type == \"maximal\") {\n        // Maximal values\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            int vi = 1000000;\n            int di = 1000000;\n            int pi = 1000000;\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else if (type == \"minimal\") {\n        // Minimal values\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            int vi = 1;\n            int di = 1;\n            int pi = 1;\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            int vi = rnd.next(1, 1000000);\n            int di = rnd.next(1, 1000000);\n            int pi = rnd.next(1, 1000000);\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else if (type == \"chain_reaction\") {\n        // Chain reaction test case: the first child crying causes all others to cry and leave\n        printf(\"%d\\n\", n);\n        vector<int> vi(n);\n        vector<int> di(n);\n        vector<int> pi(n);\n\n        vi[0] = min(n, 1000000); // First child's crying affects as many children as possible\n        di[0] = 1;\n        pi[0] = 1000000; // Large confidence for the first child\n\n        int affect_range = vi[0];\n\n        for(int i = 1; i < n; ++i) {\n            if(i < affect_range) {\n                int reduction = vi[0] - (i - 1);\n                pi[i] = rnd.next(0, reduction); // Will become negative after first child's cry\n            } else {\n                pi[i] = rnd.next(1, 1000000); // Won't be affected by first child's cry\n            }\n            vi[i] = 1;\n            di[i] = 1000000; // Large di to affect subsequent children\n        }\n\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d %d\\n\", vi[i], di[i], pi[i]);\n        }\n    } else if (type == \"no_chain_reaction\") {\n        // No chain reaction: children's confidences are high enough to not be affected\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            int vi = rnd.next(1, 1000000);\n            int di = rnd.next(1, 1000000);\n            int pi = 1000000;\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else if (type == \"maximal\") {\n        // Maximal values\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            int vi = 1000000;\n            int di = 1000000;\n            int pi = 1000000;\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else if (type == \"minimal\") {\n        // Minimal values\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            int vi = 1;\n            int di = 1;\n            int pi = 1;\n            printf(\"%d %d %d\\n\", vi, di, pi);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type minimal\n./gen -n 1 -type maximal\n\n./gen -n 2 -type random\n./gen -n 2 -type chain_reaction\n\n./gen -n 5 -type random\n./gen -n 5 -type minimal\n./gen -n 5 -type maximal\n./gen -n 5 -type no_chain_reaction\n./gen -n 5 -type chain_reaction\n\n./gen -n 100 -type random\n./gen -n 100 -type minimal\n./gen -n 100 -type maximal\n./gen -n 100 -type no_chain_reaction\n./gen -n 100 -type chain_reaction\n\n./gen -n 1000 -type random\n./gen -n 1000 -type minimal\n./gen -n 1000 -type maximal\n./gen -n 1000 -type no_chain_reaction\n./gen -n 1000 -type chain_reaction\n\n./gen -n 2000 -type random\n./gen -n 2000 -type chain_reaction\n./gen -n 2000 -type no_chain_reaction\n\n./gen -n 3000 -type random\n\n./gen -n 3999 -type chain_reaction\n\n./gen -n 4000 -type random\n./gen -n 4000 -type minimal\n./gen -n 4000 -type maximal\n./gen -n 4000 -type no_chain_reaction\n./gen -n 4000 -type chain_reaction\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:43.477067",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "586/D",
      "title": "D. Phillip and Trains",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputEach test contains from one to ten sets of the input data. The first line of the test contains a single integer t (1 ≤ t ≤ 10 for pretests and tests or t = 1 for hacks; see the Notes section for details) — the number of sets.Then follows the description of t sets of the input data. The first line of the description of each set contains two integers n, k (2 ≤ n ≤ 100, 1 ≤ k ≤ 26) — the number of columns on the field and the number of trains. Each of the following three lines contains the sequence of n character, representing the row of the field where the game is on. Philip's initial position is marked as 's', he is in the leftmost column. Each of the k trains is marked by some sequence of identical uppercase letters of the English alphabet, located in one line. Distinct trains are represented by distinct letters. Character '.' represents an empty cell, that is, the cell that doesn't contain either Philip or the trains.",
      "output_spec": "OutputFor each set of the input data print on a single line word YES, if it is possible to win the game and word NO otherwise.",
      "sample_tests": "ExamplesInputCopy216 4...AAAAA........s.BBB......CCCCC........DDDDD...16 4...AAAAA........s.BBB....CCCCC.........DDDDD....OutputCopyYESNOInputCopy210 4s.ZZ...........AAABB.YYYYYY...10 4s.ZZ..........AAAABB.YYYYYY...OutputCopyYESNO",
      "description": "D. Phillip and Trains\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputEach test contains from one to ten sets of the input data. The first line of the test contains a single integer t (1 ≤ t ≤ 10 for pretests and tests or t = 1 for hacks; see the Notes section for details) — the number of sets.Then follows the description of t sets of the input data. The first line of the description of each set contains two integers n, k (2 ≤ n ≤ 100, 1 ≤ k ≤ 26) — the number of columns on the field and the number of trains. Each of the following three lines contains the sequence of n character, representing the row of the field where the game is on. Philip's initial position is marked as 's', he is in the leftmost column. Each of the k trains is marked by some sequence of identical uppercase letters of the English alphabet, located in one line. Distinct trains are represented by distinct letters. Character '.' represents an empty cell, that is, the cell that doesn't contain either Philip or the trains.\n\nOutputFor each set of the input data print on a single line word YES, if it is possible to win the game and word NO otherwise.\n\nInputCopy216 4...AAAAA........s.BBB......CCCCC........DDDDD...16 4...AAAAA........s.BBB....CCCCC.........DDDDD....OutputCopyYESNOInputCopy210 4s.ZZ...........AAABB.YYYYYY...10 4s.ZZ..........AAAABB.YYYYYY...OutputCopyYESNO\n\nInputCopy216 4...AAAAA........s.BBB......CCCCC........DDDDD...16 4...AAAAA........s.BBB....CCCCC.........DDDDD....\n\nOutputCopyYESNO\n\nInputCopy210 4s.ZZ...........AAABB.YYYYYY...10 4s.ZZ..........AAAABB.YYYYYY...\n\nOutputCopyYESNO\n\nNoteIn the first set of the input of the first sample Philip must first go forward and go down to the third row of the field, then go only forward, then go forward and climb to the second row, go forward again and go up to the first row. After that way no train blocks Philip's path, so he can go straight to the end of the tunnel.Note that in this problem the challenges are restricted to tests that contain only one testset.",
      "solutions": [
        {
          "title": "Разбор Codeforces Round #325 - Codeforces",
          "content": "586A - Alena's ScheduleThe problem has been prepared by adedalic.To solve this problem one should remove all leading and trailing zeroes from array and then calculate the number of ones and number of zeroes neighboured by ones. The sum of this values is the answer for the problem.Complexity: O(n).586B - Laurenty and ShopThe problem has been prepared by Oleg_Smirnov.Let's call some path ith if we start it by going i times left, then we cross the prospect and go left n - 1 - i times again. Let di be equal to the time we should wait on traffic lights while following i-th path. If we consider any way from the shop to home, it is equal (but reversed) to only path from home to the shop, meaning that we need to find two distinct paths from home to the shop. So the answer to the problem is the sum of the smallest and the second smallest values among di. One could easily calculate di using calculated di - 1, so di could be found in one for cycle.If we will consider only two minimum values among di, solution complexity will be O(n).Complexity: O(n).585A - Gennady the DentistThe problem has been prepared by Neon.Let's store for each child his current confidence value and a boolean indicating whether child had left the queue (or visited the dentist office) or not. Then one could easily process children one by one, considering only children who still are in the queue (using boolean array), and changing stored values.Such solution has complexity O(n2) and requires author's attention much, especially the case with possible confidence value overflowing. Of course there are much faster solutions not required in our case.585B - Phillip and TrainsThe problem has been prepared by IlyaLos.One could consider a graph with vertices corresponding to every (x, y) position. I should notice that train positions for each Phillip position are fully restorable from his y coordinate. Edge between vertices u and v means that we could get from position corresponding to u to position corresponding by v in one turn without moving onto a train cell or moving in a cell which will be occupied by some train before the next turn. All we need next is to find whether any finishing position is reachable from the only starting position (using BFS or DFS, or, as soon as graph is a DAG, dynamic programming).As soon as graph has O(n) vertices and O(n) edges, solution complexity equals to O(n).585C - Alice, Bob, Oranges and ApplesThe problem has been prepared by Edvard.Firstly, let's understand the process described in problem statement. If one would write a tree of a sum-pairs (x, y) with letters and , he would get the Stern–Brocot tree. Let the number of oranges be enumerator and the number of apples be denumerator of fraction. At every step we have two fractions (at first step they are ) and should replace exactly one of them with their mediant. In such way first fraction is first parent to the left from mediant while second fraction is parent to the right. The process described in statement is, this way, a process of finding a fraction in the Stern-Brocot tree, finishing when the current mediant is equal to current node in the tree and (x, y) pair is the fraction we are searching. This means that if , (x, y) does not correspond to any correct fraction and the answer is \"Impossible\". Other way, we could find it in the tree. If x > y, we should firstly go in the right subtree. Moreover, we could then consider we are searching from the root. If x < y, we should go left and next consider from the root. This gives us Euclidian algorithm, which could be realized to work in complexity.Complexity: O(logn).585D - Lizard Era: BeginningThe problem has been prepared by danilka.pro.To solve the problem we will use meet-in-the-middle approach. For we should consider all variants. Let in some variant approval values of three companions are a, b, c respectively. If we will consider some variant from other half (there are of them) and a', b', c' approval values, then to ``merge'' such two parts correctly, two conditions a - b = b' - a' и b - c = c' - b' must be true (a + a' = b + b' = c + c' is true), and the value we are maximizing is a + a'.This way, to solve the task one could consider every variant from the first half and store for every possible pair (a - b, b - c) the maximum a value achievable (using, for example, the structure or any fast sorting algorithm). If one would then consider every variant from the second half, he just need to find (b' - a', c' - b') pair in the structure to get the maximum a value if possible and update answer with a + a' value. Answer restoring is pretty same to the algorithm above.Such solution has complexity.585E - Present for Vitalik the Philatelist The problem has been prepared by gridnevvvit.Let's calculate the number of subsets with gcd equal to 1 — value A. Let's do that using principle of inclusions-exclusions: firstly we say that all subsets is good. The total number of subsets is equal to 2n. Now let's subtract subsets with gcd divisible by 2. The number of that subsets is equal to 2cnt2 - 1 (cnti is the number of numbers that is divisable by i). Next we should subtract 2cnt3 - 1. Subsets with gcd divisible by 4 we already counted with number two. Next we should subtract 2cnt5 - 1. Now we should notice that subsets with gcd divisible by 6 we already processed twice: firstly with number 2, then with — 3, so let's add the number of these subsets 2cnt6 - 1. If we continue this process we will get, that for all numbers d we should add the value μ(d)(2cntd - 1), where μ(d) is equals to 0, if d is divisible by square of some prime, 1, if the number of primes in factorization of d is even and  - 1 in other case. So the numbers that is divisible by square of some prime we can ignore, because they have coefficient 0. To calculate values cnti we should factorize all numbers and iterate over 2k divisors with value μ(d) ≠ 0. Now it's easy to see, that the number of subsets with gcd greater than 1 equals to B = 2n - A. To solve the problem let's fix the stamp that Vitaliy will buy ai. Let's recalculate the number B for array a without element ai. To do that we should only subtract those terms that was affected by number ai. We can do that in 2k, where k is the number of primes in factorization of the number ai. It's easy to see that only the subsets with gcd greater than 1, but not divisible by any divisor of ai, should we counted in answer. To calculate number of those subsets let's again use the principle of inclusions-exclusions. For every divisor d of ai let's subtract the value μ (2cntd - 1) from B. So now we got Bi — the number of subsets with gcd greater than 1, but coprime with ai. The answer to problem is the sum over all Bi. The maximum number of primes in factorization of number not greater than 107 is equal to 8. We can factorize all numbers from 1 to n in linear time by algorithm for finding the smallest divisors for all intergers from 1 to n, or by sieve of Eratosthenes in O(nloglogn) time.Complexity: O(C + n2K), where , K — is the largest number of primes in factorization of ai.585F - Digits of Number PiThe problem has been prepared by Edvard.Consider all substrings of string s with length . Let's add them all to trie data structure, calculate failure links and build automata by digits. We can do that in linear time using Aho-Korasik algorithm. Now to solve the problem we should calculate dp zi, v, b1, b2, b. State of dp is described by five numbers: i — number of digits, that we already put to our number, v — in which vertex of trie we are, b1 — equals to one if the prefix that we built is equals to prefix of x, b2 — equals to one if the prefix that we built is equals to prefix of y, b — equals to one if we already have some substring with length on the prexif that we built. The value of dp is the number of ways to built prefix with the given set of properties. To update dp we should iterate over the digit that we want to add to prefix, check that we still is in segment [x, y], go from vertex v to the next vertex in automata. So the answer is the sum by all v, b1, b2 zb, v, v1, v2, 1.Complexity: O(nd2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20898",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 586 和字母"
          },
          "content_length": 8145
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 1",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 2",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 3",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 4",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 10, \"t\");\n    inf.readEoln();\n    for (int test = 0; test < t; ++test) {\n        int n = inf.readInt(2, 100, \"n\");\n        inf.readSpace();\n        int k = inf.readInt(1, 26, \"k\");\n        inf.readEoln();\n        vector<string> grid(3);\n        string pattern = \"[\\\\.sA-Z]{\" + to_string(n) + \"}\";\n        int count_s = 0;\n        set<char> train_letters;\n        for (int i = 0; i < 3; ++i) {\n            grid[i] = inf.readLine(pattern);\n            for (int j = 0; j < n; ++j) {\n                char c = grid[i][j];\n                if (c == 's') {\n                    ensuref(j == 0, \"'s' must be in the first column, but found at column %d\", j + 1);\n                    ++count_s;\n                } else if ('A' <= c && c <= 'Z') {\n                    train_letters.insert(c);\n                }\n            }\n        }\n        ensuref(count_s == 1, \"There must be exactly one 's' in the grid\");\n        ensuref((int)train_letters.size() == k, \"Number of distinct trains (%d) does not match k (%d)\", (int)train_letters.size(), k);\n        for (char train : train_letters) {\n            int train_row = -1;\n            vector<int> positions;\n            for (int i = 0; i < 3; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    if (grid[i][j] == train) {\n                        if (train_row == -1) {\n                            train_row = i;\n                        } else {\n                            ensuref(train_row == i, \"Train '%c' appears in more than one row\", train);\n                        }\n                        positions.push_back(j);\n                    }\n                }\n            }\n            ensuref((int)positions.size() >= 2, \"Train '%c' must have length at least 2\", train);\n            sort(positions.begin(), positions.end());\n            for (int idx = 1; idx < (int)positions.size(); ++idx) {\n                ensuref(positions[idx] == positions[idx - 1] + 1, \"Train '%c' positions are not contiguous\", train);\n            }\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 10, \"t\");\n    inf.readEoln();\n    for (int test = 0; test < t; ++test) {\n        int n = inf.readInt(2, 100, \"n\");\n        inf.readSpace();\n        int k = inf.readInt(1, 26, \"k\");\n        inf.readEoln();\n        vector<string> grid(3);\n        string pattern = \"[\\\\.sA-Z]{\" + to_string(n) + \"}\";\n        int count_s = 0;\n        set<char> train_letters;\n        for (int i = 0; i < 3; ++i) {\n            grid[i] = inf.readLine(pattern);\n            for (int j = 0; j < n; ++j) {\n                char c = grid[i][j];\n                if (c == 's') {\n                    ensuref(j == 0, \"'s' must be in the first column, but found at column %d\", j + 1);\n                    ++count_s;\n                } else if ('A' <= c && c <= 'Z') {\n                    train_letters.insert(c);\n                }\n            }\n        }\n        ensuref(count_s == 1, \"There must be exactly one 's' in the grid\");\n        ensuref((int)train_letters.size() == k, \"Number of distinct trains (%d) does not match k (%d)\", (int)train_letters.size(), k);\n        for (char train : train_letters) {\n            int train_row = -1;\n            vector<int> positions;\n            for (int i = 0; i < 3; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    if (grid[i][j] == train) {\n                        if (train_row == -1) {\n                            train_row = i;\n                        } else {\n                            ensuref(train_row == i, \"Train '%c' appears in more than one row\", train);\n                        }\n                        positions.push_back(j);\n                    }\n                }\n            }\n            ensuref((int)positions.size() >= 2, \"Train '%c' must have length at least 2\", train);\n            sort(positions.begin(), positions.end());\n            for (int idx = 1; idx < (int)positions.size(); ++idx) {\n                ensuref(positions[idx] == positions[idx - 1] + 1, \"Train '%c' positions are not contiguous\", train);\n            }\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 10, \"t\");\n    inf.readEoln();\n    for (int test = 0; test < t; ++test) {\n        int n = inf.readInt(2, 100, \"n\");\n        inf.readSpace();\n        int k = inf.readInt(1, 26, \"k\");\n        inf.readEoln();\n        vector<string> grid(3);\n        string pattern = \"[\\\\.sA-Z]{\" + to_string(n) + \"}\";\n        int count_s = 0;\n        set<char> train_letters;\n        for (int i = 0; i < 3; ++i) {\n            grid[i] = inf.readLine(pattern);\n            for (int j = 0; j < n; ++j) {\n                char c = grid[i][j];\n                if (c == 's') {\n                    ensuref(j == 0, \"'s' must be in the first column, but found at column %d\", j + 1);\n                    ++count_s;\n                } else if ('A' <= c && c <= 'Z') {\n                    train_letters.insert(c);\n                }\n            }\n        }\n        ensuref(count_s == 1, \"There must be exactly one 's' in the grid\");\n        ensuref((int)train_letters.size() == k, \"Number of distinct trains (%d) does not match k (%d)\", (int)train_letters.size(), k);\n        for (char train : train_letters) {\n            int train_row = -1;\n            vector<int> positions;\n            for (int i = 0; i < 3; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    if (grid[i][j] == train) {\n                        if (train_row == -1) {\n                            train_row = i;\n                        } else {\n                            ensuref(train_row == i, \"Train '%c' appears in more than one row\", train);\n                        }\n                        positions.push_back(j);\n                    }\n                }\n            }\n            ensuref((int)positions.size() >= 2, \"Train '%c' must have length at least 2\", train);\n            sort(positions.begin(), positions.end());\n            for (int idx = 1; idx < (int)positions.size(); ++idx) {\n                ensuref(positions[idx] == positions[idx - 1] + 1, \"Train '%c' positions are not contiguous\", train);\n            }\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_random_test_case(int n, int k) {\n    vector<string> grid(3, string(n, '.'));\n\n    // Place 's' in the leftmost column\n    int philip_row = rnd.next(3); // 0, 1, or 2\n    grid[philip_row][0] = 's';\n\n    // Keep track of used letters\n    vector<char> letters;\n    for (char c = 'A'; c <= 'Z'; ++c) {\n        letters.push_back(c);\n    }\n    shuffle(letters.begin(), letters.end());\n\n    int trains_added = 0;\n    while (trains_added < k) {\n        int row = rnd.next(3);\n        int max_start_col = n - 2; // since train length >=2\n        if (max_start_col <= 0) {\n            // Cannot place train of length >=2\n            break;\n        }\n        int start_col = rnd.next(1, max_start_col);\n\n        // Random length between 2 and 5\n        int max_length = min(5, n - start_col);\n        int length = rnd.next(2, max_length);\n\n        // Check if the positions are available\n        bool can_place = true;\n        char train_char = letters[trains_added]; // Use next available letter\n\n        for (int i = start_col; i < start_col + length; ++i) {\n            if (grid[row][i] != '.') {\n                can_place = false;\n                break;\n            }\n        }\n\n        if (can_place) {\n            // Place the train\n            for (int i = start_col; i < start_col + length; ++i) {\n                grid[row][i] = train_char;\n            }\n            trains_added++;\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, trains_added);\n\n    // Output the grid\n    for (int i = 0; i < 3; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n}\n\nvoid generate_possible_test_case(int n, int k) {\n    vector<string> grid(3, string(n, '.'));\n\n    // Place 's' in the leftmost column\n    int philip_row = rnd.next(3);\n    grid[philip_row][0] = 's';\n\n    // List of letters for trains\n    vector<char> letters;\n    for (char c = 'A'; c <= 'Z'; ++c) {\n        letters.push_back(c);\n    }\n    shuffle(letters.begin(), letters.end());\n\n    int trains_added = 0;\n    int num_trains = min(k, 26); // Ensure k ≤ 26\n\n    // Place trains in rows different from Philip's\n    for (int t = 0; t < num_trains; ++t) {\n        // Choose a row different from Philip's starting row\n        int train_row;\n        if (philip_row == 0) {\n            train_row = rnd.next(1,2);\n        } else if (philip_row == 2) {\n            train_row = rnd.next(0,1);\n        } else {\n            if (rnd.next(2) == 0) {\n                train_row = 0;\n            } else {\n                train_row = 2;\n            }\n        }\n\n        // Try to find a position to place train\n        int max_start_col = n - 2; // At least length 2\n        if (max_start_col <= 0) {\n            // Cannot place train\n            break;\n        }\n        int start_col = rnd.next(1, max_start_col);\n\n        // Random length between 2 and 5\n        int max_length = min(5, n - start_col);\n        int length = rnd.next(2, max_length);\n\n        // Check if positions are available\n        bool can_place = true;\n        char train_char = letters[t];\n        for (int i = start_col; i < start_col + length; ++i) {\n            if (grid[train_row][i] != '.') {\n                can_place = false;\n                break;\n            }\n        }\n        if (can_place) {\n            // Place the train\n            for (int i = start_col; i < start_col + length; ++i) {\n                grid[train_row][i] = train_char;\n            }\n            trains_added++;\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, trains_added);\n\n    // Output the grid\n    for (int i = 0; i < 3; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n}\n\nvoid generate_impossible_test_case(int n, int k) {\n    vector<string> grid(3, string(n, '.'));\n\n    // Place 's' in the leftmost column\n    int philip_row = rnd.next(3);\n    grid[philip_row][0] = 's';\n\n    // List of letters for trains\n    vector<char> letters;\n    for (char c = 'A'; c <= 'Z'; ++c) {\n        letters.push_back(c);\n    }\n\n    int trains_added = 0;\n\n    // Place trains in all three rows starting ahead of Philip to block him\n    int start_col = 1; // Immediately after Philip\n\n    // For each row\n    for (int row = 0; row < 3 && trains_added < k; ++row) {\n        // Place a train starting from start_col\n        if (start_col + 1 >= n) continue; // Need at least two cells\n\n        char train_char = letters[trains_added];\n        for (int i = start_col; i < min(n, start_col + 2); ++i) {\n            grid[row][i] = train_char;\n        }\n        trains_added++;\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, trains_added);\n\n    // Output the grid\n    for (int i = 0; i < 3; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 1);\n    int n = opt<int>(\"n\", 10); // default value\n    int k = opt<int>(\"k\", 1); // default number of trains\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", t);\n\n    for (int test = 0; test < t; ++test) {\n        if (type == \"random\") {\n            generate_random_test_case(n, k);\n        } else if (type == \"possible\") {\n            generate_possible_test_case(n, k);\n        } else if (type == \"impossible\") {\n            generate_impossible_test_case(n, k);\n        } else {\n            // Default to random if type is not recognized\n            generate_random_test_case(n, k);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_random_test_case(int n, int k) {\n    vector<string> grid(3, string(n, '.'));\n\n    // Place 's' in the leftmost column\n    int philip_row = rnd.next(3); // 0, 1, or 2\n    grid[philip_row][0] = 's';\n\n    // Keep track of used letters\n    vector<char> letters;\n    for (char c = 'A'; c <= 'Z'; ++c) {\n        letters.push_back(c);\n    }\n    shuffle(letters.begin(), letters.end());\n\n    int trains_added = 0;\n    while (trains_added < k) {\n        int row = rnd.next(3);\n        int max_start_col = n - 2; // since train length >=2\n        if (max_start_col <= 0) {\n            // Cannot place train of length >=2\n            break;\n        }\n        int start_col = rnd.next(1, max_start_col);\n\n        // Random length between 2 and 5\n        int max_length = min(5, n - start_col);\n        int length = rnd.next(2, max_length);\n\n        // Check if the positions are available\n        bool can_place = true;\n        char train_char = letters[trains_added]; // Use next available letter\n\n        for (int i = start_col; i < start_col + length; ++i) {\n            if (grid[row][i] != '.') {\n                can_place = false;\n                break;\n            }\n        }\n\n        if (can_place) {\n            // Place the train\n            for (int i = start_col; i < start_col + length; ++i) {\n                grid[row][i] = train_char;\n            }\n            trains_added++;\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, trains_added);\n\n    // Output the grid\n    for (int i = 0; i < 3; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n}\n\nvoid generate_possible_test_case(int n, int k) {\n    vector<string> grid(3, string(n, '.'));\n\n    // Place 's' in the leftmost column\n    int philip_row = rnd.next(3);\n    grid[philip_row][0] = 's';\n\n    // List of letters for trains\n    vector<char> letters;\n    for (char c = 'A'; c <= 'Z'; ++c) {\n        letters.push_back(c);\n    }\n    shuffle(letters.begin(), letters.end());\n\n    int trains_added = 0;\n    int num_trains = min(k, 26); // Ensure k ≤ 26\n\n    // Place trains in rows different from Philip's\n    for (int t = 0; t < num_trains; ++t) {\n        // Choose a row different from Philip's starting row\n        int train_row;\n        if (philip_row == 0) {\n            train_row = rnd.next(1,2);\n        } else if (philip_row == 2) {\n            train_row = rnd.next(0,1);\n        } else {\n            if (rnd.next(2) == 0) {\n                train_row = 0;\n            } else {\n                train_row = 2;\n            }\n        }\n\n        // Try to find a position to place train\n        int max_start_col = n - 2; // At least length 2\n        if (max_start_col <= 0) {\n            // Cannot place train\n            break;\n        }\n        int start_col = rnd.next(1, max_start_col);\n\n        // Random length between 2 and 5\n        int max_length = min(5, n - start_col);\n        int length = rnd.next(2, max_length);\n\n        // Check if positions are available\n        bool can_place = true;\n        char train_char = letters[t];\n        for (int i = start_col; i < start_col + length; ++i) {\n            if (grid[train_row][i] != '.') {\n                can_place = false;\n                break;\n            }\n        }\n        if (can_place) {\n            // Place the train\n            for (int i = start_col; i < start_col + length; ++i) {\n                grid[train_row][i] = train_char;\n            }\n            trains_added++;\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, trains_added);\n\n    // Output the grid\n    for (int i = 0; i < 3; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n}\n\nvoid generate_impossible_test_case(int n, int k) {\n    vector<string> grid(3, string(n, '.'));\n\n    // Place 's' in the leftmost column\n    int philip_row = rnd.next(3);\n    grid[philip_row][0] = 's';\n\n    // List of letters for trains\n    vector<char> letters;\n    for (char c = 'A'; c <= 'Z'; ++c) {\n        letters.push_back(c);\n    }\n\n    int trains_added = 0;\n\n    // Place trains in all three rows starting ahead of Philip to block him\n    int start_col = 1; // Immediately after Philip\n\n    // For each row\n    for (int row = 0; row < 3 && trains_added < k; ++row) {\n        // Place a train starting from start_col\n        if (start_col + 1 >= n) continue; // Need at least two cells\n\n        char train_char = letters[trains_added];\n        for (int i = start_col; i < min(n, start_col + 2); ++i) {\n            grid[row][i] = train_char;\n        }\n        trains_added++;\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, trains_added);\n\n    // Output the grid\n    for (int i = 0; i < 3; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 1);\n    int n = opt<int>(\"n\", 10); // default value\n    int k = opt<int>(\"k\", 1); // default number of trains\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", t);\n\n    for (int test = 0; test < t; ++test) {\n        if (type == \"random\") {\n            generate_random_test_case(n, k);\n        } else if (type == \"possible\") {\n            generate_possible_test_case(n, k);\n        } else if (type == \"impossible\") {\n            generate_impossible_test_case(n, k);\n        } else {\n            // Default to random if type is not recognized\n            generate_random_test_case(n, k);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -n 2 -k 1 -type random\n./gen -t 1 -n 2 -k 1 -type possible\n./gen -t 1 -n 2 -k 1 -type impossible\n./gen -t 1 -n 10 -k 3 -type random\n./gen -t 1 -n 10 -k 3 -type possible\n./gen -t 1 -n 10 -k 3 -type impossible\n./gen -t 1 -n 20 -k 5 -type random\n./gen -t 1 -n 20 -k 5 -type possible\n./gen -t 1 -n 20 -k 5 -type impossible\n./gen -t 1 -n 50 -k 10 -type random\n./gen -t 1 -n 50 -k 10 -type possible\n./gen -t 1 -n 50 -k 10 -type impossible\n./gen -t 1 -n 100 -k 20 -type random\n./gen -t 1 -n 100 -k 20 -type possible\n./gen -t 1 -n 100 -k 20 -type impossible\n./gen -t 1 -n 100 -k 26 -type random\n./gen -t 1 -n 100 -k 26 -type possible\n./gen -t 1 -n 100 -k 26 -type impossible\n./gen -t 5 -n 50 -k 10 -type random\n./gen -t 5 -n 50 -k 10 -type possible\n./gen -t 5 -n 50 -k 10 -type impossible\n./gen -t 10 -n 100 -k 26 -type random\n./gen -t 10 -n 100 -k 26 -type possible\n./gen -t 10 -n 100 -k 26 -type impossible\n./gen -t 1 -n 2 -k 1 -type random\n./gen -t 1 -n 2 -k 1 -type possible\n./gen -t 1 -n 2 -k 1 -type impossible\n./gen -t 1 -n 100 -k 1 -type random\n./gen -t 1 -n 100 -k 1 -type possible\n./gen -t 1 -n 100 -k 1 -type impossible\n./gen -t 1 -n 99 -k 25 -type random\n./gen -t 1 -n 99 -k 25 -type possible\n./gen -t 1 -n 99 -k 25 -type impossible\n./gen -t 1 -n 50 -k 5 -type random\n./gen -t 1 -n 50 -k 5 -type possible\n./gen -t 1 -n 50 -k 5 -type impossible\n./gen -t 1 -n 2 -k 26 -type impossible\n./gen -t 1 -n 100 -k 1 -type impossible\n./gen -t 1 -n 2 -k 26 -type possible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:45.606981",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "586/E",
      "title": "E. Алиса, Боб, Апельсины и Яблоки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных находится два целых числа x, y (1 ≤ x, y ≤ 1018, xy > 1) — количество апельсинов и яблок, которые изначально были в мешке.",
      "output_spec": "Выходные данныеВыведите любую последовательность карточек, удовлетворяющую условиям задачи в виде строки из символов 'A' и 'B' в сжатом виде. Это значит, что вам нужно заменить отрезки одинаковых подряд идущих символов на количество повторений символа и сам символ. Например, строку AAABAABBB нужно заменить на строку 3A1B2A3B, но нельзя заменить на 2A1A1B2A3B или на 3AB2A3B. Смотрите примеры для уточнения формата вывода. выведенная вами строка должна состоять из не более, чем 106 символов. Гарантируется, что если ответ существует, то существует его представление в сжатом виде, состоящее из не более чем 106 символов. Если возможных ответов несколько, разрешается вывести любой из них.Если последовательности карточек, удовлетворяющей условию задачи, не существует, выведите одно слово Impossible.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 4Выходные данныеСкопировать3BВходные данныеСкопировать2 2Выходные данныеСкопироватьImpossibleВходные данныеСкопировать3 2Выходные данныеСкопировать1A1B",
      "description": "E. Алиса, Боб, Апельсины и Яблоки\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных находится два целых числа x, y (1 ≤ x, y ≤ 1018, xy > 1) — количество апельсинов и яблок, которые изначально были в мешке.\n\nВходные данные\n\nВыходные данныеВыведите любую последовательность карточек, удовлетворяющую условиям задачи в виде строки из символов 'A' и 'B' в сжатом виде. Это значит, что вам нужно заменить отрезки одинаковых подряд идущих символов на количество повторений символа и сам символ. Например, строку AAABAABBB нужно заменить на строку 3A1B2A3B, но нельзя заменить на 2A1A1B2A3B или на 3AB2A3B. Смотрите примеры для уточнения формата вывода. выведенная вами строка должна состоять из не более, чем 106 символов. Гарантируется, что если ответ существует, то существует его представление в сжатом виде, состоящее из не более чем 106 символов. Если возможных ответов несколько, разрешается вывести любой из них.Если последовательности карточек, удовлетворяющей условию задачи, не существует, выведите одно слово Impossible.\n\nВыходные данные\n\nВходные данныеСкопировать1 4Выходные данныеСкопировать3BВходные данныеСкопировать2 2Выходные данныеСкопироватьImpossibleВходные данныеСкопировать3 2Выходные данныеСкопировать1A1B\n\nВходные данныеСкопировать1 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3B\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьImpossible\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1A1B\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере, если в ряду находились три карточки с буквой 'B', то Бобу пришлось бы три раза отдать Алисе по одному яблоку. Таким образом, в итоге у Алисы был бы один апельсин и три яблока, а у Боба одно яблоко. Значит в мешке изначально был один апельсин и четыре яблока.Во втором примере, ответа не существует, так как одной карточки было бы недостаточно для завершения игры, если же карточек было хотя бы две, то это значило бы, что в мешке изначально было хотя бы три яблока или апельсина.В третьем примере, на карточках были записаны буквы 'AB', поэтому после убирания первой карточки у Боба был бы один апельсин и одно яблоко, а после убирания второй карточки у Алисы было бы два апельсина и одно яблоко. Таким образом, изначально в мешке было три апельсина и два яблока.",
      "solutions": [
        {
          "title": "Разбор Codeforces Round #325 - Codeforces",
          "content": "586A - Расписание АлёныЗадачу подготовил adedalic.В этой задаче сначала нужно было выкинуть все нули на префиксе и суффиксе строки, после чего ответ был равен количеству единиц плюс количество нулей с двух сторон от которых стоят единицы. Асимптотическая сложность решения: O(n).586B - Лаврентий и магазинЗадачу подготовил Oleg_Smirnov.Назовем путь i-м (0 ≤ i ≤ n - 1), если мы, выходя из дома, сначала i раз идем налево, потом переходим проспект и снова n - 1 - i раз идем налево. Введем обозначение di — время, которое нам придется ждать на светофорах на i-м пути. Если рассмотреть путь из магазина домой с конца, то получится пути из дома в магазиг, поэтому искомый путь есть два разных пути из дома в магазин. Значит ответом на задачу является сумма наименьшего и второго по величине значения di. Значение di легко пересчитывается из значения di - 1, таким образом все di можно посчитать за один проход.Асимптотическая сложность решения: O(n).585A - Стоматолог ГеннадийЗадачу подготовил Neon.Заведем очередь в которой, будут находится дети. На каждой итерации решения пройдем по всем детям, если есть ребенок с отрицательной решимостью удалим его из очереди, а из решимостей детей с большими номерами вычтем di. Если все дети в очереди имеют решимость не меньше нуля, возьмем первого ребенка из очереди, а от решимостей остальных вычтем арифметическую прогрессию, как это описывается в условии.Асимптотическая сложность решения: O(n2).585B - Филипп и поездаЗадачу подготовил IlyaLos.В задаче требовалось просто промоделировать игру. Это можно сделать с помощью обхода в глубину, ширину или динамического программирования. Состоянием является пара чисел x, y — позиция Филиппа в туннеле, а значением или в зависимости от того, можем ли мы попасть из стартовой позиции в x, y. Положения поездов в каждый момент времени определяются однозначно.Асимптотическая сложность решения: O(n).585C - Алиса, Боб, Апельсины и ЯблокиЗадачу подготовил Edvard.Поймем для начала, что означает процесс описанный в условии. Если нарисовать дерево переходов по буквам и , то получится дерево Штерна-Броко. Пусть апельсины это значения знаменателя дроби, а яблоки — числителя. На каждом шагу у нас есть две дроби (изначально ) и мы заменяем либо первую дробь на их медианту, либо вторую. Таким образом, первая дробь есть первый предок влево от медианты, а вторая — первый предок вправо. Таким образом, искомый процесс это просто процесс поиска дроби в дереве Штерна-Броко, который завершается тем, что текущая медианта совпадает с дробью, которую мы ищем (момент окончания игры, описанный в условии). Значит, числа x, y заданные в условии это просто дробь, которую мы ищем. Отсюда следует, что ответа не существует, если x не взаимнопросто с y (поскольку таким дробей нет в дереве Штерна-Броко). Пусть теперь мы хотим найти дробь в дереве. Понятно, что если x > y, то мы сначала перейдем в правую ветку. Более того мы можем считать, что теперь ищем дробь и никуда не спускались. Если же x < y, то нам нужно спуситься в левую ветку и можно считать, что мы ищем дробь и пока никуда не спускались. Эти рассуждения легко формализовать, чтобы получить строгое доказательство. Таким образом, решение задачи сводится к выполнению алгоритма Евклида для пары чисел x, y. Как известно время работы алгоритма Евклида O(logn) (дольше всего алгоритм Евклида работает на двух последовательных числах Фибоначчи), значит длина ответа тоже растет как логарифм.Асимптотическая сложность решения: O(logn).585D - Lizard Era: BeginningЗадачу подготовил danilka.pro.Для решения этой задачи воспользуемся приемом . А именно переберем для первых (первая половина) заданий с какими спутницами главный герой будет путешествовать. Пусть при этом симпатия первой спутницы оказалась равна a, второй — b, а третьей c. Пусть существует способ выбрать спутниц для последующих (вторая половина) заданий так и пусть симпатии при этом будут равны a', b', c'. Тогда, чтобы по всем заданиям суммы симпатий были одинаковы необходимо и достаточно, чтобы a - b = b' - a' и b - c = c' - b'. Теперь для решения задачи достаточно перебрать первую половину и сохранить в некоторой структуре данных тройки чисел a - b, b - c, a (третье число нужно для максимизации ответа в случае равенства). Далее нужно перебрать вторую половину и найти в структуре данных значения b' - a', c' - b', m, где m — максимальное третье значение которое есть в структуре данных. В качестве структуры данных можно использовать map < pair < int, int > , int >  в языке C++, первые два числа это значение a - b, b - c, а третье — максимальное a соответствующее первым двум. Также можно все тройки сложить в один большой массив, отсортировать его и бинарным поиском находить необходимые значения.Асимптотическая сложность решения: , где logC — константа, появляющаяся вместе со структурой данных.585E - Подарок для филателиста ВиталикаЗадачу подготовил gridnevvvit.Пусть мы хотим посчитать количество подмножеств с НОД равным 1 — число A. Посчитаем это количество с помощью формулы включений-исключений: сначала скажем, что все подмножества нам подходят. Таких подмножеств 2n. Теперь вычтем подмножества с НОД кратным 2. Количество таких множеств 2cnt2 - 1, где cnti — количество чисел, делящихся на i. Далее вычитаем 2cnt3 - 1. Подмножества с НОД кратным 4 мы учли вместе с двойкой. Далее вычитаем 2cnt5 - 1. Теперь заметим, что подмножества с НОД кратным 6 мы вычли уже дважды: сначала с двойкой, затем с тройкой, поэтому давайте прибавим количество таких подмножеств 2cnt6 - 1. Продолжая этот процесс получаем, что для числа d, к ответу нужно прибавить величину μ(d)(2cntd - 1), где μ(d) равно 0, если d делится на полный квадрат, 1, если количество простых в факторизации d четно и  - 1 в противном случае. Значит числа, делящиеся на полный квадрат мы можем не суммировать, поскольку они входят с коэффициентом 0. Для подсчета значений cnti достаточно факторизовать все числа и для каждого за 2k перебрать делитель, со значением μ(d) ≠ 0. Теперь легко понять, что количество подмножеств с НОД большим 1 равно B = 2n - A. Теперь для решения задачи давайте переберем марку, которую купит Виталик ai. Пересчитаем число B так, как если бы числа ai не было в множестве. Для этого нужно просто вычесть те слагаемые на которые повлияло число ai. Это можно сделать за 2k, где k — количество простых в факторизации числа ai (снова нужно перебрать делители ai со значением μ(d) ≠ 0). Теперь поймем какие подмножества дадут НОД равный 1 вместе с выбранной маркой. Понятно это те подмножества НОД которых больше 1, но при этом не делится ни на один делитель ai. Для этого снова воспользуемся формулой включений-исключений. Для каждого делителя d числа ai вычтем из B значение μ(d)(2cntd - 1). Таким образом, мы получим количество способов Bi выбрать подмножество c НОД большим 1, но при это взаимнопростым с ai. Ответом на задачу является сумма всех Bi. Наибольшее количество простых в факторизации числа не превосходящего 107 равно 8. Факторизацию чисел можно выполнить с помощью линейного алгоритма поиска минимального делителя чисел от 1 до n, либо с помощью решета Эратосфена за время O(nloglogn).Асимптотическая сложность решения: O(C + n2K), где , а K — наибольшее количество простых в факторизации чисел ai.585F - Знаки числа ПиЗадачу подготовил Edvard.Расмотрим все подстроки строки s длины . Сложим все эти строки в бор, посчитаем суффиксные ссылки и построим автомат по цифрам. Это можно сделать за линейное время с помощью алгоритма Ахо-Корасик. Теперь для решения задачи посчитаем динамику zi, v, b1, b2, b в котором состояние описывается пятеркой чисел: i — количество цифр которые мы уже поставили в искомом числе, которое встречается , v — в какой вершине бора мы находимся, b1 — равен ли префикс числа, которое мы набираем префиксу числа x, b2 — равен ли префикс числа, которое мы набираем префиксу числа y, b — находится ли некоторая подстрока длина на уже набранном префиксе в боре (значения b1, b2, b — равны либо 0, либо 1). Значением динамики является количество способов набрать префикс с заданным набором свойств. Для того, чтобы сделать переход нужно перебрать цифру, проверить что мы не вышли за границы отрезка [x, y], перейти от вершины v к следующей вершине по автомату и заданной цифре. Ответом является сумма по всем v, b1, b2 zb, v, v1, v2, 1.Асимптотическая сложность решения: O(nd2).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20898",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 586 和字母"
          },
          "content_length": 8320
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 1",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 2",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 3",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 4",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long x = inf.readLong(1, 1000000000000000000LL, \"x\");\n    inf.readSpace();\n    long long y = inf.readLong(1, 1000000000000000000LL, \"y\");\n    inf.readEoln();\n\n    ensuref(x != 1 || y != 1, \"The product x*y must be greater than 1, but x = y = 1.\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long x = inf.readLong(1, 1000000000000000000LL, \"x\");\n    inf.readSpace();\n    long long y = inf.readLong(1, 1000000000000000000LL, \"y\");\n    inf.readEoln();\n\n    ensuref(x != 1 || y != 1, \"The product x*y must be greater than 1, but x = y = 1.\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long x = inf.readLong(1, 1000000000000000000LL, \"x\");\n    inf.readSpace();\n    long long y = inf.readLong(1, 1000000000000000000LL, \"y\");\n    inf.readEoln();\n\n    ensuref(x != 1 || y != 1, \"The product x*y must be greater than 1, but x = y = 1.\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// We will simulate the game in aggregated manner. If we have n consecutive 'A's:\n//   - Each 'A' means: Alice gives Bob all her fruit, then she takes from the bag\n//     that exact set of fruit (so, effectively, Bob gains Alice's fruit, and\n//     the bag loses that many).\n//   - Doing n 'A' operations in a row means Bob's fruit is incremented by\n//     n * (Alice's fruit), and the bag is decremented by the same total amount.\n//   - Similarly for n consecutive 'B's, but with roles of Alice and Bob swapped.\n//\n// We also must check that the compressed format is valid (no two consecutive\n// runs with the same letter, each repetition > 0, etc.).\n//\n// The checker compares the jury's answer (ans) with the contestant's answer (ouf).\n// - If the jury shows a valid sequence, then a solution definitely exists.\n//   * If the contestant output is invalid or \"Impossible\", we print WA.\n//   * If the contestant output is also valid, we print OK.\n// - If the jury shows \"Impossible\", then presumably there is no solution.\n//   * If the contestant finds a valid solution, we print FAIL (the jury is wrong).\n//   * If the contestant also says \"Impossible\", we print OK.\n\nstatic long long x, y; // total oranges (x) and apples (y) found in the bag initially.\n\n// Helper function to check one solution (either jury's or participant's).\n// Returns true if the provided stream says there IS a valid solution.\n// Returns false if the stream says \"Impossible\" or if it fails in a correct manner.\n// If the solution is invalid, we call quitf with the appropriate verdict.\nbool readAndCheckSolution(InStream &stream, bool isParticipant, long long X, long long Y) {\n    // Read a single token. This can be \"Impossible\" or a compressed sequence.\n    if (!stream.seekEof()) {\n        // We allow them to print either \"Impossible\" or some RLE string (e.g. \"3A1B2A\").\n        string token = stream.readToken();\n\n        // If the token is exactly \"Impossible\", then we interpret that\n        // as \"no solution from this stream\".\n        if (token == \"Impossible\") {\n            return false;\n        }\n\n        // Otherwise, we expect it to be a compressed form of the sequence of 'A'/'B'.\n        // We also check the length constraint: \"The string that you print\n        // should consist of at most 10^6 characters.\"\n        if ((int)token.size() > 1000000) {\n            stream.quitf(isParticipant ? _wa : _fail,\n                         \"Output exceeds 10^6 characters\");\n        }\n\n        // We'll parse the token as pairs: [positive integer][letter A or B].\n        // Check that consecutive letters are not the same. We'll simulate\n        // the game in an aggregated manner.\n\n        // Initial fruit distribution: \n        // Alice has 1 orange, 0 apples.\n        // Bob has 0 oranges, 1 apple.\n        // The bag has X-1 oranges, Y-1 apples (because Alice took an orange\n        // and Bob took an apple initially).\n        if (X == 0 || Y == 0) {\n            // The problem statement says x, y >= 1 and x*y > 1, so we should never get here\n            // if the input was valid. But just in case:\n            stream.quitf(isParticipant ? _wa : _fail, \"Invalid x or y in input\");\n        }\n        long long Aor = 1, Aap = 0;        // Alice's oranges, apples\n        long long Bor = 0, Bap = 1;        // Bob's oranges, apples\n        long long BagOr = X - 1, BagAp = Y - 1;\n\n        // We'll parse the token from left to right, collecting each run (count + letter).\n        // Keep track of the last letter to ensure no double-literal runs like \"3A2A\".\n        char lastLetter = 0;\n\n        // We'll parse by scanning digits, then exactly one letter.\n        for (int i = 0; i < (int)token.size();) {\n            // 1) parse the repetition count (must be positive, up to 1e18).\n            if (!isdigit(token[i])) {\n                stream.quitf(isParticipant ? _wa : _fail,\n                             \"Invalid format: expected digit at position %d\", i+1);\n            }\n            long long runCount = 0;\n            int startDigitsPos = i;\n            while (i < (int)token.size() && isdigit(token[i])) {\n                // parse the number\n                // watch out for overflow > 1e18\n                int d = (token[i] - '0');\n                // we'll check for overflow in 64-bit arithmetic.\n                if (runCount > (LLONG_MAX - d) / 10) {\n                    stream.quitf(isParticipant ? _wa : _fail,\n                                 \"Repetition count is too large (overflow) near position %d\", i+1);\n                }\n                runCount = runCount * 10 + d;\n                i++;\n            }\n            if (runCount <= 0) {\n                stream.quitf(isParticipant ? _wa : _fail,\n                             \"Repetition count must be positive near position %d\", startDigitsPos+1);\n            }\n            // 2) parse the letter\n            if (i >= (int)token.size()) {\n                stream.quitf(isParticipant ? _wa : _fail,\n                             \"Invalid format: missing letter after digits at end of string\");\n            }\n            char c = token[i++];\n            if (c != 'A' && c != 'B') {\n                stream.quitf(isParticipant ? _wa : _fail,\n                             \"Invalid letter '%c' at position %d (expected 'A' or 'B')\",\n                             c, i);\n            }\n            // check consecutive runs with same letter\n            if (c == lastLetter) {\n                stream.quitf(isParticipant ? _wa : _fail,\n                             \"Consecutive runs with the same letter '%c'\", c);\n            }\n            lastLetter = c;\n\n            // Now apply runCount times this operation in an aggregated manner.\n            // If c == 'A': Bob gets Aor,Bap += ...\n            // If c == 'B': Alice gets ...\n            // But each time we must ensure the bag has enough fruit.\n\n            if (c == 'A') {\n                // We need runCount * Aor <= BagOr\n                // and runCount * Aap <= BagAp\n                if (Aor > 0) {\n                    long long need = runCount * Aor;\n                    if (need > BagOr) {\n                        stream.quitf(isParticipant ? _wa : _fail,\n                                     \"Not enough oranges in the bag for repeated 'A' operation\");\n                    }\n                    BagOr -= need;\n                    Bor += need;\n                }\n                if (Aap > 0) {\n                    long long need = runCount * Aap;\n                    if (need > BagAp) {\n                        stream.quitf(isParticipant ? _wa : _fail,\n                                     \"Not enough apples in the bag for repeated 'A' operation\");\n                    }\n                    BagAp -= need;\n                    Bap += need;\n                }\n            } else {\n                // c == 'B'\n                // runCount * Bor <= BagOr\n                // runCount * Bap <= BagAp\n                if (Bor > 0) {\n                    long long need = runCount * Bor;\n                    if (need > BagOr) {\n                        stream.quitf(isParticipant ? _wa : _fail,\n                                     \"Not enough oranges in the bag for repeated 'B' operation\");\n                    }\n                    BagOr -= need;\n                    Aor += need;\n                }\n                if (Bap > 0) {\n                    long long need = runCount * Bap;\n                    if (need > BagAp) {\n                        stream.quitf(isParticipant ? _wa : _fail,\n                                     \"Not enough apples in the bag for repeated 'B' operation\");\n                    }\n                    BagAp -= need;\n                    Aap += need;\n                }\n            }\n        }\n\n        // After processing all runs, the bag must be empty.\n        if (BagOr != 0 || BagAp != 0) {\n            stream.quitf(isParticipant ? _wa : _fail,\n                         \"The bag is not empty at the end of the game\");\n        }\n\n        // If we made it here, this solution is valid. Return true.\n        return true;\n    }\n    else {\n        // No tokens at all => invalid format or empty output\n        stream.quitf(isParticipant ? _wa : _fail, \"Empty output\");\n        // never reaches here\n        return false;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read x,y from the input file.\n    // 1 <= x,y <= 1e18, x*y > 1.\n    x = inf.readLong(1, (long long)1e18, \"x\");\n    y = inf.readLong(1, (long long)1e18, \"y\");\n    // Condition x*y > 1 => total fruit >= 2\n    // We'll trust the input is correct as per the statement.\n\n    // Read jury's answer.\n    bool jurySolutionExists = readAndCheckSolution(ans, /*isParticipant=*/false, x, y);\n\n    // Read participant's answer.\n    bool participantSolutionExists = readAndCheckSolution(ouf, /*isParticipant=*/true, x, y);\n\n    // Now decide verdict:\n    // If jury has a solution and participant does not, WA.\n    if (jurySolutionExists && !participantSolutionExists) {\n        quitf(_wa, \"Participant claims 'Impossible' or produced an invalid solution, but jury has a valid solution.\");\n    }\n    // If jury says \"Impossible\" but participant found a valid solution, FAIL.\n    if (!jurySolutionExists && participantSolutionExists) {\n        quitf(_fail, \"Jury says 'Impossible' but participant found a valid solution.\");\n    }\n    // If both have no solution => OK\n    if (!jurySolutionExists && !participantSolutionExists) {\n        quitf(_ok, \"Both answers say 'Impossible'\");\n    }\n    // If both have a solution => OK\n    quitf(_ok, \"Both answers have valid solutions\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    long long x = opt<long long>(\"x\", -1);\n    long long y = opt<long long>(\"y\", -1);\n\n    // Constraints\n    const long long MAX_N = 1000000000000000000LL; // 1e18\n    const long long MIN_N = 1LL;\n\n    if (x != -1 && y != -1) {\n        if (x < MIN_N || x > MAX_N || y < MIN_N || y > MAX_N || x * y <= 1LL) {\n            cerr << \"Invalid x and y provided in parameters!\" << endl;\n            exit(1);\n        }\n        printf(\"%lld %lld\\n\", x, y);\n        return 0;\n    }\n\n    if (type == \"small\") {\n        x = rnd.next(2LL, 10LL);\n        y = rnd.next(2LL, 10LL);\n    } else if (type == \"large\") {\n        x = rnd.next(MAX_N / 2, MAX_N);\n        y = rnd.next(MAX_N / 2, MAX_N);\n    } else if (type == \"equal\") {\n        x = y = rnd.next(MIN_N + 1, MAX_N);\n    } else if (type == \"x_is_one\") {\n        x = 1;\n        y = rnd.next(2LL, MAX_N);\n    } else if (type == \"y_is_one\") {\n        x = rnd.next(2LL, MAX_N);\n        y = 1;\n    } else if (type == \"impossible\") {\n        x = 1;\n        y = 1;\n    } else if (type == \"random\") {\n        x = rnd.next(MIN_N + 1, MAX_N);\n        y = rnd.next(MIN_N + 1, MAX_N);\n        while (x * y <= 1) {\n            x = rnd.next(MIN_N + 1, MAX_N);\n            y = rnd.next(MIN_N + 1, MAX_N);\n        }\n    } else if (type == \"max\") {\n        x = y = MAX_N;\n    } else if (type == \"x_large_y_small\") {\n        x = rnd.next(MAX_N / 2, MAX_N);\n        y = rnd.next(MIN_N + 1, MIN_N + 10);\n    } else if (type == \"x_small_y_large\") {\n        x = rnd.next(MIN_N + 1, MIN_N + 10);\n        y = rnd.next(MAX_N / 2, MAX_N);\n    } else if (type == \"x_and_y_prime\") {\n        x = 1000000007LL;\n        y = 1000000009LL;\n    } else if (type == \"x_is_power_of_two\") {\n        x = 1LL << rnd.next(1, 60); // Powers of two up to 2^60\n        y = rnd.next(MIN_N + 1, MAX_N);\n    } else if (type == \"y_is_power_of_two\") {\n        x = rnd.next(MIN_N + 1, MAX_N);\n        y = 1LL << rnd.next(1, 60); // Powers of two up to 2^60\n    } else if (type == \"x_near_max_y_small\") {\n        x = MAX_N - rnd.next(0LL, 10LL);\n        y = MIN_N + rnd.next(1LL, 10LL);\n    } else if (type == \"impossible_cases\") {\n        x = rnd.next(2LL, 100LL);\n        y = rnd.next(2LL, 100LL);\n        // For impossible cases, make sure x and y are small and potentially lead to impossible answers\n    } else {\n        cerr << \"Unknown type parameter!\" << endl;\n        exit(1);\n    }\n\n    if (x * y <= 1LL) {\n        // Ensure the constraints are met\n        x = 2LL; y = 2LL;\n    }\n\n    printf(\"%lld %lld\\n\", x, y);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    long long x = opt<long long>(\"x\", -1);\n    long long y = opt<long long>(\"y\", -1);\n\n    // Constraints\n    const long long MAX_N = 1000000000000000000LL; // 1e18\n    const long long MIN_N = 1LL;\n\n    if (x != -1 && y != -1) {\n        if (x < MIN_N || x > MAX_N || y < MIN_N || y > MAX_N || x * y <= 1LL) {\n            cerr << \"Invalid x and y provided in parameters!\" << endl;\n            exit(1);\n        }\n        printf(\"%lld %lld\\n\", x, y);\n        return 0;\n    }\n\n    if (type == \"small\") {\n        x = rnd.next(2LL, 10LL);\n        y = rnd.next(2LL, 10LL);\n    } else if (type == \"large\") {\n        x = rnd.next(MAX_N / 2, MAX_N);\n        y = rnd.next(MAX_N / 2, MAX_N);\n    } else if (type == \"equal\") {\n        x = y = rnd.next(MIN_N + 1, MAX_N);\n    } else if (type == \"x_is_one\") {\n        x = 1;\n        y = rnd.next(2LL, MAX_N);\n    } else if (type == \"y_is_one\") {\n        x = rnd.next(2LL, MAX_N);\n        y = 1;\n    } else if (type == \"impossible\") {\n        x = 1;\n        y = 1;\n    } else if (type == \"random\") {\n        x = rnd.next(MIN_N + 1, MAX_N);\n        y = rnd.next(MIN_N + 1, MAX_N);\n        while (x * y <= 1) {\n            x = rnd.next(MIN_N + 1, MAX_N);\n            y = rnd.next(MIN_N + 1, MAX_N);\n        }\n    } else if (type == \"max\") {\n        x = y = MAX_N;\n    } else if (type == \"x_large_y_small\") {\n        x = rnd.next(MAX_N / 2, MAX_N);\n        y = rnd.next(MIN_N + 1, MIN_N + 10);\n    } else if (type == \"x_small_y_large\") {\n        x = rnd.next(MIN_N + 1, MIN_N + 10);\n        y = rnd.next(MAX_N / 2, MAX_N);\n    } else if (type == \"x_and_y_prime\") {\n        x = 1000000007LL;\n        y = 1000000009LL;\n    } else if (type == \"x_is_power_of_two\") {\n        x = 1LL << rnd.next(1, 60); // Powers of two up to 2^60\n        y = rnd.next(MIN_N + 1, MAX_N);\n    } else if (type == \"y_is_power_of_two\") {\n        x = rnd.next(MIN_N + 1, MAX_N);\n        y = 1LL << rnd.next(1, 60); // Powers of two up to 2^60\n    } else if (type == \"x_near_max_y_small\") {\n        x = MAX_N - rnd.next(0LL, 10LL);\n        y = MIN_N + rnd.next(1LL, 10LL);\n    } else if (type == \"impossible_cases\") {\n        x = rnd.next(2LL, 100LL);\n        y = rnd.next(2LL, 100LL);\n        // For impossible cases, make sure x and y are small and potentially lead to impossible answers\n    } else {\n        cerr << \"Unknown type parameter!\" << endl;\n        exit(1);\n    }\n\n    if (x * y <= 1LL) {\n        // Ensure the constraints are met\n        x = 2LL; y = 2LL;\n    }\n\n    printf(\"%lld %lld\\n\", x, y);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -type small\n./gen -type small\n./gen -type small\n\n# Large test cases\n./gen -type large\n./gen -type large\n./gen -type large\n\n# Equal x and y\n./gen -type equal\n./gen -type equal\n./gen -type equal\n\n# x is one\n./gen -type x_is_one\n./gen -type x_is_one\n\n# y is one\n./gen -type y_is_one\n./gen -type y_is_one\n\n# Impossible cases\n./gen -type impossible\n./gen -type impossible\n\n# Random cases\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Maximum cases\n./gen -type max\n./gen -type max\n\n# x large, y small\n./gen -type x_large_y_small\n./gen -type x_large_y_small\n\n# x small, y large\n./gen -type x_small_y_large\n./gen -type x_small_y_large\n\n# x and y are primes\n./gen -type x_and_y_prime\n./gen -type x_and_y_prime\n\n# x is power of two\n./gen -type x_is_power_of_two\n./gen -type x_is_power_of_two\n\n# y is power of two\n./gen -type y_is_power_of_two\n./gen -type y_is_power_of_two\n\n# x near max, y small\n./gen -type x_near_max_y_small\n./gen -type x_near_max_y_small\n\n# Additional impossible cases\n./gen -type impossible_cases\n./gen -type impossible_cases\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:47.777358",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "586/F",
      "title": "F. Lizard Era: Beginning",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains positive integer n (1 ≤ n ≤ 25) — the number of important tasks. Next n lines contain the descriptions of the tasks — the i-th line contains three integers li, mi, wi — the values by which the attitude of Lynn, Meliana and Worrigan respectively will change towards the hero if the hero takes them on the i-th task. All the numbers in the input are integers and do not exceed 107 in absolute value.",
      "output_spec": "OutputIf there is no solution, print in the first line \"Impossible\".Otherwise, print n lines, two characters is each line — in the i-th line print the first letters of the companions' names that hero should take to complete the i-th task ('L' for Lynn, 'M' for Meliana, 'W' for Worrigan). Print the letters in any order, if there are multiple solutions, print any of them.",
      "sample_tests": "ExamplesInputCopy31 0 00 1 00 0 1OutputCopyLMMWMWInputCopy70 8 95 9 -26 -8 -79 4 5-4 -9 9-4 5 2-6 8 -7OutputCopyLMMWLMLWMWLMLWInputCopy21 0 01 1 0OutputCopyImpossible",
      "description": "F. Lizard Era: Beginning\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains positive integer n (1 ≤ n ≤ 25) — the number of important tasks. Next n lines contain the descriptions of the tasks — the i-th line contains three integers li, mi, wi — the values by which the attitude of Lynn, Meliana and Worrigan respectively will change towards the hero if the hero takes them on the i-th task. All the numbers in the input are integers and do not exceed 107 in absolute value.\n\nOutputIf there is no solution, print in the first line \"Impossible\".Otherwise, print n lines, two characters is each line — in the i-th line print the first letters of the companions' names that hero should take to complete the i-th task ('L' for Lynn, 'M' for Meliana, 'W' for Worrigan). Print the letters in any order, if there are multiple solutions, print any of them.\n\nInputCopy31 0 00 1 00 0 1OutputCopyLMMWMWInputCopy70 8 95 9 -26 -8 -79 4 5-4 -9 9-4 5 2-6 8 -7OutputCopyLMMWLMLWMWLMLWInputCopy21 0 01 1 0OutputCopyImpossible\n\nInputCopy31 0 00 1 00 0 1\n\nOutputCopyLMMWMW\n\nInputCopy70 8 95 9 -26 -8 -79 4 5-4 -9 9-4 5 2-6 8 -7\n\nOutputCopyLMMWLMLWMWLMLW\n\nInputCopy21 0 01 1 0\n\nOutputCopyImpossible",
      "solutions": [
        {
          "title": "Разбор Codeforces Round #325 - Codeforces",
          "content": "586A - Alena's ScheduleThe problem has been prepared by adedalic.To solve this problem one should remove all leading and trailing zeroes from array and then calculate the number of ones and number of zeroes neighboured by ones. The sum of this values is the answer for the problem.Complexity: O(n).586B - Laurenty and ShopThe problem has been prepared by Oleg_Smirnov.Let's call some path ith if we start it by going i times left, then we cross the prospect and go left n - 1 - i times again. Let di be equal to the time we should wait on traffic lights while following i-th path. If we consider any way from the shop to home, it is equal (but reversed) to only path from home to the shop, meaning that we need to find two distinct paths from home to the shop. So the answer to the problem is the sum of the smallest and the second smallest values among di. One could easily calculate di using calculated di - 1, so di could be found in one for cycle.If we will consider only two minimum values among di, solution complexity will be O(n).Complexity: O(n).585A - Gennady the DentistThe problem has been prepared by Neon.Let's store for each child his current confidence value and a boolean indicating whether child had left the queue (or visited the dentist office) or not. Then one could easily process children one by one, considering only children who still are in the queue (using boolean array), and changing stored values.Such solution has complexity O(n2) and requires author's attention much, especially the case with possible confidence value overflowing. Of course there are much faster solutions not required in our case.585B - Phillip and TrainsThe problem has been prepared by IlyaLos.One could consider a graph with vertices corresponding to every (x, y) position. I should notice that train positions for each Phillip position are fully restorable from his y coordinate. Edge between vertices u and v means that we could get from position corresponding to u to position corresponding by v in one turn without moving onto a train cell or moving in a cell which will be occupied by some train before the next turn. All we need next is to find whether any finishing position is reachable from the only starting position (using BFS or DFS, or, as soon as graph is a DAG, dynamic programming).As soon as graph has O(n) vertices and O(n) edges, solution complexity equals to O(n).585C - Alice, Bob, Oranges and ApplesThe problem has been prepared by Edvard.Firstly, let's understand the process described in problem statement. If one would write a tree of a sum-pairs (x, y) with letters and , he would get the Stern–Brocot tree. Let the number of oranges be enumerator and the number of apples be denumerator of fraction. At every step we have two fractions (at first step they are ) and should replace exactly one of them with their mediant. In such way first fraction is first parent to the left from mediant while second fraction is parent to the right. The process described in statement is, this way, a process of finding a fraction in the Stern-Brocot tree, finishing when the current mediant is equal to current node in the tree and (x, y) pair is the fraction we are searching. This means that if , (x, y) does not correspond to any correct fraction and the answer is \"Impossible\". Other way, we could find it in the tree. If x > y, we should firstly go in the right subtree. Moreover, we could then consider we are searching from the root. If x < y, we should go left and next consider from the root. This gives us Euclidian algorithm, which could be realized to work in complexity.Complexity: O(logn).585D - Lizard Era: BeginningThe problem has been prepared by danilka.pro.To solve the problem we will use meet-in-the-middle approach. For we should consider all variants. Let in some variant approval values of three companions are a, b, c respectively. If we will consider some variant from other half (there are of them) and a', b', c' approval values, then to ``merge'' such two parts correctly, two conditions a - b = b' - a' и b - c = c' - b' must be true (a + a' = b + b' = c + c' is true), and the value we are maximizing is a + a'.This way, to solve the task one could consider every variant from the first half and store for every possible pair (a - b, b - c) the maximum a value achievable (using, for example, the structure or any fast sorting algorithm). If one would then consider every variant from the second half, he just need to find (b' - a', c' - b') pair in the structure to get the maximum a value if possible and update answer with a + a' value. Answer restoring is pretty same to the algorithm above.Such solution has complexity.585E - Present for Vitalik the Philatelist The problem has been prepared by gridnevvvit.Let's calculate the number of subsets with gcd equal to 1 — value A. Let's do that using principle of inclusions-exclusions: firstly we say that all subsets is good. The total number of subsets is equal to 2n. Now let's subtract subsets with gcd divisible by 2. The number of that subsets is equal to 2cnt2 - 1 (cnti is the number of numbers that is divisable by i). Next we should subtract 2cnt3 - 1. Subsets with gcd divisible by 4 we already counted with number two. Next we should subtract 2cnt5 - 1. Now we should notice that subsets with gcd divisible by 6 we already processed twice: firstly with number 2, then with — 3, so let's add the number of these subsets 2cnt6 - 1. If we continue this process we will get, that for all numbers d we should add the value μ(d)(2cntd - 1), where μ(d) is equals to 0, if d is divisible by square of some prime, 1, if the number of primes in factorization of d is even and  - 1 in other case. So the numbers that is divisible by square of some prime we can ignore, because they have coefficient 0. To calculate values cnti we should factorize all numbers and iterate over 2k divisors with value μ(d) ≠ 0. Now it's easy to see, that the number of subsets with gcd greater than 1 equals to B = 2n - A. To solve the problem let's fix the stamp that Vitaliy will buy ai. Let's recalculate the number B for array a without element ai. To do that we should only subtract those terms that was affected by number ai. We can do that in 2k, where k is the number of primes in factorization of the number ai. It's easy to see that only the subsets with gcd greater than 1, but not divisible by any divisor of ai, should we counted in answer. To calculate number of those subsets let's again use the principle of inclusions-exclusions. For every divisor d of ai let's subtract the value μ (2cntd - 1) from B. So now we got Bi — the number of subsets with gcd greater than 1, but coprime with ai. The answer to problem is the sum over all Bi. The maximum number of primes in factorization of number not greater than 107 is equal to 8. We can factorize all numbers from 1 to n in linear time by algorithm for finding the smallest divisors for all intergers from 1 to n, or by sieve of Eratosthenes in O(nloglogn) time.Complexity: O(C + n2K), where , K — is the largest number of primes in factorization of ai.585F - Digits of Number PiThe problem has been prepared by Edvard.Consider all substrings of string s with length . Let's add them all to trie data structure, calculate failure links and build automata by digits. We can do that in linear time using Aho-Korasik algorithm. Now to solve the problem we should calculate dp zi, v, b1, b2, b. State of dp is described by five numbers: i — number of digits, that we already put to our number, v — in which vertex of trie we are, b1 — equals to one if the prefix that we built is equals to prefix of x, b2 — equals to one if the prefix that we built is equals to prefix of y, b — equals to one if we already have some substring with length on the prexif that we built. The value of dp is the number of ways to built prefix with the given set of properties. To update dp we should iterate over the digit that we want to add to prefix, check that we still is in segment [x, y], go from vertex v to the next vertex in automata. So the answer is the sum by all v, b1, b2 zb, v, v1, v2, 1.Complexity: O(nd2).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/20898",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 586 和字母"
          },
          "content_length": 8145
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 1",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 2",
          "code": "4\n2 0 0\n1 0 2\n0 0 0\n0 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 3",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #325 - Codeforces - Code 4",
          "code": "6\n1 0 1\n1 1 0\n0 1 1\n0 1 1\n1 1 0\n1 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20898",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 25);\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int l = inf.readInt(-10000000, 10000000);\n        inf.readSpace();\n        int m = inf.readInt(-10000000, 10000000);\n        inf.readSpace();\n        int w = inf.readInt(-10000000, 10000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 25);\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int l = inf.readInt(-10000000, 10000000);\n        inf.readSpace();\n        int m = inf.readInt(-10000000, 10000000);\n        inf.readSpace();\n        int w = inf.readInt(-10000000, 10000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 25);\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int l = inf.readInt(-10000000, 10000000);\n        inf.readSpace();\n        int m = inf.readInt(-10000000, 10000000);\n        inf.readSpace();\n        int w = inf.readInt(-10000000, 10000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<vector<int>> quests; // [n][3], attitude changes for L, M, W\n\n// Function to read, validate and compute the total attitude value from a stream (output or ans)\nint readAns(InStream& stream) {\n    string line = stream.readToken();\n    if (line == \"Impossible\") {\n        return INT_MIN; // Special indicator for impossible\n    }\n    // Read the remaining lines\n    vector<string> selection;\n    selection.push_back(line);\n    for (int i = 1; i < n; i++) {\n        selection.push_back(stream.readToken());\n    }\n    \n    // Validate and process selection\n    if ((int)selection.size() != n) {\n        stream.quitf(_wa, \"Expected %d lines of companion choices, found %d lines\", n, (int)selection.size());\n    }\n    \n    vector<int> attitudes(3, 0); // attitudes for L, M, W\n    for (int quest = 0; quest < n; quest++) {\n        string s = selection[quest];\n        if ((int)s.size() != 2) {\n            stream.quitf(_wa, \"Invalid selection length at line %d\", quest + 1);\n        }\n        set<char> companions;\n        for (char c : s) {\n            if (c != 'L' && c != 'M' && c != 'W') {\n                stream.quitf(_wa, \"Invalid companion character '%c' at line %d\", c, quest + 1);\n            }\n            companions.insert(c);\n        }\n        if ((int)companions.size() != 2) {\n            stream.quitf(_wa, \"Companions are not distinct at line %d\", quest + 1);\n        }\n        // Update attitudes\n        for (char c : companions) {\n            int idx = (c == 'L') ? 0 : (c == 'M') ? 1 : 2;\n            attitudes[idx] += quests[quest][idx];\n        }\n    }\n    // Check if attitudes are equal\n    if (!(attitudes[0] == attitudes[1] && attitudes[1] == attitudes[2])) {\n        stream.quitf(_wa, \"Final attitudes are not equal\");\n    }\n    // Return the final attitude value\n    return attitudes[0]; // Since attitudes[0] == attitudes[1] == attitudes[2]\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read the input file\n    n = inf.readInt();\n    quests.resize(n, vector<int>(3));\n    for (int i = 0; i < n; i++) {\n        quests[i][0] = inf.readInt(); // L\n        quests[i][1] = inf.readInt(); // M\n        quests[i][2] = inf.readInt(); // W\n    }\n    // Read judge's answer\n    int judge_attitude = readAns(ans);\n    // Read participant's answer\n    int part_attitude = readAns(ouf);\n    // If judge's answer is impossible\n    if (judge_attitude == INT_MIN) {\n        if (part_attitude == INT_MIN)\n            quitf(_ok, \"Both report impossible\");\n        else\n            quitf(_fail, \"Participant found a solution but jury says impossible\");\n    } else {\n        if (part_attitude == INT_MIN) {\n            quitf(_wa, \"Participant reports impossible but solution exists\");\n        } else {\n            if (part_attitude < judge_attitude) {\n                quitf(_wa, \"Participant's final attitude (%d) less than optimal (%d)\", part_attitude, judge_attitude);\n            } else if (part_attitude == judge_attitude) {\n                quitf(_ok, \"Correct solution with final attitude %d\", part_attitude);\n            } else { // part_attitude > judge_attitude\n                quitf(_fail, \"Participant's final attitude (%d) better than optimal (%d)\", part_attitude, judge_attitude);\n            }\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    if (type == \"all_zero\") {\n        // All attitude changes are zero\n        for (int i = 0; i < n; ++i) {\n            printf(\"0 0 0\\n\");\n        }\n    } else if (type == \"random\") {\n        // Random li, mi, wi within [-1e7, 1e7]\n        for (int i = 0; i < n; ++i) {\n            int li = rnd.next(-10000000, 10000000);\n            int mi = rnd.next(-10000000, 10000000);\n            int wi = rnd.next(-10000000, 10000000);\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    } else if (type == \"impossible\") {\n        // Generate a case where it's impossible to equalize the attitudes\n        // For this case, we ensure that the attitude of one companion will always be higher\n        // We set li = 1, mi = 0, wi = 0 for all tasks\n        for (int i = 0; i < n; ++i) {\n            printf(\"1 0 0\\n\");\n        }\n    } else if (type == \"possible\") {\n        // Generate a case where it's possible to equalize the attitudes\n        // We generate random values and try to balance them\n        for (int i = 0; i < n; ++i) {\n            int li = rnd.next(-100, 100);\n            int mi = rnd.next(-100, 100);\n            int wi = rnd.next(-100, 100);\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    } else if (type == \"max_attitude\") {\n        // Generate a case where multiple solutions exist,\n        // but maximizing total attitude is required\n        for (int i = 0; i < n; ++i) {\n            // Provide higher values to create variance in total attitudes\n            int li = rnd.next(0, 10000000);\n            int mi = rnd.next(0, 10000000);\n            int wi = rnd.next(0, 10000000);\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    } else if (type == \"negative\") {\n        // Generate a case with negative values\n        for (int i = 0; i < n; ++i) {\n            int li = rnd.next(-10000000, 0);\n            int mi = rnd.next(-10000000, 0);\n            int wi = rnd.next(-10000000, 0);\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    } else {\n        // Handle invalid types\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    if (type == \"all_zero\") {\n        // All attitude changes are zero\n        for (int i = 0; i < n; ++i) {\n            printf(\"0 0 0\\n\");\n        }\n    } else if (type == \"random\") {\n        // Random li, mi, wi within [-1e7, 1e7]\n        for (int i = 0; i < n; ++i) {\n            int li = rnd.next(-10000000, 10000000);\n            int mi = rnd.next(-10000000, 10000000);\n            int wi = rnd.next(-10000000, 10000000);\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    } else if (type == \"impossible\") {\n        // Generate a case where it's impossible to equalize the attitudes\n        // For this case, we ensure that the attitude of one companion will always be higher\n        // We set li = 1, mi = 0, wi = 0 for all tasks\n        for (int i = 0; i < n; ++i) {\n            printf(\"1 0 0\\n\");\n        }\n    } else if (type == \"possible\") {\n        // Generate a case where it's possible to equalize the attitudes\n        // We generate random values and try to balance them\n        for (int i = 0; i < n; ++i) {\n            int li = rnd.next(-100, 100);\n            int mi = rnd.next(-100, 100);\n            int wi = rnd.next(-100, 100);\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    } else if (type == \"max_attitude\") {\n        // Generate a case where multiple solutions exist,\n        // but maximizing total attitude is required\n        for (int i = 0; i < n; ++i) {\n            // Provide higher values to create variance in total attitudes\n            int li = rnd.next(0, 10000000);\n            int mi = rnd.next(0, 10000000);\n            int wi = rnd.next(0, 10000000);\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    } else if (type == \"negative\") {\n        // Generate a case with negative values\n        for (int i = 0; i < n; ++i) {\n            int li = rnd.next(-10000000, 0);\n            int mi = rnd.next(-10000000, 0);\n            int wi = rnd.next(-10000000, 0);\n            printf(\"%d %d %d\\n\", li, mi, wi);\n        }\n    } else {\n        // Handle invalid types\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_zero\n./gen -n 1 -type random\n./gen -n 1 -type impossible\n./gen -n 1 -type possible\n\n./gen -n 5 -type all_zero\n./gen -n 5 -type random\n./gen -n 5 -type impossible\n./gen -n 5 -type possible\n./gen -n 5 -type max_attitude\n./gen -n 5 -type negative\n\n./gen -n 10 -type all_zero\n./gen -n 10 -type random\n./gen -n 10 -type impossible\n./gen -n 10 -type possible\n./gen -n 10 -type max_attitude\n./gen -n 10 -type negative\n\n./gen -n 15 -type all_zero\n./gen -n 15 -type random\n./gen -n 15 -type impossible\n./gen -n 15 -type possible\n./gen -n 15 -type max_attitude\n./gen -n 15 -type negative\n\n./gen -n 20 -type all_zero\n./gen -n 20 -type random\n./gen -n 20 -type impossible\n./gen -n 20 -type possible\n./gen -n 20 -type max_attitude\n./gen -n 20 -type negative\n\n./gen -n 25 -type all_zero\n./gen -n 25 -type random\n./gen -n 25 -type impossible\n./gen -n 25 -type possible\n./gen -n 25 -type max_attitude\n./gen -n 25 -type negative\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:49.958678",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "587/A",
      "title": "A. Duff и гири",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке ввода записано целое число n (1 ≤ n ≤ 106), количество гирь.Во второй строке записано n целых чисел w1, ..., wn, разделенных пробелами (0 ≤ wi ≤ 106 для каждого 1 ≤ i ≤ n), — показатели весов гирь.",
      "output_spec": "Выходные данныеВыведите минимальное количество шагов на единственной строке.",
      "sample_tests": "ПримерыВходные данныеСкопировать51 1 2 3 3Выходные данныеСкопировать2Входные данныеСкопировать40 1 2 3Выходные данныеСкопировать4",
      "description": "A. Duff и гири\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке ввода записано целое число n (1 ≤ n ≤ 106), количество гирь.Во второй строке записано n целых чисел w1, ..., wn, разделенных пробелами (0 ≤ wi ≤ 106 для каждого 1 ≤ i ≤ n), — показатели весов гирь.\n\nВходные данные\n\nВыходные данныеВыведите минимальное количество шагов на единственной строке.\n\nВыходные данные\n\nВходные данныеСкопировать51 1 2 3 3Выходные данныеСкопировать2Входные данныеСкопировать40 1 2 3Выходные данныеСкопировать4\n\nВходные данныеСкопировать51 1 2 3 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать40 1 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере: один из оптимальных способов — выбросить первые три гири на первом ходу, а остальные — на втором ходу. Произвести эти действия за один ход невозможно, так как их сумма не является степенью двойки.Во втором примере: единственный оптиальный способ — на каждом ходу выбрасывать по гире. Это нельзя сделать менее, чем за 4 хода, потому что нет такого поднабора гирь, где гирь было бы больше одной, а сумма равнялась степени двойки.",
      "solutions": [
        {
          "title": "Codeforces Round #326 - Codeforces",
          "content": "Hello Codeforces.I'm honored to announce you, that Codeforces round #326 is gonna take place soon on Codeforces.Writers are AmirMohammad Dehghan(PrinceOfPersia) and Ali Haghani(Haghani). There will be 6 problems in each division(4 problems are common) and you'll have 2 and a half hour to solve them. I hope you enjoy the problems.I wanna thank Maxim Akhmedov(Zlobober) for his great helps in preparing this round, MikeMirzayanov for wonderful platforms of Codeforce and Polygon, Delinur for translating problem statements into Russian and MohammadReza Maleki(mruxim) and Ali Bahjati(LiTi) for their great advices (and LiTi again for some graphics).This is my third round on Codeforces and not the last one, I hope.This is the last round on Codeforces with Zlobober as coordinator. It was nice working with him. We had a lot of fun and interesting contests during his coordination. I just wanna say: Thank you Maxim for all your contribution to CodeForces community and good luck in the future. After I heard these news, my first guess for the next coordinator was I_love_Tanya_Romanova; But I don't know if CodeForces hires people from out of Russia or not.The main character of this round is Duff, but you'll also have to help her friend, Malek!I wish you all high ratings and lots of joy.Scoring will be posted soon.GL & HF!Problems are sorted by the expected difficulty, but we strictly recommend you to read all the problems.UPD: Scoring is: 750-1000-1500-2000-2500-3000 in Div.2 and 500-1000-1500-2000-2750-2750 in Div.1 .UPD1: Editorial is published.UPD2: System test is over. Congratulations to all winners.Div.1 Winners are: qwer1561 Endagorion jcvb subscriber wjh720 Div.2 Winners are: sleepy_mario BIT-silence Owaski Orenji.Sora JavaInTheSouth Also congratulations to JoeyWheeler, the only one who solved problem Div.1 D.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20913",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1832
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces",
          "content": "Div.2 A (Author: Haghani)Idea is a simple greedy, buy needed meat for i - th day when it's cheapest among days 1, 2, ..., n.So, the pseudo code below will work: ans = 0\nprice = infinity\nfor i = 1 to n\n price = min(price, p[i])\n ans += price * a[i]Time complexity: C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by ZloboberDiv.2 B (Author: PrinceOfPersia)Find all prime divisors of n. Assume they are p1, p2, ..., pk (in ). If answer is a, then we know that for each 1 ≤ i ≤ k, obviously a is not divisible by pi2 (and all greater powers of pi). So a ≤ p1 × p2 × ... × pk. And we know that p1 × p2 × ... × pk is itself lovely. So,answer is p1 × p2 × ... × pkTime complexity: C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by ZloboberA (Author: PrinceOfPersia)Problem is: you have to find the minimum number of k, such there is a sequence a1, a2, ..., ak with condition 2a1 + 2a2 + ... + 2ak = S = 2w1 + 2w2 + ... + 2w2. Obviously, minimum value of k is the number of set bits in binary representation of S (proof is easy, you can prove it as a practice :P).Our only problem is how to count the number of set bits in binary representation of S? Building the binary representation of S as an array in is easy: MAXN = 1000000 + log(1000000)\nbit[0..MAXN] = {} // all equal to zero\nans = 0\nfor i = 1 to n\n bit[w[i]] ++ // of course after this, some bits maybe greater than 1, we'll fix them below\nfor i = 0 to MAXN - 1\n bit[i + 1] += bit[i]/2 // floor(bit[i]/2)\n bit[i] %= 2 // bit[i] = bit[i] modulo 2\n ans += bit[i] // if bit[i] = 0, then answer doesn't change, otherwise it'll increase by 1Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniB (Author: PrinceOfPersia)If we fix x and bix mod n, then problem will be solved (because we can then multiply it by the number of valid distinct values of ).For the problem above, let dp[i][j] be the number of valid subsequences of b where x = j and and . Of course, for every i, dp[i][1] = 1. For calculating value of dp[i][j]:For this purpose, we can sort the array a and use two pointer:if p0, p1, ...pn - 1 is a permutation of 0, ..., n - 1 where for each 0 ≤ t < n - 1, apt ≤ apt + 1: for i = 0 to n-1\n dp[i][1] = 1\nfor j = 2 to k\n pointer = 0\n sum = 0\n for i = 0 to n-1\n while pointer < n and a[p[pointer]] <= a[i]\n sum = (sum + dp[p[pointer ++]][j - 1]) % MOD\n dp[i][j] = sumNow, if and x = l - 1 mod n, then answer equals to (there are c - j + 1 valid different values of for the first group and c - j for the second group).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberC (Author: PrinceOfPersia)Solution is something like the fourth LCA approach discussed here.For each 1 ≤ i ≤ n and 0 ≤ j ≤ lg(n), store the minimum 10 people in the path from city (vertex) i to its 2j - th parent in an array.Now everything is needed is: how to merge the array of two paths? You can keep the these 10 values in the array in increasing order and for merging, use merge function which will work in . And then delete the extra values (more than 10).And do the same as described in the article for a query (just like the preprocess part).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberD (Author: PrinceOfPersia)Run binary search on the answer (t). For checking if answer is less than or equal to x (check(x)):First of all delete all edges with destructing time greater than x. Now, if there is more than one pair of edges with the same color connected to a vertex(because we can delete at most one of them), answer is \"No\".Use 2-Sat. Consider a literal for each edge e (xe). If xe = TRUE, it means it should be destructed and it shouldn't otherwise. There are some conditions: For each vertex v, if there is one (exactly one) pair of edges like i and j with the same color connected to v, then we should have the clause . For each vertex v, if the edges connected to it are e1, e2, ..., ek, we should make sure that there is no pair (i, j) where 1 ≤ i < j ≤ k and xe1 = xe2 = True. The naive approach is to add a clause for each pair. But it's not efficient. The efficient way tho satisfy the second condition is to use prefix or: adding k new literals p1, p2, ..., pk and for each j ≤ i, make sure . To make sure about this, we can add two clauses for each pi: and (the second one is only for i > 1).And the only thing left is to make sure (there are no two TRUE edges).This way the number of literals and clauses are . So, after binary search is over, we should run check(t) to get a sample matching.Time complexity: (but slow, because of the constant factor)C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberE (Authors: PrinceOfPersia and Haghani)Lemma #1: If numbers b1, b2, ..., bk are k Kheshtaks of a1, ..., an, then is a Kheshtak of a1, ..., an.Proof: For each 1 ≤ i ≤ k, consider maski is a binary bitmask of length n and its j - th bit shows a subsequence of a1, ..., an (subset) with xor equal to bi.So, xor of elements subsequence(subset) of a1, ..., an with bitmask equal to equals to . So, it's a Kheshtak of this sequence.From this lemma, we can get another results: If all numbers b1, b2, ..., bk are k Kheshtaks of a1, ..., an, then every Kheshtak of b1, b2, ..., bk is a Kheshtak of a1, ..., anLemma #2: Score of sequence a1, a2, ..., an is equal to the score of sequence .Proof: If we show the second sequence by b1, b2, ..., bn, then for each 1 ≤ i ≤ n: bi = ai = each element from sequence b is a Kheshtak of sequence a and vise versa. So, due to the result of Lemma #1, each Kheshtak of sequence b is a Kheshtak of sequence a and vise versa. So: score(b1, ..., bn) ≤ score(a1, ..., an) score(a1, ..., an) ≤ score(b1, ..., bn) score(a1, ..., an) = score(b1, ..., bn)Back to original problem: denote another array b2, ..., bn where . Let's solve these two problems:1- We have array a1, ..., an and q queries of two types: upd(l, r, k): Given numbers l, r and k, for each l ≤ i ≤ r, perform ask(i):  Given number i, return the value of ai. This problem can be solved easily with a simple segment tree using lazy propagation.2- We have array b2, ..., bn and queries of two types: modify(p, k): Perform bp = k. basis(l, r): Find and return the basis vector of bl, bl + 1, ..., br (using Gaussian Elimination, its size it at most 32). This problem can be solved by a segment tree where in each node we have the basis of the substring of that node (node [l, r) has the basis of sequence bl, ..., br - 1).This way we can insert to a basis vector v: insert(x, v)\n\tfor a in v\n\t\tif a & -a & x\n\t\t\tx ^= a\n\tif !x\n\t\treturn\n\tfor a in v\n\t\tif x & -x & a\n\t\t\ta ^= x\n\tv.push(x)But size of v will always be less than or equal to 32. For merging two nodes (of segment tree), we can insert the elements of one in another one.For handling queries of two types, we act like this:Type one: Call functions: upd(l, r, k), and .Type two: Let b = basis(l + 1, r). Call insert(al, b). And then print 2b.size() as the answer.Time complexity: = C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberF (Author: PrinceOfPersia)Use Aho-Corasick. Assume first of all we build the trie of our strings (function t). If t(v, c) ≠  - 1 it means that there is an edge in the trie outgoing from vertex v written c on it.So, for building Aho-Corasick, consider f(v) = the vertex we go into, in case of failure (t(v, c) =  - 1). i.e the deepest vertex (u), that v ≠ u and the path from root to u is a suffix of path from root to v. No we can build an automaton (Aho-Corasick), function g. For each i, do this (in the automaton): cur = root\nfor c in s[i]\n\tcur = g(cur, c)\n\tAnd then push i in q[cur] (q is a vector, also we do this for cur = root).\n\nend[cur].push(i) \t// end is also a vector, consisting of the indices of strings ending in vertex cur (state cur in automaton)\nlast[i] = cur // last[i] is the final state we get to from searching string s[i] in automaton gAssume cnt(v, i) is the number of occurrences of number i in q[v]. Also, denote .Build another tree. In this tree, for each i that is not root of the trie, let par[i] = f(i) (the vertex we go in the trie, in case of failure) and call it C-Tree.So now, problem is on a tree. Operations are : Each query gives numbers l, r, k and you have to find the number .Act offline. If N = 105, then:1. For each i such that , collect queries (like struct) in a vector of queries query[i], then run dfs on the C-Tree and using a partial sum answer to all queries with k = i. There are at most of these numbers, so it can be done in . After doing these, erase i from all q[1], q[1], ..., q[N].Code (in dfs) would be like this(on C-Tree): partial_sum[n] = {}; // all 0\ndfs(v, i){\n\tcnt = 0;\n\tfor x in q[v]\n\t\tif(x == i)\n\t\t++ cnt;\n\tfor u in childern[v]\n\t\tcnt += dfs(u);\n\tfor x in end[v]\n\t\tpartial_sum[x] += cnt;\n\treturn cnt;\n}\ncalc(i){\n\tdfs(root, i);\n\tfor i = 2 to n\n\t\tpartial_sum[i] += partial_sum[i-1]\n\tfor query u in query[i]\n\t\tu.ans = partial_sum[u.r] - partial_sum[u.l - 1]\n}And we should just run calc(i) for each of them.2. For each i such that , collect queries (like struct) in a vector of queries query[i]. (each element of this vector have three integers in it: l, r and ans).Consider this problem:We have an array a of length N(initially all element equal to 0) and some queries of two types: increase(i, val): increase a[i] by val sum(i): tell the value of a[1] + a[2] + ... + a[i] We know that number of queries of the first type is and from the second type is . Using Sqrt decomposition, we can solve this problem in : K = sqrt(N)\ntot[K] = {}, a[N] = {} // this code is 0-based\nincrease(i, val)\n\twhile i < N and i % K > 0\n\t\ta[i ++] += val\n\twhile i < K\n\t\ttot[i/K] += val\n\t\ti += K\nsum(i)\n\treturn a[i] + tot[i/K]Back to our problem now.Then, just run dfs once on this C-Tree and act like this: dfs(vertex v):\n\tfor i in end[v]\n\t\tincrease(i, 1)\n\tfor i in q[v]\n\t\tfor query u in query[i]\n\t\t\tu.ans += sum(u.r) - sum(u.l - 1)\n\tfor u in children[v]\n\t\tdfs(u)\n\tfor i in end[v]\n\t\tincrease(i, -1)Then answer to a query q is q.ans.Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20971",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10107
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #326 - Codeforces - Code 1",
          "code": "00:30 start time (local time)\n+  0:10 expected delay\n+  2:30 contest\n+  0:30 system test\n+  0:30 rating changes\n= 04:10 sleep time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 - Codeforces - Code 2",
          "code": "00:30 start time (local time)\n+  0:10 expected delay\n+  2:30 contest\n+  0:30 system test\n+  0:30 rating changes\n= 04:10 sleep time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 - Codeforces - Code 3",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 - Codeforces - Code 4",
          "code": "#just_grandmaster_things",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 1",
          "code": "ans = 0\nprice = infinity\nfor i = 1 to n\n      price = min(price, p[i])\n      ans += price * a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 2",
          "code": "ans = 0\nprice = infinity\nfor i = 1 to n\n      price = min(price, p[i])\n      ans += price * a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 3",
          "code": "MAXN = 1000000 + log(1000000)\nbit[0..MAXN] = {} // all equal to zero\nans = 0\nfor i = 1 to n\n      bit[w[i]] ++ // of course after this, some bits maybe greater than 1, we'll fix them below\nfor i = 0 to MAXN - 1\n      bit[i + 1] += bit[i]/2 // floor(bit[i]/2)\n      bit[i] %= 2 // bit[i] = bit[i] modulo 2\n      ans += bit[i] // if bit[i] = 0, then answer doesn't change, otherwise it'll increase by 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 4",
          "code": "MAXN = 1000000 + log(1000000)\nbit[0..MAXN] = {} // all equal to zero\nans = 0\nfor i = 1 to n\n      bit[w[i]] ++ // of course after this, some bits maybe greater than 1, we'll fix them below\nfor i = 0 to MAXN - 1\n      bit[i + 1] += bit[i]/2 // floor(bit[i]/2)\n      bit[i] %= 2 // bit[i] = bit[i] modulo 2\n      ans += bit[i] // if bit[i] = 0, then answer doesn't change, otherwise it'll increase by 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 5",
          "code": "for i = 0 to n-1\n      dp[i][1] = 1\nfor j = 2 to k\n      pointer = 0\n      sum = 0\n      for i = 0 to n-1\n            while pointer < n and a[p[pointer]] <= a[i]\n                  sum = (sum + dp[p[pointer ++]][j - 1]) % MOD\n            dp[i][j] = sum",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 6",
          "code": "for i = 0 to n-1\n      dp[i][1] = 1\nfor j = 2 to k\n      pointer = 0\n      sum = 0\n      for i = 0 to n-1\n            while pointer < n and a[p[pointer]] <= a[i]\n                  sum = (sum + dp[p[pointer ++]][j - 1]) % MOD\n            dp[i][j] = sum",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 7",
          "code": "insert(x, v)\n\tfor a in v\n\t\tif a & -a & x\n\t\t\tx ^= a\n\tif !x\n\t\treturn\n\tfor a in v\n\t\tif x & -x & a\n\t\t\ta ^= x\n\tv.push(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 8",
          "code": "insert(x, v)\n\tfor a in v\n\t\tif a & -a & x\n\t\t\tx ^= a\n\tif !x\n\t\treturn\n\tfor a in v\n\t\tif x & -x & a\n\t\t\ta ^= x\n\tv.push(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 9",
          "code": "cur = root\nfor c in s[i]\n\tcur = g(cur, c)\n\tAnd then push i in q[cur] (q is a vector, also we do this for cur = root).\n\nend[cur].push(i) \t// end is also a vector, consisting of the indices of strings ending in vertex cur (state cur in automaton)\nlast[i] = cur // last[i] is the final state we get to from searching string s[i] in automaton g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 10",
          "code": "cur = root\nfor c in s[i]\n\tcur = g(cur, c)\n\tAnd then push i in q[cur] (q is a vector, also we do this for cur = root).\n\nend[cur].push(i) \t// end is also a vector, consisting of the indices of strings ending in vertex cur (state cur in automaton)\nlast[i] = cur // last[i] is the final state we get to from searching string s[i] in automaton g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 11",
          "code": "partial_sum[n] = {}; // all 0\ndfs(v, i){\n\tcnt = 0;\n\tfor x in q[v]\n\t\tif(x == i)\n\t\t++ cnt;\n\tfor u in childern[v]\n\t\tcnt += dfs(u);\n\tfor x in end[v]\n\t\tpartial_sum[x] += cnt;\n\treturn cnt;\n}\ncalc(i){\n\tdfs(root, i);\n\tfor i = 2 to n\n\t\tpartial_sum[i] += partial_sum[i-1]\n\tfor query u in query[i]\n\t\tu.ans = partial_sum[u.r] - partial_sum[u.l - 1]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 12",
          "code": "partial_sum[n] = {}; // all 0\ndfs(v, i){\n\tcnt = 0;\n\tfor x in q[v]\n\t\tif(x == i)\n\t\t++ cnt;\n\tfor u in childern[v]\n\t\tcnt += dfs(u);\n\tfor x in end[v]\n\t\tpartial_sum[x] += cnt;\n\treturn cnt;\n}\ncalc(i){\n\tdfs(root, i);\n\tfor i = 2 to n\n\t\tpartial_sum[i] += partial_sum[i-1]\n\tfor query u in query[i]\n\t\tu.ans = partial_sum[u.r] - partial_sum[u.l - 1]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 13",
          "code": "K = sqrt(N)\ntot[K] = {}, a[N] = {} // this code is 0-based\nincrease(i, val)\n\twhile i < N and i % K > 0\n\t\ta[i ++] += val\n\twhile i < K\n\t\ttot[i/K] += val\n\t\ti += K\nsum(i)\n\treturn a[i] + tot[i/K]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 14",
          "code": "K = sqrt(N)\ntot[K] = {}, a[N] = {} // this code is 0-based\nincrease(i, val)\n\twhile i < N and i % K > 0\n\t\ta[i ++] += val\n\twhile i < K\n\t\ttot[i/K] += val\n\t\ti += K\nsum(i)\n\treturn a[i] + tot[i/K]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 15",
          "code": "dfs(vertex v):\n\tfor i in end[v]\n\t\tincrease(i, 1)\n\tfor i in q[v]\n\t\tfor query u in query[i]\n\t\t\tu.ans += sum(u.r) - sum(u.l - 1)\n\tfor u in children[v]\n\t\tdfs(u)\n\tfor i in end[v]\n\t\tincrease(i, -1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 16",
          "code": "dfs(vertex v):\n\tfor i in end[v]\n\t\tincrease(i, 1)\n\tfor i in q[v]\n\t\tfor query u in query[i]\n\t\t\tu.ans += sum(u.r) - sum(u.l - 1)\n\tfor u in children[v]\n\t\tdfs(u)\n\tfor i in end[v]\n\t\tincrease(i, -1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 17",
          "code": "3 12 2\n5 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 18",
          "code": "3 12 2\n5 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 19",
          "code": "5 9 1  5 9 1  5 9 1   5 9 1  --> b\n1 2 3  4 5 6  7 8 9  10 11 12 --> positions\n\nlength 1 subsequence 12\nlength 2: \n1-4,1-5,1-7,1-8,1-10,1-11,2-5,2-8,2-11,3-4,3-5,3-6,3-7,3-8,3-9,3-10,3-11,3-12,\n4-7,4-8,4-10,4-11,5-8,5-11,6-7,6-8,6-9,6-10,6-11,6-12\n7-10,7-11,8-11,9-10,9-11,9-12\n\ntotal 36+12 = 48",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 20",
          "code": "5 9 1  5 9 1  5 9 1   5 9 1  --> b\n1 2 3  4 5 6  7 8 9  10 11 12 --> positions\n\nlength 1 subsequence 12\nlength 2: \n1-4,1-5,1-7,1-8,1-10,1-11,2-5,2-8,2-11,3-4,3-5,3-6,3-7,3-8,3-9,3-10,3-11,3-12,\n4-7,4-8,4-10,4-11,5-8,5-11,6-7,6-8,6-9,6-10,6-11,6-12\n7-10,7-11,8-11,9-10,9-11,9-12\n\ntotal 36+12 = 48",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    vector<int> w = inf.readInts(n, 0, 1000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    vector<int> w = inf.readInts(n, 0, 1000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    vector<int> w = inf.readInts(n, 0, 1000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int max_w = opt<int>(\"max_w\", 1000000);\n    string type = opt<string>(\"type\", \"random\");\n    int w_value = opt<int>(\"w_value\", 0); // For \"all_same\" type\n\n    vector<int> w;\n\n    if (type == \"minimal\") {\n        n = 1;\n        w.push_back(0);\n    } else if (type == \"maximal\") {\n        for (int i = 0; i < n; ++i)\n            w.push_back(max_w);\n    } else if (type == \"all_zero\") {\n        for (int i = 0; i < n; ++i)\n            w.push_back(0);\n    } else if (type == \"all_same\") {\n        if (w_value < 0 || w_value > max_w) {\n            w_value = max_w / 2;\n        }\n        for (int i = 0; i < n; ++i)\n            w.push_back(w_value);\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            w.push_back(rnd.next(0, max_w));\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            w.push_back(min(i, max_w));\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            w.push_back(max_w - min(i, max_w));\n    } else {\n        // Default to random if type is unknown\n        for (int i = 0; i < n; ++i)\n            w.push_back(rnd.next(0, max_w));\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the sequence w_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", w[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int max_w = opt<int>(\"max_w\", 1000000);\n    string type = opt<string>(\"type\", \"random\");\n    int w_value = opt<int>(\"w_value\", 0); // For \"all_same\" type\n\n    vector<int> w;\n\n    if (type == \"minimal\") {\n        n = 1;\n        w.push_back(0);\n    } else if (type == \"maximal\") {\n        for (int i = 0; i < n; ++i)\n            w.push_back(max_w);\n    } else if (type == \"all_zero\") {\n        for (int i = 0; i < n; ++i)\n            w.push_back(0);\n    } else if (type == \"all_same\") {\n        if (w_value < 0 || w_value > max_w) {\n            w_value = max_w / 2;\n        }\n        for (int i = 0; i < n; ++i)\n            w.push_back(w_value);\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            w.push_back(rnd.next(0, max_w));\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            w.push_back(min(i, max_w));\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            w.push_back(max_w - min(i, max_w));\n    } else {\n        // Default to random if type is unknown\n        for (int i = 0; i < n; ++i)\n            w.push_back(rnd.next(0, max_w));\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the sequence w_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", w[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -max_w 0 -type minimal\n./gen -n 1 -max_w 1 -type random\n./gen -n 5 -max_w 5 -type all_zero\n./gen -n 5 -max_w 5 -type all_same -w_value 3\n./gen -n 10 -max_w 10 -type increasing\n./gen -n 10 -max_w 10 -type decreasing\n./gen -n 15 -max_w 15 -type random\n./gen -n 100 -max_w 50 -type random\n./gen -n 1000 -max_w 1000 -type decreasing\n./gen -n 1000 -max_w 1000 -type increasing\n./gen -n 10000 -max_w 500 -type all_same -w_value 250\n./gen -n 100000 -max_w 100000 -type random\n./gen -n 100000 -max_w 100000 -type all_zero\n./gen -n 100000 -max_w 100000 -type all_same -w_value 100000\n./gen -n 500000 -max_w 500000 -type increasing\n./gen -n 500000 -max_w 500000 -type decreasing\n./gen -n 1000000 -max_w 1000000 -type random\n./gen -n 1000000 -max_w 1000000 -type all_same -w_value 0\n./gen -n 1000000 -max_w 1000000 -type all_same -w_value 1\n./gen -n 1000000 -max_w 1000000 -type all_same -w_value 1000000\n./gen -n 1000000 -max_w 1000000 -type increasing\n./gen -n 1000000 -max_w 1000000 -type decreasing\n./gen -n 1000000 -max_w 1000000 -type random\n./gen -n 1000000 -max_w 1000000 -type random\n./gen -n 1000000 -max_w 0 -type all_zero\n./gen -n 1 -max_w 1000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:52.092927",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "587/B",
      "title": "B. Duff in Beach",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains three integers, n, l and k (1 ≤ n, k, n × k ≤ 106 and 1 ≤ l ≤ 1018).The second line contains n space separated integers, a0, a1, ..., an - 1 (1 ≤ ai ≤ 109 for each 0 ≤ i ≤ n - 1).",
      "output_spec": "OutputPrint the answer modulo 1 000 000 007 in one line.",
      "sample_tests": "ExamplesInputCopy3 5 35 9 1OutputCopy10InputCopy5 10 31 2 3 4 5OutputCopy25",
      "description": "B. Duff in Beach\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains three integers, n, l and k (1 ≤ n, k, n × k ≤ 106 and 1 ≤ l ≤ 1018).The second line contains n space separated integers, a0, a1, ..., an - 1 (1 ≤ ai ≤ 109 for each 0 ≤ i ≤ n - 1).\n\nOutputPrint the answer modulo 1 000 000 007 in one line.\n\nInputCopy3 5 35 9 1OutputCopy10InputCopy5 10 31 2 3 4 5OutputCopy25\n\nInputCopy3 5 35 9 1\n\nOutputCopy10\n\nInputCopy5 10 31 2 3 4 5\n\nOutputCopy25\n\nNoteIn the first sample case, . So all such sequences are: , , , , , , , ,  and .",
      "solutions": [
        {
          "title": "Codeforces Round #326 - Codeforces",
          "content": "Hello Codeforces.I'm honored to announce you, that Codeforces round #326 is gonna take place soon on Codeforces.Writers are AmirMohammad Dehghan(PrinceOfPersia) and Ali Haghani(Haghani). There will be 6 problems in each division(4 problems are common) and you'll have 2 and a half hour to solve them. I hope you enjoy the problems.I wanna thank Maxim Akhmedov(Zlobober) for his great helps in preparing this round, MikeMirzayanov for wonderful platforms of Codeforce and Polygon, Delinur for translating problem statements into Russian and MohammadReza Maleki(mruxim) and Ali Bahjati(LiTi) for their great advices (and LiTi again for some graphics).This is my third round on Codeforces and not the last one, I hope.This is the last round on Codeforces with Zlobober as coordinator. It was nice working with him. We had a lot of fun and interesting contests during his coordination. I just wanna say: Thank you Maxim for all your contribution to CodeForces community and good luck in the future. After I heard these news, my first guess for the next coordinator was I_love_Tanya_Romanova; But I don't know if CodeForces hires people from out of Russia or not.The main character of this round is Duff, but you'll also have to help her friend, Malek!I wish you all high ratings and lots of joy.Scoring will be posted soon.GL & HF!Problems are sorted by the expected difficulty, but we strictly recommend you to read all the problems.UPD: Scoring is: 750-1000-1500-2000-2500-3000 in Div.2 and 500-1000-1500-2000-2750-2750 in Div.1 .UPD1: Editorial is published.UPD2: System test is over. Congratulations to all winners.Div.1 Winners are: qwer1561 Endagorion jcvb subscriber wjh720 Div.2 Winners are: sleepy_mario BIT-silence Owaski Orenji.Sora JavaInTheSouth Also congratulations to JoeyWheeler, the only one who solved problem Div.1 D.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20913",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1832
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces",
          "content": "Div.2 A (Author: Haghani)Idea is a simple greedy, buy needed meat for i - th day when it's cheapest among days 1, 2, ..., n.So, the pseudo code below will work: ans = 0\nprice = infinity\nfor i = 1 to n\n price = min(price, p[i])\n ans += price * a[i]Time complexity: C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by ZloboberDiv.2 B (Author: PrinceOfPersia)Find all prime divisors of n. Assume they are p1, p2, ..., pk (in ). If answer is a, then we know that for each 1 ≤ i ≤ k, obviously a is not divisible by pi2 (and all greater powers of pi). So a ≤ p1 × p2 × ... × pk. And we know that p1 × p2 × ... × pk is itself lovely. So,answer is p1 × p2 × ... × pkTime complexity: C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by ZloboberA (Author: PrinceOfPersia)Problem is: you have to find the minimum number of k, such there is a sequence a1, a2, ..., ak with condition 2a1 + 2a2 + ... + 2ak = S = 2w1 + 2w2 + ... + 2w2. Obviously, minimum value of k is the number of set bits in binary representation of S (proof is easy, you can prove it as a practice :P).Our only problem is how to count the number of set bits in binary representation of S? Building the binary representation of S as an array in is easy: MAXN = 1000000 + log(1000000)\nbit[0..MAXN] = {} // all equal to zero\nans = 0\nfor i = 1 to n\n bit[w[i]] ++ // of course after this, some bits maybe greater than 1, we'll fix them below\nfor i = 0 to MAXN - 1\n bit[i + 1] += bit[i]/2 // floor(bit[i]/2)\n bit[i] %= 2 // bit[i] = bit[i] modulo 2\n ans += bit[i] // if bit[i] = 0, then answer doesn't change, otherwise it'll increase by 1Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniB (Author: PrinceOfPersia)If we fix x and bix mod n, then problem will be solved (because we can then multiply it by the number of valid distinct values of ).For the problem above, let dp[i][j] be the number of valid subsequences of b where x = j and and . Of course, for every i, dp[i][1] = 1. For calculating value of dp[i][j]:For this purpose, we can sort the array a and use two pointer:if p0, p1, ...pn - 1 is a permutation of 0, ..., n - 1 where for each 0 ≤ t < n - 1, apt ≤ apt + 1: for i = 0 to n-1\n dp[i][1] = 1\nfor j = 2 to k\n pointer = 0\n sum = 0\n for i = 0 to n-1\n while pointer < n and a[p[pointer]] <= a[i]\n sum = (sum + dp[p[pointer ++]][j - 1]) % MOD\n dp[i][j] = sumNow, if and x = l - 1 mod n, then answer equals to (there are c - j + 1 valid different values of for the first group and c - j for the second group).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberC (Author: PrinceOfPersia)Solution is something like the fourth LCA approach discussed here.For each 1 ≤ i ≤ n and 0 ≤ j ≤ lg(n), store the minimum 10 people in the path from city (vertex) i to its 2j - th parent in an array.Now everything is needed is: how to merge the array of two paths? You can keep the these 10 values in the array in increasing order and for merging, use merge function which will work in . And then delete the extra values (more than 10).And do the same as described in the article for a query (just like the preprocess part).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberD (Author: PrinceOfPersia)Run binary search on the answer (t). For checking if answer is less than or equal to x (check(x)):First of all delete all edges with destructing time greater than x. Now, if there is more than one pair of edges with the same color connected to a vertex(because we can delete at most one of them), answer is \"No\".Use 2-Sat. Consider a literal for each edge e (xe). If xe = TRUE, it means it should be destructed and it shouldn't otherwise. There are some conditions: For each vertex v, if there is one (exactly one) pair of edges like i and j with the same color connected to v, then we should have the clause . For each vertex v, if the edges connected to it are e1, e2, ..., ek, we should make sure that there is no pair (i, j) where 1 ≤ i < j ≤ k and xe1 = xe2 = True. The naive approach is to add a clause for each pair. But it's not efficient. The efficient way tho satisfy the second condition is to use prefix or: adding k new literals p1, p2, ..., pk and for each j ≤ i, make sure . To make sure about this, we can add two clauses for each pi: and (the second one is only for i > 1).And the only thing left is to make sure (there are no two TRUE edges).This way the number of literals and clauses are . So, after binary search is over, we should run check(t) to get a sample matching.Time complexity: (but slow, because of the constant factor)C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberE (Authors: PrinceOfPersia and Haghani)Lemma #1: If numbers b1, b2, ..., bk are k Kheshtaks of a1, ..., an, then is a Kheshtak of a1, ..., an.Proof: For each 1 ≤ i ≤ k, consider maski is a binary bitmask of length n and its j - th bit shows a subsequence of a1, ..., an (subset) with xor equal to bi.So, xor of elements subsequence(subset) of a1, ..., an with bitmask equal to equals to . So, it's a Kheshtak of this sequence.From this lemma, we can get another results: If all numbers b1, b2, ..., bk are k Kheshtaks of a1, ..., an, then every Kheshtak of b1, b2, ..., bk is a Kheshtak of a1, ..., anLemma #2: Score of sequence a1, a2, ..., an is equal to the score of sequence .Proof: If we show the second sequence by b1, b2, ..., bn, then for each 1 ≤ i ≤ n: bi = ai = each element from sequence b is a Kheshtak of sequence a and vise versa. So, due to the result of Lemma #1, each Kheshtak of sequence b is a Kheshtak of sequence a and vise versa. So: score(b1, ..., bn) ≤ score(a1, ..., an) score(a1, ..., an) ≤ score(b1, ..., bn) score(a1, ..., an) = score(b1, ..., bn)Back to original problem: denote another array b2, ..., bn where . Let's solve these two problems:1- We have array a1, ..., an and q queries of two types: upd(l, r, k): Given numbers l, r and k, for each l ≤ i ≤ r, perform ask(i):  Given number i, return the value of ai. This problem can be solved easily with a simple segment tree using lazy propagation.2- We have array b2, ..., bn and queries of two types: modify(p, k): Perform bp = k. basis(l, r): Find and return the basis vector of bl, bl + 1, ..., br (using Gaussian Elimination, its size it at most 32). This problem can be solved by a segment tree where in each node we have the basis of the substring of that node (node [l, r) has the basis of sequence bl, ..., br - 1).This way we can insert to a basis vector v: insert(x, v)\n\tfor a in v\n\t\tif a & -a & x\n\t\t\tx ^= a\n\tif !x\n\t\treturn\n\tfor a in v\n\t\tif x & -x & a\n\t\t\ta ^= x\n\tv.push(x)But size of v will always be less than or equal to 32. For merging two nodes (of segment tree), we can insert the elements of one in another one.For handling queries of two types, we act like this:Type one: Call functions: upd(l, r, k), and .Type two: Let b = basis(l + 1, r). Call insert(al, b). And then print 2b.size() as the answer.Time complexity: = C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberF (Author: PrinceOfPersia)Use Aho-Corasick. Assume first of all we build the trie of our strings (function t). If t(v, c) ≠  - 1 it means that there is an edge in the trie outgoing from vertex v written c on it.So, for building Aho-Corasick, consider f(v) = the vertex we go into, in case of failure (t(v, c) =  - 1). i.e the deepest vertex (u), that v ≠ u and the path from root to u is a suffix of path from root to v. No we can build an automaton (Aho-Corasick), function g. For each i, do this (in the automaton): cur = root\nfor c in s[i]\n\tcur = g(cur, c)\n\tAnd then push i in q[cur] (q is a vector, also we do this for cur = root).\n\nend[cur].push(i) \t// end is also a vector, consisting of the indices of strings ending in vertex cur (state cur in automaton)\nlast[i] = cur // last[i] is the final state we get to from searching string s[i] in automaton gAssume cnt(v, i) is the number of occurrences of number i in q[v]. Also, denote .Build another tree. In this tree, for each i that is not root of the trie, let par[i] = f(i) (the vertex we go in the trie, in case of failure) and call it C-Tree.So now, problem is on a tree. Operations are : Each query gives numbers l, r, k and you have to find the number .Act offline. If N = 105, then:1. For each i such that , collect queries (like struct) in a vector of queries query[i], then run dfs on the C-Tree and using a partial sum answer to all queries with k = i. There are at most of these numbers, so it can be done in . After doing these, erase i from all q[1], q[1], ..., q[N].Code (in dfs) would be like this(on C-Tree): partial_sum[n] = {}; // all 0\ndfs(v, i){\n\tcnt = 0;\n\tfor x in q[v]\n\t\tif(x == i)\n\t\t++ cnt;\n\tfor u in childern[v]\n\t\tcnt += dfs(u);\n\tfor x in end[v]\n\t\tpartial_sum[x] += cnt;\n\treturn cnt;\n}\ncalc(i){\n\tdfs(root, i);\n\tfor i = 2 to n\n\t\tpartial_sum[i] += partial_sum[i-1]\n\tfor query u in query[i]\n\t\tu.ans = partial_sum[u.r] - partial_sum[u.l - 1]\n}And we should just run calc(i) for each of them.2. For each i such that , collect queries (like struct) in a vector of queries query[i]. (each element of this vector have three integers in it: l, r and ans).Consider this problem:We have an array a of length N(initially all element equal to 0) and some queries of two types: increase(i, val): increase a[i] by val sum(i): tell the value of a[1] + a[2] + ... + a[i] We know that number of queries of the first type is and from the second type is . Using Sqrt decomposition, we can solve this problem in : K = sqrt(N)\ntot[K] = {}, a[N] = {} // this code is 0-based\nincrease(i, val)\n\twhile i < N and i % K > 0\n\t\ta[i ++] += val\n\twhile i < K\n\t\ttot[i/K] += val\n\t\ti += K\nsum(i)\n\treturn a[i] + tot[i/K]Back to our problem now.Then, just run dfs once on this C-Tree and act like this: dfs(vertex v):\n\tfor i in end[v]\n\t\tincrease(i, 1)\n\tfor i in q[v]\n\t\tfor query u in query[i]\n\t\t\tu.ans += sum(u.r) - sum(u.l - 1)\n\tfor u in children[v]\n\t\tdfs(u)\n\tfor i in end[v]\n\t\tincrease(i, -1)Then answer to a query q is q.ans.Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20971",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10107
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #326 - Codeforces - Code 1",
          "code": "00:30 start time (local time)\n+  0:10 expected delay\n+  2:30 contest\n+  0:30 system test\n+  0:30 rating changes\n= 04:10 sleep time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 - Codeforces - Code 2",
          "code": "00:30 start time (local time)\n+  0:10 expected delay\n+  2:30 contest\n+  0:30 system test\n+  0:30 rating changes\n= 04:10 sleep time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 - Codeforces - Code 3",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 - Codeforces - Code 4",
          "code": "#just_grandmaster_things",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 1",
          "code": "ans = 0\nprice = infinity\nfor i = 1 to n\n      price = min(price, p[i])\n      ans += price * a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 2",
          "code": "ans = 0\nprice = infinity\nfor i = 1 to n\n      price = min(price, p[i])\n      ans += price * a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 3",
          "code": "MAXN = 1000000 + log(1000000)\nbit[0..MAXN] = {} // all equal to zero\nans = 0\nfor i = 1 to n\n      bit[w[i]] ++ // of course after this, some bits maybe greater than 1, we'll fix them below\nfor i = 0 to MAXN - 1\n      bit[i + 1] += bit[i]/2 // floor(bit[i]/2)\n      bit[i] %= 2 // bit[i] = bit[i] modulo 2\n      ans += bit[i] // if bit[i] = 0, then answer doesn't change, otherwise it'll increase by 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 4",
          "code": "MAXN = 1000000 + log(1000000)\nbit[0..MAXN] = {} // all equal to zero\nans = 0\nfor i = 1 to n\n      bit[w[i]] ++ // of course after this, some bits maybe greater than 1, we'll fix them below\nfor i = 0 to MAXN - 1\n      bit[i + 1] += bit[i]/2 // floor(bit[i]/2)\n      bit[i] %= 2 // bit[i] = bit[i] modulo 2\n      ans += bit[i] // if bit[i] = 0, then answer doesn't change, otherwise it'll increase by 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 5",
          "code": "for i = 0 to n-1\n      dp[i][1] = 1\nfor j = 2 to k\n      pointer = 0\n      sum = 0\n      for i = 0 to n-1\n            while pointer < n and a[p[pointer]] <= a[i]\n                  sum = (sum + dp[p[pointer ++]][j - 1]) % MOD\n            dp[i][j] = sum",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 6",
          "code": "for i = 0 to n-1\n      dp[i][1] = 1\nfor j = 2 to k\n      pointer = 0\n      sum = 0\n      for i = 0 to n-1\n            while pointer < n and a[p[pointer]] <= a[i]\n                  sum = (sum + dp[p[pointer ++]][j - 1]) % MOD\n            dp[i][j] = sum",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 7",
          "code": "insert(x, v)\n\tfor a in v\n\t\tif a & -a & x\n\t\t\tx ^= a\n\tif !x\n\t\treturn\n\tfor a in v\n\t\tif x & -x & a\n\t\t\ta ^= x\n\tv.push(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 8",
          "code": "insert(x, v)\n\tfor a in v\n\t\tif a & -a & x\n\t\t\tx ^= a\n\tif !x\n\t\treturn\n\tfor a in v\n\t\tif x & -x & a\n\t\t\ta ^= x\n\tv.push(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 9",
          "code": "cur = root\nfor c in s[i]\n\tcur = g(cur, c)\n\tAnd then push i in q[cur] (q is a vector, also we do this for cur = root).\n\nend[cur].push(i) \t// end is also a vector, consisting of the indices of strings ending in vertex cur (state cur in automaton)\nlast[i] = cur // last[i] is the final state we get to from searching string s[i] in automaton g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 10",
          "code": "cur = root\nfor c in s[i]\n\tcur = g(cur, c)\n\tAnd then push i in q[cur] (q is a vector, also we do this for cur = root).\n\nend[cur].push(i) \t// end is also a vector, consisting of the indices of strings ending in vertex cur (state cur in automaton)\nlast[i] = cur // last[i] is the final state we get to from searching string s[i] in automaton g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 11",
          "code": "partial_sum[n] = {}; // all 0\ndfs(v, i){\n\tcnt = 0;\n\tfor x in q[v]\n\t\tif(x == i)\n\t\t++ cnt;\n\tfor u in childern[v]\n\t\tcnt += dfs(u);\n\tfor x in end[v]\n\t\tpartial_sum[x] += cnt;\n\treturn cnt;\n}\ncalc(i){\n\tdfs(root, i);\n\tfor i = 2 to n\n\t\tpartial_sum[i] += partial_sum[i-1]\n\tfor query u in query[i]\n\t\tu.ans = partial_sum[u.r] - partial_sum[u.l - 1]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 12",
          "code": "partial_sum[n] = {}; // all 0\ndfs(v, i){\n\tcnt = 0;\n\tfor x in q[v]\n\t\tif(x == i)\n\t\t++ cnt;\n\tfor u in childern[v]\n\t\tcnt += dfs(u);\n\tfor x in end[v]\n\t\tpartial_sum[x] += cnt;\n\treturn cnt;\n}\ncalc(i){\n\tdfs(root, i);\n\tfor i = 2 to n\n\t\tpartial_sum[i] += partial_sum[i-1]\n\tfor query u in query[i]\n\t\tu.ans = partial_sum[u.r] - partial_sum[u.l - 1]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 13",
          "code": "K = sqrt(N)\ntot[K] = {}, a[N] = {} // this code is 0-based\nincrease(i, val)\n\twhile i < N and i % K > 0\n\t\ta[i ++] += val\n\twhile i < K\n\t\ttot[i/K] += val\n\t\ti += K\nsum(i)\n\treturn a[i] + tot[i/K]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 14",
          "code": "K = sqrt(N)\ntot[K] = {}, a[N] = {} // this code is 0-based\nincrease(i, val)\n\twhile i < N and i % K > 0\n\t\ta[i ++] += val\n\twhile i < K\n\t\ttot[i/K] += val\n\t\ti += K\nsum(i)\n\treturn a[i] + tot[i/K]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 15",
          "code": "dfs(vertex v):\n\tfor i in end[v]\n\t\tincrease(i, 1)\n\tfor i in q[v]\n\t\tfor query u in query[i]\n\t\t\tu.ans += sum(u.r) - sum(u.l - 1)\n\tfor u in children[v]\n\t\tdfs(u)\n\tfor i in end[v]\n\t\tincrease(i, -1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 16",
          "code": "dfs(vertex v):\n\tfor i in end[v]\n\t\tincrease(i, 1)\n\tfor i in q[v]\n\t\tfor query u in query[i]\n\t\t\tu.ans += sum(u.r) - sum(u.l - 1)\n\tfor u in children[v]\n\t\tdfs(u)\n\tfor i in end[v]\n\t\tincrease(i, -1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 17",
          "code": "3 12 2\n5 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 18",
          "code": "3 12 2\n5 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 19",
          "code": "5 9 1  5 9 1  5 9 1   5 9 1  --> b\n1 2 3  4 5 6  7 8 9  10 11 12 --> positions\n\nlength 1 subsequence 12\nlength 2: \n1-4,1-5,1-7,1-8,1-10,1-11,2-5,2-8,2-11,3-4,3-5,3-6,3-7,3-8,3-9,3-10,3-11,3-12,\n4-7,4-8,4-10,4-11,5-8,5-11,6-7,6-8,6-9,6-10,6-11,6-12\n7-10,7-11,8-11,9-10,9-11,9-12\n\ntotal 36+12 = 48",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 20",
          "code": "5 9 1  5 9 1  5 9 1   5 9 1  --> b\n1 2 3  4 5 6  7 8 9  10 11 12 --> positions\n\nlength 1 subsequence 12\nlength 2: \n1-4,1-5,1-7,1-8,1-10,1-11,2-5,2-8,2-11,3-4,3-5,3-6,3-7,3-8,3-9,3-10,3-11,3-12,\n4-7,4-8,4-10,4-11,5-8,5-11,6-7,6-8,6-9,6-10,6-11,6-12\n7-10,7-11,8-11,9-10,9-11,9-12\n\ntotal 36+12 = 48",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    ensuref(1LL * n * k <= 1000000, \"n * k must be <= 1e6\");\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    ensuref(1LL * n * k <= 1000000, \"n * k must be <= 1e6\");\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    ensuref(1LL * n * k <= 1000000, \"n * k must be <= 1e6\");\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    long long l = opt<long long>(\"l\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Constraints\n    const int maxN = 1000000;\n    const int maxK = 1000000;\n    const int maxA = 1000000000;\n\n    // Ensure constraints\n    if (n < 1 || n > maxN) {\n        fprintf(stderr, \"Invalid value of n: %d\\n\", n);\n        exit(1);\n    }\n    if (k < 1 || n * (long long)k > maxN) {\n        fprintf(stderr, \"Invalid value of k: %d\\n\", k);\n        exit(1);\n    }\n    if (l < 1 || l > 1000000000000000000LL) {\n        fprintf(stderr, \"Invalid value of l: %lld\\n\", l);\n        exit(1);\n    }\n\n    vector<int> a(n);\n\n    if (type == \"all_same\") {\n        int val = rnd.next(1, maxA);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    }\n    else if (type == \"increasing\") {\n        int start = rnd.next(1, maxA - n + 1);\n        for(int i = 0; i < n; ++i)\n            a[i] = start + i;\n    }\n    else if (type == \"decreasing\") {\n        int start = rnd.next(n, maxA);\n        for(int i = 0; i < n; ++i)\n            a[i] = start - i;\n    }\n    else if (type == \"small_numbers\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 10);\n    }\n    else if (type == \"large_numbers\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(maxA - 10, maxA);\n    }\n    else if (type == \"powers_of_two\") {\n        int mod = maxA;\n        int val = 1;\n        for(int i = 0; i < n; ++i) {\n            a[i] = val;\n            val = (val * 2);\n            if (val > maxA) val = 1;\n        }\n    }\n    else if (type == \"max_divisions\") {\n        a[0] = 1;\n        for(int i = 1; i < n; ++i) {\n            int mul = rnd.next(1, 5);\n            long long next_val = (long long)a[i-1] * mul;\n            if(next_val > maxA) next_val = maxA;\n            a[i] = (int)next_val;\n        }\n    }\n    else { // Random\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, maxA);\n    }\n\n    // Output\n    printf(\"%d %lld %d\\n\", n, l, k);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if(i < n -1) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    long long l = opt<long long>(\"l\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Constraints\n    const int maxN = 1000000;\n    const int maxK = 1000000;\n    const int maxA = 1000000000;\n\n    // Ensure constraints\n    if (n < 1 || n > maxN) {\n        fprintf(stderr, \"Invalid value of n: %d\\n\", n);\n        exit(1);\n    }\n    if (k < 1 || n * (long long)k > maxN) {\n        fprintf(stderr, \"Invalid value of k: %d\\n\", k);\n        exit(1);\n    }\n    if (l < 1 || l > 1000000000000000000LL) {\n        fprintf(stderr, \"Invalid value of l: %lld\\n\", l);\n        exit(1);\n    }\n\n    vector<int> a(n);\n\n    if (type == \"all_same\") {\n        int val = rnd.next(1, maxA);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    }\n    else if (type == \"increasing\") {\n        int start = rnd.next(1, maxA - n + 1);\n        for(int i = 0; i < n; ++i)\n            a[i] = start + i;\n    }\n    else if (type == \"decreasing\") {\n        int start = rnd.next(n, maxA);\n        for(int i = 0; i < n; ++i)\n            a[i] = start - i;\n    }\n    else if (type == \"small_numbers\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 10);\n    }\n    else if (type == \"large_numbers\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(maxA - 10, maxA);\n    }\n    else if (type == \"powers_of_two\") {\n        int mod = maxA;\n        int val = 1;\n        for(int i = 0; i < n; ++i) {\n            a[i] = val;\n            val = (val * 2);\n            if (val > maxA) val = 1;\n        }\n    }\n    else if (type == \"max_divisions\") {\n        a[0] = 1;\n        for(int i = 1; i < n; ++i) {\n            int mul = rnd.next(1, 5);\n            long long next_val = (long long)a[i-1] * mul;\n            if(next_val > maxA) next_val = maxA;\n            a[i] = (int)next_val;\n        }\n    }\n    else { // Random\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, maxA);\n    }\n\n    // Output\n    printf(\"%d %lld %d\\n\", n, l, k);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if(i < n -1) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, l, k\n./gen -n 5 -l 10 -k 3 -type random\n./gen -n 10 -l 20 -k 5 -type all_same\n./gen -n 8 -l 8 -k 4 -type increasing\n./gen -n 7 -l 1 -k 7 -type decreasing\n./gen -n 9 -l 9 -k 9 -type small_numbers\n\n# Edge cases with l = n\n./gen -n 100 -l 100 -k 10 -type random\n./gen -n 200 -l 200 -k 5 -type all_same\n\n# Edge case l = 1\n./gen -n 1000 -l 1 -k 1 -type random\n\n# Edge case l is just less than n\n./gen -n 1000 -l 999 -k 1000 -type random\n\n# Edge case l is just greater than n\n./gen -n 1000 -l 1001 -k 1000 -type random\n\n# Maximum l\n./gen -n 1000 -l 1000000000000000000 -k 1 -type random\n\n# Max n with k=1\n./gen -n 1000000 -l 10000 -k 1 -type random\n\n# Max n with small l\n./gen -n 1000000 -l 1 -k 1 -type random\n\n# Max k with n=1\n./gen -n 1 -l 1000 -k 1000000 -type random\n\n# Random types with max n*k within limit\n./gen -n 1000 -l 10000000000 -k 1000 -type random\n./gen -n 2000 -l 10000000000 -k 500 -type random\n\n# Type: all_same\n./gen -n 10000 -l 100000 -k 100 -type all_same\n\n# Type: increasing\n./gen -n 10000 -l 50000 -k 200 -type increasing\n\n# Type: decreasing\n./gen -n 10000 -l 50000 -k 200 -type decreasing\n\n# Type: small_numbers\n./gen -n 10000 -l 100000 -k 100 -type small_numbers\n\n# Type: large_numbers\n./gen -n 10000 -l 100000 -k 100 -type large_numbers\n\n# Type: powers_of_two\n./gen -n 10000 -l 100000 -k 100 -type powers_of_two\n\n# Type: max_divisions\n./gen -n 10000 -l 100000 -k 100 -type max_divisions\n\n# Edge cases with n*k at limit\n./gen -n 1000 -l 1000000000000 -k 1000 -type random\n\n# Edge cases with n*k just below limit\n./gen -n 1000 -l 1000000000000 -k 1000 -type all_same\n\n# Edge case with minimal l\n./gen -n 1 -l 1 -k 1 -type small_numbers\n\n# Edge case with both n and l minimal\n./gen -n 1 -l 1 -k 1 -type random\n\n# Edge case with both n and l maximal within constraints\n./gen -n 1000000 -l 1000000 -k 1 -type random\n\n# Random test cases\n./gen -n 50000 -l 1000000000000 -k 20 -type random\n./gen -n 50000 -l 1000000000000 -k 20 -type small_numbers\n./gen -n 50000 -l 1000000000000 -k 20 -type large_numbers\n\n# Edge case where l % n == 0\n./gen -n 1000 -l 1000000 -k 100 -type random\n\n# Edge case where l % n != 0\n./gen -n 1000 -l 1000001 -k 100 -type random\n\n# Edge case with max divisions\n./gen -n 1000 -l 1000000 -k 100 -type max_divisions\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:54.596102",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "587/C",
      "title": "C. Duff в армии",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 секунды",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеВ первой строке ввода записано три целых числа, n, m и q (1 ≤ n, m, q ≤ 105).В следующих n - 1 строках записаны дороги. В каждой строке записано два целых числа, v и u, номера городов, соединённых очередной дорогой (1 ≤ v, u ≤ n, v ≠ u).В следующей строке записано m целых чисел c1, c2, ..., cm (1 ≤ ci ≤ n, 1 ≤ i ≤ m).В следующих q строках записаны запросы. Каждый из них состоит из трёх целых чисел, v, u и a (1 ≤ v, u ≤ n и 1 ≤ a ≤ 10).",
      "output_spec": "Выходные данныеДля каждого запроса выведите числа k, p1, p2, ..., pk через пробел в одной строке.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 4 51 31 21 44 52 1 4 34 5 61 5 25 5 102 3 35 3 1Выходные данныеСкопировать1 32 2 303 1 2 41 2",
      "description": "C. Duff в армии\n\nограничение по времени на тест4 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке ввода записано три целых числа, n, m и q (1 ≤ n, m, q ≤ 105).В следующих n - 1 строках записаны дороги. В каждой строке записано два целых числа, v и u, номера городов, соединённых очередной дорогой (1 ≤ v, u ≤ n, v ≠ u).В следующей строке записано m целых чисел c1, c2, ..., cm (1 ≤ ci ≤ n, 1 ≤ i ≤ m).В следующих q строках записаны запросы. Каждый из них состоит из трёх целых чисел, v, u и a (1 ≤ v, u ≤ n и 1 ≤ a ≤ 10).\n\nВходные данные\n\nВыходные данныеДля каждого запроса выведите числа k, p1, p2, ..., pk через пробел в одной строке.\n\nВыходные данные\n\nВходные данныеСкопировать5 4 51 31 21 44 52 1 4 34 5 61 5 25 5 102 3 35 3 1Выходные данныеСкопировать1 32 2 303 1 2 41 2\n\nВходные данныеСкопировать5 4 51 31 21 44 52 1 4 34 5 61 5 25 5 102 3 35 3 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 32 2 303 1 2 41 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ тесте из условия страна Andarz Gu имеет следующий вид (номера людей, живущих в каждом городе, подписаны рядом с соответствующим городом):",
      "solutions": [
        {
          "title": "Codeforces Round #326 - Codeforces",
          "content": "Hello Codeforces.I'm honored to announce you, that Codeforces round #326 is gonna take place soon on Codeforces.Writers are AmirMohammad Dehghan(PrinceOfPersia) and Ali Haghani(Haghani). There will be 6 problems in each division(4 problems are common) and you'll have 2 and a half hour to solve them. I hope you enjoy the problems.I wanna thank Maxim Akhmedov(Zlobober) for his great helps in preparing this round, MikeMirzayanov for wonderful platforms of Codeforce and Polygon, Delinur for translating problem statements into Russian and MohammadReza Maleki(mruxim) and Ali Bahjati(LiTi) for their great advices (and LiTi again for some graphics).This is my third round on Codeforces and not the last one, I hope.This is the last round on Codeforces with Zlobober as coordinator. It was nice working with him. We had a lot of fun and interesting contests during his coordination. I just wanna say: Thank you Maxim for all your contribution to CodeForces community and good luck in the future. After I heard these news, my first guess for the next coordinator was I_love_Tanya_Romanova; But I don't know if CodeForces hires people from out of Russia or not.The main character of this round is Duff, but you'll also have to help her friend, Malek!I wish you all high ratings and lots of joy.Scoring will be posted soon.GL & HF!Problems are sorted by the expected difficulty, but we strictly recommend you to read all the problems.UPD: Scoring is: 750-1000-1500-2000-2500-3000 in Div.2 and 500-1000-1500-2000-2750-2750 in Div.1 .UPD1: Editorial is published.UPD2: System test is over. Congratulations to all winners.Div.1 Winners are: qwer1561 Endagorion jcvb subscriber wjh720 Div.2 Winners are: sleepy_mario BIT-silence Owaski Orenji.Sora JavaInTheSouth Also congratulations to JoeyWheeler, the only one who solved problem Div.1 D.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20913",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1832
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces",
          "content": "Div.2 A (Author: Haghani)Idea is a simple greedy, buy needed meat for i - th day when it's cheapest among days 1, 2, ..., n.So, the pseudo code below will work: ans = 0\nprice = infinity\nfor i = 1 to n\n price = min(price, p[i])\n ans += price * a[i]Time complexity: C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by ZloboberDiv.2 B (Author: PrinceOfPersia)Find all prime divisors of n. Assume they are p1, p2, ..., pk (in ). If answer is a, then we know that for each 1 ≤ i ≤ k, obviously a is not divisible by pi2 (and all greater powers of pi). So a ≤ p1 × p2 × ... × pk. And we know that p1 × p2 × ... × pk is itself lovely. So,answer is p1 × p2 × ... × pkTime complexity: C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by ZloboberA (Author: PrinceOfPersia)Problem is: you have to find the minimum number of k, such there is a sequence a1, a2, ..., ak with condition 2a1 + 2a2 + ... + 2ak = S = 2w1 + 2w2 + ... + 2w2. Obviously, minimum value of k is the number of set bits in binary representation of S (proof is easy, you can prove it as a practice :P).Our only problem is how to count the number of set bits in binary representation of S? Building the binary representation of S as an array in is easy: MAXN = 1000000 + log(1000000)\nbit[0..MAXN] = {} // all equal to zero\nans = 0\nfor i = 1 to n\n bit[w[i]] ++ // of course after this, some bits maybe greater than 1, we'll fix them below\nfor i = 0 to MAXN - 1\n bit[i + 1] += bit[i]/2 // floor(bit[i]/2)\n bit[i] %= 2 // bit[i] = bit[i] modulo 2\n ans += bit[i] // if bit[i] = 0, then answer doesn't change, otherwise it'll increase by 1Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniB (Author: PrinceOfPersia)If we fix x and bix mod n, then problem will be solved (because we can then multiply it by the number of valid distinct values of ).For the problem above, let dp[i][j] be the number of valid subsequences of b where x = j and and . Of course, for every i, dp[i][1] = 1. For calculating value of dp[i][j]:For this purpose, we can sort the array a and use two pointer:if p0, p1, ...pn - 1 is a permutation of 0, ..., n - 1 where for each 0 ≤ t < n - 1, apt ≤ apt + 1: for i = 0 to n-1\n dp[i][1] = 1\nfor j = 2 to k\n pointer = 0\n sum = 0\n for i = 0 to n-1\n while pointer < n and a[p[pointer]] <= a[i]\n sum = (sum + dp[p[pointer ++]][j - 1]) % MOD\n dp[i][j] = sumNow, if and x = l - 1 mod n, then answer equals to (there are c - j + 1 valid different values of for the first group and c - j for the second group).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberC (Author: PrinceOfPersia)Solution is something like the fourth LCA approach discussed here.For each 1 ≤ i ≤ n and 0 ≤ j ≤ lg(n), store the minimum 10 people in the path from city (vertex) i to its 2j - th parent in an array.Now everything is needed is: how to merge the array of two paths? You can keep the these 10 values in the array in increasing order and for merging, use merge function which will work in . And then delete the extra values (more than 10).And do the same as described in the article for a query (just like the preprocess part).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberD (Author: PrinceOfPersia)Run binary search on the answer (t). For checking if answer is less than or equal to x (check(x)):First of all delete all edges with destructing time greater than x. Now, if there is more than one pair of edges with the same color connected to a vertex(because we can delete at most one of them), answer is \"No\".Use 2-Sat. Consider a literal for each edge e (xe). If xe = TRUE, it means it should be destructed and it shouldn't otherwise. There are some conditions: For each vertex v, if there is one (exactly one) pair of edges like i and j with the same color connected to v, then we should have the clause . For each vertex v, if the edges connected to it are e1, e2, ..., ek, we should make sure that there is no pair (i, j) where 1 ≤ i < j ≤ k and xe1 = xe2 = True. The naive approach is to add a clause for each pair. But it's not efficient. The efficient way tho satisfy the second condition is to use prefix or: adding k new literals p1, p2, ..., pk and for each j ≤ i, make sure . To make sure about this, we can add two clauses for each pi: and (the second one is only for i > 1).And the only thing left is to make sure (there are no two TRUE edges).This way the number of literals and clauses are . So, after binary search is over, we should run check(t) to get a sample matching.Time complexity: (but slow, because of the constant factor)C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberE (Authors: PrinceOfPersia and Haghani)Lemma #1: If numbers b1, b2, ..., bk are k Kheshtaks of a1, ..., an, then is a Kheshtak of a1, ..., an.Proof: For each 1 ≤ i ≤ k, consider maski is a binary bitmask of length n and its j - th bit shows a subsequence of a1, ..., an (subset) with xor equal to bi.So, xor of elements subsequence(subset) of a1, ..., an with bitmask equal to equals to . So, it's a Kheshtak of this sequence.From this lemma, we can get another results: If all numbers b1, b2, ..., bk are k Kheshtaks of a1, ..., an, then every Kheshtak of b1, b2, ..., bk is a Kheshtak of a1, ..., anLemma #2: Score of sequence a1, a2, ..., an is equal to the score of sequence .Proof: If we show the second sequence by b1, b2, ..., bn, then for each 1 ≤ i ≤ n: bi = ai = each element from sequence b is a Kheshtak of sequence a and vise versa. So, due to the result of Lemma #1, each Kheshtak of sequence b is a Kheshtak of sequence a and vise versa. So: score(b1, ..., bn) ≤ score(a1, ..., an) score(a1, ..., an) ≤ score(b1, ..., bn) score(a1, ..., an) = score(b1, ..., bn)Back to original problem: denote another array b2, ..., bn where . Let's solve these two problems:1- We have array a1, ..., an and q queries of two types: upd(l, r, k): Given numbers l, r and k, for each l ≤ i ≤ r, perform ask(i):  Given number i, return the value of ai. This problem can be solved easily with a simple segment tree using lazy propagation.2- We have array b2, ..., bn and queries of two types: modify(p, k): Perform bp = k. basis(l, r): Find and return the basis vector of bl, bl + 1, ..., br (using Gaussian Elimination, its size it at most 32). This problem can be solved by a segment tree where in each node we have the basis of the substring of that node (node [l, r) has the basis of sequence bl, ..., br - 1).This way we can insert to a basis vector v: insert(x, v)\n\tfor a in v\n\t\tif a & -a & x\n\t\t\tx ^= a\n\tif !x\n\t\treturn\n\tfor a in v\n\t\tif x & -x & a\n\t\t\ta ^= x\n\tv.push(x)But size of v will always be less than or equal to 32. For merging two nodes (of segment tree), we can insert the elements of one in another one.For handling queries of two types, we act like this:Type one: Call functions: upd(l, r, k), and .Type two: Let b = basis(l + 1, r). Call insert(al, b). And then print 2b.size() as the answer.Time complexity: = C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberF (Author: PrinceOfPersia)Use Aho-Corasick. Assume first of all we build the trie of our strings (function t). If t(v, c) ≠  - 1 it means that there is an edge in the trie outgoing from vertex v written c on it.So, for building Aho-Corasick, consider f(v) = the vertex we go into, in case of failure (t(v, c) =  - 1). i.e the deepest vertex (u), that v ≠ u and the path from root to u is a suffix of path from root to v. No we can build an automaton (Aho-Corasick), function g. For each i, do this (in the automaton): cur = root\nfor c in s[i]\n\tcur = g(cur, c)\n\tAnd then push i in q[cur] (q is a vector, also we do this for cur = root).\n\nend[cur].push(i) \t// end is also a vector, consisting of the indices of strings ending in vertex cur (state cur in automaton)\nlast[i] = cur // last[i] is the final state we get to from searching string s[i] in automaton gAssume cnt(v, i) is the number of occurrences of number i in q[v]. Also, denote .Build another tree. In this tree, for each i that is not root of the trie, let par[i] = f(i) (the vertex we go in the trie, in case of failure) and call it C-Tree.So now, problem is on a tree. Operations are : Each query gives numbers l, r, k and you have to find the number .Act offline. If N = 105, then:1. For each i such that , collect queries (like struct) in a vector of queries query[i], then run dfs on the C-Tree and using a partial sum answer to all queries with k = i. There are at most of these numbers, so it can be done in . After doing these, erase i from all q[1], q[1], ..., q[N].Code (in dfs) would be like this(on C-Tree): partial_sum[n] = {}; // all 0\ndfs(v, i){\n\tcnt = 0;\n\tfor x in q[v]\n\t\tif(x == i)\n\t\t++ cnt;\n\tfor u in childern[v]\n\t\tcnt += dfs(u);\n\tfor x in end[v]\n\t\tpartial_sum[x] += cnt;\n\treturn cnt;\n}\ncalc(i){\n\tdfs(root, i);\n\tfor i = 2 to n\n\t\tpartial_sum[i] += partial_sum[i-1]\n\tfor query u in query[i]\n\t\tu.ans = partial_sum[u.r] - partial_sum[u.l - 1]\n}And we should just run calc(i) for each of them.2. For each i such that , collect queries (like struct) in a vector of queries query[i]. (each element of this vector have three integers in it: l, r and ans).Consider this problem:We have an array a of length N(initially all element equal to 0) and some queries of two types: increase(i, val): increase a[i] by val sum(i): tell the value of a[1] + a[2] + ... + a[i] We know that number of queries of the first type is and from the second type is . Using Sqrt decomposition, we can solve this problem in : K = sqrt(N)\ntot[K] = {}, a[N] = {} // this code is 0-based\nincrease(i, val)\n\twhile i < N and i % K > 0\n\t\ta[i ++] += val\n\twhile i < K\n\t\ttot[i/K] += val\n\t\ti += K\nsum(i)\n\treturn a[i] + tot[i/K]Back to our problem now.Then, just run dfs once on this C-Tree and act like this: dfs(vertex v):\n\tfor i in end[v]\n\t\tincrease(i, 1)\n\tfor i in q[v]\n\t\tfor query u in query[i]\n\t\t\tu.ans += sum(u.r) - sum(u.l - 1)\n\tfor u in children[v]\n\t\tdfs(u)\n\tfor i in end[v]\n\t\tincrease(i, -1)Then answer to a query q is q.ans.Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20971",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10107
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #326 - Codeforces - Code 1",
          "code": "00:30 start time (local time)\n+  0:10 expected delay\n+  2:30 contest\n+  0:30 system test\n+  0:30 rating changes\n= 04:10 sleep time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 - Codeforces - Code 2",
          "code": "00:30 start time (local time)\n+  0:10 expected delay\n+  2:30 contest\n+  0:30 system test\n+  0:30 rating changes\n= 04:10 sleep time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 - Codeforces - Code 3",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 - Codeforces - Code 4",
          "code": "#just_grandmaster_things",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 1",
          "code": "ans = 0\nprice = infinity\nfor i = 1 to n\n      price = min(price, p[i])\n      ans += price * a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 2",
          "code": "ans = 0\nprice = infinity\nfor i = 1 to n\n      price = min(price, p[i])\n      ans += price * a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 3",
          "code": "MAXN = 1000000 + log(1000000)\nbit[0..MAXN] = {} // all equal to zero\nans = 0\nfor i = 1 to n\n      bit[w[i]] ++ // of course after this, some bits maybe greater than 1, we'll fix them below\nfor i = 0 to MAXN - 1\n      bit[i + 1] += bit[i]/2 // floor(bit[i]/2)\n      bit[i] %= 2 // bit[i] = bit[i] modulo 2\n      ans += bit[i] // if bit[i] = 0, then answer doesn't change, otherwise it'll increase by 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 4",
          "code": "MAXN = 1000000 + log(1000000)\nbit[0..MAXN] = {} // all equal to zero\nans = 0\nfor i = 1 to n\n      bit[w[i]] ++ // of course after this, some bits maybe greater than 1, we'll fix them below\nfor i = 0 to MAXN - 1\n      bit[i + 1] += bit[i]/2 // floor(bit[i]/2)\n      bit[i] %= 2 // bit[i] = bit[i] modulo 2\n      ans += bit[i] // if bit[i] = 0, then answer doesn't change, otherwise it'll increase by 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 5",
          "code": "for i = 0 to n-1\n      dp[i][1] = 1\nfor j = 2 to k\n      pointer = 0\n      sum = 0\n      for i = 0 to n-1\n            while pointer < n and a[p[pointer]] <= a[i]\n                  sum = (sum + dp[p[pointer ++]][j - 1]) % MOD\n            dp[i][j] = sum",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 6",
          "code": "for i = 0 to n-1\n      dp[i][1] = 1\nfor j = 2 to k\n      pointer = 0\n      sum = 0\n      for i = 0 to n-1\n            while pointer < n and a[p[pointer]] <= a[i]\n                  sum = (sum + dp[p[pointer ++]][j - 1]) % MOD\n            dp[i][j] = sum",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 7",
          "code": "insert(x, v)\n\tfor a in v\n\t\tif a & -a & x\n\t\t\tx ^= a\n\tif !x\n\t\treturn\n\tfor a in v\n\t\tif x & -x & a\n\t\t\ta ^= x\n\tv.push(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 8",
          "code": "insert(x, v)\n\tfor a in v\n\t\tif a & -a & x\n\t\t\tx ^= a\n\tif !x\n\t\treturn\n\tfor a in v\n\t\tif x & -x & a\n\t\t\ta ^= x\n\tv.push(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 9",
          "code": "cur = root\nfor c in s[i]\n\tcur = g(cur, c)\n\tAnd then push i in q[cur] (q is a vector, also we do this for cur = root).\n\nend[cur].push(i) \t// end is also a vector, consisting of the indices of strings ending in vertex cur (state cur in automaton)\nlast[i] = cur // last[i] is the final state we get to from searching string s[i] in automaton g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 10",
          "code": "cur = root\nfor c in s[i]\n\tcur = g(cur, c)\n\tAnd then push i in q[cur] (q is a vector, also we do this for cur = root).\n\nend[cur].push(i) \t// end is also a vector, consisting of the indices of strings ending in vertex cur (state cur in automaton)\nlast[i] = cur // last[i] is the final state we get to from searching string s[i] in automaton g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 11",
          "code": "partial_sum[n] = {}; // all 0\ndfs(v, i){\n\tcnt = 0;\n\tfor x in q[v]\n\t\tif(x == i)\n\t\t++ cnt;\n\tfor u in childern[v]\n\t\tcnt += dfs(u);\n\tfor x in end[v]\n\t\tpartial_sum[x] += cnt;\n\treturn cnt;\n}\ncalc(i){\n\tdfs(root, i);\n\tfor i = 2 to n\n\t\tpartial_sum[i] += partial_sum[i-1]\n\tfor query u in query[i]\n\t\tu.ans = partial_sum[u.r] - partial_sum[u.l - 1]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 12",
          "code": "partial_sum[n] = {}; // all 0\ndfs(v, i){\n\tcnt = 0;\n\tfor x in q[v]\n\t\tif(x == i)\n\t\t++ cnt;\n\tfor u in childern[v]\n\t\tcnt += dfs(u);\n\tfor x in end[v]\n\t\tpartial_sum[x] += cnt;\n\treturn cnt;\n}\ncalc(i){\n\tdfs(root, i);\n\tfor i = 2 to n\n\t\tpartial_sum[i] += partial_sum[i-1]\n\tfor query u in query[i]\n\t\tu.ans = partial_sum[u.r] - partial_sum[u.l - 1]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 13",
          "code": "K = sqrt(N)\ntot[K] = {}, a[N] = {} // this code is 0-based\nincrease(i, val)\n\twhile i < N and i % K > 0\n\t\ta[i ++] += val\n\twhile i < K\n\t\ttot[i/K] += val\n\t\ti += K\nsum(i)\n\treturn a[i] + tot[i/K]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 14",
          "code": "K = sqrt(N)\ntot[K] = {}, a[N] = {} // this code is 0-based\nincrease(i, val)\n\twhile i < N and i % K > 0\n\t\ta[i ++] += val\n\twhile i < K\n\t\ttot[i/K] += val\n\t\ti += K\nsum(i)\n\treturn a[i] + tot[i/K]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 15",
          "code": "dfs(vertex v):\n\tfor i in end[v]\n\t\tincrease(i, 1)\n\tfor i in q[v]\n\t\tfor query u in query[i]\n\t\t\tu.ans += sum(u.r) - sum(u.l - 1)\n\tfor u in children[v]\n\t\tdfs(u)\n\tfor i in end[v]\n\t\tincrease(i, -1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 16",
          "code": "dfs(vertex v):\n\tfor i in end[v]\n\t\tincrease(i, 1)\n\tfor i in q[v]\n\t\tfor query u in query[i]\n\t\t\tu.ans += sum(u.r) - sum(u.l - 1)\n\tfor u in children[v]\n\t\tdfs(u)\n\tfor i in end[v]\n\t\tincrease(i, -1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 17",
          "code": "3 12 2\n5 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 18",
          "code": "3 12 2\n5 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 19",
          "code": "5 9 1  5 9 1  5 9 1   5 9 1  --> b\n1 2 3  4 5 6  7 8 9  10 11 12 --> positions\n\nlength 1 subsequence 12\nlength 2: \n1-4,1-5,1-7,1-8,1-10,1-11,2-5,2-8,2-11,3-4,3-5,3-6,3-7,3-8,3-9,3-10,3-11,3-12,\n4-7,4-8,4-10,4-11,5-8,5-11,6-7,6-8,6-9,6-10,6-11,6-12\n7-10,7-11,8-11,9-10,9-11,9-12\n\ntotal 36+12 = 48",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 20",
          "code": "5 9 1  5 9 1  5 9 1   5 9 1  --> b\n1 2 3  4 5 6  7 8 9  10 11 12 --> positions\n\nlength 1 subsequence 12\nlength 2: \n1-4,1-5,1-7,1-8,1-10,1-11,2-5,2-8,2-11,3-4,3-5,3-6,3-7,3-8,3-9,3-10,3-11,3-12,\n4-7,4-8,4-10,4-11,5-8,5-11,6-7,6-8,6-9,6-10,6-11,6-12\n7-10,7-11,8-11,9-10,9-11,9-12\n\ntotal 36+12 = 48",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAX_N, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, MAX_N, \"q\");\n    inf.readEoln();\n\n    // Initialize Union-Find (Disjoint Set Union) structure\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    // Function to find the representative of a set\n    function<int(int)> find = [&](int u) {\n        if (parent[u] != u)\n            parent[u] = find(parent[u]);\n        return parent[u];\n    };\n\n    // Read and process the edges\n    for (int i = 0; i < n - 1; ++i) {\n        int v = inf.readInt(1, n, \"v\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u\");\n        ensuref(v != u, \"Edge cannot connect a node to itself\");\n        inf.readEoln();\n\n        // Union the sets and check for cycles\n        int pv = find(v);\n        int pu = find(u);\n        if (pv != pu) {\n            parent[pu] = pv;\n        } else {\n            ensuref(false, \"Graph contains a cycle\");\n        }\n    }\n\n    // Read the people locations\n    vector<int> c = inf.readInts(m, 1, n, \"c\");\n    inf.readEoln();\n\n    // Read the queries\n    for (int i = 0; i < q; ++i) {\n        int v = inf.readInt(1, n, \"v\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int a = inf.readInt(1, 10, \"a\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAX_N, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, MAX_N, \"q\");\n    inf.readEoln();\n\n    // Initialize Union-Find (Disjoint Set Union) structure\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    // Function to find the representative of a set\n    function<int(int)> find = [&](int u) {\n        if (parent[u] != u)\n            parent[u] = find(parent[u]);\n        return parent[u];\n    };\n\n    // Read and process the edges\n    for (int i = 0; i < n - 1; ++i) {\n        int v = inf.readInt(1, n, \"v\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u\");\n        ensuref(v != u, \"Edge cannot connect a node to itself\");\n        inf.readEoln();\n\n        // Union the sets and check for cycles\n        int pv = find(v);\n        int pu = find(u);\n        if (pv != pu) {\n            parent[pu] = pv;\n        } else {\n            ensuref(false, \"Graph contains a cycle\");\n        }\n    }\n\n    // Read the people locations\n    vector<int> c = inf.readInts(m, 1, n, \"c\");\n    inf.readEoln();\n\n    // Read the queries\n    for (int i = 0; i < q; ++i) {\n        int v = inf.readInt(1, n, \"v\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int a = inf.readInt(1, 10, \"a\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAX_N, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, MAX_N, \"q\");\n    inf.readEoln();\n\n    // Initialize Union-Find (Disjoint Set Union) structure\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    // Function to find the representative of a set\n    function<int(int)> find = [&](int u) {\n        if (parent[u] != u)\n            parent[u] = find(parent[u]);\n        return parent[u];\n    };\n\n    // Read and process the edges\n    for (int i = 0; i < n - 1; ++i) {\n        int v = inf.readInt(1, n, \"v\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u\");\n        ensuref(v != u, \"Edge cannot connect a node to itself\");\n        inf.readEoln();\n\n        // Union the sets and check for cycles\n        int pv = find(v);\n        int pu = find(u);\n        if (pv != pu) {\n            parent[pu] = pv;\n        } else {\n            ensuref(false, \"Graph contains a cycle\");\n        }\n    }\n\n    // Read the people locations\n    vector<int> c = inf.readInts(m, 1, n, \"c\");\n    inf.readEoln();\n\n    // Read the queries\n    for (int i = 0; i < q; ++i) {\n        int v = inf.readInt(1, n, \"v\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int a = inf.readInt(1, 10, \"a\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string people_type = opt<string>(\"people_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Ensure that n, m, q are within constraints\n    assert(1 <= n && n <= 100000);\n    assert(1 <= m && m <= 100000);\n    assert(1 <= q && q <= 100000);\n\n    // Generate the tree\n    vector<pair<int,int>> edges;\n    if (tree_type == \"chain\") {\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({i-1, i});\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"random\") {\n        for (int i = 2; i <= n; i++) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    } else {\n        // Default to random\n        for (int i = 2; i <= n; i++) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n\n    // Shuffle nodes to make numbering random\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; i++) perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    // Apply permutation to edges\n    vector<pair<int,int>> shuffled_edges;\n    for (auto e : edges) {\n        int u = perm[e.first];\n        int v = perm[e.second];\n        shuffled_edges.push_back({u,v});\n    }\n    // Shuffle edges\n    shuffle(shuffled_edges.begin(), shuffled_edges.end());\n\n    // Generate people positions\n    vector<int> c(m + 1);\n    if (people_type == \"random\") {\n        for (int i = 1; i <= m; i++) {\n            c[i] = rnd.next(1, n);\n        }\n    } else if (people_type == \"one_per_city\") {\n        // Ensure that m ≤ n\n        assert(m <= n);\n        vector<int> cities = perm; // perm[1..n]\n        // Assign first m cities to people\n        for (int i = 1; i <= m; i++) {\n            c[i] = cities[i];\n        }\n    } else if (people_type == \"all_in_one_city\") {\n        int city = rnd.next(1, n);\n        for (int i = 1; i <= m; i++) {\n            c[i] = city;\n        }\n    } else {\n        // Default to random\n        for (int i = 1; i <= m; i++) {\n            c[i] = rnd.next(1, n);\n        }\n    }\n\n    // Generate queries\n    vector<tuple<int,int,int>> queries;\n    const int a_max = 10;\n    if (query_type == \"random\") {\n        for (int i = 0; i < q; i++) {\n            int v = rnd.next(1, n);\n            int u = rnd.next(1, n);\n            int a = rnd.next(1, a_max);\n            queries.push_back(make_tuple(v,u,a));\n        }\n    } else if (query_type == \"small_paths\") {\n        for (int i = 0; i < q; i++) {\n            int v = rnd.next(1, n);\n            int u = v;\n            for (int j = 0; j < 3 && u == v; j++) { // Try up to 3 times to get a different u\n                u = rnd.next(max(1,v-5), min(n,v+5)); // Nearby nodes\n            }\n            int a = rnd.next(1, a_max);\n            queries.push_back(make_tuple(v,u,a));\n        }\n    } else if (query_type == \"large_paths\") {\n        for (int i = 0; i < q; i++) {\n            int v = perm[1];\n            int u = perm[n];\n            int a = rnd.next(1, a_max);\n            queries.push_back(make_tuple(v,u,a));\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < q; i++) {\n            int v = rnd.next(1, n);\n            int u = rnd.next(1, n);\n            int a = rnd.next(1, a_max);\n            queries.push_back(make_tuple(v,u,a));\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, q);\n    for (auto e : shuffled_edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    for (int i = 1; i <= m; i++) {\n        printf(\"%d%c\", c[i], i == m ? '\\n' : ' ');\n    }\n    for (auto query : queries) {\n        int v, u, a;\n        tie(v,u,a) = query;\n        printf(\"%d %d %d\\n\", v, u, a);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string people_type = opt<string>(\"people_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Ensure that n, m, q are within constraints\n    assert(1 <= n && n <= 100000);\n    assert(1 <= m && m <= 100000);\n    assert(1 <= q && q <= 100000);\n\n    // Generate the tree\n    vector<pair<int,int>> edges;\n    if (tree_type == \"chain\") {\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({i-1, i});\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"random\") {\n        for (int i = 2; i <= n; i++) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    } else {\n        // Default to random\n        for (int i = 2; i <= n; i++) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n\n    // Shuffle nodes to make numbering random\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; i++) perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    // Apply permutation to edges\n    vector<pair<int,int>> shuffled_edges;\n    for (auto e : edges) {\n        int u = perm[e.first];\n        int v = perm[e.second];\n        shuffled_edges.push_back({u,v});\n    }\n    // Shuffle edges\n    shuffle(shuffled_edges.begin(), shuffled_edges.end());\n\n    // Generate people positions\n    vector<int> c(m + 1);\n    if (people_type == \"random\") {\n        for (int i = 1; i <= m; i++) {\n            c[i] = rnd.next(1, n);\n        }\n    } else if (people_type == \"one_per_city\") {\n        // Ensure that m ≤ n\n        assert(m <= n);\n        vector<int> cities = perm; // perm[1..n]\n        // Assign first m cities to people\n        for (int i = 1; i <= m; i++) {\n            c[i] = cities[i];\n        }\n    } else if (people_type == \"all_in_one_city\") {\n        int city = rnd.next(1, n);\n        for (int i = 1; i <= m; i++) {\n            c[i] = city;\n        }\n    } else {\n        // Default to random\n        for (int i = 1; i <= m; i++) {\n            c[i] = rnd.next(1, n);\n        }\n    }\n\n    // Generate queries\n    vector<tuple<int,int,int>> queries;\n    const int a_max = 10;\n    if (query_type == \"random\") {\n        for (int i = 0; i < q; i++) {\n            int v = rnd.next(1, n);\n            int u = rnd.next(1, n);\n            int a = rnd.next(1, a_max);\n            queries.push_back(make_tuple(v,u,a));\n        }\n    } else if (query_type == \"small_paths\") {\n        for (int i = 0; i < q; i++) {\n            int v = rnd.next(1, n);\n            int u = v;\n            for (int j = 0; j < 3 && u == v; j++) { // Try up to 3 times to get a different u\n                u = rnd.next(max(1,v-5), min(n,v+5)); // Nearby nodes\n            }\n            int a = rnd.next(1, a_max);\n            queries.push_back(make_tuple(v,u,a));\n        }\n    } else if (query_type == \"large_paths\") {\n        for (int i = 0; i < q; i++) {\n            int v = perm[1];\n            int u = perm[n];\n            int a = rnd.next(1, a_max);\n            queries.push_back(make_tuple(v,u,a));\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < q; i++) {\n            int v = rnd.next(1, n);\n            int u = rnd.next(1, n);\n            int a = rnd.next(1, a_max);\n            queries.push_back(make_tuple(v,u,a));\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, q);\n    for (auto e : shuffled_edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    for (int i = 1; i <= m; i++) {\n        printf(\"%d%c\", c[i], i == m ? '\\n' : ' ');\n    }\n    for (auto query : queries) {\n        int v, u, a;\n        tie(v,u,a) = query;\n        printf(\"%d %d %d\\n\", v, u, a);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 5 -m 3 -q 2 -tree_type chain -people_type random -query_type random\n./gen -n 5 -m 3 -q 2 -tree_type star -people_type random -query_type random\n./gen -n 5 -m 5 -q 5 -tree_type random -people_type one_per_city -query_type random\n\n# Medium test cases\n./gen -n 100 -m 50 -q 50 -tree_type chain -people_type random -query_type random\n./gen -n 100 -m 50 -q 50 -tree_type star -people_type all_in_one_city -query_type large_paths\n./gen -n 1000 -m 500 -q 500 -tree_type random -people_type random -query_type small_paths\n\n# Large test cases\n./gen -n 100000 -m 100000 -q 100000 -tree_type chain -people_type random -query_type random\n./gen -n 100000 -m 100000 -q 100000 -tree_type star -people_type all_in_one_city -query_type large_paths\n./gen -n 100000 -m 100000 -q 100000 -tree_type random -people_type random -query_type small_paths\n\n# Edge cases\n./gen -n 1 -m 1 -q 1 -tree_type chain -people_type all_in_one_city -query_type random\n./gen -n 2 -m 2 -q 2 -tree_type chain -people_type one_per_city -query_type random\n\n# Special cases\n./gen -n 100000 -m 100000 -q 100000 -tree_type chain -people_type one_per_city -query_type small_paths\n./gen -n 100000 -m 100000 -q 100000 -tree_type star -people_type one_per_city -query_type large_paths\n./gen -n 100000 -m 50000 -q 100000 -tree_type random -people_type random -query_type random\n\n# All people in one city\n./gen -n 100000 -m 100000 -q 100000 -tree_type random -people_type all_in_one_city -query_type random\n\n# All people in different cities\n./gen -n 100000 -m 100000 -q 100000 -tree_type random -people_type one_per_city -query_type random\n\n# Random trees with various query types\n./gen -n 50000 -m 40000 -q 50000 -tree_type random -people_type random -query_type random\n./gen -n 50000 -m 40000 -q 50000 -tree_type random -people_type random -query_type small_paths\n./gen -n 50000 -m 40000 -q 50000 -tree_type random -people_type random -query_type large_paths\n\n# Tree with only leaf nodes having people\n./gen -n 100000 -m 50000 -q 100000 -tree_type random -people_type leaf_only -query_type random\n\n# Tree with only internal nodes having people\n./gen -n 100000 -m 50000 -q 100000 -tree_type random -people_type internal_only -query_type random\n\n# Varying 'a' in queries\n./gen -n 100000 -m 100000 -q 100000 -tree_type random -people_type random -query_type varying_a\n\n# Paths of length 1 (v == u)\n./gen -n 100000 -m 100000 -q 100000 -tree_type random -people_type random -query_type same_node\n\n# Maximum 'a' in all queries\n./gen -n 100000 -m 100000 -q 100000 -tree_type random -people_type random -query_type max_a\n\n# Minimum 'a' in all queries\n./gen -n 100000 -m 100000 -q 100000 -tree_type random -people_type random -query_type min_a\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:56.382476",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "587/D",
      "title": "D. Duff in Mafia",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test6 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two integers n and m (2 ≤ n ≤ 5 × 104 and 1 ≤ m ≤ 5 × 104), number of cities and number of roads in the country.The next m lines contain the the roads. i - th of them contains four integers vi, ui, ci and ti (1 ≤ vi, ui ≤ n, vi ≠ ui and 1 ≤ ci, ti ≤ 109 for each 1 ≤ i ≤ m).",
      "output_spec": "OutputIn the first line of input, print \"Yes\" (without quotes) if satisfying the first condition is possible and \"No\" (without quotes) otherwise.If it is possible, then you have to print two integers t and k in the second line, the minimum destructing time and the number of roads in the matching ().In the third line print k distinct integers separated by spaces, indices of the roads in the matching in any order. Roads are numbered starting from one in order of their appearance in the input.If there's more than one solution, print any of them.",
      "sample_tests": "ExamplesInputCopy5 72 1 3 73 1 1 65 4 1 84 5 1 13 2 2 34 5 2 52 3 2 4OutputCopyYes3 24 5InputCopy3 53 2 1 31 3 1 13 2 1 41 3 2 21 3 2 10OutputCopyNo",
      "description": "D. Duff in Mafia\n\ntime limit per test6 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains two integers n and m (2 ≤ n ≤ 5 × 104 and 1 ≤ m ≤ 5 × 104), number of cities and number of roads in the country.The next m lines contain the the roads. i - th of them contains four integers vi, ui, ci and ti (1 ≤ vi, ui ≤ n, vi ≠ ui and 1 ≤ ci, ti ≤ 109 for each 1 ≤ i ≤ m).\n\nOutputIn the first line of input, print \"Yes\" (without quotes) if satisfying the first condition is possible and \"No\" (without quotes) otherwise.If it is possible, then you have to print two integers t and k in the second line, the minimum destructing time and the number of roads in the matching ().In the third line print k distinct integers separated by spaces, indices of the roads in the matching in any order. Roads are numbered starting from one in order of their appearance in the input.If there's more than one solution, print any of them.\n\nInputCopy5 72 1 3 73 1 1 65 4 1 84 5 1 13 2 2 34 5 2 52 3 2 4OutputCopyYes3 24 5InputCopy3 53 2 1 31 3 1 13 2 1 41 3 2 21 3 2 10OutputCopyNo\n\nInputCopy5 72 1 3 73 1 1 65 4 1 84 5 1 13 2 2 34 5 2 52 3 2 4\n\nOutputCopyYes3 24 5\n\nInputCopy3 53 2 1 31 3 1 13 2 1 41 3 2 21 3 2 10\n\nOutputCopyNo\n\nNoteGraph of Andarz Gu in the first sample case is as follows:  A solution would be to destruct the roads with crosses.Graph of Andarz Gu in the second sample case is as follows:",
      "solutions": [
        {
          "title": "Codeforces Round #326 - Codeforces",
          "content": "Hello Codeforces.I'm honored to announce you, that Codeforces round #326 is gonna take place soon on Codeforces.Writers are AmirMohammad Dehghan(PrinceOfPersia) and Ali Haghani(Haghani). There will be 6 problems in each division(4 problems are common) and you'll have 2 and a half hour to solve them. I hope you enjoy the problems.I wanna thank Maxim Akhmedov(Zlobober) for his great helps in preparing this round, MikeMirzayanov for wonderful platforms of Codeforce and Polygon, Delinur for translating problem statements into Russian and MohammadReza Maleki(mruxim) and Ali Bahjati(LiTi) for their great advices (and LiTi again for some graphics).This is my third round on Codeforces and not the last one, I hope.This is the last round on Codeforces with Zlobober as coordinator. It was nice working with him. We had a lot of fun and interesting contests during his coordination. I just wanna say: Thank you Maxim for all your contribution to CodeForces community and good luck in the future. After I heard these news, my first guess for the next coordinator was I_love_Tanya_Romanova; But I don't know if CodeForces hires people from out of Russia or not.The main character of this round is Duff, but you'll also have to help her friend, Malek!I wish you all high ratings and lots of joy.Scoring will be posted soon.GL & HF!Problems are sorted by the expected difficulty, but we strictly recommend you to read all the problems.UPD: Scoring is: 750-1000-1500-2000-2500-3000 in Div.2 and 500-1000-1500-2000-2750-2750 in Div.1 .UPD1: Editorial is published.UPD2: System test is over. Congratulations to all winners.Div.1 Winners are: qwer1561 Endagorion jcvb subscriber wjh720 Div.2 Winners are: sleepy_mario BIT-silence Owaski Orenji.Sora JavaInTheSouth Also congratulations to JoeyWheeler, the only one who solved problem Div.1 D.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20913",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1832
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces",
          "content": "Div.2 A (Author: Haghani)Idea is a simple greedy, buy needed meat for i - th day when it's cheapest among days 1, 2, ..., n.So, the pseudo code below will work: ans = 0\nprice = infinity\nfor i = 1 to n\n price = min(price, p[i])\n ans += price * a[i]Time complexity: C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by ZloboberDiv.2 B (Author: PrinceOfPersia)Find all prime divisors of n. Assume they are p1, p2, ..., pk (in ). If answer is a, then we know that for each 1 ≤ i ≤ k, obviously a is not divisible by pi2 (and all greater powers of pi). So a ≤ p1 × p2 × ... × pk. And we know that p1 × p2 × ... × pk is itself lovely. So,answer is p1 × p2 × ... × pkTime complexity: C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by ZloboberA (Author: PrinceOfPersia)Problem is: you have to find the minimum number of k, such there is a sequence a1, a2, ..., ak with condition 2a1 + 2a2 + ... + 2ak = S = 2w1 + 2w2 + ... + 2w2. Obviously, minimum value of k is the number of set bits in binary representation of S (proof is easy, you can prove it as a practice :P).Our only problem is how to count the number of set bits in binary representation of S? Building the binary representation of S as an array in is easy: MAXN = 1000000 + log(1000000)\nbit[0..MAXN] = {} // all equal to zero\nans = 0\nfor i = 1 to n\n bit[w[i]] ++ // of course after this, some bits maybe greater than 1, we'll fix them below\nfor i = 0 to MAXN - 1\n bit[i + 1] += bit[i]/2 // floor(bit[i]/2)\n bit[i] %= 2 // bit[i] = bit[i] modulo 2\n ans += bit[i] // if bit[i] = 0, then answer doesn't change, otherwise it'll increase by 1Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniB (Author: PrinceOfPersia)If we fix x and bix mod n, then problem will be solved (because we can then multiply it by the number of valid distinct values of ).For the problem above, let dp[i][j] be the number of valid subsequences of b where x = j and and . Of course, for every i, dp[i][1] = 1. For calculating value of dp[i][j]:For this purpose, we can sort the array a and use two pointer:if p0, p1, ...pn - 1 is a permutation of 0, ..., n - 1 where for each 0 ≤ t < n - 1, apt ≤ apt + 1: for i = 0 to n-1\n dp[i][1] = 1\nfor j = 2 to k\n pointer = 0\n sum = 0\n for i = 0 to n-1\n while pointer < n and a[p[pointer]] <= a[i]\n sum = (sum + dp[p[pointer ++]][j - 1]) % MOD\n dp[i][j] = sumNow, if and x = l - 1 mod n, then answer equals to (there are c - j + 1 valid different values of for the first group and c - j for the second group).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberC (Author: PrinceOfPersia)Solution is something like the fourth LCA approach discussed here.For each 1 ≤ i ≤ n and 0 ≤ j ≤ lg(n), store the minimum 10 people in the path from city (vertex) i to its 2j - th parent in an array.Now everything is needed is: how to merge the array of two paths? You can keep the these 10 values in the array in increasing order and for merging, use merge function which will work in . And then delete the extra values (more than 10).And do the same as described in the article for a query (just like the preprocess part).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberD (Author: PrinceOfPersia)Run binary search on the answer (t). For checking if answer is less than or equal to x (check(x)):First of all delete all edges with destructing time greater than x. Now, if there is more than one pair of edges with the same color connected to a vertex(because we can delete at most one of them), answer is \"No\".Use 2-Sat. Consider a literal for each edge e (xe). If xe = TRUE, it means it should be destructed and it shouldn't otherwise. There are some conditions: For each vertex v, if there is one (exactly one) pair of edges like i and j with the same color connected to v, then we should have the clause . For each vertex v, if the edges connected to it are e1, e2, ..., ek, we should make sure that there is no pair (i, j) where 1 ≤ i < j ≤ k and xe1 = xe2 = True. The naive approach is to add a clause for each pair. But it's not efficient. The efficient way tho satisfy the second condition is to use prefix or: adding k new literals p1, p2, ..., pk and for each j ≤ i, make sure . To make sure about this, we can add two clauses for each pi: and (the second one is only for i > 1).And the only thing left is to make sure (there are no two TRUE edges).This way the number of literals and clauses are . So, after binary search is over, we should run check(t) to get a sample matching.Time complexity: (but slow, because of the constant factor)C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberE (Authors: PrinceOfPersia and Haghani)Lemma #1: If numbers b1, b2, ..., bk are k Kheshtaks of a1, ..., an, then is a Kheshtak of a1, ..., an.Proof: For each 1 ≤ i ≤ k, consider maski is a binary bitmask of length n and its j - th bit shows a subsequence of a1, ..., an (subset) with xor equal to bi.So, xor of elements subsequence(subset) of a1, ..., an with bitmask equal to equals to . So, it's a Kheshtak of this sequence.From this lemma, we can get another results: If all numbers b1, b2, ..., bk are k Kheshtaks of a1, ..., an, then every Kheshtak of b1, b2, ..., bk is a Kheshtak of a1, ..., anLemma #2: Score of sequence a1, a2, ..., an is equal to the score of sequence .Proof: If we show the second sequence by b1, b2, ..., bn, then for each 1 ≤ i ≤ n: bi = ai = each element from sequence b is a Kheshtak of sequence a and vise versa. So, due to the result of Lemma #1, each Kheshtak of sequence b is a Kheshtak of sequence a and vise versa. So: score(b1, ..., bn) ≤ score(a1, ..., an) score(a1, ..., an) ≤ score(b1, ..., bn) score(a1, ..., an) = score(b1, ..., bn)Back to original problem: denote another array b2, ..., bn where . Let's solve these two problems:1- We have array a1, ..., an and q queries of two types: upd(l, r, k): Given numbers l, r and k, for each l ≤ i ≤ r, perform ask(i):  Given number i, return the value of ai. This problem can be solved easily with a simple segment tree using lazy propagation.2- We have array b2, ..., bn and queries of two types: modify(p, k): Perform bp = k. basis(l, r): Find and return the basis vector of bl, bl + 1, ..., br (using Gaussian Elimination, its size it at most 32). This problem can be solved by a segment tree where in each node we have the basis of the substring of that node (node [l, r) has the basis of sequence bl, ..., br - 1).This way we can insert to a basis vector v: insert(x, v)\n\tfor a in v\n\t\tif a & -a & x\n\t\t\tx ^= a\n\tif !x\n\t\treturn\n\tfor a in v\n\t\tif x & -x & a\n\t\t\ta ^= x\n\tv.push(x)But size of v will always be less than or equal to 32. For merging two nodes (of segment tree), we can insert the elements of one in another one.For handling queries of two types, we act like this:Type one: Call functions: upd(l, r, k), and .Type two: Let b = basis(l + 1, r). Call insert(al, b). And then print 2b.size() as the answer.Time complexity: = C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberF (Author: PrinceOfPersia)Use Aho-Corasick. Assume first of all we build the trie of our strings (function t). If t(v, c) ≠  - 1 it means that there is an edge in the trie outgoing from vertex v written c on it.So, for building Aho-Corasick, consider f(v) = the vertex we go into, in case of failure (t(v, c) =  - 1). i.e the deepest vertex (u), that v ≠ u and the path from root to u is a suffix of path from root to v. No we can build an automaton (Aho-Corasick), function g. For each i, do this (in the automaton): cur = root\nfor c in s[i]\n\tcur = g(cur, c)\n\tAnd then push i in q[cur] (q is a vector, also we do this for cur = root).\n\nend[cur].push(i) \t// end is also a vector, consisting of the indices of strings ending in vertex cur (state cur in automaton)\nlast[i] = cur // last[i] is the final state we get to from searching string s[i] in automaton gAssume cnt(v, i) is the number of occurrences of number i in q[v]. Also, denote .Build another tree. In this tree, for each i that is not root of the trie, let par[i] = f(i) (the vertex we go in the trie, in case of failure) and call it C-Tree.So now, problem is on a tree. Operations are : Each query gives numbers l, r, k and you have to find the number .Act offline. If N = 105, then:1. For each i such that , collect queries (like struct) in a vector of queries query[i], then run dfs on the C-Tree and using a partial sum answer to all queries with k = i. There are at most of these numbers, so it can be done in . After doing these, erase i from all q[1], q[1], ..., q[N].Code (in dfs) would be like this(on C-Tree): partial_sum[n] = {}; // all 0\ndfs(v, i){\n\tcnt = 0;\n\tfor x in q[v]\n\t\tif(x == i)\n\t\t++ cnt;\n\tfor u in childern[v]\n\t\tcnt += dfs(u);\n\tfor x in end[v]\n\t\tpartial_sum[x] += cnt;\n\treturn cnt;\n}\ncalc(i){\n\tdfs(root, i);\n\tfor i = 2 to n\n\t\tpartial_sum[i] += partial_sum[i-1]\n\tfor query u in query[i]\n\t\tu.ans = partial_sum[u.r] - partial_sum[u.l - 1]\n}And we should just run calc(i) for each of them.2. For each i such that , collect queries (like struct) in a vector of queries query[i]. (each element of this vector have three integers in it: l, r and ans).Consider this problem:We have an array a of length N(initially all element equal to 0) and some queries of two types: increase(i, val): increase a[i] by val sum(i): tell the value of a[1] + a[2] + ... + a[i] We know that number of queries of the first type is and from the second type is . Using Sqrt decomposition, we can solve this problem in : K = sqrt(N)\ntot[K] = {}, a[N] = {} // this code is 0-based\nincrease(i, val)\n\twhile i < N and i % K > 0\n\t\ta[i ++] += val\n\twhile i < K\n\t\ttot[i/K] += val\n\t\ti += K\nsum(i)\n\treturn a[i] + tot[i/K]Back to our problem now.Then, just run dfs once on this C-Tree and act like this: dfs(vertex v):\n\tfor i in end[v]\n\t\tincrease(i, 1)\n\tfor i in q[v]\n\t\tfor query u in query[i]\n\t\t\tu.ans += sum(u.r) - sum(u.l - 1)\n\tfor u in children[v]\n\t\tdfs(u)\n\tfor i in end[v]\n\t\tincrease(i, -1)Then answer to a query q is q.ans.Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20971",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10107
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #326 - Codeforces - Code 1",
          "code": "00:30 start time (local time)\n+  0:10 expected delay\n+  2:30 contest\n+  0:30 system test\n+  0:30 rating changes\n= 04:10 sleep time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 - Codeforces - Code 2",
          "code": "00:30 start time (local time)\n+  0:10 expected delay\n+  2:30 contest\n+  0:30 system test\n+  0:30 rating changes\n= 04:10 sleep time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 - Codeforces - Code 3",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 - Codeforces - Code 4",
          "code": "#just_grandmaster_things",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 1",
          "code": "ans = 0\nprice = infinity\nfor i = 1 to n\n      price = min(price, p[i])\n      ans += price * a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 2",
          "code": "ans = 0\nprice = infinity\nfor i = 1 to n\n      price = min(price, p[i])\n      ans += price * a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 3",
          "code": "MAXN = 1000000 + log(1000000)\nbit[0..MAXN] = {} // all equal to zero\nans = 0\nfor i = 1 to n\n      bit[w[i]] ++ // of course after this, some bits maybe greater than 1, we'll fix them below\nfor i = 0 to MAXN - 1\n      bit[i + 1] += bit[i]/2 // floor(bit[i]/2)\n      bit[i] %= 2 // bit[i] = bit[i] modulo 2\n      ans += bit[i] // if bit[i] = 0, then answer doesn't change, otherwise it'll increase by 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 4",
          "code": "MAXN = 1000000 + log(1000000)\nbit[0..MAXN] = {} // all equal to zero\nans = 0\nfor i = 1 to n\n      bit[w[i]] ++ // of course after this, some bits maybe greater than 1, we'll fix them below\nfor i = 0 to MAXN - 1\n      bit[i + 1] += bit[i]/2 // floor(bit[i]/2)\n      bit[i] %= 2 // bit[i] = bit[i] modulo 2\n      ans += bit[i] // if bit[i] = 0, then answer doesn't change, otherwise it'll increase by 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 5",
          "code": "for i = 0 to n-1\n      dp[i][1] = 1\nfor j = 2 to k\n      pointer = 0\n      sum = 0\n      for i = 0 to n-1\n            while pointer < n and a[p[pointer]] <= a[i]\n                  sum = (sum + dp[p[pointer ++]][j - 1]) % MOD\n            dp[i][j] = sum",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 6",
          "code": "for i = 0 to n-1\n      dp[i][1] = 1\nfor j = 2 to k\n      pointer = 0\n      sum = 0\n      for i = 0 to n-1\n            while pointer < n and a[p[pointer]] <= a[i]\n                  sum = (sum + dp[p[pointer ++]][j - 1]) % MOD\n            dp[i][j] = sum",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 7",
          "code": "insert(x, v)\n\tfor a in v\n\t\tif a & -a & x\n\t\t\tx ^= a\n\tif !x\n\t\treturn\n\tfor a in v\n\t\tif x & -x & a\n\t\t\ta ^= x\n\tv.push(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 8",
          "code": "insert(x, v)\n\tfor a in v\n\t\tif a & -a & x\n\t\t\tx ^= a\n\tif !x\n\t\treturn\n\tfor a in v\n\t\tif x & -x & a\n\t\t\ta ^= x\n\tv.push(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 9",
          "code": "cur = root\nfor c in s[i]\n\tcur = g(cur, c)\n\tAnd then push i in q[cur] (q is a vector, also we do this for cur = root).\n\nend[cur].push(i) \t// end is also a vector, consisting of the indices of strings ending in vertex cur (state cur in automaton)\nlast[i] = cur // last[i] is the final state we get to from searching string s[i] in automaton g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 10",
          "code": "cur = root\nfor c in s[i]\n\tcur = g(cur, c)\n\tAnd then push i in q[cur] (q is a vector, also we do this for cur = root).\n\nend[cur].push(i) \t// end is also a vector, consisting of the indices of strings ending in vertex cur (state cur in automaton)\nlast[i] = cur // last[i] is the final state we get to from searching string s[i] in automaton g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 11",
          "code": "partial_sum[n] = {}; // all 0\ndfs(v, i){\n\tcnt = 0;\n\tfor x in q[v]\n\t\tif(x == i)\n\t\t++ cnt;\n\tfor u in childern[v]\n\t\tcnt += dfs(u);\n\tfor x in end[v]\n\t\tpartial_sum[x] += cnt;\n\treturn cnt;\n}\ncalc(i){\n\tdfs(root, i);\n\tfor i = 2 to n\n\t\tpartial_sum[i] += partial_sum[i-1]\n\tfor query u in query[i]\n\t\tu.ans = partial_sum[u.r] - partial_sum[u.l - 1]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 12",
          "code": "partial_sum[n] = {}; // all 0\ndfs(v, i){\n\tcnt = 0;\n\tfor x in q[v]\n\t\tif(x == i)\n\t\t++ cnt;\n\tfor u in childern[v]\n\t\tcnt += dfs(u);\n\tfor x in end[v]\n\t\tpartial_sum[x] += cnt;\n\treturn cnt;\n}\ncalc(i){\n\tdfs(root, i);\n\tfor i = 2 to n\n\t\tpartial_sum[i] += partial_sum[i-1]\n\tfor query u in query[i]\n\t\tu.ans = partial_sum[u.r] - partial_sum[u.l - 1]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 13",
          "code": "K = sqrt(N)\ntot[K] = {}, a[N] = {} // this code is 0-based\nincrease(i, val)\n\twhile i < N and i % K > 0\n\t\ta[i ++] += val\n\twhile i < K\n\t\ttot[i/K] += val\n\t\ti += K\nsum(i)\n\treturn a[i] + tot[i/K]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 14",
          "code": "K = sqrt(N)\ntot[K] = {}, a[N] = {} // this code is 0-based\nincrease(i, val)\n\twhile i < N and i % K > 0\n\t\ta[i ++] += val\n\twhile i < K\n\t\ttot[i/K] += val\n\t\ti += K\nsum(i)\n\treturn a[i] + tot[i/K]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 15",
          "code": "dfs(vertex v):\n\tfor i in end[v]\n\t\tincrease(i, 1)\n\tfor i in q[v]\n\t\tfor query u in query[i]\n\t\t\tu.ans += sum(u.r) - sum(u.l - 1)\n\tfor u in children[v]\n\t\tdfs(u)\n\tfor i in end[v]\n\t\tincrease(i, -1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 16",
          "code": "dfs(vertex v):\n\tfor i in end[v]\n\t\tincrease(i, 1)\n\tfor i in q[v]\n\t\tfor query u in query[i]\n\t\t\tu.ans += sum(u.r) - sum(u.l - 1)\n\tfor u in children[v]\n\t\tdfs(u)\n\tfor i in end[v]\n\t\tincrease(i, -1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 17",
          "code": "3 12 2\n5 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 18",
          "code": "3 12 2\n5 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 19",
          "code": "5 9 1  5 9 1  5 9 1   5 9 1  --> b\n1 2 3  4 5 6  7 8 9  10 11 12 --> positions\n\nlength 1 subsequence 12\nlength 2: \n1-4,1-5,1-7,1-8,1-10,1-11,2-5,2-8,2-11,3-4,3-5,3-6,3-7,3-8,3-9,3-10,3-11,3-12,\n4-7,4-8,4-10,4-11,5-8,5-11,6-7,6-8,6-9,6-10,6-11,6-12\n7-10,7-11,8-11,9-10,9-11,9-12\n\ntotal 36+12 = 48",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 20",
          "code": "5 9 1  5 9 1  5 9 1   5 9 1  --> b\n1 2 3  4 5 6  7 8 9  10 11 12 --> positions\n\nlength 1 subsequence 12\nlength 2: \n1-4,1-5,1-7,1-8,1-10,1-11,2-5,2-8,2-11,3-4,3-5,3-6,3-7,3-8,3-9,3-10,3-11,3-12,\n4-7,4-8,4-10,4-11,5-8,5-11,6-7,6-8,6-9,6-10,6-11,6-12\n7-10,7-11,8-11,9-10,9-11,9-12\n\ntotal 36+12 = 48",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 50000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readSpace();\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        ensuref(vi != ui, \"Edge %d has the same endpoints: vi = ui = %d\", i + 1, vi);\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readSpace();\n        int ti = inf.readInt(1, 1000000000, \"ti\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 50000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readSpace();\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        ensuref(vi != ui, \"Edge %d has the same endpoints: vi = ui = %d\", i + 1, vi);\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readSpace();\n        int ti = inf.readInt(1, 1000000000, \"ti\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 50000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readSpace();\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        ensuref(vi != ui, \"Edge %d has the same endpoints: vi = ui = %d\", i + 1, vi);\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readSpace();\n        int ti = inf.readInt(1, 1000000000, \"ti\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read the input data\n    int n = inf.readInt();\n    int m = inf.readInt();\n    vector<tuple<int, int, int, int>> edges(m + 1); // edges[1..m], store (u, v, c, t)\n    for (int i = 1; i <= m; ++i) {\n        int vi = inf.readInt();\n        int ui = inf.readInt();\n        int ci = inf.readInt();\n        int ti = inf.readInt();\n        edges[i] = make_tuple(vi, ui, ci, ti);\n    }\n\n    // Read the jury's answer\n    string juryVerdict = ans.readToken();\n    if (juryVerdict != \"Yes\" && juryVerdict != \"No\") {\n        ans.quitf(_fail, \"Jury's answer is neither 'Yes' nor 'No'\");\n    }\n\n    // Read the contestant's answer\n    string contVerdict = ouf.readToken();\n    if (contVerdict != \"Yes\" && contVerdict != \"No\") {\n        quitf(_wa, \"Contestant's answer is neither 'Yes' nor 'No'\");\n    }\n\n    // If jury says 'No'\n    if (juryVerdict == \"No\") {\n        if (contVerdict == \"No\") {\n            // Both say 'No' - accept\n            quitf(_ok, \"Both say 'No'\");\n        } else { // jury says 'No' but contestant says 'Yes'\n            quitf(_wa, \"Contestant claims solution exists but jury says there is none\");\n        }\n    } else { // jury says 'Yes'\n        if (contVerdict == \"No\") {\n            quitf(_wa, \"Contestant failed to find a solution when one exists\");\n        } else { // Both say 'Yes'\n            // Read jury's t and k\n            int jury_t = ans.readInt();\n            int jury_k = ans.readInt();\n            vector<int> jury_destroys = ans.readInts(jury_k, 1, m);\n            // Read contestant's t and k\n            int cont_t = ouf.readInt(0, 1000000000, \"t\");\n            int cont_k = ouf.readInt(0, m, \"k\"); // matching can be empty\n            vector<int> cont_destroys = ouf.readInts(cont_k, 1, m, \"destroyed roads indices\");\n            set<int> cont_destroys_set(cont_destroys.begin(), cont_destroys.end());\n            if ((int)cont_destroys_set.size() != cont_k) {\n                quitf(_wa, \"Duplicate road indices in the destroyed roads\");\n            }\n            // Check that cont_t is correct\n            // Compute the maximum ti among destroyed roads\n            int max_ti = 0;\n            for (int idx : cont_destroys) {\n                int ti = get<3>(edges[idx]);\n                if (ti > max_ti)\n                    max_ti = ti;\n            }\n            if (cont_t != max_ti) {\n                quitf(_wa, \"Contestant's t (%d) does not match maximum ti among destroyed roads (%d)\", cont_t, max_ti);\n            }\n            if (cont_t > jury_t) {\n                quitf(_wa, \"Contestant's destruction time (%d) is worse than minimal (%d)\", cont_t, jury_t);\n            } else if (cont_t < jury_t) {\n                quitf(_fail, \"Contestant's destruction time (%d) is better than jury's minimal (%d)\", cont_t, jury_t);\n            } else { // cont_t == jury_t\n                // Now need to validate contestant's matching\n                // Check destroyed roads form a matching\n                vector<bool> used_vertex(n + 1, false); // vertices 1..n\n                for (int idx : cont_destroys) {\n                    int vi = get<0>(edges[idx]);\n                    int ui = get<1>(edges[idx]);\n\n                    if (used_vertex[vi]) {\n                        quitf(_wa, \"Vertex %d appears in multiple destroyed roads\", vi);\n                    }\n                    if (used_vertex[ui]) {\n                        quitf(_wa, \"Vertex %d appears in multiple destroyed roads\", ui);\n                    }\n                    used_vertex[vi] = used_vertex[ui] = true;\n                }\n                // Build adjacency list of remaining edges\n                map<pair<int, int>, int> rem_edges; // Map edge (u,v) to color c\n                for (int i = 1; i <= m; ++i) {\n                    if (cont_destroys_set.count(i))\n                        continue; // destroyed edge\n                    int vi = get<0>(edges[i]);\n                    int ui = get<1>(edges[i]);\n                    int ci = get<2>(edges[i]);\n                    pair<int, int> edge = make_pair(min(vi, ui), max(vi, ui));\n                    rem_edges[edge] = ci;\n                }\n                // For each color, check that the edges form a matching\n                map<int, vector<pair<int, int>>> color_edges; // ci -> list of edges (u,v)\n                for (auto& edge_pair : rem_edges) {\n                    int ci = edge_pair.second;\n                    int u = edge_pair.first.first;\n                    int v = edge_pair.first.second;\n                    color_edges[ci].push_back(make_pair(u, v));\n                }\n                // Now for each color, check that the edges form a matching\n                for (auto& color_pair : color_edges) {\n                    int color = color_pair.first;\n                    vector<pair<int, int>>& edges_list = color_pair.second;\n                    vector<bool> used_in_color(n + 1, false);\n                    for (auto& e : edges_list) {\n                        int u = e.first;\n                        int v = e.second;\n                        if (used_in_color[u]) {\n                            quitf(_wa, \"Vertex %d occurs in multiple edges of color %d in remaining graph\", u, color);\n                        }\n                        if (used_in_color[v]) {\n                            quitf(_wa, \"Vertex %d occurs in multiple edges of color %d in remaining graph\", v, color);\n                        }\n                        used_in_color[u] = used_in_color[v] = true;\n                    }\n                }\n                // All checks passed\n                quitf(_ok, \"Correct solution with t = %d\", cont_t);\n            }\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // number of cities\n    int m = opt<int>(\"m\"); // number of roads\n    string type = opt<string>(\"type\", \"possible\"); // \"possible\" or \"impossible\"\n    int maxc = opt<int>(\"maxc\", n); // maximum color value\n    int maxt = opt<int>(\"maxt\", 1e9); // maximum ti value\n    int minc = opt<int>(\"minc\", 1); // minimum color value\n    int mint = opt<int>(\"mint\", 1); // minimum ti value\n\n    // Edge list: each edge is (u, v, c, t)\n    vector< tuple<int,int,int,int> > edges;\n\n    if (type == \"possible\") {\n        // Generate a graph where condition 1 can be satisfied\n\n        // First, let's generate a random connected graph\n        // Build a tree\n        vector<int> perm(n);\n        for(int i = 0; i < n; ++i)\n            perm[i] = i + 1;\n        shuffle(perm.begin(), perm.end());\n\n        vector< pair<int,int> > tree_edges;\n        for(int i = 1; i < n; ++i) {\n            int u = perm[rnd.next(i)];\n            int v = perm[i];\n            tree_edges.push_back({u, v});\n        }\n\n        // Now, we have n-1 edges, we need to add m - (n-1) more edges\n        int extra_edges = m - (n - 1);\n        set< pair<int,int> > used_edges;\n        for(auto e : tree_edges) {\n            used_edges.insert({min(e.first,e.second), max(e.first,e.second)});\n        }\n\n        for(int i = 0; i < extra_edges; ++i) {\n            int u, v;\n            do {\n                u = rnd.next(1, n);\n                v = rnd.next(1, n);\n            } while(u == v || used_edges.count({min(u,v), max(u,v)}));\n            used_edges.insert({min(u,v), max(u,v)});\n            tree_edges.push_back({u, v});\n        }\n\n        // Now, assign colors and ti values\n        for(auto e : tree_edges) {\n            int u = e.first;\n            int v = e.second;\n            int c = rnd.next(minc, maxc);\n            int t = rnd.next(mint, maxt);\n            edges.emplace_back(u, v, c, t);\n        }\n\n    } else if (type == \"impossible\") {\n        // Generate a test case where it's impossible to satisfy the first condition\n\n        // Create an odd-length cycle of edges all of the same color\n\n        int cycle_length = min(n, m);\n        if(cycle_length % 2 == 0) cycle_length -= 1; // ensure odd length\n        if(cycle_length < 3) cycle_length = 3; // minimum cycle length\n\n        // Build the cycle\n        for(int i = 1; i <= cycle_length; ++i) {\n            int u = i;\n            int v = i % cycle_length + 1; // next vertex\n            int c = minc; // same color\n            int t = rnd.next(mint, maxt);\n            edges.emplace_back(u, v, c, t);\n        }\n\n        // Add extra edges to reach m edges\n        int extra_edges = m - ((cycle_length) + 0); // edges added so far\n        set< pair<int,int> > used_edges;\n        for(auto e : edges) {\n            int u = get<0>(e);\n            int v = get<1>(e);\n            used_edges.insert({min(u,v), max(u,v)});\n        }\n        for(int i = 0; i < extra_edges; ++i) {\n            int u, v;\n            do {\n                u = rnd.next(1, n);\n                v = rnd.next(1, n);\n            } while(u == v || used_edges.count({min(u,v), max(u,v)}));\n            used_edges.insert({min(u,v), max(u,v)});\n            int c = rnd.next(minc, maxc);\n            int t = rnd.next(mint, maxt);\n            edges.emplace_back(u, v, c, t);\n        }\n    } else {\n        // default to 'possible'\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output edges\n    for(size_t i = 0; i < edges.size(); ++i) {\n        int u, v, c, t;\n        tie(u, v, c, t) = edges[i];\n        printf(\"%d %d %d %d\\n\", u, v, c, t);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // number of cities\n    int m = opt<int>(\"m\"); // number of roads\n    string type = opt<string>(\"type\", \"possible\"); // \"possible\" or \"impossible\"\n    int maxc = opt<int>(\"maxc\", n); // maximum color value\n    int maxt = opt<int>(\"maxt\", 1e9); // maximum ti value\n    int minc = opt<int>(\"minc\", 1); // minimum color value\n    int mint = opt<int>(\"mint\", 1); // minimum ti value\n\n    // Edge list: each edge is (u, v, c, t)\n    vector< tuple<int,int,int,int> > edges;\n\n    if (type == \"possible\") {\n        // Generate a graph where condition 1 can be satisfied\n\n        // First, let's generate a random connected graph\n        // Build a tree\n        vector<int> perm(n);\n        for(int i = 0; i < n; ++i)\n            perm[i] = i + 1;\n        shuffle(perm.begin(), perm.end());\n\n        vector< pair<int,int> > tree_edges;\n        for(int i = 1; i < n; ++i) {\n            int u = perm[rnd.next(i)];\n            int v = perm[i];\n            tree_edges.push_back({u, v});\n        }\n\n        // Now, we have n-1 edges, we need to add m - (n-1) more edges\n        int extra_edges = m - (n - 1);\n        set< pair<int,int> > used_edges;\n        for(auto e : tree_edges) {\n            used_edges.insert({min(e.first,e.second), max(e.first,e.second)});\n        }\n\n        for(int i = 0; i < extra_edges; ++i) {\n            int u, v;\n            do {\n                u = rnd.next(1, n);\n                v = rnd.next(1, n);\n            } while(u == v || used_edges.count({min(u,v), max(u,v)}));\n            used_edges.insert({min(u,v), max(u,v)});\n            tree_edges.push_back({u, v});\n        }\n\n        // Now, assign colors and ti values\n        for(auto e : tree_edges) {\n            int u = e.first;\n            int v = e.second;\n            int c = rnd.next(minc, maxc);\n            int t = rnd.next(mint, maxt);\n            edges.emplace_back(u, v, c, t);\n        }\n\n    } else if (type == \"impossible\") {\n        // Generate a test case where it's impossible to satisfy the first condition\n\n        // Create an odd-length cycle of edges all of the same color\n\n        int cycle_length = min(n, m);\n        if(cycle_length % 2 == 0) cycle_length -= 1; // ensure odd length\n        if(cycle_length < 3) cycle_length = 3; // minimum cycle length\n\n        // Build the cycle\n        for(int i = 1; i <= cycle_length; ++i) {\n            int u = i;\n            int v = i % cycle_length + 1; // next vertex\n            int c = minc; // same color\n            int t = rnd.next(mint, maxt);\n            edges.emplace_back(u, v, c, t);\n        }\n\n        // Add extra edges to reach m edges\n        int extra_edges = m - ((cycle_length) + 0); // edges added so far\n        set< pair<int,int> > used_edges;\n        for(auto e : edges) {\n            int u = get<0>(e);\n            int v = get<1>(e);\n            used_edges.insert({min(u,v), max(u,v)});\n        }\n        for(int i = 0; i < extra_edges; ++i) {\n            int u, v;\n            do {\n                u = rnd.next(1, n);\n                v = rnd.next(1, n);\n            } while(u == v || used_edges.count({min(u,v), max(u,v)}));\n            used_edges.insert({min(u,v), max(u,v)});\n            int c = rnd.next(minc, maxc);\n            int t = rnd.next(mint, maxt);\n            edges.emplace_back(u, v, c, t);\n        }\n    } else {\n        // default to 'possible'\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output edges\n    for(size_t i = 0; i < edges.size(); ++i) {\n        int u, v, c, t;\n        tie(u, v, c, t) = edges[i];\n        printf(\"%d %d %d %d\\n\", u, v, c, t);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 7 -type possible\n./gen -n 5 -m 7 -type impossible\n\n./gen -n 100 -m 200 -type possible\n./gen -n 100 -m 200 -type impossible\n\n./gen -n 1000 -m 5000 -type possible\n./gen -n 1000 -m 5000 -type impossible\n\n./gen -n 10000 -m 50000 -type possible\n./gen -n 10000 -m 50000 -type impossible\n\n./gen -n 50000 -m 50000 -type possible\n./gen -n 50000 -m 50000 -type impossible\n\n# Tests with varying minc and maxc\n./gen -n 1000 -m 2000 -type possible -minc 1 -maxc 10\n./gen -n 1000 -m 2000 -type possible -minc 1 -maxc 2\n./gen -n 1000 -m 2000 -type possible -minc 5 -maxc 5\n./gen -n 1000 -m 2000 -type impossible -minc 1 -maxc 1\n\n# Tests with varying mint and maxt\n./gen -n 1000 -m 2000 -type possible -mint 1 -maxt 1000\n./gen -n 1000 -m 2000 -type possible -mint 1000 -maxt 1000\n./gen -n 1000 -m 2000 -type possible -mint 1 -maxt 1\n./gen -n 1000 -m 2000 -type impossible -mint 1 -maxt 1\n\n# Edge cases\n./gen -n 2 -m 1 -type possible\n./gen -n 2 -m 1 -type impossible\n\n./gen -n 3 -m 3 -type possible\n./gen -n 3 -m 3 -type impossible\n\n# Max values\n./gen -n 50000 -m 50000 -type possible -mint 1 -maxt 1000000000 -minc 1 -maxc 1000000000\n\n# Additional varying n and m\n./gen -n 10000 -m 30000 -type possible\n./gen -n 10000 -m 30000 -type impossible\n\n# Tests with low m\n./gen -n 5000 -m 5000 -type possible\n./gen -n 5000 -m 5000 -type impossible\n\n# Tests with high m\n./gen -n 5000 -m 25000 -type possible\n./gen -n 5000 -m 25000 -type impossible\n\n# Tests with higher colors\n./gen -n 1000 -m 5000 -type possible -minc 1 -maxc 100\n./gen -n 1000 -m 5000 -type impossible -minc 1 -maxc 100\n\n# Tests with only one color\n./gen -n 1000 -m 2000 -type possible -minc 1 -maxc 1\n./gen -n 1000 -m 2000 -type impossible -minc 1 -maxc 1\n\n# Tests with varied ti\n./gen -n 1000 -m 2000 -type possible -mint 1 -maxt 1000000\n./gen -n 1000 -m 2000 -type impossible -mint 1 -maxt 1000000\n\n# Tests where ti is the same\n./gen -n 1000 -m 2000 -type possible -mint 1000 -maxt 1000\n./gen -n 1000 -m 2000 -type impossible -mint 1000 -maxt 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:53:58.451920",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "587/E",
      "title": "E. Duff as a Queen",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test7 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two integers, n and q (1 ≤ n ≤ 2 × 105 and 1 ≤ q ≤ 4 × 104).The second line of input contains n integers, a1, a2, ..., an separated by spaces (0 ≤ ai ≤ 109 for each 1 ≤ i ≤ n).The next q lines contain the queries. Each line starts with an integer t (1 ≤ t ≤ 2), type of the corresponding query. If t = 1, then there are three more integers in that line, l, r and k. Otherwise there are two more integers, l and r. (1 ≤ l ≤ r ≤ n and 0 ≤ k ≤ 109)",
      "output_spec": "OutputPrint the answer of each query of the second type in one line.",
      "sample_tests": "ExamplesInputCopy5 51 2 3 4 22 1 51 2 2 82 1 51 1 3 102 2 2OutputCopy8161",
      "description": "E. Duff as a Queen\n\ntime limit per test7 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains two integers, n and q (1 ≤ n ≤ 2 × 105 and 1 ≤ q ≤ 4 × 104).The second line of input contains n integers, a1, a2, ..., an separated by spaces (0 ≤ ai ≤ 109 for each 1 ≤ i ≤ n).The next q lines contain the queries. Each line starts with an integer t (1 ≤ t ≤ 2), type of the corresponding query. If t = 1, then there are three more integers in that line, l, r and k. Otherwise there are two more integers, l and r. (1 ≤ l ≤ r ≤ n and 0 ≤ k ≤ 109)\n\nOutputPrint the answer of each query of the second type in one line.\n\nInputCopy5 51 2 3 4 22 1 51 2 2 82 1 51 1 3 102 2 2OutputCopy8161\n\nInputCopy5 51 2 3 4 22 1 51 2 2 82 1 51 1 3 102 2 2\n\nOutputCopy8161\n\nNoteIn the first query, we want all Kheshtaks of sequence 1, 2, 3, 4, 2 which are: 0, 1, 2, 3, 4, 5, 6, 7.In the third query, we want all Khestaks of sequence 1, 10, 3, 4, 2 which are: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15.In the fifth query, we want all Kheshtaks of sequence 0 which is 0.",
      "solutions": [
        {
          "title": "Codeforces Round #326 - Codeforces",
          "content": "Hello Codeforces.I'm honored to announce you, that Codeforces round #326 is gonna take place soon on Codeforces.Writers are AmirMohammad Dehghan(PrinceOfPersia) and Ali Haghani(Haghani). There will be 6 problems in each division(4 problems are common) and you'll have 2 and a half hour to solve them. I hope you enjoy the problems.I wanna thank Maxim Akhmedov(Zlobober) for his great helps in preparing this round, MikeMirzayanov for wonderful platforms of Codeforce and Polygon, Delinur for translating problem statements into Russian and MohammadReza Maleki(mruxim) and Ali Bahjati(LiTi) for their great advices (and LiTi again for some graphics).This is my third round on Codeforces and not the last one, I hope.This is the last round on Codeforces with Zlobober as coordinator. It was nice working with him. We had a lot of fun and interesting contests during his coordination. I just wanna say: Thank you Maxim for all your contribution to CodeForces community and good luck in the future. After I heard these news, my first guess for the next coordinator was I_love_Tanya_Romanova; But I don't know if CodeForces hires people from out of Russia or not.The main character of this round is Duff, but you'll also have to help her friend, Malek!I wish you all high ratings and lots of joy.Scoring will be posted soon.GL & HF!Problems are sorted by the expected difficulty, but we strictly recommend you to read all the problems.UPD: Scoring is: 750-1000-1500-2000-2500-3000 in Div.2 and 500-1000-1500-2000-2750-2750 in Div.1 .UPD1: Editorial is published.UPD2: System test is over. Congratulations to all winners.Div.1 Winners are: qwer1561 Endagorion jcvb subscriber wjh720 Div.2 Winners are: sleepy_mario BIT-silence Owaski Orenji.Sora JavaInTheSouth Also congratulations to JoeyWheeler, the only one who solved problem Div.1 D.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20913",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1832
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces",
          "content": "Div.2 A (Author: Haghani)Idea is a simple greedy, buy needed meat for i - th day when it's cheapest among days 1, 2, ..., n.So, the pseudo code below will work: ans = 0\nprice = infinity\nfor i = 1 to n\n price = min(price, p[i])\n ans += price * a[i]Time complexity: C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by ZloboberDiv.2 B (Author: PrinceOfPersia)Find all prime divisors of n. Assume they are p1, p2, ..., pk (in ). If answer is a, then we know that for each 1 ≤ i ≤ k, obviously a is not divisible by pi2 (and all greater powers of pi). So a ≤ p1 × p2 × ... × pk. And we know that p1 × p2 × ... × pk is itself lovely. So,answer is p1 × p2 × ... × pkTime complexity: C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by ZloboberA (Author: PrinceOfPersia)Problem is: you have to find the minimum number of k, such there is a sequence a1, a2, ..., ak with condition 2a1 + 2a2 + ... + 2ak = S = 2w1 + 2w2 + ... + 2w2. Obviously, minimum value of k is the number of set bits in binary representation of S (proof is easy, you can prove it as a practice :P).Our only problem is how to count the number of set bits in binary representation of S? Building the binary representation of S as an array in is easy: MAXN = 1000000 + log(1000000)\nbit[0..MAXN] = {} // all equal to zero\nans = 0\nfor i = 1 to n\n bit[w[i]] ++ // of course after this, some bits maybe greater than 1, we'll fix them below\nfor i = 0 to MAXN - 1\n bit[i + 1] += bit[i]/2 // floor(bit[i]/2)\n bit[i] %= 2 // bit[i] = bit[i] modulo 2\n ans += bit[i] // if bit[i] = 0, then answer doesn't change, otherwise it'll increase by 1Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniB (Author: PrinceOfPersia)If we fix x and bix mod n, then problem will be solved (because we can then multiply it by the number of valid distinct values of ).For the problem above, let dp[i][j] be the number of valid subsequences of b where x = j and and . Of course, for every i, dp[i][1] = 1. For calculating value of dp[i][j]:For this purpose, we can sort the array a and use two pointer:if p0, p1, ...pn - 1 is a permutation of 0, ..., n - 1 where for each 0 ≤ t < n - 1, apt ≤ apt + 1: for i = 0 to n-1\n dp[i][1] = 1\nfor j = 2 to k\n pointer = 0\n sum = 0\n for i = 0 to n-1\n while pointer < n and a[p[pointer]] <= a[i]\n sum = (sum + dp[p[pointer ++]][j - 1]) % MOD\n dp[i][j] = sumNow, if and x = l - 1 mod n, then answer equals to (there are c - j + 1 valid different values of for the first group and c - j for the second group).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberC (Author: PrinceOfPersia)Solution is something like the fourth LCA approach discussed here.For each 1 ≤ i ≤ n and 0 ≤ j ≤ lg(n), store the minimum 10 people in the path from city (vertex) i to its 2j - th parent in an array.Now everything is needed is: how to merge the array of two paths? You can keep the these 10 values in the array in increasing order and for merging, use merge function which will work in . And then delete the extra values (more than 10).And do the same as described in the article for a query (just like the preprocess part).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberD (Author: PrinceOfPersia)Run binary search on the answer (t). For checking if answer is less than or equal to x (check(x)):First of all delete all edges with destructing time greater than x. Now, if there is more than one pair of edges with the same color connected to a vertex(because we can delete at most one of them), answer is \"No\".Use 2-Sat. Consider a literal for each edge e (xe). If xe = TRUE, it means it should be destructed and it shouldn't otherwise. There are some conditions: For each vertex v, if there is one (exactly one) pair of edges like i and j with the same color connected to v, then we should have the clause . For each vertex v, if the edges connected to it are e1, e2, ..., ek, we should make sure that there is no pair (i, j) where 1 ≤ i < j ≤ k and xe1 = xe2 = True. The naive approach is to add a clause for each pair. But it's not efficient. The efficient way tho satisfy the second condition is to use prefix or: adding k new literals p1, p2, ..., pk and for each j ≤ i, make sure . To make sure about this, we can add two clauses for each pi: and (the second one is only for i > 1).And the only thing left is to make sure (there are no two TRUE edges).This way the number of literals and clauses are . So, after binary search is over, we should run check(t) to get a sample matching.Time complexity: (but slow, because of the constant factor)C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberE (Authors: PrinceOfPersia and Haghani)Lemma #1: If numbers b1, b2, ..., bk are k Kheshtaks of a1, ..., an, then is a Kheshtak of a1, ..., an.Proof: For each 1 ≤ i ≤ k, consider maski is a binary bitmask of length n and its j - th bit shows a subsequence of a1, ..., an (subset) with xor equal to bi.So, xor of elements subsequence(subset) of a1, ..., an with bitmask equal to equals to . So, it's a Kheshtak of this sequence.From this lemma, we can get another results: If all numbers b1, b2, ..., bk are k Kheshtaks of a1, ..., an, then every Kheshtak of b1, b2, ..., bk is a Kheshtak of a1, ..., anLemma #2: Score of sequence a1, a2, ..., an is equal to the score of sequence .Proof: If we show the second sequence by b1, b2, ..., bn, then for each 1 ≤ i ≤ n: bi = ai = each element from sequence b is a Kheshtak of sequence a and vise versa. So, due to the result of Lemma #1, each Kheshtak of sequence b is a Kheshtak of sequence a and vise versa. So: score(b1, ..., bn) ≤ score(a1, ..., an) score(a1, ..., an) ≤ score(b1, ..., bn) score(a1, ..., an) = score(b1, ..., bn)Back to original problem: denote another array b2, ..., bn where . Let's solve these two problems:1- We have array a1, ..., an and q queries of two types: upd(l, r, k): Given numbers l, r and k, for each l ≤ i ≤ r, perform ask(i):  Given number i, return the value of ai. This problem can be solved easily with a simple segment tree using lazy propagation.2- We have array b2, ..., bn and queries of two types: modify(p, k): Perform bp = k. basis(l, r): Find and return the basis vector of bl, bl + 1, ..., br (using Gaussian Elimination, its size it at most 32). This problem can be solved by a segment tree where in each node we have the basis of the substring of that node (node [l, r) has the basis of sequence bl, ..., br - 1).This way we can insert to a basis vector v: insert(x, v)\n\tfor a in v\n\t\tif a & -a & x\n\t\t\tx ^= a\n\tif !x\n\t\treturn\n\tfor a in v\n\t\tif x & -x & a\n\t\t\ta ^= x\n\tv.push(x)But size of v will always be less than or equal to 32. For merging two nodes (of segment tree), we can insert the elements of one in another one.For handling queries of two types, we act like this:Type one: Call functions: upd(l, r, k), and .Type two: Let b = basis(l + 1, r). Call insert(al, b). And then print 2b.size() as the answer.Time complexity: = C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberF (Author: PrinceOfPersia)Use Aho-Corasick. Assume first of all we build the trie of our strings (function t). If t(v, c) ≠  - 1 it means that there is an edge in the trie outgoing from vertex v written c on it.So, for building Aho-Corasick, consider f(v) = the vertex we go into, in case of failure (t(v, c) =  - 1). i.e the deepest vertex (u), that v ≠ u and the path from root to u is a suffix of path from root to v. No we can build an automaton (Aho-Corasick), function g. For each i, do this (in the automaton): cur = root\nfor c in s[i]\n\tcur = g(cur, c)\n\tAnd then push i in q[cur] (q is a vector, also we do this for cur = root).\n\nend[cur].push(i) \t// end is also a vector, consisting of the indices of strings ending in vertex cur (state cur in automaton)\nlast[i] = cur // last[i] is the final state we get to from searching string s[i] in automaton gAssume cnt(v, i) is the number of occurrences of number i in q[v]. Also, denote .Build another tree. In this tree, for each i that is not root of the trie, let par[i] = f(i) (the vertex we go in the trie, in case of failure) and call it C-Tree.So now, problem is on a tree. Operations are : Each query gives numbers l, r, k and you have to find the number .Act offline. If N = 105, then:1. For each i such that , collect queries (like struct) in a vector of queries query[i], then run dfs on the C-Tree and using a partial sum answer to all queries with k = i. There are at most of these numbers, so it can be done in . After doing these, erase i from all q[1], q[1], ..., q[N].Code (in dfs) would be like this(on C-Tree): partial_sum[n] = {}; // all 0\ndfs(v, i){\n\tcnt = 0;\n\tfor x in q[v]\n\t\tif(x == i)\n\t\t++ cnt;\n\tfor u in childern[v]\n\t\tcnt += dfs(u);\n\tfor x in end[v]\n\t\tpartial_sum[x] += cnt;\n\treturn cnt;\n}\ncalc(i){\n\tdfs(root, i);\n\tfor i = 2 to n\n\t\tpartial_sum[i] += partial_sum[i-1]\n\tfor query u in query[i]\n\t\tu.ans = partial_sum[u.r] - partial_sum[u.l - 1]\n}And we should just run calc(i) for each of them.2. For each i such that , collect queries (like struct) in a vector of queries query[i]. (each element of this vector have three integers in it: l, r and ans).Consider this problem:We have an array a of length N(initially all element equal to 0) and some queries of two types: increase(i, val): increase a[i] by val sum(i): tell the value of a[1] + a[2] + ... + a[i] We know that number of queries of the first type is and from the second type is . Using Sqrt decomposition, we can solve this problem in : K = sqrt(N)\ntot[K] = {}, a[N] = {} // this code is 0-based\nincrease(i, val)\n\twhile i < N and i % K > 0\n\t\ta[i ++] += val\n\twhile i < K\n\t\ttot[i/K] += val\n\t\ti += K\nsum(i)\n\treturn a[i] + tot[i/K]Back to our problem now.Then, just run dfs once on this C-Tree and act like this: dfs(vertex v):\n\tfor i in end[v]\n\t\tincrease(i, 1)\n\tfor i in q[v]\n\t\tfor query u in query[i]\n\t\t\tu.ans += sum(u.r) - sum(u.l - 1)\n\tfor u in children[v]\n\t\tdfs(u)\n\tfor i in end[v]\n\t\tincrease(i, -1)Then answer to a query q is q.ans.Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20971",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10107
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #326 - Codeforces - Code 1",
          "code": "00:30 start time (local time)\n+  0:10 expected delay\n+  2:30 contest\n+  0:30 system test\n+  0:30 rating changes\n= 04:10 sleep time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 - Codeforces - Code 2",
          "code": "00:30 start time (local time)\n+  0:10 expected delay\n+  2:30 contest\n+  0:30 system test\n+  0:30 rating changes\n= 04:10 sleep time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 - Codeforces - Code 3",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 - Codeforces - Code 4",
          "code": "#just_grandmaster_things",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 1",
          "code": "ans = 0\nprice = infinity\nfor i = 1 to n\n      price = min(price, p[i])\n      ans += price * a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 2",
          "code": "ans = 0\nprice = infinity\nfor i = 1 to n\n      price = min(price, p[i])\n      ans += price * a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 3",
          "code": "MAXN = 1000000 + log(1000000)\nbit[0..MAXN] = {} // all equal to zero\nans = 0\nfor i = 1 to n\n      bit[w[i]] ++ // of course after this, some bits maybe greater than 1, we'll fix them below\nfor i = 0 to MAXN - 1\n      bit[i + 1] += bit[i]/2 // floor(bit[i]/2)\n      bit[i] %= 2 // bit[i] = bit[i] modulo 2\n      ans += bit[i] // if bit[i] = 0, then answer doesn't change, otherwise it'll increase by 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 4",
          "code": "MAXN = 1000000 + log(1000000)\nbit[0..MAXN] = {} // all equal to zero\nans = 0\nfor i = 1 to n\n      bit[w[i]] ++ // of course after this, some bits maybe greater than 1, we'll fix them below\nfor i = 0 to MAXN - 1\n      bit[i + 1] += bit[i]/2 // floor(bit[i]/2)\n      bit[i] %= 2 // bit[i] = bit[i] modulo 2\n      ans += bit[i] // if bit[i] = 0, then answer doesn't change, otherwise it'll increase by 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 5",
          "code": "for i = 0 to n-1\n      dp[i][1] = 1\nfor j = 2 to k\n      pointer = 0\n      sum = 0\n      for i = 0 to n-1\n            while pointer < n and a[p[pointer]] <= a[i]\n                  sum = (sum + dp[p[pointer ++]][j - 1]) % MOD\n            dp[i][j] = sum",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 6",
          "code": "for i = 0 to n-1\n      dp[i][1] = 1\nfor j = 2 to k\n      pointer = 0\n      sum = 0\n      for i = 0 to n-1\n            while pointer < n and a[p[pointer]] <= a[i]\n                  sum = (sum + dp[p[pointer ++]][j - 1]) % MOD\n            dp[i][j] = sum",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 7",
          "code": "insert(x, v)\n\tfor a in v\n\t\tif a & -a & x\n\t\t\tx ^= a\n\tif !x\n\t\treturn\n\tfor a in v\n\t\tif x & -x & a\n\t\t\ta ^= x\n\tv.push(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 8",
          "code": "insert(x, v)\n\tfor a in v\n\t\tif a & -a & x\n\t\t\tx ^= a\n\tif !x\n\t\treturn\n\tfor a in v\n\t\tif x & -x & a\n\t\t\ta ^= x\n\tv.push(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 9",
          "code": "cur = root\nfor c in s[i]\n\tcur = g(cur, c)\n\tAnd then push i in q[cur] (q is a vector, also we do this for cur = root).\n\nend[cur].push(i) \t// end is also a vector, consisting of the indices of strings ending in vertex cur (state cur in automaton)\nlast[i] = cur // last[i] is the final state we get to from searching string s[i] in automaton g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 10",
          "code": "cur = root\nfor c in s[i]\n\tcur = g(cur, c)\n\tAnd then push i in q[cur] (q is a vector, also we do this for cur = root).\n\nend[cur].push(i) \t// end is also a vector, consisting of the indices of strings ending in vertex cur (state cur in automaton)\nlast[i] = cur // last[i] is the final state we get to from searching string s[i] in automaton g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 11",
          "code": "partial_sum[n] = {}; // all 0\ndfs(v, i){\n\tcnt = 0;\n\tfor x in q[v]\n\t\tif(x == i)\n\t\t++ cnt;\n\tfor u in childern[v]\n\t\tcnt += dfs(u);\n\tfor x in end[v]\n\t\tpartial_sum[x] += cnt;\n\treturn cnt;\n}\ncalc(i){\n\tdfs(root, i);\n\tfor i = 2 to n\n\t\tpartial_sum[i] += partial_sum[i-1]\n\tfor query u in query[i]\n\t\tu.ans = partial_sum[u.r] - partial_sum[u.l - 1]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 12",
          "code": "partial_sum[n] = {}; // all 0\ndfs(v, i){\n\tcnt = 0;\n\tfor x in q[v]\n\t\tif(x == i)\n\t\t++ cnt;\n\tfor u in childern[v]\n\t\tcnt += dfs(u);\n\tfor x in end[v]\n\t\tpartial_sum[x] += cnt;\n\treturn cnt;\n}\ncalc(i){\n\tdfs(root, i);\n\tfor i = 2 to n\n\t\tpartial_sum[i] += partial_sum[i-1]\n\tfor query u in query[i]\n\t\tu.ans = partial_sum[u.r] - partial_sum[u.l - 1]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 13",
          "code": "K = sqrt(N)\ntot[K] = {}, a[N] = {} // this code is 0-based\nincrease(i, val)\n\twhile i < N and i % K > 0\n\t\ta[i ++] += val\n\twhile i < K\n\t\ttot[i/K] += val\n\t\ti += K\nsum(i)\n\treturn a[i] + tot[i/K]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 14",
          "code": "K = sqrt(N)\ntot[K] = {}, a[N] = {} // this code is 0-based\nincrease(i, val)\n\twhile i < N and i % K > 0\n\t\ta[i ++] += val\n\twhile i < K\n\t\ttot[i/K] += val\n\t\ti += K\nsum(i)\n\treturn a[i] + tot[i/K]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 15",
          "code": "dfs(vertex v):\n\tfor i in end[v]\n\t\tincrease(i, 1)\n\tfor i in q[v]\n\t\tfor query u in query[i]\n\t\t\tu.ans += sum(u.r) - sum(u.l - 1)\n\tfor u in children[v]\n\t\tdfs(u)\n\tfor i in end[v]\n\t\tincrease(i, -1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 16",
          "code": "dfs(vertex v):\n\tfor i in end[v]\n\t\tincrease(i, 1)\n\tfor i in q[v]\n\t\tfor query u in query[i]\n\t\t\tu.ans += sum(u.r) - sum(u.l - 1)\n\tfor u in children[v]\n\t\tdfs(u)\n\tfor i in end[v]\n\t\tincrease(i, -1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 17",
          "code": "3 12 2\n5 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 18",
          "code": "3 12 2\n5 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 19",
          "code": "5 9 1  5 9 1  5 9 1   5 9 1  --> b\n1 2 3  4 5 6  7 8 9  10 11 12 --> positions\n\nlength 1 subsequence 12\nlength 2: \n1-4,1-5,1-7,1-8,1-10,1-11,2-5,2-8,2-11,3-4,3-5,3-6,3-7,3-8,3-9,3-10,3-11,3-12,\n4-7,4-8,4-10,4-11,5-8,5-11,6-7,6-8,6-9,6-10,6-11,6-12\n7-10,7-11,8-11,9-10,9-11,9-12\n\ntotal 36+12 = 48",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 20",
          "code": "5 9 1  5 9 1  5 9 1   5 9 1  --> b\n1 2 3  4 5 6  7 8 9  10 11 12 --> positions\n\nlength 1 subsequence 12\nlength 2: \n1-4,1-5,1-7,1-8,1-10,1-11,2-5,2-8,2-11,3-4,3-5,3-6,3-7,3-8,3-9,3-10,3-11,3-12,\n4-7,4-8,4-10,4-11,5-8,5-11,6-7,6-8,6-9,6-10,6-11,6-12\n7-10,7-11,8-11,9-10,9-11,9-12\n\ntotal 36+12 = 48",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and q\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 40000, \"q\");\n    inf.readEoln();\n\n    // Read a_i\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Now read q queries\n    for (int i = 0; i < q; ++i) {\n        int t = inf.readInt(1, 2, \"t\");\n\n        if (t == 1) {\n            inf.readSpace();\n            int l = inf.readInt(1, n, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r\");\n            inf.readSpace();\n            int k = inf.readInt(0, 1000000000, \"k\");\n            inf.readEoln();\n        } else { // t == 2\n            inf.readSpace();\n            int l = inf.readInt(1, n, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r\");\n            inf.readEoln();\n        }\n    }\n\n    // Check for EOF\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and q\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 40000, \"q\");\n    inf.readEoln();\n\n    // Read a_i\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Now read q queries\n    for (int i = 0; i < q; ++i) {\n        int t = inf.readInt(1, 2, \"t\");\n\n        if (t == 1) {\n            inf.readSpace();\n            int l = inf.readInt(1, n, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r\");\n            inf.readSpace();\n            int k = inf.readInt(0, 1000000000, \"k\");\n            inf.readEoln();\n        } else { // t == 2\n            inf.readSpace();\n            int l = inf.readInt(1, n, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r\");\n            inf.readEoln();\n        }\n    }\n\n    // Check for EOF\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and q\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 40000, \"q\");\n    inf.readEoln();\n\n    // Read a_i\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Now read q queries\n    for (int i = 0; i < q; ++i) {\n        int t = inf.readInt(1, 2, \"t\");\n\n        if (t == 1) {\n            inf.readSpace();\n            int l = inf.readInt(1, n, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r\");\n            inf.readSpace();\n            int k = inf.readInt(0, 1000000000, \"k\");\n            inf.readEoln();\n        } else { // t == 2\n            inf.readSpace();\n            int l = inf.readInt(1, n, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r\");\n            inf.readEoln();\n        }\n    }\n\n    // Check for EOF\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    int maxAi = opt<int>(\"maxAi\", 1000000000); // Default is 1e9\n    int maxk = opt<int>(\"maxk\", 1000000000); // Default is 1e9\n    string array_type = opt<string>(\"array_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    vector<int> a(n);\n\n    // Generate the initial array according to array_type\n    if (array_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, maxAi);\n    } else if (array_type == \"zeros\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (array_type == \"ones\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (array_type == \"max\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = maxAi;\n    } else if (array_type == \"increasing\") {\n        int val = 0;\n        for (int i = 0; i < n; ++i)\n            a[i] = val++;\n    } else if (array_type == \"decreasing\") {\n        int val = maxAi;\n        for (int i = 0; i < n; ++i)\n            a[i] = val--;\n    } else if (array_type == \"small\") {\n        int maxSmall = min(maxAi, 10);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, maxSmall);\n    } else if (array_type == \"large\") {\n        int minLarge = max(0, maxAi - 10);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(minLarge, maxAi);\n    } else if (array_type == \"alternating\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? 0 : maxAi;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, maxAi);\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n\n    // Output the array\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    // Generate the queries according to query_type\n    for (int i = 0; i < q; ++i) {\n        int t, l, r, k;\n        if (query_type == \"random\") {\n            t = rnd.next(1, 2);\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n            if (t == 1)\n                k = rnd.next(0, maxk);\n        } else if (query_type == \"allType1\") {\n            t = 1;\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n            k = rnd.next(0, maxk);\n        } else if (query_type == \"allType2\") {\n            t = 2;\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n        } else if (query_type == \"extremes\") {\n            t = rnd.next(1, 2);\n            l = 1;\n            r = n;\n            if (t == 1)\n                k = rnd.next(0, maxk);\n        } else if (query_type == \"single\") {\n            t = rnd.next(1, 2);\n            l = rnd.next(1, n);\n            r = l;\n            if (t == 1)\n                k = rnd.next(0, maxk);\n        } else if (query_type == \"kSmall\") {\n            t = 1;\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n            k = rnd.next(0, min(maxk, 10));\n        } else if (query_type == \"kLarge\") {\n            t = 1;\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n            k = rnd.next(max(0, maxk - 10), maxk);\n        } else {\n            // Default to random\n            t = rnd.next(1, 2);\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n            if (t == 1)\n                k = rnd.next(0, maxk);\n        }\n\n        // Output the query\n        if (t == 1)\n            printf(\"%d %d %d %d\\n\", t, l, r, k);\n        else\n            printf(\"%d %d %d\\n\", t, l, r);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    int maxAi = opt<int>(\"maxAi\", 1000000000); // Default is 1e9\n    int maxk = opt<int>(\"maxk\", 1000000000); // Default is 1e9\n    string array_type = opt<string>(\"array_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    vector<int> a(n);\n\n    // Generate the initial array according to array_type\n    if (array_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, maxAi);\n    } else if (array_type == \"zeros\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (array_type == \"ones\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (array_type == \"max\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = maxAi;\n    } else if (array_type == \"increasing\") {\n        int val = 0;\n        for (int i = 0; i < n; ++i)\n            a[i] = val++;\n    } else if (array_type == \"decreasing\") {\n        int val = maxAi;\n        for (int i = 0; i < n; ++i)\n            a[i] = val--;\n    } else if (array_type == \"small\") {\n        int maxSmall = min(maxAi, 10);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, maxSmall);\n    } else if (array_type == \"large\") {\n        int minLarge = max(0, maxAi - 10);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(minLarge, maxAi);\n    } else if (array_type == \"alternating\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? 0 : maxAi;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, maxAi);\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n\n    // Output the array\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    // Generate the queries according to query_type\n    for (int i = 0; i < q; ++i) {\n        int t, l, r, k;\n        if (query_type == \"random\") {\n            t = rnd.next(1, 2);\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n            if (t == 1)\n                k = rnd.next(0, maxk);\n        } else if (query_type == \"allType1\") {\n            t = 1;\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n            k = rnd.next(0, maxk);\n        } else if (query_type == \"allType2\") {\n            t = 2;\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n        } else if (query_type == \"extremes\") {\n            t = rnd.next(1, 2);\n            l = 1;\n            r = n;\n            if (t == 1)\n                k = rnd.next(0, maxk);\n        } else if (query_type == \"single\") {\n            t = rnd.next(1, 2);\n            l = rnd.next(1, n);\n            r = l;\n            if (t == 1)\n                k = rnd.next(0, maxk);\n        } else if (query_type == \"kSmall\") {\n            t = 1;\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n            k = rnd.next(0, min(maxk, 10));\n        } else if (query_type == \"kLarge\") {\n            t = 1;\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n            k = rnd.next(max(0, maxk - 10), maxk);\n        } else {\n            // Default to random\n            t = rnd.next(1, 2);\n            l = rnd.next(1, n);\n            r = rnd.next(l, n);\n            if (t == 1)\n                k = rnd.next(0, maxk);\n        }\n\n        // Output the query\n        if (t == 1)\n            printf(\"%d %d %d %d\\n\", t, l, r, k);\n        else\n            printf(\"%d %d %d\\n\", t, l, r);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -array_type zeros -query_type allType2\n./gen -n 1 -q 1 -array_type zeros -query_type allType1 -maxk 0\n\n./gen -n 2 -q 2 -array_type ones -query_type single\n\n./gen -n 5 -q 5 -array_type increasing -query_type extremes\n./gen -n 5 -q 5 -array_type decreasing -query_type extremes\n\n./gen -n 10 -q 10 -array_type alternating -query_type random\n\n./gen -n 100 -q 50 -array_type random -query_type random -maxAi 10\n./gen -n 100 -q 50 -array_type small -query_type random\n./gen -n 100 -q 50 -array_type random -query_type kSmall\n./gen -n 100 -q 50 -array_type random -query_type kLarge\n\n./gen -n 1000 -q 500 -array_type random -query_type random\n./gen -n 1000 -q 500 -array_type zeros -query_type allType2\n\n./gen -n 10000 -q 1000 -array_type max -query_type allType1\n./gen -n 10000 -q 1000 -array_type large -query_type random\n\n./gen -n 50000 -q 5000 -array_type random -query_type random\n\n./gen -n 100000 -q 10000 -array_type random -query_type random\n\n./gen -n 200000 -q 20000 -array_type random -query_type random\n./gen -n 200000 -q 40000 -array_type random -query_type random\n./gen -n 200000 -q 40000 -array_type zeros -query_type extremes\n./gen -n 200000 -q 40000 -array_type ones -query_type single\n./gen -n 200000 -q 40000 -array_type max -query_type extremes\n./gen -n 200000 -q 40000 -array_type increasing -query_type random\n./gen -n 200000 -q 40000 -array_type decreasing -query_type random\n./gen -n 200000 -q 40000 -array_type alternating -query_type random\n./gen -n 200000 -q 40000 -array_type random -query_type kSmall\n./gen -n 200000 -q 40000 -array_type random -query_type kLarge\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:00.560082",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "587/F",
      "title": "F. Duff is Mad",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two integers n and q (1 ≤ n, q ≤ 105).The next n lines contain the names. i-th of them contains an string si, consisting of lowercase English letters   ().The next q lines contain the requests. Each of them contains three integers, l, r and k (says that Malek should take  candies from Duff's k-th friend).",
      "output_spec": "OutputPrint the answer to each request in one line.",
      "sample_tests": "ExamplesInputCopy5 5aababababababb1 5 43 5 41 5 21 5 31 4 1OutputCopy126371",
      "description": "F. Duff is Mad\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains two integers n and q (1 ≤ n, q ≤ 105).The next n lines contain the names. i-th of them contains an string si, consisting of lowercase English letters   ().The next q lines contain the requests. Each of them contains three integers, l, r and k (says that Malek should take  candies from Duff's k-th friend).\n\nOutputPrint the answer to each request in one line.\n\nInputCopy5 5aababababababb1 5 43 5 41 5 21 5 31 4 1OutputCopy126371\n\nInputCopy5 5aababababababb1 5 43 5 41 5 21 5 31 4 1\n\nOutputCopy126371",
      "solutions": [
        {
          "title": "Codeforces Round #326 - Codeforces",
          "content": "Hello Codeforces.I'm honored to announce you, that Codeforces round #326 is gonna take place soon on Codeforces.Writers are AmirMohammad Dehghan(PrinceOfPersia) and Ali Haghani(Haghani). There will be 6 problems in each division(4 problems are common) and you'll have 2 and a half hour to solve them. I hope you enjoy the problems.I wanna thank Maxim Akhmedov(Zlobober) for his great helps in preparing this round, MikeMirzayanov for wonderful platforms of Codeforce and Polygon, Delinur for translating problem statements into Russian and MohammadReza Maleki(mruxim) and Ali Bahjati(LiTi) for their great advices (and LiTi again for some graphics).This is my third round on Codeforces and not the last one, I hope.This is the last round on Codeforces with Zlobober as coordinator. It was nice working with him. We had a lot of fun and interesting contests during his coordination. I just wanna say: Thank you Maxim for all your contribution to CodeForces community and good luck in the future. After I heard these news, my first guess for the next coordinator was I_love_Tanya_Romanova; But I don't know if CodeForces hires people from out of Russia or not.The main character of this round is Duff, but you'll also have to help her friend, Malek!I wish you all high ratings and lots of joy.Scoring will be posted soon.GL & HF!Problems are sorted by the expected difficulty, but we strictly recommend you to read all the problems.UPD: Scoring is: 750-1000-1500-2000-2500-3000 in Div.2 and 500-1000-1500-2000-2750-2750 in Div.1 .UPD1: Editorial is published.UPD2: System test is over. Congratulations to all winners.Div.1 Winners are: qwer1561 Endagorion jcvb subscriber wjh720 Div.2 Winners are: sleepy_mario BIT-silence Owaski Orenji.Sora JavaInTheSouth Also congratulations to JoeyWheeler, the only one who solved problem Div.1 D.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20913",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1832
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces",
          "content": "Div.2 A (Author: Haghani)Idea is a simple greedy, buy needed meat for i - th day when it's cheapest among days 1, 2, ..., n.So, the pseudo code below will work: ans = 0\nprice = infinity\nfor i = 1 to n\n price = min(price, p[i])\n ans += price * a[i]Time complexity: C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by ZloboberDiv.2 B (Author: PrinceOfPersia)Find all prime divisors of n. Assume they are p1, p2, ..., pk (in ). If answer is a, then we know that for each 1 ≤ i ≤ k, obviously a is not divisible by pi2 (and all greater powers of pi). So a ≤ p1 × p2 × ... × pk. And we know that p1 × p2 × ... × pk is itself lovely. So,answer is p1 × p2 × ... × pkTime complexity: C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by ZloboberA (Author: PrinceOfPersia)Problem is: you have to find the minimum number of k, such there is a sequence a1, a2, ..., ak with condition 2a1 + 2a2 + ... + 2ak = S = 2w1 + 2w2 + ... + 2w2. Obviously, minimum value of k is the number of set bits in binary representation of S (proof is easy, you can prove it as a practice :P).Our only problem is how to count the number of set bits in binary representation of S? Building the binary representation of S as an array in is easy: MAXN = 1000000 + log(1000000)\nbit[0..MAXN] = {} // all equal to zero\nans = 0\nfor i = 1 to n\n bit[w[i]] ++ // of course after this, some bits maybe greater than 1, we'll fix them below\nfor i = 0 to MAXN - 1\n bit[i + 1] += bit[i]/2 // floor(bit[i]/2)\n bit[i] %= 2 // bit[i] = bit[i] modulo 2\n ans += bit[i] // if bit[i] = 0, then answer doesn't change, otherwise it'll increase by 1Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniB (Author: PrinceOfPersia)If we fix x and bix mod n, then problem will be solved (because we can then multiply it by the number of valid distinct values of ).For the problem above, let dp[i][j] be the number of valid subsequences of b where x = j and and . Of course, for every i, dp[i][1] = 1. For calculating value of dp[i][j]:For this purpose, we can sort the array a and use two pointer:if p0, p1, ...pn - 1 is a permutation of 0, ..., n - 1 where for each 0 ≤ t < n - 1, apt ≤ apt + 1: for i = 0 to n-1\n dp[i][1] = 1\nfor j = 2 to k\n pointer = 0\n sum = 0\n for i = 0 to n-1\n while pointer < n and a[p[pointer]] <= a[i]\n sum = (sum + dp[p[pointer ++]][j - 1]) % MOD\n dp[i][j] = sumNow, if and x = l - 1 mod n, then answer equals to (there are c - j + 1 valid different values of for the first group and c - j for the second group).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberC (Author: PrinceOfPersia)Solution is something like the fourth LCA approach discussed here.For each 1 ≤ i ≤ n and 0 ≤ j ≤ lg(n), store the minimum 10 people in the path from city (vertex) i to its 2j - th parent in an array.Now everything is needed is: how to merge the array of two paths? You can keep the these 10 values in the array in increasing order and for merging, use merge function which will work in . And then delete the extra values (more than 10).And do the same as described in the article for a query (just like the preprocess part).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberD (Author: PrinceOfPersia)Run binary search on the answer (t). For checking if answer is less than or equal to x (check(x)):First of all delete all edges with destructing time greater than x. Now, if there is more than one pair of edges with the same color connected to a vertex(because we can delete at most one of them), answer is \"No\".Use 2-Sat. Consider a literal for each edge e (xe). If xe = TRUE, it means it should be destructed and it shouldn't otherwise. There are some conditions: For each vertex v, if there is one (exactly one) pair of edges like i and j with the same color connected to v, then we should have the clause . For each vertex v, if the edges connected to it are e1, e2, ..., ek, we should make sure that there is no pair (i, j) where 1 ≤ i < j ≤ k and xe1 = xe2 = True. The naive approach is to add a clause for each pair. But it's not efficient. The efficient way tho satisfy the second condition is to use prefix or: adding k new literals p1, p2, ..., pk and for each j ≤ i, make sure . To make sure about this, we can add two clauses for each pi: and (the second one is only for i > 1).And the only thing left is to make sure (there are no two TRUE edges).This way the number of literals and clauses are . So, after binary search is over, we should run check(t) to get a sample matching.Time complexity: (but slow, because of the constant factor)C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberE (Authors: PrinceOfPersia and Haghani)Lemma #1: If numbers b1, b2, ..., bk are k Kheshtaks of a1, ..., an, then is a Kheshtak of a1, ..., an.Proof: For each 1 ≤ i ≤ k, consider maski is a binary bitmask of length n and its j - th bit shows a subsequence of a1, ..., an (subset) with xor equal to bi.So, xor of elements subsequence(subset) of a1, ..., an with bitmask equal to equals to . So, it's a Kheshtak of this sequence.From this lemma, we can get another results: If all numbers b1, b2, ..., bk are k Kheshtaks of a1, ..., an, then every Kheshtak of b1, b2, ..., bk is a Kheshtak of a1, ..., anLemma #2: Score of sequence a1, a2, ..., an is equal to the score of sequence .Proof: If we show the second sequence by b1, b2, ..., bn, then for each 1 ≤ i ≤ n: bi = ai = each element from sequence b is a Kheshtak of sequence a and vise versa. So, due to the result of Lemma #1, each Kheshtak of sequence b is a Kheshtak of sequence a and vise versa. So: score(b1, ..., bn) ≤ score(a1, ..., an) score(a1, ..., an) ≤ score(b1, ..., bn) score(a1, ..., an) = score(b1, ..., bn)Back to original problem: denote another array b2, ..., bn where . Let's solve these two problems:1- We have array a1, ..., an and q queries of two types: upd(l, r, k): Given numbers l, r and k, for each l ≤ i ≤ r, perform ask(i):  Given number i, return the value of ai. This problem can be solved easily with a simple segment tree using lazy propagation.2- We have array b2, ..., bn and queries of two types: modify(p, k): Perform bp = k. basis(l, r): Find and return the basis vector of bl, bl + 1, ..., br (using Gaussian Elimination, its size it at most 32). This problem can be solved by a segment tree where in each node we have the basis of the substring of that node (node [l, r) has the basis of sequence bl, ..., br - 1).This way we can insert to a basis vector v: insert(x, v)\n\tfor a in v\n\t\tif a & -a & x\n\t\t\tx ^= a\n\tif !x\n\t\treturn\n\tfor a in v\n\t\tif x & -x & a\n\t\t\ta ^= x\n\tv.push(x)But size of v will always be less than or equal to 32. For merging two nodes (of segment tree), we can insert the elements of one in another one.For handling queries of two types, we act like this:Type one: Call functions: upd(l, r, k), and .Type two: Let b = basis(l + 1, r). Call insert(al, b). And then print 2b.size() as the answer.Time complexity: = C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by ZloboberF (Author: PrinceOfPersia)Use Aho-Corasick. Assume first of all we build the trie of our strings (function t). If t(v, c) ≠  - 1 it means that there is an edge in the trie outgoing from vertex v written c on it.So, for building Aho-Corasick, consider f(v) = the vertex we go into, in case of failure (t(v, c) =  - 1). i.e the deepest vertex (u), that v ≠ u and the path from root to u is a suffix of path from root to v. No we can build an automaton (Aho-Corasick), function g. For each i, do this (in the automaton): cur = root\nfor c in s[i]\n\tcur = g(cur, c)\n\tAnd then push i in q[cur] (q is a vector, also we do this for cur = root).\n\nend[cur].push(i) \t// end is also a vector, consisting of the indices of strings ending in vertex cur (state cur in automaton)\nlast[i] = cur // last[i] is the final state we get to from searching string s[i] in automaton gAssume cnt(v, i) is the number of occurrences of number i in q[v]. Also, denote .Build another tree. In this tree, for each i that is not root of the trie, let par[i] = f(i) (the vertex we go in the trie, in case of failure) and call it C-Tree.So now, problem is on a tree. Operations are : Each query gives numbers l, r, k and you have to find the number .Act offline. If N = 105, then:1. For each i such that , collect queries (like struct) in a vector of queries query[i], then run dfs on the C-Tree and using a partial sum answer to all queries with k = i. There are at most of these numbers, so it can be done in . After doing these, erase i from all q[1], q[1], ..., q[N].Code (in dfs) would be like this(on C-Tree): partial_sum[n] = {}; // all 0\ndfs(v, i){\n\tcnt = 0;\n\tfor x in q[v]\n\t\tif(x == i)\n\t\t++ cnt;\n\tfor u in childern[v]\n\t\tcnt += dfs(u);\n\tfor x in end[v]\n\t\tpartial_sum[x] += cnt;\n\treturn cnt;\n}\ncalc(i){\n\tdfs(root, i);\n\tfor i = 2 to n\n\t\tpartial_sum[i] += partial_sum[i-1]\n\tfor query u in query[i]\n\t\tu.ans = partial_sum[u.r] - partial_sum[u.l - 1]\n}And we should just run calc(i) for each of them.2. For each i such that , collect queries (like struct) in a vector of queries query[i]. (each element of this vector have three integers in it: l, r and ans).Consider this problem:We have an array a of length N(initially all element equal to 0) and some queries of two types: increase(i, val): increase a[i] by val sum(i): tell the value of a[1] + a[2] + ... + a[i] We know that number of queries of the first type is and from the second type is . Using Sqrt decomposition, we can solve this problem in : K = sqrt(N)\ntot[K] = {}, a[N] = {} // this code is 0-based\nincrease(i, val)\n\twhile i < N and i % K > 0\n\t\ta[i ++] += val\n\twhile i < K\n\t\ttot[i/K] += val\n\t\ti += K\nsum(i)\n\treturn a[i] + tot[i/K]Back to our problem now.Then, just run dfs once on this C-Tree and act like this: dfs(vertex v):\n\tfor i in end[v]\n\t\tincrease(i, 1)\n\tfor i in q[v]\n\t\tfor query u in query[i]\n\t\t\tu.ans += sum(u.r) - sum(u.l - 1)\n\tfor u in children[v]\n\t\tdfs(u)\n\tfor i in end[v]\n\t\tincrease(i, -1)Then answer to a query q is q.ans.Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/20971",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10107
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #326 - Codeforces - Code 1",
          "code": "00:30 start time (local time)\n+  0:10 expected delay\n+  2:30 contest\n+  0:30 system test\n+  0:30 rating changes\n= 04:10 sleep time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 - Codeforces - Code 2",
          "code": "00:30 start time (local time)\n+  0:10 expected delay\n+  2:30 contest\n+  0:30 system test\n+  0:30 rating changes\n= 04:10 sleep time",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 - Codeforces - Code 3",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 - Codeforces - Code 4",
          "code": "#just_grandmaster_things",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20913",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 1",
          "code": "ans = 0\nprice = infinity\nfor i = 1 to n\n      price = min(price, p[i])\n      ans += price * a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 2",
          "code": "ans = 0\nprice = infinity\nfor i = 1 to n\n      price = min(price, p[i])\n      ans += price * a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 3",
          "code": "MAXN = 1000000 + log(1000000)\nbit[0..MAXN] = {} // all equal to zero\nans = 0\nfor i = 1 to n\n      bit[w[i]] ++ // of course after this, some bits maybe greater than 1, we'll fix them below\nfor i = 0 to MAXN - 1\n      bit[i + 1] += bit[i]/2 // floor(bit[i]/2)\n      bit[i] %= 2 // bit[i] = bit[i] modulo 2\n      ans += bit[i] // if bit[i] = 0, then answer doesn't change, otherwise it'll increase by 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 4",
          "code": "MAXN = 1000000 + log(1000000)\nbit[0..MAXN] = {} // all equal to zero\nans = 0\nfor i = 1 to n\n      bit[w[i]] ++ // of course after this, some bits maybe greater than 1, we'll fix them below\nfor i = 0 to MAXN - 1\n      bit[i + 1] += bit[i]/2 // floor(bit[i]/2)\n      bit[i] %= 2 // bit[i] = bit[i] modulo 2\n      ans += bit[i] // if bit[i] = 0, then answer doesn't change, otherwise it'll increase by 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 5",
          "code": "for i = 0 to n-1\n      dp[i][1] = 1\nfor j = 2 to k\n      pointer = 0\n      sum = 0\n      for i = 0 to n-1\n            while pointer < n and a[p[pointer]] <= a[i]\n                  sum = (sum + dp[p[pointer ++]][j - 1]) % MOD\n            dp[i][j] = sum",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 6",
          "code": "for i = 0 to n-1\n      dp[i][1] = 1\nfor j = 2 to k\n      pointer = 0\n      sum = 0\n      for i = 0 to n-1\n            while pointer < n and a[p[pointer]] <= a[i]\n                  sum = (sum + dp[p[pointer ++]][j - 1]) % MOD\n            dp[i][j] = sum",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 7",
          "code": "insert(x, v)\n\tfor a in v\n\t\tif a & -a & x\n\t\t\tx ^= a\n\tif !x\n\t\treturn\n\tfor a in v\n\t\tif x & -x & a\n\t\t\ta ^= x\n\tv.push(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 8",
          "code": "insert(x, v)\n\tfor a in v\n\t\tif a & -a & x\n\t\t\tx ^= a\n\tif !x\n\t\treturn\n\tfor a in v\n\t\tif x & -x & a\n\t\t\ta ^= x\n\tv.push(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 9",
          "code": "cur = root\nfor c in s[i]\n\tcur = g(cur, c)\n\tAnd then push i in q[cur] (q is a vector, also we do this for cur = root).\n\nend[cur].push(i) \t// end is also a vector, consisting of the indices of strings ending in vertex cur (state cur in automaton)\nlast[i] = cur // last[i] is the final state we get to from searching string s[i] in automaton g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 10",
          "code": "cur = root\nfor c in s[i]\n\tcur = g(cur, c)\n\tAnd then push i in q[cur] (q is a vector, also we do this for cur = root).\n\nend[cur].push(i) \t// end is also a vector, consisting of the indices of strings ending in vertex cur (state cur in automaton)\nlast[i] = cur // last[i] is the final state we get to from searching string s[i] in automaton g",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 11",
          "code": "partial_sum[n] = {}; // all 0\ndfs(v, i){\n\tcnt = 0;\n\tfor x in q[v]\n\t\tif(x == i)\n\t\t++ cnt;\n\tfor u in childern[v]\n\t\tcnt += dfs(u);\n\tfor x in end[v]\n\t\tpartial_sum[x] += cnt;\n\treturn cnt;\n}\ncalc(i){\n\tdfs(root, i);\n\tfor i = 2 to n\n\t\tpartial_sum[i] += partial_sum[i-1]\n\tfor query u in query[i]\n\t\tu.ans = partial_sum[u.r] - partial_sum[u.l - 1]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 12",
          "code": "partial_sum[n] = {}; // all 0\ndfs(v, i){\n\tcnt = 0;\n\tfor x in q[v]\n\t\tif(x == i)\n\t\t++ cnt;\n\tfor u in childern[v]\n\t\tcnt += dfs(u);\n\tfor x in end[v]\n\t\tpartial_sum[x] += cnt;\n\treturn cnt;\n}\ncalc(i){\n\tdfs(root, i);\n\tfor i = 2 to n\n\t\tpartial_sum[i] += partial_sum[i-1]\n\tfor query u in query[i]\n\t\tu.ans = partial_sum[u.r] - partial_sum[u.l - 1]\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 13",
          "code": "K = sqrt(N)\ntot[K] = {}, a[N] = {} // this code is 0-based\nincrease(i, val)\n\twhile i < N and i % K > 0\n\t\ta[i ++] += val\n\twhile i < K\n\t\ttot[i/K] += val\n\t\ti += K\nsum(i)\n\treturn a[i] + tot[i/K]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 14",
          "code": "K = sqrt(N)\ntot[K] = {}, a[N] = {} // this code is 0-based\nincrease(i, val)\n\twhile i < N and i % K > 0\n\t\ta[i ++] += val\n\twhile i < K\n\t\ttot[i/K] += val\n\t\ti += K\nsum(i)\n\treturn a[i] + tot[i/K]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 15",
          "code": "dfs(vertex v):\n\tfor i in end[v]\n\t\tincrease(i, 1)\n\tfor i in q[v]\n\t\tfor query u in query[i]\n\t\t\tu.ans += sum(u.r) - sum(u.l - 1)\n\tfor u in children[v]\n\t\tdfs(u)\n\tfor i in end[v]\n\t\tincrease(i, -1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 16",
          "code": "dfs(vertex v):\n\tfor i in end[v]\n\t\tincrease(i, 1)\n\tfor i in q[v]\n\t\tfor query u in query[i]\n\t\t\tu.ans += sum(u.r) - sum(u.l - 1)\n\tfor u in children[v]\n\t\tdfs(u)\n\tfor i in end[v]\n\t\tincrease(i, -1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 17",
          "code": "3 12 2\n5 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 18",
          "code": "3 12 2\n5 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 19",
          "code": "5 9 1  5 9 1  5 9 1   5 9 1  --> b\n1 2 3  4 5 6  7 8 9  10 11 12 --> positions\n\nlength 1 subsequence 12\nlength 2: \n1-4,1-5,1-7,1-8,1-10,1-11,2-5,2-8,2-11,3-4,3-5,3-6,3-7,3-8,3-9,3-10,3-11,3-12,\n4-7,4-8,4-10,4-11,5-8,5-11,6-7,6-8,6-9,6-10,6-11,6-12\n7-10,7-11,8-11,9-10,9-11,9-12\n\ntotal 36+12 = 48",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #326 (Editorial) - Codeforces - Code 20",
          "code": "5 9 1  5 9 1  5 9 1   5 9 1  --> b\n1 2 3  4 5 6  7 8 9  10 11 12 --> positions\n\nlength 1 subsequence 12\nlength 2: \n1-4,1-5,1-7,1-8,1-10,1-11,2-5,2-8,2-11,3-4,3-5,3-6,3-7,3-8,3-9,3-10,3-11,3-12,\n4-7,4-8,4-10,4-11,5-8,5-11,6-7,6-8,6-9,6-10,6-11,6-12\n7-10,7-11,8-11,9-10,9-11,9-12\n\ntotal 36+12 = 48",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/20971",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    long long total_length = 0;\n    for (int i = 1; i <= n; ++i) {\n        string s = inf.readToken(\"[a-z]+\", \"si\");\n        int len = s.length();\n        ensuref(1 <= len && len <= 100000, \"Length of si[%d] must be between 1 and 100000, got %d\", i, len);\n        total_length += len;\n        ensuref(total_length <= 10000000LL, \"Total length of si exceeds 10000000, total_length=%lld\", total_length);\n        inf.readEoln();\n    }\n\n    for (int i = 1; i <= q; ++i) {\n        int l = inf.readInt(1, n, \"l\");\n        inf.readSpace();\n        int r = inf.readInt(1, n, \"r\");\n        inf.readSpace();\n        int k = inf.readInt(1, n, \"k\");\n        inf.readEoln();\n        ensuref(l <= r, \"In query %d, l=%d must be less than or equal to r=%d\", i, l, r);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    long long total_length = 0;\n    for (int i = 1; i <= n; ++i) {\n        string s = inf.readToken(\"[a-z]+\", \"si\");\n        int len = s.length();\n        ensuref(1 <= len && len <= 100000, \"Length of si[%d] must be between 1 and 100000, got %d\", i, len);\n        total_length += len;\n        ensuref(total_length <= 10000000LL, \"Total length of si exceeds 10000000, total_length=%lld\", total_length);\n        inf.readEoln();\n    }\n\n    for (int i = 1; i <= q; ++i) {\n        int l = inf.readInt(1, n, \"l\");\n        inf.readSpace();\n        int r = inf.readInt(1, n, \"r\");\n        inf.readSpace();\n        int k = inf.readInt(1, n, \"k\");\n        inf.readEoln();\n        ensuref(l <= r, \"In query %d, l=%d must be less than or equal to r=%d\", i, l, r);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    long long total_length = 0;\n    for (int i = 1; i <= n; ++i) {\n        string s = inf.readToken(\"[a-z]+\", \"si\");\n        int len = s.length();\n        ensuref(1 <= len && len <= 100000, \"Length of si[%d] must be between 1 and 100000, got %d\", i, len);\n        total_length += len;\n        ensuref(total_length <= 10000000LL, \"Total length of si exceeds 10000000, total_length=%lld\", total_length);\n        inf.readEoln();\n    }\n\n    for (int i = 1; i <= q; ++i) {\n        int l = inf.readInt(1, n, \"l\");\n        inf.readSpace();\n        int r = inf.readInt(1, n, \"r\");\n        inf.readSpace();\n        int k = inf.readInt(1, n, \"k\");\n        inf.readEoln();\n        ensuref(l <= r, \"In query %d, l=%d must be less than or equal to r=%d\", i, l, r);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces test data for the problem described above.\n\n  Usage:\n    ./gen -n <number_of_strings> -q <number_of_queries> -type <test_type> -maxLen <maximum_total_length>\n\n  Notes:\n    1) You should NOT set the random seed yourself; testlib does that.\n    2) Make sure sum of lengths of all strings does not exceed maxLen, because\n       the provided solution code uses arrays sized around 100000 for storing characters.\n    3) Each query is (l, r, k) with 1 <= l <= r <= n, 1 <= k <= n.\n    4) By changing the \"type\" parameter, you can get different shapes of tests:\n       - \"cornerCase\": minimal n, q.\n       - \"smallDistinct\": small n, distinct strings.\n       - \"same\": all strings identical or near-identical.\n       - \"random\": random strings, random queries.\n       - \"repeatedPattern\": strings with repeated patterns to stress occurrence counting.\n    5) The generator only prints one single test instance per run. \n       You typically call it multiple times to produce multiple testcases.\n*/\n\nstatic const int ALPHABET_SIZE = 26; // 'a'..'z'\n\n/* Generate a random lowercase string of length len. */\nstring genRandomString(int len) {\n    string s;\n    s.resize(len);\n    for(int i = 0; i < len; i++){\n        s[i] = char('a' + rnd.next(ALPHABET_SIZE)); \n    }\n    return s;\n}\n\n/* Generate a repeated pattern string, e.g., \"abcabcabc...\". */\nstring genRepeatedPattern(int len) {\n    // We'll pick a small random pattern length between 1 and 10,\n    // then repeat it until we get 'len' characters.\n    int patLen = rnd.next(1, min(10, len));\n    string pat = genRandomString(patLen);\n    string result;\n    result.reserve(len);\n    while((int)result.size() < len) {\n        for (char c : pat) {\n            if ((int)result.size() == len) break;\n            result.push_back(c);\n        }\n    }\n    return result;\n}\n\n/* Generate a test with minimal n=1, q=1. */\nvoid cornerCaseTest(int n, int q, int maxLen) {\n    // Force n=1, q=1 regardless of user input\n    n = 1; \n    q = 1; \n    // One string, length 1 to keep it simple:\n    // sum of lengths must be <= maxLen\n    // We'll just produce \"a\".\n    cout << n << \" \" << q << \"\\n\";\n    cout << \"a\\n\";\n    // Only one friend => only valid query is l=1, r=1, k=1\n    cout << \"1 1 1\\n\";\n}\n\n/* Generate small but distinct strings. */\nvoid smallDistinctTest(int n, int q, int maxLen) {\n    // We'll keep sum of lengths up to maxLen. \n    // For \"smallDistinct\", let's distribute length equally so total is well under maxLen.\n    // E.g., each string ~ length = min( (int)maxLen/n, 10 ) to keep them short.\n    int eachLen = min((int)maxLen / max(n, 1), 10);\n    long long totalLen = 0;\n\n    cout << n << \" \" << q << \"\\n\";\n\n    // Generate n distinct strings, each of length up to 'eachLen'\n    for(int i = 0; i < n; i++){\n        int len = rnd.next(1, eachLen);\n        totalLen += len;\n        // Just create a random string. We'll attempt to keep them distinct\n        // by adding i as a \"suffix\" in some way.\n        // But since they're short, collisions are still possible if i is large.\n        // We'll just rely on partial randomness.\n        // (We do not need perfect distinctness, just \"likely distinct\".)\n        string s = genRandomString(len);\n        // Tweak last character based on i\n        s.back() = (char)('a' + (s.back() - 'a' + i) % 26);\n        cout << s << \"\\n\";\n    }\n\n    // Generate q queries\n    for(int i = 0; i < q; i++){\n        int l = rnd.next(1, n);\n        int r = rnd.next(1, n);\n        if(l > r) swap(l, r);\n        int k = rnd.next(1, n);\n        cout << l << \" \" << r << \" \" << k << \"\\n\";\n    }\n}\n\n/* Generate all identical or near-identical strings. */\nvoid sameStringsTest(int n, int q, int maxLen) {\n    // We'll pick a single random length, repeated for all.\n    // Keep sum <= maxLen => length * n <= maxLen => length <= maxLen / n\n    int baseLen = maxLen / max(n, 1);\n    if(baseLen == 0) baseLen = 1; // fallback\n\n    // We'll pick an actual length in [1..baseLen]\n    int len = rnd.next(1, baseLen);\n\n    // We'll also pick one random string for them all\n    string baseString = genRandomString(len);\n\n    cout << n << \" \" << q << \"\\n\";\n    // Print n copies of that string\n    for(int i = 0; i < n; i++){\n        cout << baseString << \"\\n\";\n    }\n\n    // Queries\n    // We can generate random queries but also mix in some boundary queries\n    for(int i = 0; i < q; i++){\n        if(i < 5 && n >= 1) {\n            // Some boundary queries\n            cout << 1 << \" \" << n << \" \" << rnd.next(1, n) << \"\\n\";\n        } else {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if(l > r) swap(l, r);\n            int k = rnd.next(1, n);\n            cout << l << \" \" << r << \" \" << k << \"\\n\";\n        }\n    }\n}\n\n/* Generate random strings with random queries. */\nvoid randomStringsTest(int n, int q, int maxLen) {\n    // We randomly generate lengths for each string, ensuring sum <= maxLen.\n    // Then fill them with random letters, and produce random queries.\n\n    cout << n << \" \" << q << \"\\n\";\n\n    long long totalLen = 0;\n    // We keep track to ensure totalLen <= maxLen\n    for(int i = 0; i < n; i++){\n        // Remaining capacity:\n        long long rem = maxLen - totalLen;\n        if(rem <= 0) {\n            // Force length = 1 if we run out of capacity\n            // (should not happen if the user sets maxLen large enough)\n            rem = 1;\n        }\n        // We'll pick length up to min(50, rem), just as a small random chunk\n        int len = rnd.next(1, (int)min(50LL, rem));\n        totalLen += len;\n        cout << genRandomString(len) << \"\\n\";\n    }\n\n    for(int i = 0; i < q; i++){\n        int l = rnd.next(1, n);\n        int r = rnd.next(1, n);\n        if(l > r) swap(l, r);\n        int k = rnd.next(1, n);\n        cout << l << \" \" << r << \" \" << k << \"\\n\";\n    }\n}\n\n/* Generate strings with repeated patterns. */\nvoid repeatedPatternTest(int n, int q, int maxLen) {\n    cout << n << \" \" << q << \"\\n\";\n    long long totalLen = 0;\n\n    for(int i = 0; i < n; i++){\n        long long rem = maxLen - totalLen;\n        if(rem <= 0) rem = 1;\n        // Generate pattern length up to min(30, rem) to keep it somewhat short\n        int len = rnd.next(1, (int)min(30LL, rem));\n        totalLen += len;\n        // repeated pattern\n        cout << genRepeatedPattern(len) << \"\\n\";\n    }\n\n    // We'll do random queries plus some that try to push extreme ranges\n    for(int i = 0; i < q; i++){\n        if(i < 3 && n >= 2) {\n            // Try a query that covers everything\n            cout << 1 << \" \" << n << \" \" << rnd.next(1, n) << \"\\n\";\n        } else {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if(l > r) swap(l, r);\n            int k = rnd.next(1, n);\n            cout << l << \" \" << r << \" \" << k << \"\\n\";\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\", 5);\n    int q = opt<int>(\"q\", 5);\n    string t = opt<string>(\"type\", \"random\");\n    int maxLen = opt<int>(\"maxLen\", 100000); // maximum total length of all strings\n\n    // Based on \"t\", dispatch to different test-shaping routines\n    if(t == \"cornerCase\") {\n        cornerCaseTest(n, q, maxLen);\n    } \n    else if(t == \"smallDistinct\") {\n        smallDistinctTest(n, q, maxLen);\n    } \n    else if(t == \"same\") {\n        sameStringsTest(n, q, maxLen);\n    } \n    else if(t == \"random\") {\n        randomStringsTest(n, q, maxLen);\n    } \n    else if(t == \"repeatedPattern\") {\n        repeatedPatternTest(n, q, maxLen);\n    }\n    else {\n        // Default fallback\n        randomStringsTest(n, q, maxLen);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces test data for the problem described above.\n\n  Usage:\n    ./gen -n <number_of_strings> -q <number_of_queries> -type <test_type> -maxLen <maximum_total_length>\n\n  Notes:\n    1) You should NOT set the random seed yourself; testlib does that.\n    2) Make sure sum of lengths of all strings does not exceed maxLen, because\n       the provided solution code uses arrays sized around 100000 for storing characters.\n    3) Each query is (l, r, k) with 1 <= l <= r <= n, 1 <= k <= n.\n    4) By changing the \"type\" parameter, you can get different shapes of tests:\n       - \"cornerCase\": minimal n, q.\n       - \"smallDistinct\": small n, distinct strings.\n       - \"same\": all strings identical or near-identical.\n       - \"random\": random strings, random queries.\n       - \"repeatedPattern\": strings with repeated patterns to stress occurrence counting.\n    5) The generator only prints one single test instance per run. \n       You typically call it multiple times to produce multiple testcases.\n*/\n\nstatic const int ALPHABET_SIZE = 26; // 'a'..'z'\n\n/* Generate a random lowercase string of length len. */\nstring genRandomString(int len) {\n    string s;\n    s.resize(len);\n    for(int i = 0; i < len; i++){\n        s[i] = char('a' + rnd.next(ALPHABET_SIZE)); \n    }\n    return s;\n}\n\n/* Generate a repeated pattern string, e.g., \"abcabcabc...\". */\nstring genRepeatedPattern(int len) {\n    // We'll pick a small random pattern length between 1 and 10,\n    // then repeat it until we get 'len' characters.\n    int patLen = rnd.next(1, min(10, len));\n    string pat = genRandomString(patLen);\n    string result;\n    result.reserve(len);\n    while((int)result.size() < len) {\n        for (char c : pat) {\n            if ((int)result.size() == len) break;\n            result.push_back(c);\n        }\n    }\n    return result;\n}\n\n/* Generate a test with minimal n=1, q=1. */\nvoid cornerCaseTest(int n, int q, int maxLen) {\n    // Force n=1, q=1 regardless of user input\n    n = 1; \n    q = 1; \n    // One string, length 1 to keep it simple:\n    // sum of lengths must be <= maxLen\n    // We'll just produce \"a\".\n    cout << n << \" \" << q << \"\\n\";\n    cout << \"a\\n\";\n    // Only one friend => only valid query is l=1, r=1, k=1\n    cout << \"1 1 1\\n\";\n}\n\n/* Generate small but distinct strings. */\nvoid smallDistinctTest(int n, int q, int maxLen) {\n    // We'll keep sum of lengths up to maxLen. \n    // For \"smallDistinct\", let's distribute length equally so total is well under maxLen.\n    // E.g., each string ~ length = min( (int)maxLen/n, 10 ) to keep them short.\n    int eachLen = min((int)maxLen / max(n, 1), 10);\n    long long totalLen = 0;\n\n    cout << n << \" \" << q << \"\\n\";\n\n    // Generate n distinct strings, each of length up to 'eachLen'\n    for(int i = 0; i < n; i++){\n        int len = rnd.next(1, eachLen);\n        totalLen += len;\n        // Just create a random string. We'll attempt to keep them distinct\n        // by adding i as a \"suffix\" in some way.\n        // But since they're short, collisions are still possible if i is large.\n        // We'll just rely on partial randomness.\n        // (We do not need perfect distinctness, just \"likely distinct\".)\n        string s = genRandomString(len);\n        // Tweak last character based on i\n        s.back() = (char)('a' + (s.back() - 'a' + i) % 26);\n        cout << s << \"\\n\";\n    }\n\n    // Generate q queries\n    for(int i = 0; i < q; i++){\n        int l = rnd.next(1, n);\n        int r = rnd.next(1, n);\n        if(l > r) swap(l, r);\n        int k = rnd.next(1, n);\n        cout << l << \" \" << r << \" \" << k << \"\\n\";\n    }\n}\n\n/* Generate all identical or near-identical strings. */\nvoid sameStringsTest(int n, int q, int maxLen) {\n    // We'll pick a single random length, repeated for all.\n    // Keep sum <= maxLen => length * n <= maxLen => length <= maxLen / n\n    int baseLen = maxLen / max(n, 1);\n    if(baseLen == 0) baseLen = 1; // fallback\n\n    // We'll pick an actual length in [1..baseLen]\n    int len = rnd.next(1, baseLen);\n\n    // We'll also pick one random string for them all\n    string baseString = genRandomString(len);\n\n    cout << n << \" \" << q << \"\\n\";\n    // Print n copies of that string\n    for(int i = 0; i < n; i++){\n        cout << baseString << \"\\n\";\n    }\n\n    // Queries\n    // We can generate random queries but also mix in some boundary queries\n    for(int i = 0; i < q; i++){\n        if(i < 5 && n >= 1) {\n            // Some boundary queries\n            cout << 1 << \" \" << n << \" \" << rnd.next(1, n) << \"\\n\";\n        } else {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if(l > r) swap(l, r);\n            int k = rnd.next(1, n);\n            cout << l << \" \" << r << \" \" << k << \"\\n\";\n        }\n    }\n}\n\n/* Generate random strings with random queries. */\nvoid randomStringsTest(int n, int q, int maxLen) {\n    // We randomly generate lengths for each string, ensuring sum <= maxLen.\n    // Then fill them with random letters, and produce random queries.\n\n    cout << n << \" \" << q << \"\\n\";\n\n    long long totalLen = 0;\n    // We keep track to ensure totalLen <= maxLen\n    for(int i = 0; i < n; i++){\n        // Remaining capacity:\n        long long rem = maxLen - totalLen;\n        if(rem <= 0) {\n            // Force length = 1 if we run out of capacity\n            // (should not happen if the user sets maxLen large enough)\n            rem = 1;\n        }\n        // We'll pick length up to min(50, rem), just as a small random chunk\n        int len = rnd.next(1, (int)min(50LL, rem));\n        totalLen += len;\n        cout << genRandomString(len) << \"\\n\";\n    }\n\n    for(int i = 0; i < q; i++){\n        int l = rnd.next(1, n);\n        int r = rnd.next(1, n);\n        if(l > r) swap(l, r);\n        int k = rnd.next(1, n);\n        cout << l << \" \" << r << \" \" << k << \"\\n\";\n    }\n}\n\n/* Generate strings with repeated patterns. */\nvoid repeatedPatternTest(int n, int q, int maxLen) {\n    cout << n << \" \" << q << \"\\n\";\n    long long totalLen = 0;\n\n    for(int i = 0; i < n; i++){\n        long long rem = maxLen - totalLen;\n        if(rem <= 0) rem = 1;\n        // Generate pattern length up to min(30, rem) to keep it somewhat short\n        int len = rnd.next(1, (int)min(30LL, rem));\n        totalLen += len;\n        // repeated pattern\n        cout << genRepeatedPattern(len) << \"\\n\";\n    }\n\n    // We'll do random queries plus some that try to push extreme ranges\n    for(int i = 0; i < q; i++){\n        if(i < 3 && n >= 2) {\n            // Try a query that covers everything\n            cout << 1 << \" \" << n << \" \" << rnd.next(1, n) << \"\\n\";\n        } else {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if(l > r) swap(l, r);\n            int k = rnd.next(1, n);\n            cout << l << \" \" << r << \" \" << k << \"\\n\";\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\", 5);\n    int q = opt<int>(\"q\", 5);\n    string t = opt<string>(\"type\", \"random\");\n    int maxLen = opt<int>(\"maxLen\", 100000); // maximum total length of all strings\n\n    // Based on \"t\", dispatch to different test-shaping routines\n    if(t == \"cornerCase\") {\n        cornerCaseTest(n, q, maxLen);\n    } \n    else if(t == \"smallDistinct\") {\n        smallDistinctTest(n, q, maxLen);\n    } \n    else if(t == \"same\") {\n        sameStringsTest(n, q, maxLen);\n    } \n    else if(t == \"random\") {\n        randomStringsTest(n, q, maxLen);\n    } \n    else if(t == \"repeatedPattern\") {\n        repeatedPatternTest(n, q, maxLen);\n    }\n    else {\n        // Default fallback\n        randomStringsTest(n, q, maxLen);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -type cornerCase\n./gen -n 5 -q 5 -type cornerCase\n\n./gen -n 5 -q 5 -type smallDistinct\n./gen -n 10 -q 10 -type smallDistinct\n./gen -n 20 -q 30 -type smallDistinct\n\n./gen -n 5 -q 5 -type same\n./gen -n 50 -q 50 -type same\n./gen -n 100 -q 100 -type same\n\n./gen -n 5 -q 5 -type random\n./gen -n 50 -q 50 -type random\n./gen -n 100 -q 100 -type random\n./gen -n 500 -q 500 -type random -maxLen 100000\n./gen -n 500 -q 1000 -type random -maxLen 100000\n\n./gen -n 5 -q 5 -type repeatedPattern\n./gen -n 30 -q 30 -type repeatedPattern\n./gen -n 50 -q 100 -type repeatedPattern\n\n./gen -n 300 -q 300 -type smallDistinct -maxLen 100000\n./gen -n 300 -q 300 -type same -maxLen 100000\n./gen -n 300 -q 300 -type repeatedPattern -maxLen 100000\n./gen -n 300 -q 300 -type random -maxLen 100000\n\n./gen -n 100000 -q 100000 -type same -maxLen 100000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:02.185253",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "588/A",
      "title": "A. Duff and Meat",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains integer n (1 ≤ n ≤ 105), the number of days.In the next n lines, i-th line contains two integers ai and pi (1 ≤ ai, pi ≤ 100), the amount of meat Duff needs and the cost of meat in that day.",
      "output_spec": "OutputPrint the minimum money needed to keep Duff happy for n days, in one line.",
      "sample_tests": "ExamplesInputCopy31 32 23 1OutputCopy10InputCopy31 32 13 2OutputCopy8",
      "description": "A. Duff and Meat\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains integer n (1 ≤ n ≤ 105), the number of days.In the next n lines, i-th line contains two integers ai and pi (1 ≤ ai, pi ≤ 100), the amount of meat Duff needs and the cost of meat in that day.\n\nOutputPrint the minimum money needed to keep Duff happy for n days, in one line.\n\nInputCopy31 32 23 1OutputCopy10InputCopy31 32 13 2OutputCopy8\n\nInputCopy31 32 23 1\n\nOutputCopy10\n\nInputCopy31 32 13 2\n\nOutputCopy8\n\nNoteIn the first sample case: An optimal way would be to buy 1 kg on the first day, 2 kg on the second day and 3 kg on the third day.In the second sample case: An optimal way would be to buy 1 kg on the first day and 5 kg (needed meat for the second and third day) on the second day.",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char * argv[])\n{\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for(int i=1; i<=n; i++)\n    {\n        int ai = inf.readInt(1, 100, \"a_i\");\n        inf.readSpace();\n        int pi = inf.readInt(1, 100, \"p_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char * argv[])\n{\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for(int i=1; i<=n; i++)\n    {\n        int ai = inf.readInt(1, 100, \"a_i\");\n        inf.readSpace();\n        int pi = inf.readInt(1, 100, \"p_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char * argv[])\n{\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for(int i=1; i<=n; i++)\n    {\n        int ai = inf.readInt(1, 100, \"a_i\");\n        inf.readSpace();\n        int pi = inf.readInt(1, 100, \"p_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string price_type = opt<string>(\"price_type\", \"random\");\n    string amount_type = opt<string>(\"amount_type\", \"random\");\n\n    vector<int> ai(n);\n    vector<int> pi(n);\n\n    // Generate ai\n    if (amount_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n        }\n    } else if (amount_type == \"all_1\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 1;\n        }\n    } else if (amount_type == \"all_max\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 100;\n        }\n    } else if (amount_type == \"random_small\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 5);\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Generate pi\n    if (price_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(1, 100);\n        }\n    } else if (price_type == \"increasing\") {\n        pi[0] = rnd.next(1, 100);\n        for (int i = 1; i < n; ++i) {\n            pi[i] = pi[i-1] + rnd.next(0, 100 - pi[i-1]);\n            if (pi[i] > 100) pi[i] = 100;\n        }\n    } else if (price_type == \"decreasing\") {\n        pi[0] = rnd.next(1, 100);\n        for (int i = 1; i < n; ++i) {\n            pi[i] = pi[i-1] - rnd.next(0, pi[i-1]-1);\n            if (pi[i] < 1) pi[i] = 1;\n        }\n    } else if (price_type == \"constant\") {\n        int price = rnd.next(1, 100);\n        for (int i = 0; i < n; ++i) {\n            pi[i] = price;\n        }\n    } else if (price_type == \"first_high\") {\n        pi[0] = 100;\n        for (int i = 1; i < n; ++i) {\n            pi[i] = rnd.next(1, 50);\n        }\n    } else if (price_type == \"first_low\") {\n        pi[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            pi[i] = rnd.next(50, 100);\n        }\n    } else if (price_type == \"zigzag\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                pi[i] = rnd.next(1, 50);\n            } else {\n                pi[i] = rnd.next(51, 100);\n            }\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output ai and pi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", ai[i], pi[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string price_type = opt<string>(\"price_type\", \"random\");\n    string amount_type = opt<string>(\"amount_type\", \"random\");\n\n    vector<int> ai(n);\n    vector<int> pi(n);\n\n    // Generate ai\n    if (amount_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n        }\n    } else if (amount_type == \"all_1\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 1;\n        }\n    } else if (amount_type == \"all_max\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 100;\n        }\n    } else if (amount_type == \"random_small\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 5);\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Generate pi\n    if (price_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(1, 100);\n        }\n    } else if (price_type == \"increasing\") {\n        pi[0] = rnd.next(1, 100);\n        for (int i = 1; i < n; ++i) {\n            pi[i] = pi[i-1] + rnd.next(0, 100 - pi[i-1]);\n            if (pi[i] > 100) pi[i] = 100;\n        }\n    } else if (price_type == \"decreasing\") {\n        pi[0] = rnd.next(1, 100);\n        for (int i = 1; i < n; ++i) {\n            pi[i] = pi[i-1] - rnd.next(0, pi[i-1]-1);\n            if (pi[i] < 1) pi[i] = 1;\n        }\n    } else if (price_type == \"constant\") {\n        int price = rnd.next(1, 100);\n        for (int i = 0; i < n; ++i) {\n            pi[i] = price;\n        }\n    } else if (price_type == \"first_high\") {\n        pi[0] = 100;\n        for (int i = 1; i < n; ++i) {\n            pi[i] = rnd.next(1, 50);\n        }\n    } else if (price_type == \"first_low\") {\n        pi[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            pi[i] = rnd.next(50, 100);\n        }\n    } else if (price_type == \"zigzag\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                pi[i] = rnd.next(1, 50);\n            } else {\n                pi[i] = rnd.next(51, 100);\n            }\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output ai and pi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", ai[i], pi[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -price_type constant -amount_type all_1\n./gen -n 2 -price_type first_high -amount_type all_max\n./gen -n 5 -price_type increasing -amount_type all_1\n./gen -n 5 -price_type decreasing -amount_type all_max\n./gen -n 10 -price_type random -amount_type random\n./gen -n 10 -price_type zigzag -amount_type random_small\n./gen -n 15 -price_type first_low -amount_type random\n./gen -n 50 -price_type constant -amount_type random\n./gen -n 100 -price_type increasing -amount_type all_1\n./gen -n 100 -price_type decreasing -amount_type all_max\n./gen -n 500 -price_type random -amount_type random\n./gen -n 1000 -price_type first_high -amount_type random\n./gen -n 1000 -price_type first_low -amount_type random\n./gen -n 5000 -price_type zigzag -amount_type random\n./gen -n 10000 -price_type increasing -amount_type random\n./gen -n 20000 -price_type decreasing -amount_type random\n./gen -n 30000 -price_type random -amount_type random_small\n./gen -n 40000 -price_type constant -amount_type all_max\n./gen -n 50000 -price_type first_high -amount_type random\n./gen -n 60000 -price_type first_low -amount_type random\n./gen -n 70000 -price_type zigzag -amount_type all_1\n./gen -n 80000 -price_type random -amount_type random\n./gen -n 90000 -price_type increasing -amount_type random_small\n./gen -n 100000 -price_type decreasing -amount_type random_small\n./gen -n 100000 -price_type constant -amount_type all_1\n./gen -n 100000 -price_type random -amount_type all_max\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:04.364181",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "588/B",
      "title": "B. Duff in Love",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first and only line of input contains one integer, n (1 ≤ n ≤ 1012).",
      "output_spec": "OutputPrint the answer in one line.",
      "sample_tests": "ExamplesInputCopy10OutputCopy10InputCopy12OutputCopy6",
      "description": "B. Duff in Love\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first and only line of input contains one integer, n (1 ≤ n ≤ 1012).\n\nOutputPrint the answer in one line.\n\nInputCopy10OutputCopy10InputCopy12OutputCopy6\n\nInputCopy10\n\nOutputCopy10\n\nInputCopy12\n\nOutputCopy6\n\nNoteIn first sample case, there are numbers 1, 2, 5 and 10 in the shop. 10 isn't divisible by any perfect square, so 10 is lovely.In second sample case, there are numbers 1, 2, 3, 4, 6 and 12 in the shop. 12 is divisible by 4 = 22, so 12 is not lovely, while 6 is indeed lovely.",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 1000000000000LL, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    long long n = opt<long long>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    \n    if (n == -1) {\n        if (type == \"random\") {\n            n = rnd.next(1LL, 1000000000000LL); // 1 ≤ n ≤ 10^12\n        } else if (type == \"square\") {\n            // Generate n as a perfect square\n            long long max_x = (long long)sqrt(1000000000000LL);\n            long long x = rnd.next(1LL, max_x);\n            n = x * x;\n        } else if (type == \"square_free\") {\n            // Generate n as a square-free number (product of distinct primes)\n            const int MAX_PRIME = 1000000;\n            vector<int> primes;\n            vector<bool> is_prime(MAX_PRIME + 1, true);\n            for (int i = 2; i <= MAX_PRIME; i++) {\n                if (is_prime[i]) {\n                    primes.push_back(i);\n                    if (1LL * i * i <= MAX_PRIME) {\n                        for (int j = i * i; j <= MAX_PRIME; j += i)\n                            is_prime[j] = false;\n                    }\n                }\n            }\n            shuffle(primes.begin(), primes.end());\n            n = 1;\n            for (size_t i = 0; i < primes.size(); i++) {\n                if (rnd.next(0, 1)) {\n                    n *= primes[i];\n                    if (n > 1000000000000LL) {\n                        n /= primes[i];\n                        break;\n                    }\n                }\n            }\n            if (n == 1) n = 2; // Ensure n ≥ 2\n        } else if (type == \"product_of_squares\") {\n            // Generate n as a product of squares\n            long long max_x = (long long)pow(1000000000000LL, 1.0 / 6.0);\n            vector<long long> x_values;\n            for (int i = 0; i < 3; i++) {\n                long long x = rnd.next(2LL, max_x);\n                x_values.push_back(x);\n            }\n            n = 1;\n            for (auto x : x_values) {\n                n *= x * x;\n                if (n > 1000000000000LL) {\n                    n /= x * x;\n                    break;\n                }\n            }\n            if (n == 1) n = 4; // Ensure n ≥ 4\n        } else if (type == \"max\") {\n            n = 1000000000000LL;\n        } else if (type == \"min\") {\n            n = 1LL;\n        } else {\n            n = rnd.next(1LL, 1000000000000LL);\n        }\n    }\n    // Ensure n is within the allowed range\n    n = max(1LL, min(n, 1000000000000LL));\n    // Output n\n    printf(\"%lld\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    long long n = opt<long long>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    \n    if (n == -1) {\n        if (type == \"random\") {\n            n = rnd.next(1LL, 1000000000000LL); // 1 ≤ n ≤ 10^12\n        } else if (type == \"square\") {\n            // Generate n as a perfect square\n            long long max_x = (long long)sqrt(1000000000000LL);\n            long long x = rnd.next(1LL, max_x);\n            n = x * x;\n        } else if (type == \"square_free\") {\n            // Generate n as a square-free number (product of distinct primes)\n            const int MAX_PRIME = 1000000;\n            vector<int> primes;\n            vector<bool> is_prime(MAX_PRIME + 1, true);\n            for (int i = 2; i <= MAX_PRIME; i++) {\n                if (is_prime[i]) {\n                    primes.push_back(i);\n                    if (1LL * i * i <= MAX_PRIME) {\n                        for (int j = i * i; j <= MAX_PRIME; j += i)\n                            is_prime[j] = false;\n                    }\n                }\n            }\n            shuffle(primes.begin(), primes.end());\n            n = 1;\n            for (size_t i = 0; i < primes.size(); i++) {\n                if (rnd.next(0, 1)) {\n                    n *= primes[i];\n                    if (n > 1000000000000LL) {\n                        n /= primes[i];\n                        break;\n                    }\n                }\n            }\n            if (n == 1) n = 2; // Ensure n ≥ 2\n        } else if (type == \"product_of_squares\") {\n            // Generate n as a product of squares\n            long long max_x = (long long)pow(1000000000000LL, 1.0 / 6.0);\n            vector<long long> x_values;\n            for (int i = 0; i < 3; i++) {\n                long long x = rnd.next(2LL, max_x);\n                x_values.push_back(x);\n            }\n            n = 1;\n            for (auto x : x_values) {\n                n *= x * x;\n                if (n > 1000000000000LL) {\n                    n /= x * x;\n                    break;\n                }\n            }\n            if (n == 1) n = 4; // Ensure n ≥ 4\n        } else if (type == \"max\") {\n            n = 1000000000000LL;\n        } else if (type == \"min\") {\n            n = 1LL;\n        } else {\n            n = rnd.next(1LL, 1000000000000LL);\n        }\n    }\n    // Ensure n is within the allowed range\n    n = max(1LL, min(n, 1000000000000LL));\n    // Output n\n    printf(\"%lld\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Edge cases\n./gen -n 1\n./gen -n 1000000000000\n\n# Random n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Square numbers\n./gen -type square\n./gen -type square\n./gen -type square\n\n# Square-free numbers\n./gen -type square_free\n./gen -type square_free\n./gen -type square_free\n\n# Product of squares\n./gen -type product_of_squares\n./gen -type product_of_squares\n./gen -type product_of_squares\n\n# Specific small numbers\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 6\n\n# Specific large square number\n./gen -n 999950884081  # 999975^2\n\n# Specific large square-free number\n./gen -n 9999991       # Large prime number\n\n# Specific number with small largest lovely divisor\n./gen -n 1073741824    # 2^30\n\n# Random numbers near limits\n./gen -n 999999999999\n./gen -n 1000000000000\n\n# Additional random numbers\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:06.058950",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "588/C",
      "title": "C. Duff and Weight Lifting",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains integer n (1 ≤ n ≤ 106), the number of weights.The second line contains n integers w1, ..., wn separated by spaces (0 ≤ wi ≤ 106 for each 1 ≤ i ≤ n), the powers of two forming the weights values.",
      "output_spec": "OutputPrint the minimum number of steps in a single line.",
      "sample_tests": "ExamplesInputCopy51 1 2 3 3OutputCopy2InputCopy40 1 2 3OutputCopy4",
      "description": "C. Duff and Weight Lifting\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains integer n (1 ≤ n ≤ 106), the number of weights.The second line contains n integers w1, ..., wn separated by spaces (0 ≤ wi ≤ 106 for each 1 ≤ i ≤ n), the powers of two forming the weights values.\n\nOutputPrint the minimum number of steps in a single line.\n\nInputCopy51 1 2 3 3OutputCopy2InputCopy40 1 2 3OutputCopy4\n\nInputCopy51 1 2 3 3\n\nOutputCopy2\n\nInputCopy40 1 2 3\n\nOutputCopy4\n\nNoteIn the first sample case: One optimal way would be to throw away the first three in the first step and the rest in the second step. Also, it's not possible to do it in one step because their sum is not a power of two.In the second sample case: The only optimal way is to throw away one weight in each step. It's not possible to do it in less than 4 steps because there's no subset of weights with more than one weight and sum equal to a power of two.",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 0, 1000000, \"w_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 0, 1000000, \"w_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 0, 1000000, \"w_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int max_w = opt<int>(\"max_w\", 1000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> w;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            w.push_back(rnd.next(0, max_w));\n        }\n    } else if (type == \"max_exponent\") {\n        for (int i = 0; i < n; ++i) {\n            w.push_back(max_w);\n        }\n    } else if (type == \"min_exponent\") {\n        for (int i = 0; i < n; ++i) {\n            w.push_back(0);\n        }\n    } else if (type == \"same_exponent\") {\n        int ex = rnd.next(0, max_w);\n        for (int i = 0; i < n; ++i) {\n            w.push_back(ex);\n        }\n    } else if (type == \"distinct_exponents\") {\n        if (n > max_w + 1) {\n            fprintf(stderr, \"n is too large for distinct exponents with max_w = %d\\n\", max_w);\n            exit(1);\n        }\n        vector<int> exponents(max_w + 1);\n        iota(exponents.begin(), exponents.end(), 0);\n        shuffle(exponents.begin(), exponents.end());\n        w.assign(exponents.begin(), exponents.begin() + n);\n    } else if (type == \"counts_powers\") {\n        vector<int> exponents;\n        for (int i = 0; i <= max_w; ++i) exponents.push_back(i);\n        shuffle(exponents.begin(), exponents.end());\n        int idx = 0;\n        while ((int)w.size() < n) {\n            if (idx >= (int)exponents.size()) idx = 0;\n            int ex = exponents[idx++];\n            int c = 1 << rnd.next(0, 10); // counts of powers of two from 1 to 1024\n            for (int i = 0; i < c && (int)w.size() < n; ++i) {\n                w.push_back(ex);\n            }\n        }\n        shuffle(w.begin(), w.end());\n        w.resize(n); // Ensure size is exactly n\n    } else if (type == \"counts_not_powers\") {\n        vector<int> exponents;\n        for (int i = 0; i <= max_w; ++i) exponents.push_back(i);\n        shuffle(exponents.begin(), exponents.end());\n        int idx = 0;\n        while ((int)w.size() < n) {\n            if (idx >= (int)exponents.size()) idx = 0;\n            int ex = exponents[idx++];\n            int c = rnd.next(1, 1000); // Counts between 1 and 1000\n            if ((c & (c - 1)) == 0) {\n                c += 1;\n                if(c > 1000) c -= 2; // Keep c in range [1,1000]\n            }\n            for (int i = 0; i < c && (int)w.size() < n; ++i) {\n                w.push_back(ex);\n            }\n        }\n        shuffle(w.begin(), w.end());\n        w.resize(n); // Ensure size is exactly n\n    } else {\n        for (int i = 0; i < n; ++i) {\n            w.push_back(rnd.next(0, max_w));\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", w[i], i == n -1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int max_w = opt<int>(\"max_w\", 1000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> w;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            w.push_back(rnd.next(0, max_w));\n        }\n    } else if (type == \"max_exponent\") {\n        for (int i = 0; i < n; ++i) {\n            w.push_back(max_w);\n        }\n    } else if (type == \"min_exponent\") {\n        for (int i = 0; i < n; ++i) {\n            w.push_back(0);\n        }\n    } else if (type == \"same_exponent\") {\n        int ex = rnd.next(0, max_w);\n        for (int i = 0; i < n; ++i) {\n            w.push_back(ex);\n        }\n    } else if (type == \"distinct_exponents\") {\n        if (n > max_w + 1) {\n            fprintf(stderr, \"n is too large for distinct exponents with max_w = %d\\n\", max_w);\n            exit(1);\n        }\n        vector<int> exponents(max_w + 1);\n        iota(exponents.begin(), exponents.end(), 0);\n        shuffle(exponents.begin(), exponents.end());\n        w.assign(exponents.begin(), exponents.begin() + n);\n    } else if (type == \"counts_powers\") {\n        vector<int> exponents;\n        for (int i = 0; i <= max_w; ++i) exponents.push_back(i);\n        shuffle(exponents.begin(), exponents.end());\n        int idx = 0;\n        while ((int)w.size() < n) {\n            if (idx >= (int)exponents.size()) idx = 0;\n            int ex = exponents[idx++];\n            int c = 1 << rnd.next(0, 10); // counts of powers of two from 1 to 1024\n            for (int i = 0; i < c && (int)w.size() < n; ++i) {\n                w.push_back(ex);\n            }\n        }\n        shuffle(w.begin(), w.end());\n        w.resize(n); // Ensure size is exactly n\n    } else if (type == \"counts_not_powers\") {\n        vector<int> exponents;\n        for (int i = 0; i <= max_w; ++i) exponents.push_back(i);\n        shuffle(exponents.begin(), exponents.end());\n        int idx = 0;\n        while ((int)w.size() < n) {\n            if (idx >= (int)exponents.size()) idx = 0;\n            int ex = exponents[idx++];\n            int c = rnd.next(1, 1000); // Counts between 1 and 1000\n            if ((c & (c - 1)) == 0) {\n                c += 1;\n                if(c > 1000) c -= 2; // Keep c in range [1,1000]\n            }\n            for (int i = 0; i < c && (int)w.size() < n; ++i) {\n                w.push_back(ex);\n            }\n        }\n        shuffle(w.begin(), w.end());\n        w.resize(n); // Ensure size is exactly n\n    } else {\n        for (int i = 0; i < n; ++i) {\n            w.push_back(rnd.next(0, max_w));\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", w[i], i == n -1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test 1: Minimal n, minimal w_i\n./gen -n 1 -type min_exponent\n\n# Test 2: Minimal n, maximal w_i\n./gen -n 1 -type max_exponent -max_w 1000000\n\n# Test 3: Small n, same exponent\n./gen -n 5 -type same_exponent -max_w 10\n\n# Test 4: Small n, distinct exponents\n./gen -n 5 -type distinct_exponents -max_w 10\n\n# Test 5: Small n, counts_powers\n./gen -n 5 -type counts_powers -max_w 10\n\n# Test 6: Small n, counts_not_powers\n./gen -n 5 -type counts_not_powers -max_w 10\n\n# Test 7: n = 10000, random exponents\n./gen -n 10000 -type random -max_w 100\n\n# Test 8: n = 10000, same exponent\n./gen -n 10000 -type same_exponent -max_w 1000000\n\n# Test 9: n = 100000, counts_powers\n./gen -n 100000 -type counts_powers -max_w 1000000\n\n# Test 10: n = 100000, counts_not_powers\n./gen -n 100000 -type counts_not_powers -max_w 1000000\n\n# Test 11: n = 1000000, same exponent\n./gen -n 1000000 -type same_exponent -max_w 1000000\n\n# Test 12: n = 1000000, distinct exponents\n./gen -n 1000000 -type distinct_exponents -max_w 1000000\n\n# Test 13: n = 1000000, counts_powers\n./gen -n 1000000 -type counts_powers -max_w 1000000\n\n# Test 14: n = 1000000, counts_not_powers\n./gen -n 1000000 -type counts_not_powers -max_w 1000000\n\n# Test 15: n = 1000000, random exponents, small max_w\n./gen -n 1000000 -type random -max_w 10\n\n# Test 16: n = 1000000, random exponents, large max_w\n./gen -n 1000000 -type random -max_w 1000000\n\n# Test 17: n = 1000000, exponents=0\n./gen -n 1000000 -type min_exponent\n\n# Test 18: n = 1000000, exponents=max_w\n./gen -n 1000000 -type max_exponent -max_w 1000000\n\n# Test 19: n = 999999, distinct exponents\n./gen -n 999999 -type distinct_exponents -max_w 999999\n\n# Test 20: n = random small n\n./gen -n 1234 -type random -max_w 1000\n\n# Test 21: n = random medium n\n./gen -n 54321 -type random -max_w 50000\n\n# Test 22: n = random large n\n./gen -n 999999 -type random -max_w 1000000\n\n# Test 23: n = 1000000, random exponents, max_w = 50\n./gen -n 1000000 -type random -max_w 50\n\n# Test 24: n = 1000000, random exponents, max_w = 500\n./gen -n 1000000 -type random -max_w 500\n\n# Test 25: n = 1000000, counts_powers with smaller max_w\n./gen -n 1000000 -type counts_powers -max_w 1000\n\n# Test 26: n = maximum n, maximum w_i\n./gen -n 1000000 -type random -max_w 1000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:07.897239",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "588/D",
      "title": "D. Duff на пляже",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке ввода записано три целых числа, n, l и k (1 ≤ n, k, n × k ≤ 106 and 1 ≤ l ≤ 1018).Во второй строке записано n целых чисел через пробел, a0, a1, ..., an - 1 (1 ≤ ai ≤ 109 для каждого 0 ≤ i ≤ n - 1).",
      "output_spec": "Выходные данныеВыведите ответ по модулю 1 000 000 007.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 5 35 9 1Выходные данныеСкопировать10Входные данныеСкопировать5 10 31 2 3 4 5Выходные данныеСкопировать25",
      "description": "D. Duff на пляже\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке ввода записано три целых числа, n, l и k (1 ≤ n, k, n × k ≤ 106 and 1 ≤ l ≤ 1018).Во второй строке записано n целых чисел через пробел, a0, a1, ..., an - 1 (1 ≤ ai ≤ 109 для каждого 0 ≤ i ≤ n - 1).\n\nВходные данные\n\nВыходные данныеВыведите ответ по модулю 1 000 000 007.\n\nВыходные данные\n\nВходные данныеСкопировать3 5 35 9 1Выходные данныеСкопировать10Входные данныеСкопировать5 10 31 2 3 4 5Выходные данныеСкопировать25\n\nВходные данныеСкопировать3 5 35 9 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 10 31 2 3 4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать25\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте . Таким образом, все такие последовательности: , , , , , , , ,  and .",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    ensuref(1LL * n * k <= 1000000LL, \"n * k must be <= 1e6, but n = %d, k = %d, n*k = %lld\", n, k, 1LL * n * k);\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    ensuref(1LL * n * k <= 1000000LL, \"n * k must be <= 1e6, but n = %d, k = %d, n*k = %lld\", n, k, 1LL * n * k);\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    long long l = inf.readLong(1LL, 1000000000000000000LL, \"l\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    ensuref(1LL * n * k <= 1000000LL, \"n * k must be <= 1e6, but n = %d, k = %d, n*k = %lld\", n, k, 1LL * n * k);\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    long long l = opt<long long>(\"l\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output n, l, k\n    printf(\"%d %lld %d\\n\", n, l, k);\n\n    vector<int> a(n);\n\n    if (type == \"same\") {\n        // All elements are the same\n        int val = opt<int>(\"val\", 1);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"increasing\") {\n        // Increasing sequence\n        int start = opt<int>(\"start\", 1);\n        int step = opt<int>(\"step\", 1);\n        for (int i = 0; i < n; ++i)\n            a[i] = start + i * step;\n    } else if (type == \"decreasing\") {\n        // Decreasing sequence\n        int start = opt<int>(\"start\", int(1e9));\n        int step = opt<int>(\"step\", 1);\n        for (int i = 0; i < n; ++i)\n            a[i] = start - i * step;\n    } else {\n        // Random sequence\n        int min_ai = opt<int>(\"min_ai\", 1);\n        int max_ai = opt<int>(\"max_ai\", int(1e9));\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(min_ai, max_ai);\n    }\n\n    // Output array a\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    long long l = opt<long long>(\"l\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output n, l, k\n    printf(\"%d %lld %d\\n\", n, l, k);\n\n    vector<int> a(n);\n\n    if (type == \"same\") {\n        // All elements are the same\n        int val = opt<int>(\"val\", 1);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"increasing\") {\n        // Increasing sequence\n        int start = opt<int>(\"start\", 1);\n        int step = opt<int>(\"step\", 1);\n        for (int i = 0; i < n; ++i)\n            a[i] = start + i * step;\n    } else if (type == \"decreasing\") {\n        // Decreasing sequence\n        int start = opt<int>(\"start\", int(1e9));\n        int step = opt<int>(\"step\", 1);\n        for (int i = 0; i < n; ++i)\n            a[i] = start - i * step;\n    } else {\n        // Random sequence\n        int min_ai = opt<int>(\"min_ai\", 1);\n        int max_ai = opt<int>(\"max_ai\", int(1e9));\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(min_ai, max_ai);\n    }\n\n    // Output array a\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], \" \\n\"[i == n - 1]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, small k, small l\n./gen -n 1 -l 1 -k 1 -type same -val 1\n./gen -n 2 -l 2 -k 2 -type increasing -start 1 -step 1\n./gen -n 3 -l 3 -k 1 -type decreasing -start 3 -step 1\n./gen -n 5 -l 5 -k 5 -type random -min_ai 1 -max_ai 5\n\n# Small n, small k, large l\n./gen -n 1 -l 1000000000000000000 -k 1 -type same -val 1\n./gen -n 2 -l 1000000000000000000 -k 2 -type increasing -start 1 -step 1\n\n# n x k near 10^6\n./gen -n 1000 -l 1000000 -k 1000 -type random\n./gen -n 500 -l 2000000 -k 500 -type random\n\n# n = 1, k = 1e6\n./gen -n 1 -l 1000000 -k 1000000 -type same -val 1\n\n# n = 10^6, k = 1\n./gen -n 1000000 -l 100000000 -k 1 -type random\n\n# All a_i = 1\n./gen -n 1000000 -l 1000000000000000000 -k 1 -type same -val 1\n\n# Increasing a_i\n./gen -n 1000 -l 1000000 -k 1000 -type increasing -start 1 -step 1\n\n# Decreasing a_i\n./gen -n 1000 -l 1000000 -k 1000 -type decreasing -start 1000000 -step 1\n\n# Maximum l\n./gen -n 1 -l 1000000000000000000 -k 1 -type random\n\n# Random a_i with min_ai = 1e9\n./gen -n 10000 -l 1000000000000000000 -k 100 -type random -min_ai 1000000000 -max_ai 1000000000\n\n# Small l\n./gen -n 1000 -l 1 -k 1000 -type random\n\n# n equals k\n./gen -n 1000 -l 1000000 -k 1000 -type random\n\n# l is not multiple of n\n./gen -n 1000 -l 1234567 -k 1000 -type random\n\n# l is a multiple of n\n./gen -n 1000 -l 1000000 -k 1000 -type random\n\n# Random small a_i\n./gen -n 1000 -l 1000000 -k 1000 -type random -min_ai 1 -max_ai 10\n\n# Random large a_i\n./gen -n 1000 -l 1000000 -k 1000 -type random -min_ai 1000000000 -max_ai 1000000000\n\n# n = 999, k = 1001 (n * k = 999999)\n./gen -n 999 -l 1000000 -k 1001 -type random\n\n# Maximum possible n and k\n./gen -n 1000 -l 1000000 -k 1000 -type random\n\n# l small, n and k large\n./gen -n 1000 -l 100 -k 1000 -type random\n\n# n x k equals 10^6\n./gen -n 1000 -l 1000000 -k 1000 -type random\n\n# n maximum, k minimum\n./gen -n 1000000 -l 100000000 -k 1 -type random\n\n# k maximum, n minimum\n./gen -n 1 -l 1000000 -k 1000000 -type random\n\n# All possible combinations with n * k = 10^6\n./gen -n 1 -l 1000000 -k 1000000 -type random\n./gen -n 2 -l 500000 -k 500000 -type random\n./gen -n 4 -l 250000 -k 250000 -type random\n./gen -n 5 -l 200000 -k 200000 -type random\n./gen -n 10 -l 100000 -k 100000 -type random\n./gen -n 20 -l 50000 -k 50000 -type random\n./gen -n 40 -l 25000 -k 25000 -type random\n./gen -n 100 -l 10000 -k 10000 -type random\n./gen -n 200 -l 5000 -k 5000 -type random\n./gen -n 1000 -l 1000 -k 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:10.092951",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "588/E",
      "title": "E. Duff in the Army",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line of input contains three integers, n, m and q (1 ≤ n, m, q ≤ 105).The next n - 1 lines contain the roads. Each line contains two integers v and u, endpoints of a road (1 ≤ v, u ≤ n, v ≠ u).Next line contains m integers c1, c2, ..., cm separated by spaces (1 ≤ ci ≤ n for each 1 ≤ i ≤ m).Next q lines contain the queries. Each of them contains three integers, v, u and a (1 ≤ v, u ≤ n and 1 ≤ a ≤ 10).",
      "output_spec": "OutputFor each query, print numbers k, p1, p2, ..., pk separated by spaces in one line.",
      "sample_tests": "ExamplesInputCopy5 4 51 31 21 44 52 1 4 34 5 61 5 25 5 102 3 35 3 1OutputCopy1 32 2 303 1 2 41 2",
      "description": "E. Duff in the Army\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains three integers, n, m and q (1 ≤ n, m, q ≤ 105).The next n - 1 lines contain the roads. Each line contains two integers v and u, endpoints of a road (1 ≤ v, u ≤ n, v ≠ u).Next line contains m integers c1, c2, ..., cm separated by spaces (1 ≤ ci ≤ n for each 1 ≤ i ≤ m).Next q lines contain the queries. Each of them contains three integers, v, u and a (1 ≤ v, u ≤ n and 1 ≤ a ≤ 10).\n\nOutputFor each query, print numbers k, p1, p2, ..., pk separated by spaces in one line.\n\nInputCopy5 4 51 31 21 44 52 1 4 34 5 61 5 25 5 102 3 35 3 1OutputCopy1 32 2 303 1 2 41 2\n\nInputCopy5 4 51 31 21 44 52 1 4 34 5 61 5 25 5 102 3 35 3 1\n\nOutputCopy1 32 2 303 1 2 41 2\n\nNoteGraph of Andarz Gu in the sample case is as follows (ID of people in each city are written next to them):",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MAXQ = 100000;\n\nint parent[MAXN+1]; // DSU parent array\n\nint find(int x) {\n    if (parent[x] != x) \n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    int rx = find(x);\n    int ry = find(y);\n    if (rx == ry) \n        return false; // Already connected\n    parent[ry] = rx;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, q\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAXM, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, MAXQ, \"q\");\n    inf.readEoln();\n\n    // Initialize DSU\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    set<pair<int,int>> edges;\n\n    for (int i = 1; i <= n - 1; ++i) {\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readEoln();\n\n        ensuref(v != u, \"Edge #%d is a self-loop at node %d\", i, v);\n\n        pair<int,int> edge = make_pair(min(v, u), max(v, u));\n        ensuref(edges.count(edge) == 0, \"Edge between %d and %d appears multiple times\", v, u);\n        edges.insert(edge);\n\n        // Union in DSU\n        bool merged = unite(v, u);\n        ensuref(merged, \"Adding edge #%d between %d and %d creates a cycle\", i, v, u);\n    }\n\n    // Ensure the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected, node %d is in a different component\", i);\n    }\n\n    // Read c_1 to c_m\n    vector<int> c = inf.readInts(m, 1, n, \"c\");\n    inf.readEoln();\n\n    // Read q queries\n    for (int i = 1; i <= q; ++i) {\n        int v = inf.readInt(1, n, \"v_qi\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u_qi\");\n        inf.readSpace();\n        int a = inf.readInt(1, 10, \"a_qi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MAXQ = 100000;\n\nint parent[MAXN+1]; // DSU parent array\n\nint find(int x) {\n    if (parent[x] != x) \n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    int rx = find(x);\n    int ry = find(y);\n    if (rx == ry) \n        return false; // Already connected\n    parent[ry] = rx;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, q\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAXM, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, MAXQ, \"q\");\n    inf.readEoln();\n\n    // Initialize DSU\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    set<pair<int,int>> edges;\n\n    for (int i = 1; i <= n - 1; ++i) {\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readEoln();\n\n        ensuref(v != u, \"Edge #%d is a self-loop at node %d\", i, v);\n\n        pair<int,int> edge = make_pair(min(v, u), max(v, u));\n        ensuref(edges.count(edge) == 0, \"Edge between %d and %d appears multiple times\", v, u);\n        edges.insert(edge);\n\n        // Union in DSU\n        bool merged = unite(v, u);\n        ensuref(merged, \"Adding edge #%d between %d and %d creates a cycle\", i, v, u);\n    }\n\n    // Ensure the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected, node %d is in a different component\", i);\n    }\n\n    // Read c_1 to c_m\n    vector<int> c = inf.readInts(m, 1, n, \"c\");\n    inf.readEoln();\n\n    // Read q queries\n    for (int i = 1; i <= q; ++i) {\n        int v = inf.readInt(1, n, \"v_qi\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u_qi\");\n        inf.readSpace();\n        int a = inf.readInt(1, 10, \"a_qi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MAXQ = 100000;\n\nint parent[MAXN+1]; // DSU parent array\n\nint find(int x) {\n    if (parent[x] != x) \n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nbool unite(int x, int y) {\n    int rx = find(x);\n    int ry = find(y);\n    if (rx == ry) \n        return false; // Already connected\n    parent[ry] = rx;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n, m, q\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAXM, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, MAXQ, \"q\");\n    inf.readEoln();\n\n    // Initialize DSU\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    set<pair<int,int>> edges;\n\n    for (int i = 1; i <= n - 1; ++i) {\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readEoln();\n\n        ensuref(v != u, \"Edge #%d is a self-loop at node %d\", i, v);\n\n        pair<int,int> edge = make_pair(min(v, u), max(v, u));\n        ensuref(edges.count(edge) == 0, \"Edge between %d and %d appears multiple times\", v, u);\n        edges.insert(edge);\n\n        // Union in DSU\n        bool merged = unite(v, u);\n        ensuref(merged, \"Adding edge #%d between %d and %d creates a cycle\", i, v, u);\n    }\n\n    // Ensure the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected, node %d is in a different component\", i);\n    }\n\n    // Read c_1 to c_m\n    vector<int> c = inf.readInts(m, 1, n, \"c\");\n    inf.readEoln();\n\n    // Read q queries\n    for (int i = 1; i <= q; ++i) {\n        int v = inf.readInt(1, n, \"v_qi\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u_qi\");\n        inf.readSpace();\n        int a = inf.readInt(1, 10, \"a_qi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int u, v;\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n); // Default to n\n    int q = opt<int>(\"q\");\n    string treeType = opt<string>(\"treeType\", \"random\");\n    string peopleDistribution = opt<string>(\"peopleDistribution\", \"random\");\n    string queryType = opt<string>(\"queryType\", \"random\");\n\n    // Now generate data accordingly\n    vector<Edge> edges;\n    vector<int> parent(n + 1);\n    // Build the tree\n    if (treeType == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n            parent[i] = i - 1;\n        }\n    } else if (treeType == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n            parent[i] = 1;\n        }\n    } else if (treeType == \"balanced\") {\n        for (int i = 2; i <= n; ++i) {\n            int par = i / 2;\n            edges.push_back({par, i});\n            parent[i] = par;\n        }\n    } else if (treeType == \"random\") {\n        for (int i = 2; i <= n; ++i) {\n            int par = rnd.next(1, i - 1);\n            edges.push_back({par, i});\n            parent[i] = par;\n        }\n    } else {\n        // Default to random\n        for (int i = 2; i <= n; ++i) {\n            int par = rnd.next(1, i - 1);\n            edges.push_back({par, i});\n            parent[i] = par;\n        }\n    }\n\n    // Optional: shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n, m, q\n    printf(\"%d %d %d\\n\", n, m, q);\n\n    // Output the edges\n    for (const auto& e : edges) {\n        printf(\"%d %d\\n\", e.u, e.v);\n    }\n\n    // Now assign people to cities\n    vector<int> c(m + 1); // c[1..m]\n    if (peopleDistribution == \"one_each\") {\n        // Assign each person to a unique city\n        if (m > n) {\n            // Can't assign more people than cities\n            // Assign first n people to unique cities, rest randomly\n            vector<int> perm(n);\n            for (int i = 1; i <= n; ++i)\n                perm[i - 1] = i;\n            shuffle(perm.begin(), perm.end());\n            for (int i = 1; i <= n; ++i) {\n                c[i] = perm[i - 1];\n            }\n            for (int i = n + 1; i <= m; ++i) {\n                c[i] = rnd.next(1, n);\n            }\n        } else {\n            vector<int> perm(n);\n            for (int i = 1; i <= n; ++i)\n                perm[i - 1] = i;\n            shuffle(perm.begin(), perm.end());\n            for (int i = 1; i <= m; ++i) {\n                c[i] = perm[i - 1];\n            }\n        }\n    } else if (peopleDistribution == \"all_one_city\") {\n        // Assign all people to city 1\n        for (int i = 1; i <= m; ++i) {\n            c[i] = 1;\n        }\n    } else if (peopleDistribution == \"random\") {\n        // Assign people randomly to cities\n        for (int i = 1; i <= m; ++i) {\n            c[i] = rnd.next(1, n);\n        }\n    } else if (peopleDistribution == \"leaves\") {\n        // Assign people only to leaf nodes (nodes with degree 1)\n        vector<int> degree(n + 1, 0);\n        for (const auto& e : edges) {\n            degree[e.u]++;\n            degree[e.v]++;\n        }\n        vector<int> leaves;\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1) {\n                leaves.push_back(i);\n            }\n        }\n        // If not enough leaves, fall back to random\n        if (leaves.size() == 0) {\n            for (int i = 1; i <= m; ++i) {\n                c[i] = rnd.next(1, n);\n            }\n        } else {\n            for (int i = 1; i <= m; ++i) {\n                c[i] = leaves[rnd.next(0, (int)leaves.size() - 1)];\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 1; i <= m; ++i) {\n            c[i] = rnd.next(1, n);\n        }\n    }\n\n    // Output the ci's\n    for (int i = 1; i <= m; ++i) {\n        printf(\"%d\", c[i]);\n        if (i != m) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Now generate queries\n\n    // Query format: v u a\n\n    vector<tuple<int, int, int>> queries;\n\n    if (queryType == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int u = rnd.next(1, n);\n            int a = rnd.next(1, 10);\n            queries.push_back(make_tuple(v, u, a));\n        }\n    } else if (queryType == \"distant\") {\n        // Try to choose v and u that are far apart\n        // For chain tree, v=1, u=n\n        if (treeType == \"chain\") {\n            int v = 1;\n            int u = n;\n            for (int i = 0; i < q; ++i) {\n                int a = rnd.next(1, 10);\n                queries.push_back(make_tuple(v, u, a));\n            }\n        } else {\n            // For random tree, we can try to approximate diameters\n            // But it's complex, so we'll select random nodes\n            for (int i = 0; i < q; ++i) {\n                int v = rnd.next(1, n);\n                int u = rnd.next(1, n);\n                int a = rnd.next(1, 10);\n                queries.push_back(make_tuple(v, u, a));\n            }\n        }\n    } else if (queryType == \"same\") {\n        // v == u\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int a = rnd.next(1, 10);\n            queries.push_back(make_tuple(v, v, a));\n        }\n    } else if (queryType == \"max_a\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int u = rnd.next(1, n);\n            int a = 10;\n            queries.push_back(make_tuple(v, u, a));\n        }\n    } else if (queryType == \"min_a\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int u = rnd.next(1, n);\n            int a = 1;\n            queries.push_back(make_tuple(v, u, a));\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int u = rnd.next(1, n);\n            int a = rnd.next(1, 10);\n            queries.push_back(make_tuple(v, u, a));\n        }\n    }\n\n    // Output queries\n    for (const auto& query : queries) {\n        int v, u, a;\n        tie(v, u, a) = query;\n        printf(\"%d %d %d\\n\", v, u, a);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int u, v;\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n); // Default to n\n    int q = opt<int>(\"q\");\n    string treeType = opt<string>(\"treeType\", \"random\");\n    string peopleDistribution = opt<string>(\"peopleDistribution\", \"random\");\n    string queryType = opt<string>(\"queryType\", \"random\");\n\n    // Now generate data accordingly\n    vector<Edge> edges;\n    vector<int> parent(n + 1);\n    // Build the tree\n    if (treeType == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n            parent[i] = i - 1;\n        }\n    } else if (treeType == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n            parent[i] = 1;\n        }\n    } else if (treeType == \"balanced\") {\n        for (int i = 2; i <= n; ++i) {\n            int par = i / 2;\n            edges.push_back({par, i});\n            parent[i] = par;\n        }\n    } else if (treeType == \"random\") {\n        for (int i = 2; i <= n; ++i) {\n            int par = rnd.next(1, i - 1);\n            edges.push_back({par, i});\n            parent[i] = par;\n        }\n    } else {\n        // Default to random\n        for (int i = 2; i <= n; ++i) {\n            int par = rnd.next(1, i - 1);\n            edges.push_back({par, i});\n            parent[i] = par;\n        }\n    }\n\n    // Optional: shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output n, m, q\n    printf(\"%d %d %d\\n\", n, m, q);\n\n    // Output the edges\n    for (const auto& e : edges) {\n        printf(\"%d %d\\n\", e.u, e.v);\n    }\n\n    // Now assign people to cities\n    vector<int> c(m + 1); // c[1..m]\n    if (peopleDistribution == \"one_each\") {\n        // Assign each person to a unique city\n        if (m > n) {\n            // Can't assign more people than cities\n            // Assign first n people to unique cities, rest randomly\n            vector<int> perm(n);\n            for (int i = 1; i <= n; ++i)\n                perm[i - 1] = i;\n            shuffle(perm.begin(), perm.end());\n            for (int i = 1; i <= n; ++i) {\n                c[i] = perm[i - 1];\n            }\n            for (int i = n + 1; i <= m; ++i) {\n                c[i] = rnd.next(1, n);\n            }\n        } else {\n            vector<int> perm(n);\n            for (int i = 1; i <= n; ++i)\n                perm[i - 1] = i;\n            shuffle(perm.begin(), perm.end());\n            for (int i = 1; i <= m; ++i) {\n                c[i] = perm[i - 1];\n            }\n        }\n    } else if (peopleDistribution == \"all_one_city\") {\n        // Assign all people to city 1\n        for (int i = 1; i <= m; ++i) {\n            c[i] = 1;\n        }\n    } else if (peopleDistribution == \"random\") {\n        // Assign people randomly to cities\n        for (int i = 1; i <= m; ++i) {\n            c[i] = rnd.next(1, n);\n        }\n    } else if (peopleDistribution == \"leaves\") {\n        // Assign people only to leaf nodes (nodes with degree 1)\n        vector<int> degree(n + 1, 0);\n        for (const auto& e : edges) {\n            degree[e.u]++;\n            degree[e.v]++;\n        }\n        vector<int> leaves;\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1) {\n                leaves.push_back(i);\n            }\n        }\n        // If not enough leaves, fall back to random\n        if (leaves.size() == 0) {\n            for (int i = 1; i <= m; ++i) {\n                c[i] = rnd.next(1, n);\n            }\n        } else {\n            for (int i = 1; i <= m; ++i) {\n                c[i] = leaves[rnd.next(0, (int)leaves.size() - 1)];\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 1; i <= m; ++i) {\n            c[i] = rnd.next(1, n);\n        }\n    }\n\n    // Output the ci's\n    for (int i = 1; i <= m; ++i) {\n        printf(\"%d\", c[i]);\n        if (i != m) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Now generate queries\n\n    // Query format: v u a\n\n    vector<tuple<int, int, int>> queries;\n\n    if (queryType == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int u = rnd.next(1, n);\n            int a = rnd.next(1, 10);\n            queries.push_back(make_tuple(v, u, a));\n        }\n    } else if (queryType == \"distant\") {\n        // Try to choose v and u that are far apart\n        // For chain tree, v=1, u=n\n        if (treeType == \"chain\") {\n            int v = 1;\n            int u = n;\n            for (int i = 0; i < q; ++i) {\n                int a = rnd.next(1, 10);\n                queries.push_back(make_tuple(v, u, a));\n            }\n        } else {\n            // For random tree, we can try to approximate diameters\n            // But it's complex, so we'll select random nodes\n            for (int i = 0; i < q; ++i) {\n                int v = rnd.next(1, n);\n                int u = rnd.next(1, n);\n                int a = rnd.next(1, 10);\n                queries.push_back(make_tuple(v, u, a));\n            }\n        }\n    } else if (queryType == \"same\") {\n        // v == u\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int a = rnd.next(1, 10);\n            queries.push_back(make_tuple(v, v, a));\n        }\n    } else if (queryType == \"max_a\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int u = rnd.next(1, n);\n            int a = 10;\n            queries.push_back(make_tuple(v, u, a));\n        }\n    } else if (queryType == \"min_a\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int u = rnd.next(1, n);\n            int a = 1;\n            queries.push_back(make_tuple(v, u, a));\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int u = rnd.next(1, n);\n            int a = rnd.next(1, 10);\n            queries.push_back(make_tuple(v, u, a));\n        }\n    }\n\n    // Output queries\n    for (const auto& query : queries) {\n        int v, u, a;\n        tie(v, u, a) = query;\n        printf(\"%d %d %d\\n\", v, u, a);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, small m, small q\n./gen -n 5 -m 5 -q 5 -treeType chain -peopleDistribution one_each -queryType random\n./gen -n 5 -m 5 -q 5 -treeType star -peopleDistribution all_one_city -queryType same\n./gen -n 5 -m 5 -q 5 -treeType balanced -peopleDistribution random -queryType max_a\n\n# Medium n, varying tree types\n./gen -n 100 -m 50 -q 100 -treeType chain -peopleDistribution random -queryType random\n./gen -n 100 -m 50 -q 100 -treeType star -peopleDistribution one_each -queryType min_a\n./gen -n 100 -m 50 -q 100 -treeType balanced -peopleDistribution leaves -queryType random\n\n# Large n, m, q, random tree\n./gen -n 100000 -m 100000 -q 100000 -treeType random -peopleDistribution random -queryType random\n\n# Large n, minimal a\n./gen -n 100000 -m 100000 -q 100000 -treeType chain -peopleDistribution random -queryType min_a\n\n# Large n, maximum a\n./gen -n 100000 -m 100000 -q 100000 -treeType chain -peopleDistribution random -queryType max_a\n\n# Large n, people in leaves\n./gen -n 100000 -m 100000 -q 100000 -treeType balanced -peopleDistribution leaves -queryType distant\n\n# Star tree, all people in one city\n./gen -n 100000 -m 100000 -q 100000 -treeType star -peopleDistribution all_one_city -queryType random\n\n# Small n, all people in one city\n./gen -n 10 -m 10 -q 10 -treeType random -peopleDistribution all_one_city -queryType random\n\n# Edge case: n = 1\n./gen -n 1 -m 1 -q 1 -treeType chain -peopleDistribution random -queryType random\n\n# Edge case: v = u in queries\n./gen -n 1000 -m 500 -q 1000 -treeType random -peopleDistribution random -queryType same\n\n# Edge case: m = n\n./gen -n 100000 -m 100000 -q 100000 -treeType random -peopleDistribution one_each -queryType random\n\n# Edge case: m < n\n./gen -n 100000 -m 50000 -q 100000 -treeType random -peopleDistribution random -queryType random\n\n# Edge case: m > n\n./gen -n 50000 -m 100000 -q 100000 -treeType random -peopleDistribution random -queryType random\n\n# Edge case: chain tree, distant queries\n./gen -n 100000 -m 100000 -q 100000 -treeType chain -peopleDistribution random -queryType distant\n\n# Edge case: star tree, distant queries\n./gen -n 100000 -m 100000 -q 100000 -treeType star -peopleDistribution random -queryType distant\n\n# Edge case: balanced tree, distant queries\n./gen -n 100000 -m 100000 -q 100000 -treeType balanced -peopleDistribution random -queryType distant\n\n# Edge case: maximum a=10 in all queries\n./gen -n 100000 -m 100000 -q 100000 -treeType random -peopleDistribution random -queryType max_a\n\n# Edge case: minimal a=1 in all queries\n./gen -n 100000 -m 100000 -q 100000 -treeType random -peopleDistribution random -queryType min_a\n\n# Edge case: m = 1e5, a = 10, to test when x > a\n./gen -n 100000 -m 100000 -q 100000 -treeType random -peopleDistribution random -queryType max_a\n\n# Edge case: m = 10, a = 10, to test when x = a\n./gen -n 1000 -m 10 -q 1000 -treeType random -peopleDistribution random -queryType max_a\n\n# Edge case: m = 5, a = 10, to test when x < a\n./gen -n 1000 -m 5 -q 1000 -treeType random -peopleDistribution random -queryType max_a\n\n# Edge case: n = m = q = 1, minimal sizes\n./gen -n 1 -m 1 -q 1 -treeType chain -peopleDistribution random -queryType random\n\n# Edge case: Queries with v = u = same node\n./gen -n 50000 -m 50000 -q 100000 -treeType random -peopleDistribution random -queryType same\n\n# Edge case: Huge tree with minimal queries\n./gen -n 100000 -m 100000 -q 1 -treeType random -peopleDistribution random -queryType random\n\n# Edge case: Small tree with many queries\n./gen -n 10 -m 10 -q 100000 -treeType random -peopleDistribution random -queryType random\n\n# Edge case: Chain tree with people only on leaves\n./gen -n 100000 -m 100000 -q 100000 -treeType chain -peopleDistribution leaves -queryType random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:12.097274",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "588/F",
      "title": "F. Duff in Mafia",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test6 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two integers n and m (2 ≤ n ≤ 5 × 104 and 1 ≤ m ≤ 5 × 104), number of cities and number of roads in the country.The next m lines contain the the roads. i - th of them contains four integers vi, ui, ci and ti (1 ≤ vi, ui ≤ n, vi ≠ ui and 1 ≤ ci, ti ≤ 109 for each 1 ≤ i ≤ m).",
      "output_spec": "OutputIn the first line of input, print \"Yes\" (without quotes) if satisfying the first condition is possible and \"No\" (without quotes) otherwise.If it is possible, then you have to print two integers t and k in the second line, the minimum destructing time and the number of roads in the matching ().In the third line print k distinct integers separated by spaces, indices of the roads in the matching in any order. Roads are numbered starting from one in order of their appearance in the input.If there's more than one solution, print any of them.",
      "sample_tests": "ExamplesInputCopy5 72 1 3 73 1 1 65 4 1 84 5 1 13 2 2 34 5 2 52 3 2 4OutputCopyYes3 24 5InputCopy3 53 2 1 31 3 1 13 2 1 41 3 2 21 3 2 10OutputCopyNo",
      "description": "F. Duff in Mafia\n\ntime limit per test6 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains two integers n and m (2 ≤ n ≤ 5 × 104 and 1 ≤ m ≤ 5 × 104), number of cities and number of roads in the country.The next m lines contain the the roads. i - th of them contains four integers vi, ui, ci and ti (1 ≤ vi, ui ≤ n, vi ≠ ui and 1 ≤ ci, ti ≤ 109 for each 1 ≤ i ≤ m).\n\nOutputIn the first line of input, print \"Yes\" (without quotes) if satisfying the first condition is possible and \"No\" (without quotes) otherwise.If it is possible, then you have to print two integers t and k in the second line, the minimum destructing time and the number of roads in the matching ().In the third line print k distinct integers separated by spaces, indices of the roads in the matching in any order. Roads are numbered starting from one in order of their appearance in the input.If there's more than one solution, print any of them.\n\nInputCopy5 72 1 3 73 1 1 65 4 1 84 5 1 13 2 2 34 5 2 52 3 2 4OutputCopyYes3 24 5InputCopy3 53 2 1 31 3 1 13 2 1 41 3 2 21 3 2 10OutputCopyNo\n\nInputCopy5 72 1 3 73 1 1 65 4 1 84 5 1 13 2 2 34 5 2 52 3 2 4\n\nOutputCopyYes3 24 5\n\nInputCopy3 53 2 1 31 3 1 13 2 1 41 3 2 21 3 2 10\n\nOutputCopyNo\n\nNoteGraph of Andarz Gu in the first sample case is as follows:  A solution would be to destruct the roads with crosses.Graph of Andarz Gu in the second sample case is as follows:",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(2, 50000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readSpace();\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readSpace();\n        int ti = inf.readInt(1, 1000000000, \"ti\");\n        inf.readEoln();\n\n        // Ensure that vi != ui\n        ensuref(vi != ui, \"Edge %d has vi == ui (%d == %d)\", i+1, vi, ui);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(2, 50000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readSpace();\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readSpace();\n        int ti = inf.readInt(1, 1000000000, \"ti\");\n        inf.readEoln();\n\n        // Ensure that vi != ui\n        ensuref(vi != ui, \"Edge %d has vi == ui (%d == %d)\", i+1, vi, ui);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(2, 50000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readSpace();\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int ci = inf.readInt(1, 1000000000, \"ci\");\n        inf.readSpace();\n        int ti = inf.readInt(1, 1000000000, \"ti\");\n        inf.readEoln();\n\n        // Ensure that vi != ui\n        ensuref(vi != ui, \"Edge %d has vi == ui (%d == %d)\", i+1, vi, ui);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int vi, ui;\n    int ci;\n    int ti;\n};\n\nvoid readAnswer(InStream& stream, bool& isPossible, int& t, vector<int>& selectedEdges, int m) {\n    string verdict = stream.readToken();\n    if (verdict == \"Yes\") {\n        isPossible = true;\n        t = stream.readInt(0, INT_MAX, \"t\"); // t >= 0\n        int k = stream.readInt(0, m, \"k\"); // 0 <= k <= m\n        selectedEdges.resize(k);\n        set<int> usedEdges;\n        for (int i = 0; i < k; ++i) {\n            int edgeIndex = stream.readInt(1, m, format(\"edge index %d\", i+1).c_str());\n            if (usedEdges.count(edgeIndex)) {\n                stream.quitf(_wa, \"Edge index %d is repeated.\", edgeIndex);\n            }\n            usedEdges.insert(edgeIndex);\n            selectedEdges[i] = edgeIndex;\n        }\n    } else if (verdict == \"No\") {\n        isPossible = false;\n    } else {\n        stream.quitf(_pe, \"Expected 'Yes' or 'No', but found '%s'\", verdict.c_str());\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input from inf\n    int n = inf.readInt();\n    int m = inf.readInt();\n\n    vector<Edge> edges(m);\n\n    for (int i = 0; i < m; ++i) {\n        int vi = inf.readInt();\n        int ui = inf.readInt();\n        int ci = inf.readInt();\n        int ti = inf.readInt();\n        edges[i] = {vi, ui, ci, ti};\n    }\n\n    // Read jury's answer\n    bool jury_possible;\n    int jury_t;\n    vector<int> jury_selected_edges;\n\n    readAnswer(ans, jury_possible, jury_t, jury_selected_edges, m);\n\n    // Read participant's answer\n    bool participant_possible;\n    int participant_t;\n    vector<int> participant_selected_edges;\n\n    readAnswer(ouf, participant_possible, participant_t, participant_selected_edges, m);\n\n    // Now compare answers and issue verdicts\n    if (!jury_possible && participant_possible) {\n        quitf(_fail, \"Participant found a solution, but jury says 'No'\");\n    } else if (jury_possible && !participant_possible) {\n        quitf(_wa, \"Participant says 'No', but a solution exists\");\n    } else if (!jury_possible && !participant_possible) {\n        quitf(_ok, \"No solution exists, both outputs are 'No'\");\n    } else {\n        // Both are 'Yes'\n        if (participant_t > jury_t) {\n            quitf(_wa, \"Participant's destruction time %d is greater than minimal possible %d\", participant_t, jury_t);\n        } else if (participant_t < jury_t) {\n            quitf(_fail, \"Participant found a better solution than jury: participant t = %d, jury t = %d\", participant_t, jury_t);\n        } else {\n            // participant_t == jury_t\n            // Validate participant's solution\n\n            // First, check that selected edges form a matching (no two edges share a vertex)\n            vector<bool> vertex_used(n + 1, false);\n            int calculated_t = 0;\n            for (int idx : participant_selected_edges) {\n                int edge_idx = idx - 1;\n                int vi = edges[edge_idx].vi;\n                int ui = edges[edge_idx].ui;\n\n                if (vertex_used[vi]) {\n                    quitf(_wa, \"Vertex %d is shared by multiple selected edges\", vi);\n                }\n                if (vertex_used[ui]) {\n                    quitf(_wa, \"Vertex %d is shared by multiple selected edges\", ui);\n                }\n                vertex_used[vi] = true;\n                vertex_used[ui] = true;\n\n                calculated_t = max(calculated_t, edges[edge_idx].ti);\n            }\n            if (participant_t != calculated_t) {\n                quitf(_wa, \"Participant's t (%d) does not match the maximum destruction time of selected edges (%d)\", participant_t, calculated_t);\n            }\n\n            // Now, check that the remaining graph forms a proper coloring\n            vector<Edge> remaining_edges;\n            set<int> selected_edge_indices(participant_selected_edges.begin(), participant_selected_edges.end());\n            for (int i = 0; i < m; ++i) {\n                if (selected_edge_indices.count(i + 1) == 0) {\n                    remaining_edges.push_back(edges[i]);\n                }\n            }\n\n            unordered_map<int, vector<Edge>> color_edges;\n            for (const Edge& e : remaining_edges) {\n                color_edges[e.ci].push_back(e);\n            }\n\n            for (const auto& color_entry : color_edges) {\n                int ci = color_entry.first;\n                const vector<Edge>& color_edges_list = color_entry.second;\n                vector<bool> vertices_used(n + 1, false);\n                for (const Edge& e : color_edges_list) {\n                    int vi = e.vi;\n                    int ui = e.ui;\n                    if (vertices_used[vi]) {\n                        quitf(_wa, \"In remaining graph, vertex %d is incident to multiple edges of color %d\", vi, ci);\n                    }\n                    if (vertices_used[ui]) {\n                        quitf(_wa, \"In remaining graph, vertex %d is incident to multiple edges of color %d\", ui, ci);\n                    }\n                    vertices_used[vi] = true;\n                    vertices_used[ui] = true;\n                }\n            }\n            quitf(_ok, \"Correct solution with destruction time %d\", participant_t);\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n - 1); // Default m to n - 1 if not provided\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n    vector<int> ci;\n    vector<int> ti;\n\n    if (type == \"random\") {\n        // Generate random edges\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int vi = rnd.next(1, n);\n            int ui = rnd.next(1, n);\n            if (vi == ui) continue;\n            if (vi > ui) swap(vi, ui);  // Ensure vi < ui to avoid duplicates\n            edge_set.insert({vi, ui});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n        ci.resize(m);\n        ti.resize(m);\n        for (int i = 0; i < m; i++) {\n            ci[i] = rnd.next(1, 1000000000);  // ci between 1 and 1e9\n            ti[i] = rnd.next(1, 1000000000);  // ti between 1 and 1e9\n        }\n\n    } else if (type == \"impossible\") {\n        // Generate a graph where satisfying the conditions is impossible\n        if (n < 3) n = 3;  // Need at least 3 nodes for a cycle\n        m = n;\n        for (int i = 1; i <= n; i++) {\n            int vi = i;\n            int ui = i % n + 1;\n            edges.push_back({vi, ui});\n            ci.push_back(1);  // All edges have the same color\n            ti.push_back(rnd.next(1, 1000000000)); // Random ti\n        }\n\n    } else if (type == \"single_color\") {\n        // Generate edges where all have the same color\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int vi = rnd.next(1, n);\n            int ui = rnd.next(1, n);\n            if (vi == ui) continue;\n            if (vi > ui) swap(vi, ui);\n            edge_set.insert({vi, ui});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n        ci.resize(m, 1);  // All edges have color 1\n        ti.resize(m);\n        for (int i = 0; i < m; i++) {\n            ti[i] = rnd.next(1, 1000000000);  // Random ti\n        }\n\n    } else if (type == \"special_case\") {\n        // Generate a special case to test specific conditions\n        int center = 1;\n        m = n - 1;\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({center, i});\n            ci.push_back(1);  // Same color\n            if (i == n) {\n                // Last edge has low ti\n                ti.push_back(1);\n            } else {\n                // Other edges have high ti\n                ti.push_back(1000000000);\n            }\n        }\n\n    } else {\n        // Default to random if unknown type\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int vi = rnd.next(1, n);\n            int ui = rnd.next(1, n);\n            if (vi == ui) continue;\n            if (vi > ui) swap(vi, ui);  // Ensure vi < ui to avoid duplicates\n            edge_set.insert({vi, ui});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n        ci.resize(m);\n        ti.resize(m);\n        for (int i = 0; i < m; i++) {\n            ci[i] = rnd.next(1, 1000000000);\n            ti[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output edges\n    for (int i = 0; i < m; i++) {\n        printf(\"%d %d %d %d\\n\", edges[i].first, edges[i].second, ci[i], ti[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n - 1); // Default m to n - 1 if not provided\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n    vector<int> ci;\n    vector<int> ti;\n\n    if (type == \"random\") {\n        // Generate random edges\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int vi = rnd.next(1, n);\n            int ui = rnd.next(1, n);\n            if (vi == ui) continue;\n            if (vi > ui) swap(vi, ui);  // Ensure vi < ui to avoid duplicates\n            edge_set.insert({vi, ui});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n        ci.resize(m);\n        ti.resize(m);\n        for (int i = 0; i < m; i++) {\n            ci[i] = rnd.next(1, 1000000000);  // ci between 1 and 1e9\n            ti[i] = rnd.next(1, 1000000000);  // ti between 1 and 1e9\n        }\n\n    } else if (type == \"impossible\") {\n        // Generate a graph where satisfying the conditions is impossible\n        if (n < 3) n = 3;  // Need at least 3 nodes for a cycle\n        m = n;\n        for (int i = 1; i <= n; i++) {\n            int vi = i;\n            int ui = i % n + 1;\n            edges.push_back({vi, ui});\n            ci.push_back(1);  // All edges have the same color\n            ti.push_back(rnd.next(1, 1000000000)); // Random ti\n        }\n\n    } else if (type == \"single_color\") {\n        // Generate edges where all have the same color\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int vi = rnd.next(1, n);\n            int ui = rnd.next(1, n);\n            if (vi == ui) continue;\n            if (vi > ui) swap(vi, ui);\n            edge_set.insert({vi, ui});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n        ci.resize(m, 1);  // All edges have color 1\n        ti.resize(m);\n        for (int i = 0; i < m; i++) {\n            ti[i] = rnd.next(1, 1000000000);  // Random ti\n        }\n\n    } else if (type == \"special_case\") {\n        // Generate a special case to test specific conditions\n        int center = 1;\n        m = n - 1;\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({center, i});\n            ci.push_back(1);  // Same color\n            if (i == n) {\n                // Last edge has low ti\n                ti.push_back(1);\n            } else {\n                // Other edges have high ti\n                ti.push_back(1000000000);\n            }\n        }\n\n    } else {\n        // Default to random if unknown type\n        set<pair<int, int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int vi = rnd.next(1, n);\n            int ui = rnd.next(1, n);\n            if (vi == ui) continue;\n            if (vi > ui) swap(vi, ui);  // Ensure vi < ui to avoid duplicates\n            edge_set.insert({vi, ui});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n        ci.resize(m);\n        ti.resize(m);\n        for (int i = 0; i < m; i++) {\n            ci[i] = rnd.next(1, 1000000000);\n            ti[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output edges\n    for (int i = 0; i < m; i++) {\n        printf(\"%d %d %d %d\\n\", edges[i].first, edges[i].second, ci[i], ti[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -m 3 -type impossible\n./gen -n 5 -m 7 -type impossible\n./gen -n 5 -m 5 -type impossible\n./gen -n 100 -m 200 -type impossible\n./gen -n 50000 -m 50000 -type impossible\n\n./gen -n 3 -m 3 -type single_color\n./gen -n 50 -m 100 -type single_color\n./gen -n 100 -m 1000 -type single_color\n./gen -n 5000 -m 10000 -type single_color\n./gen -n 50000 -m 50000 -type single_color\n\n./gen -n 2 -m 1 -type random\n./gen -n 3 -m 2 -type random\n./gen -n 5 -m 4 -type random\n./gen -n 10 -m 20 -type random\n./gen -n 50 -m 100 -type random\n./gen -n 100 -m 500 -type random\n./gen -n 500 -m 1000 -type random\n./gen -n 1000 -m 5000 -type random\n./gen -n 5000 -m 20000 -type random\n./gen -n 10000 -m 30000 -type random\n./gen -n 50000 -m 5000 -type random\n./gen -n 50000 -m 25000 -type random\n./gen -n 50000 -m 50000 -type random\n\n./gen -n 3 -type special_case\n./gen -n 10 -type special_case\n./gen -n 100 -type special_case\n./gen -n 1000 -type special_case\n./gen -n 50000 -type special_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:14.088744",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "59/A",
      "title": "A. Слово",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записано слово s — оно состоит из больших и маленьких латинских букв и имеет длину от 1 до 100.",
      "output_spec": "Выходные данныеВыведите исправленное слово s. Если в заданном слове s строго больше заглавных букв, приведите его к верхнему регистру, иначе — к нижнему.",
      "sample_tests": "ПримерыВходные данныеСкопироватьHoUseВыходные данныеСкопироватьhouseВходные данныеСкопироватьViPВыходные данныеСкопироватьVIPВходные данныеСкопироватьmaTRIxВыходные данныеСкопироватьmatrix",
      "description": "ограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано слово s — оно состоит из больших и маленьких латинских букв и имеет длину от 1 до 100.\n\nВходные данные\n\nВыходные данныеВыведите исправленное слово s. Если в заданном слове s строго больше заглавных букв, приведите его к верхнему регистру, иначе — к нижнему.\n\nВыходные данные\n\nВходные данныеСкопироватьHoUseВыходные данныеСкопироватьhouseВходные данныеСкопироватьViPВыходные данныеСкопироватьVIPВходные данныеСкопироватьmaTRIxВыходные данныеСкопироватьmatrix\n\nВходные данныеСкопироватьHoUse\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьhouse\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьViP\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьVIP\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьmaTRIx\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьmatrix\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #55 (Div. 2) - Codeforces",
          "content": "Пока все мировое сообщество спортивных программистов затаив дыхание ждет новостей о времени и месте проведения финала, мы решили не затягивать с раундом и в поезде по дороге из Петрозаводска в Саратов придумали задачи. В купе присутствовали – Михаил Мирзаянов, Артем Рахов, Максим Иванов. Задачи перевела Мария Белова. Удачи! Артем Рахов и команда Codeforces",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/1272",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 358
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces",
          "content": "Here I am sharing how I approached and solved the problems of the recently held Round 55 (DIV 2)A. WordThis was an extremely simple problem. Simply count the number of upper case latin letters. If that is strictly greater than number of lower case letters convert the word to upper case other wise convert it to lower case. Complexity: O(wordlength)B. Fortune TellingFor this problem all you need to do is store the smallest odd number of petals and also the sum of all the petals. It is quite obvious that only if the number of petals is odd the result would be \"Loves\". So if the sum is even print sum - smallest odd, otherwise print the sum.Complexity: O(n).C. TitleThis was a very nice problem. My approach was to first flag all the letters which have already appeared. Notice, that we have to output the lexicographically smallest palindrome. So, start from the middle of the letter and iterate one side...If you get a '?' stop and check if the corresponding position on the other side also has a '?'. If yes, then fill both with the lexicographically biggest letter which hasn't appeared yet in the word and also flag that letter.Once you have exhausted all the letters and there are still '?' left then simply fill them with 'a'.Now simply iterate over the word again and see if there are any question marks left, if yes copy the values in the corresponding block on the other side. At the same time check if at any time the two opposite values match or not. If they do throughout then it is a valid plaindrome which is also the lexicographically smallest palindrome.Here is a slightly messy implementation of the same: http://codepad.org/Fr7NYqYTComplexity: O(wordlength + k)D. Team ArrangementThis was in my opinion was the toughest problem. However once you get the logic, its pretty obvious. However, it was a slightly challenging implementation for me as the structure of the data to be stored was sort of complex.The basic idea was simply that if we have to find the preference list of a number 'p' then two things might happen:Case 1: p is the most skilled in his team and thus he chose the team. In this case we know that all the members of the teams coming after p's team are less preferred than p's team mates. Let p's team mates be 'm' and 'n' such that m > n.To get the lexicographically smallest preference list, we will divide all the programmers into two lists. The first list will contain all members (ai) from teams which were chosen before p's team such that ai < m. It will also contain m and n.The second list will contain all the left over members.The separation can be done in O(n) time. Now all we need to do is sort the first list, print it, sort the second list, print it!Complexity: O(nlogn)... It can be reduced to O(n) also but the constant will be pretty high and will give almost the same result as O(nlogn).Case 2: p is not the leader of the team. Then you just have to output all number except 'p' from 1 to 3 * n.As for the last problem, I do not have a solution. I do not have much experienced with implementing graphs unfortunately.Please point out any optimizations to the above or mistakes which I might have made in the above.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/1276",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3171
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #55 (Div. 2) - Codeforces - Code 1",
          "code": "var a : array['a'..'z'] of integer;ch : char;beginch := '?';inc(a[ch]);end.",
          "language": "JavaScript",
          "source": "https://codeforces.com/blog/entry/1272",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #55 (Div. 2) - Codeforces - Code 2",
          "code": "#include <iostream>using namespace std;int n,k,r,m=100;int main(){   cin>>n;   while(n--)   {      cin>>k;      if(k&1)         m=min(m,k);      r+=k;   }   if(r&1)      cout<<r;   else if(m&1)      cout<<r-m;   else      cout<<0;}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1272",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #55 (Div. 2) - Codeforces - Code 3",
          "code": "int R(int a, int b, int c){        int p = N3*N;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1272",
          "author": "Qingyu"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 1",
          "code": "while (!pq.empty()){\n    pair<int,int> v= pq.top();\n    pq.pop();\n\n    int ver=v.second;\n    for (int i=0;i<adj[ver].size();i++){\n       if (1+dist[ver]<dist[i] && map[mp(pre[ver],ver)] != i){\n         dist[i]=1+dist[ver];\n         pre[i]=ver;\n         pq.push(mp(dist[i],i));\n       }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "Qingyu"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 2",
          "code": "while (!pq.empty()){\n    pair<int,int> v= pq.top();\n    pq.pop();\n\n    int ver=v.second;\n    for (int i=0;i<adj[ver].size();i++){\n       if (1+dist[ver]<dist[i] && map[mp(pre[ver],ver)] != i){\n         dist[i]=1+dist[ver];\n         pre[i]=ver;\n         pq.push(mp(dist[i],i));\n       }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "Qingyu"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 3",
          "code": "map<pair<int,int>,int> map;\n\nfor (int i=0;i<m;i++){\n    int a,b;\n    cin >> a>>b;\n    adj[a].pb(b);\n    adj[b].pb(a);\n}\nfor (int i=0;i<k;i++){\n    int a,b,c;\n    cin >> a>>b>>c;\n    map.insert({make_pair(a,b),c});\n}\ndijkstra(map,1,n);\nif (dist[n]==INT_MAX) {\n    cout << -1; return 0;\n}\ncout << dist[n];\nint x=n;\nvector<int> route;\n\nwhile (x!=-1){\n    route.push_back(x);\n    x=pre[x];\n}\nfor(auto i=route.size()-1;i>-1;i--){\n    cout << route[i]<< \"  \";\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "Qingyu"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 4",
          "code": "map<pair<int,int>,int> map;\n\nfor (int i=0;i<m;i++){\n    int a,b;\n    cin >> a>>b;\n    adj[a].pb(b);\n    adj[b].pb(a);\n}\nfor (int i=0;i<k;i++){\n    int a,b,c;\n    cin >> a>>b>>c;\n    map.insert({make_pair(a,b),c});\n}\ndijkstra(map,1,n);\nif (dist[n]==INT_MAX) {\n    cout << -1; return 0;\n}\ncout << dist[n];\nint x=n;\nvector<int> route;\n\nwhile (x!=-1){\n    route.push_back(x);\n    x=pre[x];\n}\nfor(auto i=route.size()-1;i>-1;i--){\n    cout << route[i]<< \"  \";\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"^[a-zA-Z]{1,100}$\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"^[a-zA-Z]{1,100}$\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"^[a-zA-Z]{1,100}$\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, 'a');\n\n    if (type == \"all_lower\") {\n        // All lowercase letters.\n        for(int i = 0; i < n; ++i)\n            s[i] = 'a' + rnd.next(26);\n    } else if (type == \"all_upper\") {\n        // All uppercase letters.\n        for(int i = 0; i < n; ++i)\n            s[i] = 'A' + rnd.next(26);\n    } else if (type == \"alternating\") {\n        // Alternating upper and lower case\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                s[i] = 'a' + rnd.next(26);\n            else\n                s[i] = 'A' + rnd.next(26);\n        }\n    } else if (type == \"equal_case\") {\n        // Equal number of uppercase and lowercase letters\n        int lower_cnt = n / 2;\n        for (int i = 0; i < lower_cnt; ++i)\n            s[i] = 'a' + rnd.next(26);\n        for (int i = lower_cnt; i < n; ++i)\n            s[i] = 'A' + rnd.next(26);\n        shuffle(s.begin(), s.end());\n    } else if (type == \"more_lower\") {\n        // More lowercase letters\n        int lower_cnt = n / 2 + 1;\n        for (int i = 0; i < lower_cnt; ++i)\n            s[i] = 'a' + rnd.next(26);\n        for (int i = lower_cnt; i < n; ++i)\n            s[i] = 'A' + rnd.next(26);\n        shuffle(s.begin(), s.end());\n    } else if (type == \"more_upper\") {\n        // More uppercase letters\n        int upper_cnt = n / 2 + 1;\n        for (int i = 0; i < upper_cnt; ++i)\n            s[i] = 'A' + rnd.next(26);\n        for (int i = upper_cnt; i < n; ++i)\n            s[i] = 'a' + rnd.next(26);\n        shuffle(s.begin(), s.end());\n    } else if (type == \"special\") {\n        // Generate a word with a special pattern\n        string pattern = opt<string>(\"pattern\", \"aA\");\n        s = \"\";\n        while ((int)s.length() < n)\n            s += pattern;\n        s = s.substr(0, n); // Truncate to length n\n    } else {\n        // Random case\n        for(int i = 0; i < n; ++i) {\n            if (rnd.next(2) == 0)\n                s[i] = 'a' + rnd.next(26);\n            else\n                s[i] = 'A' + rnd.next(26);\n        }\n    }\n\n    // Output the word s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, 'a');\n\n    if (type == \"all_lower\") {\n        // All lowercase letters.\n        for(int i = 0; i < n; ++i)\n            s[i] = 'a' + rnd.next(26);\n    } else if (type == \"all_upper\") {\n        // All uppercase letters.\n        for(int i = 0; i < n; ++i)\n            s[i] = 'A' + rnd.next(26);\n    } else if (type == \"alternating\") {\n        // Alternating upper and lower case\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                s[i] = 'a' + rnd.next(26);\n            else\n                s[i] = 'A' + rnd.next(26);\n        }\n    } else if (type == \"equal_case\") {\n        // Equal number of uppercase and lowercase letters\n        int lower_cnt = n / 2;\n        for (int i = 0; i < lower_cnt; ++i)\n            s[i] = 'a' + rnd.next(26);\n        for (int i = lower_cnt; i < n; ++i)\n            s[i] = 'A' + rnd.next(26);\n        shuffle(s.begin(), s.end());\n    } else if (type == \"more_lower\") {\n        // More lowercase letters\n        int lower_cnt = n / 2 + 1;\n        for (int i = 0; i < lower_cnt; ++i)\n            s[i] = 'a' + rnd.next(26);\n        for (int i = lower_cnt; i < n; ++i)\n            s[i] = 'A' + rnd.next(26);\n        shuffle(s.begin(), s.end());\n    } else if (type == \"more_upper\") {\n        // More uppercase letters\n        int upper_cnt = n / 2 + 1;\n        for (int i = 0; i < upper_cnt; ++i)\n            s[i] = 'A' + rnd.next(26);\n        for (int i = upper_cnt; i < n; ++i)\n            s[i] = 'a' + rnd.next(26);\n        shuffle(s.begin(), s.end());\n    } else if (type == \"special\") {\n        // Generate a word with a special pattern\n        string pattern = opt<string>(\"pattern\", \"aA\");\n        s = \"\";\n        while ((int)s.length() < n)\n            s += pattern;\n        s = s.substr(0, n); // Truncate to length n\n    } else {\n        // Random case\n        for(int i = 0; i < n; ++i) {\n            if (rnd.next(2) == 0)\n                s[i] = 'a' + rnd.next(26);\n            else\n                s[i] = 'A' + rnd.next(26);\n        }\n    }\n\n    // Output the word s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_lower\n./gen -n 1 -type all_upper\n./gen -n 1 -type random\n./gen -n 1 -type alternating\n\n./gen -n 2 -type equal_case\n./gen -n 2 -type more_lower\n./gen -n 2 -type more_upper\n./gen -n 2 -type random\n\n./gen -n 5 -type all_lower\n./gen -n 5 -type all_upper\n./gen -n 5 -type alternating\n./gen -n 5 -type equal_case\n./gen -n 5 -type more_lower\n./gen -n 5 -type more_upper\n./gen -n 5 -type random\n\n./gen -n 10 -type random\n\n./gen -n 50 -type random\n\n./gen -n 99 -type equal_case\n./gen -n 99 -type more_lower\n./gen -n 99 -type more_upper\n./gen -n 99 -type random\n\n./gen -n 100 -type all_lower\n./gen -n 100 -type all_upper\n./gen -n 100 -type alternating\n./gen -n 100 -type equal_case\n./gen -n 100 -type more_lower\n./gen -n 100 -type more_upper\n./gen -n 100 -type random\n\n./gen -n 100 -type special -pattern \"aA\"\n./gen -n 100 -type special -pattern \"Aa\"\n./gen -n 100 -type special -pattern \"abcDEF\"\n./gen -n 100 -type special -pattern \"ABab\"\n./gen -n 100 -type special -pattern \"AaaBBbb\"\n./gen -n 100 -type special -pattern \"A\"\n./gen -n 100 -type special -pattern \"a\"\n./gen -n 100 -type special -pattern \"AzZa\"\n./gen -n 100 -type special -pattern \"zZ\"\n./gen -n 99 -type special -pattern \"Aa\"\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:16.210823",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "59/B",
      "title": "B. Fortune Telling",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 100), which is the number of flowers growing in the field. The second line contains n integers ai (1 ≤ ai ≤ 100) which represent the number of petals on a given i-th camomile.",
      "output_spec": "OutputPrint a single number which is the maximal number of petals in the bouquet, the fortune telling on which would result in \"Loves\". If there are no such bouquet, print 0 instead. The bouquet may consist of a single flower.",
      "sample_tests": "ExamplesInputCopy11OutputCopy1InputCopy12OutputCopy0InputCopy35 6 7OutputCopy13",
      "description": "B. Fortune Telling\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 100), which is the number of flowers growing in the field. The second line contains n integers ai (1 ≤ ai ≤ 100) which represent the number of petals on a given i-th camomile.\n\nOutputPrint a single number which is the maximal number of petals in the bouquet, the fortune telling on which would result in \"Loves\". If there are no such bouquet, print 0 instead. The bouquet may consist of a single flower.\n\nInputCopy11OutputCopy1InputCopy12OutputCopy0InputCopy35 6 7OutputCopy13\n\nInputCopy11\n\nOutputCopy1\n\nInputCopy12\n\nOutputCopy0\n\nInputCopy35 6 7\n\nOutputCopy13",
      "solutions": [
        {
          "title": "Codeforces Beta Round #55 (Div. 2) - Codeforces",
          "content": "While the world community of participants of programming contests is waiting with bated breath for the news about new date and place of the Final, we decided not to delay the next round and prepared some problems on the train from Petrozavodsk to Saratov. In preparation were involved Mike Mirzayanov, Artem Rakhov and Max Ivanov. Tasks were translated into English by Maria Belova.Good luck!Artem Rakhov and Codeforces team",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1272",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 424
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces",
          "content": "Here I am sharing how I approached and solved the problems of the recently held Round 55 (DIV 2)A. WordThis was an extremely simple problem. Simply count the number of upper case latin letters. If that is strictly greater than number of lower case letters convert the word to upper case other wise convert it to lower case. Complexity: O(wordlength)B. Fortune TellingFor this problem all you need to do is store the smallest odd number of petals and also the sum of all the petals. It is quite obvious that only if the number of petals is odd the result would be \"Loves\". So if the sum is even print sum - smallest odd, otherwise print the sum.Complexity: O(n).C. TitleThis was a very nice problem. My approach was to first flag all the letters which have already appeared. Notice, that we have to output the lexicographically smallest palindrome. So, start from the middle of the letter and iterate one side...If you get a '?' stop and check if the corresponding position on the other side also has a '?'. If yes, then fill both with the lexicographically biggest letter which hasn't appeared yet in the word and also flag that letter.Once you have exhausted all the letters and there are still '?' left then simply fill them with 'a'.Now simply iterate over the word again and see if there are any question marks left, if yes copy the values in the corresponding block on the other side. At the same time check if at any time the two opposite values match or not. If they do throughout then it is a valid plaindrome which is also the lexicographically smallest palindrome.Here is a slightly messy implementation of the same: http://codepad.org/Fr7NYqYTComplexity: O(wordlength + k)D. Team ArrangementThis was in my opinion was the toughest problem. However once you get the logic, its pretty obvious. However, it was a slightly challenging implementation for me as the structure of the data to be stored was sort of complex.The basic idea was simply that if we have to find the preference list of a number 'p' then two things might happen:Case 1: p is the most skilled in his team and thus he chose the team. In this case we know that all the members of the teams coming after p's team are less preferred than p's team mates. Let p's team mates be 'm' and 'n' such that m > n.To get the lexicographically smallest preference list, we will divide all the programmers into two lists. The first list will contain all members (ai) from teams which were chosen before p's team such that ai < m. It will also contain m and n.The second list will contain all the left over members.The separation can be done in O(n) time. Now all we need to do is sort the first list, print it, sort the second list, print it!Complexity: O(nlogn)... It can be reduced to O(n) also but the constant will be pretty high and will give almost the same result as O(nlogn).Case 2: p is not the leader of the team. Then you just have to output all number except 'p' from 1 to 3 * n.As for the last problem, I do not have a solution. I do not have much experienced with implementing graphs unfortunately.Please point out any optimizations to the above or mistakes which I might have made in the above.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1276",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3171
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #55 (Div. 2) - Codeforces - Code 1",
          "code": "#include <iostream>using namespace std;int n,k,r,m=100;int main(){   cin>>n;   while(n--)   {      cin>>k;      if(k&1)         m=min(m,k);      r+=k;   }   if(r&1)      cout<<r;   else if(m&1)      cout<<r-m;   else      cout<<0;}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1272",
          "author": "jiangly"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 1",
          "code": "while (!pq.empty()){\n    pair<int,int> v= pq.top();\n    pq.pop();\n\n    int ver=v.second;\n    for (int i=0;i<adj[ver].size();i++){\n       if (1+dist[ver]<dist[i] && map[mp(pre[ver],ver)] != i){\n         dist[i]=1+dist[ver];\n         pre[i]=ver;\n         pq.push(mp(dist[i],i));\n       }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "jiangly"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 2",
          "code": "while (!pq.empty()){\n    pair<int,int> v= pq.top();\n    pq.pop();\n\n    int ver=v.second;\n    for (int i=0;i<adj[ver].size();i++){\n       if (1+dist[ver]<dist[i] && map[mp(pre[ver],ver)] != i){\n         dist[i]=1+dist[ver];\n         pre[i]=ver;\n         pq.push(mp(dist[i],i));\n       }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "jiangly"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 3",
          "code": "map<pair<int,int>,int> map;\n\nfor (int i=0;i<m;i++){\n    int a,b;\n    cin >> a>>b;\n    adj[a].pb(b);\n    adj[b].pb(a);\n}\nfor (int i=0;i<k;i++){\n    int a,b,c;\n    cin >> a>>b>>c;\n    map.insert({make_pair(a,b),c});\n}\ndijkstra(map,1,n);\nif (dist[n]==INT_MAX) {\n    cout << -1; return 0;\n}\ncout << dist[n];\nint x=n;\nvector<int> route;\n\nwhile (x!=-1){\n    route.push_back(x);\n    x=pre[x];\n}\nfor(auto i=route.size()-1;i>-1;i--){\n    cout << route[i]<< \"  \";\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "jiangly"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 4",
          "code": "map<pair<int,int>,int> map;\n\nfor (int i=0;i<m;i++){\n    int a,b;\n    cin >> a>>b;\n    adj[a].pb(b);\n    adj[b].pb(a);\n}\nfor (int i=0;i<k;i++){\n    int a,b,c;\n    cin >> a>>b>>c;\n    map.insert({make_pair(a,b),c});\n}\ndijkstra(map,1,n);\nif (dist[n]==INT_MAX) {\n    cout << -1; return 0;\n}\ncout << dist[n];\nint x=n;\nvector<int> route;\n\nwhile (x!=-1){\n    route.push_back(x);\n    x=pre[x];\n}\nfor(auto i=route.size()-1;i>-1;i--){\n    cout << route[i]<< \"  \";\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"minimal_odd\") {\n        // n=1, ai=1 (total sum is odd)\n        a[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"minimal_even\") {\n        // n=1, ai=2 (total sum is even)\n        a[0] = 2;\n        for (int i = 1; i < n; ++i) {\n            a[i] = 2;\n        }\n    } else if (type == \"all_even\") {\n        // All ai are even numbers\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 50) * 2; // Even numbers between 2 and 100\n        }\n    } else if (type == \"all_odd\") {\n        // All ai are odd numbers\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 50) * 2 - 1; // Odd numbers between 1 and 99\n        }\n    } else if (type == \"mix_even_odd\") {\n        // Mix of even and odd numbers\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1))\n                a[i] = rnd.next(1, 50) * 2;     // Even number\n            else\n                a[i] = rnd.next(1, 50) * 2 - 1; // Odd number\n        }\n    } else if (type == \"maximal_sum_even\") {\n        // Maximize total sum, ensure it's even\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100; // Max ai\n        }\n        int total = n * 100;\n        if (total % 2 != 0) {\n            a[0] = 99; // Adjust to make total sum even\n        }\n    } else if (type == \"maximal_sum_odd\") {\n        // Maximize total sum, ensure it's odd\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100; // Max ai\n        }\n        int total = n * 100;\n        if (total % 2 == 0) {\n            a[0] = 99; // Adjust to make total sum odd\n        }\n    } else {\n        // Random ai between 1 and 100\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"minimal_odd\") {\n        // n=1, ai=1 (total sum is odd)\n        a[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"minimal_even\") {\n        // n=1, ai=2 (total sum is even)\n        a[0] = 2;\n        for (int i = 1; i < n; ++i) {\n            a[i] = 2;\n        }\n    } else if (type == \"all_even\") {\n        // All ai are even numbers\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 50) * 2; // Even numbers between 2 and 100\n        }\n    } else if (type == \"all_odd\") {\n        // All ai are odd numbers\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 50) * 2 - 1; // Odd numbers between 1 and 99\n        }\n    } else if (type == \"mix_even_odd\") {\n        // Mix of even and odd numbers\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1))\n                a[i] = rnd.next(1, 50) * 2;     // Even number\n            else\n                a[i] = rnd.next(1, 50) * 2 - 1; // Odd number\n        }\n    } else if (type == \"maximal_sum_even\") {\n        // Maximize total sum, ensure it's even\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100; // Max ai\n        }\n        int total = n * 100;\n        if (total % 2 != 0) {\n            a[0] = 99; // Adjust to make total sum even\n        }\n    } else if (type == \"maximal_sum_odd\") {\n        // Maximize total sum, ensure it's odd\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100; // Max ai\n        }\n        int total = n * 100;\n        if (total % 2 == 0) {\n            a[0] = 99; // Adjust to make total sum odd\n        }\n    } else {\n        // Random ai between 1 and 100\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type minimal_odd\n./gen -n 1 -type minimal_even\n\n./gen -n 1 -type all_odd\n./gen -n 1 -type all_even\n./gen -n 1 -type mix_even_odd\n\n./gen -n 2 -type minimal_odd\n./gen -n 2 -type minimal_even\n./gen -n 2 -type all_odd\n./gen -n 2 -type all_even\n./gen -n 2 -type mix_even_odd\n\n./gen -n 50 -type maximal_sum_even\n./gen -n 50 -type maximal_sum_odd\n\n./gen -n 99 -type maximal_sum_even\n./gen -n 99 -type maximal_sum_odd\n./gen -n 99 -type mix_even_odd\n\n./gen -n 100 -type maximal_sum_even\n./gen -n 100 -type maximal_sum_odd\n\n./gen -n 100 -type all_even\n./gen -n 100 -type all_odd\n./gen -n 100 -type mix_even_odd\n\n./gen -n 100 -type random\n./gen -n 95 -type random\n./gen -n 90 -type random\n./gen -n 85 -type random\n./gen -n 80 -type random\n\n./gen -n 100 -type minimal_odd\n./gen -n 100 -type minimal_even\n\n./gen -n 3 -type mix_even_odd\n\n./gen -n 5 -type all_even\n\n./gen -n 10 -type all_odd\n\n./gen -n 10 -type mix_even_odd\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:18.339634",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "59/C",
      "title": "C. Title",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer k (1 ≤ k ≤ 26) which is the number of allowed alphabet letters. The second line contains s which is the given template. In s only the first k lowercase letters of Latin alphabet and question marks can be present, the length of s is from 1 to 100 characters inclusively.",
      "output_spec": "OutputIf there is no solution, print IMPOSSIBLE. Otherwise, a single line should contain the required title, satisfying the given template. The title should be a palindrome and it can only contain the first k letters of the Latin alphabet. At that, each of those k letters must be present at least once. If there are several suitable titles, print the lexicographically minimal one. The lexicographical comparison is performed by the standard < operator in modern programming languages. The line a is lexicographically smaller than the line b, if exists such an i (1 ≤ i ≤ |s|), that ai < bi, and for any j (1 ≤ j < i) aj = bj. |s| stands for the length of the given template.",
      "sample_tests": "ExamplesInputCopy3a?cOutputCopyIMPOSSIBLEInputCopy2a??aOutputCopyabbaInputCopy2?b?aOutputCopyabba",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer k (1 ≤ k ≤ 26) which is the number of allowed alphabet letters. The second line contains s which is the given template. In s only the first k lowercase letters of Latin alphabet and question marks can be present, the length of s is from 1 to 100 characters inclusively.\n\nOutputIf there is no solution, print IMPOSSIBLE. Otherwise, a single line should contain the required title, satisfying the given template. The title should be a palindrome and it can only contain the first k letters of the Latin alphabet. At that, each of those k letters must be present at least once. If there are several suitable titles, print the lexicographically minimal one. The lexicographical comparison is performed by the standard < operator in modern programming languages. The line a is lexicographically smaller than the line b, if exists such an i (1 ≤ i ≤ |s|), that ai < bi, and for any j (1 ≤ j < i) aj = bj. |s| stands for the length of the given template.\n\nInputCopy3a?cOutputCopyIMPOSSIBLEInputCopy2a??aOutputCopyabbaInputCopy2?b?aOutputCopyabba\n\nInputCopy3a?c\n\nOutputCopyIMPOSSIBLE\n\nInputCopy2a??a\n\nOutputCopyabba\n\nInputCopy2?b?a\n\nOutputCopyabba",
      "solutions": [
        {
          "title": "Codeforces Beta Round #55 (Div. 2) - Codeforces",
          "content": "While the world community of participants of programming contests is waiting with bated breath for the news about new date and place of the Final, we decided not to delay the next round and prepared some problems on the train from Petrozavodsk to Saratov. In preparation were involved Mike Mirzayanov, Artem Rakhov and Max Ivanov. Tasks were translated into English by Maria Belova.Good luck!Artem Rakhov and Codeforces team",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1272",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 424
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces",
          "content": "Here I am sharing how I approached and solved the problems of the recently held Round 55 (DIV 2)A. WordThis was an extremely simple problem. Simply count the number of upper case latin letters. If that is strictly greater than number of lower case letters convert the word to upper case other wise convert it to lower case. Complexity: O(wordlength)B. Fortune TellingFor this problem all you need to do is store the smallest odd number of petals and also the sum of all the petals. It is quite obvious that only if the number of petals is odd the result would be \"Loves\". So if the sum is even print sum - smallest odd, otherwise print the sum.Complexity: O(n).C. TitleThis was a very nice problem. My approach was to first flag all the letters which have already appeared. Notice, that we have to output the lexicographically smallest palindrome. So, start from the middle of the letter and iterate one side...If you get a '?' stop and check if the corresponding position on the other side also has a '?'. If yes, then fill both with the lexicographically biggest letter which hasn't appeared yet in the word and also flag that letter.Once you have exhausted all the letters and there are still '?' left then simply fill them with 'a'.Now simply iterate over the word again and see if there are any question marks left, if yes copy the values in the corresponding block on the other side. At the same time check if at any time the two opposite values match or not. If they do throughout then it is a valid plaindrome which is also the lexicographically smallest palindrome.Here is a slightly messy implementation of the same: http://codepad.org/Fr7NYqYTComplexity: O(wordlength + k)D. Team ArrangementThis was in my opinion was the toughest problem. However once you get the logic, its pretty obvious. However, it was a slightly challenging implementation for me as the structure of the data to be stored was sort of complex.The basic idea was simply that if we have to find the preference list of a number 'p' then two things might happen:Case 1: p is the most skilled in his team and thus he chose the team. In this case we know that all the members of the teams coming after p's team are less preferred than p's team mates. Let p's team mates be 'm' and 'n' such that m > n.To get the lexicographically smallest preference list, we will divide all the programmers into two lists. The first list will contain all members (ai) from teams which were chosen before p's team such that ai < m. It will also contain m and n.The second list will contain all the left over members.The separation can be done in O(n) time. Now all we need to do is sort the first list, print it, sort the second list, print it!Complexity: O(nlogn)... It can be reduced to O(n) also but the constant will be pretty high and will give almost the same result as O(nlogn).Case 2: p is not the leader of the team. Then you just have to output all number except 'p' from 1 to 3 * n.As for the last problem, I do not have a solution. I do not have much experienced with implementing graphs unfortunately.Please point out any optimizations to the above or mistakes which I might have made in the above.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1276",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3171
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #55 (Div. 2) - Codeforces - Code 1",
          "code": "#include <iostream>using namespace std;int n,k,r,m=100;int main(){   cin>>n;   while(n--)   {      cin>>k;      if(k&1)         m=min(m,k);      r+=k;   }   if(r&1)      cout<<r;   else if(m&1)      cout<<r-m;   else      cout<<0;}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1272",
          "author": "jiangly"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 1",
          "code": "while (!pq.empty()){\n    pair<int,int> v= pq.top();\n    pq.pop();\n\n    int ver=v.second;\n    for (int i=0;i<adj[ver].size();i++){\n       if (1+dist[ver]<dist[i] && map[mp(pre[ver],ver)] != i){\n         dist[i]=1+dist[ver];\n         pre[i]=ver;\n         pq.push(mp(dist[i],i));\n       }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "jiangly"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 2",
          "code": "while (!pq.empty()){\n    pair<int,int> v= pq.top();\n    pq.pop();\n\n    int ver=v.second;\n    for (int i=0;i<adj[ver].size();i++){\n       if (1+dist[ver]<dist[i] && map[mp(pre[ver],ver)] != i){\n         dist[i]=1+dist[ver];\n         pre[i]=ver;\n         pq.push(mp(dist[i],i));\n       }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "jiangly"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 3",
          "code": "map<pair<int,int>,int> map;\n\nfor (int i=0;i<m;i++){\n    int a,b;\n    cin >> a>>b;\n    adj[a].pb(b);\n    adj[b].pb(a);\n}\nfor (int i=0;i<k;i++){\n    int a,b,c;\n    cin >> a>>b>>c;\n    map.insert({make_pair(a,b),c});\n}\ndijkstra(map,1,n);\nif (dist[n]==INT_MAX) {\n    cout << -1; return 0;\n}\ncout << dist[n];\nint x=n;\nvector<int> route;\n\nwhile (x!=-1){\n    route.push_back(x);\n    x=pre[x];\n}\nfor(auto i=route.size()-1;i>-1;i--){\n    cout << route[i]<< \"  \";\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "jiangly"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 4",
          "code": "map<pair<int,int>,int> map;\n\nfor (int i=0;i<m;i++){\n    int a,b;\n    cin >> a>>b;\n    adj[a].pb(b);\n    adj[b].pb(a);\n}\nfor (int i=0;i<k;i++){\n    int a,b,c;\n    cin >> a>>b>>c;\n    map.insert({make_pair(a,b),c});\n}\ndijkstra(map,1,n);\nif (dist[n]==INT_MAX) {\n    cout << -1; return 0;\n}\ncout << dist[n];\nint x=n;\nvector<int> route;\n\nwhile (x!=-1){\n    route.push_back(x);\n    x=pre[x];\n}\nfor(auto i=route.size()-1;i>-1;i--){\n    cout << route[i]<< \"  \";\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 26, \"k\");\n    inf.readEoln();\n    string letters = \"\";\n    for (char c = 'a'; c <= 'a' + k - 1; ++c) {\n        letters += c;\n    }\n    string pattern = \"[\" + letters + \"?]{1,100}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 26, \"k\");\n    inf.readEoln();\n    string letters = \"\";\n    for (char c = 'a'; c <= 'a' + k - 1; ++c) {\n        letters += c;\n    }\n    string pattern = \"[\" + letters + \"?]{1,100}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 26, \"k\");\n    inf.readEoln();\n    string letters = \"\";\n    for (char c = 'a'; c <= 'a' + k - 1; ++c) {\n        letters += c;\n    }\n    string pattern = \"[\" + letters + \"?]{1,100}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\"); // Length of s, 1 ≤ n ≤ 100\n    int k = opt<int>(\"k\"); // Number of letters allowed, 1 ≤ k ≤ 26\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n\n    // Ensure parameters are within the constraints\n    ensure(1 <= n && n <= 100);\n    ensure(1 <= k && k <= 26);\n\n    string s(n, '?'); // Initialize s with '?' of length n\n\n    if (type == \"random\") {\n        // Generate a random s of length n with letters from 'a' to 'a'+k-1 and '?'\n        for (int i = 0; i < n; ++i) {\n            int r = rnd.next(0, k); // Randomly choose from 0 to k\n            if (r == k)\n                s[i] = '?'; // With probability 1/(k+1), set to '?'\n            else\n                s[i] = 'a' + r; // Else, set to a letter from 'a' to 'a'+k-1\n        }\n    }\n    else if (type == \"palin\") {\n        // Generate a palindromic s\n        for (int i = 0; i <= (n - 1) / 2; ++i) {\n            int r = rnd.next(0, k); // Randomly choose from 0 to k\n            char c;\n            if (r == k)\n                c = '?';\n            else\n                c = 'a' + r;\n            s[i] = c;\n            s[n - i - 1] = c; // Ensure symmetry for palindrome\n        }\n    }\n    else if (type == \"impossible\") {\n        // Generate an s that cannot be completed to satisfy the requirements\n        bool conflictMade = false;\n        if (n >= 2 && k >= 2) {\n            // Set conflicting letters at symmetric positions\n            s[0] = 'a';\n            s[n - 1] = 'b';\n            conflictMade = true;\n        }\n        else if (n < k) {\n            // Not enough length to include all k letters\n            // s remains as '?' which cannot include all k letters\n            conflictMade = true;\n        }\n        else if (k == 1 && n % 2 == 0) {\n            // Cannot form a palindrome of even length with only one letter\n            s[n / 2 - 1] = 'a';\n            s[n / 2] = 'b';\n            conflictMade = true;\n        }\n        else {\n            // Try to create conflicting letters\n            for (int i = 0; i < n / 2; ++i) {\n                char c1 = 'a' + rnd.next(0, k - 1);\n                char c2 = 'a' + rnd.next(0, k - 1);\n                if (c1 != c2) {\n                    s[i] = c1;\n                    s[n - i - 1] = c2;\n                    conflictMade = true;\n                    break;\n                }\n            }\n        }\n        if (!conflictMade) {\n            // If unable to make s impossible, fill with random letters\n            for (int i = 0; i < n; ++i) {\n                s[i] = 'a' + rnd.next(0, k - 1);\n            }\n        }\n    }\n    else if (type == \"all_question_marks\") {\n        // s is already initialized with '?', do nothing\n    }\n    else {\n        // Unknown type, fill s with random letters\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(0, k - 1);\n        }\n    }\n\n    // Output k and s\n    cout << k << endl;\n    cout << s << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\"); // Length of s, 1 ≤ n ≤ 100\n    int k = opt<int>(\"k\"); // Number of letters allowed, 1 ≤ k ≤ 26\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n\n    // Ensure parameters are within the constraints\n    ensure(1 <= n && n <= 100);\n    ensure(1 <= k && k <= 26);\n\n    string s(n, '?'); // Initialize s with '?' of length n\n\n    if (type == \"random\") {\n        // Generate a random s of length n with letters from 'a' to 'a'+k-1 and '?'\n        for (int i = 0; i < n; ++i) {\n            int r = rnd.next(0, k); // Randomly choose from 0 to k\n            if (r == k)\n                s[i] = '?'; // With probability 1/(k+1), set to '?'\n            else\n                s[i] = 'a' + r; // Else, set to a letter from 'a' to 'a'+k-1\n        }\n    }\n    else if (type == \"palin\") {\n        // Generate a palindromic s\n        for (int i = 0; i <= (n - 1) / 2; ++i) {\n            int r = rnd.next(0, k); // Randomly choose from 0 to k\n            char c;\n            if (r == k)\n                c = '?';\n            else\n                c = 'a' + r;\n            s[i] = c;\n            s[n - i - 1] = c; // Ensure symmetry for palindrome\n        }\n    }\n    else if (type == \"impossible\") {\n        // Generate an s that cannot be completed to satisfy the requirements\n        bool conflictMade = false;\n        if (n >= 2 && k >= 2) {\n            // Set conflicting letters at symmetric positions\n            s[0] = 'a';\n            s[n - 1] = 'b';\n            conflictMade = true;\n        }\n        else if (n < k) {\n            // Not enough length to include all k letters\n            // s remains as '?' which cannot include all k letters\n            conflictMade = true;\n        }\n        else if (k == 1 && n % 2 == 0) {\n            // Cannot form a palindrome of even length with only one letter\n            s[n / 2 - 1] = 'a';\n            s[n / 2] = 'b';\n            conflictMade = true;\n        }\n        else {\n            // Try to create conflicting letters\n            for (int i = 0; i < n / 2; ++i) {\n                char c1 = 'a' + rnd.next(0, k - 1);\n                char c2 = 'a' + rnd.next(0, k - 1);\n                if (c1 != c2) {\n                    s[i] = c1;\n                    s[n - i - 1] = c2;\n                    conflictMade = true;\n                    break;\n                }\n            }\n        }\n        if (!conflictMade) {\n            // If unable to make s impossible, fill with random letters\n            for (int i = 0; i < n; ++i) {\n                s[i] = 'a' + rnd.next(0, k - 1);\n            }\n        }\n    }\n    else if (type == \"all_question_marks\") {\n        // s is already initialized with '?', do nothing\n    }\n    else {\n        // Unknown type, fill s with random letters\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(0, k - 1);\n        }\n    }\n\n    // Output k and s\n    cout << k << endl;\n    cout << s << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type random\n./gen -n 1 -k 1 -type palin\n./gen -n 1 -k 1 -type impossible\n./gen -n 1 -k 1 -type all_question_marks\n\n./gen -n 2 -k 2 -type random\n./gen -n 2 -k 2 -type palin\n./gen -n 2 -k 2 -type impossible\n./gen -n 2 -k 2 -type all_question_marks\n\n./gen -n 5 -k 3 -type random\n./gen -n 5 -k 3 -type palin\n./gen -n 5 -k 3 -type impossible\n\n./gen -n 10 -k 5 -type random\n./gen -n 10 -k 5 -type palin\n\n./gen -n 20 -k 10 -type random\n./gen -n 20 -k 10 -type palin\n./gen -n 20 -k 10 -type impossible\n./gen -n 20 -k 10 -type all_question_marks\n\n./gen -n 50 -k 15 -type random\n./gen -n 50 -k 15 -type palin\n\n./gen -n 50 -k 20 -type impossible\n\n./gen -n 100 -k 26 -type random\n./gen -n 100 -k 26 -type palin\n./gen -n 100 -k 26 -type all_question_marks\n\n./gen -n 100 -k 25 -type impossible\n\n./gen -n 99 -k 26 -type random\n./gen -n 99 -k 26 -type palin\n\n./gen -n 3 -k 4 -type impossible\n./gen -n 4 -k 5 -type impossible\n\n./gen -n 10 -k 1 -type random\n./gen -n 10 -k 1 -type palin\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:19.922216",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "59/D",
      "title": "D. Team Arrangement",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 105) which is the number of resulting teams. The second line contains 3n space-separated integers from 1 to 3n which are the results of personal training sessions. It is guaranteed that every student appears in the results exactly once.Then follow n lines each containing three integers from 1 to 3n — each line describes the members of a given team. The members of one team can be listed in any order, but the teams themselves are listed in the order in which they were created. It is guaranteed that the arrangement is correct, that is that every student is a member of exactly one team and those teams could really be created from the given results using the method described above.The last line contains number k (1 ≤ k ≤ 3n) which is the number of a student for who the list of priorities should be found.",
      "output_spec": "OutputPrint 3n - 1 numbers — the lexicographically smallest list of priorities for the student number k. The lexicographical comparison is performed by the standard < operator in modern programming languages. The list a is lexicographically less that the list b if exists such an i (1 ≤ i ≤ 3n), that ai < bi, and for any j (1 ≤ j < i) aj = bj. Note, that the list 1 9 10 is lexicographically less than the list 1 10 9. That is, the comparison of lists is different from the comparison of lines.",
      "sample_tests": "ExamplesInputCopy35 4 1 2 6 3 7 8 95 6 29 3 41 7 84OutputCopy2 3 5 6 9 1 7 8 InputCopy35 4 1 2 6 3 7 8 95 6 29 3 41 7 88OutputCopy1 2 3 4 5 6 7 9 InputCopy24 1 3 2 5 64 6 51 2 34OutputCopy5 6 1 2 3",
      "description": "D. Team Arrangement\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 105) which is the number of resulting teams. The second line contains 3n space-separated integers from 1 to 3n which are the results of personal training sessions. It is guaranteed that every student appears in the results exactly once.Then follow n lines each containing three integers from 1 to 3n — each line describes the members of a given team. The members of one team can be listed in any order, but the teams themselves are listed in the order in which they were created. It is guaranteed that the arrangement is correct, that is that every student is a member of exactly one team and those teams could really be created from the given results using the method described above.The last line contains number k (1 ≤ k ≤ 3n) which is the number of a student for who the list of priorities should be found.\n\nOutputPrint 3n - 1 numbers — the lexicographically smallest list of priorities for the student number k. The lexicographical comparison is performed by the standard < operator in modern programming languages. The list a is lexicographically less that the list b if exists such an i (1 ≤ i ≤ 3n), that ai < bi, and for any j (1 ≤ j < i) aj = bj. Note, that the list 1 9 10 is lexicographically less than the list 1 10 9. That is, the comparison of lists is different from the comparison of lines.\n\nInputCopy35 4 1 2 6 3 7 8 95 6 29 3 41 7 84OutputCopy2 3 5 6 9 1 7 8 InputCopy35 4 1 2 6 3 7 8 95 6 29 3 41 7 88OutputCopy1 2 3 4 5 6 7 9 InputCopy24 1 3 2 5 64 6 51 2 34OutputCopy5 6 1 2 3\n\nInputCopy35 4 1 2 6 3 7 8 95 6 29 3 41 7 84\n\nOutputCopy2 3 5 6 9 1 7 8\n\nInputCopy35 4 1 2 6 3 7 8 95 6 29 3 41 7 88\n\nOutputCopy1 2 3 4 5 6 7 9\n\nInputCopy24 1 3 2 5 64 6 51 2 34\n\nOutputCopy5 6 1 2 3",
      "solutions": [
        {
          "title": "Codeforces Beta Round #55 (Div. 2) - Codeforces",
          "content": "While the world community of participants of programming contests is waiting with bated breath for the news about new date and place of the Final, we decided not to delay the next round and prepared some problems on the train from Petrozavodsk to Saratov. In preparation were involved Mike Mirzayanov, Artem Rakhov and Max Ivanov. Tasks were translated into English by Maria Belova.Good luck!Artem Rakhov and Codeforces team",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1272",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 424
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces",
          "content": "Here I am sharing how I approached and solved the problems of the recently held Round 55 (DIV 2)A. WordThis was an extremely simple problem. Simply count the number of upper case latin letters. If that is strictly greater than number of lower case letters convert the word to upper case other wise convert it to lower case. Complexity: O(wordlength)B. Fortune TellingFor this problem all you need to do is store the smallest odd number of petals and also the sum of all the petals. It is quite obvious that only if the number of petals is odd the result would be \"Loves\". So if the sum is even print sum - smallest odd, otherwise print the sum.Complexity: O(n).C. TitleThis was a very nice problem. My approach was to first flag all the letters which have already appeared. Notice, that we have to output the lexicographically smallest palindrome. So, start from the middle of the letter and iterate one side...If you get a '?' stop and check if the corresponding position on the other side also has a '?'. If yes, then fill both with the lexicographically biggest letter which hasn't appeared yet in the word and also flag that letter.Once you have exhausted all the letters and there are still '?' left then simply fill them with 'a'.Now simply iterate over the word again and see if there are any question marks left, if yes copy the values in the corresponding block on the other side. At the same time check if at any time the two opposite values match or not. If they do throughout then it is a valid plaindrome which is also the lexicographically smallest palindrome.Here is a slightly messy implementation of the same: http://codepad.org/Fr7NYqYTComplexity: O(wordlength + k)D. Team ArrangementThis was in my opinion was the toughest problem. However once you get the logic, its pretty obvious. However, it was a slightly challenging implementation for me as the structure of the data to be stored was sort of complex.The basic idea was simply that if we have to find the preference list of a number 'p' then two things might happen:Case 1: p is the most skilled in his team and thus he chose the team. In this case we know that all the members of the teams coming after p's team are less preferred than p's team mates. Let p's team mates be 'm' and 'n' such that m > n.To get the lexicographically smallest preference list, we will divide all the programmers into two lists. The first list will contain all members (ai) from teams which were chosen before p's team such that ai < m. It will also contain m and n.The second list will contain all the left over members.The separation can be done in O(n) time. Now all we need to do is sort the first list, print it, sort the second list, print it!Complexity: O(nlogn)... It can be reduced to O(n) also but the constant will be pretty high and will give almost the same result as O(nlogn).Case 2: p is not the leader of the team. Then you just have to output all number except 'p' from 1 to 3 * n.As for the last problem, I do not have a solution. I do not have much experienced with implementing graphs unfortunately.Please point out any optimizations to the above or mistakes which I might have made in the above.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1276",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3171
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #55 (Div. 2) - Codeforces - Code 1",
          "code": "#include <iostream>using namespace std;int n,k,r,m=100;int main(){   cin>>n;   while(n--)   {      cin>>k;      if(k&1)         m=min(m,k);      r+=k;   }   if(r&1)      cout<<r;   else if(m&1)      cout<<r-m;   else      cout<<0;}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1272",
          "author": "jiangly"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 1",
          "code": "while (!pq.empty()){\n    pair<int,int> v= pq.top();\n    pq.pop();\n\n    int ver=v.second;\n    for (int i=0;i<adj[ver].size();i++){\n       if (1+dist[ver]<dist[i] && map[mp(pre[ver],ver)] != i){\n         dist[i]=1+dist[ver];\n         pre[i]=ver;\n         pq.push(mp(dist[i],i));\n       }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "jiangly"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 2",
          "code": "while (!pq.empty()){\n    pair<int,int> v= pq.top();\n    pq.pop();\n\n    int ver=v.second;\n    for (int i=0;i<adj[ver].size();i++){\n       if (1+dist[ver]<dist[i] && map[mp(pre[ver],ver)] != i){\n         dist[i]=1+dist[ver];\n         pre[i]=ver;\n         pq.push(mp(dist[i],i));\n       }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "jiangly"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 3",
          "code": "map<pair<int,int>,int> map;\n\nfor (int i=0;i<m;i++){\n    int a,b;\n    cin >> a>>b;\n    adj[a].pb(b);\n    adj[b].pb(a);\n}\nfor (int i=0;i<k;i++){\n    int a,b,c;\n    cin >> a>>b>>c;\n    map.insert({make_pair(a,b),c});\n}\ndijkstra(map,1,n);\nif (dist[n]==INT_MAX) {\n    cout << -1; return 0;\n}\ncout << dist[n];\nint x=n;\nvector<int> route;\n\nwhile (x!=-1){\n    route.push_back(x);\n    x=pre[x];\n}\nfor(auto i=route.size()-1;i>-1;i--){\n    cout << route[i]<< \"  \";\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "jiangly"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 4",
          "code": "map<pair<int,int>,int> map;\n\nfor (int i=0;i<m;i++){\n    int a,b;\n    cin >> a>>b;\n    adj[a].pb(b);\n    adj[b].pb(a);\n}\nfor (int i=0;i<k;i++){\n    int a,b,c;\n    cin >> a>>b>>c;\n    map.insert({make_pair(a,b),c});\n}\ndijkstra(map,1,n);\nif (dist[n]==INT_MAX) {\n    cout << -1; return 0;\n}\ncout << dist[n];\nint x=n;\nvector<int> route;\n\nwhile (x!=-1){\n    route.push_back(x);\n    x=pre[x];\n}\nfor(auto i=route.size()-1;i>-1;i--){\n    cout << route[i]<< \"  \";\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int total_students = 3 * n;\n\n    vector<int> results;\n    results.reserve(total_students);\n\n    vector<bool> student_in_results(total_students + 1, false);\n\n    // Read 3n results\n    for (int i = 0; i < total_students; ++i) {\n        int x = inf.readInt(1, total_students, \"result_i\");\n        ensuref(!student_in_results[x], \"Student %d appears more than once in results\", x);\n        student_in_results[x] = true;\n        results.push_back(x);\n\n        if (i < total_students - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    vector<bool> student_in_teams(total_students + 1, false);\n\n    // Read n teams\n    for (int i = 0; i < n; ++i) {\n        int team_members[3];\n        for (int j = 0; j < 3; ++j) {\n            int x = inf.readInt(1, total_students, \"team_member\");\n            ensuref(!student_in_teams[x], \"Student %d appears in more than one team\", x);\n            student_in_teams[x] = true;\n            team_members[j] = x;\n\n            if (j < 2) {\n                inf.readSpace();\n            } else {\n                inf.readEoln();\n            }\n        }\n        ensuref(team_members[0] != team_members[1] && team_members[0] != team_members[2] && team_members[1] != team_members[2],\n            \"Team %d does not have 3 unique members\", i + 1);\n    }\n\n    // Check that all students are assigned to a team\n    for (int i = 1; i <= total_students; ++i) {\n        ensuref(student_in_teams[i], \"Student %d is not assigned to any team\", i);\n    }\n\n    int k = inf.readInt(1, total_students, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int total_students = 3 * n;\n\n    vector<int> results;\n    results.reserve(total_students);\n\n    vector<bool> student_in_results(total_students + 1, false);\n\n    // Read 3n results\n    for (int i = 0; i < total_students; ++i) {\n        int x = inf.readInt(1, total_students, \"result_i\");\n        ensuref(!student_in_results[x], \"Student %d appears more than once in results\", x);\n        student_in_results[x] = true;\n        results.push_back(x);\n\n        if (i < total_students - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    vector<bool> student_in_teams(total_students + 1, false);\n\n    // Read n teams\n    for (int i = 0; i < n; ++i) {\n        int team_members[3];\n        for (int j = 0; j < 3; ++j) {\n            int x = inf.readInt(1, total_students, \"team_member\");\n            ensuref(!student_in_teams[x], \"Student %d appears in more than one team\", x);\n            student_in_teams[x] = true;\n            team_members[j] = x;\n\n            if (j < 2) {\n                inf.readSpace();\n            } else {\n                inf.readEoln();\n            }\n        }\n        ensuref(team_members[0] != team_members[1] && team_members[0] != team_members[2] && team_members[1] != team_members[2],\n            \"Team %d does not have 3 unique members\", i + 1);\n    }\n\n    // Check that all students are assigned to a team\n    for (int i = 1; i <= total_students; ++i) {\n        ensuref(student_in_teams[i], \"Student %d is not assigned to any team\", i);\n    }\n\n    int k = inf.readInt(1, total_students, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int total_students = 3 * n;\n\n    vector<int> results;\n    results.reserve(total_students);\n\n    vector<bool> student_in_results(total_students + 1, false);\n\n    // Read 3n results\n    for (int i = 0; i < total_students; ++i) {\n        int x = inf.readInt(1, total_students, \"result_i\");\n        ensuref(!student_in_results[x], \"Student %d appears more than once in results\", x);\n        student_in_results[x] = true;\n        results.push_back(x);\n\n        if (i < total_students - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    vector<bool> student_in_teams(total_students + 1, false);\n\n    // Read n teams\n    for (int i = 0; i < n; ++i) {\n        int team_members[3];\n        for (int j = 0; j < 3; ++j) {\n            int x = inf.readInt(1, total_students, \"team_member\");\n            ensuref(!student_in_teams[x], \"Student %d appears in more than one team\", x);\n            student_in_teams[x] = true;\n            team_members[j] = x;\n\n            if (j < 2) {\n                inf.readSpace();\n            } else {\n                inf.readEoln();\n            }\n        }\n        ensuref(team_members[0] != team_members[1] && team_members[0] != team_members[2] && team_members[1] != team_members[2],\n            \"Team %d does not have 3 unique members\", i + 1);\n    }\n\n    // Check that all students are assigned to a team\n    for (int i = 1; i <= total_students; ++i) {\n        ensuref(student_in_teams[i], \"Student %d is not assigned to any team\", i);\n    }\n\n    int k = inf.readInt(1, total_students, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    int N = 3 * n;\n    ensure(1 <= n && n <= 100000);\n    if (k == -1) k = rnd.next(1, N);\n    ensure(1 <= k && k <= N);\n\n    vector<int> results(N);\n    for (int i = 0; i < N; ++i) {\n        results[i] = i + 1;\n    }\n    shuffle(results.begin(), results.end());\n\n    set<int> unassigned_students;\n    for (int i = 1; i <= N; ++i) {\n        unassigned_students.insert(i);\n    }\n\n    vector<vector<int>> teams;\n\n    while (!unassigned_students.empty()) {\n        // Find the unassigned student with best score (lowest index in results[])\n        int best_student = -1;\n        for (int i = 0; i < N; ++i) {\n            if (unassigned_students.count(results[i])) {\n                best_student = results[i];\n                break;\n            }\n        }\n        int captain = best_student;\n\n        // Handle 'k_is_captain' type\n        if (type == \"k_is_captain\" && captain != k && unassigned_students.count(k)) {\n            captain = k;\n        }\n        unassigned_students.erase(captain);\n\n        // Prepare list of unassigned students (excluding captain)\n        vector<int> unassigned_vector;\n        for (int student : unassigned_students) {\n            if (student != captain) {\n                unassigned_vector.push_back(student);\n            }\n        }\n        int teammate1, teammate2;\n\n        // Now select two teammates\n        if (unassigned_vector.size() >= 2) {\n            shuffle(unassigned_vector.begin(), unassigned_vector.end());\n            teammate1 = unassigned_vector[0];\n            teammate2 = unassigned_vector[1];\n            unassigned_students.erase(teammate1);\n            unassigned_students.erase(teammate2);\n        } else {\n            // n=1 case, only two students left\n            teammate1 = *unassigned_vector.begin();\n            unassigned_students.erase(teammate1);\n            teammate2 = *unassigned_students.begin();\n            unassigned_students.erase(teammate2);\n        }\n        vector<int> team = {captain, teammate1, teammate2};\n        teams.push_back(team);\n    }\n\n    // Now output the data\n    printf(\"%d\\n\", n);\n    // Output the results[]\n    for (int i = 0; i < N; ++i) {\n        printf(\"%d\", results[i]);\n        if (i + 1 < N) printf(\" \");\n    }\n    printf(\"\\n\");\n    // Output teams in the order they were formed\n    for (size_t i = 0; i < teams.size(); ++i) {\n        // Shuffle team members\n        shuffle(teams[i].begin(), teams[i].end());\n        printf(\"%d %d %d\\n\", teams[i][0], teams[i][1], teams[i][2]);\n    }\n    // Output k\n    printf(\"%d\\n\", k);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    int N = 3 * n;\n    ensure(1 <= n && n <= 100000);\n    if (k == -1) k = rnd.next(1, N);\n    ensure(1 <= k && k <= N);\n\n    vector<int> results(N);\n    for (int i = 0; i < N; ++i) {\n        results[i] = i + 1;\n    }\n    shuffle(results.begin(), results.end());\n\n    set<int> unassigned_students;\n    for (int i = 1; i <= N; ++i) {\n        unassigned_students.insert(i);\n    }\n\n    vector<vector<int>> teams;\n\n    while (!unassigned_students.empty()) {\n        // Find the unassigned student with best score (lowest index in results[])\n        int best_student = -1;\n        for (int i = 0; i < N; ++i) {\n            if (unassigned_students.count(results[i])) {\n                best_student = results[i];\n                break;\n            }\n        }\n        int captain = best_student;\n\n        // Handle 'k_is_captain' type\n        if (type == \"k_is_captain\" && captain != k && unassigned_students.count(k)) {\n            captain = k;\n        }\n        unassigned_students.erase(captain);\n\n        // Prepare list of unassigned students (excluding captain)\n        vector<int> unassigned_vector;\n        for (int student : unassigned_students) {\n            if (student != captain) {\n                unassigned_vector.push_back(student);\n            }\n        }\n        int teammate1, teammate2;\n\n        // Now select two teammates\n        if (unassigned_vector.size() >= 2) {\n            shuffle(unassigned_vector.begin(), unassigned_vector.end());\n            teammate1 = unassigned_vector[0];\n            teammate2 = unassigned_vector[1];\n            unassigned_students.erase(teammate1);\n            unassigned_students.erase(teammate2);\n        } else {\n            // n=1 case, only two students left\n            teammate1 = *unassigned_vector.begin();\n            unassigned_students.erase(teammate1);\n            teammate2 = *unassigned_students.begin();\n            unassigned_students.erase(teammate2);\n        }\n        vector<int> team = {captain, teammate1, teammate2};\n        teams.push_back(team);\n    }\n\n    // Now output the data\n    printf(\"%d\\n\", n);\n    // Output the results[]\n    for (int i = 0; i < N; ++i) {\n        printf(\"%d\", results[i]);\n        if (i + 1 < N) printf(\" \");\n    }\n    printf(\"\\n\");\n    // Output teams in the order they were formed\n    for (size_t i = 0; i < teams.size(); ++i) {\n        // Shuffle team members\n        shuffle(teams[i].begin(), teams[i].end());\n        printf(\"%d %d %d\\n\", teams[i][0], teams[i][1], teams[i][2]);\n    }\n    // Output k\n    printf(\"%d\\n\", k);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type random\n./gen -n 1 -k 2 -type random\n./gen -n 1 -k 3 -type random\n./gen -n 5 -k 5 -type random\n./gen -n 5 -k 10 -type random\n./gen -n 5 -k 15 -type random\n./gen -n 10 -k 1 -type random\n./gen -n 10 -k 10 -type random\n./gen -n 10 -k 30 -type random\n./gen -n 100 -k 50 -type random\n./gen -n 100 -k 100 -type random\n./gen -n 100 -k 300 -type random\n./gen -n 500 -k 1 -type random\n./gen -n 500 -k 750 -type random\n./gen -n 500 -k 1500 -type random\n./gen -n 1000 -k 1 -type random\n./gen -n 1000 -k 1500 -type random\n./gen -n 1000 -k 3000 -type random\n./gen -n 5000 -k 1 -type random\n./gen -n 5000 -k 7500 -type random\n./gen -n 5000 -k 15000 -type random\n./gen -n 10000 -k 1 -type random\n./gen -n 10000 -k 15000 -type random\n./gen -n 10000 -k 30000 -type random\n./gen -n 50000 -k 1 -type random\n./gen -n 50000 -k 75000 -type random\n./gen -n 50000 -k 150000 -type random\n./gen -n 100000 -k 1 -type random\n./gen -n 100000 -k 150000 -type random\n./gen -n 100000 -k 300000 -type random\n./gen -n 100000 -k 1 -type k_is_captain\n./gen -n 100000 -k 150000 -type k_is_captain\n./gen -n 100000 -k 300000 -type k_is_captain\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:21.838148",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "59/E",
      "title": "E. Shortest Path",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m, k (2 ≤ n ≤ 3000, 1 ≤ m ≤ 20000, 0 ≤ k ≤ 105) which are the number of cities, the number of roads and the number of the forbidden triplets correspondingly. Then follow m lines each containing two integers xi, yi (1 ≤ xi, yi ≤ n) which are the road descriptions. The road is described by the numbers of the cities it joins. No road joins a city with itself, there cannot be more than one road between a pair of cities. Then follow k lines each containing three integers ai, bi, ci (1 ≤ ai, bi, ci ≤ n) which are the forbidden triplets. Each ordered triplet is listed mo more than one time. All three cities in each triplet are distinct.City n can be unreachable from city 1 by roads.",
      "output_spec": "OutputIf there are no path from 1 to n print -1. Otherwise on the first line print the number of roads d along the shortest path from the city 1 to the city n. On the second line print d + 1 numbers — any of the possible shortest paths for Vasya. The path should start in the city 1 and end in the city n.",
      "sample_tests": "ExamplesInputCopy4 4 11 22 33 41 31 4 3OutputCopy21 3 4InputCopy3 1 01 2OutputCopy-1InputCopy4 4 21 22 33 41 31 2 31 3 4OutputCopy41 3 2 3 4",
      "description": "E. Shortest Path\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m, k (2 ≤ n ≤ 3000, 1 ≤ m ≤ 20000, 0 ≤ k ≤ 105) which are the number of cities, the number of roads and the number of the forbidden triplets correspondingly. Then follow m lines each containing two integers xi, yi (1 ≤ xi, yi ≤ n) which are the road descriptions. The road is described by the numbers of the cities it joins. No road joins a city with itself, there cannot be more than one road between a pair of cities. Then follow k lines each containing three integers ai, bi, ci (1 ≤ ai, bi, ci ≤ n) which are the forbidden triplets. Each ordered triplet is listed mo more than one time. All three cities in each triplet are distinct.City n can be unreachable from city 1 by roads.\n\nOutputIf there are no path from 1 to n print -1. Otherwise on the first line print the number of roads d along the shortest path from the city 1 to the city n. On the second line print d + 1 numbers — any of the possible shortest paths for Vasya. The path should start in the city 1 and end in the city n.\n\nInputCopy4 4 11 22 33 41 31 4 3OutputCopy21 3 4InputCopy3 1 01 2OutputCopy-1InputCopy4 4 21 22 33 41 31 2 31 3 4OutputCopy41 3 2 3 4\n\nInputCopy4 4 11 22 33 41 31 4 3\n\nOutputCopy21 3 4\n\nInputCopy3 1 01 2\n\nOutputCopy-1\n\nInputCopy4 4 21 22 33 41 31 2 31 3 4\n\nOutputCopy41 3 2 3 4",
      "solutions": [
        {
          "title": "Codeforces Beta Round #55 (Div. 2) - Codeforces",
          "content": "While the world community of participants of programming contests is waiting with bated breath for the news about new date and place of the Final, we decided not to delay the next round and prepared some problems on the train from Petrozavodsk to Saratov. In preparation were involved Mike Mirzayanov, Artem Rakhov and Max Ivanov. Tasks were translated into English by Maria Belova.Good luck!Artem Rakhov and Codeforces team",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1272",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 424
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces",
          "content": "Here I am sharing how I approached and solved the problems of the recently held Round 55 (DIV 2)A. WordThis was an extremely simple problem. Simply count the number of upper case latin letters. If that is strictly greater than number of lower case letters convert the word to upper case other wise convert it to lower case. Complexity: O(wordlength)B. Fortune TellingFor this problem all you need to do is store the smallest odd number of petals and also the sum of all the petals. It is quite obvious that only if the number of petals is odd the result would be \"Loves\". So if the sum is even print sum - smallest odd, otherwise print the sum.Complexity: O(n).C. TitleThis was a very nice problem. My approach was to first flag all the letters which have already appeared. Notice, that we have to output the lexicographically smallest palindrome. So, start from the middle of the letter and iterate one side...If you get a '?' stop and check if the corresponding position on the other side also has a '?'. If yes, then fill both with the lexicographically biggest letter which hasn't appeared yet in the word and also flag that letter.Once you have exhausted all the letters and there are still '?' left then simply fill them with 'a'.Now simply iterate over the word again and see if there are any question marks left, if yes copy the values in the corresponding block on the other side. At the same time check if at any time the two opposite values match or not. If they do throughout then it is a valid plaindrome which is also the lexicographically smallest palindrome.Here is a slightly messy implementation of the same: http://codepad.org/Fr7NYqYTComplexity: O(wordlength + k)D. Team ArrangementThis was in my opinion was the toughest problem. However once you get the logic, its pretty obvious. However, it was a slightly challenging implementation for me as the structure of the data to be stored was sort of complex.The basic idea was simply that if we have to find the preference list of a number 'p' then two things might happen:Case 1: p is the most skilled in his team and thus he chose the team. In this case we know that all the members of the teams coming after p's team are less preferred than p's team mates. Let p's team mates be 'm' and 'n' such that m > n.To get the lexicographically smallest preference list, we will divide all the programmers into two lists. The first list will contain all members (ai) from teams which were chosen before p's team such that ai < m. It will also contain m and n.The second list will contain all the left over members.The separation can be done in O(n) time. Now all we need to do is sort the first list, print it, sort the second list, print it!Complexity: O(nlogn)... It can be reduced to O(n) also but the constant will be pretty high and will give almost the same result as O(nlogn).Case 2: p is not the leader of the team. Then you just have to output all number except 'p' from 1 to 3 * n.As for the last problem, I do not have a solution. I do not have much experienced with implementing graphs unfortunately.Please point out any optimizations to the above or mistakes which I might have made in the above.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1276",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3171
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #55 (Div. 2) - Codeforces - Code 1",
          "code": "#include <iostream>using namespace std;int n,k,r,m=100;int main(){   cin>>n;   while(n--)   {      cin>>k;      if(k&1)         m=min(m,k);      r+=k;   }   if(r&1)      cout<<r;   else if(m&1)      cout<<r-m;   else      cout<<0;}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/1272",
          "author": "jiangly"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 1",
          "code": "while (!pq.empty()){\n    pair<int,int> v= pq.top();\n    pq.pop();\n\n    int ver=v.second;\n    for (int i=0;i<adj[ver].size();i++){\n       if (1+dist[ver]<dist[i] && map[mp(pre[ver],ver)] != i){\n         dist[i]=1+dist[ver];\n         pre[i]=ver;\n         pq.push(mp(dist[i],i));\n       }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "jiangly"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 2",
          "code": "while (!pq.empty()){\n    pair<int,int> v= pq.top();\n    pq.pop();\n\n    int ver=v.second;\n    for (int i=0;i<adj[ver].size();i++){\n       if (1+dist[ver]<dist[i] && map[mp(pre[ver],ver)] != i){\n         dist[i]=1+dist[ver];\n         pre[i]=ver;\n         pq.push(mp(dist[i],i));\n       }\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "jiangly"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 3",
          "code": "map<pair<int,int>,int> map;\n\nfor (int i=0;i<m;i++){\n    int a,b;\n    cin >> a>>b;\n    adj[a].pb(b);\n    adj[b].pb(a);\n}\nfor (int i=0;i<k;i++){\n    int a,b,c;\n    cin >> a>>b>>c;\n    map.insert({make_pair(a,b),c});\n}\ndijkstra(map,1,n);\nif (dist[n]==INT_MAX) {\n    cout << -1; return 0;\n}\ncout << dist[n];\nint x=n;\nvector<int> route;\n\nwhile (x!=-1){\n    route.push_back(x);\n    x=pre[x];\n}\nfor(auto i=route.size()-1;i>-1;i--){\n    cout << route[i]<< \"  \";\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "jiangly"
        },
        {
          "title": "Round 55 (DIV 2) - Codeforces - Code 4",
          "code": "map<pair<int,int>,int> map;\n\nfor (int i=0;i<m;i++){\n    int a,b;\n    cin >> a>>b;\n    adj[a].pb(b);\n    adj[b].pb(a);\n}\nfor (int i=0;i<k;i++){\n    int a,b,c;\n    cin >> a>>b>>c;\n    map.insert({make_pair(a,b),c});\n}\ndijkstra(map,1,n);\nif (dist[n]==INT_MAX) {\n    cout << -1; return 0;\n}\ncout << dist[n];\nint x=n;\nvector<int> route;\n\nwhile (x!=-1){\n    route.push_back(x);\n    x=pre[x];\n}\nfor(auto i=route.size()-1;i>-1;i--){\n    cout << route[i]<< \"  \";\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1276",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n\n        ensuref(xi != yi, \"Road cannot connect city to itself at line %d\", i + 2);\n\n        int u = xi, v = yi;\n        if (u > v) swap(u, v);\n        pair<int, int> edge = make_pair(u, v);\n\n        ensuref(edges.find(edge) == edges.end(), \"Duplicate road between cities %d and %d at line %d\", u, v, i + 2);\n        edges.insert(edge);\n    }\n\n    set<tuple<int, int, int>> triplets;\n    for (int i = 0; i < k; ++i) {\n        int ai = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"b_i\");\n        inf.readSpace();\n        int ci = inf.readInt(1, n, \"c_i\");\n        inf.readEoln();\n\n        ensuref(ai != bi && ai != ci && bi != ci, \"Forbidden triplet cities must be distinct at line %d\", m + i + 2);\n\n        tuple<int, int, int> triplet = make_tuple(ai, bi, ci);\n\n        ensuref(triplets.find(triplet) == triplets.end(), \"Duplicate forbidden triplet at line %d\", m + i + 2);\n        triplets.insert(triplet);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n\n        ensuref(xi != yi, \"Road cannot connect city to itself at line %d\", i + 2);\n\n        int u = xi, v = yi;\n        if (u > v) swap(u, v);\n        pair<int, int> edge = make_pair(u, v);\n\n        ensuref(edges.find(edge) == edges.end(), \"Duplicate road between cities %d and %d at line %d\", u, v, i + 2);\n        edges.insert(edge);\n    }\n\n    set<tuple<int, int, int>> triplets;\n    for (int i = 0; i < k; ++i) {\n        int ai = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"b_i\");\n        inf.readSpace();\n        int ci = inf.readInt(1, n, \"c_i\");\n        inf.readEoln();\n\n        ensuref(ai != bi && ai != ci && bi != ci, \"Forbidden triplet cities must be distinct at line %d\", m + i + 2);\n\n        tuple<int, int, int> triplet = make_tuple(ai, bi, ci);\n\n        ensuref(triplets.find(triplet) == triplets.end(), \"Duplicate forbidden triplet at line %d\", m + i + 2);\n        triplets.insert(triplet);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 3000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000, \"k\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n\n        ensuref(xi != yi, \"Road cannot connect city to itself at line %d\", i + 2);\n\n        int u = xi, v = yi;\n        if (u > v) swap(u, v);\n        pair<int, int> edge = make_pair(u, v);\n\n        ensuref(edges.find(edge) == edges.end(), \"Duplicate road between cities %d and %d at line %d\", u, v, i + 2);\n        edges.insert(edge);\n    }\n\n    set<tuple<int, int, int>> triplets;\n    for (int i = 0; i < k; ++i) {\n        int ai = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"b_i\");\n        inf.readSpace();\n        int ci = inf.readInt(1, n, \"c_i\");\n        inf.readEoln();\n\n        ensuref(ai != bi && ai != ci && bi != ci, \"Forbidden triplet cities must be distinct at line %d\", m + i + 2);\n\n        tuple<int, int, int> triplet = make_tuple(ai, bi, ci);\n\n        ensuref(triplets.find(triplet) == triplets.end(), \"Duplicate forbidden triplet at line %d\", m + i + 2);\n        triplets.insert(triplet);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, k;\nvector<vector<int>> adj;\nunordered_map<int, unordered_map<int, unordered_set<int>>> forbidden;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    // Read the input data from the input file\n    n = inf.readInt();\n    m = inf.readInt();\n    k = inf.readInt();\n    \n    adj.resize(n + 1);\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt();\n        int v = inf.readInt();\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    \n    // Build the forbidden triplets map\n    for (int i = 0; i < k; i++) {\n        int a = inf.readInt();\n        int b = inf.readInt();\n        int c = inf.readInt();\n        forbidden[a][b].insert(c);\n    }\n    \n    // Compute the minimal distance from city 1 to city n avoiding forbidden triplets\n    const int INF = INT_MAX;\n    vector<vector<int>> dist(n + 1, vector<int>(n + 1, INF));\n    dist[1][0] = 0;\n    queue<pair<int, int>> q;\n    q.push({1, 0});\n    \n    while (!q.empty()) {\n        int current = q.front().first;\n        int prev = q.front().second;\n        q.pop();\n        int current_dist = dist[current][prev];\n        for (int next : adj[current]) {\n            // Check if the triplet (prev, current, next) is forbidden\n            if (forbidden.count(prev) && forbidden[prev].count(current) && forbidden[prev][current].count(next)) {\n                continue;\n            }\n            if (dist[next][current] > current_dist + 1) {\n                dist[next][current] = current_dist + 1;\n                q.push({next, current});\n            }\n        }\n    }\n    \n    // Find the minimal distance to city n\n    int min_dist = INF;\n    for (int prev = 0; prev <= n; prev++) {\n        if (dist[n][prev] < min_dist) {\n            min_dist = dist[n][prev];\n        }\n    }\n    \n    // Read the contestant's output\n    int first_number = ouf.readInt();\n    if (first_number == -1) {\n        // Contestant claims no path exists\n        if (min_dist == INF) {\n            quitf(_ok, \"Correctly reported no path exists\");\n        } else {\n            quitf(_wa, \"A path exists, but contestant reported no path\");\n        }\n    } else {\n        // Contestant outputs the length of the path\n        int contestant_d = first_number;\n        int path_length = contestant_d + 1;\n        if (path_length < 2) {\n            quitf(_wa, \"Path length should be at least 2\");\n        }\n        vector<int> path(path_length);\n        for (int i = 0; i < path_length; i++) {\n            path[i] = ouf.readInt(1, n, format(\"path[%d]\", i + 1).c_str());\n        }\n        // Check that the path starts at 1 and ends at n\n        if (path.front() != 1) {\n            quitf(_wa, \"Path does not start at city 1\");\n        }\n        if (path.back() != n) {\n            quitf(_wa, \"Path does not end at city n\");\n        }\n        // Check that consecutive nodes are connected\n        for (int i = 0; i < path_length - 1; i++) {\n            int u = path[i];\n            int v = path[i + 1];\n            bool connected = false;\n            for (int neighbor : adj[u]) {\n                if (neighbor == v) {\n                    connected = true;\n                    break;\n                }\n            }\n            if (!connected) {\n                quitf(_wa, \"Edge (%d, %d) does not exist in the graph\", u, v);\n            }\n        }\n        // Check that the path avoids forbidden triplets\n        for (int i = 2; i < path_length; i++) {\n            int a = path[i - 2];\n            int b = path[i - 1];\n            int c = path[i];\n            if (forbidden.count(a) && forbidden[a].count(b) && forbidden[a][b].count(c)) {\n                quitf(_wa, \"Forbidden triplet (%d, %d, %d) encountered in path\", a, b, c);\n            }\n        }\n        // Check that the path length is minimal\n        if (contestant_d != min_dist) {\n            quitf(_wa, \"Path length is not minimal; contestant path length = %d, minimal path length = %d\", contestant_d, min_dist);\n        }\n        quitf(_ok, \"Correct path of minimal length %d\", min_dist);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateConnectedGraph(int n, int m, vector<pair<int,int>>& edges) {\n    if (m < n - 1) {\n        fprintf(stderr, \"Not enough edges to form a connected graph\\n\");\n        exit(1);\n    }\n\n    vector<int> parent(n+1);\n    iota(parent.begin(), parent.end(), 0);\n\n    function<int(int)> find = [&](int x) {\n        return parent[x] == x ? x : parent[x] = find(parent[x]);\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) {\n            parent[x] = y;\n            return true;\n        }\n        return false;\n    };\n\n    set<pair<int,int>> edge_set;\n\n    // Generate a random spanning tree\n    for (int i = 1; i < n; ++i) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        while (find(u) == find(v) || u == v) {\n            u = rnd.next(1, n);\n            v = rnd.next(1, n);\n        }\n        unite(u, v);\n        auto e = make_pair(min(u,v), max(u,v));\n        edge_set.insert(e);\n        edges.push_back(e);\n    }\n\n    // Add more random edges to reach m edges\n    while ((int)edge_set.size() < m) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        if (u == v) continue;\n        auto e = make_pair(min(u,v), max(u,v));\n        if (!edge_set.count(e)) {\n            edge_set.insert(e);\n            edges.push_back(e);\n        }\n    }\n}\n\nvoid generateRandomGraph(int n, int m, vector<pair<int,int>>& edges) {\n    set<pair<int,int>> edge_set;\n    while ((int)edge_set.size() < m) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        if (u == v) continue;\n        auto e = make_pair(min(u,v), max(u,v));\n        if (!edge_set.count(e)) {\n            edge_set.insert(e);\n            edges.push_back(e);\n        }\n    }\n}\n\nvoid generateChainGraph(int n, int m, vector<pair<int,int>>& edges) {\n    if (m < n - 1) {\n        fprintf(stderr, \"Not enough edges to form a chain graph\\n\");\n        exit(1);\n    }\n    for (int i = 1; i < n; ++i) {\n        edges.push_back({i, i+1});\n    }\n    // Add additional random edges\n    set<pair<int,int>> edge_set(edges.begin(), edges.end());\n    while ((int)edge_set.size() < m) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        if (u == v) continue;\n        auto e = make_pair(min(u,v), max(u,v));\n        if (!edge_set.count(e)) {\n            edge_set.insert(e);\n            edges.push_back(e);\n        }\n    }\n}\n\nvoid generateStarGraph(int n, int m, vector<pair<int,int>>& edges) {\n    if (m < n - 1) {\n        fprintf(stderr, \"Not enough edges to form a star graph\\n\");\n        exit(1);\n    }\n    for (int i = 2; i <= n; ++i) {\n        edges.push_back({1, i});\n    }\n    // Add additional random edges\n    set<pair<int,int>> edge_set(edges.begin(), edges.end());\n    while ((int)edge_set.size() < m) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        if (u == v) continue;\n        auto e = make_pair(min(u,v), max(u,v));\n        if (!edge_set.count(e)) {\n            edge_set.insert(e);\n            edges.push_back(e);\n        }\n    }\n}\n\nvoid generateRandomForbiddenTriplets(int n, int k, set<tuple<int,int,int>>& forbidden) {\n    while ((int)forbidden.size() < k) {\n        int a = rnd.next(1, n);\n        int b = rnd.next(1, n);\n        int c = rnd.next(1, n);\n        set<int> s = {a, b, c};\n        if ((int)s.size() < 3) continue;\n        auto t = make_tuple(a, b, c);\n        if (!forbidden.count(t)) {\n            forbidden.insert(t);\n        }\n    }\n}\n\nvoid generatePathForbiddenTriplets(vector<int>& path, int k, set<tuple<int,int,int>>& forbidden) {\n    for (int i = 0; i + 2 < (int)path.size(); ++i) {\n        int a = path[i];\n        int b = path[i+1];\n        int c = path[i+2];\n        forbidden.insert(make_tuple(a, b, c));\n        if ((int)forbidden.size() >= k) break;\n    }\n    // If k > number of triplets in path, generate random forbidden triplets\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n    bool connected = opt<bool>(\"connected\", true);\n    string ftype = opt<string>(\"ftype\", \"none\");\n\n    vector<pair<int,int>> edges;\n\n    if (type == \"random\") {\n        if (connected)\n            generateConnectedGraph(n, m, edges);\n        else\n            generateRandomGraph(n, m, edges);\n    } else if (type == \"chain\") {\n        generateChainGraph(n, m, edges);\n    } else if (type == \"star\") {\n        generateStarGraph(n, m, edges);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    set<tuple<int,int,int>> forbidden;\n\n    if (ftype == \"none\") {\n        // Do nothing\n    } else if (ftype == \"random\") {\n        generateRandomForbiddenTriplets(n, k, forbidden);\n    } else if (ftype == \"path\") {\n        // For path forbidden triplets, we need to obtain a path\n        vector<int> path;\n        if (type == \"chain\") {\n            for (int i = 1; i <= n; ++i)\n                path.push_back(i);\n        } else if (type == \"star\") {\n            path.push_back(1);\n            path.push_back(2); // There is no unique path in star; pick some path\n            path.push_back(n);\n        } else {\n            // For random graph, we can attempt to find a path from 1 to n using BFS\n            vector<int> visited(n+1, 0);\n            vector<int> prev(n+1, -1);\n            queue<int> q;\n            q.push(1);\n            visited[1] = 1;\n            vector<vector<int>> adj(n+1);\n            for (auto e : edges) {\n                adj[e.first].push_back(e.second);\n                adj[e.second].push_back(e.first);\n            }\n            bool found = false;\n            while (!q.empty()) {\n                int u = q.front(); q.pop();\n                if (u == n) {\n                    found = true;\n                    break;\n                }\n                for (int v : adj[u]) {\n                    if (!visited[v]) {\n                        visited[v] = 1;\n                        prev[v] = u;\n                        q.push(v);\n                    }\n                }\n            }\n            if (found) {\n                // Reconstruct path\n                int curr = n;\n                while (curr != -1) {\n                    path.push_back(curr);\n                    curr = prev[curr];\n                }\n                reverse(path.begin(), path.end());\n            } else {\n                // No path from 1 to n\n            }\n        }\n        if (!path.empty())\n            generatePathForbiddenTriplets(path, k, forbidden);\n\n        if ((int)forbidden.size() < k)\n            generateRandomForbiddenTriplets(n, k - forbidden.size(), forbidden);\n    } else {\n        fprintf(stderr, \"Unknown ftype: %s\\n\", ftype.c_str());\n        exit(1);\n    }\n\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    for (auto t : forbidden) {\n        int a, b, c;\n        tie(a,b,c) = t;\n        printf(\"%d %d %d\\n\", a, b, c);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateConnectedGraph(int n, int m, vector<pair<int,int>>& edges) {\n    if (m < n - 1) {\n        fprintf(stderr, \"Not enough edges to form a connected graph\\n\");\n        exit(1);\n    }\n\n    vector<int> parent(n+1);\n    iota(parent.begin(), parent.end(), 0);\n\n    function<int(int)> find = [&](int x) {\n        return parent[x] == x ? x : parent[x] = find(parent[x]);\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) {\n            parent[x] = y;\n            return true;\n        }\n        return false;\n    };\n\n    set<pair<int,int>> edge_set;\n\n    // Generate a random spanning tree\n    for (int i = 1; i < n; ++i) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        while (find(u) == find(v) || u == v) {\n            u = rnd.next(1, n);\n            v = rnd.next(1, n);\n        }\n        unite(u, v);\n        auto e = make_pair(min(u,v), max(u,v));\n        edge_set.insert(e);\n        edges.push_back(e);\n    }\n\n    // Add more random edges to reach m edges\n    while ((int)edge_set.size() < m) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        if (u == v) continue;\n        auto e = make_pair(min(u,v), max(u,v));\n        if (!edge_set.count(e)) {\n            edge_set.insert(e);\n            edges.push_back(e);\n        }\n    }\n}\n\nvoid generateRandomGraph(int n, int m, vector<pair<int,int>>& edges) {\n    set<pair<int,int>> edge_set;\n    while ((int)edge_set.size() < m) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        if (u == v) continue;\n        auto e = make_pair(min(u,v), max(u,v));\n        if (!edge_set.count(e)) {\n            edge_set.insert(e);\n            edges.push_back(e);\n        }\n    }\n}\n\nvoid generateChainGraph(int n, int m, vector<pair<int,int>>& edges) {\n    if (m < n - 1) {\n        fprintf(stderr, \"Not enough edges to form a chain graph\\n\");\n        exit(1);\n    }\n    for (int i = 1; i < n; ++i) {\n        edges.push_back({i, i+1});\n    }\n    // Add additional random edges\n    set<pair<int,int>> edge_set(edges.begin(), edges.end());\n    while ((int)edge_set.size() < m) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        if (u == v) continue;\n        auto e = make_pair(min(u,v), max(u,v));\n        if (!edge_set.count(e)) {\n            edge_set.insert(e);\n            edges.push_back(e);\n        }\n    }\n}\n\nvoid generateStarGraph(int n, int m, vector<pair<int,int>>& edges) {\n    if (m < n - 1) {\n        fprintf(stderr, \"Not enough edges to form a star graph\\n\");\n        exit(1);\n    }\n    for (int i = 2; i <= n; ++i) {\n        edges.push_back({1, i});\n    }\n    // Add additional random edges\n    set<pair<int,int>> edge_set(edges.begin(), edges.end());\n    while ((int)edge_set.size() < m) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        if (u == v) continue;\n        auto e = make_pair(min(u,v), max(u,v));\n        if (!edge_set.count(e)) {\n            edge_set.insert(e);\n            edges.push_back(e);\n        }\n    }\n}\n\nvoid generateRandomForbiddenTriplets(int n, int k, set<tuple<int,int,int>>& forbidden) {\n    while ((int)forbidden.size() < k) {\n        int a = rnd.next(1, n);\n        int b = rnd.next(1, n);\n        int c = rnd.next(1, n);\n        set<int> s = {a, b, c};\n        if ((int)s.size() < 3) continue;\n        auto t = make_tuple(a, b, c);\n        if (!forbidden.count(t)) {\n            forbidden.insert(t);\n        }\n    }\n}\n\nvoid generatePathForbiddenTriplets(vector<int>& path, int k, set<tuple<int,int,int>>& forbidden) {\n    for (int i = 0; i + 2 < (int)path.size(); ++i) {\n        int a = path[i];\n        int b = path[i+1];\n        int c = path[i+2];\n        forbidden.insert(make_tuple(a, b, c));\n        if ((int)forbidden.size() >= k) break;\n    }\n    // If k > number of triplets in path, generate random forbidden triplets\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\", 0);\n    string type = opt<string>(\"type\", \"random\");\n    bool connected = opt<bool>(\"connected\", true);\n    string ftype = opt<string>(\"ftype\", \"none\");\n\n    vector<pair<int,int>> edges;\n\n    if (type == \"random\") {\n        if (connected)\n            generateConnectedGraph(n, m, edges);\n        else\n            generateRandomGraph(n, m, edges);\n    } else if (type == \"chain\") {\n        generateChainGraph(n, m, edges);\n    } else if (type == \"star\") {\n        generateStarGraph(n, m, edges);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    set<tuple<int,int,int>> forbidden;\n\n    if (ftype == \"none\") {\n        // Do nothing\n    } else if (ftype == \"random\") {\n        generateRandomForbiddenTriplets(n, k, forbidden);\n    } else if (ftype == \"path\") {\n        // For path forbidden triplets, we need to obtain a path\n        vector<int> path;\n        if (type == \"chain\") {\n            for (int i = 1; i <= n; ++i)\n                path.push_back(i);\n        } else if (type == \"star\") {\n            path.push_back(1);\n            path.push_back(2); // There is no unique path in star; pick some path\n            path.push_back(n);\n        } else {\n            // For random graph, we can attempt to find a path from 1 to n using BFS\n            vector<int> visited(n+1, 0);\n            vector<int> prev(n+1, -1);\n            queue<int> q;\n            q.push(1);\n            visited[1] = 1;\n            vector<vector<int>> adj(n+1);\n            for (auto e : edges) {\n                adj[e.first].push_back(e.second);\n                adj[e.second].push_back(e.first);\n            }\n            bool found = false;\n            while (!q.empty()) {\n                int u = q.front(); q.pop();\n                if (u == n) {\n                    found = true;\n                    break;\n                }\n                for (int v : adj[u]) {\n                    if (!visited[v]) {\n                        visited[v] = 1;\n                        prev[v] = u;\n                        q.push(v);\n                    }\n                }\n            }\n            if (found) {\n                // Reconstruct path\n                int curr = n;\n                while (curr != -1) {\n                    path.push_back(curr);\n                    curr = prev[curr];\n                }\n                reverse(path.begin(), path.end());\n            } else {\n                // No path from 1 to n\n            }\n        }\n        if (!path.empty())\n            generatePathForbiddenTriplets(path, k, forbidden);\n\n        if ((int)forbidden.size() < k)\n            generateRandomForbiddenTriplets(n, k - forbidden.size(), forbidden);\n    } else {\n        fprintf(stderr, \"Unknown ftype: %s\\n\", ftype.c_str());\n        exit(1);\n    }\n\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    for (auto t : forbidden) {\n        int a, b, c;\n        tie(a,b,c) = t;\n        printf(\"%d %d %d\\n\", a, b, c);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random connected graph, no forbidden triplets\n./gen -n 10 -m 15 -k 0 -type random -connected true -ftype none\n\n# Small random disconnected graph, no forbidden triplets\n./gen -n 10 -m 5 -k 0 -type random -connected false -ftype none\n\n# Medium size connected random graph, random forbidden triplets\n./gen -n 100 -m 500 -k 50 -type random -connected true -ftype random\n\n# Large connected random graph, maximal forbidden triplets\n./gen -n 3000 -m 20000 -k 100000 -type random -connected true -ftype random\n\n# Chain graph, with forbidden triplets along path to block shortest path\n./gen -n 1000 -m 1500 -k 100 -type chain -ftype path\n\n# Star graph, with random forbidden triplets\n./gen -n 100 -m 200 -k 50 -type star -ftype random\n\n# Random connected graph, with no forbidden triplets\n./gen -n 3000 -m 20000 -k 0 -type random -connected true -ftype none\n\n# Random disconnected graph, with no forbidden triplets\n./gen -n 3000 -m 5000 -k 0 -type random -connected false -ftype none\n\n# Chain graph, with no forbidden triplets\n./gen -n 3000 -m 4000 -k 0 -type chain -ftype none\n\n# Star graph, with maximal forbidden triplets\n./gen -n 3000 -m 5000 -k 100000 -type star -ftype random\n\n# Random connected graph, with forbidden triplets that block path\n./gen -n 1000 -m 5000 -k 100 -type random -connected true -ftype path\n\n# Small graph where n = 2\n./gen -n 2 -m 1 -k 0 -type random -connected true -ftype none\n\n# Medium graph with k = 0\n./gen -n 1000 -m 10000 -k 0 -type random -connected true -ftype none\n\n# Graph with no edges\n./gen -n 100 -m 0 -k 0 -type random -connected false -ftype none\n\n# Graph with maximum edges\n./gen -n 3000 -m 20000 -k 0 -type random -connected true -ftype none\n\n# Graph with n = 3000, m = 20000, k = 100000, connected, random\n./gen -n 3000 -m 20000 -k 100000 -type random -connected true -ftype random\n\n# Chain graph, k = n - 2, forbidden triplets along path\n./gen -n 500 -m 600 -k 498 -type chain -ftype path\n\n# Star graph, k = n - 2, forbidden triplets along path\n./gen -n 500 -m 600 -k 498 -type star -ftype path\n\n# Graph where the shortest path is length 1\n./gen -n 2 -m 1 -k 0 -type random -connected true -ftype none\n\n# Disconnected graph where city n is unreachable from 1\n./gen -n 100 -m 50 -k 0 -type random -connected false -ftype none\n\n# Graph with city n unreachable due to forbidden triplets\n./gen -n 10 -m 15 -k 20 -type random -connected true -ftype random\n\n# Maximal everything\n./gen -n 3000 -m 20000 -k 100000 -type random -connected true -ftype random\n\n# Small chain graph with k = 0\n./gen -n 10 -m 10 -k 0 -type chain -ftype none\n\n# Empty forbidden triplets\n./gen -n 1000 -m 5000 -k 0 -type random -connected true -ftype none\n\n# Max forbidden triplets in chain graph\n./gen -n 3000 -m 4000 -k 100000 -type chain -ftype random\n\n# Graph with loops prevented (xi ≠ yi)\n./gen -n 100 -m 1000 -k 0 -type random -connected true -ftype none\n\n# Graph with repeated edges prevented\n./gen -n 1000 -m 2000 -k 0 -type random -connected true -ftype none\n\n# Graph with forbidden triplets covering all possible combinations\n./gen -n 50 -m 100 -k 10000 -type random -connected true -ftype random\n\n# Random connected graph, forbidden triplets that do not block path\n./gen -n 500 -m 1000 -k 100 -type random -connected true -ftype random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:23.852673",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "590/A",
      "title": "A. Median Smoothing",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first input line of the input contains a single integer n (3 ≤ n ≤ 500 000) — the length of the initial sequence.The next line contains n integers a1, a2, ..., an (ai = 0 or ai = 1), giving the initial sequence itself.",
      "output_spec": "OutputIf the sequence will never become stable, print a single number  - 1.Otherwise, first print a single integer — the minimum number of times one needs to apply the median smoothing algorithm to the initial sequence before it becomes is stable. In the second line print n numbers separated by a space  — the resulting sequence itself.",
      "sample_tests": "ExamplesInputCopy40 0 1 1OutputCopy00 0 1 1InputCopy50 1 0 1 0OutputCopy20 0 0 0 0",
      "description": "A. Median Smoothing\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first input line of the input contains a single integer n (3 ≤ n ≤ 500 000) — the length of the initial sequence.The next line contains n integers a1, a2, ..., an (ai = 0 or ai = 1), giving the initial sequence itself.\n\nOutputIf the sequence will never become stable, print a single number  - 1.Otherwise, first print a single integer — the minimum number of times one needs to apply the median smoothing algorithm to the initial sequence before it becomes is stable. In the second line print n numbers separated by a space  — the resulting sequence itself.\n\nInputCopy40 0 1 1OutputCopy00 0 1 1InputCopy50 1 0 1 0OutputCopy20 0 0 0 0\n\nInputCopy40 0 1 1\n\nOutputCopy00 0 1 1\n\nInputCopy50 1 0 1 0\n\nOutputCopy20 0 0 0 0\n\nNoteIn the second sample the stabilization occurs in two steps: , and the sequence 00000 is obviously stable.",
      "solutions": [
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces",
          "content": "Hello, dear participants of Codeforces community!Starting from Codeforces Round #327 I'll be the new coordinator and will manage preparation process for all regular Codeforces rounds and other contests held on this platform. I'll do my best to increase the quality of contests we offer you, though Zlobober already raised this bar high. Let's cheer him once again, for all the great job he had done!Tomorrow round will be held using the problems of Moscow team olympiad for high-school students. Do not be tricked by the word \"school\" — there will be a gold medalist of IOI 2015 participating and some candidates to this year Russian IOI team, meaning the level of the problems will be appropriate. I am sure everyone will find an interesting problem to enjoy.The problemset was prepared by the team of Moscow authors (list is incomplete): Zlobober, romanandreev, meshanya, wilwell, glebushka98, timgaripov, thefacetakt, haku, LHiC, Timus, Sender, sankear, iskhakovt, andrewgark, ipavlov, StopKran, AleX leaded by your humble servant GlebsHP and the chairman of the jury Helen Andreeva.Special thanks to Delinur for translation and stella_marine for correction.Five problems will be offered in both divisions and the scoring distribution will be announced later (good traditions should live).UPD. Round time. Please note that Russia is not changing the timezone this night, while about 100 countries do so. Be sure to check when round starts in your timezone!UPD2. Please note, that the distribution motivates you to read all the problems! Div1.: 750-1000-1250-1750-2500 Div2.: 500-1000-1750-2000-2250UPD3. The results and the editorial will be published later, after the closing ceremony of the official competition.UPD4. The system testing is over, results are now final. Feel free to upsolve and read other contestants code. Congratulations to Div. 1 top-5: Endagorion JoeyWheeler sdya RAD -XraY- UPD5. Problem analysis is now available.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21185",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1940
        },
        {
          "title": "Codeforces Round #327 problems analysis - Codeforces",
          "content": "I like the idea of Endagorion to supplement the problems analysis with small challenges, somehow related to the problem preparation, it's generalization, or more effective solution. Following this, some problems in this analysis are also complemented with this sort of tasks.Div. 2A (Wizards' Duel)Idea of the problem: Roman Gusarev, development: timgaripov.Let's start with determining the position of the first collision. Two impulses converge with a speed p + q, so the first collision will occur after seconds. The coordinate of this collision is given by the formula .Note, that the distance one impulse passes while returning to it's caster is equal to the distance it has passed from the caster to the first collision. That means impulses will reach their casters simultaneously, and the situation will be identic to the beginning of the duel. Hence, the second collision (third, fourth, etc) will occur at exactly the same place as the first one.Code example: 13836780.Div. 2B (Rebranding)Idea of the problem: glebushka98, development: thefacetakt.Trivial solution will just emulate the work of all designers, every time considering all characters of the string one by one and replacing all xi with yi and vice versa. This will work in O(n·m) and get TL.First one should note that same characters always end as a same characters, meaning the position of the letter doesn't affect the result in any way. One should only remember the mapping for all distinct characters. Let p(i, c) be the mapping of c after i designers already finished their job. Now: p(0, c) = c If p(i - 1, c) = xi, then p(i, c) = yi Same, if p(i - 1, c) = yi, then p(i, c) = xi This solution complexity is O(|Σ|·m + n) and is enough to pass all the tests.Challenge: improve the complexity to O(Σ + n + m).Code examples: 13837577 implements O(|Σ|·m + n) and 13839154 stands for O(|Σ| + n + m).Div. 2C\\Div. 1A (Median Smoothing)Problem idea and development: Sender.We will call the element of a sequence stable, if it doesn't change after applying the algorithm of median smoothing for any number of times. Both ends are stable by the definition of the median smoothing. Also, it is easy to notice, that two equal consecutive elements are both stable.Now we should take a look at how do stable elements affect their neighbors. Suppose ai - 1 = ai, meaning i - 1 and i are stable. Additionaly assume, that ai + 1 is not a stable element, hence ai + 1 ≠ ai and ai + 1 ≠ ai + 2. Keeping in mind that only 0 and 1 values are possible, we conclude that ai = ai + 2 and applying a median smoothing algorithm to this sequence will result in ai = ai + 1. That means, if there is a stable element in position i, both i + 1 and i - 1 are guaranteed to be stable after one application of median smoothing. Now we can conclude, that all sequences will turn to stable at some point.Note, that if there are two stable elements i and j with no other stable elements located between them, the sequence of elements between them is alternating, i.e. ak = (ai + k - i)mod2, where . One can check, that stable elements may occur only at the ends of the alternating sequence, meaning the sequence will remain alternating until it will be killed by effect spreading from ending stable elements.The solution is: calculate max(min(|i - sj|)), where sj are the initial stable elements. Time complexity is O(n).Challenge 1: hack the solution that just applies median smoothing until something changes.Challenge 2: think of how to speed up the algorithm from challenge 1 using bitmasks (still gets TL).Code examples: 13838940 and 13838480.Div. 2D\\Div. 1B (Chip 'n Dale Rescue Rangers)Problem idea and development: StopKran.If the velocity of the dirigible relative to the air is given by the vector (ax, ay), while the velocity of the wind is (bx, by), the resulting velocity of the dirigible relative to the plane is (ax + bx, ay + by).The main idea here is that the answer function is monotonous. If the dirigible is able to reach to target in seconds, then it can do so in seconds, for any x ≥ 0. That is an obvious consequence from the fact the maximum self speed of the dirigible is strictly greater then the speed of the wind at any moment of time.For any monotonous function we can use binary search. Now we only need to check, if for some given value it's possible for the dirigible to reach the target in seconds. Let's separate the movement of the air and the movement of the dirigible in the air. The movement cause by the air is: (xn, yn) = , if ; (xn, yn) = , for . The only thing we need to check now is that the distance between the point (xn, yn) and the target coordinates (x2, y2) can be covered moving with the speed vmax in seconds assuming there is no wind.Time complexity is , where C stands for the maximum coordinate, аnd ε — desired accuracy.Challenge 1: think of the solution in case it's not guaranteed that the dirigible is faster than the wind.Challenge 2: can you come up with O(1) solution?Code examples: 13838659 and 13842505.Div. 2E\\Div. 1C (Three States)Problem idea and development: haku.Affirmation. Suppose we are given an undirected unweighted connected graph and three distinct chosen vertices u, v, w of this graph. We state that at least one minimum connecting network for these three vertices has the following form: some vertex c is chosen and the resulting network is obtained as a union of shortest paths from c to each of the chosen vertices.Proof. One of the optimal subgraphs connecting these three vertices is always a tree. Really, we can take any connecting subgraph and while there are cycles remaining in it, take any cycle and throw away any edge of this cycle. Moreover, only vertices u, v and w are allowed to be leaves of this tree, as we can delete from the network any other leaves and the network will still be connected. If the tree has no more than three leaves, it has no more than one vertex with the degree greater than 2. This vertex is c from the statement above. Any path from c to the leaves may obviously be replaced with the shortest path. Special case is than there is no node with the degree greater than 2, meaning one of u, v or w lies on the shortest path connecting two other vertices.The solution is: find the shortest path from each of the chosen vertices to all other vertices, and then try every vertex of the graph as c. Time complexity is O(|V| + |E|).To apply this solution to the given problem we should first build a graph, where cells of the table stand for the vertices and two vertices are connected by an edge, if the corresponding cells were neighboring. Now we should merge all vertices of a single state in one in order to obtain a task described in the beginning. Time complexity is a linear function of the size of the table .Code examples: 13843265 — the solution described above that uses 0-1 bfs instead of merging, 13840329 — another approach that tries to different cases.Div. 1D (Top Secret Task)Problem idea and development: glebushka98.If , than the sum of k minimums is obviously an answer. Let i1 < i2 <  ...  < ik be the indices of the elements that will form the answer. Note, that the relative order of the chosen subset will remain the same, as there is no reason to swap two elements that will both be included in the answer. The minimum number of operations required to place this k elements at the beginning is equal to — .T ≤ S  ≤  . . Calculate the dynamic programming d[i][j][p] &mdash minimum possible sum, if we chose j elements among first i with the total indices sum no greater than p. In order to optimize the memory consumption we will keep in memory only two latest layers of the dp.Time complexity is O(n4), with O(n3) memory consumption.Code examples: 13845513 and 13845571.Div. 1E (Birthday)Problem idea: meshanya, development: romanandreev.The given problem actually consists of two separate problems: build the directed graph of substring relation and find the maximum independent set in it. Note, that if the string s2 is a substring of some string s1, while string s3 is a substring of the string s2, then s3 is a substring of s1. That means the graph of substring relation defines a partially ordered set.To build the graph one can use Aho-Corasick algorithm. Usage of this structure allow to build all essential arc of the graph in time O(L), where L stands for the total length of all strings in the input. We will call the arc essential, if there is no w, such that and . One of the ways to do so is: Build Aho-Corasick using all strings in the input; For every node of the Aho-Corasick structure find and remember the nearest terminal node in the suffix-link path; Once again traverse all strings through Aho-Corasick. Every time new symbol is added, add an arc from the node corresponding to the current string (in the graph we build, not Aho-Corasick) to the node of the graph corresponding to the nearest terminal in the suffix-link path; The previous step will build all essential arcs plus some other arcs, but they do not affect the next step in any way; Find the transitive closure of the graph. To solve the second part of the problem one should use the Dilworth theorem. The way to restore the answer subset comes from the constructive proof of the theorem.Time complexity is O(L + n3) to build the graph plus O(n3) to find the maximum antichain. The overall complexity is O(L + n3).Congratulation to ikatanic — — the only participant to solve this problem during the contest. View his code 13851141 for further clarifications.Challenge: solve the problem with the same asymptotic, if we are to find the subset with the maximum total length of all strings in it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21203",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9655
        }
      ],
      "code_examples": [
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 1",
          "code": "3 3\n1.2\n1.2\n333",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 2",
          "code": "3 3\n1.2\n1.2\n333",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 3",
          "code": "3 3\n1..\n..2\n3..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 4",
          "code": "3 3\n1..\n..2\n3..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 5",
          "code": "segs = re.findall('(.*?)(0{2,}|1{2,})', s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 6",
          "code": "segs = re.findall('(.*?)(0{2,}|1{2,})', s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 7",
          "code": "110010101110100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 8",
          "code": "[('', '11'), ('', '00'), ('1010', '111'), ('01', '00')]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 9",
          "code": "\"1 - NUMBER_1, NUMBER_1\"+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 10",
          "code": "\"NUMBER_1,NUMBER_1\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 11",
          "code": "\"NUMBER_1\" * (length_of_repetition / 2) + \"NUMBER_2\" * (length_of_repetition / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 12",
          "code": "UPD4: ............ Congratulations to Div. 1 top-5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 13",
          "code": "UPD4: ............ Congratulations to Div. 1 top-5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 14",
          "code": "sleep(10 * 60 * 60 * 1000); //10 hours\nupdate_ratings();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 15",
          "code": "sleep(10 * 60 * 60 * 1000); //10 hours\nupdate_ratings();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 500000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 500000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 500000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1);\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = i % 2;\n        }\n    } else if (type == \"all_zero\") {\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"all_one\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"max_steps\") {\n        /* Generate a sequence that requires more steps to stabilize */\n        /* One way is to create an alternating sequence */\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 0 : 1;\n        }\n    } else {\n        /* default to random */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n-1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1);\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = i % 2;\n        }\n    } else if (type == \"all_zero\") {\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"all_one\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"max_steps\") {\n        /* Generate a sequence that requires more steps to stabilize */\n        /* One way is to create an alternating sequence */\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 0 : 1;\n        }\n    } else {\n        /* default to random */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1);\n        }\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n-1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 3 -type all_zero\n./gen -n 3 -type all_one\n./gen -n 3 -type alternating\n./gen -n 3 -type random\n\n# Medium test cases\n./gen -n 10 -type all_zero\n./gen -n 10 -type all_one\n./gen -n 10 -type alternating\n./gen -n 10 -type random\n\n# Max steps test cases\n./gen -n 20 -type max_steps\n./gen -n 50 -type max_steps\n./gen -n 100 -type max_steps\n\n# Large test cases\n./gen -n 500000 -type all_zero\n./gen -n 500000 -type all_one\n./gen -n 500000 -type alternating\n./gen -n 500000 -type random\n./gen -n 500000 -type max_steps\n\n# Random large test cases\n./gen -n 499999 -type random\n./gen -n 300000 -type random\n./gen -n 200000 -type random\n./gen -n 100000 -type random\n\n# Max steps large test cases\n./gen -n 499999 -type max_steps\n./gen -n 300000 -type max_steps\n./gen -n 200000 -type max_steps\n./gen -n 100000 -type max_steps\n\n# Edge cases\n./gen -n 3 -type max_steps\n./gen -n 4 -type max_steps\n./gen -n 5 -type max_steps\n\n# Additional random test cases\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n\n# Small random test cases\n./gen -n 7 -type random\n./gen -n 8 -type random\n./gen -n 9 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:25.508590",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "590/B",
      "title": "B. Chip 'n Dale Rescue Rangers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains four integers x1, y1, x2, y2 (|x1|,  |y1|,  |x2|,  |y2| ≤ 10 000) — the coordinates of the rescuers' headquarters and the point, where signal of the distress came from, respectively. The second line contains two integers  and t (0 < v, t ≤ 1000), which are denoting the maximum speed of the chipmunk dirigible relative to the air and the moment of time when the wind changes according to the weather forecast, respectively. Next follow one per line two pairs of integer (vx, vy) and (wx, wy), describing the wind for the first t seconds and the wind that will blow at all the remaining time, respectively. It is guaranteed that  and .",
      "output_spec": "OutputPrint a single real value — the minimum time the rescuers need to get to point (x2, y2). You answer will be considered correct if its absolute or relative error does not exceed 10 - 6. Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .",
      "sample_tests": "ExamplesInputCopy0 0 5 53 2-1 -1-1 0OutputCopy3.729935587093555327InputCopy0 0 0 1000100 1000-50 050 0OutputCopy11.547005383792516398",
      "description": "B. Chip 'n Dale Rescue Rangers\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains four integers x1, y1, x2, y2 (|x1|,  |y1|,  |x2|,  |y2| ≤ 10 000) — the coordinates of the rescuers' headquarters and the point, where signal of the distress came from, respectively. The second line contains two integers  and t (0 < v, t ≤ 1000), which are denoting the maximum speed of the chipmunk dirigible relative to the air and the moment of time when the wind changes according to the weather forecast, respectively. Next follow one per line two pairs of integer (vx, vy) and (wx, wy), describing the wind for the first t seconds and the wind that will blow at all the remaining time, respectively. It is guaranteed that  and .\n\nOutputPrint a single real value — the minimum time the rescuers need to get to point (x2, y2). You answer will be considered correct if its absolute or relative error does not exceed 10 - 6. Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .\n\nInputCopy0 0 5 53 2-1 -1-1 0OutputCopy3.729935587093555327InputCopy0 0 0 1000100 1000-50 050 0OutputCopy11.547005383792516398\n\nInputCopy0 0 5 53 2-1 -1-1 0\n\nOutputCopy3.729935587093555327\n\nInputCopy0 0 0 1000100 1000-50 050 0\n\nOutputCopy11.547005383792516398",
      "solutions": [
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces",
          "content": "Hello, dear participants of Codeforces community!Starting from Codeforces Round #327 I'll be the new coordinator and will manage preparation process for all regular Codeforces rounds and other contests held on this platform. I'll do my best to increase the quality of contests we offer you, though Zlobober already raised this bar high. Let's cheer him once again, for all the great job he had done!Tomorrow round will be held using the problems of Moscow team olympiad for high-school students. Do not be tricked by the word \"school\" — there will be a gold medalist of IOI 2015 participating and some candidates to this year Russian IOI team, meaning the level of the problems will be appropriate. I am sure everyone will find an interesting problem to enjoy.The problemset was prepared by the team of Moscow authors (list is incomplete): Zlobober, romanandreev, meshanya, wilwell, glebushka98, timgaripov, thefacetakt, haku, LHiC, Timus, Sender, sankear, iskhakovt, andrewgark, ipavlov, StopKran, AleX leaded by your humble servant GlebsHP and the chairman of the jury Helen Andreeva.Special thanks to Delinur for translation and stella_marine for correction.Five problems will be offered in both divisions and the scoring distribution will be announced later (good traditions should live).UPD. Round time. Please note that Russia is not changing the timezone this night, while about 100 countries do so. Be sure to check when round starts in your timezone!UPD2. Please note, that the distribution motivates you to read all the problems! Div1.: 750-1000-1250-1750-2500 Div2.: 500-1000-1750-2000-2250UPD3. The results and the editorial will be published later, after the closing ceremony of the official competition.UPD4. The system testing is over, results are now final. Feel free to upsolve and read other contestants code. Congratulations to Div. 1 top-5: Endagorion JoeyWheeler sdya RAD -XraY- UPD5. Problem analysis is now available.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21185",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1940
        },
        {
          "title": "Codeforces Round #327 problems analysis - Codeforces",
          "content": "I like the idea of Endagorion to supplement the problems analysis with small challenges, somehow related to the problem preparation, it's generalization, or more effective solution. Following this, some problems in this analysis are also complemented with this sort of tasks.Div. 2A (Wizards' Duel)Idea of the problem: Roman Gusarev, development: timgaripov.Let's start with determining the position of the first collision. Two impulses converge with a speed p + q, so the first collision will occur after seconds. The coordinate of this collision is given by the formula .Note, that the distance one impulse passes while returning to it's caster is equal to the distance it has passed from the caster to the first collision. That means impulses will reach their casters simultaneously, and the situation will be identic to the beginning of the duel. Hence, the second collision (third, fourth, etc) will occur at exactly the same place as the first one.Code example: 13836780.Div. 2B (Rebranding)Idea of the problem: glebushka98, development: thefacetakt.Trivial solution will just emulate the work of all designers, every time considering all characters of the string one by one and replacing all xi with yi and vice versa. This will work in O(n·m) and get TL.First one should note that same characters always end as a same characters, meaning the position of the letter doesn't affect the result in any way. One should only remember the mapping for all distinct characters. Let p(i, c) be the mapping of c after i designers already finished their job. Now: p(0, c) = c If p(i - 1, c) = xi, then p(i, c) = yi Same, if p(i - 1, c) = yi, then p(i, c) = xi This solution complexity is O(|Σ|·m + n) and is enough to pass all the tests.Challenge: improve the complexity to O(Σ + n + m).Code examples: 13837577 implements O(|Σ|·m + n) and 13839154 stands for O(|Σ| + n + m).Div. 2C\\Div. 1A (Median Smoothing)Problem idea and development: Sender.We will call the element of a sequence stable, if it doesn't change after applying the algorithm of median smoothing for any number of times. Both ends are stable by the definition of the median smoothing. Also, it is easy to notice, that two equal consecutive elements are both stable.Now we should take a look at how do stable elements affect their neighbors. Suppose ai - 1 = ai, meaning i - 1 and i are stable. Additionaly assume, that ai + 1 is not a stable element, hence ai + 1 ≠ ai and ai + 1 ≠ ai + 2. Keeping in mind that only 0 and 1 values are possible, we conclude that ai = ai + 2 and applying a median smoothing algorithm to this sequence will result in ai = ai + 1. That means, if there is a stable element in position i, both i + 1 and i - 1 are guaranteed to be stable after one application of median smoothing. Now we can conclude, that all sequences will turn to stable at some point.Note, that if there are two stable elements i and j with no other stable elements located between them, the sequence of elements between them is alternating, i.e. ak = (ai + k - i)mod2, where . One can check, that stable elements may occur only at the ends of the alternating sequence, meaning the sequence will remain alternating until it will be killed by effect spreading from ending stable elements.The solution is: calculate max(min(|i - sj|)), where sj are the initial stable elements. Time complexity is O(n).Challenge 1: hack the solution that just applies median smoothing until something changes.Challenge 2: think of how to speed up the algorithm from challenge 1 using bitmasks (still gets TL).Code examples: 13838940 and 13838480.Div. 2D\\Div. 1B (Chip 'n Dale Rescue Rangers)Problem idea and development: StopKran.If the velocity of the dirigible relative to the air is given by the vector (ax, ay), while the velocity of the wind is (bx, by), the resulting velocity of the dirigible relative to the plane is (ax + bx, ay + by).The main idea here is that the answer function is monotonous. If the dirigible is able to reach to target in seconds, then it can do so in seconds, for any x ≥ 0. That is an obvious consequence from the fact the maximum self speed of the dirigible is strictly greater then the speed of the wind at any moment of time.For any monotonous function we can use binary search. Now we only need to check, if for some given value it's possible for the dirigible to reach the target in seconds. Let's separate the movement of the air and the movement of the dirigible in the air. The movement cause by the air is: (xn, yn) = , if ; (xn, yn) = , for . The only thing we need to check now is that the distance between the point (xn, yn) and the target coordinates (x2, y2) can be covered moving with the speed vmax in seconds assuming there is no wind.Time complexity is , where C stands for the maximum coordinate, аnd ε — desired accuracy.Challenge 1: think of the solution in case it's not guaranteed that the dirigible is faster than the wind.Challenge 2: can you come up with O(1) solution?Code examples: 13838659 and 13842505.Div. 2E\\Div. 1C (Three States)Problem idea and development: haku.Affirmation. Suppose we are given an undirected unweighted connected graph and three distinct chosen vertices u, v, w of this graph. We state that at least one minimum connecting network for these three vertices has the following form: some vertex c is chosen and the resulting network is obtained as a union of shortest paths from c to each of the chosen vertices.Proof. One of the optimal subgraphs connecting these three vertices is always a tree. Really, we can take any connecting subgraph and while there are cycles remaining in it, take any cycle and throw away any edge of this cycle. Moreover, only vertices u, v and w are allowed to be leaves of this tree, as we can delete from the network any other leaves and the network will still be connected. If the tree has no more than three leaves, it has no more than one vertex with the degree greater than 2. This vertex is c from the statement above. Any path from c to the leaves may obviously be replaced with the shortest path. Special case is than there is no node with the degree greater than 2, meaning one of u, v or w lies on the shortest path connecting two other vertices.The solution is: find the shortest path from each of the chosen vertices to all other vertices, and then try every vertex of the graph as c. Time complexity is O(|V| + |E|).To apply this solution to the given problem we should first build a graph, where cells of the table stand for the vertices and two vertices are connected by an edge, if the corresponding cells were neighboring. Now we should merge all vertices of a single state in one in order to obtain a task described in the beginning. Time complexity is a linear function of the size of the table .Code examples: 13843265 — the solution described above that uses 0-1 bfs instead of merging, 13840329 — another approach that tries to different cases.Div. 1D (Top Secret Task)Problem idea and development: glebushka98.If , than the sum of k minimums is obviously an answer. Let i1 < i2 <  ...  < ik be the indices of the elements that will form the answer. Note, that the relative order of the chosen subset will remain the same, as there is no reason to swap two elements that will both be included in the answer. The minimum number of operations required to place this k elements at the beginning is equal to — .T ≤ S  ≤  . . Calculate the dynamic programming d[i][j][p] &mdash minimum possible sum, if we chose j elements among first i with the total indices sum no greater than p. In order to optimize the memory consumption we will keep in memory only two latest layers of the dp.Time complexity is O(n4), with O(n3) memory consumption.Code examples: 13845513 and 13845571.Div. 1E (Birthday)Problem idea: meshanya, development: romanandreev.The given problem actually consists of two separate problems: build the directed graph of substring relation and find the maximum independent set in it. Note, that if the string s2 is a substring of some string s1, while string s3 is a substring of the string s2, then s3 is a substring of s1. That means the graph of substring relation defines a partially ordered set.To build the graph one can use Aho-Corasick algorithm. Usage of this structure allow to build all essential arc of the graph in time O(L), where L stands for the total length of all strings in the input. We will call the arc essential, if there is no w, such that and . One of the ways to do so is: Build Aho-Corasick using all strings in the input; For every node of the Aho-Corasick structure find and remember the nearest terminal node in the suffix-link path; Once again traverse all strings through Aho-Corasick. Every time new symbol is added, add an arc from the node corresponding to the current string (in the graph we build, not Aho-Corasick) to the node of the graph corresponding to the nearest terminal in the suffix-link path; The previous step will build all essential arcs plus some other arcs, but they do not affect the next step in any way; Find the transitive closure of the graph. To solve the second part of the problem one should use the Dilworth theorem. The way to restore the answer subset comes from the constructive proof of the theorem.Time complexity is O(L + n3) to build the graph plus O(n3) to find the maximum antichain. The overall complexity is O(L + n3).Congratulation to ikatanic — — the only participant to solve this problem during the contest. View his code 13851141 for further clarifications.Challenge: solve the problem with the same asymptotic, if we are to find the subset with the maximum total length of all strings in it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21203",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9655
        }
      ],
      "code_examples": [
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 1",
          "code": "3 3\n1.2\n1.2\n333",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 2",
          "code": "3 3\n1.2\n1.2\n333",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 3",
          "code": "3 3\n1..\n..2\n3..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 4",
          "code": "3 3\n1..\n..2\n3..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 5",
          "code": "segs = re.findall('(.*?)(0{2,}|1{2,})', s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 6",
          "code": "segs = re.findall('(.*?)(0{2,}|1{2,})', s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 7",
          "code": "110010101110100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 8",
          "code": "[('', '11'), ('', '00'), ('1010', '111'), ('01', '00')]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 9",
          "code": "\"1 - NUMBER_1, NUMBER_1\"+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 10",
          "code": "\"NUMBER_1,NUMBER_1\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 11",
          "code": "\"NUMBER_1\" * (length_of_repetition / 2) + \"NUMBER_2\" * (length_of_repetition / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 12",
          "code": "UPD4: ............ Congratulations to Div. 1 top-5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 13",
          "code": "UPD4: ............ Congratulations to Div. 1 top-5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 14",
          "code": "sleep(10 * 60 * 60 * 1000); //10 hours\nupdate_ratings();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 15",
          "code": "sleep(10 * 60 * 60 * 1000); //10 hours\nupdate_ratings();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x1 = inf.readInt(-10000, 10000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-10000, 10000, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(-10000, 10000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-10000, 10000, \"y2\");\n    inf.readEoln();\n\n    int v = inf.readInt(1, 1000, \"v\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000, \"t\");\n    inf.readEoln();\n\n    int vx = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int vy = inf.readInt(-1000000000, 1000000000);\n    inf.readEoln();\n\n    int wx = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int wy = inf.readInt(-1000000000, 1000000000);\n    inf.readEoln();\n\n    long long v_square = 1LL * v * v;\n\n    long long vw_square = 1LL * vx * vx + 1LL * vy * vy;\n    ensuref(vw_square <= v_square, \"Wind speed squared %lld exceeds maximum squared v^2=%lld\", vw_square, v_square);\n\n    long long ww_square = 1LL * wx * wx + 1LL * wy * wy;\n    ensuref(ww_square <= v_square, \"Wind speed squared %lld exceeds maximum squared v^2=%lld\", ww_square, v_square);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x1 = inf.readInt(-10000, 10000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-10000, 10000, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(-10000, 10000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-10000, 10000, \"y2\");\n    inf.readEoln();\n\n    int v = inf.readInt(1, 1000, \"v\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000, \"t\");\n    inf.readEoln();\n\n    int vx = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int vy = inf.readInt(-1000000000, 1000000000);\n    inf.readEoln();\n\n    int wx = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int wy = inf.readInt(-1000000000, 1000000000);\n    inf.readEoln();\n\n    long long v_square = 1LL * v * v;\n\n    long long vw_square = 1LL * vx * vx + 1LL * vy * vy;\n    ensuref(vw_square <= v_square, \"Wind speed squared %lld exceeds maximum squared v^2=%lld\", vw_square, v_square);\n\n    long long ww_square = 1LL * wx * wx + 1LL * wy * wy;\n    ensuref(ww_square <= v_square, \"Wind speed squared %lld exceeds maximum squared v^2=%lld\", ww_square, v_square);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x1 = inf.readInt(-10000, 10000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-10000, 10000, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(-10000, 10000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-10000, 10000, \"y2\");\n    inf.readEoln();\n\n    int v = inf.readInt(1, 1000, \"v\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000, \"t\");\n    inf.readEoln();\n\n    int vx = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int vy = inf.readInt(-1000000000, 1000000000);\n    inf.readEoln();\n\n    int wx = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int wy = inf.readInt(-1000000000, 1000000000);\n    inf.readEoln();\n\n    long long v_square = 1LL * v * v;\n\n    long long vw_square = 1LL * vx * vx + 1LL * vy * vy;\n    ensuref(vw_square <= v_square, \"Wind speed squared %lld exceeds maximum squared v^2=%lld\", vw_square, v_square);\n\n    long long ww_square = 1LL * wx * wx + 1LL * wy * wy;\n    ensuref(ww_square <= v_square, \"Wind speed squared %lld exceeds maximum squared v^2=%lld\", ww_square, v_square);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateWind(int v, int &vx, int &vy, double dir = -10.0) {\n    int v_wind_max = v - 1;\n    if (dir < -1) {\n        // Random direction\n        dir = rnd.next(0, 359) * M_PI / 180.0;\n    }\n    int speed = rnd.next(0, v_wind_max);\n    vx = int(speed * cos(dir));\n    vy = int(speed * sin(dir));\n    if (vx == 0 && vy ==0 && speed > 0) {\n        // Adjust to ensure non-zero wind vector\n        vx = 1;\n    }\n    while (vx * vx + vy * vy >= v * v) {\n        speed = rnd.next(0, v_wind_max);\n        vx = int(speed * cos(dir));\n        vy = int(speed * sin(dir));\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Parse parameters\n    string type = opt<string>(\"type\", \"random\");\n    int max_coord = opt<int>(\"max_coord\", 10000);\n    int max_v = opt<int>(\"max_v\", 1000);\n    int max_t = opt<int>(\"max_t\", 1000);\n\n    int x1, y1, x2, y2;\n    int v;\n    int t;\n    int vx1, vy1, wx1, wy1; // Wind vectors\n    \n    if (type == \"random\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = rnd.next(1, max_v);\n        t = rnd.next(1, max_t);\n        generateWind(v, vx1, vy1);\n        generateWind(v, wx1, wy1);\n    } else if (type == \"same_point\") {\n        x1 = x2 = rnd.next(-max_coord, max_coord);\n        y1 = y2 = rnd.next(-max_coord, max_coord);\n        v = max_v / 2;\n        t = rnd.next(1, max_t);\n        vx1 = vy1 = wx1 = wy1 = 0;\n    } else if (type == \"max_v\") {\n        v = max_v;\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        t = rnd.next(1, max_t);\n        generateWind(v, vx1, vy1);\n        wx1 = vx1; wy1 = vy1;\n    } else if (type == \"no_wind\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = rnd.next(1, max_v);\n        t = rnd.next(1, max_t);\n        vx1 = vy1 = wx1 = wy1 = 0;\n    } else if (type == \"wind_unfavorable\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = rnd.next(1, max_v);\n        t = rnd.next(1, max_t);\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        double dir = atan2(-dy, -dx);\n        generateWind(v, vx1, vy1, dir);\n        wx1 = vx1;\n        wy1 = vy1;\n    } else if (type == \"wind_favorable\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = rnd.next(1, max_v);\n        t = rnd.next(1, max_t);\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        double dir = atan2(dy, dx);\n        generateWind(v, vx1, vy1, dir);\n        wx1 = vx1;\n        wy1 = vy1;\n    } else if (type == \"wind_changes\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = rnd.next(1, max_v);\n        t = rnd.next(1, max_t);\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        double dir = atan2(dy, dx);\n        generateWind(v, vx1, vy1, dir);\n        dir += M_PI;\n        generateWind(v, wx1, wy1, dir);\n    } else if (type == \"min_t\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = rnd.next(1, max_v);\n        t = 1;\n        generateWind(v, vx1, vy1);\n        generateWind(v, wx1, wy1);\n    } else if (type == \"max_t\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = rnd.next(1, max_v);\n        t = max_t;\n        generateWind(v, vx1, vy1);\n        generateWind(v, wx1, wy1);\n    } else if (type == \"edge_case\") {\n        x1 = y1 = x2 = y2 = 0;\n        v = 1;\n        t = 1;\n        vx1 = vy1 = wx1 = wy1 = 0;\n    } else {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = rnd.next(1, max_v);\n        t = rnd.next(1, max_t);\n        generateWind(v, vx1, vy1);\n        generateWind(v, wx1, wy1);\n    }\n    printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n    printf(\"%d %d\\n\", v, t);\n    printf(\"%d %d\\n\", vx1, vy1);\n    printf(\"%d %d\\n\", wx1, wy1);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateWind(int v, int &vx, int &vy, double dir = -10.0) {\n    int v_wind_max = v - 1;\n    if (dir < -1) {\n        // Random direction\n        dir = rnd.next(0, 359) * M_PI / 180.0;\n    }\n    int speed = rnd.next(0, v_wind_max);\n    vx = int(speed * cos(dir));\n    vy = int(speed * sin(dir));\n    if (vx == 0 && vy ==0 && speed > 0) {\n        // Adjust to ensure non-zero wind vector\n        vx = 1;\n    }\n    while (vx * vx + vy * vy >= v * v) {\n        speed = rnd.next(0, v_wind_max);\n        vx = int(speed * cos(dir));\n        vy = int(speed * sin(dir));\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Parse parameters\n    string type = opt<string>(\"type\", \"random\");\n    int max_coord = opt<int>(\"max_coord\", 10000);\n    int max_v = opt<int>(\"max_v\", 1000);\n    int max_t = opt<int>(\"max_t\", 1000);\n\n    int x1, y1, x2, y2;\n    int v;\n    int t;\n    int vx1, vy1, wx1, wy1; // Wind vectors\n    \n    if (type == \"random\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = rnd.next(1, max_v);\n        t = rnd.next(1, max_t);\n        generateWind(v, vx1, vy1);\n        generateWind(v, wx1, wy1);\n    } else if (type == \"same_point\") {\n        x1 = x2 = rnd.next(-max_coord, max_coord);\n        y1 = y2 = rnd.next(-max_coord, max_coord);\n        v = max_v / 2;\n        t = rnd.next(1, max_t);\n        vx1 = vy1 = wx1 = wy1 = 0;\n    } else if (type == \"max_v\") {\n        v = max_v;\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        t = rnd.next(1, max_t);\n        generateWind(v, vx1, vy1);\n        wx1 = vx1; wy1 = vy1;\n    } else if (type == \"no_wind\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = rnd.next(1, max_v);\n        t = rnd.next(1, max_t);\n        vx1 = vy1 = wx1 = wy1 = 0;\n    } else if (type == \"wind_unfavorable\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = rnd.next(1, max_v);\n        t = rnd.next(1, max_t);\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        double dir = atan2(-dy, -dx);\n        generateWind(v, vx1, vy1, dir);\n        wx1 = vx1;\n        wy1 = vy1;\n    } else if (type == \"wind_favorable\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = rnd.next(1, max_v);\n        t = rnd.next(1, max_t);\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        double dir = atan2(dy, dx);\n        generateWind(v, vx1, vy1, dir);\n        wx1 = vx1;\n        wy1 = vy1;\n    } else if (type == \"wind_changes\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = rnd.next(1, max_v);\n        t = rnd.next(1, max_t);\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        double dir = atan2(dy, dx);\n        generateWind(v, vx1, vy1, dir);\n        dir += M_PI;\n        generateWind(v, wx1, wy1, dir);\n    } else if (type == \"min_t\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = rnd.next(1, max_v);\n        t = 1;\n        generateWind(v, vx1, vy1);\n        generateWind(v, wx1, wy1);\n    } else if (type == \"max_t\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = rnd.next(1, max_v);\n        t = max_t;\n        generateWind(v, vx1, vy1);\n        generateWind(v, wx1, wy1);\n    } else if (type == \"edge_case\") {\n        x1 = y1 = x2 = y2 = 0;\n        v = 1;\n        t = 1;\n        vx1 = vy1 = wx1 = wy1 = 0;\n    } else {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = rnd.next(1, max_v);\n        t = rnd.next(1, max_t);\n        generateWind(v, vx1, vy1);\n        generateWind(v, wx1, wy1);\n    }\n    printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n    printf(\"%d %d\\n\", v, t);\n    printf(\"%d %d\\n\", vx1, vy1);\n    printf(\"%d %d\\n\", wx1, wy1);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random -max_coord 10\n./gen -type random -max_coord 100\n./gen -type random -max_coord 10000\n\n./gen -type same_point\n./gen -type same_point -max_coord 10000\n\n./gen -type max_v\n./gen -type max_v -max_v 1000\n\n./gen -type no_wind\n./gen -type no_wind -max_v 500\n\n./gen -type wind_favorable\n./gen -type wind_unfavorable\n\n./gen -type wind_changes\n\n./gen -type min_t\n./gen -type max_t\n\n./gen -type edge_case\n\n./gen -type random -max_coord 1000\n./gen -type random -max_coord 5000\n./gen -type random -max_coord 8000\n\n./gen -type wind_favorable\n./gen -type wind_unfavorable\n./gen -type no_wind\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type random -max_v 5\n./gen -type random -max_v 10\n./gen -type random -max_v 1\n./gen -type random -max_v 2\n./gen -type random -max_v 3\n\n./gen -type random -max_v 999\n\n./gen -type random -max_t 1\n\n./gen -type max_v\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:27.481214",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "590/C",
      "title": "C. Three States",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line of the input contains the dimensions of the map n and m (1 ≤ n, m ≤ 1000) — the number of rows and columns respectively.Each of the next n lines contain m characters, describing the rows of the map. Digits from 1 to 3 represent the accessory to the corresponding state. The character '.' corresponds to the cell where it is allowed to build a road and the character '#' means no construction is allowed in this cell.",
      "output_spec": "OutputPrint a single integer — the minimum number of cells you need to build a road inside in order to connect all the cells of all states. If such a goal is unachievable, print -1.",
      "sample_tests": "ExamplesInputCopy4 511..2#..22#.323.#333OutputCopy2InputCopy1 51#2#3OutputCopy-1",
      "description": "C. Three States\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains the dimensions of the map n and m (1 ≤ n, m ≤ 1000) — the number of rows and columns respectively.Each of the next n lines contain m characters, describing the rows of the map. Digits from 1 to 3 represent the accessory to the corresponding state. The character '.' corresponds to the cell where it is allowed to build a road and the character '#' means no construction is allowed in this cell.\n\nOutputPrint a single integer — the minimum number of cells you need to build a road inside in order to connect all the cells of all states. If such a goal is unachievable, print -1.\n\nInputCopy4 511..2#..22#.323.#333OutputCopy2InputCopy1 51#2#3OutputCopy-1\n\nInputCopy4 511..2#..22#.323.#333\n\nOutputCopy2\n\nInputCopy1 51#2#3\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces",
          "content": "Hello, dear participants of Codeforces community!Starting from Codeforces Round #327 I'll be the new coordinator and will manage preparation process for all regular Codeforces rounds and other contests held on this platform. I'll do my best to increase the quality of contests we offer you, though Zlobober already raised this bar high. Let's cheer him once again, for all the great job he had done!Tomorrow round will be held using the problems of Moscow team olympiad for high-school students. Do not be tricked by the word \"school\" — there will be a gold medalist of IOI 2015 participating and some candidates to this year Russian IOI team, meaning the level of the problems will be appropriate. I am sure everyone will find an interesting problem to enjoy.The problemset was prepared by the team of Moscow authors (list is incomplete): Zlobober, romanandreev, meshanya, wilwell, glebushka98, timgaripov, thefacetakt, haku, LHiC, Timus, Sender, sankear, iskhakovt, andrewgark, ipavlov, StopKran, AleX leaded by your humble servant GlebsHP and the chairman of the jury Helen Andreeva.Special thanks to Delinur for translation and stella_marine for correction.Five problems will be offered in both divisions and the scoring distribution will be announced later (good traditions should live).UPD. Round time. Please note that Russia is not changing the timezone this night, while about 100 countries do so. Be sure to check when round starts in your timezone!UPD2. Please note, that the distribution motivates you to read all the problems! Div1.: 750-1000-1250-1750-2500 Div2.: 500-1000-1750-2000-2250UPD3. The results and the editorial will be published later, after the closing ceremony of the official competition.UPD4. The system testing is over, results are now final. Feel free to upsolve and read other contestants code. Congratulations to Div. 1 top-5: Endagorion JoeyWheeler sdya RAD -XraY- UPD5. Problem analysis is now available.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21185",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1940
        },
        {
          "title": "Codeforces Round #327 problems analysis - Codeforces",
          "content": "I like the idea of Endagorion to supplement the problems analysis with small challenges, somehow related to the problem preparation, it's generalization, or more effective solution. Following this, some problems in this analysis are also complemented with this sort of tasks.Div. 2A (Wizards' Duel)Idea of the problem: Roman Gusarev, development: timgaripov.Let's start with determining the position of the first collision. Two impulses converge with a speed p + q, so the first collision will occur after seconds. The coordinate of this collision is given by the formula .Note, that the distance one impulse passes while returning to it's caster is equal to the distance it has passed from the caster to the first collision. That means impulses will reach their casters simultaneously, and the situation will be identic to the beginning of the duel. Hence, the second collision (third, fourth, etc) will occur at exactly the same place as the first one.Code example: 13836780.Div. 2B (Rebranding)Idea of the problem: glebushka98, development: thefacetakt.Trivial solution will just emulate the work of all designers, every time considering all characters of the string one by one and replacing all xi with yi and vice versa. This will work in O(n·m) and get TL.First one should note that same characters always end as a same characters, meaning the position of the letter doesn't affect the result in any way. One should only remember the mapping for all distinct characters. Let p(i, c) be the mapping of c after i designers already finished their job. Now: p(0, c) = c If p(i - 1, c) = xi, then p(i, c) = yi Same, if p(i - 1, c) = yi, then p(i, c) = xi This solution complexity is O(|Σ|·m + n) and is enough to pass all the tests.Challenge: improve the complexity to O(Σ + n + m).Code examples: 13837577 implements O(|Σ|·m + n) and 13839154 stands for O(|Σ| + n + m).Div. 2C\\Div. 1A (Median Smoothing)Problem idea and development: Sender.We will call the element of a sequence stable, if it doesn't change after applying the algorithm of median smoothing for any number of times. Both ends are stable by the definition of the median smoothing. Also, it is easy to notice, that two equal consecutive elements are both stable.Now we should take a look at how do stable elements affect their neighbors. Suppose ai - 1 = ai, meaning i - 1 and i are stable. Additionaly assume, that ai + 1 is not a stable element, hence ai + 1 ≠ ai and ai + 1 ≠ ai + 2. Keeping in mind that only 0 and 1 values are possible, we conclude that ai = ai + 2 and applying a median smoothing algorithm to this sequence will result in ai = ai + 1. That means, if there is a stable element in position i, both i + 1 and i - 1 are guaranteed to be stable after one application of median smoothing. Now we can conclude, that all sequences will turn to stable at some point.Note, that if there are two stable elements i and j with no other stable elements located between them, the sequence of elements between them is alternating, i.e. ak = (ai + k - i)mod2, where . One can check, that stable elements may occur only at the ends of the alternating sequence, meaning the sequence will remain alternating until it will be killed by effect spreading from ending stable elements.The solution is: calculate max(min(|i - sj|)), where sj are the initial stable elements. Time complexity is O(n).Challenge 1: hack the solution that just applies median smoothing until something changes.Challenge 2: think of how to speed up the algorithm from challenge 1 using bitmasks (still gets TL).Code examples: 13838940 and 13838480.Div. 2D\\Div. 1B (Chip 'n Dale Rescue Rangers)Problem idea and development: StopKran.If the velocity of the dirigible relative to the air is given by the vector (ax, ay), while the velocity of the wind is (bx, by), the resulting velocity of the dirigible relative to the plane is (ax + bx, ay + by).The main idea here is that the answer function is monotonous. If the dirigible is able to reach to target in seconds, then it can do so in seconds, for any x ≥ 0. That is an obvious consequence from the fact the maximum self speed of the dirigible is strictly greater then the speed of the wind at any moment of time.For any monotonous function we can use binary search. Now we only need to check, if for some given value it's possible for the dirigible to reach the target in seconds. Let's separate the movement of the air and the movement of the dirigible in the air. The movement cause by the air is: (xn, yn) = , if ; (xn, yn) = , for . The only thing we need to check now is that the distance between the point (xn, yn) and the target coordinates (x2, y2) can be covered moving with the speed vmax in seconds assuming there is no wind.Time complexity is , where C stands for the maximum coordinate, аnd ε — desired accuracy.Challenge 1: think of the solution in case it's not guaranteed that the dirigible is faster than the wind.Challenge 2: can you come up with O(1) solution?Code examples: 13838659 and 13842505.Div. 2E\\Div. 1C (Three States)Problem idea and development: haku.Affirmation. Suppose we are given an undirected unweighted connected graph and three distinct chosen vertices u, v, w of this graph. We state that at least one minimum connecting network for these three vertices has the following form: some vertex c is chosen and the resulting network is obtained as a union of shortest paths from c to each of the chosen vertices.Proof. One of the optimal subgraphs connecting these three vertices is always a tree. Really, we can take any connecting subgraph and while there are cycles remaining in it, take any cycle and throw away any edge of this cycle. Moreover, only vertices u, v and w are allowed to be leaves of this tree, as we can delete from the network any other leaves and the network will still be connected. If the tree has no more than three leaves, it has no more than one vertex with the degree greater than 2. This vertex is c from the statement above. Any path from c to the leaves may obviously be replaced with the shortest path. Special case is than there is no node with the degree greater than 2, meaning one of u, v or w lies on the shortest path connecting two other vertices.The solution is: find the shortest path from each of the chosen vertices to all other vertices, and then try every vertex of the graph as c. Time complexity is O(|V| + |E|).To apply this solution to the given problem we should first build a graph, where cells of the table stand for the vertices and two vertices are connected by an edge, if the corresponding cells were neighboring. Now we should merge all vertices of a single state in one in order to obtain a task described in the beginning. Time complexity is a linear function of the size of the table .Code examples: 13843265 — the solution described above that uses 0-1 bfs instead of merging, 13840329 — another approach that tries to different cases.Div. 1D (Top Secret Task)Problem idea and development: glebushka98.If , than the sum of k minimums is obviously an answer. Let i1 < i2 <  ...  < ik be the indices of the elements that will form the answer. Note, that the relative order of the chosen subset will remain the same, as there is no reason to swap two elements that will both be included in the answer. The minimum number of operations required to place this k elements at the beginning is equal to — .T ≤ S  ≤  . . Calculate the dynamic programming d[i][j][p] &mdash minimum possible sum, if we chose j elements among first i with the total indices sum no greater than p. In order to optimize the memory consumption we will keep in memory only two latest layers of the dp.Time complexity is O(n4), with O(n3) memory consumption.Code examples: 13845513 and 13845571.Div. 1E (Birthday)Problem idea: meshanya, development: romanandreev.The given problem actually consists of two separate problems: build the directed graph of substring relation and find the maximum independent set in it. Note, that if the string s2 is a substring of some string s1, while string s3 is a substring of the string s2, then s3 is a substring of s1. That means the graph of substring relation defines a partially ordered set.To build the graph one can use Aho-Corasick algorithm. Usage of this structure allow to build all essential arc of the graph in time O(L), where L stands for the total length of all strings in the input. We will call the arc essential, if there is no w, such that and . One of the ways to do so is: Build Aho-Corasick using all strings in the input; For every node of the Aho-Corasick structure find and remember the nearest terminal node in the suffix-link path; Once again traverse all strings through Aho-Corasick. Every time new symbol is added, add an arc from the node corresponding to the current string (in the graph we build, not Aho-Corasick) to the node of the graph corresponding to the nearest terminal in the suffix-link path; The previous step will build all essential arcs plus some other arcs, but they do not affect the next step in any way; Find the transitive closure of the graph. To solve the second part of the problem one should use the Dilworth theorem. The way to restore the answer subset comes from the constructive proof of the theorem.Time complexity is O(L + n3) to build the graph plus O(n3) to find the maximum antichain. The overall complexity is O(L + n3).Congratulation to ikatanic — — the only participant to solve this problem during the contest. View his code 13851141 for further clarifications.Challenge: solve the problem with the same asymptotic, if we are to find the subset with the maximum total length of all strings in it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21203",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9655
        }
      ],
      "code_examples": [
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 1",
          "code": "3 3\n1.2\n1.2\n333",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 2",
          "code": "3 3\n1.2\n1.2\n333",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 3",
          "code": "3 3\n1..\n..2\n3..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 4",
          "code": "3 3\n1..\n..2\n3..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 5",
          "code": "segs = re.findall('(.*?)(0{2,}|1{2,})', s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 6",
          "code": "segs = re.findall('(.*?)(0{2,}|1{2,})', s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 7",
          "code": "110010101110100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 8",
          "code": "[('', '11'), ('', '00'), ('1010', '111'), ('01', '00')]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 9",
          "code": "\"1 - NUMBER_1, NUMBER_1\"+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 10",
          "code": "\"NUMBER_1,NUMBER_1\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 11",
          "code": "\"NUMBER_1\" * (length_of_repetition / 2) + \"NUMBER_2\" * (length_of_repetition / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 12",
          "code": "UPD4: ............ Congratulations to Div. 1 top-5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 13",
          "code": "UPD4: ............ Congratulations to Div. 1 top-5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 14",
          "code": "sleep(10 * 60 * 60 * 1000); //10 hours\nupdate_ratings();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 15",
          "code": "sleep(10 * 60 * 60 * 1000); //10 hours\nupdate_ratings();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine(\"[123.#]{\" + to_string(m) + \"}\", \"grid line\");\n        grid[i] = line;\n    }\n\n    for (char state = '1'; state <= '3'; ++state) {\n        vector<pair<int,int>> positions;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (grid[i][j] == state) {\n                    positions.push_back({i,j});\n                }\n            }\n        }\n        ensuref(!positions.empty(), \"There must be at least one cell for state %c\", state);\n        // Check connectedness\n        int total_cells = positions.size();\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        queue<pair<int,int>> q;\n        q.push(positions[0]);\n        visited[positions[0].first][positions[0].second] = true;\n        int visited_cells = 1;\n        while (!q.empty()) {\n            auto [x, y] = q.front(); q.pop();\n            const int dx[] = { -1, 0, 1, 0 };\n            const int dy[] = { 0, 1, 0, -1 };\n            for (int dir = 0; dir < 4; ++dir) {\n                int nx = x + dx[dir];\n                int ny = y + dy[dir];\n                if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n                    if (!visited[nx][ny] && grid[nx][ny] == state) {\n                        visited[nx][ny] = true;\n                        visited_cells++;\n                        q.push({ nx, ny });\n                    }\n                }\n            }\n        }\n        ensuref(visited_cells == total_cells, \"Cells of state %c are not connected\", state);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine(\"[123.#]{\" + to_string(m) + \"}\", \"grid line\");\n        grid[i] = line;\n    }\n\n    for (char state = '1'; state <= '3'; ++state) {\n        vector<pair<int,int>> positions;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (grid[i][j] == state) {\n                    positions.push_back({i,j});\n                }\n            }\n        }\n        ensuref(!positions.empty(), \"There must be at least one cell for state %c\", state);\n        // Check connectedness\n        int total_cells = positions.size();\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        queue<pair<int,int>> q;\n        q.push(positions[0]);\n        visited[positions[0].first][positions[0].second] = true;\n        int visited_cells = 1;\n        while (!q.empty()) {\n            auto [x, y] = q.front(); q.pop();\n            const int dx[] = { -1, 0, 1, 0 };\n            const int dy[] = { 0, 1, 0, -1 };\n            for (int dir = 0; dir < 4; ++dir) {\n                int nx = x + dx[dir];\n                int ny = y + dy[dir];\n                if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n                    if (!visited[nx][ny] && grid[nx][ny] == state) {\n                        visited[nx][ny] = true;\n                        visited_cells++;\n                        q.push({ nx, ny });\n                    }\n                }\n            }\n        }\n        ensuref(visited_cells == total_cells, \"Cells of state %c are not connected\", state);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine(\"[123.#]{\" + to_string(m) + \"}\", \"grid line\");\n        grid[i] = line;\n    }\n\n    for (char state = '1'; state <= '3'; ++state) {\n        vector<pair<int,int>> positions;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (grid[i][j] == state) {\n                    positions.push_back({i,j});\n                }\n            }\n        }\n        ensuref(!positions.empty(), \"There must be at least one cell for state %c\", state);\n        // Check connectedness\n        int total_cells = positions.size();\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        queue<pair<int,int>> q;\n        q.push(positions[0]);\n        visited[positions[0].first][positions[0].second] = true;\n        int visited_cells = 1;\n        while (!q.empty()) {\n            auto [x, y] = q.front(); q.pop();\n            const int dx[] = { -1, 0, 1, 0 };\n            const int dy[] = { 0, 1, 0, -1 };\n            for (int dir = 0; dir < 4; ++dir) {\n                int nx = x + dx[dir];\n                int ny = y + dy[dir];\n                if (0 <= nx && nx < n && 0 <= ny && ny < m) {\n                    if (!visited[nx][ny] && grid[nx][ny] == state) {\n                        visited[nx][ny] = true;\n                        visited_cells++;\n                        q.push({ nx, ny });\n                    }\n                }\n            }\n        }\n        ensuref(visited_cells == total_cells, \"Cells of state %c are not connected\", state);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_connected_component(int n, int m, char state_char, vector<string>& grid, vector<vector<bool>>& used, int size_limit, int start_x, int start_y) {\n    queue<pair<int, int>> q;\n\n    q.push({start_x, start_y});\n    used[start_x][start_y] = true;\n    grid[start_x][start_y] = state_char;\n\n    int size = 1;\n\n    while (!q.empty() && size < size_limit) {\n        pair<int, int> p = q.front();\n        q.pop();\n\n        int cx = p.first;\n        int cy = p.second;\n\n        vector<pair<int, int>> neighbors;\n\n        neighbors.push_back({cx - 1, cy});\n        neighbors.push_back({cx + 1, cy});\n        neighbors.push_back({cx, cy - 1});\n        neighbors.push_back({cx, cy + 1});\n\n        shuffle(neighbors.begin(), neighbors.end());\n\n        for (auto& nb : neighbors) {\n            int nx = nb.first;\n            int ny = nb.second;\n\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && !used[nx][ny]) {\n                // Assign this cell to the state\n                used[nx][ny] = true;\n                grid[nx][ny] = state_char;\n                q.push({nx, ny});\n                size++;\n\n                if (size >= size_limit) break;\n            }\n        }\n\n        if (size >= size_limit) break;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, ' '));\n    vector<vector<bool>> used(n, vector<bool>(m, false));\n\n    if (type == \"random\") {\n        // Generate connected components for each state\n        for (char state_char = '1'; state_char <= '3'; ++state_char) {\n            // Find an unassigned cell to start with\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, m - 1);\n            } while (used[x][y]);\n\n            int max_size = n * m / 5;\n            int min_size = n * m / 10;\n            int size_limit = rnd.next(min_size, max_size);\n\n            generate_connected_component(n, m, state_char, grid, used, size_limit, x, y);\n        }\n\n        // Fill remaining cells with '.' or '#' randomly\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (!used[i][j]) {\n                    if (rnd.next(100) < 80) { // 80% chance to be '.'\n                        grid[i][j] = '.';\n                    } else {\n                        grid[i][j] = '#';\n                    }\n                    used[i][j] = true;\n                }\n            }\n        }\n    } else if (type == \"isolated_states\") {\n        // Place states in different corners\n\n        // State '1' in top-left\n        int x1 = 0;\n        int y1 = 0;\n        generate_connected_component(n, m, '1', grid, used, n * m / 10, x1, y1);\n\n        // State '2' in top-right\n        int x2 = 0;\n        int y2 = m - 1;\n        generate_connected_component(n, m, '2', grid, used, n * m / 10, x2, y2);\n\n        // State '3' in bottom-left\n        int x3 = n - 1;\n        int y3 = 0;\n        generate_connected_component(n, m, '3', grid, used, n * m / 10, x3, y3);\n\n        // Fill the rest of the grid with '#' obstacles with some '.' cells\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (!used[i][j]) {\n                    if (rnd.next(100) < 10) { // 10% chance to be '.', rest are '#'\n                        grid[i][j] = '.';\n                    } else {\n                        grid[i][j] = '#';\n                    }\n                    used[i][j] = true;\n                }\n            }\n        }\n    } else if (type == \"connected_states\") {\n        // Place all states close to each other\n\n        // Pick a starting point\n        int x = n / 2;\n        int y = m / 2;\n\n        // Assign cells around (x,y) to states '1', '2', '3'\n\n        int radius = min(n, m) / 4;\n\n        for (char state_char = '1'; state_char <= '3'; ++state_char) {\n            int x_offset = rnd.next(-radius, radius);\n            int y_offset = rnd.next(-radius, radius);\n\n            int sx = x + x_offset;\n            int sy = y + y_offset;\n\n            if (sx < 0) sx = 0;\n            if (sx >= n) sx = n - 1;\n            if (sy < 0) sy = 0;\n            if (sy >= m) sy = m - 1;\n\n            generate_connected_component(n, m, state_char, grid, used, n * m / 10, sx, sy);\n        }\n\n        // Fill the rest of the grid with '.' or '#' randomly\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (!used[i][j]) {\n                    if (rnd.next(100) < 80) { // 80% chance to be '.'\n                        grid[i][j] = '.';\n                    } else {\n                        grid[i][j] = '#';\n                    }\n                    used[i][j] = true;\n                }\n            }\n        }\n    } else if (type == \"impossible\") {\n        // Place states completely surrounded by '#' obstacles\n\n        for (char state_char = '1'; state_char <= '3'; ++state_char) {\n            int x, y;\n            do {\n                x = rnd.next(1, n - 2);\n                y = rnd.next(1, m - 2);\n            } while (used[x][y] || used[x - 1][y] || used[x + 1][y] || used[x][y - 1] || used[x][y + 1]);\n\n            grid[x][y] = state_char;\n            used[x][y] = true;\n\n            // Surround with '#' obstacles\n            used[x - 1][y] = true; grid[x - 1][y] = '#';\n            used[x + 1][y] = true; grid[x + 1][y] = '#';\n            used[x][y - 1] = true; grid[x][y - 1] = '#';\n            used[x][y + 1] = true; grid[x][y + 1] = '#';\n        }\n\n        // Fill the rest of the grid with '#' or '.' with low probability\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (!used[i][j]) {\n                    if (rnd.next(100) < 5) { // 5% chance to be '.'\n                        grid[i][j] = '.';\n                    } else {\n                        grid[i][j] = '#';\n                    }\n                    used[i][j] = true;\n                }\n            }\n        }\n    } else {\n        // default to 'random'\n    }\n\n    // Output n m\n    printf(\"%d %d\\n\", n, m);\n    // Output grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_connected_component(int n, int m, char state_char, vector<string>& grid, vector<vector<bool>>& used, int size_limit, int start_x, int start_y) {\n    queue<pair<int, int>> q;\n\n    q.push({start_x, start_y});\n    used[start_x][start_y] = true;\n    grid[start_x][start_y] = state_char;\n\n    int size = 1;\n\n    while (!q.empty() && size < size_limit) {\n        pair<int, int> p = q.front();\n        q.pop();\n\n        int cx = p.first;\n        int cy = p.second;\n\n        vector<pair<int, int>> neighbors;\n\n        neighbors.push_back({cx - 1, cy});\n        neighbors.push_back({cx + 1, cy});\n        neighbors.push_back({cx, cy - 1});\n        neighbors.push_back({cx, cy + 1});\n\n        shuffle(neighbors.begin(), neighbors.end());\n\n        for (auto& nb : neighbors) {\n            int nx = nb.first;\n            int ny = nb.second;\n\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && !used[nx][ny]) {\n                // Assign this cell to the state\n                used[nx][ny] = true;\n                grid[nx][ny] = state_char;\n                q.push({nx, ny});\n                size++;\n\n                if (size >= size_limit) break;\n            }\n        }\n\n        if (size >= size_limit) break;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, ' '));\n    vector<vector<bool>> used(n, vector<bool>(m, false));\n\n    if (type == \"random\") {\n        // Generate connected components for each state\n        for (char state_char = '1'; state_char <= '3'; ++state_char) {\n            // Find an unassigned cell to start with\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, m - 1);\n            } while (used[x][y]);\n\n            int max_size = n * m / 5;\n            int min_size = n * m / 10;\n            int size_limit = rnd.next(min_size, max_size);\n\n            generate_connected_component(n, m, state_char, grid, used, size_limit, x, y);\n        }\n\n        // Fill remaining cells with '.' or '#' randomly\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (!used[i][j]) {\n                    if (rnd.next(100) < 80) { // 80% chance to be '.'\n                        grid[i][j] = '.';\n                    } else {\n                        grid[i][j] = '#';\n                    }\n                    used[i][j] = true;\n                }\n            }\n        }\n    } else if (type == \"isolated_states\") {\n        // Place states in different corners\n\n        // State '1' in top-left\n        int x1 = 0;\n        int y1 = 0;\n        generate_connected_component(n, m, '1', grid, used, n * m / 10, x1, y1);\n\n        // State '2' in top-right\n        int x2 = 0;\n        int y2 = m - 1;\n        generate_connected_component(n, m, '2', grid, used, n * m / 10, x2, y2);\n\n        // State '3' in bottom-left\n        int x3 = n - 1;\n        int y3 = 0;\n        generate_connected_component(n, m, '3', grid, used, n * m / 10, x3, y3);\n\n        // Fill the rest of the grid with '#' obstacles with some '.' cells\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (!used[i][j]) {\n                    if (rnd.next(100) < 10) { // 10% chance to be '.', rest are '#'\n                        grid[i][j] = '.';\n                    } else {\n                        grid[i][j] = '#';\n                    }\n                    used[i][j] = true;\n                }\n            }\n        }\n    } else if (type == \"connected_states\") {\n        // Place all states close to each other\n\n        // Pick a starting point\n        int x = n / 2;\n        int y = m / 2;\n\n        // Assign cells around (x,y) to states '1', '2', '3'\n\n        int radius = min(n, m) / 4;\n\n        for (char state_char = '1'; state_char <= '3'; ++state_char) {\n            int x_offset = rnd.next(-radius, radius);\n            int y_offset = rnd.next(-radius, radius);\n\n            int sx = x + x_offset;\n            int sy = y + y_offset;\n\n            if (sx < 0) sx = 0;\n            if (sx >= n) sx = n - 1;\n            if (sy < 0) sy = 0;\n            if (sy >= m) sy = m - 1;\n\n            generate_connected_component(n, m, state_char, grid, used, n * m / 10, sx, sy);\n        }\n\n        // Fill the rest of the grid with '.' or '#' randomly\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (!used[i][j]) {\n                    if (rnd.next(100) < 80) { // 80% chance to be '.'\n                        grid[i][j] = '.';\n                    } else {\n                        grid[i][j] = '#';\n                    }\n                    used[i][j] = true;\n                }\n            }\n        }\n    } else if (type == \"impossible\") {\n        // Place states completely surrounded by '#' obstacles\n\n        for (char state_char = '1'; state_char <= '3'; ++state_char) {\n            int x, y;\n            do {\n                x = rnd.next(1, n - 2);\n                y = rnd.next(1, m - 2);\n            } while (used[x][y] || used[x - 1][y] || used[x + 1][y] || used[x][y - 1] || used[x][y + 1]);\n\n            grid[x][y] = state_char;\n            used[x][y] = true;\n\n            // Surround with '#' obstacles\n            used[x - 1][y] = true; grid[x - 1][y] = '#';\n            used[x + 1][y] = true; grid[x + 1][y] = '#';\n            used[x][y - 1] = true; grid[x][y - 1] = '#';\n            used[x][y + 1] = true; grid[x][y + 1] = '#';\n        }\n\n        // Fill the rest of the grid with '#' or '.' with low probability\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (!used[i][j]) {\n                    if (rnd.next(100) < 5) { // 5% chance to be '.'\n                        grid[i][j] = '.';\n                    } else {\n                        grid[i][j] = '#';\n                    }\n                    used[i][j] = true;\n                }\n            }\n        }\n    } else {\n        // default to 'random'\n    }\n\n    // Output n m\n    printf(\"%d %d\\n\", n, m);\n    // Output grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type impossible\n./gen -n 3 -m 3 -type random\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type isolated_states\n./gen -n 10 -m 10 -type connected_states\n./gen -n 10 -m 10 -type impossible\n./gen -n 50 -m 50 -type random\n./gen -n 50 -m 50 -type isolated_states\n./gen -n 50 -m 50 -type connected_states\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type isolated_states\n./gen -n 100 -m 100 -type connected_states\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type isolated_states\n./gen -n 1000 -m 1000 -type connected_states\n./gen -n 1000 -m 1000 -type impossible\n./gen -n 500 -m 20 -type random\n./gen -n 20 -m 500 -type random\n./gen -n 1 -m 1000 -type random\n./gen -n 1000 -m 1 -type random\n./gen -n 1 -m 1000 -type isolated_states\n./gen -n 1000 -m 1 -type isolated_states\n./gen -n 1 -m 1000 -type impossible\n./gen -n 1000 -m 1 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:29.545957",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "590/D",
      "title": "Problem 590/D",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 150, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readSpace();\n    int s = inf.readInt(1, 1000000000, \"s\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 1000000, \"qi\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 150, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readSpace();\n    int s = inf.readInt(1, 1000000000, \"s\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 1000000, \"qi\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 150, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readSpace();\n    int s = inf.readInt(1, 1000000000, \"s\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 1000000, \"qi\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    long long s = opt<long long>(\"s\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> q(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            q[i] = rnd.next(1, 1000000);\n    } else if (type == \"min_at_end\") {\n        // Generate large qi for most soldiers\n        for(int i = 0; i < n - k; ++i)\n            q[i] = rnd.next(500000, 1000000);\n        // Generate small qi for last k soldiers\n        for(int i = n - k; i < n; ++i)\n            q[i] = rnd.next(1, 1000);\n    } else if (type == \"max_at_front\") {\n        for(int i = 0; i < n; ++i)\n            q[i] = rnd.next(1, 1000000);\n        // Sort in decreasing order\n        sort(q.begin(), q.end(), greater<int>());\n    } else if (type == \"ascending\") {\n        for(int i = 0; i < n; ++i)\n            q[i] = rnd.next(1, 1000000);\n        sort(q.begin(), q.end());\n    } else if (type == \"descending\") {\n        for(int i = 0; i < n; ++i)\n            q[i] = rnd.next(1, 1000000);\n        sort(q.begin(), q.end(), greater<int>());\n    } else if (type == \"alternating\") {\n        vector<int> small, large;\n        int half_n = n / 2;\n        for(int i = 0; i < half_n; ++i)\n            small.push_back(rnd.next(1, 1000));\n        for(int i = 0; i < n - half_n; ++i)\n            large.push_back(rnd.next(500000, 1000000));\n        shuffle(small.begin(), small.end());\n        shuffle(large.begin(), large.end());\n        int idx_small = 0, idx_large = 0;\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0 && idx_small < small.size()) {\n                q[i] = small[idx_small++];\n            } else if (idx_large < large.size()) {\n                q[i] = large[idx_large++];\n            } else if (idx_small < small.size()) {\n                q[i] = small[idx_small++];\n            }\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i)\n            q[i] = rnd.next(1, 1000000);\n    }\n\n    // Output n, k, s\n    printf(\"%d %d %lld\\n\", n, k, s);\n\n    // Output qi\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", q[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    long long s = opt<long long>(\"s\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> q(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            q[i] = rnd.next(1, 1000000);\n    } else if (type == \"min_at_end\") {\n        // Generate large qi for most soldiers\n        for(int i = 0; i < n - k; ++i)\n            q[i] = rnd.next(500000, 1000000);\n        // Generate small qi for last k soldiers\n        for(int i = n - k; i < n; ++i)\n            q[i] = rnd.next(1, 1000);\n    } else if (type == \"max_at_front\") {\n        for(int i = 0; i < n; ++i)\n            q[i] = rnd.next(1, 1000000);\n        // Sort in decreasing order\n        sort(q.begin(), q.end(), greater<int>());\n    } else if (type == \"ascending\") {\n        for(int i = 0; i < n; ++i)\n            q[i] = rnd.next(1, 1000000);\n        sort(q.begin(), q.end());\n    } else if (type == \"descending\") {\n        for(int i = 0; i < n; ++i)\n            q[i] = rnd.next(1, 1000000);\n        sort(q.begin(), q.end(), greater<int>());\n    } else if (type == \"alternating\") {\n        vector<int> small, large;\n        int half_n = n / 2;\n        for(int i = 0; i < half_n; ++i)\n            small.push_back(rnd.next(1, 1000));\n        for(int i = 0; i < n - half_n; ++i)\n            large.push_back(rnd.next(500000, 1000000));\n        shuffle(small.begin(), small.end());\n        shuffle(large.begin(), large.end());\n        int idx_small = 0, idx_large = 0;\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0 && idx_small < small.size()) {\n                q[i] = small[idx_small++];\n            } else if (idx_large < large.size()) {\n                q[i] = large[idx_large++];\n            } else if (idx_small < small.size()) {\n                q[i] = small[idx_small++];\n            }\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i)\n            q[i] = rnd.next(1, 1000000);\n    }\n\n    // Output n, k, s\n    printf(\"%d %d %lld\\n\", n, k, s);\n\n    // Output qi\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", q[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -k 3 -s 0 -type random\n./gen -n 5 -k 3 -s 10 -type random\n./gen -n 10 -k 5 -s 0 -type random\n./gen -n 10 -k 5 -s 100 -type random\n./gen -n 150 -k 75 -s 0 -type random\n./gen -n 150 -k 75 -s 1000000000 -type random\n./gen -n 150 -k 1 -s 0 -type random\n./gen -n 150 -k 1 -s 1000000000 -type random\n\n./gen -n 150 -k 75 -s 0 -type min_at_end\n./gen -n 150 -k 75 -s 1000000000 -type min_at_end\n./gen -n 150 -k 1 -s 0 -type min_at_end\n./gen -n 150 -k 1 -s 1000000000 -type min_at_end\n\n./gen -n 150 -k 75 -s 0 -type max_at_front\n./gen -n 150 -k 75 -s 1000000000 -type max_at_front\n\n./gen -n 150 -k 75 -s 0 -type ascending\n./gen -n 150 -k 75 -s 0 -type descending\n\n./gen -n 150 -k 1 -s 0 -type ascending\n\n./gen -n 150 -k 150 -s 0 -type random\n\n./gen -n 150 -k 150 -s 1000000000 -type random\n\n./gen -n 100 -k 50 -s 1000000000 -type alternating\n\n./gen -n 100 -k 50 -s 0 -type alternating\n\n./gen -n 149 -k 75 -s 1000000000 -type min_at_end\n\n./gen -n 149 -k 75 -s 0 -type min_at_end\n\n./gen -n 2 -k 1 -s 0 -type random\n\n./gen -n 2 -k 1 -s 1 -type min_at_end\n\n./gen -n 2 -k 2 -s 0 -type max_at_front\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:31.223408",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "590/E",
      "title": "E. Birthday",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (1 ≤ n ≤ 750) — the number of Dasha's relatives and friends.Each of the next n lines contains exactly one greeting. Each greeting consists of characters 'a' and 'b' only.The total length of all greetings won't exceed 10 000 000 characters.",
      "output_spec": "OutputIn the first line print the maximum size of the stylish set. In the second line print the numbers of ribbons involved in it, assuming that they are numbered from 1 to n in the order they appear in the input. If there are several stylish sets of the maximum size, print any of them.",
      "sample_tests": "ExamplesInputCopy5abababaaababababbbabOutputCopy22 5",
      "description": "E. Birthday\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains integer n (1 ≤ n ≤ 750) — the number of Dasha's relatives and friends.Each of the next n lines contains exactly one greeting. Each greeting consists of characters 'a' and 'b' only.The total length of all greetings won't exceed 10 000 000 characters.\n\nOutputIn the first line print the maximum size of the stylish set. In the second line print the numbers of ribbons involved in it, assuming that they are numbered from 1 to n in the order they appear in the input. If there are several stylish sets of the maximum size, print any of them.\n\nInputCopy5abababaaababababbbabOutputCopy22 5\n\nInputCopy5abababaaababababbbab\n\nOutputCopy22 5\n\nNoteIn the sample, the answer that keeps ribbons 3 and 4 is also considered correct.",
      "solutions": [
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces",
          "content": "Hello, dear participants of Codeforces community!Starting from Codeforces Round #327 I'll be the new coordinator and will manage preparation process for all regular Codeforces rounds and other contests held on this platform. I'll do my best to increase the quality of contests we offer you, though Zlobober already raised this bar high. Let's cheer him once again, for all the great job he had done!Tomorrow round will be held using the problems of Moscow team olympiad for high-school students. Do not be tricked by the word \"school\" — there will be a gold medalist of IOI 2015 participating and some candidates to this year Russian IOI team, meaning the level of the problems will be appropriate. I am sure everyone will find an interesting problem to enjoy.The problemset was prepared by the team of Moscow authors (list is incomplete): Zlobober, romanandreev, meshanya, wilwell, glebushka98, timgaripov, thefacetakt, haku, LHiC, Timus, Sender, sankear, iskhakovt, andrewgark, ipavlov, StopKran, AleX leaded by your humble servant GlebsHP and the chairman of the jury Helen Andreeva.Special thanks to Delinur for translation and stella_marine for correction.Five problems will be offered in both divisions and the scoring distribution will be announced later (good traditions should live).UPD. Round time. Please note that Russia is not changing the timezone this night, while about 100 countries do so. Be sure to check when round starts in your timezone!UPD2. Please note, that the distribution motivates you to read all the problems! Div1.: 750-1000-1250-1750-2500 Div2.: 500-1000-1750-2000-2250UPD3. The results and the editorial will be published later, after the closing ceremony of the official competition.UPD4. The system testing is over, results are now final. Feel free to upsolve and read other contestants code. Congratulations to Div. 1 top-5: Endagorion JoeyWheeler sdya RAD -XraY- UPD5. Problem analysis is now available.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21185",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1940
        },
        {
          "title": "Codeforces Round #327 problems analysis - Codeforces",
          "content": "I like the idea of Endagorion to supplement the problems analysis with small challenges, somehow related to the problem preparation, it's generalization, or more effective solution. Following this, some problems in this analysis are also complemented with this sort of tasks.Div. 2A (Wizards' Duel)Idea of the problem: Roman Gusarev, development: timgaripov.Let's start with determining the position of the first collision. Two impulses converge with a speed p + q, so the first collision will occur after seconds. The coordinate of this collision is given by the formula .Note, that the distance one impulse passes while returning to it's caster is equal to the distance it has passed from the caster to the first collision. That means impulses will reach their casters simultaneously, and the situation will be identic to the beginning of the duel. Hence, the second collision (third, fourth, etc) will occur at exactly the same place as the first one.Code example: 13836780.Div. 2B (Rebranding)Idea of the problem: glebushka98, development: thefacetakt.Trivial solution will just emulate the work of all designers, every time considering all characters of the string one by one and replacing all xi with yi and vice versa. This will work in O(n·m) and get TL.First one should note that same characters always end as a same characters, meaning the position of the letter doesn't affect the result in any way. One should only remember the mapping for all distinct characters. Let p(i, c) be the mapping of c after i designers already finished their job. Now: p(0, c) = c If p(i - 1, c) = xi, then p(i, c) = yi Same, if p(i - 1, c) = yi, then p(i, c) = xi This solution complexity is O(|Σ|·m + n) and is enough to pass all the tests.Challenge: improve the complexity to O(Σ + n + m).Code examples: 13837577 implements O(|Σ|·m + n) and 13839154 stands for O(|Σ| + n + m).Div. 2C\\Div. 1A (Median Smoothing)Problem idea and development: Sender.We will call the element of a sequence stable, if it doesn't change after applying the algorithm of median smoothing for any number of times. Both ends are stable by the definition of the median smoothing. Also, it is easy to notice, that two equal consecutive elements are both stable.Now we should take a look at how do stable elements affect their neighbors. Suppose ai - 1 = ai, meaning i - 1 and i are stable. Additionaly assume, that ai + 1 is not a stable element, hence ai + 1 ≠ ai and ai + 1 ≠ ai + 2. Keeping in mind that only 0 and 1 values are possible, we conclude that ai = ai + 2 and applying a median smoothing algorithm to this sequence will result in ai = ai + 1. That means, if there is a stable element in position i, both i + 1 and i - 1 are guaranteed to be stable after one application of median smoothing. Now we can conclude, that all sequences will turn to stable at some point.Note, that if there are two stable elements i and j with no other stable elements located between them, the sequence of elements between them is alternating, i.e. ak = (ai + k - i)mod2, where . One can check, that stable elements may occur only at the ends of the alternating sequence, meaning the sequence will remain alternating until it will be killed by effect spreading from ending stable elements.The solution is: calculate max(min(|i - sj|)), where sj are the initial stable elements. Time complexity is O(n).Challenge 1: hack the solution that just applies median smoothing until something changes.Challenge 2: think of how to speed up the algorithm from challenge 1 using bitmasks (still gets TL).Code examples: 13838940 and 13838480.Div. 2D\\Div. 1B (Chip 'n Dale Rescue Rangers)Problem idea and development: StopKran.If the velocity of the dirigible relative to the air is given by the vector (ax, ay), while the velocity of the wind is (bx, by), the resulting velocity of the dirigible relative to the plane is (ax + bx, ay + by).The main idea here is that the answer function is monotonous. If the dirigible is able to reach to target in seconds, then it can do so in seconds, for any x ≥ 0. That is an obvious consequence from the fact the maximum self speed of the dirigible is strictly greater then the speed of the wind at any moment of time.For any monotonous function we can use binary search. Now we only need to check, if for some given value it's possible for the dirigible to reach the target in seconds. Let's separate the movement of the air and the movement of the dirigible in the air. The movement cause by the air is: (xn, yn) = , if ; (xn, yn) = , for . The only thing we need to check now is that the distance between the point (xn, yn) and the target coordinates (x2, y2) can be covered moving with the speed vmax in seconds assuming there is no wind.Time complexity is , where C stands for the maximum coordinate, аnd ε — desired accuracy.Challenge 1: think of the solution in case it's not guaranteed that the dirigible is faster than the wind.Challenge 2: can you come up with O(1) solution?Code examples: 13838659 and 13842505.Div. 2E\\Div. 1C (Three States)Problem idea and development: haku.Affirmation. Suppose we are given an undirected unweighted connected graph and three distinct chosen vertices u, v, w of this graph. We state that at least one minimum connecting network for these three vertices has the following form: some vertex c is chosen and the resulting network is obtained as a union of shortest paths from c to each of the chosen vertices.Proof. One of the optimal subgraphs connecting these three vertices is always a tree. Really, we can take any connecting subgraph and while there are cycles remaining in it, take any cycle and throw away any edge of this cycle. Moreover, only vertices u, v and w are allowed to be leaves of this tree, as we can delete from the network any other leaves and the network will still be connected. If the tree has no more than three leaves, it has no more than one vertex with the degree greater than 2. This vertex is c from the statement above. Any path from c to the leaves may obviously be replaced with the shortest path. Special case is than there is no node with the degree greater than 2, meaning one of u, v or w lies on the shortest path connecting two other vertices.The solution is: find the shortest path from each of the chosen vertices to all other vertices, and then try every vertex of the graph as c. Time complexity is O(|V| + |E|).To apply this solution to the given problem we should first build a graph, where cells of the table stand for the vertices and two vertices are connected by an edge, if the corresponding cells were neighboring. Now we should merge all vertices of a single state in one in order to obtain a task described in the beginning. Time complexity is a linear function of the size of the table .Code examples: 13843265 — the solution described above that uses 0-1 bfs instead of merging, 13840329 — another approach that tries to different cases.Div. 1D (Top Secret Task)Problem idea and development: glebushka98.If , than the sum of k minimums is obviously an answer. Let i1 < i2 <  ...  < ik be the indices of the elements that will form the answer. Note, that the relative order of the chosen subset will remain the same, as there is no reason to swap two elements that will both be included in the answer. The minimum number of operations required to place this k elements at the beginning is equal to — .T ≤ S  ≤  . . Calculate the dynamic programming d[i][j][p] &mdash minimum possible sum, if we chose j elements among first i with the total indices sum no greater than p. In order to optimize the memory consumption we will keep in memory only two latest layers of the dp.Time complexity is O(n4), with O(n3) memory consumption.Code examples: 13845513 and 13845571.Div. 1E (Birthday)Problem idea: meshanya, development: romanandreev.The given problem actually consists of two separate problems: build the directed graph of substring relation and find the maximum independent set in it. Note, that if the string s2 is a substring of some string s1, while string s3 is a substring of the string s2, then s3 is a substring of s1. That means the graph of substring relation defines a partially ordered set.To build the graph one can use Aho-Corasick algorithm. Usage of this structure allow to build all essential arc of the graph in time O(L), where L stands for the total length of all strings in the input. We will call the arc essential, if there is no w, such that and . One of the ways to do so is: Build Aho-Corasick using all strings in the input; For every node of the Aho-Corasick structure find and remember the nearest terminal node in the suffix-link path; Once again traverse all strings through Aho-Corasick. Every time new symbol is added, add an arc from the node corresponding to the current string (in the graph we build, not Aho-Corasick) to the node of the graph corresponding to the nearest terminal in the suffix-link path; The previous step will build all essential arcs plus some other arcs, but they do not affect the next step in any way; Find the transitive closure of the graph. To solve the second part of the problem one should use the Dilworth theorem. The way to restore the answer subset comes from the constructive proof of the theorem.Time complexity is O(L + n3) to build the graph plus O(n3) to find the maximum antichain. The overall complexity is O(L + n3).Congratulation to ikatanic — — the only participant to solve this problem during the contest. View his code 13851141 for further clarifications.Challenge: solve the problem with the same asymptotic, if we are to find the subset with the maximum total length of all strings in it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21203",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9655
        }
      ],
      "code_examples": [
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 1",
          "code": "3 3\n1.2\n1.2\n333",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 2",
          "code": "3 3\n1.2\n1.2\n333",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 3",
          "code": "3 3\n1..\n..2\n3..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 4",
          "code": "3 3\n1..\n..2\n3..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 5",
          "code": "segs = re.findall('(.*?)(0{2,}|1{2,})', s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 6",
          "code": "segs = re.findall('(.*?)(0{2,}|1{2,})', s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 7",
          "code": "110010101110100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 8",
          "code": "[('', '11'), ('', '00'), ('1010', '111'), ('01', '00')]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 9",
          "code": "\"1 - NUMBER_1, NUMBER_1\"+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 10",
          "code": "\"NUMBER_1,NUMBER_1\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 11",
          "code": "\"NUMBER_1\" * (length_of_repetition / 2) + \"NUMBER_2\" * (length_of_repetition / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 12",
          "code": "UPD4: ............ Congratulations to Div. 1 top-5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 13",
          "code": "UPD4: ............ Congratulations to Div. 1 top-5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 14",
          "code": "sleep(10 * 60 * 60 * 1000); //10 hours\nupdate_ratings();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 15",
          "code": "sleep(10 * 60 * 60 * 1000); //10 hours\nupdate_ratings();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 750, \"n\");\n    inf.readEoln();\n    long long total_length = 0;\n    set<string> greetings_set;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[ab]*\", \"greeting\");\n        total_length += (long long)s.length();\n        ensuref(total_length <= 10000000, \"Total length of greetings exceeds 1e7\");\n        ensuref(greetings_set.count(s) == 0, \"All greetings must be different, duplicate greeting at line %d\", i + 2);\n        greetings_set.insert(s);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 750, \"n\");\n    inf.readEoln();\n    long long total_length = 0;\n    set<string> greetings_set;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[ab]*\", \"greeting\");\n        total_length += (long long)s.length();\n        ensuref(total_length <= 10000000, \"Total length of greetings exceeds 1e7\");\n        ensuref(greetings_set.count(s) == 0, \"All greetings must be different, duplicate greeting at line %d\", i + 2);\n        greetings_set.insert(s);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 750, \"n\");\n    inf.readEoln();\n    long long total_length = 0;\n    set<string> greetings_set;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[ab]*\", \"greeting\");\n        total_length += (long long)s.length();\n        ensuref(total_length <= 10000000, \"Total length of greetings exceeds 1e7\");\n        ensuref(greetings_set.count(s) == 0, \"All greetings must be different, duplicate greeting at line %d\", i + 2);\n        greetings_set.insert(s);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint readAnswer(InStream& stream, int n, const vector<string>& greetings, vector<int>& indices_out, TResult onErrorVerdict) {\n    int k = stream.readInt(0, n, \"k\");\n    vector<int> indices(k);\n    set<int> indices_set;\n    for (int i = 0; i < k; ++i) {\n        int idx = stream.readInt(1, n, format(\"indices[%d]\", i+1).c_str());\n        if (indices_set.count(idx)) {\n            stream.quitf(onErrorVerdict, \"Index %d is used more than once\", idx);\n        }\n        indices_set.insert(idx);\n        indices[i] = idx;\n    }\n    // Now check that the selected set is stylish\n    vector<string> selected_greetings(k);\n    for (int i = 0; i < k; ++i) {\n        int idx = indices[i] - 1; // 1-based to 0-based\n        selected_greetings[i] = greetings[idx];\n    }\n    // Check that no greeting is substring of another\n    for (int i = 0; i < k; ++i) {\n        for (int j = 0; j < k; ++j) {\n            if (i == j) continue;\n            if (selected_greetings[j].find(selected_greetings[i]) != std::string::npos) {\n                stream.quitf(onErrorVerdict, \"Greeting %d is substring of greeting %d\", indices[i], indices[j]);\n            }\n        }\n    }\n    indices_out = indices;\n    return k;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read n from inf\n    int n = inf.readInt(1, 750, \"n\");\n    vector<string> greetings(n);\n    for (int i = 0; i < n; ++i) {\n        greetings[i] = inf.readToken();\n    }\n    // Now read jury's answer from ans\n    vector<int> jury_indices, participant_indices;\n    int k_jury = readAnswer(ans, n, greetings, jury_indices, _fail);\n\n    // Now read participant's answer from ouf\n    int k_participant = readAnswer(ouf, n, greetings, participant_indices, _wa);\n\n    // Check that participant's k is not less than jury's k\n    if (k_participant < k_jury) {\n        quitf(_wa, \"Participant's answer is worse than jury's: k_participant = %d, k_jury = %d\", k_participant, k_jury);\n    }\n    else if (k_participant > k_jury) {\n        quitf(_fail, \"Participant's answer is better than jury's: k_participant = %d, k_jury = %d\", k_participant, k_jury);\n    }\n    else {\n        // Participant's answer is correct\n        quitf(_ok, \"Participant's answer is correct with k = %d\", k_participant);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxLen = opt<int>(\"maxLen\", 10000); // default max length of greetings\n    int minLen = opt<int>(\"minLen\", 1); // default minimum length of greetings\n\n    vector<string> greetings(n);\n    int totalLength = 0;\n    const int totalLengthLimit = 10000000;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int remainingLength = totalLengthLimit - totalLength;\n            int remainingGreetings = n - i;\n            int maxPossibleLen = remainingLength - (remainingGreetings - 1);\n            if (maxPossibleLen < minLen) {\n                n = i;\n                break;\n            }\n            int len = rnd.next(minLen, min(maxLen, maxPossibleLen));\n            totalLength += len;\n            string s;\n            for (int j = 0; j < len; ++j) {\n                s += (rnd.next(0, 1) == 0 ? 'a' : 'b');\n            }\n            greetings[i] = s;\n        }\n    } else if (type == \"all_substrings\") {\n        int baseLen = min(maxLen, totalLengthLimit / n);\n        if (baseLen == 0) baseLen = 1;\n        // Generate base string\n        string baseStr;\n        for (int i = 0; i < baseLen; ++i) {\n            baseStr += (rnd.next(0, 1) == 0 ? 'a' : 'b');\n        }\n        for (int i = 0; i < n; ++i) {\n            int len = baseLen - i;\n            if (len < minLen) {\n                n = i;\n                break;\n            }\n            greetings[i] = baseStr.substr(0, len);\n            totalLength += len;\n            if (totalLength > totalLengthLimit) {\n                n = i;\n                break;\n            }\n        }\n    } else if (type == \"prefixes\") {\n        int baseLen = min(maxLen, totalLengthLimit / n);\n        if (baseLen == 0) baseLen = 1;\n        // Generate base string\n        string baseStr;\n        for (int i = 0; i < baseLen; ++i) {\n            baseStr += (rnd.next(0, 1) == 0 ? 'a' : 'b');\n        }\n        for (int i = 0; i < n; ++i) {\n            int len = minLen + i;\n            if (len > baseLen) {\n                n = i;\n                break;\n            }\n            greetings[i] = baseStr.substr(0, len);\n            totalLength += len;\n            if (totalLength > totalLengthLimit) {\n                n = i;\n                break;\n            }\n        }\n    } else if (type == \"suffixes\") {\n        int baseLen = min(maxLen, totalLengthLimit / n);\n        if (baseLen == 0) baseLen = 1;\n        // Generate base string\n        string baseStr;\n        for (int i = 0; i < baseLen; ++i) {\n            baseStr += (rnd.next(0, 1) == 0 ? 'a' : 'b');\n        }\n        for (int i = 0; i < n; ++i) {\n            int len = minLen + i;\n            if (len > baseLen) {\n                n = i;\n                break;\n            }\n            greetings[i] = baseStr.substr(baseLen - len, len);\n            totalLength += len;\n            if (totalLength > totalLengthLimit) {\n                n = i;\n                break;\n            }\n        }\n    } else if (type == \"no_substrings\") {\n        int len = max(minLen, min(maxLen, totalLengthLimit / n));\n        int prefixLen = max(1, (int)ceil(log2(n)));\n        if (len < prefixLen) {\n            len = prefixLen;\n        }\n        totalLength = 0;\n        for (int i = 0; i < n; ++i) {\n            string s;\n            // Encode i in binary using 'a' and 'b' in the first prefixLen positions\n            for (int j = 0; j < prefixLen; ++j) {\n                if ((i >> j) & 1) {\n                    s += 'b';\n                } else {\n                    s += 'a';\n                }\n            }\n            // Fill the rest of the string with random 'a's and 'b's\n            for (int j = prefixLen; j < len; ++j) {\n                s += (rnd.next(0, 1) == 0 ? 'a' : 'b');\n            }\n            greetings[i] = s;\n            totalLength += len;\n            if (totalLength > totalLengthLimit) {\n                n = i;\n                break;\n            }\n        }\n    } else if (type == \"same\") {\n        int len = min(maxLen, totalLengthLimit / n);\n        if (len < minLen) len = minLen;\n        // Generate a base string\n        string baseStr;\n        for (int i = 0; i < len; ++i) {\n            baseStr += (rnd.next(0, 1) == 0 ? 'a' : 'b');\n        }\n        for (int i = 0; i < n; ++i) {\n            // Copy baseStr and change one character\n            string s = baseStr;\n            int pos = rnd.next(0, len - 1);\n            s[pos] = (s[pos] == 'a') ? 'b' : 'a';\n            greetings[i] = s;\n            totalLength += len;\n            if (totalLength > totalLengthLimit) {\n                n = i;\n                break;\n            }\n        }\n    } else {\n        // Default: random\n        for (int i = 0; i < n; ++i) {\n            int remainingLength = totalLengthLimit - totalLength;\n            int remainingGreetings = n - i;\n            int maxPossibleLen = remainingLength - (remainingGreetings - 1);\n            if (maxPossibleLen < minLen) {\n                n = i;\n                break;\n            }\n            int len = rnd.next(minLen, min(maxLen, maxPossibleLen));\n            totalLength += len;\n            string s;\n            for (int j = 0; j < len; ++j) {\n                s += (rnd.next(0, 1) == 0 ? 'a' : 'b');\n            }\n            greetings[i] = s;\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", greetings[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxLen = opt<int>(\"maxLen\", 10000); // default max length of greetings\n    int minLen = opt<int>(\"minLen\", 1); // default minimum length of greetings\n\n    vector<string> greetings(n);\n    int totalLength = 0;\n    const int totalLengthLimit = 10000000;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int remainingLength = totalLengthLimit - totalLength;\n            int remainingGreetings = n - i;\n            int maxPossibleLen = remainingLength - (remainingGreetings - 1);\n            if (maxPossibleLen < minLen) {\n                n = i;\n                break;\n            }\n            int len = rnd.next(minLen, min(maxLen, maxPossibleLen));\n            totalLength += len;\n            string s;\n            for (int j = 0; j < len; ++j) {\n                s += (rnd.next(0, 1) == 0 ? 'a' : 'b');\n            }\n            greetings[i] = s;\n        }\n    } else if (type == \"all_substrings\") {\n        int baseLen = min(maxLen, totalLengthLimit / n);\n        if (baseLen == 0) baseLen = 1;\n        // Generate base string\n        string baseStr;\n        for (int i = 0; i < baseLen; ++i) {\n            baseStr += (rnd.next(0, 1) == 0 ? 'a' : 'b');\n        }\n        for (int i = 0; i < n; ++i) {\n            int len = baseLen - i;\n            if (len < minLen) {\n                n = i;\n                break;\n            }\n            greetings[i] = baseStr.substr(0, len);\n            totalLength += len;\n            if (totalLength > totalLengthLimit) {\n                n = i;\n                break;\n            }\n        }\n    } else if (type == \"prefixes\") {\n        int baseLen = min(maxLen, totalLengthLimit / n);\n        if (baseLen == 0) baseLen = 1;\n        // Generate base string\n        string baseStr;\n        for (int i = 0; i < baseLen; ++i) {\n            baseStr += (rnd.next(0, 1) == 0 ? 'a' : 'b');\n        }\n        for (int i = 0; i < n; ++i) {\n            int len = minLen + i;\n            if (len > baseLen) {\n                n = i;\n                break;\n            }\n            greetings[i] = baseStr.substr(0, len);\n            totalLength += len;\n            if (totalLength > totalLengthLimit) {\n                n = i;\n                break;\n            }\n        }\n    } else if (type == \"suffixes\") {\n        int baseLen = min(maxLen, totalLengthLimit / n);\n        if (baseLen == 0) baseLen = 1;\n        // Generate base string\n        string baseStr;\n        for (int i = 0; i < baseLen; ++i) {\n            baseStr += (rnd.next(0, 1) == 0 ? 'a' : 'b');\n        }\n        for (int i = 0; i < n; ++i) {\n            int len = minLen + i;\n            if (len > baseLen) {\n                n = i;\n                break;\n            }\n            greetings[i] = baseStr.substr(baseLen - len, len);\n            totalLength += len;\n            if (totalLength > totalLengthLimit) {\n                n = i;\n                break;\n            }\n        }\n    } else if (type == \"no_substrings\") {\n        int len = max(minLen, min(maxLen, totalLengthLimit / n));\n        int prefixLen = max(1, (int)ceil(log2(n)));\n        if (len < prefixLen) {\n            len = prefixLen;\n        }\n        totalLength = 0;\n        for (int i = 0; i < n; ++i) {\n            string s;\n            // Encode i in binary using 'a' and 'b' in the first prefixLen positions\n            for (int j = 0; j < prefixLen; ++j) {\n                if ((i >> j) & 1) {\n                    s += 'b';\n                } else {\n                    s += 'a';\n                }\n            }\n            // Fill the rest of the string with random 'a's and 'b's\n            for (int j = prefixLen; j < len; ++j) {\n                s += (rnd.next(0, 1) == 0 ? 'a' : 'b');\n            }\n            greetings[i] = s;\n            totalLength += len;\n            if (totalLength > totalLengthLimit) {\n                n = i;\n                break;\n            }\n        }\n    } else if (type == \"same\") {\n        int len = min(maxLen, totalLengthLimit / n);\n        if (len < minLen) len = minLen;\n        // Generate a base string\n        string baseStr;\n        for (int i = 0; i < len; ++i) {\n            baseStr += (rnd.next(0, 1) == 0 ? 'a' : 'b');\n        }\n        for (int i = 0; i < n; ++i) {\n            // Copy baseStr and change one character\n            string s = baseStr;\n            int pos = rnd.next(0, len - 1);\n            s[pos] = (s[pos] == 'a') ? 'b' : 'a';\n            greetings[i] = s;\n            totalLength += len;\n            if (totalLength > totalLengthLimit) {\n                n = i;\n                break;\n            }\n        }\n    } else {\n        // Default: random\n        for (int i = 0; i < n; ++i) {\n            int remainingLength = totalLengthLimit - totalLength;\n            int remainingGreetings = n - i;\n            int maxPossibleLen = remainingLength - (remainingGreetings - 1);\n            if (maxPossibleLen < minLen) {\n                n = i;\n                break;\n            }\n            int len = rnd.next(minLen, min(maxLen, maxPossibleLen));\n            totalLength += len;\n            string s;\n            for (int j = 0; j < len; ++j) {\n                s += (rnd.next(0, 1) == 0 ? 'a' : 'b');\n            }\n            greetings[i] = s;\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", greetings[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type all_substrings\n./gen -n 1 -type no_substrings\n\n./gen -n 2 -type random\n./gen -n 2 -type all_substrings\n./gen -n 2 -type prefixes\n./gen -n 2 -type suffixes\n./gen -n 2 -type no_substrings\n./gen -n 2 -type same\n\n./gen -n 10 -type random\n./gen -n 10 -type all_substrings\n./gen -n 10 -type prefixes\n./gen -n 10 -type suffixes\n./gen -n 10 -type no_substrings\n./gen -n 10 -type same\n\n./gen -n 100 -type random\n./gen -n 100 -type all_substrings\n./gen -n 100 -type prefixes\n./gen -n 100 -type suffixes\n./gen -n 100 -type no_substrings\n./gen -n 100 -type same\n\n./gen -n 500 -type random\n./gen -n 500 -type all_substrings\n./gen -n 500 -type prefixes\n./gen -n 500 -type suffixes\n./gen -n 500 -type no_substrings\n./gen -n 500 -type same\n\n./gen -n 750 -type random\n./gen -n 750 -type all_substrings\n./gen -n 750 -type prefixes\n./gen -n 750 -type suffixes\n./gen -n 750 -type no_substrings\n./gen -n 750 -type same\n\n# Test with maxLen parameter\n\n./gen -n 750 -type random -maxLen 1\n./gen -n 750 -type random -maxLen 10000000\n./gen -n 750 -type all_substrings -maxLen 10000000\n./gen -n 750 -type prefixes -maxLen 10000000\n./gen -n 750 -type suffixes -maxLen 10000000\n./gen -n 750 -type no_substrings -maxLen 10000000\n\n# Test with minLen parameter for 'no_substrings' type\n./gen -n 750 -type no_substrings -minLen 100\n\n# Other special cases\n\n./gen -n 2 -type all_substrings -maxLen 10000000\n./gen -n 3 -type prefixes\n./gen -n 3 -type suffixes\n./gen -n 2 -type same\n\n# Edge cases\n\n./gen -n 750 -type random -maxLen 1 -minLen 1\n./gen -n 750 -type random -maxLen 2 -minLen 1\n./gen -n 750 -type random -maxLen 2 -minLen 2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:32.900075",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "591/A",
      "title": "A. Wizards' Duel",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains a single integer l (1 ≤ l ≤ 1 000) — the length of the corridor where the fight takes place.The second line contains integer p, the third line contains integer q (1 ≤ p, q ≤ 500) — the speeds of magical impulses for Harry Potter and He-Who-Must-Not-Be-Named, respectively.",
      "output_spec": "OutputPrint a single real number — the distance from the end of the corridor, where Harry is located, to the place of the second meeting of the spell impulses. Your answer will be considered correct if its absolute or relative error will not exceed 10 - 4. Namely: let's assume that your answer equals a, and the answer of the jury is b. The checker program will consider your answer correct if .",
      "sample_tests": "ExamplesInputCopy1005050OutputCopy50InputCopy1996040OutputCopy119.4",
      "description": "A. Wizards' Duel\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains a single integer l (1 ≤ l ≤ 1 000) — the length of the corridor where the fight takes place.The second line contains integer p, the third line contains integer q (1 ≤ p, q ≤ 500) — the speeds of magical impulses for Harry Potter and He-Who-Must-Not-Be-Named, respectively.\n\nOutputPrint a single real number — the distance from the end of the corridor, where Harry is located, to the place of the second meeting of the spell impulses. Your answer will be considered correct if its absolute or relative error will not exceed 10 - 4. Namely: let's assume that your answer equals a, and the answer of the jury is b. The checker program will consider your answer correct if .\n\nInputCopy1005050OutputCopy50InputCopy1996040OutputCopy119.4\n\nInputCopy1005050\n\nOutputCopy50\n\nInputCopy1996040\n\nOutputCopy119.4\n\nNoteIn the first sample the speeds of the impulses are equal, so both of their meetings occur exactly in the middle of the corridor.",
      "solutions": [
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces",
          "content": "Hello, dear participants of Codeforces community!Starting from Codeforces Round #327 I'll be the new coordinator and will manage preparation process for all regular Codeforces rounds and other contests held on this platform. I'll do my best to increase the quality of contests we offer you, though Zlobober already raised this bar high. Let's cheer him once again, for all the great job he had done!Tomorrow round will be held using the problems of Moscow team olympiad for high-school students. Do not be tricked by the word \"school\" — there will be a gold medalist of IOI 2015 participating and some candidates to this year Russian IOI team, meaning the level of the problems will be appropriate. I am sure everyone will find an interesting problem to enjoy.The problemset was prepared by the team of Moscow authors (list is incomplete): Zlobober, romanandreev, meshanya, wilwell, glebushka98, timgaripov, thefacetakt, haku, LHiC, Timus, Sender, sankear, iskhakovt, andrewgark, ipavlov, StopKran, AleX leaded by your humble servant GlebsHP and the chairman of the jury Helen Andreeva.Special thanks to Delinur for translation and stella_marine for correction.Five problems will be offered in both divisions and the scoring distribution will be announced later (good traditions should live).UPD. Round time. Please note that Russia is not changing the timezone this night, while about 100 countries do so. Be sure to check when round starts in your timezone!UPD2. Please note, that the distribution motivates you to read all the problems! Div1.: 750-1000-1250-1750-2500 Div2.: 500-1000-1750-2000-2250UPD3. The results and the editorial will be published later, after the closing ceremony of the official competition.UPD4. The system testing is over, results are now final. Feel free to upsolve and read other contestants code. Congratulations to Div. 1 top-5: Endagorion JoeyWheeler sdya RAD -XraY- UPD5. Problem analysis is now available.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21185",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1940
        },
        {
          "title": "Codeforces Round #327 problems analysis - Codeforces",
          "content": "I like the idea of Endagorion to supplement the problems analysis with small challenges, somehow related to the problem preparation, it's generalization, or more effective solution. Following this, some problems in this analysis are also complemented with this sort of tasks.Div. 2A (Wizards' Duel)Idea of the problem: Roman Gusarev, development: timgaripov.Let's start with determining the position of the first collision. Two impulses converge with a speed p + q, so the first collision will occur after seconds. The coordinate of this collision is given by the formula .Note, that the distance one impulse passes while returning to it's caster is equal to the distance it has passed from the caster to the first collision. That means impulses will reach their casters simultaneously, and the situation will be identic to the beginning of the duel. Hence, the second collision (third, fourth, etc) will occur at exactly the same place as the first one.Code example: 13836780.Div. 2B (Rebranding)Idea of the problem: glebushka98, development: thefacetakt.Trivial solution will just emulate the work of all designers, every time considering all characters of the string one by one and replacing all xi with yi and vice versa. This will work in O(n·m) and get TL.First one should note that same characters always end as a same characters, meaning the position of the letter doesn't affect the result in any way. One should only remember the mapping for all distinct characters. Let p(i, c) be the mapping of c after i designers already finished their job. Now: p(0, c) = c If p(i - 1, c) = xi, then p(i, c) = yi Same, if p(i - 1, c) = yi, then p(i, c) = xi This solution complexity is O(|Σ|·m + n) and is enough to pass all the tests.Challenge: improve the complexity to O(Σ + n + m).Code examples: 13837577 implements O(|Σ|·m + n) and 13839154 stands for O(|Σ| + n + m).Div. 2C\\Div. 1A (Median Smoothing)Problem idea and development: Sender.We will call the element of a sequence stable, if it doesn't change after applying the algorithm of median smoothing for any number of times. Both ends are stable by the definition of the median smoothing. Also, it is easy to notice, that two equal consecutive elements are both stable.Now we should take a look at how do stable elements affect their neighbors. Suppose ai - 1 = ai, meaning i - 1 and i are stable. Additionaly assume, that ai + 1 is not a stable element, hence ai + 1 ≠ ai and ai + 1 ≠ ai + 2. Keeping in mind that only 0 and 1 values are possible, we conclude that ai = ai + 2 and applying a median smoothing algorithm to this sequence will result in ai = ai + 1. That means, if there is a stable element in position i, both i + 1 and i - 1 are guaranteed to be stable after one application of median smoothing. Now we can conclude, that all sequences will turn to stable at some point.Note, that if there are two stable elements i and j with no other stable elements located between them, the sequence of elements between them is alternating, i.e. ak = (ai + k - i)mod2, where . One can check, that stable elements may occur only at the ends of the alternating sequence, meaning the sequence will remain alternating until it will be killed by effect spreading from ending stable elements.The solution is: calculate max(min(|i - sj|)), where sj are the initial stable elements. Time complexity is O(n).Challenge 1: hack the solution that just applies median smoothing until something changes.Challenge 2: think of how to speed up the algorithm from challenge 1 using bitmasks (still gets TL).Code examples: 13838940 and 13838480.Div. 2D\\Div. 1B (Chip 'n Dale Rescue Rangers)Problem idea and development: StopKran.If the velocity of the dirigible relative to the air is given by the vector (ax, ay), while the velocity of the wind is (bx, by), the resulting velocity of the dirigible relative to the plane is (ax + bx, ay + by).The main idea here is that the answer function is monotonous. If the dirigible is able to reach to target in seconds, then it can do so in seconds, for any x ≥ 0. That is an obvious consequence from the fact the maximum self speed of the dirigible is strictly greater then the speed of the wind at any moment of time.For any monotonous function we can use binary search. Now we only need to check, if for some given value it's possible for the dirigible to reach the target in seconds. Let's separate the movement of the air and the movement of the dirigible in the air. The movement cause by the air is: (xn, yn) = , if ; (xn, yn) = , for . The only thing we need to check now is that the distance between the point (xn, yn) and the target coordinates (x2, y2) can be covered moving with the speed vmax in seconds assuming there is no wind.Time complexity is , where C stands for the maximum coordinate, аnd ε — desired accuracy.Challenge 1: think of the solution in case it's not guaranteed that the dirigible is faster than the wind.Challenge 2: can you come up with O(1) solution?Code examples: 13838659 and 13842505.Div. 2E\\Div. 1C (Three States)Problem idea and development: haku.Affirmation. Suppose we are given an undirected unweighted connected graph and three distinct chosen vertices u, v, w of this graph. We state that at least one minimum connecting network for these three vertices has the following form: some vertex c is chosen and the resulting network is obtained as a union of shortest paths from c to each of the chosen vertices.Proof. One of the optimal subgraphs connecting these three vertices is always a tree. Really, we can take any connecting subgraph and while there are cycles remaining in it, take any cycle and throw away any edge of this cycle. Moreover, only vertices u, v and w are allowed to be leaves of this tree, as we can delete from the network any other leaves and the network will still be connected. If the tree has no more than three leaves, it has no more than one vertex with the degree greater than 2. This vertex is c from the statement above. Any path from c to the leaves may obviously be replaced with the shortest path. Special case is than there is no node with the degree greater than 2, meaning one of u, v or w lies on the shortest path connecting two other vertices.The solution is: find the shortest path from each of the chosen vertices to all other vertices, and then try every vertex of the graph as c. Time complexity is O(|V| + |E|).To apply this solution to the given problem we should first build a graph, where cells of the table stand for the vertices and two vertices are connected by an edge, if the corresponding cells were neighboring. Now we should merge all vertices of a single state in one in order to obtain a task described in the beginning. Time complexity is a linear function of the size of the table .Code examples: 13843265 — the solution described above that uses 0-1 bfs instead of merging, 13840329 — another approach that tries to different cases.Div. 1D (Top Secret Task)Problem idea and development: glebushka98.If , than the sum of k minimums is obviously an answer. Let i1 < i2 <  ...  < ik be the indices of the elements that will form the answer. Note, that the relative order of the chosen subset will remain the same, as there is no reason to swap two elements that will both be included in the answer. The minimum number of operations required to place this k elements at the beginning is equal to — .T ≤ S  ≤  . . Calculate the dynamic programming d[i][j][p] &mdash minimum possible sum, if we chose j elements among first i with the total indices sum no greater than p. In order to optimize the memory consumption we will keep in memory only two latest layers of the dp.Time complexity is O(n4), with O(n3) memory consumption.Code examples: 13845513 and 13845571.Div. 1E (Birthday)Problem idea: meshanya, development: romanandreev.The given problem actually consists of two separate problems: build the directed graph of substring relation and find the maximum independent set in it. Note, that if the string s2 is a substring of some string s1, while string s3 is a substring of the string s2, then s3 is a substring of s1. That means the graph of substring relation defines a partially ordered set.To build the graph one can use Aho-Corasick algorithm. Usage of this structure allow to build all essential arc of the graph in time O(L), where L stands for the total length of all strings in the input. We will call the arc essential, if there is no w, such that and . One of the ways to do so is: Build Aho-Corasick using all strings in the input; For every node of the Aho-Corasick structure find and remember the nearest terminal node in the suffix-link path; Once again traverse all strings through Aho-Corasick. Every time new symbol is added, add an arc from the node corresponding to the current string (in the graph we build, not Aho-Corasick) to the node of the graph corresponding to the nearest terminal in the suffix-link path; The previous step will build all essential arcs plus some other arcs, but they do not affect the next step in any way; Find the transitive closure of the graph. To solve the second part of the problem one should use the Dilworth theorem. The way to restore the answer subset comes from the constructive proof of the theorem.Time complexity is O(L + n3) to build the graph plus O(n3) to find the maximum antichain. The overall complexity is O(L + n3).Congratulation to ikatanic — — the only participant to solve this problem during the contest. View his code 13851141 for further clarifications.Challenge: solve the problem with the same asymptotic, if we are to find the subset with the maximum total length of all strings in it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21203",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9655
        }
      ],
      "code_examples": [
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 1",
          "code": "3 3\n1.2\n1.2\n333",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 2",
          "code": "3 3\n1.2\n1.2\n333",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 3",
          "code": "3 3\n1..\n..2\n3..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 4",
          "code": "3 3\n1..\n..2\n3..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 5",
          "code": "segs = re.findall('(.*?)(0{2,}|1{2,})', s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 6",
          "code": "segs = re.findall('(.*?)(0{2,}|1{2,})', s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 7",
          "code": "110010101110100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 8",
          "code": "[('', '11'), ('', '00'), ('1010', '111'), ('01', '00')]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 9",
          "code": "\"1 - NUMBER_1, NUMBER_1\"+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 10",
          "code": "\"NUMBER_1,NUMBER_1\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 11",
          "code": "\"NUMBER_1\" * (length_of_repetition / 2) + \"NUMBER_2\" * (length_of_repetition / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 12",
          "code": "UPD4: ............ Congratulations to Div. 1 top-5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 13",
          "code": "UPD4: ............ Congratulations to Div. 1 top-5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 14",
          "code": "sleep(10 * 60 * 60 * 1000); //10 hours\nupdate_ratings();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 15",
          "code": "sleep(10 * 60 * 60 * 1000); //10 hours\nupdate_ratings();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int l = inf.readInt(1, 1000, \"l\");\n    inf.readEoln();\n\n    int p = inf.readInt(1, 500, \"p\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 500, \"q\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int l = inf.readInt(1, 1000, \"l\");\n    inf.readEoln();\n\n    int p = inf.readInt(1, 500, \"p\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 500, \"q\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int l = inf.readInt(1, 1000, \"l\");\n    inf.readEoln();\n\n    int p = inf.readInt(1, 500, \"p\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, 500, \"q\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read the jury's answer (correct answer)\n    double jury_ans = ans.readDouble();\n\n    // Read the participant's answer\n    double participant_ans = ouf.readDouble();\n\n    // Ensure that there are no extra tokens in participant's output\n    if (!ouf.seekEof()) {\n        quitf(_pe, \"Extra tokens detected after the answer\");\n    }\n\n    // Maximum allowed absolute or relative error\n    const double MAX_ERROR = 1E-4;\n\n    // Calculate absolute error\n    double absolute_error = fabs(participant_ans - jury_ans);\n\n    // Calculate relative error\n    double relative_error = absolute_error / max(1.0, fabs(jury_ans));\n\n    // Check if the error is within the acceptable range\n    if (absolute_error > MAX_ERROR * max(1.0, fabs(jury_ans))) {\n        quitf(_wa, \"Too big error: expected %.10f, found %.10f, absolute error = %.10e, relative error = %.10e\",\n              jury_ans, participant_ans, absolute_error, relative_error);\n    } else {\n        quitf(_ok, \"Correct within acceptable error. Participant's answer = %.10f, Jury's answer = %.10f\",\n              participant_ans, jury_ans);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int lmin = opt<int>(\"lmin\", 1);\n    int lmax = opt<int>(\"lmax\", 1000);\n    int pmin = opt<int>(\"pmin\", 1);\n    int pmax = opt<int>(\"pmax\", 500);\n    int qmin = opt<int>(\"qmin\", 1);\n    int qmax = opt<int>(\"qmax\", 500);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int l, p, q;\n\n    if (type == \"min\") {\n        l = lmin;\n        p = pmin;\n        q = qmin;\n    }\n    else if (type == \"max\") {\n        l = lmax;\n        p = pmax;\n        q = qmax;\n    }\n    else if (type == \"p_eq_q\") {\n        l = rnd.next(lmin, lmax);\n        p = rnd.next(pmin, pmax);\n        q = p;\n    }\n    else if (type == \"p_lt_q\") {\n        l = rnd.next(lmin, lmax);\n        p = rnd.next(pmin, pmax - 1);\n        q = rnd.next(p + 1, qmax);\n    }\n    else if (type == \"p_gt_q\") {\n        l = rnd.next(lmin, lmax);\n        q = rnd.next(qmin, qmax - 1);\n        p = rnd.next(q + 1, pmax);\n    }\n    else if (type == \"p_1_q_max\") {\n        l = rnd.next(lmin, lmax);\n        p = pmin;\n        q = qmax;\n    }\n    else if (type == \"p_max_q_1\") {\n        l = rnd.next(lmin, lmax);\n        p = pmax;\n        q = qmin;\n    }\n    else if (type == \"co_prime\") { // select p and q co-prime\n        l = rnd.next(lmin, lmax);\n        do {\n            p = rnd.next(pmin, pmax);\n            q = rnd.next(qmin, qmax);\n        } while (__gcd(p,q) != 1);\n    }\n    else if (type == \"random\") {\n        l = rnd.next(lmin, lmax);\n        p = rnd.next(pmin, pmax);\n        q = rnd.next(qmin, qmax);\n    }\n    else {\n        // default to random\n        l = rnd.next(lmin, lmax);\n        p = rnd.next(pmin, pmax);\n        q = rnd.next(qmin, qmax);\n    }\n\n    printf(\"%d\\n%d\\n%d\\n\", l, p, q);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int lmin = opt<int>(\"lmin\", 1);\n    int lmax = opt<int>(\"lmax\", 1000);\n    int pmin = opt<int>(\"pmin\", 1);\n    int pmax = opt<int>(\"pmax\", 500);\n    int qmin = opt<int>(\"qmin\", 1);\n    int qmax = opt<int>(\"qmax\", 500);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int l, p, q;\n\n    if (type == \"min\") {\n        l = lmin;\n        p = pmin;\n        q = qmin;\n    }\n    else if (type == \"max\") {\n        l = lmax;\n        p = pmax;\n        q = qmax;\n    }\n    else if (type == \"p_eq_q\") {\n        l = rnd.next(lmin, lmax);\n        p = rnd.next(pmin, pmax);\n        q = p;\n    }\n    else if (type == \"p_lt_q\") {\n        l = rnd.next(lmin, lmax);\n        p = rnd.next(pmin, pmax - 1);\n        q = rnd.next(p + 1, qmax);\n    }\n    else if (type == \"p_gt_q\") {\n        l = rnd.next(lmin, lmax);\n        q = rnd.next(qmin, qmax - 1);\n        p = rnd.next(q + 1, pmax);\n    }\n    else if (type == \"p_1_q_max\") {\n        l = rnd.next(lmin, lmax);\n        p = pmin;\n        q = qmax;\n    }\n    else if (type == \"p_max_q_1\") {\n        l = rnd.next(lmin, lmax);\n        p = pmax;\n        q = qmin;\n    }\n    else if (type == \"co_prime\") { // select p and q co-prime\n        l = rnd.next(lmin, lmax);\n        do {\n            p = rnd.next(pmin, pmax);\n            q = rnd.next(qmin, qmax);\n        } while (__gcd(p,q) != 1);\n    }\n    else if (type == \"random\") {\n        l = rnd.next(lmin, lmax);\n        p = rnd.next(pmin, pmax);\n        q = rnd.next(qmin, qmax);\n    }\n    else {\n        // default to random\n        l = rnd.next(lmin, lmax);\n        p = rnd.next(pmin, pmax);\n        q = rnd.next(qmin, qmax);\n    }\n\n    printf(\"%d\\n%d\\n%d\\n\", l, p, q);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -lmin 1 -lmax 1 -pmin 1 -pmax 1 -qmin 1 -qmax 1 -type min\n./gen -lmin 1000 -lmax 1000 -pmin 500 -pmax 500 -qmin 500 -qmax 500 -type max\n./gen -lmin 1 -lmax 1000 -pmin 1 -pmax 500 -qmin 1 -qmax 500 -type p_eq_q\n./gen -lmin 1 -lmax 1000 -pmin 1 -pmax 250 -qmin 251 -qmax 500 -type p_lt_q\n./gen -lmin 1 -lmax 1000 -pmin 251 -pmax 500 -qmin 1 -qmax 250 -type p_gt_q\n./gen -lmin 1000 -lmax 1000 -pmin 1 -pmax 1 -qmin 500 -qmax 500 -type p_1_q_max\n./gen -lmin 1000 -lmax 1000 -pmin 500 -pmax 500 -qmin 1 -qmax 1 -type p_max_q_1\n./gen -lmin 999 -lmax 999 -pmin 499 -pmax 499 -qmin 500 -qmax 500 -type random\n./gen -lmin 1 -lmax 1 -pmin 1 -pmax 1 -qmin 500 -qmax 500 -type random\n./gen -lmin 1 -lmax 1000 -pmin 1 -pmax 5 -qmin 1 -qmax 5 -type random\n./gen -lmin 1 -lmax 1000 -pmin 495 -pmax 500 -qmin 495 -qmax 500 -type random\n./gen -lmin 1000 -lmax 1000 -pmin 1 -pmax 500 -qmin 1 -qmax 500 -type co_prime\n./gen -lmin 1 -lmax 1000 -pmin 1 -pmax 500 -qmin 1 -qmax 500 -type random\n./gen -lmin 500 -lmax 500 -pmin 1 -pmax 100 -qmin 100 -qmax 200 -type random\n./gen -lmin 1 -lmax 1000 -pmin 10 -pmax 100 -qmin 10 -qmax 100 -type p_eq_q\n./gen -lmin 1 -lmax 1000 -pmin 1 -pmax 10 -qmin 490 -qmax 500 -type p_lt_q\n./gen -lmin 1 -lmax 1000 -pmin 490 -pmax 500 -qmin 1 -qmax 10 -type p_gt_q\n./gen -lmin 999 -lmax 999 -pmin 250 -pmax 250 -qmin 250 -qmax 250 -type p_eq_q\n./gen -lmin 1000 -lmax 1000 -pmin 1 -pmax 1 -qmin 1 -qmax 1 -type random\n./gen -lmin 1 -lmax 1 -pmin 500 -pmax 500 -qmin 500 -qmax 500 -type random\n./gen -lmin 1 -lmax 500 -pmin 1 -pmax 250 -qmin 250 -qmax 500 -type co_prime\n./gen -lmin 1 -lmax 1000 -pmin 1 -pmax 100 -qmin 400 -qmax 500 -type random\n./gen -lmin 1 -lmax 1000 -pmin 1 -pmax 500 -qmin 1 -qmax 500 -type co_prime\n./gen -lmin 1 -lmax 1000 -pmin 1 -pmax 1 -qmin 1 -qmax 500 -type p_1_q_max\n./gen -lmin 1000 -lmax 1000 -pmin 1 -pmax 500 -qmin 1 -qmax 500 -type p_eq_q\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:34.902843",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "591/B",
      "title": "B. Ребрендинг",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных находятся два числа n и m (1 ≤ n, m ≤ 200 000) — длина изначального названия и количество нанятых дизайнеров соответственно.Вторая строка состоит из n строчных английских букв и представляет собой изначальное имя корпорации.В следующих m строках содержатся описания действий дизайнеров: в i-й из последующих строк записаны две строчные английские буквы xi и yi.",
      "output_spec": "Выходные данныеВыведите окончательный вариант названия корпорации.",
      "sample_tests": "ПримерыВходные данныеСкопировать6 1policep mВыходные данныеСкопироватьmoliceВходные данныеСкопировать11 6abacabadabaa bb ca de gf ab bВыходные данныеСкопироватьcdcbcdcfcdc",
      "description": "B. Ребрендинг\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных находятся два числа n и m (1 ≤ n, m ≤ 200 000) — длина изначального названия и количество нанятых дизайнеров соответственно.Вторая строка состоит из n строчных английских букв и представляет собой изначальное имя корпорации.В следующих m строках содержатся описания действий дизайнеров: в i-й из последующих строк записаны две строчные английские буквы xi и yi.\n\nВходные данные\n\nВыходные данныеВыведите окончательный вариант названия корпорации.\n\nВыходные данные\n\nВходные данныеСкопировать6 1policep mВыходные данныеСкопироватьmoliceВходные данныеСкопировать11 6abacabadabaa bb ca de gf ab bВыходные данныеСкопироватьcdcbcdcfcdc\n\nВходные данныеСкопировать6 1policep m\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьmolice\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать11 6abacabadabaa bb ca de gf ab b\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьcdcbcdcfcdc\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВо втором примере название корпорации последовательно претерпевает следующие изменения:",
      "solutions": [
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces",
          "content": "Здравствуйте, уважаемые участники сообщества Codeforces!Начиная с Codeforces Round #327, я буду координировать подготовку регулярных раундов и прочих контестов, которые проводятся на платформе Codeforces. Обещаю приложить максимум усилий, чтобы улучшить качество подготовки контестов, хотя это и будет проблематично сделать — Zlobober установил высокую планку. Давайте ещё раз поблагодарим Максима за хорошо проделанную работу!Завтрашний раунд проводится на задачах Московcкой городской командной олимпиады по программированию среди школьников. Пусть вас не смущает, что это школьное соревнование, — среди участников есть золотой призёр IOI 2015 и несколько кандидатов в сборную России этого года, поэтому мы постарались сделать все задачи интересными, а некоторые ещё и сложными. Уверен, что каждому из вас должна понравиться хотя бы одна задача предстоящего раунда.Задачи были подготовлены коллективом московских авторов в составе (список пополняется): Zlobober, romanandreev, meshanya, wilwell, glebushka98, timgaripov, thefacetakt, haku, LHiC, Timus, Sender, sankear, iskhakovt, andrewgark, ipavlov, StopKran, AleX. Руководство подготовкой осуществляли ваш покорный слуга GlebsHP и председатель жюри олимпиады Андреева Елена Владимировна.Отдельно благодарим Delinur за перевод условий на английский язык и stella_marine за вычитку.В каждом дивизионе будет предложено для решения пять задач, разбаловка будет опубликована позднее (не будем нарушать эту традицию).UPD. Время раунда. Обратите внимание, что во многих странах мира этой ночью переводят часы, а в России не переводят — не пропустите случайно раунд :)UPD2. Обратите внимание, разбаловка как бы намекает, что надо прочитать все задачи! Div1.: 750-1000-1250-1750-2500 Div2.: 500-1000-1750-2000-2250UPD3. Результаты раунда и разбор будут опубликованы позднее, когда завершится официальное соревнование.UPD4. Системное тестирование завершено, доступны окончательные результаты, открыто дорешивание задач. Поздравляем победителей в первом дивизионе: Endagorion JoeyWheeler sdya RAD -XraY- UPD5. Появился разбор.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21185",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2070
        },
        {
          "title": "Разбор задач Codeforces Round #327 - Codeforces",
          "content": "Мне нравится идея Endagorion дополнять разбор задач небольшими упражнениями, связанными с подготовкой задачи, её обобщением или наличием более эффективного решения. Попробуем и мы предложить читателю подобные вопросы по некоторым задачам.Div. 2A (Поединок волшебников)Автор идеи: Роман Гусарев, разработка: timgaripov.Найдем координату первого столкновения импульсов. Они сближаются со скоростью p + q, а значит первое столкновение произойдёт через секунд. Следовательно, координата первого столкновения может быть вычислена как .Заметим теперь, что расстояние проходимое импульсами на обратном пути до волшебников равно расстоянию проходимому ими от волшебников до места первой встречи. Это значит, что импульсы вернутся к волшебникам одновременно, и ситуация станет идентична изначальной. Таким образом, вторая встреча (и все последующие) произойдёт в той же точке, что и первая.Пример решения: 13836780.Div. 2B (Ребрендинг)Автор идеи: glebushka98, разработка: thefacetakt.Тривиальное решение: будем эмулировать работу дизайнеров, а именно каждый раз ходить и честно перекрашвать все xi в yi и наоборот. Работает за , получает TL.Попробуем улучшить этот результат.Заметим, что одинаковые буквы переходят в одинаковые. Это означает, что позиция буквы никак не влияет на результат, и достаточно помнить для каждого возможного значения символа, во что он перейдёт. Пусть p(i, c) — символ, который будет стоять вместо всех вхождений c после обработки i дизайнеров. Тогда: p(0, c) = c Если p(i - 1, c) = xi, то p(i, c) = yi Аналогично, если p(i - 1, c) = yi, то p(i, c) = xi Данное решение работает уже за O(|Σ|·m + n) и проходит все тесты.Упражнение: доведите решение данной задачи до сложности O(Σ + n + m).Примеры решения: 13837577 за O(|Σ|·m + n) и 13839154 за O(|Σ| + n + m).Div. 2C\\Div. 1A (Медианное сглаживание)Автор идеи и разработчик: Sender.Назовём статичными точками позиции, которые не могут измениться, сколько бы раз мы не применяли к последовательности алгоритм медианного сглаживания. Оба конца являются статичными точками по определению. Также, легко заметить, что если рядом стоят два одинаковых символа, то обе эти позиции так же являются статичными точками.Исследуем влияние статичных точек на соседние элементы. Пусть ai - 1 = ai, то есть элемемнты i - 1 и i являются статичными точками. Пусть также ai + 1 статичной точкой пока не является, следовательно ai + 1 ≠ ai и ai + 1 ≠ ai + 2. Из предыдущего предложения и того, что возможны только 0 и 1 делаем вывод, что ai = ai + 2 и после одного применения алгоритма медианного сглаживания будет выполнено ai = ai + 1. То есть любая статичная точка за один шаг превращает все соседние элементы в статичные точки. Таким образом, любая последовательность в итоге стабилизируется.Остаётся только вычислить скорость стабилизации и результирующие значения. Заметим, что если между двумя статичными точками i и j нет других статичных точек, то это означает чередование всех символов между позициями i и j. Несложно проверить, что в чередующейся последовательности новые статичные точки не образуются, следовательно последовательность будет оставаться чередующейся пока до неё не дойдёт влияние одной из соседних статичных точек.Итоговое решение: выделим все статичные точки в изначальной последовательности и найдём max(min(|i - sj|)), где sj — множество индексов позиций статичных точек. Сложность решения O(n).Упражнение 1: взломайте решение честно моделирующее применение алгоритма медианного сглаживания до стабилизации процесса.Упражнение 2: придумайте как ускорить квадратичное решение с помощью битового сжатия (и всё равно получить TL).Примеры решений: 13838940 и 13838480.Div. 2D\\Div. 1B (Чип и Дейл спешат на помощь)Автор идеи и разработчик: StopKran.Заметим, что если собственная скорость дирижабля задана вектором (ax, ay), а скорость ветра вектором (bx, by), то реальный вектор движения дирижабля определяется как (ax + bx, ay + by).Одним из ключевых моментов в решении задачи является понимание монотонности функции ответа по времени. Если дирижабль может достичь цели за секунд, то он сможет достичь её и за секунд, для любого x ≥ 0. Это очевидно вытекает из условия, что максимально возможная собственная скорость дирижабля строго превосходит скорость ветра в любой момент времени. Поскольку функция ответа монотонна, воспользуемся методом бинарного поиска по ответу, а именно, научимся проверять для фиксированного параметра , возможно ли добраться от точки (x1, y1) до точки (x2, y2) за время . Будем учитывать перемещение под действием ветра и собственное перемещение отдельно. Найдём сперва смещение дирижабля вызванное ветром: (xn, yn) = , если ; (xn, yn) = , если . Остаётся только проверить, что используя только лишь собственную скорость можно добраться за время из точки (xn, yn) в точку (x2, y2).Итоговая сложность: , где C — максимальная координата, а ε — требуемая точность.Упражнение 1: подумайте как решить задачу, в случае когда не гарантируется, что дирижабль всегда быстрее ветра.Упражнение 2: можете ли вы решить задачу за время O(1)?Примеры решений: 13838659 и 13842505.Div. 2E\\Div. 1C (Три государства)Автор идеи и разработчик: haku.Утверждение. Пусть в неориентированном невзвешенном связном графе выделенны три различные вершины u, v, w. Одна из минимальных сетей, связывающих выделенные вершины, выглядит как некоторая вершина графа c, возможно совпадающая с одной из выделенных, из которой исходят кратчайшие пути к каждой из выделенных вершин, причём эти пути являются вершинно-непересекающимися.Доказательство. Одним из оптимальных связывающих подграфов обязательно является дерево. Действительно, в противном случае на любом цикле найдётся ребро, которое можно выкинуть, и это не ухудшит ответ, поскольку он не зависит от количества используемых рёбер. Листьями дерева могу являться только вершины u, v и w, иначе ответ можно было бы улучшить, просто выкинув такой листь. Дерево, у которого не более чем три листа, имеет не более одной вершины степени больше двух, которая и будет вершиной c из утверждения выше. Разумеется, любой путь от c до листа имеет смысл заменить на кратчайший. Отдельно возможен вырожденный случай, что дерево ответа — это бамбук, но в таком случае вершиной c является одна из трёх выделенных вершин (не лист).Теперь имеем следующий метод для нахождения длины кратчайшей связывающей сети: перебрать все вершины, включая выделенные, и из сумм кратчайших расстояний от данной вершины до выделенных выбрать минимальную. Ясно, что таким образом мы переберём длины различных связывающих сетей, среди которых будет и длина кратчайшей, и поэтому минимум будет ответом.Для сведения исходной задачи к задаче поиска минимальной связывающей сети, можно представить карту в виде графа, где вершинам соответствуют клетки, принадлежащие государствам или допускающие постройку дороги, а ребро между двумя вершинами ставится, если они являются соседними в таблице. Все вершины, соответствующие одному государству, необходимо сжать в одну. Несложно заметить, что исходная задача таким образом свелась к вышеописанной.Примеры решений: 13843265 — описанное решение реализовано через бфс на 0-1 графе, 13840329 — здесь логика решения несколько иная, разбираются два принципиально разных случая.Div. 1D (Сверхсекретное задание)Автор идеи и разработчик: glebushka98.Если , то ответом является сумма k минимальных элементов. Пусть i1 < i2 <  ...  < ik — индексы элементов, которые войдут в итоге в ответ. Заметим, что относительный порядок выбранных элементов менять не имеет смысла, а значит, мы можем однозначно сказать, какой из выбранных элементов займёт какую позицию в ответе. T — минимальное количество операций, за которое их можно поставить на k первых мест. — .T ≤ S  ≤  . . Посчитаем динамику d[i][j][p] — минимально возможная сумма, если среди первых i элементов выбрать j с суммой индексов не больше p. В целях оптимизации использования памяти будем хранить каждый раз только два верхних уровня динамики.Итоговая сложность решения: O(n4) по времени и O(n3) по памяти.Примеры решений: 13845513 и 13845571.Div. 1E (День рождения)Автор идеи: meshanya, разработчик: romanandreev.Задача естественно разбивается на две подзадачи: быстрое построение графа вложенности и нахождение максимального независимого множества в этом графе. Заметим сразу, что если строка s2 является подстрокой строки s1, а строка s3 является подстрокой строки s2, то s3 очевидно является подстрокой строки s1. Таким образом, граф вложений зададаёт частично упорядоченное множество.Для быстрого построения графа воспользуемся алгоритмом Ахо-Корасик. С помощью данной структуры мы построим все существенные рёбра графа, то есть такие рёбра , что не найдётся w, такого что и . Одним из возможных способов является: Построить структуру Ахо-Корасик; Для каждой вершины найти и запомнить ближайшую терминальную в суффиксном пути; Ещё раз скормить каждую строку автомату Ахо-Корасик, при этом каждый раз после добавления очередного символа требуется проводить ребро в ближайшую терминальную вершину в суффиксном пути; Кроме существенных рёбер, данный алгоритм возможно добавит ещё какие-то корректные рёбра, но это никак не влияет на результат работы следующего шага; Транзитивно замкнуть построенный граф. Для решение второй части данной задачи требует применить теорему Дилворта. Восстановление ответа следует из конструктивного доказательства теоремы. Получаем O(L + n3) на построение графа + O(n3) на нахождение максимальной антицепи, итоговая сложность решения: O(L + n3), где L — суммарная длина всех строк.Поздравляем ikatanic — единственного человека сдавшего эту задачу во время тура. Для дальнейшего уточнения решения предлагается посмотреть 13851141.Упражнение: научитесь решать задачу с сохранением асимптотики, при условии что требуется найти множество строк максимальное не по размеру, а по суммарной длине.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21203",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 9801
        }
      ],
      "code_examples": [
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 1",
          "code": "3 3\n1.2\n1.2\n333",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 2",
          "code": "3 3\n1.2\n1.2\n333",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 3",
          "code": "3 3\n1..\n..2\n3..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 4",
          "code": "3 3\n1..\n..2\n3..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 5",
          "code": "segs = re.findall('(.*?)(0{2,}|1{2,})', s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 6",
          "code": "segs = re.findall('(.*?)(0{2,}|1{2,})', s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 7",
          "code": "110010101110100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 8",
          "code": "[('', '11'), ('', '00'), ('1010', '111'), ('01', '00')]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 9",
          "code": "\"1 - NUMBER_1, NUMBER_1\"+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 10",
          "code": "\"NUMBER_1,NUMBER_1\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 11",
          "code": "\"NUMBER_1\" * (length_of_repetition / 2) + \"NUMBER_2\" * (length_of_repetition / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 12",
          "code": "int main()\n{\n\n\tchar x, y;\n\tscanf(\"%c%c\", &x, &y); //вбиваем \"2 3\"\n\tcout << x << ' ' << y << endl; // получаем на вывод \"2 \"\n\tcin >> x >> y; // вбиваем \"2 3\"\n\tcout << x << ' ' << y << endl; получаем на вывод \"3 2\", ибо \"3\" осталось с предыдущего ввода\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 13",
          "code": "int main()\n{\n\n\tchar x, y;\n\tscanf(\"%c%c\", &x, &y); //вбиваем \"2 3\"\n\tcout << x << ' ' << y << endl; // получаем на вывод \"2 \"\n\tcin >> x >> y; // вбиваем \"2 3\"\n\tcout << x << ' ' << y << endl; получаем на вывод \"3 2\", ибо \"3\" осталось с предыдущего ввода\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 14",
          "code": "scanf(\" %c %c\", &x, &y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 15",
          "code": "scanf(\" %c %c\", &x, &y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 16",
          "code": "scanf(\"%d %d\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 17",
          "code": "char x[2], y[2];\nscanf(\"%s%s\", x, y);\ncout << x[0] << ' ' << y[0] << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 18",
          "code": "char x[2], y[2];\nscanf(\"%s%s\", x, y);\ncout << x[0] << ' ' << y[0] << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 19",
          "code": "contestant.delta = (contestant.needRating - contestant.rating) / 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 20",
          "code": "contestant.delta = (contestant.needRating - contestant.rating) / 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 21",
          "code": "UPD4: ............ Congratulations to Div. 1 top-5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 22",
          "code": "UPD4: ............ Congratulations to Div. 1 top-5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 23",
          "code": "sleep(10 * 60 * 60 * 1000); //10 hours\nupdate_ratings();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 24",
          "code": "sleep(10 * 60 * 60 * 1000); //10 hours\nupdate_ratings();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    string name = inf.readToken(\"[a-z]+\", \"name\");\n    inf.readEoln();\n    ensuref(int(name.size()) == n, \"The name should have length %d, but has length %d\", n, int(name.size()));\n\n    for (int i = 0; i < m; ++i) {\n        string x_i = inf.readToken(\"[a-z]\", \"x_i\");\n        inf.readSpace();\n        string y_i = inf.readToken(\"[a-z]\", \"y_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    string name = inf.readToken(\"[a-z]+\", \"name\");\n    inf.readEoln();\n    ensuref(int(name.size()) == n, \"The name should have length %d, but has length %d\", n, int(name.size()));\n\n    for (int i = 0; i < m; ++i) {\n        string x_i = inf.readToken(\"[a-z]\", \"x_i\");\n        inf.readSpace();\n        string y_i = inf.readToken(\"[a-z]\", \"y_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    string name = inf.readToken(\"[a-z]+\", \"name\");\n    inf.readEoln();\n    ensuref(int(name.size()) == n, \"The name should have length %d, but has length %d\", n, int(name.size()));\n\n    for (int i = 0; i < m; ++i) {\n        string x_i = inf.readToken(\"[a-z]\", \"x_i\");\n        inf.readSpace();\n        string y_i = inf.readToken(\"[a-z]\", \"y_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n    vector<pair<char, char>> operations;\n\n    if (type == \"random\") {\n        // Generate random string s of length n\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n        // Generate m random operations\n        operations.resize(m);\n        for (int i = 0; i < m; ++i) {\n            char xi = 'a' + rnd.next(26);\n            char yi = 'a' + rnd.next(26);\n            operations[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"same_letter\") {\n        // Generate a string with the same letter\n        char letter = 'a' + rnd.next(26);\n        s = string(n, letter);\n\n        // Generate m random operations\n        operations.resize(m);\n        for (int i = 0; i < m; ++i) {\n            char xi = 'a' + rnd.next(26);\n            char yi = 'a' + rnd.next(26);\n            operations[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"alternating_letters\") {\n        // Generate a string with alternating letters\n        char letter1 = 'a' + rnd.next(26);\n        char letter2;\n        do {\n            letter2 = 'a' + rnd.next(26);\n        } while (letter2 == letter1);\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? letter1 : letter2;\n        }\n        // Generate m random operations\n        operations.resize(m);\n        for (int i = 0; i < m; ++i) {\n            char xi = 'a' + rnd.next(26);\n            char yi = 'a' + rnd.next(26);\n            operations[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"all_letters\") {\n        // Generate a string using all letters 'a' to 'z' repeatedly\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + (i % 26);\n        }\n        // Generate m random operations\n        operations.resize(m);\n        for (int i = 0; i < m; ++i) {\n            char xi = 'a' + rnd.next(26);\n            char yi = 'a' + rnd.next(26);\n            operations[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"swap_same_letter\") {\n        // Generate random string s\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n        // Generate m operations where xi == yi\n        operations.resize(m);\n        char letter = 'a' + rnd.next(26);\n        for (int i = 0; i < m; ++i) {\n            operations[i] = make_pair(letter, letter);\n        }\n    } else if (type == \"no_effect\") {\n        // Generate string s using a subset of letters\n        s.resize(n);\n        set<char> used_letters;\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(10); // Use letters 'a' to 'j'\n            used_letters.insert(s[i]);\n        }\n        // Generate m operations with letters not in s\n        operations.resize(m);\n        vector<char> remaining_letters;\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (used_letters.find(c) == used_letters.end()) {\n                remaining_letters.push_back(c);\n            }\n        }\n        int sz = remaining_letters.size();\n        for (int i = 0; i < m; ++i) {\n            char xi = remaining_letters[rnd.next(sz)];\n            char yi = remaining_letters[rnd.next(sz)];\n            operations[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"reverse_operations\") {\n        // Generate random string s\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n        // Generate operations that reverse themselves\n        operations.clear();\n        int op_pairs = m / 2;\n        for (int i = 0; i < op_pairs; ++i) {\n            char xi = 'a' + rnd.next(26);\n            char yi;\n            do {\n                yi = 'a' + rnd.next(26);\n            } while (xi == yi);\n            operations.push_back(make_pair(xi, yi));\n            operations.push_back(make_pair(xi, yi));\n        }\n        if (m % 2 == 1) {\n            char xi = 'a' + rnd.next(26);\n            char yi = 'a' + rnd.next(26);\n            operations.push_back(make_pair(xi, yi));\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n    // Output operations\n    for (int i = 0; i < m; ++i) {\n        printf(\"%c %c\\n\", operations[i].first, operations[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n    vector<pair<char, char>> operations;\n\n    if (type == \"random\") {\n        // Generate random string s of length n\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n        // Generate m random operations\n        operations.resize(m);\n        for (int i = 0; i < m; ++i) {\n            char xi = 'a' + rnd.next(26);\n            char yi = 'a' + rnd.next(26);\n            operations[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"same_letter\") {\n        // Generate a string with the same letter\n        char letter = 'a' + rnd.next(26);\n        s = string(n, letter);\n\n        // Generate m random operations\n        operations.resize(m);\n        for (int i = 0; i < m; ++i) {\n            char xi = 'a' + rnd.next(26);\n            char yi = 'a' + rnd.next(26);\n            operations[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"alternating_letters\") {\n        // Generate a string with alternating letters\n        char letter1 = 'a' + rnd.next(26);\n        char letter2;\n        do {\n            letter2 = 'a' + rnd.next(26);\n        } while (letter2 == letter1);\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? letter1 : letter2;\n        }\n        // Generate m random operations\n        operations.resize(m);\n        for (int i = 0; i < m; ++i) {\n            char xi = 'a' + rnd.next(26);\n            char yi = 'a' + rnd.next(26);\n            operations[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"all_letters\") {\n        // Generate a string using all letters 'a' to 'z' repeatedly\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + (i % 26);\n        }\n        // Generate m random operations\n        operations.resize(m);\n        for (int i = 0; i < m; ++i) {\n            char xi = 'a' + rnd.next(26);\n            char yi = 'a' + rnd.next(26);\n            operations[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"swap_same_letter\") {\n        // Generate random string s\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n        // Generate m operations where xi == yi\n        operations.resize(m);\n        char letter = 'a' + rnd.next(26);\n        for (int i = 0; i < m; ++i) {\n            operations[i] = make_pair(letter, letter);\n        }\n    } else if (type == \"no_effect\") {\n        // Generate string s using a subset of letters\n        s.resize(n);\n        set<char> used_letters;\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(10); // Use letters 'a' to 'j'\n            used_letters.insert(s[i]);\n        }\n        // Generate m operations with letters not in s\n        operations.resize(m);\n        vector<char> remaining_letters;\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (used_letters.find(c) == used_letters.end()) {\n                remaining_letters.push_back(c);\n            }\n        }\n        int sz = remaining_letters.size();\n        for (int i = 0; i < m; ++i) {\n            char xi = remaining_letters[rnd.next(sz)];\n            char yi = remaining_letters[rnd.next(sz)];\n            operations[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"reverse_operations\") {\n        // Generate random string s\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = 'a' + rnd.next(26);\n        }\n        // Generate operations that reverse themselves\n        operations.clear();\n        int op_pairs = m / 2;\n        for (int i = 0; i < op_pairs; ++i) {\n            char xi = 'a' + rnd.next(26);\n            char yi;\n            do {\n                yi = 'a' + rnd.next(26);\n            } while (xi == yi);\n            operations.push_back(make_pair(xi, yi));\n            operations.push_back(make_pair(xi, yi));\n        }\n        if (m % 2 == 1) {\n            char xi = 'a' + rnd.next(26);\n            char yi = 'a' + rnd.next(26);\n            operations.push_back(make_pair(xi, yi));\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n    // Output operations\n    for (int i = 0; i < m; ++i) {\n        printf(\"%c %c\\n\", operations[i].first, operations[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n\n./gen -n 10 -m 10 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 1000 -m 1000 -type random\n./gen -n 10000 -m 10000 -type random\n./gen -n 100000 -m 100000 -type random\n./gen -n 200000 -m 200000 -type random\n\n./gen -n 200000 -m 200000 -type same_letter\n./gen -n 200000 -m 200000 -type alternating_letters\n./gen -n 200000 -m 200000 -type all_letters\n\n./gen -n 200000 -m 200000 -type swap_same_letter\n./gen -n 200000 -m 200000 -type no_effect\n./gen -n 200000 -m 200000 -type reverse_operations\n\n./gen -n 200000 -m 1 -type random\n./gen -n 200000 -m 1 -type swap_same_letter\n./gen -n 200000 -m 1 -type no_effect\n\n./gen -n 1 -m 200000 -type random\n\n./gen -n 10 -m 10 -type same_letter\n./gen -n 10 -m 10 -type alternating_letters\n./gen -n 26 -m 26 -type all_letters\n\n./gen -n 100000 -m 100000 -type swap_same_letter\n./gen -n 100000 -m 100000 -type no_effect\n\n./gen -n 100000 -m 100000 -type reverse_operations\n\n./gen -n 100000 -m 50000 -type random\n\n./gen -n 50000 -m 100000 -type random\n\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type swap_same_letter\n./gen -n 1 -m 1 -type no_effect\n\n./gen -n 200000 -m 200000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:37.168476",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "591/C",
      "title": "C. Медианное сглаживание",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных находится одно целое число n (3 ≤ n ≤ 500 000) — число элементов в рассматриваемой последовательности. В следующей строке находится исходная последовательность чисел a1, a2, ..., an, состоящая только из нулей и единиц.",
      "output_spec": "Выходные данныеВ случае, если последовательность никогда не станет стабильной, выведите одно число  - 1. В противном случае в первой строке выведите одно число — минимальное число раз, которое нужно применить алгоритм медианного сглаживания, прежде чем последовательность станет стабильной. Во второй строке выведите n чисел через пробел — саму итоговую последовательность.",
      "sample_tests": "ПримерыВходные данныеСкопировать40 0 1 1Выходные данныеСкопировать00 0 1 1Входные данныеСкопировать50 1 0 1 0Выходные данныеСкопировать20 0 0 0 0",
      "description": "C. Медианное сглаживание\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных находится одно целое число n (3 ≤ n ≤ 500 000) — число элементов в рассматриваемой последовательности. В следующей строке находится исходная последовательность чисел a1, a2, ..., an, состоящая только из нулей и единиц.\n\nВходные данные\n\nВыходные данныеВ случае, если последовательность никогда не станет стабильной, выведите одно число  - 1. В противном случае в первой строке выведите одно число — минимальное число раз, которое нужно применить алгоритм медианного сглаживания, прежде чем последовательность станет стабильной. Во второй строке выведите n чисел через пробел — саму итоговую последовательность.\n\nВыходные данные\n\nВходные данныеСкопировать40 0 1 1Выходные данныеСкопировать00 0 1 1Входные данныеСкопировать50 1 0 1 0Выходные данныеСкопировать20 0 0 0 0\n\nВходные данныеСкопировать40 0 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать00 0 1 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать50 1 0 1 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать20 0 0 0 0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВо втором примере стабилизация наступает через два шага: , а последовательность 00000, как нетрудно заметить, является стабильной.",
      "solutions": [
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces",
          "content": "Здравствуйте, уважаемые участники сообщества Codeforces!Начиная с Codeforces Round #327, я буду координировать подготовку регулярных раундов и прочих контестов, которые проводятся на платформе Codeforces. Обещаю приложить максимум усилий, чтобы улучшить качество подготовки контестов, хотя это и будет проблематично сделать — Zlobober установил высокую планку. Давайте ещё раз поблагодарим Максима за хорошо проделанную работу!Завтрашний раунд проводится на задачах Московcкой городской командной олимпиады по программированию среди школьников. Пусть вас не смущает, что это школьное соревнование, — среди участников есть золотой призёр IOI 2015 и несколько кандидатов в сборную России этого года, поэтому мы постарались сделать все задачи интересными, а некоторые ещё и сложными. Уверен, что каждому из вас должна понравиться хотя бы одна задача предстоящего раунда.Задачи были подготовлены коллективом московских авторов в составе (список пополняется): Zlobober, romanandreev, meshanya, wilwell, glebushka98, timgaripov, thefacetakt, haku, LHiC, Timus, Sender, sankear, iskhakovt, andrewgark, ipavlov, StopKran, AleX. Руководство подготовкой осуществляли ваш покорный слуга GlebsHP и председатель жюри олимпиады Андреева Елена Владимировна.Отдельно благодарим Delinur за перевод условий на английский язык и stella_marine за вычитку.В каждом дивизионе будет предложено для решения пять задач, разбаловка будет опубликована позднее (не будем нарушать эту традицию).UPD. Время раунда. Обратите внимание, что во многих странах мира этой ночью переводят часы, а в России не переводят — не пропустите случайно раунд :)UPD2. Обратите внимание, разбаловка как бы намекает, что надо прочитать все задачи! Div1.: 750-1000-1250-1750-2500 Div2.: 500-1000-1750-2000-2250UPD3. Результаты раунда и разбор будут опубликованы позднее, когда завершится официальное соревнование.UPD4. Системное тестирование завершено, доступны окончательные результаты, открыто дорешивание задач. Поздравляем победителей в первом дивизионе: Endagorion JoeyWheeler sdya RAD -XraY- UPD5. Появился разбор.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21185",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2070
        },
        {
          "title": "Разбор задач Codeforces Round #327 - Codeforces",
          "content": "Мне нравится идея Endagorion дополнять разбор задач небольшими упражнениями, связанными с подготовкой задачи, её обобщением или наличием более эффективного решения. Попробуем и мы предложить читателю подобные вопросы по некоторым задачам.Div. 2A (Поединок волшебников)Автор идеи: Роман Гусарев, разработка: timgaripov.Найдем координату первого столкновения импульсов. Они сближаются со скоростью p + q, а значит первое столкновение произойдёт через секунд. Следовательно, координата первого столкновения может быть вычислена как .Заметим теперь, что расстояние проходимое импульсами на обратном пути до волшебников равно расстоянию проходимому ими от волшебников до места первой встречи. Это значит, что импульсы вернутся к волшебникам одновременно, и ситуация станет идентична изначальной. Таким образом, вторая встреча (и все последующие) произойдёт в той же точке, что и первая.Пример решения: 13836780.Div. 2B (Ребрендинг)Автор идеи: glebushka98, разработка: thefacetakt.Тривиальное решение: будем эмулировать работу дизайнеров, а именно каждый раз ходить и честно перекрашвать все xi в yi и наоборот. Работает за , получает TL.Попробуем улучшить этот результат.Заметим, что одинаковые буквы переходят в одинаковые. Это означает, что позиция буквы никак не влияет на результат, и достаточно помнить для каждого возможного значения символа, во что он перейдёт. Пусть p(i, c) — символ, который будет стоять вместо всех вхождений c после обработки i дизайнеров. Тогда: p(0, c) = c Если p(i - 1, c) = xi, то p(i, c) = yi Аналогично, если p(i - 1, c) = yi, то p(i, c) = xi Данное решение работает уже за O(|Σ|·m + n) и проходит все тесты.Упражнение: доведите решение данной задачи до сложности O(Σ + n + m).Примеры решения: 13837577 за O(|Σ|·m + n) и 13839154 за O(|Σ| + n + m).Div. 2C\\Div. 1A (Медианное сглаживание)Автор идеи и разработчик: Sender.Назовём статичными точками позиции, которые не могут измениться, сколько бы раз мы не применяли к последовательности алгоритм медианного сглаживания. Оба конца являются статичными точками по определению. Также, легко заметить, что если рядом стоят два одинаковых символа, то обе эти позиции так же являются статичными точками.Исследуем влияние статичных точек на соседние элементы. Пусть ai - 1 = ai, то есть элемемнты i - 1 и i являются статичными точками. Пусть также ai + 1 статичной точкой пока не является, следовательно ai + 1 ≠ ai и ai + 1 ≠ ai + 2. Из предыдущего предложения и того, что возможны только 0 и 1 делаем вывод, что ai = ai + 2 и после одного применения алгоритма медианного сглаживания будет выполнено ai = ai + 1. То есть любая статичная точка за один шаг превращает все соседние элементы в статичные точки. Таким образом, любая последовательность в итоге стабилизируется.Остаётся только вычислить скорость стабилизации и результирующие значения. Заметим, что если между двумя статичными точками i и j нет других статичных точек, то это означает чередование всех символов между позициями i и j. Несложно проверить, что в чередующейся последовательности новые статичные точки не образуются, следовательно последовательность будет оставаться чередующейся пока до неё не дойдёт влияние одной из соседних статичных точек.Итоговое решение: выделим все статичные точки в изначальной последовательности и найдём max(min(|i - sj|)), где sj — множество индексов позиций статичных точек. Сложность решения O(n).Упражнение 1: взломайте решение честно моделирующее применение алгоритма медианного сглаживания до стабилизации процесса.Упражнение 2: придумайте как ускорить квадратичное решение с помощью битового сжатия (и всё равно получить TL).Примеры решений: 13838940 и 13838480.Div. 2D\\Div. 1B (Чип и Дейл спешат на помощь)Автор идеи и разработчик: StopKran.Заметим, что если собственная скорость дирижабля задана вектором (ax, ay), а скорость ветра вектором (bx, by), то реальный вектор движения дирижабля определяется как (ax + bx, ay + by).Одним из ключевых моментов в решении задачи является понимание монотонности функции ответа по времени. Если дирижабль может достичь цели за секунд, то он сможет достичь её и за секунд, для любого x ≥ 0. Это очевидно вытекает из условия, что максимально возможная собственная скорость дирижабля строго превосходит скорость ветра в любой момент времени. Поскольку функция ответа монотонна, воспользуемся методом бинарного поиска по ответу, а именно, научимся проверять для фиксированного параметра , возможно ли добраться от точки (x1, y1) до точки (x2, y2) за время . Будем учитывать перемещение под действием ветра и собственное перемещение отдельно. Найдём сперва смещение дирижабля вызванное ветром: (xn, yn) = , если ; (xn, yn) = , если . Остаётся только проверить, что используя только лишь собственную скорость можно добраться за время из точки (xn, yn) в точку (x2, y2).Итоговая сложность: , где C — максимальная координата, а ε — требуемая точность.Упражнение 1: подумайте как решить задачу, в случае когда не гарантируется, что дирижабль всегда быстрее ветра.Упражнение 2: можете ли вы решить задачу за время O(1)?Примеры решений: 13838659 и 13842505.Div. 2E\\Div. 1C (Три государства)Автор идеи и разработчик: haku.Утверждение. Пусть в неориентированном невзвешенном связном графе выделенны три различные вершины u, v, w. Одна из минимальных сетей, связывающих выделенные вершины, выглядит как некоторая вершина графа c, возможно совпадающая с одной из выделенных, из которой исходят кратчайшие пути к каждой из выделенных вершин, причём эти пути являются вершинно-непересекающимися.Доказательство. Одним из оптимальных связывающих подграфов обязательно является дерево. Действительно, в противном случае на любом цикле найдётся ребро, которое можно выкинуть, и это не ухудшит ответ, поскольку он не зависит от количества используемых рёбер. Листьями дерева могу являться только вершины u, v и w, иначе ответ можно было бы улучшить, просто выкинув такой листь. Дерево, у которого не более чем три листа, имеет не более одной вершины степени больше двух, которая и будет вершиной c из утверждения выше. Разумеется, любой путь от c до листа имеет смысл заменить на кратчайший. Отдельно возможен вырожденный случай, что дерево ответа — это бамбук, но в таком случае вершиной c является одна из трёх выделенных вершин (не лист).Теперь имеем следующий метод для нахождения длины кратчайшей связывающей сети: перебрать все вершины, включая выделенные, и из сумм кратчайших расстояний от данной вершины до выделенных выбрать минимальную. Ясно, что таким образом мы переберём длины различных связывающих сетей, среди которых будет и длина кратчайшей, и поэтому минимум будет ответом.Для сведения исходной задачи к задаче поиска минимальной связывающей сети, можно представить карту в виде графа, где вершинам соответствуют клетки, принадлежащие государствам или допускающие постройку дороги, а ребро между двумя вершинами ставится, если они являются соседними в таблице. Все вершины, соответствующие одному государству, необходимо сжать в одну. Несложно заметить, что исходная задача таким образом свелась к вышеописанной.Примеры решений: 13843265 — описанное решение реализовано через бфс на 0-1 графе, 13840329 — здесь логика решения несколько иная, разбираются два принципиально разных случая.Div. 1D (Сверхсекретное задание)Автор идеи и разработчик: glebushka98.Если , то ответом является сумма k минимальных элементов. Пусть i1 < i2 <  ...  < ik — индексы элементов, которые войдут в итоге в ответ. Заметим, что относительный порядок выбранных элементов менять не имеет смысла, а значит, мы можем однозначно сказать, какой из выбранных элементов займёт какую позицию в ответе. T — минимальное количество операций, за которое их можно поставить на k первых мест. — .T ≤ S  ≤  . . Посчитаем динамику d[i][j][p] — минимально возможная сумма, если среди первых i элементов выбрать j с суммой индексов не больше p. В целях оптимизации использования памяти будем хранить каждый раз только два верхних уровня динамики.Итоговая сложность решения: O(n4) по времени и O(n3) по памяти.Примеры решений: 13845513 и 13845571.Div. 1E (День рождения)Автор идеи: meshanya, разработчик: romanandreev.Задача естественно разбивается на две подзадачи: быстрое построение графа вложенности и нахождение максимального независимого множества в этом графе. Заметим сразу, что если строка s2 является подстрокой строки s1, а строка s3 является подстрокой строки s2, то s3 очевидно является подстрокой строки s1. Таким образом, граф вложений зададаёт частично упорядоченное множество.Для быстрого построения графа воспользуемся алгоритмом Ахо-Корасик. С помощью данной структуры мы построим все существенные рёбра графа, то есть такие рёбра , что не найдётся w, такого что и . Одним из возможных способов является: Построить структуру Ахо-Корасик; Для каждой вершины найти и запомнить ближайшую терминальную в суффиксном пути; Ещё раз скормить каждую строку автомату Ахо-Корасик, при этом каждый раз после добавления очередного символа требуется проводить ребро в ближайшую терминальную вершину в суффиксном пути; Кроме существенных рёбер, данный алгоритм возможно добавит ещё какие-то корректные рёбра, но это никак не влияет на результат работы следующего шага; Транзитивно замкнуть построенный граф. Для решение второй части данной задачи требует применить теорему Дилворта. Восстановление ответа следует из конструктивного доказательства теоремы. Получаем O(L + n3) на построение графа + O(n3) на нахождение максимальной антицепи, итоговая сложность решения: O(L + n3), где L — суммарная длина всех строк.Поздравляем ikatanic — единственного человека сдавшего эту задачу во время тура. Для дальнейшего уточнения решения предлагается посмотреть 13851141.Упражнение: научитесь решать задачу с сохранением асимптотики, при условии что требуется найти множество строк максимальное не по размеру, а по суммарной длине.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21203",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 9801
        }
      ],
      "code_examples": [
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 1",
          "code": "3 3\n1.2\n1.2\n333",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 2",
          "code": "3 3\n1.2\n1.2\n333",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 3",
          "code": "3 3\n1..\n..2\n3..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 4",
          "code": "3 3\n1..\n..2\n3..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 5",
          "code": "segs = re.findall('(.*?)(0{2,}|1{2,})', s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 6",
          "code": "segs = re.findall('(.*?)(0{2,}|1{2,})', s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 7",
          "code": "110010101110100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 8",
          "code": "[('', '11'), ('', '00'), ('1010', '111'), ('01', '00')]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 9",
          "code": "\"1 - NUMBER_1, NUMBER_1\"+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 10",
          "code": "\"NUMBER_1,NUMBER_1\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 11",
          "code": "\"NUMBER_1\" * (length_of_repetition / 2) + \"NUMBER_2\" * (length_of_repetition / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 12",
          "code": "int main()\n{\n\n\tchar x, y;\n\tscanf(\"%c%c\", &x, &y); //вбиваем \"2 3\"\n\tcout << x << ' ' << y << endl; // получаем на вывод \"2 \"\n\tcin >> x >> y; // вбиваем \"2 3\"\n\tcout << x << ' ' << y << endl; получаем на вывод \"3 2\", ибо \"3\" осталось с предыдущего ввода\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 13",
          "code": "int main()\n{\n\n\tchar x, y;\n\tscanf(\"%c%c\", &x, &y); //вбиваем \"2 3\"\n\tcout << x << ' ' << y << endl; // получаем на вывод \"2 \"\n\tcin >> x >> y; // вбиваем \"2 3\"\n\tcout << x << ' ' << y << endl; получаем на вывод \"3 2\", ибо \"3\" осталось с предыдущего ввода\n\treturn 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 14",
          "code": "scanf(\" %c %c\", &x, &y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 15",
          "code": "scanf(\" %c %c\", &x, &y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 16",
          "code": "scanf(\"%d %d\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 17",
          "code": "char x[2], y[2];\nscanf(\"%s%s\", x, y);\ncout << x[0] << ' ' << y[0] << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 18",
          "code": "char x[2], y[2];\nscanf(\"%s%s\", x, y);\ncout << x[0] << ' ' << y[0] << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 19",
          "code": "contestant.delta = (contestant.needRating - contestant.rating) / 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 20",
          "code": "contestant.delta = (contestant.needRating - contestant.rating) / 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 21",
          "code": "UPD4: ............ Congratulations to Div. 1 top-5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 22",
          "code": "UPD4: ............ Congratulations to Div. 1 top-5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 23",
          "code": "sleep(10 * 60 * 60 * 1000); //10 hours\nupdate_ratings();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "Новый координатор представляет Codeforces Round #327 - Codeforces - Code 24",
          "code": "sleep(10 * 60 * 60 * 1000); //10 hours\nupdate_ratings();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 500000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 500000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 500000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    double noise_level = opt<double>(\"noise\", 0.0);\n    int pattern_length = opt<int>(\"pattern_length\", 1);\n\n    // Build sequence according to type\n    vector<int> a(n);\n\n    if (type == \"all_zero\") {\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"all_one\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = i % 2;\n        }\n    } else if (type == \"noisy_alternating\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = i % 2;\n            if (rnd.next(1.0) < noise_level) {\n                a[i] = 1 - a[i]; // Flip bit\n            }\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(2); // Random 0 or 1\n        }\n    } else if (type == \"pattern\") {\n        if (pattern_length <= 0) pattern_length = 1;\n        vector<int> pattern(pattern_length);\n        // Generate random pattern\n        for (int i = 0; i < pattern_length; ++i) {\n            pattern[i] = rnd.next(2);\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = pattern[i % pattern_length];\n        }\n\n    } else if (type == \"worst\") {\n        // Generate a sequence that could take many steps to stabilize\n        // Construct a sequence with a large block of ones in the middle\n        int ones_length = n / 2;\n        for (int i = 0; i < n; ++i) {\n            if (i >= (n - ones_length) / 2 && i < (n + ones_length) / 2) {\n                a[i] = 1;\n            } else {\n                a[i] = 0;\n            }\n        }\n    } else if (type == \"palindrome\") {\n        for (int i = 0; i <= n/2; ++i) {\n            a[i] = a[n - i - 1] = rnd.next(2);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(2);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the sequence\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n -1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    double noise_level = opt<double>(\"noise\", 0.0);\n    int pattern_length = opt<int>(\"pattern_length\", 1);\n\n    // Build sequence according to type\n    vector<int> a(n);\n\n    if (type == \"all_zero\") {\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"all_one\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = i % 2;\n        }\n    } else if (type == \"noisy_alternating\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = i % 2;\n            if (rnd.next(1.0) < noise_level) {\n                a[i] = 1 - a[i]; // Flip bit\n            }\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(2); // Random 0 or 1\n        }\n    } else if (type == \"pattern\") {\n        if (pattern_length <= 0) pattern_length = 1;\n        vector<int> pattern(pattern_length);\n        // Generate random pattern\n        for (int i = 0; i < pattern_length; ++i) {\n            pattern[i] = rnd.next(2);\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = pattern[i % pattern_length];\n        }\n\n    } else if (type == \"worst\") {\n        // Generate a sequence that could take many steps to stabilize\n        // Construct a sequence with a large block of ones in the middle\n        int ones_length = n / 2;\n        for (int i = 0; i < n; ++i) {\n            if (i >= (n - ones_length) / 2 && i < (n + ones_length) / 2) {\n                a[i] = 1;\n            } else {\n                a[i] = 0;\n            }\n        }\n    } else if (type == \"palindrome\") {\n        for (int i = 0; i <= n/2; ++i) {\n            a[i] = a[n - i - 1] = rnd.next(2);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(2);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the sequence\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n -1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type all_zero\n./gen -n 3 -type all_one\n./gen -n 3 -type alternating\n./gen -n 3 -type random\n\n./gen -n 10 -type all_zero\n./gen -n 10 -type all_one\n./gen -n 10 -type alternating\n./gen -n 10 -type random\n\n./gen -n 50 -type pattern -pattern_length 5\n./gen -n 50 -type palindrome\n\n./gen -n 100 -type all_zero\n./gen -n 100 -type all_one\n./gen -n 100 -type alternating\n./gen -n 100 -type random\n\n./gen -n 500 -type pattern -pattern_length 7\n./gen -n 500 -type noisy_alternating -noise 0.1\n\n./gen -n 1000 -type palindrome\n./gen -n 1000 -type noisy_alternating -noise 0.05\n\n./gen -n 5000 -type pattern -pattern_length 123\n\n./gen -n 10000 -type random\n\n./gen -n 10000 -type worst\n\n./gen -n 20000 -type noisy_alternating -noise 0.2\n\n./gen -n 50000 -type pattern -pattern_length 1000\n\n./gen -n 100000 -type random\n\n./gen -n 100000 -type palindrome\n\n./gen -n 100000 -type worst\n\n./gen -n 250000 -type noisy_alternating -noise 0.01\n\n./gen -n 500000 -type all_zero\n\n./gen -n 500000 -type all_one\n\n./gen -n 500000 -type alternating\n\n./gen -n 500000 -type random\n\n./gen -n 500000 -type worst\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:39.140349",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "591/D",
      "title": "D. Chip 'n Dale Rescue Rangers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains four integers x1, y1, x2, y2 (|x1|,  |y1|,  |x2|,  |y2| ≤ 10 000) — the coordinates of the rescuers' headquarters and the point, where signal of the distress came from, respectively. The second line contains two integers  and t (0 < v, t ≤ 1000), which are denoting the maximum speed of the chipmunk dirigible relative to the air and the moment of time when the wind changes according to the weather forecast, respectively. Next follow one per line two pairs of integer (vx, vy) and (wx, wy), describing the wind for the first t seconds and the wind that will blow at all the remaining time, respectively. It is guaranteed that  and .",
      "output_spec": "OutputPrint a single real value — the minimum time the rescuers need to get to point (x2, y2). You answer will be considered correct if its absolute or relative error does not exceed 10 - 6. Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .",
      "sample_tests": "ExamplesInputCopy0 0 5 53 2-1 -1-1 0OutputCopy3.729935587093555327InputCopy0 0 0 1000100 1000-50 050 0OutputCopy11.547005383792516398",
      "description": "D. Chip 'n Dale Rescue Rangers\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains four integers x1, y1, x2, y2 (|x1|,  |y1|,  |x2|,  |y2| ≤ 10 000) — the coordinates of the rescuers' headquarters and the point, where signal of the distress came from, respectively. The second line contains two integers  and t (0 < v, t ≤ 1000), which are denoting the maximum speed of the chipmunk dirigible relative to the air and the moment of time when the wind changes according to the weather forecast, respectively. Next follow one per line two pairs of integer (vx, vy) and (wx, wy), describing the wind for the first t seconds and the wind that will blow at all the remaining time, respectively. It is guaranteed that  and .\n\nOutputPrint a single real value — the minimum time the rescuers need to get to point (x2, y2). You answer will be considered correct if its absolute or relative error does not exceed 10 - 6. Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .\n\nInputCopy0 0 5 53 2-1 -1-1 0OutputCopy3.729935587093555327InputCopy0 0 0 1000100 1000-50 050 0OutputCopy11.547005383792516398\n\nInputCopy0 0 5 53 2-1 -1-1 0\n\nOutputCopy3.729935587093555327\n\nInputCopy0 0 0 1000100 1000-50 050 0\n\nOutputCopy11.547005383792516398",
      "solutions": [
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces",
          "content": "Hello, dear participants of Codeforces community!Starting from Codeforces Round #327 I'll be the new coordinator and will manage preparation process for all regular Codeforces rounds and other contests held on this platform. I'll do my best to increase the quality of contests we offer you, though Zlobober already raised this bar high. Let's cheer him once again, for all the great job he had done!Tomorrow round will be held using the problems of Moscow team olympiad for high-school students. Do not be tricked by the word \"school\" — there will be a gold medalist of IOI 2015 participating and some candidates to this year Russian IOI team, meaning the level of the problems will be appropriate. I am sure everyone will find an interesting problem to enjoy.The problemset was prepared by the team of Moscow authors (list is incomplete): Zlobober, romanandreev, meshanya, wilwell, glebushka98, timgaripov, thefacetakt, haku, LHiC, Timus, Sender, sankear, iskhakovt, andrewgark, ipavlov, StopKran, AleX leaded by your humble servant GlebsHP and the chairman of the jury Helen Andreeva.Special thanks to Delinur for translation and stella_marine for correction.Five problems will be offered in both divisions and the scoring distribution will be announced later (good traditions should live).UPD. Round time. Please note that Russia is not changing the timezone this night, while about 100 countries do so. Be sure to check when round starts in your timezone!UPD2. Please note, that the distribution motivates you to read all the problems! Div1.: 750-1000-1250-1750-2500 Div2.: 500-1000-1750-2000-2250UPD3. The results and the editorial will be published later, after the closing ceremony of the official competition.UPD4. The system testing is over, results are now final. Feel free to upsolve and read other contestants code. Congratulations to Div. 1 top-5: Endagorion JoeyWheeler sdya RAD -XraY- UPD5. Problem analysis is now available.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21185",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1940
        },
        {
          "title": "Codeforces Round #327 problems analysis - Codeforces",
          "content": "I like the idea of Endagorion to supplement the problems analysis with small challenges, somehow related to the problem preparation, it's generalization, or more effective solution. Following this, some problems in this analysis are also complemented with this sort of tasks.Div. 2A (Wizards' Duel)Idea of the problem: Roman Gusarev, development: timgaripov.Let's start with determining the position of the first collision. Two impulses converge with a speed p + q, so the first collision will occur after seconds. The coordinate of this collision is given by the formula .Note, that the distance one impulse passes while returning to it's caster is equal to the distance it has passed from the caster to the first collision. That means impulses will reach their casters simultaneously, and the situation will be identic to the beginning of the duel. Hence, the second collision (third, fourth, etc) will occur at exactly the same place as the first one.Code example: 13836780.Div. 2B (Rebranding)Idea of the problem: glebushka98, development: thefacetakt.Trivial solution will just emulate the work of all designers, every time considering all characters of the string one by one and replacing all xi with yi and vice versa. This will work in O(n·m) and get TL.First one should note that same characters always end as a same characters, meaning the position of the letter doesn't affect the result in any way. One should only remember the mapping for all distinct characters. Let p(i, c) be the mapping of c after i designers already finished their job. Now: p(0, c) = c If p(i - 1, c) = xi, then p(i, c) = yi Same, if p(i - 1, c) = yi, then p(i, c) = xi This solution complexity is O(|Σ|·m + n) and is enough to pass all the tests.Challenge: improve the complexity to O(Σ + n + m).Code examples: 13837577 implements O(|Σ|·m + n) and 13839154 stands for O(|Σ| + n + m).Div. 2C\\Div. 1A (Median Smoothing)Problem idea and development: Sender.We will call the element of a sequence stable, if it doesn't change after applying the algorithm of median smoothing for any number of times. Both ends are stable by the definition of the median smoothing. Also, it is easy to notice, that two equal consecutive elements are both stable.Now we should take a look at how do stable elements affect their neighbors. Suppose ai - 1 = ai, meaning i - 1 and i are stable. Additionaly assume, that ai + 1 is not a stable element, hence ai + 1 ≠ ai and ai + 1 ≠ ai + 2. Keeping in mind that only 0 and 1 values are possible, we conclude that ai = ai + 2 and applying a median smoothing algorithm to this sequence will result in ai = ai + 1. That means, if there is a stable element in position i, both i + 1 and i - 1 are guaranteed to be stable after one application of median smoothing. Now we can conclude, that all sequences will turn to stable at some point.Note, that if there are two stable elements i and j with no other stable elements located between them, the sequence of elements between them is alternating, i.e. ak = (ai + k - i)mod2, where . One can check, that stable elements may occur only at the ends of the alternating sequence, meaning the sequence will remain alternating until it will be killed by effect spreading from ending stable elements.The solution is: calculate max(min(|i - sj|)), where sj are the initial stable elements. Time complexity is O(n).Challenge 1: hack the solution that just applies median smoothing until something changes.Challenge 2: think of how to speed up the algorithm from challenge 1 using bitmasks (still gets TL).Code examples: 13838940 and 13838480.Div. 2D\\Div. 1B (Chip 'n Dale Rescue Rangers)Problem idea and development: StopKran.If the velocity of the dirigible relative to the air is given by the vector (ax, ay), while the velocity of the wind is (bx, by), the resulting velocity of the dirigible relative to the plane is (ax + bx, ay + by).The main idea here is that the answer function is monotonous. If the dirigible is able to reach to target in seconds, then it can do so in seconds, for any x ≥ 0. That is an obvious consequence from the fact the maximum self speed of the dirigible is strictly greater then the speed of the wind at any moment of time.For any monotonous function we can use binary search. Now we only need to check, if for some given value it's possible for the dirigible to reach the target in seconds. Let's separate the movement of the air and the movement of the dirigible in the air. The movement cause by the air is: (xn, yn) = , if ; (xn, yn) = , for . The only thing we need to check now is that the distance between the point (xn, yn) and the target coordinates (x2, y2) can be covered moving with the speed vmax in seconds assuming there is no wind.Time complexity is , where C stands for the maximum coordinate, аnd ε — desired accuracy.Challenge 1: think of the solution in case it's not guaranteed that the dirigible is faster than the wind.Challenge 2: can you come up with O(1) solution?Code examples: 13838659 and 13842505.Div. 2E\\Div. 1C (Three States)Problem idea and development: haku.Affirmation. Suppose we are given an undirected unweighted connected graph and three distinct chosen vertices u, v, w of this graph. We state that at least one minimum connecting network for these three vertices has the following form: some vertex c is chosen and the resulting network is obtained as a union of shortest paths from c to each of the chosen vertices.Proof. One of the optimal subgraphs connecting these three vertices is always a tree. Really, we can take any connecting subgraph and while there are cycles remaining in it, take any cycle and throw away any edge of this cycle. Moreover, only vertices u, v and w are allowed to be leaves of this tree, as we can delete from the network any other leaves and the network will still be connected. If the tree has no more than three leaves, it has no more than one vertex with the degree greater than 2. This vertex is c from the statement above. Any path from c to the leaves may obviously be replaced with the shortest path. Special case is than there is no node with the degree greater than 2, meaning one of u, v or w lies on the shortest path connecting two other vertices.The solution is: find the shortest path from each of the chosen vertices to all other vertices, and then try every vertex of the graph as c. Time complexity is O(|V| + |E|).To apply this solution to the given problem we should first build a graph, where cells of the table stand for the vertices and two vertices are connected by an edge, if the corresponding cells were neighboring. Now we should merge all vertices of a single state in one in order to obtain a task described in the beginning. Time complexity is a linear function of the size of the table .Code examples: 13843265 — the solution described above that uses 0-1 bfs instead of merging, 13840329 — another approach that tries to different cases.Div. 1D (Top Secret Task)Problem idea and development: glebushka98.If , than the sum of k minimums is obviously an answer. Let i1 < i2 <  ...  < ik be the indices of the elements that will form the answer. Note, that the relative order of the chosen subset will remain the same, as there is no reason to swap two elements that will both be included in the answer. The minimum number of operations required to place this k elements at the beginning is equal to — .T ≤ S  ≤  . . Calculate the dynamic programming d[i][j][p] &mdash minimum possible sum, if we chose j elements among first i with the total indices sum no greater than p. In order to optimize the memory consumption we will keep in memory only two latest layers of the dp.Time complexity is O(n4), with O(n3) memory consumption.Code examples: 13845513 and 13845571.Div. 1E (Birthday)Problem idea: meshanya, development: romanandreev.The given problem actually consists of two separate problems: build the directed graph of substring relation and find the maximum independent set in it. Note, that if the string s2 is a substring of some string s1, while string s3 is a substring of the string s2, then s3 is a substring of s1. That means the graph of substring relation defines a partially ordered set.To build the graph one can use Aho-Corasick algorithm. Usage of this structure allow to build all essential arc of the graph in time O(L), where L stands for the total length of all strings in the input. We will call the arc essential, if there is no w, such that and . One of the ways to do so is: Build Aho-Corasick using all strings in the input; For every node of the Aho-Corasick structure find and remember the nearest terminal node in the suffix-link path; Once again traverse all strings through Aho-Corasick. Every time new symbol is added, add an arc from the node corresponding to the current string (in the graph we build, not Aho-Corasick) to the node of the graph corresponding to the nearest terminal in the suffix-link path; The previous step will build all essential arcs plus some other arcs, but they do not affect the next step in any way; Find the transitive closure of the graph. To solve the second part of the problem one should use the Dilworth theorem. The way to restore the answer subset comes from the constructive proof of the theorem.Time complexity is O(L + n3) to build the graph plus O(n3) to find the maximum antichain. The overall complexity is O(L + n3).Congratulation to ikatanic — — the only participant to solve this problem during the contest. View his code 13851141 for further clarifications.Challenge: solve the problem with the same asymptotic, if we are to find the subset with the maximum total length of all strings in it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21203",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9655
        }
      ],
      "code_examples": [
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 1",
          "code": "3 3\n1.2\n1.2\n333",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 2",
          "code": "3 3\n1.2\n1.2\n333",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 3",
          "code": "3 3\n1..\n..2\n3..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 4",
          "code": "3 3\n1..\n..2\n3..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 5",
          "code": "segs = re.findall('(.*?)(0{2,}|1{2,})', s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 6",
          "code": "segs = re.findall('(.*?)(0{2,}|1{2,})', s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 7",
          "code": "110010101110100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 8",
          "code": "[('', '11'), ('', '00'), ('1010', '111'), ('01', '00')]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 9",
          "code": "\"1 - NUMBER_1, NUMBER_1\"+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 10",
          "code": "\"NUMBER_1,NUMBER_1\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 11",
          "code": "\"NUMBER_1\" * (length_of_repetition / 2) + \"NUMBER_2\" * (length_of_repetition / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 12",
          "code": "UPD4: ............ Congratulations to Div. 1 top-5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 13",
          "code": "UPD4: ............ Congratulations to Div. 1 top-5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 14",
          "code": "sleep(10 * 60 * 60 * 1000); //10 hours\nupdate_ratings();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 15",
          "code": "sleep(10 * 60 * 60 * 1000); //10 hours\nupdate_ratings();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x1 = inf.readInt(-10000, 10000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-10000, 10000, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(-10000, 10000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-10000, 10000, \"y2\");\n    inf.readEoln();\n\n    int v = inf.readInt(1, 1000, \"v\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000, \"t\");\n    inf.readEoln();\n\n    long long vx = inf.readLong(-1000000000LL, 1000000000LL, \"vx\");\n    inf.readSpace();\n    long long vy = inf.readLong(-1000000000LL, 1000000000LL, \"vy\");\n    inf.readEoln();\n\n    // Check that sqrt(vx^2 + vy^2) < v\n    long long vsquare = vx*vx + vy*vy;\n    ensuref(vsquare < 1LL * v * v, \"Wind speed sqrt(vx^2 + vy^2) must be less than v. Wind speed squared is %lld, v squared is %lld\", vsquare, 1LL*v*v);\n\n    long long wx = inf.readLong(-1000000000LL, 1000000000LL, \"wx\");\n    inf.readSpace();\n    long long wy = inf.readLong(-1000000000LL, 1000000000LL, \"wy\");\n    inf.readEoln();\n\n    // Check that sqrt(wx^2 + wy^2) < v\n    vsquare = wx*wx + wy*wy;\n    ensuref(vsquare < 1LL * v * v, \"Wind speed sqrt(wx^2 + wy^2) must be less than v. Wind speed squared is %lld, v squared is %lld\", vsquare, 1LL*v*v);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x1 = inf.readInt(-10000, 10000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-10000, 10000, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(-10000, 10000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-10000, 10000, \"y2\");\n    inf.readEoln();\n\n    int v = inf.readInt(1, 1000, \"v\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000, \"t\");\n    inf.readEoln();\n\n    long long vx = inf.readLong(-1000000000LL, 1000000000LL, \"vx\");\n    inf.readSpace();\n    long long vy = inf.readLong(-1000000000LL, 1000000000LL, \"vy\");\n    inf.readEoln();\n\n    // Check that sqrt(vx^2 + vy^2) < v\n    long long vsquare = vx*vx + vy*vy;\n    ensuref(vsquare < 1LL * v * v, \"Wind speed sqrt(vx^2 + vy^2) must be less than v. Wind speed squared is %lld, v squared is %lld\", vsquare, 1LL*v*v);\n\n    long long wx = inf.readLong(-1000000000LL, 1000000000LL, \"wx\");\n    inf.readSpace();\n    long long wy = inf.readLong(-1000000000LL, 1000000000LL, \"wy\");\n    inf.readEoln();\n\n    // Check that sqrt(wx^2 + wy^2) < v\n    vsquare = wx*wx + wy*wy;\n    ensuref(vsquare < 1LL * v * v, \"Wind speed sqrt(wx^2 + wy^2) must be less than v. Wind speed squared is %lld, v squared is %lld\", vsquare, 1LL*v*v);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int x1 = inf.readInt(-10000, 10000, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(-10000, 10000, \"y1\");\n    inf.readSpace();\n    int x2 = inf.readInt(-10000, 10000, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(-10000, 10000, \"y2\");\n    inf.readEoln();\n\n    int v = inf.readInt(1, 1000, \"v\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000, \"t\");\n    inf.readEoln();\n\n    long long vx = inf.readLong(-1000000000LL, 1000000000LL, \"vx\");\n    inf.readSpace();\n    long long vy = inf.readLong(-1000000000LL, 1000000000LL, \"vy\");\n    inf.readEoln();\n\n    // Check that sqrt(vx^2 + vy^2) < v\n    long long vsquare = vx*vx + vy*vy;\n    ensuref(vsquare < 1LL * v * v, \"Wind speed sqrt(vx^2 + vy^2) must be less than v. Wind speed squared is %lld, v squared is %lld\", vsquare, 1LL*v*v);\n\n    long long wx = inf.readLong(-1000000000LL, 1000000000LL, \"wx\");\n    inf.readSpace();\n    long long wy = inf.readLong(-1000000000LL, 1000000000LL, \"wy\");\n    inf.readEoln();\n\n    // Check that sqrt(wx^2 + wy^2) < v\n    vsquare = wx*wx + wy*wy;\n    ensuref(vsquare < 1LL * v * v, \"Wind speed sqrt(wx^2 + wy^2) must be less than v. Wind speed squared is %lld, v squared is %lld\", vsquare, 1LL*v*v);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    string type = opt<string>(\"type\");\n    int max_coord = opt<int>(\"max_coord\", 10000);\n    int v_inp = opt<int>(\"v\", 0);\n    int t_inp = opt<int>(\"t\", 0);\n\n    int x1, y1, x2, y2;\n    int v, t;\n    int vx, vy, wx, wy;\n\n    if (type == \"max_coords\") {\n        x1 = max_coord * (rnd.next(2) * 2 - 1);\n        y1 = max_coord * (rnd.next(2) * 2 - 1);\n        x2 = max_coord * (rnd.next(2) * 2 - 1);\n        y2 = max_coord * (rnd.next(2) * 2 - 1);\n\n        v = v_inp > 0 ? v_inp : 1000;\n        t = t_inp > 0 ? t_inp : rnd.next(1, 1000);\n\n        vx = vy = wx = wy = 0;\n    } else if (type == \"zero_wind\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n        t = t_inp > 0 ? t_inp : rnd.next(1, 1000);\n\n        vx = vy = wx = wy = 0;\n    } else if (type == \"max_wind\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n        t = t_inp > 0 ? t_inp : rnd.next(1, 1000);\n\n        double wind_speed = v * 0.999999;\n        double angle = rnd.next(0.0, 2.0 * M_PI);\n        vx = (int)(wind_speed * cos(angle));\n        vy = (int)(wind_speed * sin(angle));\n\n        while (sqrt(vx * vx + vy * vy) >= v) {\n            angle = rnd.next(0.0, 2.0 * M_PI);\n            vx = (int)(wind_speed * cos(angle));\n            vy = (int)(wind_speed * sin(angle));\n        }\n\n        angle = rnd.next(0.0, 2.0 * M_PI);\n        wx = (int)(wind_speed * cos(angle));\n        wy = (int)(wind_speed * sin(angle));\n\n        while (sqrt(wx * wx + wy * wy) >= v) {\n            angle = rnd.next(0.0, 2.0 * M_PI);\n            wx = (int)(wind_speed * cos(angle));\n            wy = (int)(wind_speed * sin(angle));\n        }\n    } else if (type == \"wind_help\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n\n        int dx = x2 - x1;\n        int dy = y2 - y1;\n        double dist = sqrt(dx * dx + dy * dy);\n\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n        t = t_inp > 0 ? t_inp : rnd.next(1, 1000);\n\n        double wind_speed = v * 0.9999;\n        double dir_x = dx / dist;\n        double dir_y = dy / dist;\n\n        vx = (int)(wind_speed * dir_x);\n        vy = (int)(wind_speed * dir_y);\n\n        while (sqrt(vx*vx + vy*vy) >= v) {\n            wind_speed *= 0.999;\n            vx = (int)(wind_speed * dir_x);\n            vy = (int)(wind_speed * dir_y);\n        }\n\n        wx = wy = 0;\n    } else if (type == \"wind_hinder\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n\n        int dx = x2 - x1;\n        int dy = y2 - y1;\n        double dist = sqrt(dx * dx + dy * dy);\n\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n        t = t_inp > 0 ? t_inp : rnd.next(1, 1000);\n\n        double wind_speed = v * 0.9999;\n        double dir_x = -dx / dist;\n        double dir_y = -dy / dist;\n\n        vx = (int)(wind_speed * dir_x);\n        vy = (int)(wind_speed * dir_y);\n\n        while (sqrt(vx*vx + vy*vy) >= v) {\n            wind_speed *= 0.999;\n            vx = (int)(wind_speed * dir_x);\n            vy = (int)(wind_speed * dir_y);\n        }\n\n        wx = wy = 0;\n    } else if (type == \"wind_change\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n        t = t_inp > 0 ? t_inp : rnd.next(1, 1000);\n\n        int dx = x2 - x1;\n        int dy = y2 - y1;\n        double dist = sqrt(dx * dx + dy * dy);\n\n        double wind_speed = v * 0.9999;\n        double dir_x = dx / dist;\n        double dir_y = dy / dist;\n\n        vx = (int)(wind_speed * dir_x);\n        vy = (int)(wind_speed * dir_y);\n\n        wx = (int)(-wind_speed * dir_x);\n        wy = (int)(-wind_speed * dir_y);\n\n        while (sqrt(vx*vx + vy*vy) >= v || sqrt(wx*wx + wy*wy) >= v) {\n            wind_speed *= 0.999;\n            vx = (int)(wind_speed * dir_x);\n            vy = (int)(wind_speed * dir_y);\n            wx = (int)(-wind_speed * dir_x);\n            wy = (int)(-wind_speed * dir_y);\n        }\n\n    } else if (type == \"t_zero\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n\n        t = 0;\n\n        double wind_speed = v * 0.5;\n        double angle = rnd.next(0.0, 2.0 * M_PI);\n        vx = (int)(wind_speed * cos(angle));\n        vy = (int)(wind_speed * sin(angle));\n\n        angle = rnd.next(0.0, 2.0 * M_PI);\n        wx = (int)(wind_speed * cos(angle));\n        wy = (int)(wind_speed * sin(angle));\n\n        while (sqrt(vx*vx + vy*vy) >= v || sqrt(wx*wx + wy*wy) >= v) {\n            wind_speed *= 0.999;\n            angle = rnd.next(0.0, 2.0 * M_PI);\n            vx = (int)(wind_speed * cos(angle));\n            vy = (int)(wind_speed * sin(angle));\n\n            angle = rnd.next(0.0, 2.0 * M_PI);\n            wx = (int)(wind_speed * cos(angle));\n            wy = (int)(wind_speed * sin(angle));\n        }\n    } else if (type == \"t_max\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n\n        t = 1000;\n\n        double wind_speed = v * 0.5;\n        double angle = rnd.next(0.0, 2.0 * M_PI);\n        vx = (int)(wind_speed * cos(angle));\n        vy = (int)(wind_speed * sin(angle));\n\n        angle = rnd.next(0.0, 2.0 * M_PI);\n        wx = (int)(wind_speed * cos(angle));\n        wy = (int)(wind_speed * sin(angle));\n\n        while (sqrt(vx*vx + vy*vy) >= v || sqrt(wx*wx + wy*wy) >= v) {\n            wind_speed *= 0.999;\n            angle = rnd.next(0.0, 2.0 * M_PI);\n            vx = (int)(wind_speed * cos(angle));\n            vy = (int)(wind_speed * sin(angle));\n\n            angle = rnd.next(0.0, 2.0 * M_PI);\n            wx = (int)(wind_speed * cos(angle));\n            wy = (int)(wind_speed * sin(angle));\n        }\n    } else if (type == \"same_point\") {\n        x1 = x2 = rnd.next(-max_coord, max_coord);\n        y1 = y2 = rnd.next(-max_coord, max_coord);\n\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n        t = t_inp > 0 ? t_inp : 1;\n\n        vx = vy = wx = wy = 0;\n    } else if (type == \"axis_movement\") {\n        bool move_along_x = rnd.next(2);\n        if (move_along_x) {\n            x1 = rnd.next(-max_coord, max_coord);\n            x2 = rnd.next(-max_coord, max_coord);\n            y1 = y2 = rnd.next(-max_coord, max_coord);\n        } else {\n            y1 = rnd.next(-max_coord, max_coord);\n            y2 = rnd.next(-max_coord, max_coord);\n            x1 = x2 = rnd.next(-max_coord, max_coord);\n        }\n\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n        t = t_inp > 0 ? t_inp : rnd.next(1, 1000);\n\n        vx = vy = wx = wy = 0;\n    } else {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n        t = t_inp > 0 ? t_inp : rnd.next(1, 1000);\n\n        double wind_speed = v * rnd.next(0.0, 0.99);\n        double angle = rnd.next(0.0, 2.0 * M_PI);\n        vx = (int)(wind_speed * cos(angle));\n        vy = (int)(wind_speed * sin(angle));\n\n        wind_speed = v * rnd.next(0.0, 0.99);\n        angle = rnd.next(0.0, 2.0 * M_PI);\n        wx = (int)(wind_speed * cos(angle));\n        wy = (int)(wind_speed * sin(angle));\n\n        while (sqrt(vx*vx + vy*vy) >= v || sqrt(wx*wx + wy*wy) >= v) {\n            wind_speed *= 0.99;\n            vx = (int)(wind_speed * cos(angle));\n            vy = (int)(wind_speed * sin(angle));\n\n            wind_speed *= 0.99;\n            wx = (int)(wind_speed * cos(angle));\n            wy = (int)(wind_speed * sin(angle));\n        }\n    }\n\n    printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n    printf(\"%d %d\\n\", v, t);\n    printf(\"%d %d\\n\", vx, vy);\n    printf(\"%d %d\\n\", wx, wy);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    string type = opt<string>(\"type\");\n    int max_coord = opt<int>(\"max_coord\", 10000);\n    int v_inp = opt<int>(\"v\", 0);\n    int t_inp = opt<int>(\"t\", 0);\n\n    int x1, y1, x2, y2;\n    int v, t;\n    int vx, vy, wx, wy;\n\n    if (type == \"max_coords\") {\n        x1 = max_coord * (rnd.next(2) * 2 - 1);\n        y1 = max_coord * (rnd.next(2) * 2 - 1);\n        x2 = max_coord * (rnd.next(2) * 2 - 1);\n        y2 = max_coord * (rnd.next(2) * 2 - 1);\n\n        v = v_inp > 0 ? v_inp : 1000;\n        t = t_inp > 0 ? t_inp : rnd.next(1, 1000);\n\n        vx = vy = wx = wy = 0;\n    } else if (type == \"zero_wind\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n        t = t_inp > 0 ? t_inp : rnd.next(1, 1000);\n\n        vx = vy = wx = wy = 0;\n    } else if (type == \"max_wind\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n        t = t_inp > 0 ? t_inp : rnd.next(1, 1000);\n\n        double wind_speed = v * 0.999999;\n        double angle = rnd.next(0.0, 2.0 * M_PI);\n        vx = (int)(wind_speed * cos(angle));\n        vy = (int)(wind_speed * sin(angle));\n\n        while (sqrt(vx * vx + vy * vy) >= v) {\n            angle = rnd.next(0.0, 2.0 * M_PI);\n            vx = (int)(wind_speed * cos(angle));\n            vy = (int)(wind_speed * sin(angle));\n        }\n\n        angle = rnd.next(0.0, 2.0 * M_PI);\n        wx = (int)(wind_speed * cos(angle));\n        wy = (int)(wind_speed * sin(angle));\n\n        while (sqrt(wx * wx + wy * wy) >= v) {\n            angle = rnd.next(0.0, 2.0 * M_PI);\n            wx = (int)(wind_speed * cos(angle));\n            wy = (int)(wind_speed * sin(angle));\n        }\n    } else if (type == \"wind_help\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n\n        int dx = x2 - x1;\n        int dy = y2 - y1;\n        double dist = sqrt(dx * dx + dy * dy);\n\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n        t = t_inp > 0 ? t_inp : rnd.next(1, 1000);\n\n        double wind_speed = v * 0.9999;\n        double dir_x = dx / dist;\n        double dir_y = dy / dist;\n\n        vx = (int)(wind_speed * dir_x);\n        vy = (int)(wind_speed * dir_y);\n\n        while (sqrt(vx*vx + vy*vy) >= v) {\n            wind_speed *= 0.999;\n            vx = (int)(wind_speed * dir_x);\n            vy = (int)(wind_speed * dir_y);\n        }\n\n        wx = wy = 0;\n    } else if (type == \"wind_hinder\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n\n        int dx = x2 - x1;\n        int dy = y2 - y1;\n        double dist = sqrt(dx * dx + dy * dy);\n\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n        t = t_inp > 0 ? t_inp : rnd.next(1, 1000);\n\n        double wind_speed = v * 0.9999;\n        double dir_x = -dx / dist;\n        double dir_y = -dy / dist;\n\n        vx = (int)(wind_speed * dir_x);\n        vy = (int)(wind_speed * dir_y);\n\n        while (sqrt(vx*vx + vy*vy) >= v) {\n            wind_speed *= 0.999;\n            vx = (int)(wind_speed * dir_x);\n            vy = (int)(wind_speed * dir_y);\n        }\n\n        wx = wy = 0;\n    } else if (type == \"wind_change\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n        t = t_inp > 0 ? t_inp : rnd.next(1, 1000);\n\n        int dx = x2 - x1;\n        int dy = y2 - y1;\n        double dist = sqrt(dx * dx + dy * dy);\n\n        double wind_speed = v * 0.9999;\n        double dir_x = dx / dist;\n        double dir_y = dy / dist;\n\n        vx = (int)(wind_speed * dir_x);\n        vy = (int)(wind_speed * dir_y);\n\n        wx = (int)(-wind_speed * dir_x);\n        wy = (int)(-wind_speed * dir_y);\n\n        while (sqrt(vx*vx + vy*vy) >= v || sqrt(wx*wx + wy*wy) >= v) {\n            wind_speed *= 0.999;\n            vx = (int)(wind_speed * dir_x);\n            vy = (int)(wind_speed * dir_y);\n            wx = (int)(-wind_speed * dir_x);\n            wy = (int)(-wind_speed * dir_y);\n        }\n\n    } else if (type == \"t_zero\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n\n        t = 0;\n\n        double wind_speed = v * 0.5;\n        double angle = rnd.next(0.0, 2.0 * M_PI);\n        vx = (int)(wind_speed * cos(angle));\n        vy = (int)(wind_speed * sin(angle));\n\n        angle = rnd.next(0.0, 2.0 * M_PI);\n        wx = (int)(wind_speed * cos(angle));\n        wy = (int)(wind_speed * sin(angle));\n\n        while (sqrt(vx*vx + vy*vy) >= v || sqrt(wx*wx + wy*wy) >= v) {\n            wind_speed *= 0.999;\n            angle = rnd.next(0.0, 2.0 * M_PI);\n            vx = (int)(wind_speed * cos(angle));\n            vy = (int)(wind_speed * sin(angle));\n\n            angle = rnd.next(0.0, 2.0 * M_PI);\n            wx = (int)(wind_speed * cos(angle));\n            wy = (int)(wind_speed * sin(angle));\n        }\n    } else if (type == \"t_max\") {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n\n        t = 1000;\n\n        double wind_speed = v * 0.5;\n        double angle = rnd.next(0.0, 2.0 * M_PI);\n        vx = (int)(wind_speed * cos(angle));\n        vy = (int)(wind_speed * sin(angle));\n\n        angle = rnd.next(0.0, 2.0 * M_PI);\n        wx = (int)(wind_speed * cos(angle));\n        wy = (int)(wind_speed * sin(angle));\n\n        while (sqrt(vx*vx + vy*vy) >= v || sqrt(wx*wx + wy*wy) >= v) {\n            wind_speed *= 0.999;\n            angle = rnd.next(0.0, 2.0 * M_PI);\n            vx = (int)(wind_speed * cos(angle));\n            vy = (int)(wind_speed * sin(angle));\n\n            angle = rnd.next(0.0, 2.0 * M_PI);\n            wx = (int)(wind_speed * cos(angle));\n            wy = (int)(wind_speed * sin(angle));\n        }\n    } else if (type == \"same_point\") {\n        x1 = x2 = rnd.next(-max_coord, max_coord);\n        y1 = y2 = rnd.next(-max_coord, max_coord);\n\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n        t = t_inp > 0 ? t_inp : 1;\n\n        vx = vy = wx = wy = 0;\n    } else if (type == \"axis_movement\") {\n        bool move_along_x = rnd.next(2);\n        if (move_along_x) {\n            x1 = rnd.next(-max_coord, max_coord);\n            x2 = rnd.next(-max_coord, max_coord);\n            y1 = y2 = rnd.next(-max_coord, max_coord);\n        } else {\n            y1 = rnd.next(-max_coord, max_coord);\n            y2 = rnd.next(-max_coord, max_coord);\n            x1 = x2 = rnd.next(-max_coord, max_coord);\n        }\n\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n        t = t_inp > 0 ? t_inp : rnd.next(1, 1000);\n\n        vx = vy = wx = wy = 0;\n    } else {\n        x1 = rnd.next(-max_coord, max_coord);\n        y1 = rnd.next(-max_coord, max_coord);\n        x2 = rnd.next(-max_coord, max_coord);\n        y2 = rnd.next(-max_coord, max_coord);\n        v = v_inp > 0 ? v_inp : rnd.next(1, 1000);\n        t = t_inp > 0 ? t_inp : rnd.next(1, 1000);\n\n        double wind_speed = v * rnd.next(0.0, 0.99);\n        double angle = rnd.next(0.0, 2.0 * M_PI);\n        vx = (int)(wind_speed * cos(angle));\n        vy = (int)(wind_speed * sin(angle));\n\n        wind_speed = v * rnd.next(0.0, 0.99);\n        angle = rnd.next(0.0, 2.0 * M_PI);\n        wx = (int)(wind_speed * cos(angle));\n        wy = (int)(wind_speed * sin(angle));\n\n        while (sqrt(vx*vx + vy*vy) >= v || sqrt(wx*wx + wy*wy) >= v) {\n            wind_speed *= 0.99;\n            vx = (int)(wind_speed * cos(angle));\n            vy = (int)(wind_speed * sin(angle));\n\n            wind_speed *= 0.99;\n            wx = (int)(wind_speed * cos(angle));\n            wy = (int)(wind_speed * sin(angle));\n        }\n    }\n\n    printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n    printf(\"%d %d\\n\", v, t);\n    printf(\"%d %d\\n\", vx, vy);\n    printf(\"%d %d\\n\", wx, wy);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Max coordinates\n./gen -type max_coords\n\n# Zero wind\n./gen -type zero_wind\n\n# Maximum wind speed\n./gen -type max_wind\n\n# Wind helps the airship\n./gen -type wind_help\n\n# Wind hinders the airship\n./gen -type wind_hinder\n\n# Wind changes direction at time t\n./gen -type wind_change\n\n# Wind changes immediately (t = 0)\n./gen -type t_zero\n\n# Wind changes at maximum time (t = 1000)\n./gen -type t_max\n\n# Start and end at the same point\n./gen -type same_point\n\n# Movement along the axis\n./gen -type axis_movement\n\n# Random test case\n./gen -type random\n\n# Max coordinates with specific v and t\n./gen -type max_coords -v 1000 -t 1000\n\n# Zero wind with v = 500\n./gen -type zero_wind -v 500\n\n# Maximum wind with v = 1000 and t = 500\n./gen -type max_wind -v 1000 -t 500\n\n# Wind helps with specific v and t\n./gen -type wind_help -v 700 -t 200\n\n# Wind hinders with specific v and t\n./gen -type wind_hinder -v 800 -t 300\n\n# Wind changes direction at t = 1\n./gen -type wind_change -t 1\n\n# Wind changes direction at t = 999\n./gen -type wind_change -t 999\n\n# Start and end at the same point with v = 1\n./gen -type same_point -v 1\n\n# Movement along x-axis\n./gen -type axis_movement\n\n# Movement along y-axis\n./gen -type axis_movement\n\n# Random test cases for variety\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Wind changes at t = 0 with specific v\n./gen -type t_zero -v 600\n\n# Wind changes at max t with specific v\n./gen -type t_max -v 900\n\n# Max wind with minimal wind speed\n./gen -type max_wind -v 2\n\n# Wind helps with maximum wind speed\n./gen -type wind_help -v 1000\n\n# Wind hinders with maximum wind speed\n./gen -type wind_hinder -v 1000\n\n# Additional random test cases\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:41.455847",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "591/E",
      "title": "E. Three States",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line of the input contains the dimensions of the map n and m (1 ≤ n, m ≤ 1000) — the number of rows and columns respectively.Each of the next n lines contain m characters, describing the rows of the map. Digits from 1 to 3 represent the accessory to the corresponding state. The character '.' corresponds to the cell where it is allowed to build a road and the character '#' means no construction is allowed in this cell.",
      "output_spec": "OutputPrint a single integer — the minimum number of cells you need to build a road inside in order to connect all the cells of all states. If such a goal is unachievable, print -1.",
      "sample_tests": "ExamplesInputCopy4 511..2#..22#.323.#333OutputCopy2InputCopy1 51#2#3OutputCopy-1",
      "description": "E. Three States\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains the dimensions of the map n and m (1 ≤ n, m ≤ 1000) — the number of rows and columns respectively.Each of the next n lines contain m characters, describing the rows of the map. Digits from 1 to 3 represent the accessory to the corresponding state. The character '.' corresponds to the cell where it is allowed to build a road and the character '#' means no construction is allowed in this cell.\n\nOutputPrint a single integer — the minimum number of cells you need to build a road inside in order to connect all the cells of all states. If such a goal is unachievable, print -1.\n\nInputCopy4 511..2#..22#.323.#333OutputCopy2InputCopy1 51#2#3OutputCopy-1\n\nInputCopy4 511..2#..22#.323.#333\n\nOutputCopy2\n\nInputCopy1 51#2#3\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces",
          "content": "Hello, dear participants of Codeforces community!Starting from Codeforces Round #327 I'll be the new coordinator and will manage preparation process for all regular Codeforces rounds and other contests held on this platform. I'll do my best to increase the quality of contests we offer you, though Zlobober already raised this bar high. Let's cheer him once again, for all the great job he had done!Tomorrow round will be held using the problems of Moscow team olympiad for high-school students. Do not be tricked by the word \"school\" — there will be a gold medalist of IOI 2015 participating and some candidates to this year Russian IOI team, meaning the level of the problems will be appropriate. I am sure everyone will find an interesting problem to enjoy.The problemset was prepared by the team of Moscow authors (list is incomplete): Zlobober, romanandreev, meshanya, wilwell, glebushka98, timgaripov, thefacetakt, haku, LHiC, Timus, Sender, sankear, iskhakovt, andrewgark, ipavlov, StopKran, AleX leaded by your humble servant GlebsHP and the chairman of the jury Helen Andreeva.Special thanks to Delinur for translation and stella_marine for correction.Five problems will be offered in both divisions and the scoring distribution will be announced later (good traditions should live).UPD. Round time. Please note that Russia is not changing the timezone this night, while about 100 countries do so. Be sure to check when round starts in your timezone!UPD2. Please note, that the distribution motivates you to read all the problems! Div1.: 750-1000-1250-1750-2500 Div2.: 500-1000-1750-2000-2250UPD3. The results and the editorial will be published later, after the closing ceremony of the official competition.UPD4. The system testing is over, results are now final. Feel free to upsolve and read other contestants code. Congratulations to Div. 1 top-5: Endagorion JoeyWheeler sdya RAD -XraY- UPD5. Problem analysis is now available.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21185",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1940
        },
        {
          "title": "Codeforces Round #327 problems analysis - Codeforces",
          "content": "I like the idea of Endagorion to supplement the problems analysis with small challenges, somehow related to the problem preparation, it's generalization, or more effective solution. Following this, some problems in this analysis are also complemented with this sort of tasks.Div. 2A (Wizards' Duel)Idea of the problem: Roman Gusarev, development: timgaripov.Let's start with determining the position of the first collision. Two impulses converge with a speed p + q, so the first collision will occur after seconds. The coordinate of this collision is given by the formula .Note, that the distance one impulse passes while returning to it's caster is equal to the distance it has passed from the caster to the first collision. That means impulses will reach their casters simultaneously, and the situation will be identic to the beginning of the duel. Hence, the second collision (third, fourth, etc) will occur at exactly the same place as the first one.Code example: 13836780.Div. 2B (Rebranding)Idea of the problem: glebushka98, development: thefacetakt.Trivial solution will just emulate the work of all designers, every time considering all characters of the string one by one and replacing all xi with yi and vice versa. This will work in O(n·m) and get TL.First one should note that same characters always end as a same characters, meaning the position of the letter doesn't affect the result in any way. One should only remember the mapping for all distinct characters. Let p(i, c) be the mapping of c after i designers already finished their job. Now: p(0, c) = c If p(i - 1, c) = xi, then p(i, c) = yi Same, if p(i - 1, c) = yi, then p(i, c) = xi This solution complexity is O(|Σ|·m + n) and is enough to pass all the tests.Challenge: improve the complexity to O(Σ + n + m).Code examples: 13837577 implements O(|Σ|·m + n) and 13839154 stands for O(|Σ| + n + m).Div. 2C\\Div. 1A (Median Smoothing)Problem idea and development: Sender.We will call the element of a sequence stable, if it doesn't change after applying the algorithm of median smoothing for any number of times. Both ends are stable by the definition of the median smoothing. Also, it is easy to notice, that two equal consecutive elements are both stable.Now we should take a look at how do stable elements affect their neighbors. Suppose ai - 1 = ai, meaning i - 1 and i are stable. Additionaly assume, that ai + 1 is not a stable element, hence ai + 1 ≠ ai and ai + 1 ≠ ai + 2. Keeping in mind that only 0 and 1 values are possible, we conclude that ai = ai + 2 and applying a median smoothing algorithm to this sequence will result in ai = ai + 1. That means, if there is a stable element in position i, both i + 1 and i - 1 are guaranteed to be stable after one application of median smoothing. Now we can conclude, that all sequences will turn to stable at some point.Note, that if there are two stable elements i and j with no other stable elements located between them, the sequence of elements between them is alternating, i.e. ak = (ai + k - i)mod2, where . One can check, that stable elements may occur only at the ends of the alternating sequence, meaning the sequence will remain alternating until it will be killed by effect spreading from ending stable elements.The solution is: calculate max(min(|i - sj|)), where sj are the initial stable elements. Time complexity is O(n).Challenge 1: hack the solution that just applies median smoothing until something changes.Challenge 2: think of how to speed up the algorithm from challenge 1 using bitmasks (still gets TL).Code examples: 13838940 and 13838480.Div. 2D\\Div. 1B (Chip 'n Dale Rescue Rangers)Problem idea and development: StopKran.If the velocity of the dirigible relative to the air is given by the vector (ax, ay), while the velocity of the wind is (bx, by), the resulting velocity of the dirigible relative to the plane is (ax + bx, ay + by).The main idea here is that the answer function is monotonous. If the dirigible is able to reach to target in seconds, then it can do so in seconds, for any x ≥ 0. That is an obvious consequence from the fact the maximum self speed of the dirigible is strictly greater then the speed of the wind at any moment of time.For any monotonous function we can use binary search. Now we only need to check, if for some given value it's possible for the dirigible to reach the target in seconds. Let's separate the movement of the air and the movement of the dirigible in the air. The movement cause by the air is: (xn, yn) = , if ; (xn, yn) = , for . The only thing we need to check now is that the distance between the point (xn, yn) and the target coordinates (x2, y2) can be covered moving with the speed vmax in seconds assuming there is no wind.Time complexity is , where C stands for the maximum coordinate, аnd ε — desired accuracy.Challenge 1: think of the solution in case it's not guaranteed that the dirigible is faster than the wind.Challenge 2: can you come up with O(1) solution?Code examples: 13838659 and 13842505.Div. 2E\\Div. 1C (Three States)Problem idea and development: haku.Affirmation. Suppose we are given an undirected unweighted connected graph and three distinct chosen vertices u, v, w of this graph. We state that at least one minimum connecting network for these three vertices has the following form: some vertex c is chosen and the resulting network is obtained as a union of shortest paths from c to each of the chosen vertices.Proof. One of the optimal subgraphs connecting these three vertices is always a tree. Really, we can take any connecting subgraph and while there are cycles remaining in it, take any cycle and throw away any edge of this cycle. Moreover, only vertices u, v and w are allowed to be leaves of this tree, as we can delete from the network any other leaves and the network will still be connected. If the tree has no more than three leaves, it has no more than one vertex with the degree greater than 2. This vertex is c from the statement above. Any path from c to the leaves may obviously be replaced with the shortest path. Special case is than there is no node with the degree greater than 2, meaning one of u, v or w lies on the shortest path connecting two other vertices.The solution is: find the shortest path from each of the chosen vertices to all other vertices, and then try every vertex of the graph as c. Time complexity is O(|V| + |E|).To apply this solution to the given problem we should first build a graph, where cells of the table stand for the vertices and two vertices are connected by an edge, if the corresponding cells were neighboring. Now we should merge all vertices of a single state in one in order to obtain a task described in the beginning. Time complexity is a linear function of the size of the table .Code examples: 13843265 — the solution described above that uses 0-1 bfs instead of merging, 13840329 — another approach that tries to different cases.Div. 1D (Top Secret Task)Problem idea and development: glebushka98.If , than the sum of k minimums is obviously an answer. Let i1 < i2 <  ...  < ik be the indices of the elements that will form the answer. Note, that the relative order of the chosen subset will remain the same, as there is no reason to swap two elements that will both be included in the answer. The minimum number of operations required to place this k elements at the beginning is equal to — .T ≤ S  ≤  . . Calculate the dynamic programming d[i][j][p] &mdash minimum possible sum, if we chose j elements among first i with the total indices sum no greater than p. In order to optimize the memory consumption we will keep in memory only two latest layers of the dp.Time complexity is O(n4), with O(n3) memory consumption.Code examples: 13845513 and 13845571.Div. 1E (Birthday)Problem idea: meshanya, development: romanandreev.The given problem actually consists of two separate problems: build the directed graph of substring relation and find the maximum independent set in it. Note, that if the string s2 is a substring of some string s1, while string s3 is a substring of the string s2, then s3 is a substring of s1. That means the graph of substring relation defines a partially ordered set.To build the graph one can use Aho-Corasick algorithm. Usage of this structure allow to build all essential arc of the graph in time O(L), where L stands for the total length of all strings in the input. We will call the arc essential, if there is no w, such that and . One of the ways to do so is: Build Aho-Corasick using all strings in the input; For every node of the Aho-Corasick structure find and remember the nearest terminal node in the suffix-link path; Once again traverse all strings through Aho-Corasick. Every time new symbol is added, add an arc from the node corresponding to the current string (in the graph we build, not Aho-Corasick) to the node of the graph corresponding to the nearest terminal in the suffix-link path; The previous step will build all essential arcs plus some other arcs, but they do not affect the next step in any way; Find the transitive closure of the graph. To solve the second part of the problem one should use the Dilworth theorem. The way to restore the answer subset comes from the constructive proof of the theorem.Time complexity is O(L + n3) to build the graph plus O(n3) to find the maximum antichain. The overall complexity is O(L + n3).Congratulation to ikatanic — — the only participant to solve this problem during the contest. View his code 13851141 for further clarifications.Challenge: solve the problem with the same asymptotic, if we are to find the subset with the maximum total length of all strings in it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21203",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 9655
        }
      ],
      "code_examples": [
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 1",
          "code": "3 3\n1.2\n1.2\n333",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 2",
          "code": "3 3\n1.2\n1.2\n333",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 3",
          "code": "3 3\n1..\n..2\n3..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 4",
          "code": "3 3\n1..\n..2\n3..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 5",
          "code": "segs = re.findall('(.*?)(0{2,}|1{2,})', s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 6",
          "code": "segs = re.findall('(.*?)(0{2,}|1{2,})', s)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 7",
          "code": "110010101110100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 8",
          "code": "[('', '11'), ('', '00'), ('1010', '111'), ('01', '00')]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 9",
          "code": "\"1 - NUMBER_1, NUMBER_1\"+",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 10",
          "code": "\"NUMBER_1,NUMBER_1\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 11",
          "code": "\"NUMBER_1\" * (length_of_repetition / 2) + \"NUMBER_2\" * (length_of_repetition / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 12",
          "code": "UPD4: ............ Congratulations to Div. 1 top-5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 13",
          "code": "UPD4: ............ Congratulations to Div. 1 top-5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 14",
          "code": "sleep(10 * 60 * 60 * 1000); //10 hours\nupdate_ratings();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        },
        {
          "title": "New coordinator presents Codeforces Round #327 - Codeforces - Code 15",
          "code": "sleep(10 * 60 * 60 * 1000); //10 hours\nupdate_ratings();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21185",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    // Now read n lines each of m characters\n    vector<string> grid(n);\n    for (int i = 0; i < n; i++) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].length()) == m, \"Line %d of grid should be length %d\", i + 1, m);\n        for (int j = 0; j < m; j++) {\n            char c = grid[i][j];\n            ensuref(c == '1' || c == '2' || c == '3' || c == '.' || c == '#',\n                \"Invalid character '%c' at position (%d,%d)\", c, i + 1, j + 1);\n        }\n    }\n\n    // Now for each state, check that there is at least one cell\n    for (char state = '1'; state <= '3'; state++) {\n        bool hasCell = false;\n        for (int i = 0; i < n && !hasCell; i++) {\n            for (int j = 0; j < m && !hasCell; j++) {\n                if (grid[i][j] == state) {\n                    hasCell = true;\n                }\n            }\n        }\n        ensuref(hasCell, \"State %c should have at least one cell\", state);\n    }\n\n    // Now for each state, check that the cells of that state form a connected component\n    for (char state = '1'; state <= '3'; state++) {\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        // Find starting cell\n        int si = -1, sj = -1;\n        for (int i = 0; i < n && si == -1; i++) {\n            for (int j = 0; j < m && sj == -1; j++) {\n                if (grid[i][j] == state) {\n                    si = i;\n                    sj = j;\n                    break;\n                }\n            }\n        }\n        assert(si != -1 && sj != -1); // Since we ensured hasCell\n        // BFS\n        queue<pair<int, int>> q;\n        q.push({ si, sj });\n        visited[si][sj] = true;\n        while (!q.empty()) {\n            int x = q.front().first;\n            int y = q.front().second;\n            q.pop();\n            const int dx[4] = { -1, 0, 1, 0 };\n            const int dy[4] = { 0, -1, 0, 1 };\n            for (int dir = 0; dir < 4; dir++) {\n                int nx = x + dx[dir];\n                int ny = y + dy[dir];\n                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {\n                    if (!visited[nx][ny] && grid[nx][ny] == state) {\n                        visited[nx][ny] = true;\n                        q.push({ nx, ny });\n                    }\n                }\n            }\n        }\n        // Check for unvisited cells of this state\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == state && !visited[i][j]) {\n                    ensuref(false, \"Cells of state %c are not connected\", state);\n                }\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    // Now read n lines each of m characters\n    vector<string> grid(n);\n    for (int i = 0; i < n; i++) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].length()) == m, \"Line %d of grid should be length %d\", i + 1, m);\n        for (int j = 0; j < m; j++) {\n            char c = grid[i][j];\n            ensuref(c == '1' || c == '2' || c == '3' || c == '.' || c == '#',\n                \"Invalid character '%c' at position (%d,%d)\", c, i + 1, j + 1);\n        }\n    }\n\n    // Now for each state, check that there is at least one cell\n    for (char state = '1'; state <= '3'; state++) {\n        bool hasCell = false;\n        for (int i = 0; i < n && !hasCell; i++) {\n            for (int j = 0; j < m && !hasCell; j++) {\n                if (grid[i][j] == state) {\n                    hasCell = true;\n                }\n            }\n        }\n        ensuref(hasCell, \"State %c should have at least one cell\", state);\n    }\n\n    // Now for each state, check that the cells of that state form a connected component\n    for (char state = '1'; state <= '3'; state++) {\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        // Find starting cell\n        int si = -1, sj = -1;\n        for (int i = 0; i < n && si == -1; i++) {\n            for (int j = 0; j < m && sj == -1; j++) {\n                if (grid[i][j] == state) {\n                    si = i;\n                    sj = j;\n                    break;\n                }\n            }\n        }\n        assert(si != -1 && sj != -1); // Since we ensured hasCell\n        // BFS\n        queue<pair<int, int>> q;\n        q.push({ si, sj });\n        visited[si][sj] = true;\n        while (!q.empty()) {\n            int x = q.front().first;\n            int y = q.front().second;\n            q.pop();\n            const int dx[4] = { -1, 0, 1, 0 };\n            const int dy[4] = { 0, -1, 0, 1 };\n            for (int dir = 0; dir < 4; dir++) {\n                int nx = x + dx[dir];\n                int ny = y + dy[dir];\n                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {\n                    if (!visited[nx][ny] && grid[nx][ny] == state) {\n                        visited[nx][ny] = true;\n                        q.push({ nx, ny });\n                    }\n                }\n            }\n        }\n        // Check for unvisited cells of this state\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == state && !visited[i][j]) {\n                    ensuref(false, \"Cells of state %c are not connected\", state);\n                }\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    // Now read n lines each of m characters\n    vector<string> grid(n);\n    for (int i = 0; i < n; i++) {\n        grid[i] = inf.readLine();\n        ensuref(int(grid[i].length()) == m, \"Line %d of grid should be length %d\", i + 1, m);\n        for (int j = 0; j < m; j++) {\n            char c = grid[i][j];\n            ensuref(c == '1' || c == '2' || c == '3' || c == '.' || c == '#',\n                \"Invalid character '%c' at position (%d,%d)\", c, i + 1, j + 1);\n        }\n    }\n\n    // Now for each state, check that there is at least one cell\n    for (char state = '1'; state <= '3'; state++) {\n        bool hasCell = false;\n        for (int i = 0; i < n && !hasCell; i++) {\n            for (int j = 0; j < m && !hasCell; j++) {\n                if (grid[i][j] == state) {\n                    hasCell = true;\n                }\n            }\n        }\n        ensuref(hasCell, \"State %c should have at least one cell\", state);\n    }\n\n    // Now for each state, check that the cells of that state form a connected component\n    for (char state = '1'; state <= '3'; state++) {\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        // Find starting cell\n        int si = -1, sj = -1;\n        for (int i = 0; i < n && si == -1; i++) {\n            for (int j = 0; j < m && sj == -1; j++) {\n                if (grid[i][j] == state) {\n                    si = i;\n                    sj = j;\n                    break;\n                }\n            }\n        }\n        assert(si != -1 && sj != -1); // Since we ensured hasCell\n        // BFS\n        queue<pair<int, int>> q;\n        q.push({ si, sj });\n        visited[si][sj] = true;\n        while (!q.empty()) {\n            int x = q.front().first;\n            int y = q.front().second;\n            q.pop();\n            const int dx[4] = { -1, 0, 1, 0 };\n            const int dy[4] = { 0, -1, 0, 1 };\n            for (int dir = 0; dir < 4; dir++) {\n                int nx = x + dx[dir];\n                int ny = y + dy[dir];\n                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {\n                    if (!visited[nx][ny] && grid[nx][ny] == state) {\n                        visited[nx][ny] = true;\n                        q.push({ nx, ny });\n                    }\n                }\n            }\n        }\n        // Check for unvisited cells of this state\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == state && !visited[i][j]) {\n                    ensuref(false, \"Cells of state %c are not connected\", state);\n                }\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateAlreadyConnected(int n, int m) {\n    vector<string> grid(n, string(m, '.'));\n\n    if (m >= 3) {\n        int stateWidth = m / 3;\n        int remain = m % 3;\n\n        // Place '1's in the first third of row 0\n        for (int j = 0; j < stateWidth; ++j) {\n            grid[0][j] = '1';\n        }\n\n        // Place '2's in the second third of row 0\n        for (int j = stateWidth; j < 2 * stateWidth; ++j) {\n            grid[0][j] = '2';\n        }\n\n        // Place '3's in the remaining part of row 0\n        for (int j = 2 * stateWidth; j < m; ++j) {\n            grid[0][j] = '3';\n        }\n    } else {\n        // m < 3\n        // Place the states vertically\n        int row = 0;\n        if (row < n) {\n            grid[row][0] = '1';\n            row++;\n        }\n        if (row < n) {\n            grid[row][0] = '2';\n            row++;\n        }\n        if (row < n) {\n            grid[row][0] = '3';\n            row++;\n        }\n    }\n\n    // Print the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        puts(grid[i].c_str());\n    }\n}\n\nvoid generateImpossible(int n, int m) {\n    vector<string> grid(n, string(m, '#'));\n\n    int stateSize = min(3, min(n, m) / 3);\n\n    int positions[3][2] = {\n        {1, 1}, {1, m - stateSize - 1}, {n - stateSize - 1, 1}\n    };\n\n    for (int idx = 0; idx < 3; ++idx) {\n        char state = '1' + idx;\n        int startX = positions[idx][0];\n        int startY = positions[idx][1];\n\n        if (startX + stateSize >= n || startY + stateSize >= m) {\n            cerr << \"Cannot place state \" << state << \" in the grid.\" << endl;\n            exit(1);\n        }\n\n        // Carve out the state's area\n        for (int i = startX; i < startX + stateSize; ++i) {\n            for (int j = startY; j < startY + stateSize; ++j) {\n                grid[i][j] = state;\n            }\n        }\n    }\n\n    // Print the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        puts(grid[i].c_str());\n    }\n}\n\nvoid generateRandom(int n, int m) {\n    vector<string> grid(n, string(m, '.'));\n\n    set<pair<int, int>> occupied;\n\n    for (char state = '1'; state <= '3'; ++state) {\n        int size = rnd.next(1, max(1, n * m / 10));\n\n        int startX, startY;\n        do {\n            startX = rnd.next(0, n - 1);\n            startY = rnd.next(0, m - 1);\n        } while (occupied.count({startX, startY}));\n\n        grid[startX][startY] = state;\n        occupied.insert({startX, startY});\n\n        queue<pair<int, int>> q;\n        q.push({startX, startY});\n\n        int cells = 1;\n\n        while (!q.empty() && cells < size) {\n            int x = q.front().first;\n            int y = q.front().second;\n            q.pop();\n\n            vector<pair<int, int>> adj = {\n                {x - 1, y},\n                {x + 1, y},\n                {x, y - 1},\n                {x, y + 1}\n            };\n\n            shuffle(adj.begin(), adj.end());\n            for (auto p : adj) {\n                int nx = p.first;\n                int ny = p.second;\n                if (nx >= 0 && nx < n && ny >= 0 && ny < m && !occupied.count({nx, ny}) && grid[nx][ny] == '.') {\n                    grid[nx][ny] = state;\n                    occupied.insert({nx, ny});\n                    q.push({nx, ny});\n                    cells++;\n                    if (cells >= size) break;\n                }\n            }\n        }\n    }\n\n    // Randomly fill the rest of the grid with '.' or '#' with some probability\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == '.') {\n                int r = rnd.next(100);\n                if (r < 20) {\n                    grid[i][j] = '#'; // 20% chance of obstacle\n                } else {\n                    grid[i][j] = '.'; // 80% chance of buildable area\n                }\n            }\n        }\n    }\n\n    // Print the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        puts(grid[i].c_str());\n    }\n}\n\nvoid generateStatesSurrounded(int n, int m) {\n    vector<string> grid(n, string(m, '#'));\n\n    // Place '1's in top-left corner\n    grid[1][1] = '1';\n\n    // Place '2's in top-right corner\n    grid[1][m - 2] = '2';\n\n    // Place '3's in bottom-left corner\n    grid[n - 2][1] = '3';\n\n    // Create paths connecting the states with narrow corridors\n    for (int i = 1; i < n - 1; ++i) {\n        grid[i][m / 2] = '.'; // Vertical path\n    }\n    for (int j = 1; j < m - 1; ++j) {\n        grid[n / 2][j] = '.'; // Horizontal path\n    }\n\n    // Connect '1' and '2' to the paths\n    grid[1][m / 2] = '.'; // From '1' to vertical path\n    grid[1][m - 2] = '2'; // Already connected to vertical path\n\n    // Connect '3' to the paths\n    grid[n - 2][m / 2] = '.'; // From '3' to vertical path\n\n    // Connect vertical and horizontal paths\n    grid[n / 2][m / 2] = '.'; // Intersection point\n\n    // Print the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        puts(grid[i].c_str());\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"already_connected\") {\n        generateAlreadyConnected(n, m);\n    } else if (type == \"impossible\") {\n        generateImpossible(n, m);\n    } else if (type == \"random\") {\n        generateRandom(n, m);\n    } else if (type == \"states_surrounded\") {\n        generateStatesSurrounded(n, m);\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generateAlreadyConnected(int n, int m) {\n    vector<string> grid(n, string(m, '.'));\n\n    if (m >= 3) {\n        int stateWidth = m / 3;\n        int remain = m % 3;\n\n        // Place '1's in the first third of row 0\n        for (int j = 0; j < stateWidth; ++j) {\n            grid[0][j] = '1';\n        }\n\n        // Place '2's in the second third of row 0\n        for (int j = stateWidth; j < 2 * stateWidth; ++j) {\n            grid[0][j] = '2';\n        }\n\n        // Place '3's in the remaining part of row 0\n        for (int j = 2 * stateWidth; j < m; ++j) {\n            grid[0][j] = '3';\n        }\n    } else {\n        // m < 3\n        // Place the states vertically\n        int row = 0;\n        if (row < n) {\n            grid[row][0] = '1';\n            row++;\n        }\n        if (row < n) {\n            grid[row][0] = '2';\n            row++;\n        }\n        if (row < n) {\n            grid[row][0] = '3';\n            row++;\n        }\n    }\n\n    // Print the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        puts(grid[i].c_str());\n    }\n}\n\nvoid generateImpossible(int n, int m) {\n    vector<string> grid(n, string(m, '#'));\n\n    int stateSize = min(3, min(n, m) / 3);\n\n    int positions[3][2] = {\n        {1, 1}, {1, m - stateSize - 1}, {n - stateSize - 1, 1}\n    };\n\n    for (int idx = 0; idx < 3; ++idx) {\n        char state = '1' + idx;\n        int startX = positions[idx][0];\n        int startY = positions[idx][1];\n\n        if (startX + stateSize >= n || startY + stateSize >= m) {\n            cerr << \"Cannot place state \" << state << \" in the grid.\" << endl;\n            exit(1);\n        }\n\n        // Carve out the state's area\n        for (int i = startX; i < startX + stateSize; ++i) {\n            for (int j = startY; j < startY + stateSize; ++j) {\n                grid[i][j] = state;\n            }\n        }\n    }\n\n    // Print the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        puts(grid[i].c_str());\n    }\n}\n\nvoid generateRandom(int n, int m) {\n    vector<string> grid(n, string(m, '.'));\n\n    set<pair<int, int>> occupied;\n\n    for (char state = '1'; state <= '3'; ++state) {\n        int size = rnd.next(1, max(1, n * m / 10));\n\n        int startX, startY;\n        do {\n            startX = rnd.next(0, n - 1);\n            startY = rnd.next(0, m - 1);\n        } while (occupied.count({startX, startY}));\n\n        grid[startX][startY] = state;\n        occupied.insert({startX, startY});\n\n        queue<pair<int, int>> q;\n        q.push({startX, startY});\n\n        int cells = 1;\n\n        while (!q.empty() && cells < size) {\n            int x = q.front().first;\n            int y = q.front().second;\n            q.pop();\n\n            vector<pair<int, int>> adj = {\n                {x - 1, y},\n                {x + 1, y},\n                {x, y - 1},\n                {x, y + 1}\n            };\n\n            shuffle(adj.begin(), adj.end());\n            for (auto p : adj) {\n                int nx = p.first;\n                int ny = p.second;\n                if (nx >= 0 && nx < n && ny >= 0 && ny < m && !occupied.count({nx, ny}) && grid[nx][ny] == '.') {\n                    grid[nx][ny] = state;\n                    occupied.insert({nx, ny});\n                    q.push({nx, ny});\n                    cells++;\n                    if (cells >= size) break;\n                }\n            }\n        }\n    }\n\n    // Randomly fill the rest of the grid with '.' or '#' with some probability\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == '.') {\n                int r = rnd.next(100);\n                if (r < 20) {\n                    grid[i][j] = '#'; // 20% chance of obstacle\n                } else {\n                    grid[i][j] = '.'; // 80% chance of buildable area\n                }\n            }\n        }\n    }\n\n    // Print the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        puts(grid[i].c_str());\n    }\n}\n\nvoid generateStatesSurrounded(int n, int m) {\n    vector<string> grid(n, string(m, '#'));\n\n    // Place '1's in top-left corner\n    grid[1][1] = '1';\n\n    // Place '2's in top-right corner\n    grid[1][m - 2] = '2';\n\n    // Place '3's in bottom-left corner\n    grid[n - 2][1] = '3';\n\n    // Create paths connecting the states with narrow corridors\n    for (int i = 1; i < n - 1; ++i) {\n        grid[i][m / 2] = '.'; // Vertical path\n    }\n    for (int j = 1; j < m - 1; ++j) {\n        grid[n / 2][j] = '.'; // Horizontal path\n    }\n\n    // Connect '1' and '2' to the paths\n    grid[1][m / 2] = '.'; // From '1' to vertical path\n    grid[1][m - 2] = '2'; // Already connected to vertical path\n\n    // Connect '3' to the paths\n    grid[n - 2][m / 2] = '.'; // From '3' to vertical path\n\n    // Connect vertical and horizontal paths\n    grid[n / 2][m / 2] = '.'; // Intersection point\n\n    // Print the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        puts(grid[i].c_str());\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"already_connected\") {\n        generateAlreadyConnected(n, m);\n    } else if (type == \"impossible\") {\n        generateImpossible(n, m);\n    } else if (type == \"random\") {\n        generateRandom(n, m);\n    } else if (type == \"states_surrounded\") {\n        generateStatesSurrounded(n, m);\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -type already_connected\n./gen -n 10 -m 10 -type already_connected\n./gen -n 3 -m 3 -type already_connected\n./gen -n 1 -m 1 -type already_connected\n\n./gen -n 5 -m 5 -type impossible\n./gen -n 10 -m 10 -type impossible\n./gen -n 100 -m 100 -type impossible\n\n./gen -n 10 -m 10 -type random\n./gen -n 50 -m 50 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 1000 -m 1000 -type random\n\n./gen -n 30 -m 30 -type states_surrounded\n./gen -n 50 -m 50 -type states_surrounded\n./gen -n 100 -m 100 -type states_surrounded\n\n./gen -n 1000 -m 1000 -type already_connected\n./gen -n 1000 -m 1000 -type impossible\n./gen -n 1000 -m 1000 -type states_surrounded\n\n./gen -n 500 -m 500 -type random\n./gen -n 10 -m 1000 -type random\n./gen -n 1000 -m 10 -type random\n\n./gen -n 2 -m 2 -type already_connected\n./gen -n 2 -m 2 -type impossible\n./gen -n 2 -m 2 -type states_surrounded\n\n./gen -n 1000 -m 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:43.332880",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "592/A",
      "title": "A. PawnChess",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input consists of the board description given in eight lines, each line contains eight characters. Character 'B' is used to denote a black pawn, and character 'W' represents a white pawn. Empty cell is marked with '.'. It's guaranteed that there will not be white pawns on the first row neither black pawns on the last row.",
      "output_spec": "OutputPrint 'A' if player A wins the game on the given board, and 'B' if player B will claim the victory. Again, it's guaranteed that there will always be a winner on the given board.",
      "sample_tests": "ExamplesInputCopy.................B....B.....W.............W.....................OutputCopyAInputCopy..B.......W...........B..............W........B.................OutputCopyB",
      "description": "A. PawnChess\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe input consists of the board description given in eight lines, each line contains eight characters. Character 'B' is used to denote a black pawn, and character 'W' represents a white pawn. Empty cell is marked with '.'. It's guaranteed that there will not be white pawns on the first row neither black pawns on the last row.\n\nOutputPrint 'A' if player A wins the game on the given board, and 'B' if player B will claim the victory. Again, it's guaranteed that there will always be a winner on the given board.\n\nInputCopy.................B....B.....W.............W.....................OutputCopyAInputCopy..B.......W...........B..............W........B.................OutputCopyB\n\nInputCopy.................B....B.....W.............W.....................\n\nOutputCopyA\n\nInputCopy..B.......W...........B..............W........B.................\n\nOutputCopyB\n\nNoteIn the first sample player A is able to complete his goal in 3 steps by always moving a pawn initially located at (4, 5). Player B needs at least 5 steps for any of his pawns to reach the row 8. Hence, player A will be the winner.",
      "solutions": [
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces",
          "content": "Codeforces Round #328 (Div. 2) will take place on October 31, 19:30 MSK, as usual Div. 1 participants can join out of competition.Problem Setter: Morphy (Alei Reyes)Coordinator: GlebsHP (Gleb Evstropov)English to Russian translator: Delinur (Maria Belova) Codeforces and Polygon: MikeMirzayanov (Mike Mirzayanov)Hope you enjoy the problem set.The score distribution will be announced later.UPD. Score Distribution: 500 — 1000 — 1500 — 2000 — 3000UPD. Problem Analysis is availableCongrats to the winners!Div. 2shamir0xelbn187SuperLoserDiv. 1uwiNanoApeHaghani",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21284",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 558
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces",
          "content": "Problem A. PawnChessPlayer A wins if the distance of his nearest pawn to the top of the board is less than or equal to the distance of the Player’s B nearest pawn to the bottom of the board (Note that you should only consider pawns that are not blocked by another pawns).Problem B. The monster and the squirrelAfter drawing the rays from the first vertex (n - 2) triangles are formed. The subsequent rays will generate independently sub-regions in these triangles. Let's analyse the triangle determined by vertices 1, i, i + 1, after drawing the rays from vertex i and (i + 1) the triangle will be divided into (n - i) + (i - 2) = n - 2 regions. Therefore the total number of convex regions is (n - 2)2If the squirrel starts from the region that have 1 as a vertex, then she can go through each region of triangle (1, i, i + 1) once. That implies that the squirrel can collect all the walnuts in (n - 2)2 jumps.Problem C. The Big RaceLet D be the length of the racetrack, Since both athletes should tie . Let M = lcm(B, W), then D = k·M + r. None of the athletes should give one step further, therefore r ≤ min{B - 1, W - 1, T} = X. D must be greater than 0 and less than or equal to T so  - r / M < k ≤ (T - r) / M. For r = 0, the number of valid racetracks is , and for r > 0 the number of racetracks is . Iterating over all possible r, we can count the number of racetracks in which Willman and Bolt ties: Note that . That means that for exactly M values of r. We can count the number of values of r in which , and the values of r in which . Each of the remaining values v1 - 1, v1 - 2, ..., v2 + 1 will appear exactly M times.Problem D. Super MObservation 1: Ari should teleport to one of the attacked cities (it doesn't worth going to a city that is not attacked since then she should go to one of the attacked cities)Observation 2: The nodes visited by Ari will determine a sub-tree T of the original tree, this tree is unique and is determined by all the paths from two attacked cities.Observation 3: If Ari had to return to the city from where she started, then the total distance would be 2e, where e is the number of edges of T, that is because she goes through each edge forward and backwardObservation 4: If Ari does not have to return to the starting city (the root of T), then the total distance is 2e - L, where L is the distance of the farthest node from the rootObservation 5: In order to get a minimum total distance, Ari should chose one diameter of the tree, and teleport to one of its leaves.The problem is now transformed in finding the diameter of a tree that contains the smallest index for one of its leaves. Note that all diameters pass through the center of the tree, so we can find all the farthest nodes from the center...and [details omitted].Problem E. BCPCLet’s represent the reading and writing speeds of the students as points in a plane. Two students i, j are compatible if ri'·wj' - rj'·wi' > 0 this equation is identical to the cross product: (ri', wi') × (rj', wj′) > 0. Using this fact is easy to see that three students i, j, k are compatible if the triangle (ri, wi), (rj, wj), (rk, wk) contains the point (x, y). So the problem is reduced to count the number of triangles that contains the origin.Let’s count the triangles that have two known vertices i and j (look at the picture above). It is easy to see that the third vertex should be inside the region S. So now we have to be able of counting points that are between two rays, that can be done using binary search (ordering the points first by slope and then by the distance to the origin).Now given a point i, let’s count the triangles that have i as a vertex (look at the picture above again). We have to count the points that lie between the ray iO, and every other ray jO (the angle between iO and jO must be  ≤ 180). Let Sj denote the number points that are between the rays OR and jO, then the number of triangles that have i as a vertex are . This summation can be calculated if we pre-calculate the cumulative sums of Sj. The overall complexity is O(n·log(n)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21318",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4065
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 1",
          "code": "#define ull unsigned long long\nbool overFlow(ull a, ull b) {\n    return ((a*b)/b == a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 2",
          "code": "#define ull unsigned long long\nbool overFlow(ull a, ull b) {\n    return ((a*b)/b == a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 3",
          "code": "if (minA < minB) cout << \"A\\n\";\nelse cout << \"B\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 4",
          "code": "if (minA < minB) cout << \"A\\n\";\nelse cout << \"B\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 5",
          "code": "........\n..B.....\n......W.\n..W.....\n........\n........\n..B.....\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 6",
          "code": "........\n..B.....\n......W.\n..W.....\n........\n........\n..B.....\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 7",
          "code": "........\n.W......\n........\n........\n........\n........\n......B.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 8",
          "code": "........\n.W......\n........\n........\n........\n........\n......B.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 9",
          "code": "#include <iostream>\nusing namespace std;\nint main() {\n  cout << sizeof(long double) << endl;\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 10",
          "code": "#include <iostream>\nusing namespace std;\nint main() {\n  cout << sizeof(long double) << endl;\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 11",
          "code": "#include <iostream>  using namespace std;  int main(int argc, char **argv){  int points;  cin >> points; unsigned long long answer = 1 + (points-3) + 2*(points-3) + (points-3)*(points-4);  cout << answer << endl;  return 0;  }",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 12",
          "code": "#include <iostream>  using namespace std;  int main(int argc, char **argv){  int points;  cin >> points; unsigned long long answer = 1 + (points-3) + 2*(points-3) + (points-3)*(points-4);  cout << answer << endl;  return 0;  }",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces - Code 1",
          "code": "__builtin_mul_overflow",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21318",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces - Code 2",
          "code": "int max_r = min(min(b,w)-1, t);\nint ans = t / lcm;\nfor (int r = 1; r <= max_r; ) {\nint v = (T-r)/lcm;\nint mfar = min(max_r, t - v * lcm);\nans += (mfar - r + 1) * (v + 1);\nr = mfar + 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21318",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces - Code 3",
          "code": "int max_r = min(min(b,w)-1, t);\nint ans = t / lcm;\nfor (int r = 1; r <= max_r; ) {\nint v = (T-r)/lcm;\nint mfar = min(max_r, t - v * lcm);\nans += (mfar - r + 1) * (v + 1);\nr = mfar + 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21318",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    for (int row = 1; row <= 8; ++row) {\n        // Read a line and ensure it's exactly 8 characters of '.', 'B', or 'W'\n        string s = inf.readLine(\"[\\\\.BW]{8}\");\n        if (row == 1) {\n            // Ensure that the first row does not contain 'W'\n            ensuref(s.find('W') == string::npos, \"First row must not contain 'W'\");\n        }\n        if (row == 8) {\n            // Ensure that the last row does not contain 'B'\n            ensuref(s.find('B') == string::npos, \"Last row must not contain 'B'\");\n        }\n    }\n\n    inf.readEof(); // Ensure there is no extra data\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    for (int row = 1; row <= 8; ++row) {\n        // Read a line and ensure it's exactly 8 characters of '.', 'B', or 'W'\n        string s = inf.readLine(\"[\\\\.BW]{8}\");\n        if (row == 1) {\n            // Ensure that the first row does not contain 'W'\n            ensuref(s.find('W') == string::npos, \"First row must not contain 'W'\");\n        }\n        if (row == 8) {\n            // Ensure that the last row does not contain 'B'\n            ensuref(s.find('B') == string::npos, \"Last row must not contain 'B'\");\n        }\n    }\n\n    inf.readEof(); // Ensure there is no extra data\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    for (int row = 1; row <= 8; ++row) {\n        // Read a line and ensure it's exactly 8 characters of '.', 'B', or 'W'\n        string s = inf.readLine(\"[\\\\.BW]{8}\");\n        if (row == 1) {\n            // Ensure that the first row does not contain 'W'\n            ensuref(s.find('W') == string::npos, \"First row must not contain 'W'\");\n        }\n        if (row == 8) {\n            // Ensure that the last row does not contain 'B'\n            ensuref(s.find('B') == string::npos, \"Last row must not contain 'B'\");\n        }\n    }\n\n    inf.readEof(); // Ensure there is no extra data\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read command line options.\n    string type = opt<string>(\"type\", \"random\");\n    int w = opt<int>(\"w\", 16); // Number of white pawns.\n    int b = opt<int>(\"b\", 16); // Number of black pawns.\n\n    // Validate the number of pawns to be within valid range.\n    if (w < 0 || w > 56) w = 16;\n    if (b < 0 || b > 56) b = 16;\n\n    // Initialize the board with empty cells.\n    vector<string> board(8, string(8, '.'));\n\n    if (type == \"random\") {\n        // Generate random positions for white pawns (excluding row 0).\n        vector<pair<int, int>> white_cells;\n        for (int r = 1; r < 8; ++r)\n            for (int c = 0; c < 8; ++c)\n                white_cells.push_back({r, c});\n        shuffle(white_cells.begin(), white_cells.end());\n\n        // Place white pawns.\n        for (int i = 0; i < min(w, (int)white_cells.size()); ++i) {\n            int r = white_cells[i].first;\n            int c = white_cells[i].second;\n            board[r][c] = 'W';\n        }\n\n        // Generate random positions for black pawns (excluding row 7).\n        vector<pair<int, int>> black_cells;\n        for (int r = 0; r < 7; ++r)\n            for (int c = 0; c < 8; ++c)\n                black_cells.push_back({r, c});\n        shuffle(black_cells.begin(), black_cells.end());\n\n        // Place black pawns, ensuring no overlap with white pawns.\n        for (int i = 0; i < min(b, (int)black_cells.size()); ++i) {\n            int r = black_cells[i].first;\n            int c = black_cells[i].second;\n            if (board[r][c] == '.')\n                board[r][c] = 'B';\n        }\n    } else if (type == \"white_win\") {\n        // Place a white pawn close to the top to ensure a quick win.\n        int white_col = rnd.next(8);\n        board[1][white_col] = 'W';\n\n        // Place additional white pawns randomly.\n        int remaining_white = w - 1;\n        vector<pair<int, int>> white_cells;\n        for (int r = 2; r < 8; ++r)\n            for (int c = 0; c < 8; ++c)\n                white_cells.push_back({r, c});\n        shuffle(white_cells.begin(), white_cells.end());\n        for (int i = 0; i < min(remaining_white, (int)white_cells.size()); ++i) {\n            int r = white_cells[i].first;\n            int c = white_cells[i].second;\n            board[r][c] = 'W';\n        }\n\n        // Place black pawns far from the bottom to delay their win.\n        vector<pair<int, int>> black_cells;\n        for (int r = 0; r < 2; ++r)\n            for (int c = 0; c < 8; ++c)\n                black_cells.push_back({r, c});\n        shuffle(black_cells.begin(), black_cells.end());\n        for (int i = 0; i < min(b, (int)black_cells.size()); ++i) {\n            int r = black_cells[i].first;\n            int c = black_cells[i].second;\n            if (board[r][c] == '.')\n                board[r][c] = 'B';\n        }\n    } else if (type == \"black_win\") {\n        // Place a black pawn close to the bottom to ensure a quick win.\n        int black_col = rnd.next(8);\n        board[6][black_col] = 'B';\n\n        // Place additional black pawns randomly.\n        int remaining_black = b - 1;\n        vector<pair<int, int>> black_cells;\n        for (int r = 0; r < 6; ++r)\n            for (int c = 0; c < 8; ++c)\n                black_cells.push_back({r, c});\n        shuffle(black_cells.begin(), black_cells.end());\n        for (int i = 0; i < min(remaining_black, (int)black_cells.size()); ++i) {\n            int r = black_cells[i].first;\n            int c = black_cells[i].second;\n            if (board[r][c] == '.')\n                board[r][c] = 'B';\n        }\n\n        // Place white pawns far from the top to delay their win.\n        vector<pair<int, int>> white_cells;\n        for (int r = 7; r >= 2; --r)\n            for (int c = 0; c < 8; ++c)\n                white_cells.push_back({r, c});\n        shuffle(white_cells.begin(), white_cells.end());\n        for (int i = 0; i < min(w, (int)white_cells.size()); ++i) {\n            int r = white_cells[i].first;\n            int c = white_cells[i].second;\n            if (board[r][c] == '.')\n                board[r][c] = 'W';\n        }\n    } else if (type == \"equal_race\") {\n        // Place white and black pawns equidistant from their target rows.\n        int col = rnd.next(8);\n        board[3][col] = 'W';\n        board[4][col] = 'B';\n\n        // Place additional white pawns randomly.\n        int remaining_white = w - 1;\n        vector<pair<int, int>> white_cells;\n        for (int r = 1; r < 8; ++r)\n            for (int c = 0; c < 8; ++c)\n                if (board[r][c] == '.' && !(r == 4 && c == col))\n                    white_cells.push_back({r, c});\n        shuffle(white_cells.begin(), white_cells.end());\n        for (int i = 0; i < min(remaining_white, (int)white_cells.size()); ++i) {\n            int r = white_cells[i].first;\n            int c = white_cells[i].second;\n            board[r][c] = 'W';\n        }\n\n        // Place additional black pawns randomly.\n        int remaining_black = b - 1;\n        vector<pair<int, int>> black_cells;\n        for (int r = 0; r < 7; ++r)\n            for (int c = 0; c < 8; ++c)\n                if (board[r][c] == '.' && !(r == 3 && c == col))\n                    black_cells.push_back({r, c});\n        shuffle(black_cells.begin(), black_cells.end());\n        for (int i = 0; i < min(remaining_black, (int)black_cells.size()); ++i) {\n            int r = black_cells[i].first;\n            int c = black_cells[i].second;\n            board[r][c] = 'B';\n        }\n    } else {\n        // Default to random if an unknown type is provided.\n        // Same approach as in the 'random' case.\n    }\n\n    // Output the board.\n    for (int r = 0; r < 8; ++r) {\n        printf(\"%s\\n\", board[r].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read command line options.\n    string type = opt<string>(\"type\", \"random\");\n    int w = opt<int>(\"w\", 16); // Number of white pawns.\n    int b = opt<int>(\"b\", 16); // Number of black pawns.\n\n    // Validate the number of pawns to be within valid range.\n    if (w < 0 || w > 56) w = 16;\n    if (b < 0 || b > 56) b = 16;\n\n    // Initialize the board with empty cells.\n    vector<string> board(8, string(8, '.'));\n\n    if (type == \"random\") {\n        // Generate random positions for white pawns (excluding row 0).\n        vector<pair<int, int>> white_cells;\n        for (int r = 1; r < 8; ++r)\n            for (int c = 0; c < 8; ++c)\n                white_cells.push_back({r, c});\n        shuffle(white_cells.begin(), white_cells.end());\n\n        // Place white pawns.\n        for (int i = 0; i < min(w, (int)white_cells.size()); ++i) {\n            int r = white_cells[i].first;\n            int c = white_cells[i].second;\n            board[r][c] = 'W';\n        }\n\n        // Generate random positions for black pawns (excluding row 7).\n        vector<pair<int, int>> black_cells;\n        for (int r = 0; r < 7; ++r)\n            for (int c = 0; c < 8; ++c)\n                black_cells.push_back({r, c});\n        shuffle(black_cells.begin(), black_cells.end());\n\n        // Place black pawns, ensuring no overlap with white pawns.\n        for (int i = 0; i < min(b, (int)black_cells.size()); ++i) {\n            int r = black_cells[i].first;\n            int c = black_cells[i].second;\n            if (board[r][c] == '.')\n                board[r][c] = 'B';\n        }\n    } else if (type == \"white_win\") {\n        // Place a white pawn close to the top to ensure a quick win.\n        int white_col = rnd.next(8);\n        board[1][white_col] = 'W';\n\n        // Place additional white pawns randomly.\n        int remaining_white = w - 1;\n        vector<pair<int, int>> white_cells;\n        for (int r = 2; r < 8; ++r)\n            for (int c = 0; c < 8; ++c)\n                white_cells.push_back({r, c});\n        shuffle(white_cells.begin(), white_cells.end());\n        for (int i = 0; i < min(remaining_white, (int)white_cells.size()); ++i) {\n            int r = white_cells[i].first;\n            int c = white_cells[i].second;\n            board[r][c] = 'W';\n        }\n\n        // Place black pawns far from the bottom to delay their win.\n        vector<pair<int, int>> black_cells;\n        for (int r = 0; r < 2; ++r)\n            for (int c = 0; c < 8; ++c)\n                black_cells.push_back({r, c});\n        shuffle(black_cells.begin(), black_cells.end());\n        for (int i = 0; i < min(b, (int)black_cells.size()); ++i) {\n            int r = black_cells[i].first;\n            int c = black_cells[i].second;\n            if (board[r][c] == '.')\n                board[r][c] = 'B';\n        }\n    } else if (type == \"black_win\") {\n        // Place a black pawn close to the bottom to ensure a quick win.\n        int black_col = rnd.next(8);\n        board[6][black_col] = 'B';\n\n        // Place additional black pawns randomly.\n        int remaining_black = b - 1;\n        vector<pair<int, int>> black_cells;\n        for (int r = 0; r < 6; ++r)\n            for (int c = 0; c < 8; ++c)\n                black_cells.push_back({r, c});\n        shuffle(black_cells.begin(), black_cells.end());\n        for (int i = 0; i < min(remaining_black, (int)black_cells.size()); ++i) {\n            int r = black_cells[i].first;\n            int c = black_cells[i].second;\n            if (board[r][c] == '.')\n                board[r][c] = 'B';\n        }\n\n        // Place white pawns far from the top to delay their win.\n        vector<pair<int, int>> white_cells;\n        for (int r = 7; r >= 2; --r)\n            for (int c = 0; c < 8; ++c)\n                white_cells.push_back({r, c});\n        shuffle(white_cells.begin(), white_cells.end());\n        for (int i = 0; i < min(w, (int)white_cells.size()); ++i) {\n            int r = white_cells[i].first;\n            int c = white_cells[i].second;\n            if (board[r][c] == '.')\n                board[r][c] = 'W';\n        }\n    } else if (type == \"equal_race\") {\n        // Place white and black pawns equidistant from their target rows.\n        int col = rnd.next(8);\n        board[3][col] = 'W';\n        board[4][col] = 'B';\n\n        // Place additional white pawns randomly.\n        int remaining_white = w - 1;\n        vector<pair<int, int>> white_cells;\n        for (int r = 1; r < 8; ++r)\n            for (int c = 0; c < 8; ++c)\n                if (board[r][c] == '.' && !(r == 4 && c == col))\n                    white_cells.push_back({r, c});\n        shuffle(white_cells.begin(), white_cells.end());\n        for (int i = 0; i < min(remaining_white, (int)white_cells.size()); ++i) {\n            int r = white_cells[i].first;\n            int c = white_cells[i].second;\n            board[r][c] = 'W';\n        }\n\n        // Place additional black pawns randomly.\n        int remaining_black = b - 1;\n        vector<pair<int, int>> black_cells;\n        for (int r = 0; r < 7; ++r)\n            for (int c = 0; c < 8; ++c)\n                if (board[r][c] == '.' && !(r == 3 && c == col))\n                    black_cells.push_back({r, c});\n        shuffle(black_cells.begin(), black_cells.end());\n        for (int i = 0; i < min(remaining_black, (int)black_cells.size()); ++i) {\n            int r = black_cells[i].first;\n            int c = black_cells[i].second;\n            board[r][c] = 'B';\n        }\n    } else {\n        // Default to random if an unknown type is provided.\n        // Same approach as in the 'random' case.\n    }\n\n    // Output the board.\n    for (int r = 0; r < 8; ++r) {\n        printf(\"%s\\n\", board[r].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random -w 16 -b 16\n./gen -type random -w 32 -b 24\n./gen -type random -w 48 -b 8\n./gen -type random -w 56 -b 56\n./gen -type random -w 0 -b 0\n./gen -type random -w 10 -b 50\n./gen -type random -w 50 -b 10\n\n./gen -type white_win -w 8 -b 8\n./gen -type white_win -w 16 -b 8\n./gen -type white_win -w 8 -b 16\n./gen -type white_win -w 55 -b 55\n./gen -type white_win -w 1 -b 56\n\n./gen -type black_win -w 8 -b 8\n./gen -type black_win -w 16 -b 8\n./gen -type black_win -w 8 -b 16\n./gen -type black_win -w 55 -b 55\n./gen -type black_win -w 56 -b 1\n\n./gen -type equal_race -w 1 -b 1\n./gen -type equal_race -w 5 -b 5\n./gen -type equal_race -w 20 -b 20\n./gen -type equal_race -w 30 -b 30\n\n./gen -type random -w 56 -b 0\n./gen -type random -w 0 -b 56\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:45.596148",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "592/B",
      "title": "B. The Monster and the Squirrel",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first and only line of the input contains a single integer n (3 ≤ n ≤ 54321) - the number of vertices of the regular polygon drawn by Ari.",
      "output_spec": "OutputPrint the minimum number of jumps Ada should make to collect all the walnuts. Note, that she doesn't need to leave the polygon after.",
      "sample_tests": "ExamplesInputCopy5OutputCopy9InputCopy3OutputCopy1",
      "description": "B. The Monster and the Squirrel\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first and only line of the input contains a single integer n (3 ≤ n ≤ 54321) - the number of vertices of the regular polygon drawn by Ari.\n\nOutputPrint the minimum number of jumps Ada should make to collect all the walnuts. Note, that she doesn't need to leave the polygon after.\n\nInputCopy5OutputCopy9InputCopy3OutputCopy1\n\nOutputCopy9\n\nOutputCopy1\n\nNoteOne of the possible solutions for the first sample is shown on the picture above.",
      "solutions": [
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces",
          "content": "Codeforces Round #328 (Div. 2) will take place on October 31, 19:30 MSK, as usual Div. 1 participants can join out of competition.Problem Setter: Morphy (Alei Reyes)Coordinator: GlebsHP (Gleb Evstropov)English to Russian translator: Delinur (Maria Belova) Codeforces and Polygon: MikeMirzayanov (Mike Mirzayanov)Hope you enjoy the problem set.The score distribution will be announced later.UPD. Score Distribution: 500 — 1000 — 1500 — 2000 — 3000UPD. Problem Analysis is availableCongrats to the winners!Div. 2shamir0xelbn187SuperLoserDiv. 1uwiNanoApeHaghani",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21284",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 558
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces",
          "content": "Problem A. PawnChessPlayer A wins if the distance of his nearest pawn to the top of the board is less than or equal to the distance of the Player’s B nearest pawn to the bottom of the board (Note that you should only consider pawns that are not blocked by another pawns).Problem B. The monster and the squirrelAfter drawing the rays from the first vertex (n - 2) triangles are formed. The subsequent rays will generate independently sub-regions in these triangles. Let's analyse the triangle determined by vertices 1, i, i + 1, after drawing the rays from vertex i and (i + 1) the triangle will be divided into (n - i) + (i - 2) = n - 2 regions. Therefore the total number of convex regions is (n - 2)2If the squirrel starts from the region that have 1 as a vertex, then she can go through each region of triangle (1, i, i + 1) once. That implies that the squirrel can collect all the walnuts in (n - 2)2 jumps.Problem C. The Big RaceLet D be the length of the racetrack, Since both athletes should tie . Let M = lcm(B, W), then D = k·M + r. None of the athletes should give one step further, therefore r ≤ min{B - 1, W - 1, T} = X. D must be greater than 0 and less than or equal to T so  - r / M < k ≤ (T - r) / M. For r = 0, the number of valid racetracks is , and for r > 0 the number of racetracks is . Iterating over all possible r, we can count the number of racetracks in which Willman and Bolt ties: Note that . That means that for exactly M values of r. We can count the number of values of r in which , and the values of r in which . Each of the remaining values v1 - 1, v1 - 2, ..., v2 + 1 will appear exactly M times.Problem D. Super MObservation 1: Ari should teleport to one of the attacked cities (it doesn't worth going to a city that is not attacked since then she should go to one of the attacked cities)Observation 2: The nodes visited by Ari will determine a sub-tree T of the original tree, this tree is unique and is determined by all the paths from two attacked cities.Observation 3: If Ari had to return to the city from where she started, then the total distance would be 2e, where e is the number of edges of T, that is because she goes through each edge forward and backwardObservation 4: If Ari does not have to return to the starting city (the root of T), then the total distance is 2e - L, where L is the distance of the farthest node from the rootObservation 5: In order to get a minimum total distance, Ari should chose one diameter of the tree, and teleport to one of its leaves.The problem is now transformed in finding the diameter of a tree that contains the smallest index for one of its leaves. Note that all diameters pass through the center of the tree, so we can find all the farthest nodes from the center...and [details omitted].Problem E. BCPCLet’s represent the reading and writing speeds of the students as points in a plane. Two students i, j are compatible if ri'·wj' - rj'·wi' > 0 this equation is identical to the cross product: (ri', wi') × (rj', wj′) > 0. Using this fact is easy to see that three students i, j, k are compatible if the triangle (ri, wi), (rj, wj), (rk, wk) contains the point (x, y). So the problem is reduced to count the number of triangles that contains the origin.Let’s count the triangles that have two known vertices i and j (look at the picture above). It is easy to see that the third vertex should be inside the region S. So now we have to be able of counting points that are between two rays, that can be done using binary search (ordering the points first by slope and then by the distance to the origin).Now given a point i, let’s count the triangles that have i as a vertex (look at the picture above again). We have to count the points that lie between the ray iO, and every other ray jO (the angle between iO and jO must be  ≤ 180). Let Sj denote the number points that are between the rays OR and jO, then the number of triangles that have i as a vertex are . This summation can be calculated if we pre-calculate the cumulative sums of Sj. The overall complexity is O(n·log(n)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21318",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4065
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 1",
          "code": "#define ull unsigned long long\nbool overFlow(ull a, ull b) {\n    return ((a*b)/b == a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 2",
          "code": "#define ull unsigned long long\nbool overFlow(ull a, ull b) {\n    return ((a*b)/b == a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 3",
          "code": "if (minA < minB) cout << \"A\\n\";\nelse cout << \"B\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 4",
          "code": "if (minA < minB) cout << \"A\\n\";\nelse cout << \"B\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 5",
          "code": "........\n..B.....\n......W.\n..W.....\n........\n........\n..B.....\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 6",
          "code": "........\n..B.....\n......W.\n..W.....\n........\n........\n..B.....\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 7",
          "code": "........\n.W......\n........\n........\n........\n........\n......B.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 8",
          "code": "........\n.W......\n........\n........\n........\n........\n......B.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 9",
          "code": "#include <iostream>\nusing namespace std;\nint main() {\n  cout << sizeof(long double) << endl;\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 10",
          "code": "#include <iostream>\nusing namespace std;\nint main() {\n  cout << sizeof(long double) << endl;\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 11",
          "code": "#include <iostream>  using namespace std;  int main(int argc, char **argv){  int points;  cin >> points; unsigned long long answer = 1 + (points-3) + 2*(points-3) + (points-3)*(points-4);  cout << answer << endl;  return 0;  }",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 12",
          "code": "#include <iostream>  using namespace std;  int main(int argc, char **argv){  int points;  cin >> points; unsigned long long answer = 1 + (points-3) + 2*(points-3) + (points-3)*(points-4);  cout << answer << endl;  return 0;  }",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces - Code 1",
          "code": "__builtin_mul_overflow",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21318",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces - Code 2",
          "code": "int max_r = min(min(b,w)-1, t);\nint ans = t / lcm;\nfor (int r = 1; r <= max_r; ) {\nint v = (T-r)/lcm;\nint mfar = min(max_r, t - v * lcm);\nans += (mfar - r + 1) * (v + 1);\nr = mfar + 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21318",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces - Code 3",
          "code": "int max_r = min(min(b,w)-1, t);\nint ans = t / lcm;\nfor (int r = 1; r <= max_r; ) {\nint v = (T-r)/lcm;\nint mfar = min(max_r, t - v * lcm);\nans += (mfar - r + 1) * (v + 1);\nr = mfar + 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21318",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 54321);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 54321);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 54321);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n\n    if (n != -1) {\n        // Use the provided n.\n    } else {\n        int min_n = opt<int>(\"min_n\", 3);\n        int max_n = opt<int>(\"max_n\", 54321);\n        string type = opt<string>(\"type\", \"random\");\n\n        if(type == \"min\") {\n            n = 3;\n        } else if(type == \"max\") {\n            n = 54321;\n        } else if(type == \"small\") {\n            n = rnd.next(3, 100);\n        } else if(type == \"large\") {\n            n = rnd.next(54300, 54321);\n        } else if(type == \"odd\") {\n            n = rnd.next((min_n+1)/2, max_n/2)*2 +1;\n            if(n > max_n) n -= 2;\n        } else if(type == \"even\") {\n            n = rnd.next(min_n/2, max_n/2)*2;\n            if(n < min_n) n +=2;\n        } else { // random\n            n = rnd.next(min_n, max_n);\n        }\n    }\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n\n    if (n != -1) {\n        // Use the provided n.\n    } else {\n        int min_n = opt<int>(\"min_n\", 3);\n        int max_n = opt<int>(\"max_n\", 54321);\n        string type = opt<string>(\"type\", \"random\");\n\n        if(type == \"min\") {\n            n = 3;\n        } else if(type == \"max\") {\n            n = 54321;\n        } else if(type == \"small\") {\n            n = rnd.next(3, 100);\n        } else if(type == \"large\") {\n            n = rnd.next(54300, 54321);\n        } else if(type == \"odd\") {\n            n = rnd.next((min_n+1)/2, max_n/2)*2 +1;\n            if(n > max_n) n -= 2;\n        } else if(type == \"even\") {\n            n = rnd.next(min_n/2, max_n/2)*2;\n            if(n < min_n) n +=2;\n        } else { // random\n            n = rnd.next(min_n, max_n);\n        }\n    }\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 6\n./gen -n 7\n./gen -n 8\n./gen -n 9\n./gen -n 10\n./gen -n 11\n./gen -n 12\n./gen -n 13\n./gen -n 14\n./gen -n 15\n./gen -n 16\n./gen -n 17\n./gen -n 54321\n./gen -n 54320\n./gen -n 54319\n./gen -n 50000\n./gen -n 40000\n./gen -n 30000\n./gen -n 20000\n./gen -n 10000\n./gen -n 5000\n./gen -n 1000\n./gen -n 100\n./gen -n 200\n./gen -n 300\n./gen -n 400\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:47.212836",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "592/C",
      "title": "C. Важные гонки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записаны три целых числа t, w и b (1 ≤ t, w, b ≤ 5·1018) — максимально возможная длина забега, длина шага Уиллмана и длина шага Болта соответственно.",
      "output_spec": "Выходные данныеВыведите ответ на задачу в виде несократимой дроби . Следуйте формату вывода указанному в примерах.Дробь  (p и q целые, при этом p ≥ 0 и q > 0) называется несократимой, если не существует такого целого числа d > 1, что и p и q делятся на d.",
      "sample_tests": "ПримерыВходные данныеСкопировать10 3 2Выходные данныеСкопировать3/10Входные данныеСкопировать7 1 2Выходные данныеСкопировать3/7",
      "description": "C. Важные гонки\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных записаны три целых числа t, w и b (1 ≤ t, w, b ≤ 5·1018) — максимально возможная длина забега, длина шага Уиллмана и длина шага Болта соответственно.\n\nВходные данные\n\nВыходные данныеВыведите ответ на задачу в виде несократимой дроби . Следуйте формату вывода указанному в примерах.Дробь  (p и q целые, при этом p ≥ 0 и q > 0) называется несократимой, если не существует такого целого числа d > 1, что и p и q делятся на d.\n\nВыходные данные\n\nВходные данныеСкопировать10 3 2Выходные данныеСкопировать3/10Входные данныеСкопировать7 1 2Выходные данныеСкопировать3/7\n\nВходные данныеСкопировать10 3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3/10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3/7\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Уиллман и Болт сразятся в ничью в случае, если в качестве дистанции будут выбраны 1, 6 или 7.",
      "solutions": [
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces",
          "content": "Codeforces Round #328 (Div. 2) will take place on October 31, 19:30 MSK, as usual Div. 1 participants can join out of competition.Problem Setter: Morphy (Alei Reyes)Coordinator: GlebsHP (Gleb Evstropov)English to Russian translator: Delinur (Maria Belova) Codeforces and Polygon: MikeMirzayanov (Mike Mirzayanov)Hope you enjoy the problem set.The score distribution will be announced later.UPD. Score Distribution: 500 — 1000 — 1500 — 2000 — 3000UPD. Problem Analysis is availableCongrats to the winners!Div. 2shamir0xelbn187SuperLoserDiv. 1uwiNanoApeHaghani",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21284",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 558
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces",
          "content": "Problem A. PawnChessPlayer A wins if the distance of his nearest pawn to the top of the board is less than or equal to the distance of the Player’s B nearest pawn to the bottom of the board (Note that you should only consider pawns that are not blocked by another pawns).Problem B. The monster and the squirrelAfter drawing the rays from the first vertex (n - 2) triangles are formed. The subsequent rays will generate independently sub-regions in these triangles. Let's analyse the triangle determined by vertices 1, i, i + 1, after drawing the rays from vertex i and (i + 1) the triangle will be divided into (n - i) + (i - 2) = n - 2 regions. Therefore the total number of convex regions is (n - 2)2If the squirrel starts from the region that have 1 as a vertex, then she can go through each region of triangle (1, i, i + 1) once. That implies that the squirrel can collect all the walnuts in (n - 2)2 jumps.Problem C. The Big RaceLet D be the length of the racetrack, Since both athletes should tie . Let M = lcm(B, W), then D = k·M + r. None of the athletes should give one step further, therefore r ≤ min{B - 1, W - 1, T} = X. D must be greater than 0 and less than or equal to T so  - r / M < k ≤ (T - r) / M. For r = 0, the number of valid racetracks is , and for r > 0 the number of racetracks is . Iterating over all possible r, we can count the number of racetracks in which Willman and Bolt ties: Note that . That means that for exactly M values of r. We can count the number of values of r in which , and the values of r in which . Each of the remaining values v1 - 1, v1 - 2, ..., v2 + 1 will appear exactly M times.Problem D. Super MObservation 1: Ari should teleport to one of the attacked cities (it doesn't worth going to a city that is not attacked since then she should go to one of the attacked cities)Observation 2: The nodes visited by Ari will determine a sub-tree T of the original tree, this tree is unique and is determined by all the paths from two attacked cities.Observation 3: If Ari had to return to the city from where she started, then the total distance would be 2e, where e is the number of edges of T, that is because she goes through each edge forward and backwardObservation 4: If Ari does not have to return to the starting city (the root of T), then the total distance is 2e - L, where L is the distance of the farthest node from the rootObservation 5: In order to get a minimum total distance, Ari should chose one diameter of the tree, and teleport to one of its leaves.The problem is now transformed in finding the diameter of a tree that contains the smallest index for one of its leaves. Note that all diameters pass through the center of the tree, so we can find all the farthest nodes from the center...and [details omitted].Problem E. BCPCLet’s represent the reading and writing speeds of the students as points in a plane. Two students i, j are compatible if ri'·wj' - rj'·wi' > 0 this equation is identical to the cross product: (ri', wi') × (rj', wj′) > 0. Using this fact is easy to see that three students i, j, k are compatible if the triangle (ri, wi), (rj, wj), (rk, wk) contains the point (x, y). So the problem is reduced to count the number of triangles that contains the origin.Let’s count the triangles that have two known vertices i and j (look at the picture above). It is easy to see that the third vertex should be inside the region S. So now we have to be able of counting points that are between two rays, that can be done using binary search (ordering the points first by slope and then by the distance to the origin).Now given a point i, let’s count the triangles that have i as a vertex (look at the picture above again). We have to count the points that lie between the ray iO, and every other ray jO (the angle between iO and jO must be  ≤ 180). Let Sj denote the number points that are between the rays OR and jO, then the number of triangles that have i as a vertex are . This summation can be calculated if we pre-calculate the cumulative sums of Sj. The overall complexity is O(n·log(n)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21318",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4065
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 1",
          "code": "#define ull unsigned long long\nbool overFlow(ull a, ull b) {\n    return ((a*b)/b == a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 2",
          "code": "#define ull unsigned long long\nbool overFlow(ull a, ull b) {\n    return ((a*b)/b == a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 3",
          "code": "if (minA < minB) cout << \"A\\n\";\nelse cout << \"B\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 4",
          "code": "if (minA < minB) cout << \"A\\n\";\nelse cout << \"B\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 5",
          "code": "........\n..B.....\n......W.\n..W.....\n........\n........\n..B.....\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 6",
          "code": "........\n..B.....\n......W.\n..W.....\n........\n........\n..B.....\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 7",
          "code": "........\n.W......\n........\n........\n........\n........\n......B.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 8",
          "code": "........\n.W......\n........\n........\n........\n........\n......B.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 9",
          "code": "#include <iostream>\nusing namespace std;\nint main() {\n  cout << sizeof(long double) << endl;\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 10",
          "code": "#include <iostream>\nusing namespace std;\nint main() {\n  cout << sizeof(long double) << endl;\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 11",
          "code": "#include <iostream>  using namespace std;  int main(int argc, char **argv){  int points;  cin >> points; unsigned long long answer = 1 + (points-3) + 2*(points-3) + (points-3)*(points-4);  cout << answer << endl;  return 0;  }",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 12",
          "code": "#include <iostream>  using namespace std;  int main(int argc, char **argv){  int points;  cin >> points; unsigned long long answer = 1 + (points-3) + 2*(points-3) + (points-3)*(points-4);  cout << answer << endl;  return 0;  }",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces - Code 1",
          "code": "__builtin_mul_overflow",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21318",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces - Code 2",
          "code": "int max_r = min(min(b,w)-1, t);\nint ans = t / lcm;\nfor (int r = 1; r <= max_r; ) {\nint v = (T-r)/lcm;\nint mfar = min(max_r, t - v * lcm);\nans += (mfar - r + 1) * (v + 1);\nr = mfar + 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21318",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces - Code 3",
          "code": "int max_r = min(min(b,w)-1, t);\nint ans = t / lcm;\nfor (int r = 1; r <= max_r; ) {\nint v = (T-r)/lcm;\nint mfar = min(max_r, t - v * lcm);\nans += (mfar - r + 1) * (v + 1);\nr = mfar + 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21318",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long t = inf.readLong(1, 5000000000000000000LL, \"t\");\n    inf.readSpace();\n    long long w = inf.readLong(1, 5000000000000000000LL, \"w\");\n    inf.readSpace();\n    long long b = inf.readLong(1, 5000000000000000000LL, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long t = inf.readLong(1, 5000000000000000000LL, \"t\");\n    inf.readSpace();\n    long long w = inf.readLong(1, 5000000000000000000LL, \"w\");\n    inf.readSpace();\n    long long b = inf.readLong(1, 5000000000000000000LL, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long t = inf.readLong(1, 5000000000000000000LL, \"t\");\n    inf.readSpace();\n    long long w = inf.readLong(1, 5000000000000000000LL, \"w\");\n    inf.readSpace();\n    long long b = inf.readLong(1, 5000000000000000000LL, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    long long t = opt<long long>(\"t\", -1);\n    long long w = opt<long long>(\"w\", -1);\n    long long b = opt<long long>(\"b\", -1);\n\n    const long long MAX_VAL = (long long)5e18;\n\n    if (type == \"equal\") {\n        // w = b\n        if (w == -1)\n            w = rnd.next(1LL, MAX_VAL);\n        b = w;\n        if (t == -1)\n            t = rnd.next(1LL, MAX_VAL);\n    } else if (type == \"w_divides_b\") {\n        if (w == -1)\n            w = rnd.next(1LL, (long long)1e9);\n        long long maxK = MAX_VAL / w;\n        long long k = rnd.next(2LL, max(2LL, maxK));\n        b = w * k;\n        if (t == -1)\n            t = rnd.next(1LL, MAX_VAL);\n    } else if (type == \"b_divides_w\") {\n        if (b == -1)\n            b = rnd.next(1LL, (long long)1e9);\n        long long maxK = MAX_VAL / b;\n        long long k = rnd.next(2LL, max(2LL, maxK));\n        w = b * k;\n        if (t == -1)\n            t = rnd.next(1LL, MAX_VAL);\n    } else if (type == \"coprime\") {\n        // Generate w and b that are coprime\n        if (w == -1 || b == -1) {\n            while (true) {\n                w = rnd.next(1LL, MAX_VAL);\n                b = rnd.next(1LL, MAX_VAL);\n                if (__gcd(w, b) == 1)\n                    break;\n            }\n        }\n        if (t == -1)\n            t = rnd.next(1LL, MAX_VAL);\n    } else if (type == \"max\") {\n        t = MAX_VAL;\n        w = MAX_VAL;\n        b = MAX_VAL;\n    } else if (type == \"small_t\") {\n        t = rnd.next(1LL, 10LL);\n        if (w == -1)\n            w = rnd.next(1LL, MAX_VAL);\n        if (b == -1)\n            b = rnd.next(1LL, MAX_VAL);\n    } else if (type == \"small_wb\") {\n        if (t == -1)\n            t = rnd.next(1LL, MAX_VAL);\n        w = rnd.next(1LL, 10LL);\n        b = rnd.next(1LL, 10LL);\n    } else if (type == \"t_less_than_wb\") {\n        if (t == -1)\n            t = rnd.next(1LL, (long long)1e6);\n        if (w == -1)\n            w = rnd.next(t + 1, MAX_VAL);\n        if (b == -1)\n            b = rnd.next(t + 1, MAX_VAL);\n    } else if (type == \"t_equals_wb\") {\n        if (w == -1)\n            w = rnd.next(1LL, MAX_VAL);\n        if (b == -1)\n            b = rnd.next(1LL, MAX_VAL);\n        if (rnd.next(2))\n            t = w;\n        else\n            t = b;\n    } else if (type == \"random\") {\n        t = rnd.next(1LL, MAX_VAL);\n        w = rnd.next(1LL, MAX_VAL);\n        b = rnd.next(1LL, MAX_VAL);\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Ensure t, w, b are within [1, 5e18]\n    t = max(1LL, min(t, MAX_VAL));\n    w = max(1LL, min(w, MAX_VAL));\n    b = max(1LL, min(b, MAX_VAL));\n\n    // Output t, w, b\n    printf(\"%lld %lld %lld\\n\", t, w, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    long long t = opt<long long>(\"t\", -1);\n    long long w = opt<long long>(\"w\", -1);\n    long long b = opt<long long>(\"b\", -1);\n\n    const long long MAX_VAL = (long long)5e18;\n\n    if (type == \"equal\") {\n        // w = b\n        if (w == -1)\n            w = rnd.next(1LL, MAX_VAL);\n        b = w;\n        if (t == -1)\n            t = rnd.next(1LL, MAX_VAL);\n    } else if (type == \"w_divides_b\") {\n        if (w == -1)\n            w = rnd.next(1LL, (long long)1e9);\n        long long maxK = MAX_VAL / w;\n        long long k = rnd.next(2LL, max(2LL, maxK));\n        b = w * k;\n        if (t == -1)\n            t = rnd.next(1LL, MAX_VAL);\n    } else if (type == \"b_divides_w\") {\n        if (b == -1)\n            b = rnd.next(1LL, (long long)1e9);\n        long long maxK = MAX_VAL / b;\n        long long k = rnd.next(2LL, max(2LL, maxK));\n        w = b * k;\n        if (t == -1)\n            t = rnd.next(1LL, MAX_VAL);\n    } else if (type == \"coprime\") {\n        // Generate w and b that are coprime\n        if (w == -1 || b == -1) {\n            while (true) {\n                w = rnd.next(1LL, MAX_VAL);\n                b = rnd.next(1LL, MAX_VAL);\n                if (__gcd(w, b) == 1)\n                    break;\n            }\n        }\n        if (t == -1)\n            t = rnd.next(1LL, MAX_VAL);\n    } else if (type == \"max\") {\n        t = MAX_VAL;\n        w = MAX_VAL;\n        b = MAX_VAL;\n    } else if (type == \"small_t\") {\n        t = rnd.next(1LL, 10LL);\n        if (w == -1)\n            w = rnd.next(1LL, MAX_VAL);\n        if (b == -1)\n            b = rnd.next(1LL, MAX_VAL);\n    } else if (type == \"small_wb\") {\n        if (t == -1)\n            t = rnd.next(1LL, MAX_VAL);\n        w = rnd.next(1LL, 10LL);\n        b = rnd.next(1LL, 10LL);\n    } else if (type == \"t_less_than_wb\") {\n        if (t == -1)\n            t = rnd.next(1LL, (long long)1e6);\n        if (w == -1)\n            w = rnd.next(t + 1, MAX_VAL);\n        if (b == -1)\n            b = rnd.next(t + 1, MAX_VAL);\n    } else if (type == \"t_equals_wb\") {\n        if (w == -1)\n            w = rnd.next(1LL, MAX_VAL);\n        if (b == -1)\n            b = rnd.next(1LL, MAX_VAL);\n        if (rnd.next(2))\n            t = w;\n        else\n            t = b;\n    } else if (type == \"random\") {\n        t = rnd.next(1LL, MAX_VAL);\n        w = rnd.next(1LL, MAX_VAL);\n        b = rnd.next(1LL, MAX_VAL);\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Ensure t, w, b are within [1, 5e18]\n    t = max(1LL, min(t, MAX_VAL));\n    w = max(1LL, min(w, MAX_VAL));\n    b = max(1LL, min(b, MAX_VAL));\n\n    // Output t, w, b\n    printf(\"%lld %lld %lld\\n\", t, w, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Equal w and b\n./gen -type equal -w 1\n./gen -type equal -w 5\n./gen -type equal -w 1000\n./gen -type equal -w 1000000000\n./gen -type equal -w 1000000000000000000\n\n# w divides b\n./gen -type w_divides_b -w 1\n./gen -type w_divides_b -w 2\n./gen -type w_divides_b -w 1000000000\n./gen -type w_divides_b -w 100000000000000\n\n# b divides w\n./gen -type b_divides_w -b 1\n./gen -type b_divides_w -b 2\n./gen -type b_divides_w -b 1000000000\n./gen -type b_divides_w -b 100000000000000\n\n# Coprime w and b\n./gen -type coprime\n./gen -type coprime\n\n# Maximum values\n./gen -type max\n\n# Small t\n./gen -type small_t\n./gen -type small_t\n\n# Small w and b\n./gen -type small_wb\n./gen -type small_wb\n\n# t less than w and b\n./gen -type t_less_than_wb\n./gen -type t_less_than_wb\n\n# t equals w or b\n./gen -type t_equals_wb\n./gen -type t_equals_wb\n\n# Random large values\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:49.165839",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "592/D",
      "title": "D. Супер М",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записаны два целых числа n и m (1 ≤ m ≤ n ≤ 123456) — количество городов в Байтфорсес, и количество атакуемых городов, соответственно.Далее следует n - 1 строка, описывающая систему дорог. Каждая строка состоит из двух номеров городов ui и vi (1 ≤ ui, vi ≤ n) — концы очередной дороги.Последняя строка содержит m различных целых чисел — номера атакуемых городов. Эти числа даны в произвольном порядке.",
      "output_spec": "Выходные данныеСперва выведите номер города, куда надо телепортироваться Супер М. Если оптимальных ответов несколько, выведите город с наименьшим номером.Затем выведите наименьшее возможное время, необходимое для того, чтобы распугать всех людей в атакуемых городах, измеренное в кронах.Обратите внимание, что правильный ответ всегда единственен.",
      "sample_tests": "ПримерыВходные данныеСкопировать7 21 21 31 43 53 63 72 7Выходные данныеСкопировать23Входные данныеСкопировать6 41 22 32 44 54 62 4 5 6Выходные данныеСкопировать24",
      "description": "ограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных записаны два целых числа n и m (1 ≤ m ≤ n ≤ 123456) — количество городов в Байтфорсес, и количество атакуемых городов, соответственно.Далее следует n - 1 строка, описывающая систему дорог. Каждая строка состоит из двух номеров городов ui и vi (1 ≤ ui, vi ≤ n) — концы очередной дороги.Последняя строка содержит m различных целых чисел — номера атакуемых городов. Эти числа даны в произвольном порядке.\n\nВходные данные\n\nВыходные данныеСперва выведите номер города, куда надо телепортироваться Супер М. Если оптимальных ответов несколько, выведите город с наименьшим номером.Затем выведите наименьшее возможное время, необходимое для того, чтобы распугать всех людей в атакуемых городах, измеренное в кронах.Обратите внимание, что правильный ответ всегда единственен.\n\nВыходные данные\n\nВходные данныеСкопировать7 21 21 31 43 53 63 72 7Выходные данныеСкопировать23Входные данныеСкопировать6 41 22 32 44 54 62 4 5 6Выходные данныеСкопировать24\n\nВходные данныеСкопировать7 21 21 31 43 53 63 72 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать23\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 41 22 32 44 54 62 4 5 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать24\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере есть две возможности завершить работу Супер М за 3 крона: and .Однако вам следует выбрать первый вариант, так как он начинается в городе с меньшим номером.",
      "solutions": [
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces",
          "content": "Codeforces Round #328 (Div. 2) will take place on October 31, 19:30 MSK, as usual Div. 1 participants can join out of competition.Problem Setter: Morphy (Alei Reyes)Coordinator: GlebsHP (Gleb Evstropov)English to Russian translator: Delinur (Maria Belova) Codeforces and Polygon: MikeMirzayanov (Mike Mirzayanov)Hope you enjoy the problem set.The score distribution will be announced later.UPD. Score Distribution: 500 — 1000 — 1500 — 2000 — 3000UPD. Problem Analysis is availableCongrats to the winners!Div. 2shamir0xelbn187SuperLoserDiv. 1uwiNanoApeHaghani",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21284",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 558
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces",
          "content": "Problem A. PawnChessPlayer A wins if the distance of his nearest pawn to the top of the board is less than or equal to the distance of the Player’s B nearest pawn to the bottom of the board (Note that you should only consider pawns that are not blocked by another pawns).Problem B. The monster and the squirrelAfter drawing the rays from the first vertex (n - 2) triangles are formed. The subsequent rays will generate independently sub-regions in these triangles. Let's analyse the triangle determined by vertices 1, i, i + 1, after drawing the rays from vertex i and (i + 1) the triangle will be divided into (n - i) + (i - 2) = n - 2 regions. Therefore the total number of convex regions is (n - 2)2If the squirrel starts from the region that have 1 as a vertex, then she can go through each region of triangle (1, i, i + 1) once. That implies that the squirrel can collect all the walnuts in (n - 2)2 jumps.Problem C. The Big RaceLet D be the length of the racetrack, Since both athletes should tie . Let M = lcm(B, W), then D = k·M + r. None of the athletes should give one step further, therefore r ≤ min{B - 1, W - 1, T} = X. D must be greater than 0 and less than or equal to T so  - r / M < k ≤ (T - r) / M. For r = 0, the number of valid racetracks is , and for r > 0 the number of racetracks is . Iterating over all possible r, we can count the number of racetracks in which Willman and Bolt ties: Note that . That means that for exactly M values of r. We can count the number of values of r in which , and the values of r in which . Each of the remaining values v1 - 1, v1 - 2, ..., v2 + 1 will appear exactly M times.Problem D. Super MObservation 1: Ari should teleport to one of the attacked cities (it doesn't worth going to a city that is not attacked since then she should go to one of the attacked cities)Observation 2: The nodes visited by Ari will determine a sub-tree T of the original tree, this tree is unique and is determined by all the paths from two attacked cities.Observation 3: If Ari had to return to the city from where she started, then the total distance would be 2e, where e is the number of edges of T, that is because she goes through each edge forward and backwardObservation 4: If Ari does not have to return to the starting city (the root of T), then the total distance is 2e - L, where L is the distance of the farthest node from the rootObservation 5: In order to get a minimum total distance, Ari should chose one diameter of the tree, and teleport to one of its leaves.The problem is now transformed in finding the diameter of a tree that contains the smallest index for one of its leaves. Note that all diameters pass through the center of the tree, so we can find all the farthest nodes from the center...and [details omitted].Problem E. BCPCLet’s represent the reading and writing speeds of the students as points in a plane. Two students i, j are compatible if ri'·wj' - rj'·wi' > 0 this equation is identical to the cross product: (ri', wi') × (rj', wj′) > 0. Using this fact is easy to see that three students i, j, k are compatible if the triangle (ri, wi), (rj, wj), (rk, wk) contains the point (x, y). So the problem is reduced to count the number of triangles that contains the origin.Let’s count the triangles that have two known vertices i and j (look at the picture above). It is easy to see that the third vertex should be inside the region S. So now we have to be able of counting points that are between two rays, that can be done using binary search (ordering the points first by slope and then by the distance to the origin).Now given a point i, let’s count the triangles that have i as a vertex (look at the picture above again). We have to count the points that lie between the ray iO, and every other ray jO (the angle between iO and jO must be  ≤ 180). Let Sj denote the number points that are between the rays OR and jO, then the number of triangles that have i as a vertex are . This summation can be calculated if we pre-calculate the cumulative sums of Sj. The overall complexity is O(n·log(n)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21318",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4065
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 1",
          "code": "#define ull unsigned long long\nbool overFlow(ull a, ull b) {\n    return ((a*b)/b == a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 2",
          "code": "#define ull unsigned long long\nbool overFlow(ull a, ull b) {\n    return ((a*b)/b == a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 3",
          "code": "if (minA < minB) cout << \"A\\n\";\nelse cout << \"B\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 4",
          "code": "if (minA < minB) cout << \"A\\n\";\nelse cout << \"B\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 5",
          "code": "........\n..B.....\n......W.\n..W.....\n........\n........\n..B.....\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 6",
          "code": "........\n..B.....\n......W.\n..W.....\n........\n........\n..B.....\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 7",
          "code": "........\n.W......\n........\n........\n........\n........\n......B.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 8",
          "code": "........\n.W......\n........\n........\n........\n........\n......B.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 9",
          "code": "#include <iostream>\nusing namespace std;\nint main() {\n  cout << sizeof(long double) << endl;\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 10",
          "code": "#include <iostream>\nusing namespace std;\nint main() {\n  cout << sizeof(long double) << endl;\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 11",
          "code": "#include <iostream>  using namespace std;  int main(int argc, char **argv){  int points;  cin >> points; unsigned long long answer = 1 + (points-3) + 2*(points-3) + (points-3)*(points-4);  cout << answer << endl;  return 0;  }",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 12",
          "code": "#include <iostream>  using namespace std;  int main(int argc, char **argv){  int points;  cin >> points; unsigned long long answer = 1 + (points-3) + 2*(points-3) + (points-3)*(points-4);  cout << answer << endl;  return 0;  }",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces - Code 1",
          "code": "__builtin_mul_overflow",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21318",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces - Code 2",
          "code": "int max_r = min(min(b,w)-1, t);\nint ans = t / lcm;\nfor (int r = 1; r <= max_r; ) {\nint v = (T-r)/lcm;\nint mfar = min(max_r, t - v * lcm);\nans += (mfar - r + 1) * (v + 1);\nr = mfar + 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21318",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces - Code 3",
          "code": "int max_r = min(min(b,w)-1, t);\nint ans = t / lcm;\nfor (int r = 1; r <= max_r; ) {\nint v = (T-r)/lcm;\nint mfar = min(max_r, t - v * lcm);\nans += (mfar - r + 1) * (v + 1);\nr = mfar + 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21318",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u != v)\n        parent[u] = v;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 123456, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    parent.resize(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    set<pair<int,int>> edgeSet;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge %d connects a node to itself: u=%d v=%d\", i+1, u, v);\n\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int,int> edge = make_pair(a, b);\n        ensuref(edgeSet.count(edge) == 0, \"Duplicate edge between cities %d and %d\", a, b);\n        edgeSet.insert(edge);\n\n        unite(u, v);\n    }\n\n    // Check that the graph is connected\n    int components = 0;\n    for (int i = 1; i <= n; ++i)\n        if (parent[i] == i)\n            ++components;\n    ensuref(components == 1, \"The graph is not connected; it has %d connected components\", components);\n\n    vector<int> attackedCities = inf.readInts(m, 1, n);\n    inf.readEoln();\n\n    set<int> attackedSet(attackedCities.begin(), attackedCities.end());\n    ensuref((int)attackedSet.size() == m, \"Attacked cities are not distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u != v)\n        parent[u] = v;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 123456, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    parent.resize(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    set<pair<int,int>> edgeSet;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge %d connects a node to itself: u=%d v=%d\", i+1, u, v);\n\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int,int> edge = make_pair(a, b);\n        ensuref(edgeSet.count(edge) == 0, \"Duplicate edge between cities %d and %d\", a, b);\n        edgeSet.insert(edge);\n\n        unite(u, v);\n    }\n\n    // Check that the graph is connected\n    int components = 0;\n    for (int i = 1; i <= n; ++i)\n        if (parent[i] == i)\n            ++components;\n    ensuref(components == 1, \"The graph is not connected; it has %d connected components\", components);\n\n    vector<int> attackedCities = inf.readInts(m, 1, n);\n    inf.readEoln();\n\n    set<int> attackedSet(attackedCities.begin(), attackedCities.end());\n    ensuref((int)attackedSet.size() == m, \"Attacked cities are not distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u != v)\n        parent[u] = v;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 123456, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    parent.resize(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    set<pair<int,int>> edgeSet;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge %d connects a node to itself: u=%d v=%d\", i+1, u, v);\n\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int,int> edge = make_pair(a, b);\n        ensuref(edgeSet.count(edge) == 0, \"Duplicate edge between cities %d and %d\", a, b);\n        edgeSet.insert(edge);\n\n        unite(u, v);\n    }\n\n    // Check that the graph is connected\n    int components = 0;\n    for (int i = 1; i <= n; ++i)\n        if (parent[i] == i)\n            ++components;\n    ensuref(components == 1, \"The graph is not connected; it has %d connected components\", components);\n\n    vector<int> attackedCities = inf.readInts(m, 1, n);\n    inf.readEoln();\n\n    set<int> attackedSet(attackedCities.begin(), attackedCities.end());\n    ensuref((int)attackedSet.size() == m, \"Attacked cities are not distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    string attack_type = opt<string>(\"attack_type\", \"random\");\n\n    // Adjust m according to attack_type if necessary\n    if (attack_type == \"one\") {\n        m = 1;\n    } else if (attack_type == \"all\") {\n        m = n;\n    } else if (m == -1) {\n        // If m is not specified, default to n/2\n        m = n / 2;\n    }\n    // Ensure m is within [1, n]\n    if (m < 1) m = 1;\n    if (m > n) m = n;\n\n    // Now, generate the tree according to 'type'\n    vector<pair<int, int> > edges;\n    vector<vector<int> > adj(n + 1);\n\n    if (type == \"chain\") {\n        // Generate a chain\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n            adj[i - 1].push_back(i);\n            adj[i].push_back(i - 1);\n        }\n    } else if (type == \"star\") {\n        // Node 1 connected to all other nodes\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n            adj[1].push_back(i);\n            adj[i].push_back(1);\n        }\n    } else if (type == \"balanced\") {\n        // Generate a balanced binary tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i / 2, i});\n            adj[i / 2].push_back(i);\n            adj[i].push_back(i / 2);\n        }\n    } else if (type == \"unbalanced\") {\n        // Generate an unbalanced tree\n        // We can make a chain with extra leaves attached to nodes\n        int current = 1;\n        for (int i = current + 1; i <= n; ++i) {\n            edges.push_back({current, i});\n            adj[current].push_back(i);\n            adj[i].push_back(current);\n            if (rnd.next(0, 1) == 1) {\n                current = i;\n            }\n        }\n    } else if (type == \"path-with-leaves\") {\n        // Generate a path and then attach leaves\n        int path_length = n / 2;\n        if (path_length < 1) path_length = 1;\n        for (int i = 2; i <= path_length; ++i) {\n            edges.push_back({i - 1, i});\n            adj[i - 1].push_back(i);\n            adj[i].push_back(i - 1);\n        }\n        for (int i = path_length + 1; i <= n; ++i) {\n            int attach_to = rnd.next(1, path_length);\n            edges.push_back({attach_to, i});\n            adj[attach_to].push_back(i);\n            adj[i].push_back(attach_to);\n        }\n    } else if (type == \"random\") {\n        // Generate a random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n            adj[parent].push_back(i);\n            adj[i].push_back(parent);\n        }\n    } else {\n        // Default to random\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n            adj[parent].push_back(i);\n            adj[i].push_back(parent);\n        }\n    }\n\n    // Now, select m attacked cities according to 'attack_type'\n    set<int> attacked_cities_set;\n    vector<int> attacked_cities;\n    if (attack_type == \"random\") {\n        while ((int)attacked_cities_set.size() < m) {\n            int node = rnd.next(1, n);\n            attacked_cities_set.insert(node);\n        }\n    } else if (attack_type == \"leaves\") {\n        vector<int> leaves;\n        for (int i = 1; i <= n; ++i) {\n            if (adj[i].size() == 1) {\n                leaves.push_back(i);\n            }\n        }\n        if ((int)leaves.size() < m) {\n            // If not enough leaves, fill with other nodes\n            for (int i = 1; i <= n; ++i) {\n                if (adj[i].size() != 1) {\n                    leaves.push_back(i);\n                }\n            }\n        }\n        shuffle(leaves.begin(), leaves.end());\n        for (int i = 0; i < m && i < (int)leaves.size(); ++i) {\n            attacked_cities_set.insert(leaves[i]);\n        }\n    } else if (attack_type == \"deep\") {\n        // Find deepest nodes\n        vector<int> depth(n + 1, 0);\n        function<void(int, int)> dfs = [&](int u, int p) {\n            for (int v : adj[u]) {\n                if (v != p) {\n                    depth[v] = depth[u] + 1;\n                    dfs(v, u);\n                }\n            }\n        };\n        dfs(1, -1);\n        vector<pair<int, int>> depth_nodes;\n        for (int i = 1; i <= n; ++i) {\n            depth_nodes.push_back({depth[i], i});\n        }\n        sort(depth_nodes.rbegin(), depth_nodes.rend());\n        for (int i = 0; i < m && i < n; ++i) {\n            attacked_cities_set.insert(depth_nodes[i].second);\n        }\n    } else if (attack_type == \"root\") {\n        attacked_cities_set.insert(1);\n        while ((int)attacked_cities_set.size() < m) {\n            int node = rnd.next(1, n);\n            if (node != 1) attacked_cities_set.insert(node);\n        }\n    } else if (attack_type == \"one\") {\n        // Only one attacked city\n        attacked_cities_set.insert(rnd.next(1, n));\n    } else if (attack_type == \"all\") {\n        // All nodes are attacked\n        for (int i = 1; i <= n; ++i) {\n            attacked_cities_set.insert(i);\n        }\n    } else {\n        // Default to random\n        while ((int)attacked_cities_set.size() < m) {\n            int node = rnd.next(1, n);\n            attacked_cities_set.insert(node);\n        }\n    }\n\n    attacked_cities.assign(attacked_cities_set.begin(), attacked_cities_set.end());\n    shuffle(attacked_cities.begin(), attacked_cities.end());\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    for (auto& edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%s\", attacked_cities[i], (i == m - 1) ? \"\\n\" : \" \");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    string attack_type = opt<string>(\"attack_type\", \"random\");\n\n    // Adjust m according to attack_type if necessary\n    if (attack_type == \"one\") {\n        m = 1;\n    } else if (attack_type == \"all\") {\n        m = n;\n    } else if (m == -1) {\n        // If m is not specified, default to n/2\n        m = n / 2;\n    }\n    // Ensure m is within [1, n]\n    if (m < 1) m = 1;\n    if (m > n) m = n;\n\n    // Now, generate the tree according to 'type'\n    vector<pair<int, int> > edges;\n    vector<vector<int> > adj(n + 1);\n\n    if (type == \"chain\") {\n        // Generate a chain\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n            adj[i - 1].push_back(i);\n            adj[i].push_back(i - 1);\n        }\n    } else if (type == \"star\") {\n        // Node 1 connected to all other nodes\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n            adj[1].push_back(i);\n            adj[i].push_back(1);\n        }\n    } else if (type == \"balanced\") {\n        // Generate a balanced binary tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i / 2, i});\n            adj[i / 2].push_back(i);\n            adj[i].push_back(i / 2);\n        }\n    } else if (type == \"unbalanced\") {\n        // Generate an unbalanced tree\n        // We can make a chain with extra leaves attached to nodes\n        int current = 1;\n        for (int i = current + 1; i <= n; ++i) {\n            edges.push_back({current, i});\n            adj[current].push_back(i);\n            adj[i].push_back(current);\n            if (rnd.next(0, 1) == 1) {\n                current = i;\n            }\n        }\n    } else if (type == \"path-with-leaves\") {\n        // Generate a path and then attach leaves\n        int path_length = n / 2;\n        if (path_length < 1) path_length = 1;\n        for (int i = 2; i <= path_length; ++i) {\n            edges.push_back({i - 1, i});\n            adj[i - 1].push_back(i);\n            adj[i].push_back(i - 1);\n        }\n        for (int i = path_length + 1; i <= n; ++i) {\n            int attach_to = rnd.next(1, path_length);\n            edges.push_back({attach_to, i});\n            adj[attach_to].push_back(i);\n            adj[i].push_back(attach_to);\n        }\n    } else if (type == \"random\") {\n        // Generate a random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n            adj[parent].push_back(i);\n            adj[i].push_back(parent);\n        }\n    } else {\n        // Default to random\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n            adj[parent].push_back(i);\n            adj[i].push_back(parent);\n        }\n    }\n\n    // Now, select m attacked cities according to 'attack_type'\n    set<int> attacked_cities_set;\n    vector<int> attacked_cities;\n    if (attack_type == \"random\") {\n        while ((int)attacked_cities_set.size() < m) {\n            int node = rnd.next(1, n);\n            attacked_cities_set.insert(node);\n        }\n    } else if (attack_type == \"leaves\") {\n        vector<int> leaves;\n        for (int i = 1; i <= n; ++i) {\n            if (adj[i].size() == 1) {\n                leaves.push_back(i);\n            }\n        }\n        if ((int)leaves.size() < m) {\n            // If not enough leaves, fill with other nodes\n            for (int i = 1; i <= n; ++i) {\n                if (adj[i].size() != 1) {\n                    leaves.push_back(i);\n                }\n            }\n        }\n        shuffle(leaves.begin(), leaves.end());\n        for (int i = 0; i < m && i < (int)leaves.size(); ++i) {\n            attacked_cities_set.insert(leaves[i]);\n        }\n    } else if (attack_type == \"deep\") {\n        // Find deepest nodes\n        vector<int> depth(n + 1, 0);\n        function<void(int, int)> dfs = [&](int u, int p) {\n            for (int v : adj[u]) {\n                if (v != p) {\n                    depth[v] = depth[u] + 1;\n                    dfs(v, u);\n                }\n            }\n        };\n        dfs(1, -1);\n        vector<pair<int, int>> depth_nodes;\n        for (int i = 1; i <= n; ++i) {\n            depth_nodes.push_back({depth[i], i});\n        }\n        sort(depth_nodes.rbegin(), depth_nodes.rend());\n        for (int i = 0; i < m && i < n; ++i) {\n            attacked_cities_set.insert(depth_nodes[i].second);\n        }\n    } else if (attack_type == \"root\") {\n        attacked_cities_set.insert(1);\n        while ((int)attacked_cities_set.size() < m) {\n            int node = rnd.next(1, n);\n            if (node != 1) attacked_cities_set.insert(node);\n        }\n    } else if (attack_type == \"one\") {\n        // Only one attacked city\n        attacked_cities_set.insert(rnd.next(1, n));\n    } else if (attack_type == \"all\") {\n        // All nodes are attacked\n        for (int i = 1; i <= n; ++i) {\n            attacked_cities_set.insert(i);\n        }\n    } else {\n        // Default to random\n        while ((int)attacked_cities_set.size() < m) {\n            int node = rnd.next(1, n);\n            attacked_cities_set.insert(node);\n        }\n    }\n\n    attacked_cities.assign(attacked_cities_set.begin(), attacked_cities_set.end());\n    shuffle(attacked_cities.begin(), attacked_cities.end());\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    for (auto& edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%s\", attacked_cities[i], (i == m - 1) ? \"\\n\" : \" \");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type chain -attack_type one\n./gen -n 1 -type chain -attack_type all\n\n./gen -n 2 -type chain -attack_type random\n./gen -n 2 -type chain -attack_type leaves\n\n./gen -n 5 -type chain -attack_type random\n./gen -n 5 -type chain -attack_type root\n\n./gen -n 10 -type star -attack_type leaves\n./gen -n 10 -type star -attack_type deep\n\n./gen -n 15 -type balanced -attack_type random\n\n./gen -n 20 -type path-with-leaves -attack_type leaves\n\n./gen -n 123456 -type random -attack_type random -m 100000\n\n./gen -n 123456 -type chain -attack_type random -m 1\n\n./gen -n 50000 -type star -attack_type random\n\n./gen -n 100000 -type balanced -attack_type deep -m 100000\n\n./gen -n 100000 -type unbalanced -attack_type leaves -m 1000\n\n./gen -n 100 -type random -attack_type all\n\n./gen -n 200 -type random -attack_type one\n\n./gen -n 300 -type random -attack_type root\n\n./gen -n 1000 -type path-with-leaves -attack_type leaves\n\n./gen -n 10000 -type balanced -attack_type random -m 5000\n\n./gen -n 10000 -type unbalanced -attack_type deep\n\n./gen -n 10000 -type star -attack_type random -m 1\n\n./gen -n 70000 -type random -attack_type random -m 70000\n\n./gen -n 123456 -type random -attack_type random -m 123456\n\n./gen -n 1000 -type random -attack_type random\n\n./gen -n 50000 -type chain -attack_type root -m 50000\n\n./gen -n 50000 -type chain -attack_type leaves -m 50000\n\n./gen -n 123456 -type balanced -attack_type deep -m 123456\n\n./gen -n 10 -type unbalanced -attack_type leaves\n\n./gen -n 20 -type path-with-leaves -attack_type leaves\n\n./gen -n 30 -type star -attack_type deep\n\n./gen -n 100000 -type random -attack_type random\n\n./gen -n 123456 -type random -attack_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:50.951483",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "592/E",
      "title": "E. BCPC",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputIn the first line of the input three integers n, c and d (3 ≤ n ≤ 345678, 1 ≤ c, d ≤ 109) are written. They denote the number of students Blenda can use to form teams, the value subtracted from all reading speeds and the value subtracted from all writing speeds respectively.Each of the next n lines contains two integers ri and wi (0 < ri, wi ≤ 109, |ri - c| + |wi - d| > 0). There are no two students, such that both their reading and writing speeds coincide, i.e. for every i ≠ j condition |ri - rj| + |wi - wj| > 0 holds.",
      "output_spec": "OutputPrint the number of different teams in BSU, that are good according to Blenda's definition.",
      "sample_tests": "ExamplesInputCopy5 2 21 14 12 33 23 4OutputCopy4InputCopy7 6 63 21 75 73 76 48 98 5OutputCopy11",
      "description": "time limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputIn the first line of the input three integers n, c and d (3 ≤ n ≤ 345678, 1 ≤ c, d ≤ 109) are written. They denote the number of students Blenda can use to form teams, the value subtracted from all reading speeds and the value subtracted from all writing speeds respectively.Each of the next n lines contains two integers ri and wi (0 < ri, wi ≤ 109, |ri - c| + |wi - d| > 0). There are no two students, such that both their reading and writing speeds coincide, i.e. for every i ≠ j condition |ri - rj| + |wi - wj| > 0 holds.\n\nOutputPrint the number of different teams in BSU, that are good according to Blenda's definition.\n\nInputCopy5 2 21 14 12 33 23 4OutputCopy4InputCopy7 6 63 21 75 73 76 48 98 5OutputCopy11\n\nInputCopy5 2 21 14 12 33 23 4\n\nOutputCopy4\n\nInputCopy7 6 63 21 75 73 76 48 98 5\n\nOutputCopy11\n\nNoteIn the first sample the following teams are good: (i = 1, j = 2, k = 3), (i = 2, j = 5, k = 1), (i = 1, j = 4, k = 3), (i = 5, j = 1, k = 4).Note, that for example the team (i = 3, j = 1, k = 2) is also good, but is considered to be the same as the team (i = 1, j = 2, k = 3).",
      "solutions": [
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces",
          "content": "Codeforces Round #328 (Div. 2) will take place on October 31, 19:30 MSK, as usual Div. 1 participants can join out of competition.Problem Setter: Morphy (Alei Reyes)Coordinator: GlebsHP (Gleb Evstropov)English to Russian translator: Delinur (Maria Belova) Codeforces and Polygon: MikeMirzayanov (Mike Mirzayanov)Hope you enjoy the problem set.The score distribution will be announced later.UPD. Score Distribution: 500 — 1000 — 1500 — 2000 — 3000UPD. Problem Analysis is availableCongrats to the winners!Div. 2shamir0xelbn187SuperLoserDiv. 1uwiNanoApeHaghani",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21284",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 558
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces",
          "content": "Problem A. PawnChessPlayer A wins if the distance of his nearest pawn to the top of the board is less than or equal to the distance of the Player’s B nearest pawn to the bottom of the board (Note that you should only consider pawns that are not blocked by another pawns).Problem B. The monster and the squirrelAfter drawing the rays from the first vertex (n - 2) triangles are formed. The subsequent rays will generate independently sub-regions in these triangles. Let's analyse the triangle determined by vertices 1, i, i + 1, after drawing the rays from vertex i and (i + 1) the triangle will be divided into (n - i) + (i - 2) = n - 2 regions. Therefore the total number of convex regions is (n - 2)2If the squirrel starts from the region that have 1 as a vertex, then she can go through each region of triangle (1, i, i + 1) once. That implies that the squirrel can collect all the walnuts in (n - 2)2 jumps.Problem C. The Big RaceLet D be the length of the racetrack, Since both athletes should tie . Let M = lcm(B, W), then D = k·M + r. None of the athletes should give one step further, therefore r ≤ min{B - 1, W - 1, T} = X. D must be greater than 0 and less than or equal to T so  - r / M < k ≤ (T - r) / M. For r = 0, the number of valid racetracks is , and for r > 0 the number of racetracks is . Iterating over all possible r, we can count the number of racetracks in which Willman and Bolt ties: Note that . That means that for exactly M values of r. We can count the number of values of r in which , and the values of r in which . Each of the remaining values v1 - 1, v1 - 2, ..., v2 + 1 will appear exactly M times.Problem D. Super MObservation 1: Ari should teleport to one of the attacked cities (it doesn't worth going to a city that is not attacked since then she should go to one of the attacked cities)Observation 2: The nodes visited by Ari will determine a sub-tree T of the original tree, this tree is unique and is determined by all the paths from two attacked cities.Observation 3: If Ari had to return to the city from where she started, then the total distance would be 2e, where e is the number of edges of T, that is because she goes through each edge forward and backwardObservation 4: If Ari does not have to return to the starting city (the root of T), then the total distance is 2e - L, where L is the distance of the farthest node from the rootObservation 5: In order to get a minimum total distance, Ari should chose one diameter of the tree, and teleport to one of its leaves.The problem is now transformed in finding the diameter of a tree that contains the smallest index for one of its leaves. Note that all diameters pass through the center of the tree, so we can find all the farthest nodes from the center...and [details omitted].Problem E. BCPCLet’s represent the reading and writing speeds of the students as points in a plane. Two students i, j are compatible if ri'·wj' - rj'·wi' > 0 this equation is identical to the cross product: (ri', wi') × (rj', wj′) > 0. Using this fact is easy to see that three students i, j, k are compatible if the triangle (ri, wi), (rj, wj), (rk, wk) contains the point (x, y). So the problem is reduced to count the number of triangles that contains the origin.Let’s count the triangles that have two known vertices i and j (look at the picture above). It is easy to see that the third vertex should be inside the region S. So now we have to be able of counting points that are between two rays, that can be done using binary search (ordering the points first by slope and then by the distance to the origin).Now given a point i, let’s count the triangles that have i as a vertex (look at the picture above again). We have to count the points that lie between the ray iO, and every other ray jO (the angle between iO and jO must be  ≤ 180). Let Sj denote the number points that are between the rays OR and jO, then the number of triangles that have i as a vertex are . This summation can be calculated if we pre-calculate the cumulative sums of Sj. The overall complexity is O(n·log(n)).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21318",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4065
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 1",
          "code": "#define ull unsigned long long\nbool overFlow(ull a, ull b) {\n    return ((a*b)/b == a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 2",
          "code": "#define ull unsigned long long\nbool overFlow(ull a, ull b) {\n    return ((a*b)/b == a);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 3",
          "code": "if (minA < minB) cout << \"A\\n\";\nelse cout << \"B\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 4",
          "code": "if (minA < minB) cout << \"A\\n\";\nelse cout << \"B\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 5",
          "code": "........\n..B.....\n......W.\n..W.....\n........\n........\n..B.....\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 6",
          "code": "........\n..B.....\n......W.\n..W.....\n........\n........\n..B.....\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 7",
          "code": "........\n.W......\n........\n........\n........\n........\n......B.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 8",
          "code": "........\n.W......\n........\n........\n........\n........\n......B.\n........",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 9",
          "code": "#include <iostream>\nusing namespace std;\nint main() {\n  cout << sizeof(long double) << endl;\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 10",
          "code": "#include <iostream>\nusing namespace std;\nint main() {\n  cout << sizeof(long double) << endl;\n  return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 11",
          "code": "#include <iostream>  using namespace std;  int main(int argc, char **argv){  int points;  cin >> points; unsigned long long answer = 1 + (points-3) + 2*(points-3) + (points-3)*(points-4);  cout << answer << endl;  return 0;  }",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 (Div. 2) - Codeforces - Code 12",
          "code": "#include <iostream>  using namespace std;  int main(int argc, char **argv){  int points;  cin >> points; unsigned long long answer = 1 + (points-3) + 2*(points-3) + (points-3)*(points-4);  cout << answer << endl;  return 0;  }",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21284",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces - Code 1",
          "code": "__builtin_mul_overflow",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21318",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces - Code 2",
          "code": "int max_r = min(min(b,w)-1, t);\nint ans = t / lcm;\nfor (int r = 1; r <= max_r; ) {\nint v = (T-r)/lcm;\nint mfar = min(max_r, t - v * lcm);\nans += (mfar - r + 1) * (v + 1);\nr = mfar + 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21318",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #328 Problem Analysis - Codeforces - Code 3",
          "code": "int max_r = min(min(b,w)-1, t);\nint ans = t / lcm;\nfor (int r = 1; r <= max_r; ) {\nint v = (T-r)/lcm;\nint mfar = min(max_r, t - v * lcm);\nans += (mfar - r + 1) * (v + 1);\nr = mfar + 1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21318",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 345678, \"n\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000000000, \"c\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000000, \"d\");\n    inf.readEoln();\n\n    set<pair<int,int>> s;\n\n    for (int i = 0; i < n; i++) {\n        int ri = inf.readInt(1, 1000000000, \"ri\");\n        inf.readSpace();\n        int wi = inf.readInt(1, 1000000000, \"wi\");\n        inf.readEoln();\n\n        int64_t ri_diff = abs((int64_t)ri - (int64_t)c);\n        int64_t wi_diff = abs((int64_t)wi - (int64_t)d);\n\n        ensuref(ri_diff + wi_diff > 0, \"|ri - c| + |wi - d| > 0 for i=%d\", i+1);\n\n        auto res = s.insert(make_pair(ri, wi));\n        ensuref(res.second, \"Duplicate (ri, wi) pair at line %d\", i+2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 345678, \"n\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000000000, \"c\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000000, \"d\");\n    inf.readEoln();\n\n    set<pair<int,int>> s;\n\n    for (int i = 0; i < n; i++) {\n        int ri = inf.readInt(1, 1000000000, \"ri\");\n        inf.readSpace();\n        int wi = inf.readInt(1, 1000000000, \"wi\");\n        inf.readEoln();\n\n        int64_t ri_diff = abs((int64_t)ri - (int64_t)c);\n        int64_t wi_diff = abs((int64_t)wi - (int64_t)d);\n\n        ensuref(ri_diff + wi_diff > 0, \"|ri - c| + |wi - d| > 0 for i=%d\", i+1);\n\n        auto res = s.insert(make_pair(ri, wi));\n        ensuref(res.second, \"Duplicate (ri, wi) pair at line %d\", i+2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 345678, \"n\");\n    inf.readSpace();\n    int c = inf.readInt(1, 1000000000, \"c\");\n    inf.readSpace();\n    int d = inf.readInt(1, 1000000000, \"d\");\n    inf.readEoln();\n\n    set<pair<int,int>> s;\n\n    for (int i = 0; i < n; i++) {\n        int ri = inf.readInt(1, 1000000000, \"ri\");\n        inf.readSpace();\n        int wi = inf.readInt(1, 1000000000, \"wi\");\n        inf.readEoln();\n\n        int64_t ri_diff = abs((int64_t)ri - (int64_t)c);\n        int64_t wi_diff = abs((int64_t)wi - (int64_t)d);\n\n        ensuref(ri_diff + wi_diff > 0, \"|ri - c| + |wi - d| > 0 for i=%d\", i+1);\n\n        auto res = s.insert(make_pair(ri, wi));\n        ensuref(res.second, \"Duplicate (ri, wi) pair at line %d\", i+2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long c = opt<long long>(\"c\", 1);\n    long long d = opt<long long>(\"d\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Validate n, c, d\n    n = max(3, min(n, 345678));\n    c = max(1LL, min(c, 1000000000LL));\n    d = max(1LL, min(d, 1000000000LL));\n\n    vector<pair<long long, long long>> students;\n    set<pair<long long, long long>> S;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            long long ri, wi;\n            do {\n                ri = rnd.next(1LL, 1000000000LL - n) + i;\n                wi = rnd.next(1LL, 1000000000LL - n) + i;\n            } while (S.count({ri, wi}) || (ri == c && wi == d));\n            students.emplace_back(ri, wi);\n            S.insert({ri, wi});\n        }\n    } else if (type == \"zero_ri\") {\n        for (int i = 0; i < n; i++) {\n            long long ri = c;\n            long long wi;\n            do {\n                wi = rnd.next(1LL, 1000000000LL - n) + i;\n            } while (wi == d);\n            students.emplace_back(ri, wi);\n            S.insert({ri, wi});\n        }\n    } else if (type == \"zero_wi\") {\n        for (int i = 0; i < n; i++) {\n            long long wi = d;\n            long long ri;\n            do {\n                ri = rnd.next(1LL, 1000000000LL - n) + i;\n            } while (ri == c);\n            students.emplace_back(ri, wi);\n            S.insert({ri, wi});\n        }\n    } else if (type == \"negative_ri\") {\n        for (int i = 0; i < n; i++) {\n            long long ri = rnd.next(1LL, c - 1);\n            long long wi;\n            do {\n                wi = rnd.next(1LL, 1000000000LL - n) + i;\n            } while (wi == d || S.count({ri, wi}) || (ri == c && wi == d));\n            students.emplace_back(ri, wi);\n            S.insert({ri, wi});\n        }\n    } else if (type == \"negative_wi\") {\n        for (int i = 0; i < n; i++) {\n            long long wi = rnd.next(1LL, d - 1);\n            long long ri;\n            do {\n                ri = rnd.next(1LL, 1000000000LL - n) + i;\n            } while (ri == c || S.count({ri, wi}) || (ri == c && wi == d));\n            students.emplace_back(ri, wi);\n            S.insert({ri, wi});\n        }\n    } else if (type == \"max_values\") {\n        for (int i = 0; i < n; i++) {\n            long long ri = 1000000000LL - i;\n            long long wi = 1000000000LL - i;\n            if (ri == c && wi == d) {\n                ri -= 1;\n            }\n            students.emplace_back(ri, wi);\n            S.insert({ri, wi});\n        }\n    } else if (type == \"cycle\") {\n        c = 2;\n        d = 2;\n        students.emplace_back(3LL, 2LL); // Student A\n        students.emplace_back(2LL, 3LL); // Student B\n        students.emplace_back(1LL, 1LL); // Student C\n        S.insert({3LL, 2LL});\n        S.insert({2LL, 3LL});\n        S.insert({1LL, 1LL});\n        for (int i = 3; i < n; i++) {\n            long long ri, wi;\n            do {\n                ri = rnd.next(1LL, 1000000000LL);\n                wi = rnd.next(1LL, 1000000000LL);\n            } while (S.count({ri, wi}) || (ri == c && wi == d));\n            students.emplace_back(ri, wi);\n            S.insert({ri, wi});\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; i++) {\n            long long ri, wi;\n            do {\n                ri = rnd.next(1LL, 1000000000LL - n) + i;\n                wi = rnd.next(1LL, 1000000000LL - n) + i;\n            } while (S.count({ri, wi}) || (ri == c && wi == d));\n            students.emplace_back(ri, wi);\n            S.insert({ri, wi});\n        }\n    }\n\n    // Output n, c, d\n    printf(\"%d %lld %lld\\n\", n, c, d);\n    // Output ri, wi for each student\n    for (int i = 0; i < n; i++) {\n        printf(\"%lld %lld\\n\", students[i].first, students[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long c = opt<long long>(\"c\", 1);\n    long long d = opt<long long>(\"d\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Validate n, c, d\n    n = max(3, min(n, 345678));\n    c = max(1LL, min(c, 1000000000LL));\n    d = max(1LL, min(d, 1000000000LL));\n\n    vector<pair<long long, long long>> students;\n    set<pair<long long, long long>> S;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            long long ri, wi;\n            do {\n                ri = rnd.next(1LL, 1000000000LL - n) + i;\n                wi = rnd.next(1LL, 1000000000LL - n) + i;\n            } while (S.count({ri, wi}) || (ri == c && wi == d));\n            students.emplace_back(ri, wi);\n            S.insert({ri, wi});\n        }\n    } else if (type == \"zero_ri\") {\n        for (int i = 0; i < n; i++) {\n            long long ri = c;\n            long long wi;\n            do {\n                wi = rnd.next(1LL, 1000000000LL - n) + i;\n            } while (wi == d);\n            students.emplace_back(ri, wi);\n            S.insert({ri, wi});\n        }\n    } else if (type == \"zero_wi\") {\n        for (int i = 0; i < n; i++) {\n            long long wi = d;\n            long long ri;\n            do {\n                ri = rnd.next(1LL, 1000000000LL - n) + i;\n            } while (ri == c);\n            students.emplace_back(ri, wi);\n            S.insert({ri, wi});\n        }\n    } else if (type == \"negative_ri\") {\n        for (int i = 0; i < n; i++) {\n            long long ri = rnd.next(1LL, c - 1);\n            long long wi;\n            do {\n                wi = rnd.next(1LL, 1000000000LL - n) + i;\n            } while (wi == d || S.count({ri, wi}) || (ri == c && wi == d));\n            students.emplace_back(ri, wi);\n            S.insert({ri, wi});\n        }\n    } else if (type == \"negative_wi\") {\n        for (int i = 0; i < n; i++) {\n            long long wi = rnd.next(1LL, d - 1);\n            long long ri;\n            do {\n                ri = rnd.next(1LL, 1000000000LL - n) + i;\n            } while (ri == c || S.count({ri, wi}) || (ri == c && wi == d));\n            students.emplace_back(ri, wi);\n            S.insert({ri, wi});\n        }\n    } else if (type == \"max_values\") {\n        for (int i = 0; i < n; i++) {\n            long long ri = 1000000000LL - i;\n            long long wi = 1000000000LL - i;\n            if (ri == c && wi == d) {\n                ri -= 1;\n            }\n            students.emplace_back(ri, wi);\n            S.insert({ri, wi});\n        }\n    } else if (type == \"cycle\") {\n        c = 2;\n        d = 2;\n        students.emplace_back(3LL, 2LL); // Student A\n        students.emplace_back(2LL, 3LL); // Student B\n        students.emplace_back(1LL, 1LL); // Student C\n        S.insert({3LL, 2LL});\n        S.insert({2LL, 3LL});\n        S.insert({1LL, 1LL});\n        for (int i = 3; i < n; i++) {\n            long long ri, wi;\n            do {\n                ri = rnd.next(1LL, 1000000000LL);\n                wi = rnd.next(1LL, 1000000000LL);\n            } while (S.count({ri, wi}) || (ri == c && wi == d));\n            students.emplace_back(ri, wi);\n            S.insert({ri, wi});\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; i++) {\n            long long ri, wi;\n            do {\n                ri = rnd.next(1LL, 1000000000LL - n) + i;\n                wi = rnd.next(1LL, 1000000000LL - n) + i;\n            } while (S.count({ri, wi}) || (ri == c && wi == d));\n            students.emplace_back(ri, wi);\n            S.insert({ri, wi});\n        }\n    }\n\n    // Output n, c, d\n    printf(\"%d %lld %lld\\n\", n, c, d);\n    // Output ri, wi for each student\n    for (int i = 0; i < n; i++) {\n        printf(\"%lld %lld\\n\", students[i].first, students[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -c 2 -d 2 -type cycle\n./gen -n 5 -c 2 -d 2 -type cycle\n./gen -n 10 -c 2 -d 2 -type cycle\n./gen -n 100 -c 2 -d 2 -type cycle\n\n./gen -n 3 -c 1 -d 1 -type random\n./gen -n 10 -c 123456789 -d 987654321 -type random\n./gen -n 1000 -c 500000000 -d 500000000 -type random\n./gen -n 10000 -c 1000000000 -d 1 -type random\n./gen -n 345678 -c 1000000000 -d 1000000000 -type random\n\n./gen -n 50 -c 1 -d 1 -type zero_ri\n./gen -n 50 -c 1000000000 -d 1 -type zero_wi\n./gen -n 50 -c 500000000 -d 500000000 -type negative_ri\n./gen -n 50 -c 500000000 -d 500000000 -type negative_wi\n\n./gen -n 100 -c 1000000000 -d 1000000000 -type max_values\n\n./gen -n 5 -c 2 -d 2 -type negative_ri\n./gen -n 5 -c 5 -d 5 -type negative_wi\n\n./gen -n 100000 -type random\n./gen -n 345678 -type max_values\n\n./gen -n 10000 -c 1 -d 1 -type zero_wi\n\n./gen -n 1000 -c 1 -d 1000000000 -type zero_ri\n\n./gen -n 1000 -c 1000 -d 1000 -type negative_ri\n./gen -n 1000 -c 1000 -d 1000 -type negative_wi\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:53.538684",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "593/A",
      "title": "Problem 593/A",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    int total_length = 0;\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[a-z]*\");\n        total_length += s.length();\n        ensuref(total_length <= 1000, \"The total length of words exceeds 1000. Now total_length=%d\", total_length);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    int total_length = 0;\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[a-z]*\");\n        total_length += s.length();\n        ensuref(total_length <= 1000, \"The total length of words exceeds 1000. Now total_length=%d\", total_length);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    int total_length = 0;\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[a-z]*\");\n        total_length += s.length();\n        ensuref(total_length <= 1000, \"The total length of words exceeds 1000. Now total_length=%d\", total_length);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_TOTAL_LENGTH = 1000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> words;\n    int total_length = 0;\n\n    if(type == \"minimal\") {\n        // Minimal input case: n = 1, word of length 1\n        n = 1;\n        words.push_back(\"a\");\n    } else if(type == \"maximal\") {\n        // Maximal input case: n = 100, total length = 1000\n        n = 100;\n        int per_word_length = MAX_TOTAL_LENGTH / n;\n        for(int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            string word(per_word_length, c);\n            words.push_back(word);\n        }\n    } else if(type == \"one_letter\") {\n        // Words with only one distinct letter\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 10);\n            char c = 'a' + rnd.next(26);\n            string word(len, c);\n            words.push_back(word);\n        }\n    } else if(type == \"two_letter\") {\n        // Words with exactly two distinct letters\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 10);\n            char c1 = 'a' + rnd.next(26);\n            char c2 = 'a' + rnd.next(26);\n            while(c2 == c1) c2 = 'a' + rnd.next(26);\n            string word;\n            for(int j = 0; j < len; ++j) {\n                word += (rnd.next(2) ? c1 : c2);\n            }\n            words.push_back(word);\n        }\n    } else if(type == \"three_letter\") {\n        // Words with three distinct letters\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 10);\n            char c1 = 'a' + rnd.next(26);\n            char c2 = 'a' + rnd.next(26);\n            char c3 = 'a' + rnd.next(26);\n            while(c2 == c1) c2 = 'a' + rnd.next(26);\n            while(c3 == c1 || c3 == c2) c3 = 'a' + rnd.next(26);\n            string word;\n            for(int j = 0; j < len; ++j) {\n                int r = rnd.next(3);\n                char c = (r == 0) ? c1 : (r == 1 ? c2 : c3);\n                word += c;\n            }\n            words.push_back(word);\n        }\n    } else if(type == \"duplicates\") {\n        // Words are duplicates from a small set of base words\n        int num_base_words = rnd.next(1, n / 2 + 1);\n        vector<string> base_words;\n        for(int i = 0; i < num_base_words; ++i) {\n            int len = rnd.next(1, 10);\n            string word;\n            for(int j = 0; j < len; ++j) {\n                word += 'a' + rnd.next(26);\n            }\n            base_words.push_back(word);\n        }\n        for(int i = 0; i < n; ++i) {\n            int idx = rnd.next(0, num_base_words - 1);\n            words.push_back(base_words[idx]);\n        }\n    } else if(type == \"zero_answer\") {\n        // All words have more than two distinct letters\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 10);\n            set<char> used_chars;\n            while((int)used_chars.size() < 3) {\n                char c = 'a' + rnd.next(26);\n                used_chars.insert(c);\n            }\n            vector<char> chars(used_chars.begin(), used_chars.end());\n            string word;\n            for(int j = 0; j < len; ++j) {\n                word += chars[rnd.next(0, 2)];\n            }\n            words.push_back(word);\n        }\n    } else if(type == \"varying_lengths\") {\n        // Words with varying lengths\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, max(1, MAX_TOTAL_LENGTH / n));\n            string word;\n            for(int j = 0; j < len; ++j) {\n                word += 'a' + rnd.next(26);\n            }\n            words.push_back(word);\n        }\n    } else if(type == \"overlapping\") {\n        // Words with overlapping letters to challenge the solution\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        while(c2 == c1) c2 = 'a' + rnd.next(26);\n        char c3 = 'a' + rnd.next(26);\n        while(c3 == c1 || c3 == c2) c3 = 'a' + rnd.next(26);\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 10);\n            string word;\n            for(int j = 0; j < len; ++j) {\n                int r = rnd.next(3);\n                char c = (r == 0) ? c1 : ((r == 1) ? c2 : c3);\n                word += c;\n            }\n            words.push_back(word);\n        }\n    } else {\n        // Random words\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 10);\n            string word;\n            for(int j = 0; j < len; ++j) {\n                word += 'a' + rnd.next(26);\n            }\n            words.push_back(word);\n        }\n    }\n\n    // Ensure total length does not exceed MAX_TOTAL_LENGTH\n    int length_sum = 0;\n    for(auto &word : words) {\n        length_sum += word.length();\n    }\n    if(length_sum > MAX_TOTAL_LENGTH) {\n        // Trim words to fit total length ≤ MAX_TOTAL_LENGTH\n        int remaining_length = MAX_TOTAL_LENGTH;\n        for(auto &word : words) {\n            if(remaining_length <= 0) {\n                word = \"\";\n            } else if((int)word.length() > remaining_length) {\n                word = word.substr(0, remaining_length);\n                remaining_length = 0;\n            } else {\n                remaining_length -= word.length();\n            }\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the words\n    for(auto &word : words) {\n        printf(\"%s\\n\", word.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_TOTAL_LENGTH = 1000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> words;\n    int total_length = 0;\n\n    if(type == \"minimal\") {\n        // Minimal input case: n = 1, word of length 1\n        n = 1;\n        words.push_back(\"a\");\n    } else if(type == \"maximal\") {\n        // Maximal input case: n = 100, total length = 1000\n        n = 100;\n        int per_word_length = MAX_TOTAL_LENGTH / n;\n        for(int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            string word(per_word_length, c);\n            words.push_back(word);\n        }\n    } else if(type == \"one_letter\") {\n        // Words with only one distinct letter\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 10);\n            char c = 'a' + rnd.next(26);\n            string word(len, c);\n            words.push_back(word);\n        }\n    } else if(type == \"two_letter\") {\n        // Words with exactly two distinct letters\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 10);\n            char c1 = 'a' + rnd.next(26);\n            char c2 = 'a' + rnd.next(26);\n            while(c2 == c1) c2 = 'a' + rnd.next(26);\n            string word;\n            for(int j = 0; j < len; ++j) {\n                word += (rnd.next(2) ? c1 : c2);\n            }\n            words.push_back(word);\n        }\n    } else if(type == \"three_letter\") {\n        // Words with three distinct letters\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 10);\n            char c1 = 'a' + rnd.next(26);\n            char c2 = 'a' + rnd.next(26);\n            char c3 = 'a' + rnd.next(26);\n            while(c2 == c1) c2 = 'a' + rnd.next(26);\n            while(c3 == c1 || c3 == c2) c3 = 'a' + rnd.next(26);\n            string word;\n            for(int j = 0; j < len; ++j) {\n                int r = rnd.next(3);\n                char c = (r == 0) ? c1 : (r == 1 ? c2 : c3);\n                word += c;\n            }\n            words.push_back(word);\n        }\n    } else if(type == \"duplicates\") {\n        // Words are duplicates from a small set of base words\n        int num_base_words = rnd.next(1, n / 2 + 1);\n        vector<string> base_words;\n        for(int i = 0; i < num_base_words; ++i) {\n            int len = rnd.next(1, 10);\n            string word;\n            for(int j = 0; j < len; ++j) {\n                word += 'a' + rnd.next(26);\n            }\n            base_words.push_back(word);\n        }\n        for(int i = 0; i < n; ++i) {\n            int idx = rnd.next(0, num_base_words - 1);\n            words.push_back(base_words[idx]);\n        }\n    } else if(type == \"zero_answer\") {\n        // All words have more than two distinct letters\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 10);\n            set<char> used_chars;\n            while((int)used_chars.size() < 3) {\n                char c = 'a' + rnd.next(26);\n                used_chars.insert(c);\n            }\n            vector<char> chars(used_chars.begin(), used_chars.end());\n            string word;\n            for(int j = 0; j < len; ++j) {\n                word += chars[rnd.next(0, 2)];\n            }\n            words.push_back(word);\n        }\n    } else if(type == \"varying_lengths\") {\n        // Words with varying lengths\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, max(1, MAX_TOTAL_LENGTH / n));\n            string word;\n            for(int j = 0; j < len; ++j) {\n                word += 'a' + rnd.next(26);\n            }\n            words.push_back(word);\n        }\n    } else if(type == \"overlapping\") {\n        // Words with overlapping letters to challenge the solution\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        while(c2 == c1) c2 = 'a' + rnd.next(26);\n        char c3 = 'a' + rnd.next(26);\n        while(c3 == c1 || c3 == c2) c3 = 'a' + rnd.next(26);\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 10);\n            string word;\n            for(int j = 0; j < len; ++j) {\n                int r = rnd.next(3);\n                char c = (r == 0) ? c1 : ((r == 1) ? c2 : c3);\n                word += c;\n            }\n            words.push_back(word);\n        }\n    } else {\n        // Random words\n        for(int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 10);\n            string word;\n            for(int j = 0; j < len; ++j) {\n                word += 'a' + rnd.next(26);\n            }\n            words.push_back(word);\n        }\n    }\n\n    // Ensure total length does not exceed MAX_TOTAL_LENGTH\n    int length_sum = 0;\n    for(auto &word : words) {\n        length_sum += word.length();\n    }\n    if(length_sum > MAX_TOTAL_LENGTH) {\n        // Trim words to fit total length ≤ MAX_TOTAL_LENGTH\n        int remaining_length = MAX_TOTAL_LENGTH;\n        for(auto &word : words) {\n            if(remaining_length <= 0) {\n                word = \"\";\n            } else if((int)word.length() > remaining_length) {\n                word = word.substr(0, remaining_length);\n                remaining_length = 0;\n            } else {\n                remaining_length -= word.length();\n            }\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the words\n    for(auto &word : words) {\n        printf(\"%s\\n\", word.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type minimal\n./gen -n 1 -type zero_answer\n./gen -n 1 -type varying_lengths\n\n./gen -n 10 -type one_letter\n./gen -n 10 -type two_letter\n./gen -n 10 -type three_letter\n./gen -n 10 -type duplicates\n./gen -n 10 -type overlapping\n./gen -n 10 -type zero_answer\n\n./gen -n 50 -type random\n./gen -n 50 -type varying_lengths\n./gen -n 50 -type duplicates\n./gen -n 50 -type overlapping\n\n./gen -n 100 -type maximal\n./gen -n 100 -type random\n./gen -n 100 -type one_letter\n./gen -n 100 -type two_letter\n./gen -n 100 -type three_letter\n./gen -n 100 -type duplicates\n./gen -n 100 -type overlapping\n./gen -n 100 -type zero_answer\n./gen -n 100 -type varying_lengths\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:55.238934",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "593/B",
      "title": "B. Антон и прямые",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных находится целое число n (2 ≤ n ≤ 100 000) — количество прямых в задании. Во второй строке содержатся целые числа x1, x2 ( - 1 000 000 ≤ x1 < x2 ≤ 1 000 000) определяющие полосу, внутри которой требуется найти точку пересечения прямых.В следующих n строках содержатся целые числа ki, bi ( - 1 000 000 ≤ ki, bi ≤ 1 000 000) — описание прямых. Гарантируется, что все прямые различны, то есть для любых двух i ≠ j верно, что либо ki ≠ kj, либо bi ≠ bj.",
      "output_spec": "Выходные данныеВыведите «Yes» (без кавычек), если существует хотя бы одно пересечение двух прямых, расположенное строго внутри полосы, иначе выведите «No» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать41 21 21 00 10 2Выходные данныеСкопироватьNOВходные данныеСкопировать21 31 0-1 3Выходные данныеСкопироватьYESВходные данныеСкопировать21 31 00 2Выходные данныеСкопироватьYESВходные данныеСкопировать21 31 00 3Выходные данныеСкопироватьNO",
      "description": "B. Антон и прямые\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных находится целое число n (2 ≤ n ≤ 100 000) — количество прямых в задании. Во второй строке содержатся целые числа x1, x2 ( - 1 000 000 ≤ x1 < x2 ≤ 1 000 000) определяющие полосу, внутри которой требуется найти точку пересечения прямых.В следующих n строках содержатся целые числа ki, bi ( - 1 000 000 ≤ ki, bi ≤ 1 000 000) — описание прямых. Гарантируется, что все прямые различны, то есть для любых двух i ≠ j верно, что либо ki ≠ kj, либо bi ≠ bj.\n\nВходные данные\n\nВыходные данныеВыведите «Yes» (без кавычек), если существует хотя бы одно пересечение двух прямых, расположенное строго внутри полосы, иначе выведите «No» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать41 21 21 00 10 2Выходные данныеСкопироватьNOВходные данныеСкопировать21 31 0-1 3Выходные данныеСкопироватьYESВходные данныеСкопировать21 31 00 2Выходные данныеСкопироватьYESВходные данныеСкопировать21 31 00 3Выходные данныеСкопироватьNO\n\nВходные данныеСкопировать41 21 21 00 10 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать21 31 0-1 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать21 31 00 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать21 31 00 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере прямые пересекаются только на границе полосы, но ни одного пересечения внутри нет.",
      "solutions": [
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces",
          "content": "Всем привет!Завтра в 19.30 по московскому времени состоится Codeforces Round #329, который настоятельно не рекомендуется кому-либо пропускать.Задачи для вас готовили я и Станислав josdas Наумов. Я уверен, что это не последний раунд, в котором мы являемся авторами. Мы очень надеемся, что вам понравится раунд, и каждый найдет себе задачу по вкусу. Для того, чтобы увеличить вероятность этого события, пожалуйста, прочтите все задачи этого контеста.Как всегда, благодарим GlebsHP за неоценимую помощь при подготовке контеста, Delinur за перевод условий на английский язык и MikeMirzayanov за потрясающие системы Codeforces и Polygon.Отдельное спасибо хотим сказать Алексею Саплину, Эрике Шефер, Евгению Казакову, Богдану Трубецкому.Участникам будет предложено пять задач и два часа на их решение. Разбалловка будет объявлена позднее.Желаю удачи и высокого рейтинга!UPD1: Разбалловка будет динамической.UPD2: Разбор задач",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21371",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 919
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces",
          "content": "593A - 2CharДля каждой буквы будем поддерживать суммарную длину слов (cnt1ci), в которых встречается она одна, а для каждой пары букв будем поддерживать суммарную длину слов, в которых встречаются только они(cnt2ci, cj).Для каждой строки определим количество различных букв в ней. Если она одна, то добавим к этой букве длину этого слова. Если их две, то добавим к этой паре букв длину этого слова.Переберем пару букв, которая будет ответом. Для пары букв ci, cj ответом будет cnt1ci + cnt1cj + cnt2ci, cj. Среди всех таких пар найдем максимум и выведем его.Решение за O(суммарная длина всех строк + 26 * 26)593B - Anton and LinesЗаметим, что если i-я прямая пересекаются с j-й в данной полосе, а при x = x1 i-я прямая находится выше, то при x = x2 выше окажется j-я прямая. То есть отсортируем прямые по координате y при x = x1 + eps, и при x = x2 - eps. Проверим, что порядок прямых в обоих случаях совпадает. Если существует такая прямая, что ее индекс в первом случае не совпадает со вторым, то выведем Yes. В другом случае выведем No.Единственное, что может нам помешать это пересечение на границах, так как в таком случае порядок сортировки не определен. Тогда прибавим к нашей границе x1 бесконечно малую величину eps, а от x2 отнимем eps, и порядок сортировки будет задан однозначно.Решение за O(nlogn)593C - Beautiful FunctionОдним из ответов будет являться сумма таких выражений для каждой окружности по координате x и аналогично по координате y: Пусть a = 1, b = abs(t - i), тогда это можно записать как Рассмотрим a - b + abs(a - b):если a ≤ b, то a - b + abs(a - b) = 0,если a > b, то a - b + abs(a - b) = 2a - 2bтеперь рассмотрим, что такое a > b:1 > abs(t - i)i > t - 1, и i < t + 1.При целом i это возможно лишь в случае i = t.То есть эта скобка не обнуляется лишь при i = t.Рассмотрим 2a - 2b = 2 - 2 * abs(t - i) = 2. Тогда отличается от нужной координаты не более чем на 1, но так как все радиусы не меньше 2, то эта точка принадлежит окружности.Решение за O(n).593D - Happy Tree PartyРассмотрим задачу без запросов второго типа. Заметим, что в графе, где все числа на ребрах  > 1 максимальное количество присвоений до того, как x превратится в 0, не превышает 64. Действительно, если все Rv = 2, то количество операций можно оценить как log2(x). Подвесим дерево за какую-нибудь вершину и назовем ее корнем. Научимся решать задачу при условии, что для любого v Rv > 1 и нет запросов второго типа. Для каждой вершины кроме корня мы определили ее предка как соседа наиболее близкого к корню. Пусть у нас был запрос первого типа от вершины a до вершины b с иходным числом x. Разобьем путь на две вертикальные части, одна из которых приближается к корню, а другая отдаляется. Найдем все ребра на этом пути. Для этого посчитаем глубину каждой вершины как расстояние до корня. Теперь будем параллельно подниматься в дереве из обеих вершин, пока не встретимся в общей. Если в ходе такого подъема мы прошли более 64 ребер, то в ходе замен мы получим x = 0 и мы можем на текущем шаге остановить алгоритм поиска. Таким образом, мы совершим не более O(log(x)) операций. Перейдем к задаче, где Rv > 0. Заметим, что наше предыдущее решение в таком случае может работать за O(n). Так как при прохождении по ребру с Rv = 1 наше значение не меняется. Сведем эту задачу к выше рассмотренной. Сожмем граф, то есть уберем все единичные ребра. Для этого запустим dfs от корня и будем хранить самое глубокое ребро на пути от корня до вершины с Rv > 1. Вспомним, что у нас были запросы уменьшения Rv. Будем поддерживать ближайшего предка Pv c RPv > 1. Воспользуемся идеей сжатия путей. При ответе на запрос первого типа будем пересчитывать Pv. Введем рекурсивную функцию F(v). Которая возвращает v, если Rv > 1, иначе выполняет присвоение Pv = F(Pv) и возвращает F(Pv). Каждое ребро мы удалим 1 раз, значит суммарно вызов всех функций F(v) работает O(n).Итоговое время работы O(logx) на запрос первого типа и O(1) в среднем на запрос второго типа.593E - Strange Calculation and CatsНаучимся решать задачу для маленьких t. Воспользуемся стандартной динамикой dpx, y, t = количеству способов попасть в клетку (x; y) в момент времени t. Пересчет это сумма по всем допустимым способам попасть в клетку (x; y) в момент времени t – 1. Заметим, что такую динамику можно считать при помощи возведения матрицы в степень. Заведем матрицу переходов, Ti, j = 1, если мы можем попасть из клетки i в клетку j. Пусть у нас был вектор G, где Gi равно количеству способов попасть в клетку i. Тогда новый вектор G' через dt секунд G' = G * (Tdt).Таким образом мы научились решать задачу без изменений за O(log dt * S3), где dt — момент времени, S – площадь. Рассмотрим, что происходит в момент добавления и удаления кота. При таких запросах изменяется матрица переходов. Между этими запросами T постоянная, значит мы можем возводить матрицу в степень. Таким образом, в момент изменения мы пересчитываем T, а между изменениями возводим матрицу в степень. Решение за O(m * S3 log dt), m – количество запросов",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21406",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 593\\s*B"
          },
          "content_length": 4985
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 1",
          "code": "delayed 10 mins",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 2",
          "code": "delayed 5 mins",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 3",
          "code": "Problem B. Anton and Lines\n*****\nx' is NOT guaranteed (and is NOT required) to be integer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 4",
          "code": "Problem B. Anton and Lines\n*****\nx' is NOT guaranteed (and is NOT required) to be integer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 5",
          "code": "y1[i] = k[i] * x1 + b[i];\ny2[i] = k[i] * x2 + b[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 6",
          "code": "y1[i] = k[i] * x1 + b[i];\ny2[i] = k[i] * x2 + b[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 7",
          "code": "y1[i] < y1[j] && y2[i] > y2[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 8",
          "code": "y1[i] < y1[j] && y2[i] > y2[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 9",
          "code": "y2[j] > y2[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 10",
          "code": "temp1:=lines[1,i]-lines[1,j];\ntemp2:=lines[2,j]-lines[2,i];\nif temp1<>0 \n  then temp3:=temp2/temp1 \n  else temp3:=0;\nif (temp3<x2)and(temp3>x1)\n  then ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 11",
          "code": "temp1:=lines[1,i]-lines[1,j];\ntemp2:=lines[2,j]-lines[2,i];\nif temp1<>0 \n  then temp3:=temp2/temp1 \n  else temp3:=0;\nif (temp3<x2)and(temp3>x1)\n  then ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 12",
          "code": "// a path from a to b. Initial value is y.\nlca = getLca(a, b)\n\nwhile (y > 0 && depth[a] > depth[lca])\n    // an edge e connects a and a's parent\n    if e.weight > 1\n         y /= e.weight\n         a = parent[a]\n    else\n         a = parent[a] // ***\n// do the same thing with b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 13",
          "code": "// a path from a to b. Initial value is y.\nlca = getLca(a, b)\n\nwhile (y > 0 && depth[a] > depth[lca])\n    // an edge e connects a and a's parent\n    if e.weight > 1\n         y /= e.weight\n         a = parent[a]\n    else\n         a = parent[a] // ***\n// do the same thing with b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 14",
          "code": "for each node u\n    for each child v of u\n        if e(u,v).weight == 1\n              g[v] = find(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 15",
          "code": "for each node u\n    for each child v of u\n        if e(u,v).weight == 1\n              g[v] = find(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 16",
          "code": "// update an edge e = (u, v). u is a parent of v.\n// new cost = c\n\nif c == 1\n    g[v] = find(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 17",
          "code": "// update an edge e = (u, v). u is a parent of v.\n// new cost = c\n\nif c == 1\n    g[v] = find(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 18",
          "code": "(0+(t-1)*(10+0*(t-2)))\n(10+(t-1)*((0-10)+10*(t-2)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 19",
          "code": "(0+(t-1)*(10+0*(t-2)))\n(10+(t-1)*((0-10)+10*(t-2)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 1",
          "code": "pair<ll,ll> a[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 2",
          "code": "i,j (i<j-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 3",
          "code": "if (sign(a[i].first-a[i+1].first)*sign(a[i].second-a[i+1].second)<0) ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 4",
          "code": "Y = a * X + b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 5",
          "code": "([Yi1, Yi2])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 6",
          "code": "Yi1 <= Y(i+1)1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 7",
          "code": "Yi2 >= Y(i+1)2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 8",
          "code": "stable_sort",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 9",
          "code": "#define MXN 1000000000000000000LL\n\nlong long mrg(long long x, long long y)\n{\n\tif( x * y < x || x * y < y) return MXN + 1LL;\n\n\treturn x * y;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 10",
          "code": "#define MXN 1000000000000000000LL\n\nlong long mrg(long long x, long long y)\n{\n\tif( x * y < x || x * y < y) return MXN + 1LL;\n\n\treturn x * y;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 11",
          "code": "#define MXN 1000000000000000000LL\n\nlong long mrg(long long x, long long y)\n{\n\tif((x * y)/y != x ) return MXN + 1LL;\n\n\treturn x * y;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 12",
          "code": "#define MXN 1000000000000000000LL\n\nlong long mrg(long long x, long long y)\n{\n\tif((x * y)/y != x ) return MXN + 1LL;\n\n\treturn x * y;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 13",
          "code": "x > 0 ? (y < 1) : (y > 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 14",
          "code": "unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    int x1 = inf.readInt(-1000000, 1000000, \"x1\");\n    inf.readSpace();\n    int x2 = inf.readInt(-1000000, 1000000, \"x2\");\n    ensuref(x1 < x2, \"x1 (%d) should be less than x2 (%d)\", x1, x2);\n    inf.readEoln();\n\n    set<pair<int, int>> lines;\n    for (int i = 0; i < n; ++i) {\n        int ki = inf.readInt(-1000000, 1000000, format(\"k[%d]\", i+1));\n        inf.readSpace();\n        int bi = inf.readInt(-1000000, 1000000, format(\"b[%d]\", i+1));\n        inf.readEoln();\n        auto res = lines.insert({ki, bi});\n        ensuref(res.second, \"Line %d is a duplicate of a previous line\", i+1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    int x1 = inf.readInt(-1000000, 1000000, \"x1\");\n    inf.readSpace();\n    int x2 = inf.readInt(-1000000, 1000000, \"x2\");\n    ensuref(x1 < x2, \"x1 (%d) should be less than x2 (%d)\", x1, x2);\n    inf.readEoln();\n\n    set<pair<int, int>> lines;\n    for (int i = 0; i < n; ++i) {\n        int ki = inf.readInt(-1000000, 1000000, format(\"k[%d]\", i+1));\n        inf.readSpace();\n        int bi = inf.readInt(-1000000, 1000000, format(\"b[%d]\", i+1));\n        inf.readEoln();\n        auto res = lines.insert({ki, bi});\n        ensuref(res.second, \"Line %d is a duplicate of a previous line\", i+1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    int x1 = inf.readInt(-1000000, 1000000, \"x1\");\n    inf.readSpace();\n    int x2 = inf.readInt(-1000000, 1000000, \"x2\");\n    ensuref(x1 < x2, \"x1 (%d) should be less than x2 (%d)\", x1, x2);\n    inf.readEoln();\n\n    set<pair<int, int>> lines;\n    for (int i = 0; i < n; ++i) {\n        int ki = inf.readInt(-1000000, 1000000, format(\"k[%d]\", i+1));\n        inf.readSpace();\n        int bi = inf.readInt(-1000000, 1000000, format(\"b[%d]\", i+1));\n        inf.readEoln();\n        auto res = lines.insert({ki, bi});\n        ensuref(res.second, \"Line %d is a duplicate of a previous line\", i+1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate random lines\nvoid generate_random_lines(int n, vector<pair<int, int>> &lines) {\n    set<pair<int, int>> line_set;\n    while (lines.size() < n) {\n        int ki = rnd.next(-1000000, 1000000);\n        int bi = rnd.next(-1000000, 1000000);\n        // Ensure lines are distinct\n        if (line_set.count({ki, bi}) == 0) {\n            lines.push_back({ki, bi});\n            line_set.insert({ki, bi});\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int x1 = opt<int>(\"x1\", 0);\n    int x2 = opt<int>(\"x2\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> lines;\n\n    if (type == \"random\") {\n        generate_random_lines(n, lines);\n    }\n    else if (type == \"parallel_lines\") {\n        // Generate lines with same ki, different bi\n        int ki = rnd.next(-1000000, 1000000);\n        set<int> bi_values;\n        while (lines.size() < n) {\n            int bi = rnd.next(-1000000, 1000000);\n            if (bi_values.count(bi) == 0) {\n                lines.push_back({ki, bi});\n                bi_values.insert(bi);\n            }\n        }\n    }\n    else if (type == \"intersect_at_border\") {\n        // Generate lines that intersect at x1 or x2\n\n        if(n < 2) {\n           cerr << \"n should be at least 2 for intersect_at_border\" << endl;\n           return 1;\n        }\n\n        int ki1 = rnd.next(-1000000, 1000000);\n        int ki2;\n        do {\n            ki2 = rnd.next(-1000000, 1000000);\n        } while (ki1 == ki2);\n\n        int bi1 = rnd.next(-1000000, 1000000);\n        int x_intersect = x1; // or x2\n        int bi2 = (ki1 - ki2) * x_intersect + bi1;\n\n        lines.push_back({ki1, bi1});\n        lines.push_back({ki2, bi2});\n\n        generate_random_lines(n - 2, lines);\n    }\n    else if (type == \"intersect_just_inside\") {\n        // Generate lines that intersect just inside the strip\n\n        if(n < 2) {\n           cerr << \"n should be at least 2 for intersect_just_inside\" << endl;\n           return 1;\n        }\n\n        double epsilon = 1e-6;\n        double x_prime = x1 + epsilon;\n\n        int ki1 = rnd.next(-1000000, 1000000);\n        int ki2;\n        do {\n            ki2 = rnd.next(-1000000, 1000000);\n        } while (ki1 == ki2);\n\n        int bi1 = rnd.next(-1000000, 1000000);\n        double bi2_double = (ki1 - ki2) * x_prime + bi1;\n        int bi2 = (int)round(bi2_double);\n\n        lines.push_back({ki1, bi1});\n        lines.push_back({ki2, bi2});\n\n        generate_random_lines(n - 2, lines);\n    }\n    else if (type == \"intersect_just_outside\") {\n        // Generate lines that intersect just outside the strip\n\n        if(n < 2) {\n           cerr << \"n should be at least 2 for intersect_just_outside\" << endl;\n           return 1;\n        }\n\n        double epsilon = 1e-6;\n        double x_prime = x1 - epsilon;\n\n        int ki1 = rnd.next(-1000000, 1000000);\n        int ki2;\n        do {\n            ki2 = rnd.next(-1000000, 1000000);\n        } while (ki1 == ki2);\n\n        int bi1 = rnd.next(-1000000, 1000000);\n        double bi2_double = (ki1 - ki2) * x_prime + bi1;\n        int bi2 = (int)round(bi2_double);\n\n        lines.push_back({ki1, bi1});\n        lines.push_back({ki2, bi2});\n\n        generate_random_lines(n - 2, lines);\n    }\n    else if (type == \"no_intersections\") {\n        // Generate lines that don't intersect between x1 and x2\n        // For example, all lines have ki = ki1, so they are parallel\n\n        int ki1 = rnd.next(-1000000, 1000000);\n\n        set<int> bi_values;\n        while (lines.size() < n) {\n            int bi = rnd.next(-1000000, 1000000);\n            if (bi_values.count(bi) == 0) {\n                lines.push_back({ki1, bi});\n                bi_values.insert(bi);\n            }\n        }\n    }\n    else if (type == \"intersect_inside\") {\n        // Generate lines that intersect between x1 and x2\n\n        if(n < 2) {\n           cerr << \"n should be at least 2 for intersect_inside\" << endl;\n           return 1;\n        }\n\n        double x_prime = x1 + (x2 - x1)/2.0;\n\n        int ki1 = rnd.next(-1000000, 1000000);\n        int ki2;\n        do {\n            ki2 = rnd.next(-1000000, 1000000);\n        } while (ki1 == ki2);\n\n        int bi1 = rnd.next(-1000000, 1000000);\n        double bi2_double = (ki1 - ki2) * x_prime + bi1;\n        int bi2 = (int)round(bi2_double);\n\n        lines.push_back({ki1, bi1});\n        lines.push_back({ki2, bi2});\n\n        generate_random_lines(n - 2, lines);\n    }\n    else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    printf(\"%d %d\\n\", x1, x2);\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", lines[i].first, lines[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate random lines\nvoid generate_random_lines(int n, vector<pair<int, int>> &lines) {\n    set<pair<int, int>> line_set;\n    while (lines.size() < n) {\n        int ki = rnd.next(-1000000, 1000000);\n        int bi = rnd.next(-1000000, 1000000);\n        // Ensure lines are distinct\n        if (line_set.count({ki, bi}) == 0) {\n            lines.push_back({ki, bi});\n            line_set.insert({ki, bi});\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int x1 = opt<int>(\"x1\", 0);\n    int x2 = opt<int>(\"x2\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> lines;\n\n    if (type == \"random\") {\n        generate_random_lines(n, lines);\n    }\n    else if (type == \"parallel_lines\") {\n        // Generate lines with same ki, different bi\n        int ki = rnd.next(-1000000, 1000000);\n        set<int> bi_values;\n        while (lines.size() < n) {\n            int bi = rnd.next(-1000000, 1000000);\n            if (bi_values.count(bi) == 0) {\n                lines.push_back({ki, bi});\n                bi_values.insert(bi);\n            }\n        }\n    }\n    else if (type == \"intersect_at_border\") {\n        // Generate lines that intersect at x1 or x2\n\n        if(n < 2) {\n           cerr << \"n should be at least 2 for intersect_at_border\" << endl;\n           return 1;\n        }\n\n        int ki1 = rnd.next(-1000000, 1000000);\n        int ki2;\n        do {\n            ki2 = rnd.next(-1000000, 1000000);\n        } while (ki1 == ki2);\n\n        int bi1 = rnd.next(-1000000, 1000000);\n        int x_intersect = x1; // or x2\n        int bi2 = (ki1 - ki2) * x_intersect + bi1;\n\n        lines.push_back({ki1, bi1});\n        lines.push_back({ki2, bi2});\n\n        generate_random_lines(n - 2, lines);\n    }\n    else if (type == \"intersect_just_inside\") {\n        // Generate lines that intersect just inside the strip\n\n        if(n < 2) {\n           cerr << \"n should be at least 2 for intersect_just_inside\" << endl;\n           return 1;\n        }\n\n        double epsilon = 1e-6;\n        double x_prime = x1 + epsilon;\n\n        int ki1 = rnd.next(-1000000, 1000000);\n        int ki2;\n        do {\n            ki2 = rnd.next(-1000000, 1000000);\n        } while (ki1 == ki2);\n\n        int bi1 = rnd.next(-1000000, 1000000);\n        double bi2_double = (ki1 - ki2) * x_prime + bi1;\n        int bi2 = (int)round(bi2_double);\n\n        lines.push_back({ki1, bi1});\n        lines.push_back({ki2, bi2});\n\n        generate_random_lines(n - 2, lines);\n    }\n    else if (type == \"intersect_just_outside\") {\n        // Generate lines that intersect just outside the strip\n\n        if(n < 2) {\n           cerr << \"n should be at least 2 for intersect_just_outside\" << endl;\n           return 1;\n        }\n\n        double epsilon = 1e-6;\n        double x_prime = x1 - epsilon;\n\n        int ki1 = rnd.next(-1000000, 1000000);\n        int ki2;\n        do {\n            ki2 = rnd.next(-1000000, 1000000);\n        } while (ki1 == ki2);\n\n        int bi1 = rnd.next(-1000000, 1000000);\n        double bi2_double = (ki1 - ki2) * x_prime + bi1;\n        int bi2 = (int)round(bi2_double);\n\n        lines.push_back({ki1, bi1});\n        lines.push_back({ki2, bi2});\n\n        generate_random_lines(n - 2, lines);\n    }\n    else if (type == \"no_intersections\") {\n        // Generate lines that don't intersect between x1 and x2\n        // For example, all lines have ki = ki1, so they are parallel\n\n        int ki1 = rnd.next(-1000000, 1000000);\n\n        set<int> bi_values;\n        while (lines.size() < n) {\n            int bi = rnd.next(-1000000, 1000000);\n            if (bi_values.count(bi) == 0) {\n                lines.push_back({ki1, bi});\n                bi_values.insert(bi);\n            }\n        }\n    }\n    else if (type == \"intersect_inside\") {\n        // Generate lines that intersect between x1 and x2\n\n        if(n < 2) {\n           cerr << \"n should be at least 2 for intersect_inside\" << endl;\n           return 1;\n        }\n\n        double x_prime = x1 + (x2 - x1)/2.0;\n\n        int ki1 = rnd.next(-1000000, 1000000);\n        int ki2;\n        do {\n            ki2 = rnd.next(-1000000, 1000000);\n        } while (ki1 == ki2);\n\n        int bi1 = rnd.next(-1000000, 1000000);\n        double bi2_double = (ki1 - ki2) * x_prime + bi1;\n        int bi2 = (int)round(bi2_double);\n\n        lines.push_back({ki1, bi1});\n        lines.push_back({ki2, bi2});\n\n        generate_random_lines(n - 2, lines);\n    }\n    else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    printf(\"%d %d\\n\", x1, x2);\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", lines[i].first, lines[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random test\n./gen -n 2 -x1 0 -x2 10 -type random\n\n# Small random test with negative x1\n./gen -n 5 -x1 -10 -x2 10 -type random\n\n# Medium random test\n./gen -n 1000 -x1 -1000 -x2 1000 -type random\n\n# Large random test\n./gen -n 100000 -x1 -1000000 -x2 1000000 -type random\n\n# Max size random test\n./gen -n 100000 -x1 -1000000 -x2 1000000 -type random\n\n# Max size random test with small x-range\n./gen -n 100000 -x1 -50 -x2 50 -type random\n\n# Parallel lines test small\n./gen -n 5 -x1 -100 -x2 100 -type parallel_lines\n\n# Parallel lines test medium\n./gen -n 1000 -x1 -1000 -x2 1000 -type parallel_lines\n\n# Parallel lines test large\n./gen -n 100000 -x1 -1000000 -x2 1000000 -type parallel_lines\n\n# Intersect at border small\n./gen -n 2 -x1 0 -x2 10 -type intersect_at_border\n\n# Intersect at border medium\n./gen -n 10 -x1 -50 -x2 50 -type intersect_at_border\n\n# Intersect at border large\n./gen -n 100000 -x1 -100000 -x2 100000 -type intersect_at_border\n\n# Intersect just inside small\n./gen -n 2 -x1 0 -x2 10 -type intersect_just_inside\n\n# Intersect just inside medium\n./gen -n 100 -x1 -100 -x2 100 -type intersect_just_inside\n\n# Intersect just inside large\n./gen -n 100000 -x1 -1000000 -x2 1000000 -type intersect_just_inside\n\n# Intersect just outside small\n./gen -n 2 -x1 0 -x2 10 -type intersect_just_outside\n\n# Intersect just outside medium\n./gen -n 10 -x1 -50 -x2 50 -type intersect_just_outside\n\n# Intersect just outside large\n./gen -n 100000 -x1 -1000000 -x2 1000000 -type intersect_just_outside\n\n# No intersections small\n./gen -n 5 -x1 -10 -x2 10 -type no_intersections\n\n# No intersections medium\n./gen -n 1000 -x1 -1000 -x2 -500 -type no_intersections\n\n# No intersections large\n./gen -n 100000 -x1 500000 -x2 1000000 -type no_intersections\n\n# Intersect inside small\n./gen -n 2 -x1 -10 -x2 10 -type intersect_inside\n\n# Intersect inside medium\n./gen -n 1000 -x1 -1000 -x2 1000 -type intersect_inside\n\n# Intersect inside large\n./gen -n 100000 -x1 -1000000 -x2 1000000 -type intersect_inside\n\n# Random with large negative slopes\n./gen -n 100000 -x1 -1000000 -x2 1000000 -type random\n\n# Random with small positive slopes\n./gen -n 100000 -x1 -1000000 -x2 1000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:57.294186",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "593/C",
      "title": "C. Красивая функция",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записано число n (1 ≤ n ≤ 50) — количество окружностей, загаданных Русланом. Следующие n строк содержат по три целых числа xi, yi, ri (0 ≤ xi, yi ≤ 50, 2 ≤ ri ≤ 50) — координаты и радиус i-й окружности.",
      "output_spec": "Выходные данныеВ первой строке выведите корректную функцию f(t). Во второй строке вывести корректную функцию g(t). Множество точек (xt = f(t), yt = g(t)) (0 ≤ t ≤ 50) должно удовлетворять условию, что для любой из n окружностей найдётся точка из данного мноежства лежащая внутри ли на границе.",
      "sample_tests": "ПримерыВходные данныеСкопировать30 10 410 0 420 10 4Выходные данныеСкопироватьt abs((t-10))",
      "description": "C. Красивая функция\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных записано число n (1 ≤ n ≤ 50) — количество окружностей, загаданных Русланом. Следующие n строк содержат по три целых числа xi, yi, ri (0 ≤ xi, yi ≤ 50, 2 ≤ ri ≤ 50) — координаты и радиус i-й окружности.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите корректную функцию f(t). Во второй строке вывести корректную функцию g(t). Множество точек (xt = f(t), yt = g(t)) (0 ≤ t ≤ 50) должно удовлетворять условию, что для любой из n окружностей найдётся точка из данного мноежства лежащая внутри ли на границе.\n\nВыходные данные\n\nВходные данныеСкопировать30 10 410 0 420 10 4Выходные данныеСкопироватьt abs((t-10))\n\nВходные данныеСкопировать30 10 410 0 420 10 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьt abs((t-10))\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеКорректные функции: 10 (1+2) ((t-3)+(t*4)) abs((t-10)) (abs((((23-t)*(t*t))+((45+12)*(t*t))))*((5*t)+((12*t)-13))) abs((t-(abs((t*31))+14))))Некорректные функции: 3+5+7 (не хватает скобок, должно быть ((3+5)+7) или (3+(5+7)))  abs(t-3) (не хватает скобок, должно быть abs((t-3)) 2+(2-3 (лишняя скобка) 1(t+5) (нет арифметической операции между 1 и скобкой) 5000*5000 (число превышает максимальное)  На картинке показано одно из возможных решений. Например, при t = 0;10;20 полученные координаты принадлежат заданным окружностям.",
      "solutions": [
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces",
          "content": "Всем привет!Завтра в 19.30 по московскому времени состоится Codeforces Round #329, который настоятельно не рекомендуется кому-либо пропускать.Задачи для вас готовили я и Станислав josdas Наумов. Я уверен, что это не последний раунд, в котором мы являемся авторами. Мы очень надеемся, что вам понравится раунд, и каждый найдет себе задачу по вкусу. Для того, чтобы увеличить вероятность этого события, пожалуйста, прочтите все задачи этого контеста.Как всегда, благодарим GlebsHP за неоценимую помощь при подготовке контеста, Delinur за перевод условий на английский язык и MikeMirzayanov за потрясающие системы Codeforces и Polygon.Отдельное спасибо хотим сказать Алексею Саплину, Эрике Шефер, Евгению Казакову, Богдану Трубецкому.Участникам будет предложено пять задач и два часа на их решение. Разбалловка будет объявлена позднее.Желаю удачи и высокого рейтинга!UPD1: Разбалловка будет динамической.UPD2: Разбор задач",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21371",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 919
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces",
          "content": "593A - 2CharДля каждой буквы будем поддерживать суммарную длину слов (cnt1ci), в которых встречается она одна, а для каждой пары букв будем поддерживать суммарную длину слов, в которых встречаются только они(cnt2ci, cj).Для каждой строки определим количество различных букв в ней. Если она одна, то добавим к этой букве длину этого слова. Если их две, то добавим к этой паре букв длину этого слова.Переберем пару букв, которая будет ответом. Для пары букв ci, cj ответом будет cnt1ci + cnt1cj + cnt2ci, cj. Среди всех таких пар найдем максимум и выведем его.Решение за O(суммарная длина всех строк + 26 * 26)593B - Anton and LinesЗаметим, что если i-я прямая пересекаются с j-й в данной полосе, а при x = x1 i-я прямая находится выше, то при x = x2 выше окажется j-я прямая. То есть отсортируем прямые по координате y при x = x1 + eps, и при x = x2 - eps. Проверим, что порядок прямых в обоих случаях совпадает. Если существует такая прямая, что ее индекс в первом случае не совпадает со вторым, то выведем Yes. В другом случае выведем No.Единственное, что может нам помешать это пересечение на границах, так как в таком случае порядок сортировки не определен. Тогда прибавим к нашей границе x1 бесконечно малую величину eps, а от x2 отнимем eps, и порядок сортировки будет задан однозначно.Решение за O(nlogn)593C - Beautiful FunctionОдним из ответов будет являться сумма таких выражений для каждой окружности по координате x и аналогично по координате y: Пусть a = 1, b = abs(t - i), тогда это можно записать как Рассмотрим a - b + abs(a - b):если a ≤ b, то a - b + abs(a - b) = 0,если a > b, то a - b + abs(a - b) = 2a - 2bтеперь рассмотрим, что такое a > b:1 > abs(t - i)i > t - 1, и i < t + 1.При целом i это возможно лишь в случае i = t.То есть эта скобка не обнуляется лишь при i = t.Рассмотрим 2a - 2b = 2 - 2 * abs(t - i) = 2. Тогда отличается от нужной координаты не более чем на 1, но так как все радиусы не меньше 2, то эта точка принадлежит окружности.Решение за O(n).593D - Happy Tree PartyРассмотрим задачу без запросов второго типа. Заметим, что в графе, где все числа на ребрах  > 1 максимальное количество присвоений до того, как x превратится в 0, не превышает 64. Действительно, если все Rv = 2, то количество операций можно оценить как log2(x). Подвесим дерево за какую-нибудь вершину и назовем ее корнем. Научимся решать задачу при условии, что для любого v Rv > 1 и нет запросов второго типа. Для каждой вершины кроме корня мы определили ее предка как соседа наиболее близкого к корню. Пусть у нас был запрос первого типа от вершины a до вершины b с иходным числом x. Разобьем путь на две вертикальные части, одна из которых приближается к корню, а другая отдаляется. Найдем все ребра на этом пути. Для этого посчитаем глубину каждой вершины как расстояние до корня. Теперь будем параллельно подниматься в дереве из обеих вершин, пока не встретимся в общей. Если в ходе такого подъема мы прошли более 64 ребер, то в ходе замен мы получим x = 0 и мы можем на текущем шаге остановить алгоритм поиска. Таким образом, мы совершим не более O(log(x)) операций. Перейдем к задаче, где Rv > 0. Заметим, что наше предыдущее решение в таком случае может работать за O(n). Так как при прохождении по ребру с Rv = 1 наше значение не меняется. Сведем эту задачу к выше рассмотренной. Сожмем граф, то есть уберем все единичные ребра. Для этого запустим dfs от корня и будем хранить самое глубокое ребро на пути от корня до вершины с Rv > 1. Вспомним, что у нас были запросы уменьшения Rv. Будем поддерживать ближайшего предка Pv c RPv > 1. Воспользуемся идеей сжатия путей. При ответе на запрос первого типа будем пересчитывать Pv. Введем рекурсивную функцию F(v). Которая возвращает v, если Rv > 1, иначе выполняет присвоение Pv = F(Pv) и возвращает F(Pv). Каждое ребро мы удалим 1 раз, значит суммарно вызов всех функций F(v) работает O(n).Итоговое время работы O(logx) на запрос первого типа и O(1) в среднем на запрос второго типа.593E - Strange Calculation and CatsНаучимся решать задачу для маленьких t. Воспользуемся стандартной динамикой dpx, y, t = количеству способов попасть в клетку (x; y) в момент времени t. Пересчет это сумма по всем допустимым способам попасть в клетку (x; y) в момент времени t – 1. Заметим, что такую динамику можно считать при помощи возведения матрицы в степень. Заведем матрицу переходов, Ti, j = 1, если мы можем попасть из клетки i в клетку j. Пусть у нас был вектор G, где Gi равно количеству способов попасть в клетку i. Тогда новый вектор G' через dt секунд G' = G * (Tdt).Таким образом мы научились решать задачу без изменений за O(log dt * S3), где dt — момент времени, S – площадь. Рассмотрим, что происходит в момент добавления и удаления кота. При таких запросах изменяется матрица переходов. Между этими запросами T постоянная, значит мы можем возводить матрицу в степень. Таким образом, в момент изменения мы пересчитываем T, а между изменениями возводим матрицу в степень. Решение за O(m * S3 log dt), m – количество запросов",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21406",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 593\\s*C"
          },
          "content_length": 4985
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 1",
          "code": "delayed 10 mins",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 2",
          "code": "delayed 5 mins",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 3",
          "code": "Problem B. Anton and Lines\n*****\nx' is NOT guaranteed (and is NOT required) to be integer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 4",
          "code": "Problem B. Anton and Lines\n*****\nx' is NOT guaranteed (and is NOT required) to be integer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 5",
          "code": "y1[i] = k[i] * x1 + b[i];\ny2[i] = k[i] * x2 + b[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 6",
          "code": "y1[i] = k[i] * x1 + b[i];\ny2[i] = k[i] * x2 + b[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 7",
          "code": "y1[i] < y1[j] && y2[i] > y2[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 8",
          "code": "y1[i] < y1[j] && y2[i] > y2[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 9",
          "code": "y2[j] > y2[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 10",
          "code": "temp1:=lines[1,i]-lines[1,j];\ntemp2:=lines[2,j]-lines[2,i];\nif temp1<>0 \n  then temp3:=temp2/temp1 \n  else temp3:=0;\nif (temp3<x2)and(temp3>x1)\n  then ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 11",
          "code": "temp1:=lines[1,i]-lines[1,j];\ntemp2:=lines[2,j]-lines[2,i];\nif temp1<>0 \n  then temp3:=temp2/temp1 \n  else temp3:=0;\nif (temp3<x2)and(temp3>x1)\n  then ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 12",
          "code": "// a path from a to b. Initial value is y.\nlca = getLca(a, b)\n\nwhile (y > 0 && depth[a] > depth[lca])\n    // an edge e connects a and a's parent\n    if e.weight > 1\n         y /= e.weight\n         a = parent[a]\n    else\n         a = parent[a] // ***\n// do the same thing with b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 13",
          "code": "// a path from a to b. Initial value is y.\nlca = getLca(a, b)\n\nwhile (y > 0 && depth[a] > depth[lca])\n    // an edge e connects a and a's parent\n    if e.weight > 1\n         y /= e.weight\n         a = parent[a]\n    else\n         a = parent[a] // ***\n// do the same thing with b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 14",
          "code": "for each node u\n    for each child v of u\n        if e(u,v).weight == 1\n              g[v] = find(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 15",
          "code": "for each node u\n    for each child v of u\n        if e(u,v).weight == 1\n              g[v] = find(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 16",
          "code": "// update an edge e = (u, v). u is a parent of v.\n// new cost = c\n\nif c == 1\n    g[v] = find(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 17",
          "code": "// update an edge e = (u, v). u is a parent of v.\n// new cost = c\n\nif c == 1\n    g[v] = find(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 18",
          "code": "(0+(t-1)*(10+0*(t-2)))\n(10+(t-1)*((0-10)+10*(t-2)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 19",
          "code": "(0+(t-1)*(10+0*(t-2)))\n(10+(t-1)*((0-10)+10*(t-2)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 1",
          "code": "pair<ll,ll> a[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 2",
          "code": "i,j (i<j-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 3",
          "code": "if (sign(a[i].first-a[i+1].first)*sign(a[i].second-a[i+1].second)<0) ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 4",
          "code": "Y = a * X + b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 5",
          "code": "([Yi1, Yi2])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 6",
          "code": "Yi1 <= Y(i+1)1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 7",
          "code": "Yi2 >= Y(i+1)2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 8",
          "code": "stable_sort",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 9",
          "code": "#define MXN 1000000000000000000LL\n\nlong long mrg(long long x, long long y)\n{\n\tif( x * y < x || x * y < y) return MXN + 1LL;\n\n\treturn x * y;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 10",
          "code": "#define MXN 1000000000000000000LL\n\nlong long mrg(long long x, long long y)\n{\n\tif( x * y < x || x * y < y) return MXN + 1LL;\n\n\treturn x * y;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 11",
          "code": "#define MXN 1000000000000000000LL\n\nlong long mrg(long long x, long long y)\n{\n\tif((x * y)/y != x ) return MXN + 1LL;\n\n\treturn x * y;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 12",
          "code": "#define MXN 1000000000000000000LL\n\nlong long mrg(long long x, long long y)\n{\n\tif((x * y)/y != x ) return MXN + 1LL;\n\n\treturn x * y;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 13",
          "code": "x > 0 ? (y < 1) : (y > 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 14",
          "code": "unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(0, 50, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(0, 50, \"yi\");\n        inf.readSpace();\n        int ri = inf.readInt(2, 50, \"ri\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(0, 50, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(0, 50, \"yi\");\n        inf.readSpace();\n        int ri = inf.readInt(2, 50, \"ri\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(0, 50, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(0, 50, \"yi\");\n        inf.readSpace();\n        int ri = inf.readInt(2, 50, \"ri\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Token {\n    enum Type { NUMBER, VARIABLE, PLUS, MINUS, MULTIPLY, LPAREN, RPAREN, ABS, END } type;\n    int value; // for NUMBER tokens\n    Token(Type type = END, int value = 0) : type(type), value(value) {}\n};\n\nclass Lexer {\n    string s;\n    int pos;\n    int len;\npublic:\n    Lexer(const string& str) : s(str), pos(0), len(str.length()) {}\n    Token getToken() {\n        if (pos >= len) return Token(Token::END);\n        char c = s[pos];\n        if (isdigit(c)) {\n            int val = 0;\n            while (pos < len && isdigit(s[pos])) {\n                val = val * 10 + (s[pos] - '0');\n                pos++;\n            }\n            return Token(Token::NUMBER, val);\n        }\n        if (isalpha(c)) {\n            if (s.substr(pos, 3) == \"abs\") {\n                pos += 3;\n                return Token(Token::ABS);\n            } else if (s[pos] == 't') {\n                pos++;\n                return Token(Token::VARIABLE);\n            } else {\n                return Token(Token::END); // invalid token\n            }\n        }\n        if (c == '+') {\n            pos++;\n            return Token(Token::PLUS);\n        }\n        if (c == '-') {\n            pos++;\n            return Token(Token::MINUS);\n        }\n        if (c == '*') {\n            pos++;\n            return Token(Token::MULTIPLY);\n        }\n        if (c == '(') {\n            pos++;\n            return Token(Token::LPAREN);\n        }\n        if (c == ')') {\n            pos++;\n            return Token(Token::RPAREN);\n        }\n        // Invalid character\n        return Token(Token::END);\n    }\n    int getPos() const { return pos; }\n};\n\nstruct ASTNode {\n    enum Type { CONST, VAR, ADD, SUB, MUL, ABS } type;\n    int value; // For CONST nodes\n    ASTNode* left;\n    ASTNode* right;\n    ASTNode(Type type) : type(type), value(0), left(nullptr), right(nullptr) {}\n    ~ASTNode() {\n        delete left;\n        delete right;\n    }\n};\n\nclass Parser {\n    Lexer lexer;\n    Token curToken;\n    int multiplicationCount;\n    const int MAX_MULTIPLICATIONS = 50;\n    int parsePos;\n    int failPos;\npublic:\n    Parser(const string& s) : lexer(s), multiplicationCount(0), parsePos(0), failPos(-1) {\n        curToken = lexer.getToken();\n    }\n    void nextToken() {\n        parsePos = lexer.getPos();\n        curToken = lexer.getToken();\n    }\n    ASTNode* parseFunction() {\n        ASTNode* res = parseExpr();\n        if (curToken.type != Token::END) {\n            failPos = parsePos;\n            return nullptr;\n        }\n        return res;\n    }\n    ASTNode* parseExpr() {\n        if (curToken.type == Token::NUMBER) {\n            int val = curToken.value;\n            if (val < 0 || val > 50) {\n                failPos = parsePos;\n                return nullptr;\n            }\n            nextToken();\n            ASTNode* node = new ASTNode(ASTNode::CONST);\n            node->value = val;\n            return node;\n        } else if (curToken.type == Token::VARIABLE) {\n            nextToken();\n            ASTNode* node = new ASTNode(ASTNode::VAR);\n            return node;\n        } else if (curToken.type == Token::ABS) {\n            nextToken();\n            if (curToken.type != Token::LPAREN) {\n                failPos = parsePos;\n                return nullptr;\n            }\n            nextToken();\n            ASTNode* expr = parseExpr();\n            if (!expr) return nullptr;\n            if (curToken.type != Token::RPAREN) {\n                failPos = parsePos;\n                return nullptr;\n            }\n            nextToken();\n            ASTNode* node = new ASTNode(ASTNode::ABS);\n            node->left = expr;\n            return node;\n        } else if (curToken.type == Token::LPAREN) {\n            nextToken();\n            ASTNode* left = parseExpr();\n            if (!left) return nullptr;\n            if (curToken.type != Token::PLUS && curToken.type != Token::MINUS && curToken.type != Token::MULTIPLY) {\n                failPos = parsePos;\n                return nullptr;\n            }\n            Token::Type op = curToken.type;\n            nextToken();\n            ASTNode* right = parseExpr();\n            if (!right) return nullptr;\n            if (curToken.type != Token::RPAREN) {\n                failPos = parsePos;\n                return nullptr;\n            }\n            nextToken();\n            ASTNode* node = new ASTNode(op == Token::PLUS ? ASTNode::ADD :\n                                        op == Token::MINUS ? ASTNode::SUB : ASTNode::MUL);\n            node->left = left;\n            node->right = right;\n            if (node->type == ASTNode::MUL) {\n                multiplicationCount++;\n                if (multiplicationCount > MAX_MULTIPLICATIONS) {\n                    failPos = parsePos;\n                    delete node;\n                    return nullptr;\n                }\n            }\n            return node;\n        } else {\n            failPos = parsePos;\n            return nullptr;\n        }\n    }\n    int getMultiplicationCount() const { return multiplicationCount; }\n    int getFailPos() const { return failPos; }\n};\n\nbool evaluate(ASTNode* node, int t, int64_t& result, bool& overflow) {\n    if (overflow) return false;\n    if (!node) {\n        overflow = true;\n        return false;\n    }\n    if (node->type == ASTNode::CONST) {\n        result = node->value;\n    } else if (node->type == ASTNode::VAR) {\n        result = t;\n    } else if (node->type == ASTNode::ABS) {\n        int64_t val;\n        if (!evaluate(node->left, t, val, overflow)) return false;\n        result = abs(val);\n        if (result > 1e9) {\n            overflow = true;\n            return false;\n        }\n    } else {\n        int64_t leftVal, rightVal;\n        if (!evaluate(node->left, t, leftVal, overflow)) return false;\n        if (!evaluate(node->right, t, rightVal, overflow)) return false;\n        if (abs(leftVal) > 1e9 || abs(rightVal) > 1e9) {\n            overflow = true;\n            return false;\n        }\n        if (node->type == ASTNode::ADD) {\n            result = leftVal + rightVal;\n        } else if (node->type == ASTNode::SUB) {\n            result = leftVal - rightVal;\n        } else if (node->type == ASTNode::MUL) {\n            result = leftVal * rightVal;\n        } else {\n            overflow = true;\n            return false;\n        }\n        if (abs(result) > 1e9) {\n            overflow = true;\n            return false;\n        }\n    }\n    return true;\n}\n\nstruct Circle {\n    int x, y, r;\n};\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt(1, 50);\n    vector<Circle> circles(n);\n    for (int i = 0; i < n; ++i) {\n        circles[i].x = inf.readInt(0, 50);\n        circles[i].y = inf.readInt(0, 50);\n        circles[i].r = inf.readInt(2, 50);\n    }\n    string f_str = ouf.readToken();\n    string g_str = ouf.readToken();\n    if (f_str.size() > 100 * n)\n        quitf(_wa, \"Length of f(t) exceeds limit: %d > %d\", int(f_str.size()), 100 * n);\n    if (g_str.size() > 100 * n)\n        quitf(_wa, \"Length of g(t) exceeds limit: %d > %d\", int(g_str.size()), 100 * n);\n    if (f_str.find(' ') != string::npos)\n        quitf(_wa, \"Function f(t) contains spaces\");\n    if (g_str.find(' ') != string::npos)\n        quitf(_wa, \"Function g(t) contains spaces\");\n\n    Parser f_parser(f_str);\n    ASTNode* f_ast = f_parser.parseFunction();\n    if (!f_ast)\n        quitf(_wa, \"Invalid function f(t) at position %d\", f_parser.getFailPos());\n    if (f_parser.getMultiplicationCount() > 50)\n        quitf(_wa, \"Number of multiplications in f(t) exceeds 50: %d\", f_parser.getMultiplicationCount());\n\n    Parser g_parser(g_str);\n    ASTNode* g_ast = g_parser.parseFunction();\n    if (!g_ast)\n        quitf(_wa, \"Invalid function g(t) at position %d\", g_parser.getFailPos());\n    if (g_parser.getMultiplicationCount() > 50)\n        quitf(_wa, \"Number of multiplications in g(t) exceeds 50: %d\", g_parser.getMultiplicationCount());\n\n    vector<int64_t> f_values(51), g_values(51);\n    for (int t = 0; t <= 50; ++t) {\n        int64_t f_val = 0, g_val = 0;\n        bool overflow = false;\n        if (!evaluate(f_ast, t, f_val, overflow) || overflow)\n            quitf(_wa, \"Overflow in f(t) at t=%d\", t);\n        if (!evaluate(g_ast, t, g_val, overflow) || overflow)\n            quitf(_wa, \"Overflow in g(t) at t=%d\", t);\n        if (abs(f_val) > 1e9)\n            quitf(_wa, \"Absolute value of f(%d) exceeds 1e9: %lld\", t, f_val);\n        if (abs(g_val) > 1e9)\n            quitf(_wa, \"Absolute value of g(%d) exceeds 1e9: %lld\", t, g_val);\n        f_values[t] = f_val;\n        g_values[t] = g_val;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        bool found = false;\n        int64_t xi = circles[i].x;\n        int64_t yi = circles[i].y;\n        int64_t ri_sq = int64_t(circles[i].r) * circles[i].r;\n        for (int t = 0; t <= 50; ++t) {\n            int64_t dx = f_values[t] - xi;\n            int64_t dy = g_values[t] - yi;\n            int64_t dist_sq = dx * dx + dy * dy;\n            if (dist_sq <= ri_sq) {\n                found = true;\n                break;\n            }\n        }\n        if (!found)\n            quitf(_wa, \"No point lies within circle %d\", i + 1);\n    }\n\n    delete f_ast;\n    delete g_ast;\n    quitf(_ok, \"Accepted\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 50);\n    vector<tuple<int, int, int>> circles;\n\n    if (type == \"random\") {\n        // Generate n random circles with random positions and radii within allowed ranges\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 50);\n            int yi = rnd.next(0, 50);\n            int ri = rnd.next(2, 50);\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else if (type == \"overlap\") {\n        // Generate n circles that all overlap (same center)\n        int xi = rnd.next(0, 50);\n        int yi = rnd.next(0, 50);\n        for (int i = 0; i < n; ++i) {\n            int ri = rnd.next(2, 50);\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else if (type == \"nonoverlap\") {\n        // Generate n circles that do not overlap\n        int grid_size = ceil(sqrt(n));\n        int idx = 0;\n        int spacing = 5;  // Minimum spacing between centers to prevent overlaps\n        for (int i = 0; i < grid_size && idx < n; ++i) {\n            for (int j = 0; j < grid_size && idx < n; ++j) {\n                int xi = i * spacing;\n                int yi = j * spacing;\n                if (xi > 50) xi = 50;\n                if (yi > 50) yi = 50;\n                int ri = 2;\n                circles.push_back(make_tuple(xi, yi, ri));\n                ++idx;\n            }\n        }\n    } else if (type == \"maxvalues\") {\n        // Generate n circles with maximum positions and maximum radii\n        for (int i = 0; i < n; ++i) {\n            int xi = 50;\n            int yi = 50;\n            int ri = 50;\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else if (type == \"minvalues\") {\n        // Generate n circles with minimum positions and minimum radii\n        for (int i = 0; i < n; ++i) {\n            int xi = 0;\n            int yi = 0;\n            int ri = 2;\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else if (type == \"line\") {\n        // Generate n circles arranged along a line\n        int xi = rnd.next(0, 50);\n        for (int i = 0; i < n; ++i) {\n            xi = (xi + 1) % 51;\n            int yi = rnd.next(0, 50);\n            int ri = rnd.next(2, 50);\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else if (type == \"cluster\") {\n        // Generate n circles clustered in a small area\n        int base_x = rnd.next(0, 50);\n        int base_y = rnd.next(0, 50);\n        for (int i = 0; i < n; ++i) {\n            int xi = base_x + rnd.next(-2, 2);\n            int yi = base_y + rnd.next(-2, 2);\n            xi = max(0, min(50, xi));\n            yi = max(0, min(50, yi));\n            int ri = rnd.next(2, 50);\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else if (type == \"edges\") {\n        // Generate circles at the edges of the allowed coordinate range\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 1) * 50;  // Either 0 or 50\n            int yi = rnd.next(0, 1) * 50;  // Either 0 or 50\n            int ri = rnd.next(2, 50);\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else if (type == \"same_radius\") {\n        // Generate n circles with the same radius\n        int ri = rnd.next(2, 50);\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 50);\n            int yi = rnd.next(0, 50);\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else if (type == \"increasing_radius\") {\n        // Generate circles with increasing radii\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 50);\n            int yi = rnd.next(0, 50);\n            int ri = 2 + i * (48 / max(1, n - 1));\n            ri = min(ri, 50);\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else if (type == \"decreasing_radius\") {\n        // Generate circles with decreasing radii\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 50);\n            int yi = rnd.next(0, 50);\n            int ri = 50 - i * (48 / max(1, n - 1));\n            ri = max(ri, 2);\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 50);\n            int yi = rnd.next(0, 50);\n            int ri = rnd.next(2, 50);\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (auto circle : circles) {\n        int xi, yi, ri;\n        tie(xi, yi, ri) = circle;\n        printf(\"%d %d %d\\n\", xi, yi, ri);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 50);\n    vector<tuple<int, int, int>> circles;\n\n    if (type == \"random\") {\n        // Generate n random circles with random positions and radii within allowed ranges\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 50);\n            int yi = rnd.next(0, 50);\n            int ri = rnd.next(2, 50);\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else if (type == \"overlap\") {\n        // Generate n circles that all overlap (same center)\n        int xi = rnd.next(0, 50);\n        int yi = rnd.next(0, 50);\n        for (int i = 0; i < n; ++i) {\n            int ri = rnd.next(2, 50);\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else if (type == \"nonoverlap\") {\n        // Generate n circles that do not overlap\n        int grid_size = ceil(sqrt(n));\n        int idx = 0;\n        int spacing = 5;  // Minimum spacing between centers to prevent overlaps\n        for (int i = 0; i < grid_size && idx < n; ++i) {\n            for (int j = 0; j < grid_size && idx < n; ++j) {\n                int xi = i * spacing;\n                int yi = j * spacing;\n                if (xi > 50) xi = 50;\n                if (yi > 50) yi = 50;\n                int ri = 2;\n                circles.push_back(make_tuple(xi, yi, ri));\n                ++idx;\n            }\n        }\n    } else if (type == \"maxvalues\") {\n        // Generate n circles with maximum positions and maximum radii\n        for (int i = 0; i < n; ++i) {\n            int xi = 50;\n            int yi = 50;\n            int ri = 50;\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else if (type == \"minvalues\") {\n        // Generate n circles with minimum positions and minimum radii\n        for (int i = 0; i < n; ++i) {\n            int xi = 0;\n            int yi = 0;\n            int ri = 2;\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else if (type == \"line\") {\n        // Generate n circles arranged along a line\n        int xi = rnd.next(0, 50);\n        for (int i = 0; i < n; ++i) {\n            xi = (xi + 1) % 51;\n            int yi = rnd.next(0, 50);\n            int ri = rnd.next(2, 50);\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else if (type == \"cluster\") {\n        // Generate n circles clustered in a small area\n        int base_x = rnd.next(0, 50);\n        int base_y = rnd.next(0, 50);\n        for (int i = 0; i < n; ++i) {\n            int xi = base_x + rnd.next(-2, 2);\n            int yi = base_y + rnd.next(-2, 2);\n            xi = max(0, min(50, xi));\n            yi = max(0, min(50, yi));\n            int ri = rnd.next(2, 50);\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else if (type == \"edges\") {\n        // Generate circles at the edges of the allowed coordinate range\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 1) * 50;  // Either 0 or 50\n            int yi = rnd.next(0, 1) * 50;  // Either 0 or 50\n            int ri = rnd.next(2, 50);\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else if (type == \"same_radius\") {\n        // Generate n circles with the same radius\n        int ri = rnd.next(2, 50);\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 50);\n            int yi = rnd.next(0, 50);\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else if (type == \"increasing_radius\") {\n        // Generate circles with increasing radii\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 50);\n            int yi = rnd.next(0, 50);\n            int ri = 2 + i * (48 / max(1, n - 1));\n            ri = min(ri, 50);\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else if (type == \"decreasing_radius\") {\n        // Generate circles with decreasing radii\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 50);\n            int yi = rnd.next(0, 50);\n            int ri = 50 - i * (48 / max(1, n - 1));\n            ri = max(ri, 2);\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, 50);\n            int yi = rnd.next(0, 50);\n            int ri = rnd.next(2, 50);\n            circles.push_back(make_tuple(xi, yi, ri));\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (auto circle : circles) {\n        int xi, yi, ri;\n        tie(xi, yi, ri) = circle;\n        printf(\"%d %d %d\\n\", xi, yi, ri);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type minvalues\n./gen -n 1 -type maxvalues\n./gen -n 1 -type overlap\n\n./gen -n 2 -type random\n./gen -n 2 -type overlap\n./gen -n 2 -type nonoverlap\n\n./gen -n 3 -type random\n./gen -n 3 -type cluster\n./gen -n 3 -type line\n\n./gen -n 5 -type random\n./gen -n 5 -type line\n./gen -n 5 -type edges\n\n./gen -n 10 -type random\n./gen -n 10 -type nonoverlap\n./gen -n 10 -type overlap\n./gen -n 10 -type cluster\n\n./gen -n 15 -type random\n./gen -n 15 -type same_radius\n./gen -n 15 -type increasing_radius\n\n./gen -n 20 -type random\n./gen -n 20 -type decreasing_radius\n./gen -n 20 -type maxvalues\n\n./gen -n 25 -type random\n./gen -n 25 -type cluster\n./gen -n 25 -type edges\n\n./gen -n 30 -type random\n./gen -n 30 -type nonoverlap\n./gen -n 30 -type overlap\n\n./gen -n 35 -type random\n./gen -n 35 -type line\n./gen -n 35 -type increasing_radius\n\n./gen -n 40 -type random\n./gen -n 40 -type cluster\n./gen -n 40 -type same_radius\n\n./gen -n 45 -type random\n./gen -n 45 -type decreasing_radius\n./gen -n 45 -type edges\n\n./gen -n 50 -type random\n./gen -n 50 -type nonoverlap\n./gen -n 50 -type overlap\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:54:59.632798",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "593/D",
      "title": "D. Happy Tree Party",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integers, n and m (2 ≤ n ≤ 200 000, 1 ≤ m ≤ 200 000) — the number of vertecies in the tree granted to Bogdan by his mom and the number of guests that came to the party respectively.Next n - 1 lines contain the description of the edges. The i-th of these lines contains three integers ui, vi and xi (1 ≤ ui, vi ≤ n, ui ≠ vi, 1 ≤ xi ≤ 1018), denoting an edge that connects vertecies ui and vi, with the number xi initially written on it.The following m lines describe operations, requested by Bogdan's guests. Each description contains three or four integers and has one of the two possible forms:   1 ai bi yi corresponds to a guest, who chooses the operation of the first type.  2 pi ci corresponds to a guests, who chooses the operation of the second type.  It is guaranteed that all the queries are correct, namely 1 ≤ ai, bi ≤ n, 1 ≤ pi ≤ n - 1, 1 ≤ yi ≤ 1018 and 1 ≤ ci < xpi, where xpi represents a number written on edge pi at this particular moment of time that is not necessarily equal to the initial value xpi, as some decreases may have already been applied to it. The edges are numbered from 1 to n - 1 in the order they appear in the input.",
      "output_spec": "OutputFor each guest who chooses the operation of the first type, print the result of processing the value yi through the path from ai to bi.",
      "sample_tests": "ExamplesInputCopy6 61 2 11 3 71 4 42 5 52 6 21 4 6 172 3 21 4 6 171 5 5 202 4 11 5 1 3OutputCopy24203InputCopy5 41 2 71 3 33 4 23 5 51 4 2 1001 5 4 12 2 21 1 3 4OutputCopy202",
      "description": "D. Happy Tree Party\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains integers, n and m (2 ≤ n ≤ 200 000, 1 ≤ m ≤ 200 000) — the number of vertecies in the tree granted to Bogdan by his mom and the number of guests that came to the party respectively.Next n - 1 lines contain the description of the edges. The i-th of these lines contains three integers ui, vi and xi (1 ≤ ui, vi ≤ n, ui ≠ vi, 1 ≤ xi ≤ 1018), denoting an edge that connects vertecies ui and vi, with the number xi initially written on it.The following m lines describe operations, requested by Bogdan's guests. Each description contains three or four integers and has one of the two possible forms:   1 ai bi yi corresponds to a guest, who chooses the operation of the first type.  2 pi ci corresponds to a guests, who chooses the operation of the second type.  It is guaranteed that all the queries are correct, namely 1 ≤ ai, bi ≤ n, 1 ≤ pi ≤ n - 1, 1 ≤ yi ≤ 1018 and 1 ≤ ci < xpi, where xpi represents a number written on edge pi at this particular moment of time that is not necessarily equal to the initial value xpi, as some decreases may have already been applied to it. The edges are numbered from 1 to n - 1 in the order they appear in the input.\n\nOutputFor each guest who chooses the operation of the first type, print the result of processing the value yi through the path from ai to bi.\n\nInputCopy6 61 2 11 3 71 4 42 5 52 6 21 4 6 172 3 21 4 6 171 5 5 202 4 11 5 1 3OutputCopy24203InputCopy5 41 2 71 3 33 4 23 5 51 4 2 1001 5 4 12 2 21 1 3 4OutputCopy202\n\nInputCopy6 61 2 11 3 71 4 42 5 52 6 21 4 6 172 3 21 4 6 171 5 5 202 4 11 5 1 3\n\nOutputCopy24203\n\nInputCopy5 41 2 71 3 33 4 23 5 51 4 2 1001 5 4 12 2 21 1 3 4\n\nOutputCopy202\n\nNoteInitially the tree looks like this:   The response to the first query is:  = 2After the third edge is changed, the tree looks like this:   The response to the second query is:  = 4In the third query the initial and final vertex coincide, that is, the answer will be the initial number 20.After the change in the fourth edge the tree looks like this:   In the last query the answer will be:  = 3",
      "solutions": [
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #329 (Div. 2). It'll be held on Wednesday, November 4 at 19:30 MSK and as usual Div. 1 participants can join out of competition. Writers are Stanislav Naumov (josdas) and Roman Korobkov (romanasa). There will be 5 problems and you'll have 2 hours to solve them. I hope you enjoy the problems.Great thanks to GlebsHP (Gleb Evstropov) for helping me preparing the contest, to Delinur (Maria Belova) for translating the statements into English, to MikeMirzayanov (Mike Mirzayanov) for the Codeforces and Polygon.The scoring distribution will be announced later.Good luck and high rating!UPD: The round will use the dynamic scoring with 250 points step.UPD2: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21371",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 725
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces",
          "content": "593A - 2CharFor each letter will maintain the total length of words (cnt1ci), which found it was alone, and for each pair of letters will maintain the total length of words that contains only them (cnt2ci, cj).For each row, count a number of different letters in it. If it is one, then add this letter to the length of the word. If two of them, then add to the pair of letters word`s length.Now find a pair of letters that will be the answer. For a pair of letters ci, cj answer is cnt1ci + cnt1cj + cnt2ci, cj. Among all these pairs find the maximum. This is the answer.The overall complexity is O (total length of all strings + 26 * 26)593B - Anton and LinesNote that if a s line intersects with the j th in this band, and at x = x1 i th line is higher, at x = x2 above would be j th line. Sort by y coordinate at x = x1 + eps, and x = x2 - eps. Verify that the order of lines in both cases is the same. If there is a line that its index in the former case does not coincide with the second, output Yes. In another case, derive No. The only thing that can stop us is the intersection at the borders, as in this case we dont know the sorts order. Then add to our border x1 small eps, and by x2 subtract eps, and the sort order is set uniquely. The overall complexity is O(nlogn)593C - Beautiful FunctionOne of the answers will be the amount of such expressions for each circle in the coordinate x and similarly coordinate y: For a = 1, b = abs(t - i), it can be written as Consider the a - b + abs(a - b):if a ≤ b, то a - b + abs(a - b) = 0,if a > b, то a - b + abs(a - b) = 2a - 2bNow consider what means a > b:1 > abs(t - i)i > t - 1 and i < t + 1.For integer i is possible only if i = t.That is, this bracket is not nullified only if i = t.Consider the 2a - 2b = 2 - 2 * abs(t - i) = 2. Then differs from the wanted position by no more than 1, but since all the radiuses are not less than 2, then this point belongs to the circle.The overall complexity is O(n).593D - Happy Tree PartyConsider the problem ignoring the second typed requests. We note that in the column where all the numbers on the edges of  >  1 maximum number of assignments to before x will turn into 0 is not exceeds 64. Indeed, if all the Rv = 2, the number of operations can be assessed as log2(x). Hang the tree for some top and call it the root.Learn how to solve the problem, provided that for every v Rv > 1 and no requests of the second type. For each vertex except the root, we have identified it as the ancestor of the neighbor closest to the root. Suppose we had a request of the first type from the top a to b vertices with original number x. We divide the road into two vertical parts, one of which is close to the root, while the other moves away. We find all the edges in this way. To do this, we calculate the depth of each node to the root of the distance. Now we will go up in parallel to the tree of the two peaks, until he met a total. If in the course of the recovery, we have been more than 64 edges, in the substitutions we get x = 0 and we can at the current step to stop the algorithm search. Thus, we make no more than O(log(x)) operations.Let`s turn to the problem, where Rv > 0. We note that our previous solution in this case can work for O(n). Since the passage of the edge with Rv = 1 our value does not change. We reduce this problem to the above consideration. Compress the graph, that is, remove all single edges. To do this, run by dfs root and will keep the deepest edge on the path from the root to the top with Rv > 1.Let us remember that we have had requests to reduce Rv. We maintain the closest ancestor of Pv c RPv > 1. We use the idea of compression paths. When answer to a request of the first type will be recalculated Pv. We introduce a recursive function F(v). Which returns the v, if Rv > 1, otherwise perform the assignment of Pv = F(Pv) and returns F(Pv). Each edge we will remove 1 times, so in total the call of all functions F(v) running O(n).Final time is O(logx) on request of the first type and O(1) an average of request of the second type.593E - Strange Calculation and CatsLearn how to solve the problem for small t. We use standard dynamic dpx, y, t = number of ways to get into the cell (x; y) at time t. Conversion is the sum of all valid ways to get into the cell (x; y) at time t — 1.Note that this dp can be counted by means of the construction of the power matrix. Head of the transition matrix, Ti, j = 1, if we can get out of the cell i in a cell j. Suppose we had a vector G, where Gi equal to the number of ways to get into the cell i. Then a new vector G' by dt second G' = G * (Tdt).So we learned to solve the problem without changes in O (log dt * S3), where dt — at a time, S — area.Consider what happens when adding or removing a cat. When such requests varies transition matrix. Between these requests constant T, then we can construct a power matrix. Thus, at the moment of change is recalculated T, and between changes in the degree of erecting matrix. The decision is O (m * S3 log dt), m — number of requests",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21406",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 593\\s*D"
          },
          "content_length": 5060
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 1",
          "code": "delayed 10 mins",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 2",
          "code": "delayed 5 mins",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 3",
          "code": "Problem B. Anton and Lines\n*****\nx' is NOT guaranteed (and is NOT required) to be integer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 4",
          "code": "Problem B. Anton and Lines\n*****\nx' is NOT guaranteed (and is NOT required) to be integer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 5",
          "code": "temp1:=lines[1,i]-lines[1,j];\ntemp2:=lines[2,j]-lines[2,i];\nif temp1<>0 \n  then temp3:=temp2/temp1 \n  else temp3:=0;\nif (temp3<x2)and(temp3>x1)\n  then ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 6",
          "code": "temp1:=lines[1,i]-lines[1,j];\ntemp2:=lines[2,j]-lines[2,i];\nif temp1<>0 \n  then temp3:=temp2/temp1 \n  else temp3:=0;\nif (temp3<x2)and(temp3>x1)\n  then ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 7",
          "code": "// a path from a to b. Initial value is y.\nlca = getLca(a, b)\n\nwhile (y > 0 && depth[a] > depth[lca])\n    // an edge e connects a and a's parent\n    if e.weight > 1\n         y /= e.weight\n         a = parent[a]\n    else\n         a = parent[a] // ***\n// do the same thing with b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 8",
          "code": "// a path from a to b. Initial value is y.\nlca = getLca(a, b)\n\nwhile (y > 0 && depth[a] > depth[lca])\n    // an edge e connects a and a's parent\n    if e.weight > 1\n         y /= e.weight\n         a = parent[a]\n    else\n         a = parent[a] // ***\n// do the same thing with b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 9",
          "code": "for each node u\n    for each child v of u\n        if e(u,v).weight == 1\n              g[v] = find(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 10",
          "code": "for each node u\n    for each child v of u\n        if e(u,v).weight == 1\n              g[v] = find(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 11",
          "code": "// update an edge e = (u, v). u is a parent of v.\n// new cost = c\n\nif c == 1\n    g[v] = find(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 12",
          "code": "// update an edge e = (u, v). u is a parent of v.\n// new cost = c\n\nif c == 1\n    g[v] = find(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 13",
          "code": "(0+(t-1)*(10+0*(t-2)))\n(10+(t-1)*((0-10)+10*(t-2)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 14",
          "code": "(0+(t-1)*(10+0*(t-2)))\n(10+(t-1)*((0-10)+10*(t-2)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 1",
          "code": "Y = a * X + b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 2",
          "code": "([Yi1, Yi2])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 3",
          "code": "Yi1 <= Y(i+1)1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 4",
          "code": "Yi2 >= Y(i+1)2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 5",
          "code": "#define MXN 1000000000000000000LL\n\nlong long mrg(long long x, long long y)\n{\n\tif( x * y < x || x * y < y) return MXN + 1LL;\n\n\treturn x * y;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 6",
          "code": "#define MXN 1000000000000000000LL\n\nlong long mrg(long long x, long long y)\n{\n\tif( x * y < x || x * y < y) return MXN + 1LL;\n\n\treturn x * y;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 7",
          "code": "#define MXN 1000000000000000000LL\n\nlong long mrg(long long x, long long y)\n{\n\tif((x * y)/y != x ) return MXN + 1LL;\n\n\treturn x * y;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 8",
          "code": "#define MXN 1000000000000000000LL\n\nlong long mrg(long long x, long long y)\n{\n\tif((x * y)/y != x ) return MXN + 1LL;\n\n\treturn x * y;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 9",
          "code": "x > 0 ? (y < 1) : (y > 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 10",
          "code": "unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for(int i = 1; i <= n; i++) parent[i] = i;\n\n    function<int(int)> find = [&](int u) {\n        return parent[u] == u ? u : parent[u] = find(parent[u]);\n    };\n\n    vector<long long> x(n); // x[1..n-1], x[0] unused\n\n    for(int i = 1; i <= n - 1; i++) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        ensuref(u != v, \"Edge endpoints must be distinct: u = %d, v = %d\", u, v);\n        inf.readSpace();\n        long long xi = inf.readLong(1, 1000000000000000000LL, \"xi\");\n        x[i] = xi;\n        inf.readEoln();\n\n        int fu = find(u);\n        int fv = find(v);\n        ensuref(fu != fv, \"Graph must be acyclic. Found cycle when adding edge between %d and %d\", u, v);\n        parent[fu] = fv;\n    }\n\n    for(int i = 0; i < m; i++) {\n        int op = inf.readInt(1, 2, \"op\");\n        if(op == 1) {\n            // Type 1 operation: \"1 ai bi yi\"\n            inf.readSpace();\n            int ai = inf.readInt(1, n, \"ai\");\n            inf.readSpace();\n            int bi = inf.readInt(1, n, \"bi\");\n            inf.readSpace();\n            long long yi = inf.readLong(1, 1000000000000000000LL, \"yi\");\n            inf.readEoln();\n        } else {\n            // Type 2 operation: \"2 pi ci\"\n            inf.readSpace();\n            int pi = inf.readInt(1, n - 1, \"pi\");\n            inf.readSpace();\n            ensuref(x[pi] >= 2, \"At operation %d, x[pi] = %lld, cannot decrease further\", i + 1, x[pi]);\n            long long ci = inf.readLong(1, x[pi] - 1, \"ci\");\n            inf.readEoln();\n            x[pi] = ci;\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for(int i = 1; i <= n; i++) parent[i] = i;\n\n    function<int(int)> find = [&](int u) {\n        return parent[u] == u ? u : parent[u] = find(parent[u]);\n    };\n\n    vector<long long> x(n); // x[1..n-1], x[0] unused\n\n    for(int i = 1; i <= n - 1; i++) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        ensuref(u != v, \"Edge endpoints must be distinct: u = %d, v = %d\", u, v);\n        inf.readSpace();\n        long long xi = inf.readLong(1, 1000000000000000000LL, \"xi\");\n        x[i] = xi;\n        inf.readEoln();\n\n        int fu = find(u);\n        int fv = find(v);\n        ensuref(fu != fv, \"Graph must be acyclic. Found cycle when adding edge between %d and %d\", u, v);\n        parent[fu] = fv;\n    }\n\n    for(int i = 0; i < m; i++) {\n        int op = inf.readInt(1, 2, \"op\");\n        if(op == 1) {\n            // Type 1 operation: \"1 ai bi yi\"\n            inf.readSpace();\n            int ai = inf.readInt(1, n, \"ai\");\n            inf.readSpace();\n            int bi = inf.readInt(1, n, \"bi\");\n            inf.readSpace();\n            long long yi = inf.readLong(1, 1000000000000000000LL, \"yi\");\n            inf.readEoln();\n        } else {\n            // Type 2 operation: \"2 pi ci\"\n            inf.readSpace();\n            int pi = inf.readInt(1, n - 1, \"pi\");\n            inf.readSpace();\n            ensuref(x[pi] >= 2, \"At operation %d, x[pi] = %lld, cannot decrease further\", i + 1, x[pi]);\n            long long ci = inf.readLong(1, x[pi] - 1, \"ci\");\n            inf.readEoln();\n            x[pi] = ci;\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for(int i = 1; i <= n; i++) parent[i] = i;\n\n    function<int(int)> find = [&](int u) {\n        return parent[u] == u ? u : parent[u] = find(parent[u]);\n    };\n\n    vector<long long> x(n); // x[1..n-1], x[0] unused\n\n    for(int i = 1; i <= n - 1; i++) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        ensuref(u != v, \"Edge endpoints must be distinct: u = %d, v = %d\", u, v);\n        inf.readSpace();\n        long long xi = inf.readLong(1, 1000000000000000000LL, \"xi\");\n        x[i] = xi;\n        inf.readEoln();\n\n        int fu = find(u);\n        int fv = find(v);\n        ensuref(fu != fv, \"Graph must be acyclic. Found cycle when adding edge between %d and %d\", u, v);\n        parent[fu] = fv;\n    }\n\n    for(int i = 0; i < m; i++) {\n        int op = inf.readInt(1, 2, \"op\");\n        if(op == 1) {\n            // Type 1 operation: \"1 ai bi yi\"\n            inf.readSpace();\n            int ai = inf.readInt(1, n, \"ai\");\n            inf.readSpace();\n            int bi = inf.readInt(1, n, \"bi\");\n            inf.readSpace();\n            long long yi = inf.readLong(1, 1000000000000000000LL, \"yi\");\n            inf.readEoln();\n        } else {\n            // Type 2 operation: \"2 pi ci\"\n            inf.readSpace();\n            int pi = inf.readInt(1, n - 1, \"pi\");\n            inf.readSpace();\n            ensuref(x[pi] >= 2, \"At operation %d, x[pi] = %lld, cannot decrease further\", i + 1, x[pi]);\n            long long ci = inf.readLong(1, x[pi] - 1, \"ci\");\n            inf.readEoln();\n            x[pi] = ci;\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    ll max_x = opt<ll>(\"max_x\", 1000000000000000000LL); // default to 1e18\n    int fraction_type1 = opt<int>(\"fraction_type1\", 50); // percentage of type 1 operations\n    int self_loops_fraction = opt<int>(\"self_loops_fraction\", 0); // percentage of self-loops in type 1 operations\n    ll xi_value = opt<ll>(\"xi_value\", -1LL); // If xi_value > 0, set all xi to xi_value\n    ll yi_min = opt<ll>(\"yi_min\", 1LL);\n    ll yi_max = opt<ll>(\"yi_max\", max_x);\n\n    vector<pair<int, int>> edges;\n\n    // Generate the tree\n    if (tree_type == \"chain\") {\n        // Tree is a path from 1 to n\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        // Tree is vertex 1 connected to all others\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n        // Optionally shuffle edges\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Generate xi for each edge\n    vector<ll> x(n - 1);\n    for (int i = 0; i < n - 1; ++i) {\n        if (xi_value > 0) {\n            x[i] = xi_value;\n        } else {\n            x[i] = rnd.next(1LL, max_x);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the edges and xi\n    // Edges are numbered from 1 to n - 1 in the order they appear in the input\n    for (int i = 0; i < n - 1; ++i) {\n        printf(\"%d %d %lld\\n\", edges[i].first, edges[i].second, x[i]);\n    }\n\n    // Now generate m operations\n    vector<string> operations;\n\n    int num_type1 = m * fraction_type1 / 100;\n    int num_type2 = m - num_type1;\n\n    // Randomly shuffle the order of operations\n    vector<int> op_types(m);\n    for (int i = 0; i < num_type1; ++i)\n        op_types[i] = 1;\n    for (int i = num_type1; i < m; ++i)\n        op_types[i] = 2;\n    shuffle(op_types.begin(), op_types.end());\n\n    for (int i = 0; i < m; ++i) {\n        if (op_types[i] == 1) {\n            // Type 1 operation\n            int ai = rnd.next(1, n);\n            int bi;\n            if (rnd.next(100) < self_loops_fraction) {\n                bi = ai;\n            } else {\n                bi = rnd.next(1, n);\n            }\n            ll yi = rnd.next(yi_min, yi_max);\n            char buf[100];\n            sprintf(buf, \"1 %d %d %lld\", ai, bi, yi);\n            operations.push_back(string(buf));\n        } else {\n            // Type 2 operation\n            int pi = rnd.next(1, n - 1); // edges are numbered from 1 to n - 1\n            ll current_xpi = x[pi - 1];\n            // ci must be >=1 and < xpi\n            if (current_xpi <= 1) {\n                // Cannot decrease xpi further, pick another edge\n                int num_tries = 100;\n                while (current_xpi <= 1 && num_tries > 0) {\n                    pi = rnd.next(1, n - 1);\n                    current_xpi = x[pi - 1];\n                    --num_tries;\n                }\n                if (current_xpi <= 1) {\n                    // All xpi are 1, cannot perform this operation, default to type 1 operation\n                    int ai = rnd.next(1, n);\n                    int bi;\n                    if (rnd.next(100) < self_loops_fraction) {\n                        bi = ai;\n                    } else {\n                        bi = rnd.next(1, n);\n                    }\n                    ll yi = rnd.next(yi_min, yi_max);\n                    char buf[100];\n                    sprintf(buf, \"1 %d %d %lld\", ai, bi, yi);\n                    operations.push_back(string(buf));\n                    continue;\n                }\n            }\n            ll ci = rnd.next(1LL, current_xpi - 1);\n            // Update xpi\n            x[pi - 1] = ci;\n            char buf[100];\n            sprintf(buf, \"2 %d %lld\", pi, ci);\n            operations.push_back(string(buf));\n        }\n    }\n\n    // Output the operations\n    for (const auto& op : operations) {\n        printf(\"%s\\n\", op.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    ll max_x = opt<ll>(\"max_x\", 1000000000000000000LL); // default to 1e18\n    int fraction_type1 = opt<int>(\"fraction_type1\", 50); // percentage of type 1 operations\n    int self_loops_fraction = opt<int>(\"self_loops_fraction\", 0); // percentage of self-loops in type 1 operations\n    ll xi_value = opt<ll>(\"xi_value\", -1LL); // If xi_value > 0, set all xi to xi_value\n    ll yi_min = opt<ll>(\"yi_min\", 1LL);\n    ll yi_max = opt<ll>(\"yi_max\", max_x);\n\n    vector<pair<int, int>> edges;\n\n    // Generate the tree\n    if (tree_type == \"chain\") {\n        // Tree is a path from 1 to n\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        // Tree is vertex 1 connected to all others\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n        // Optionally shuffle edges\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Generate xi for each edge\n    vector<ll> x(n - 1);\n    for (int i = 0; i < n - 1; ++i) {\n        if (xi_value > 0) {\n            x[i] = xi_value;\n        } else {\n            x[i] = rnd.next(1LL, max_x);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the edges and xi\n    // Edges are numbered from 1 to n - 1 in the order they appear in the input\n    for (int i = 0; i < n - 1; ++i) {\n        printf(\"%d %d %lld\\n\", edges[i].first, edges[i].second, x[i]);\n    }\n\n    // Now generate m operations\n    vector<string> operations;\n\n    int num_type1 = m * fraction_type1 / 100;\n    int num_type2 = m - num_type1;\n\n    // Randomly shuffle the order of operations\n    vector<int> op_types(m);\n    for (int i = 0; i < num_type1; ++i)\n        op_types[i] = 1;\n    for (int i = num_type1; i < m; ++i)\n        op_types[i] = 2;\n    shuffle(op_types.begin(), op_types.end());\n\n    for (int i = 0; i < m; ++i) {\n        if (op_types[i] == 1) {\n            // Type 1 operation\n            int ai = rnd.next(1, n);\n            int bi;\n            if (rnd.next(100) < self_loops_fraction) {\n                bi = ai;\n            } else {\n                bi = rnd.next(1, n);\n            }\n            ll yi = rnd.next(yi_min, yi_max);\n            char buf[100];\n            sprintf(buf, \"1 %d %d %lld\", ai, bi, yi);\n            operations.push_back(string(buf));\n        } else {\n            // Type 2 operation\n            int pi = rnd.next(1, n - 1); // edges are numbered from 1 to n - 1\n            ll current_xpi = x[pi - 1];\n            // ci must be >=1 and < xpi\n            if (current_xpi <= 1) {\n                // Cannot decrease xpi further, pick another edge\n                int num_tries = 100;\n                while (current_xpi <= 1 && num_tries > 0) {\n                    pi = rnd.next(1, n - 1);\n                    current_xpi = x[pi - 1];\n                    --num_tries;\n                }\n                if (current_xpi <= 1) {\n                    // All xpi are 1, cannot perform this operation, default to type 1 operation\n                    int ai = rnd.next(1, n);\n                    int bi;\n                    if (rnd.next(100) < self_loops_fraction) {\n                        bi = ai;\n                    } else {\n                        bi = rnd.next(1, n);\n                    }\n                    ll yi = rnd.next(yi_min, yi_max);\n                    char buf[100];\n                    sprintf(buf, \"1 %d %d %lld\", ai, bi, yi);\n                    operations.push_back(string(buf));\n                    continue;\n                }\n            }\n            ll ci = rnd.next(1LL, current_xpi - 1);\n            // Update xpi\n            x[pi - 1] = ci;\n            char buf[100];\n            sprintf(buf, \"2 %d %lld\", pi, ci);\n            operations.push_back(string(buf));\n        }\n    }\n\n    // Output the operations\n    for (const auto& op : operations) {\n        printf(\"%s\\n\", op.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -tree_type chain\n./gen -n 2 -m 1 -tree_type star\n./gen -n 2 -m 1 -tree_type random\n\n./gen -n 5 -m 5 -tree_type chain\n./gen -n 5 -m 5 -tree_type star\n./gen -n 5 -m 5 -tree_type random\n\n./gen -n 10 -m 20 -tree_type chain\n./gen -n 10 -m 20 -tree_type star\n./gen -n 10 -m 20 -tree_type random\n\n./gen -n 1000 -m 1000 -tree_type chain -fraction_type1 100\n./gen -n 1000 -m 1000 -tree_type star -fraction_type1 0\n./gen -n 1000 -m 1000 -tree_type random -fraction_type1 50\n\n# yi is always 1\n./gen -n 1000 -m 1000 -tree_type random -yi_min 1 -yi_max 1\n\n# yi is always 1e18\n./gen -n 1000 -m 1000 -tree_type random -yi_min 1000000000000000000 -yi_max 1000000000000000000\n\n# xi is always 1\n./gen -n 1000 -m 1000 -tree_type random -xi_value 1\n\n# xi is always 1e18\n./gen -n 1000 -m 1000 -tree_type random -xi_value 1000000000000000000\n\n# Maximum size\n./gen -n 200000 -m 200000 -tree_type random\n\n# All operations are type 1\n./gen -n 1000 -m 1000 -tree_type random -fraction_type1 100\n\n# All operations are type 2\n./gen -n 1000 -m 1000 -tree_type random -fraction_type1 0\n\n# All type 1 operations are self loops (ai == bi)\n./gen -n 1000 -m 1000 -tree_type random -self_loops_fraction 100\n\n# Edge case: chain with max n and m\n./gen -n 200000 -m 200000 -tree_type chain\n\n# Edge case: star with max n and m\n./gen -n 200000 -m 200000 -tree_type star\n\n# Random tree with xi = 1\n./gen -n 10000 -m 10000 -tree_type random -xi_value 1\n\n# Chain with xi = 1\n./gen -n 10000 -m 10000 -tree_type chain -xi_value 1\n\n# Star with xi = max x\n./gen -n 10000 -m 10000 -tree_type star -xi_value 1000000000000000000\n\n# Random tree with xi small (e.g., xi between 1 and 10)\n./gen -n 10000 -m 10000 -tree_type random -xi_value 10\n\n# Random tree with xi large (e.g., xi = 1e18)\n./gen -n 10000 -m 10000 -tree_type random -xi_value 1000000000000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:55:01.469286",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "593/E",
      "title": "E. Странные вычисления и кошки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записаны три целых положительных числа n, m и q (1 ≤ n·m ≤ 20, 1 ≤ q ≤ 10 000) — количество строк и столбцов в таблице, а так же количество событий соответственно.Следующие q строк описывают события, каждое описание содержит четыре целых числа tpi, xi, yi и ti (1 ≤ tp ≤ 3, 1 ≤ x ≤ n, 1 ≤ y ≤ m, 2 ≤ t ≤ 109) — тип события (1 когда Гошу зовут в гости, 2 когда появляется кошка и 3 когда кошка уходит), координаты клетки, с которой происходит действие, момент времени, в которое происходит действие соответственно.Гарантируется, что запросы даны в хронологическом порядке, то есть ti < ti + 1.",
      "output_spec": "Выходные данныеДля каждого приглашения в гости i (то есть tpi = 1) выведите количество способов попасть в клетку клетку (xi, yi) в момент времени ti. Отвечайте на приглашения в хронологическом порядке, то есть в порядке их следования во входном файле.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 3 32 1 2 33 1 2 51 1 1 7Выходные данныеСкопировать5Входные данныеСкопировать3 3 32 2 2 21 3 3 51 3 3 7Выходные данныеСкопировать242Входные данныеСкопировать4 5 52 2 5 32 2 4 63 2 4 91 4 4 131 4 4 15Выходные данныеСкопировать49090210598759",
      "description": "E. Странные вычисления и кошки\n\nограничение по времени на тест4 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных записаны три целых положительных числа n, m и q (1 ≤ n·m ≤ 20, 1 ≤ q ≤ 10 000) — количество строк и столбцов в таблице, а так же количество событий соответственно.Следующие q строк описывают события, каждое описание содержит четыре целых числа tpi, xi, yi и ti (1 ≤ tp ≤ 3, 1 ≤ x ≤ n, 1 ≤ y ≤ m, 2 ≤ t ≤ 109) — тип события (1 когда Гошу зовут в гости, 2 когда появляется кошка и 3 когда кошка уходит), координаты клетки, с которой происходит действие, момент времени, в которое происходит действие соответственно.Гарантируется, что запросы даны в хронологическом порядке, то есть ti < ti + 1.\n\nВходные данные\n\nВыходные данныеДля каждого приглашения в гости i (то есть tpi = 1) выведите количество способов попасть в клетку клетку (xi, yi) в момент времени ti. Отвечайте на приглашения в хронологическом порядке, то есть в порядке их следования во входном файле.\n\nВыходные данные\n\nВходные данныеСкопировать1 3 32 1 2 33 1 2 51 1 1 7Выходные данныеСкопировать5Входные данныеСкопировать3 3 32 2 2 21 3 3 51 3 3 7Выходные данныеСкопировать242Входные данныеСкопировать4 5 52 2 5 32 2 4 63 2 4 91 4 4 131 4 4 15Выходные данныеСкопировать49090210598759\n\nВходные данныеСкопировать1 3 32 1 2 33 1 2 51 1 1 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 3 32 2 2 21 3 3 51 3 3 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать242\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 5 52 2 5 32 2 4 63 2 4 91 4 4 131 4 4 15\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать49090210598759\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПояснение к первому примеру. В каждой картинке указано количество способов прийти в клетку в соответствующий момент времени. (X обозначает заблокированную клетку в этот момент)  Момент времени 1.   Момент времени 2.  Момент времени 3.  Момент времени 4.  Момент времени 5.  Момент времени 6.  Момент времени 7.",
      "solutions": [
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces",
          "content": "Всем привет!Завтра в 19.30 по московскому времени состоится Codeforces Round #329, который настоятельно не рекомендуется кому-либо пропускать.Задачи для вас готовили я и Станислав josdas Наумов. Я уверен, что это не последний раунд, в котором мы являемся авторами. Мы очень надеемся, что вам понравится раунд, и каждый найдет себе задачу по вкусу. Для того, чтобы увеличить вероятность этого события, пожалуйста, прочтите все задачи этого контеста.Как всегда, благодарим GlebsHP за неоценимую помощь при подготовке контеста, Delinur за перевод условий на английский язык и MikeMirzayanov за потрясающие системы Codeforces и Polygon.Отдельное спасибо хотим сказать Алексею Саплину, Эрике Шефер, Евгению Казакову, Богдану Трубецкому.Участникам будет предложено пять задач и два часа на их решение. Разбалловка будет объявлена позднее.Желаю удачи и высокого рейтинга!UPD1: Разбалловка будет динамической.UPD2: Разбор задач",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21371",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 919
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces",
          "content": "593A - 2CharДля каждой буквы будем поддерживать суммарную длину слов (cnt1ci), в которых встречается она одна, а для каждой пары букв будем поддерживать суммарную длину слов, в которых встречаются только они(cnt2ci, cj).Для каждой строки определим количество различных букв в ней. Если она одна, то добавим к этой букве длину этого слова. Если их две, то добавим к этой паре букв длину этого слова.Переберем пару букв, которая будет ответом. Для пары букв ci, cj ответом будет cnt1ci + cnt1cj + cnt2ci, cj. Среди всех таких пар найдем максимум и выведем его.Решение за O(суммарная длина всех строк + 26 * 26)593B - Anton and LinesЗаметим, что если i-я прямая пересекаются с j-й в данной полосе, а при x = x1 i-я прямая находится выше, то при x = x2 выше окажется j-я прямая. То есть отсортируем прямые по координате y при x = x1 + eps, и при x = x2 - eps. Проверим, что порядок прямых в обоих случаях совпадает. Если существует такая прямая, что ее индекс в первом случае не совпадает со вторым, то выведем Yes. В другом случае выведем No.Единственное, что может нам помешать это пересечение на границах, так как в таком случае порядок сортировки не определен. Тогда прибавим к нашей границе x1 бесконечно малую величину eps, а от x2 отнимем eps, и порядок сортировки будет задан однозначно.Решение за O(nlogn)593C - Beautiful FunctionОдним из ответов будет являться сумма таких выражений для каждой окружности по координате x и аналогично по координате y: Пусть a = 1, b = abs(t - i), тогда это можно записать как Рассмотрим a - b + abs(a - b):если a ≤ b, то a - b + abs(a - b) = 0,если a > b, то a - b + abs(a - b) = 2a - 2bтеперь рассмотрим, что такое a > b:1 > abs(t - i)i > t - 1, и i < t + 1.При целом i это возможно лишь в случае i = t.То есть эта скобка не обнуляется лишь при i = t.Рассмотрим 2a - 2b = 2 - 2 * abs(t - i) = 2. Тогда отличается от нужной координаты не более чем на 1, но так как все радиусы не меньше 2, то эта точка принадлежит окружности.Решение за O(n).593D - Happy Tree PartyРассмотрим задачу без запросов второго типа. Заметим, что в графе, где все числа на ребрах  > 1 максимальное количество присвоений до того, как x превратится в 0, не превышает 64. Действительно, если все Rv = 2, то количество операций можно оценить как log2(x). Подвесим дерево за какую-нибудь вершину и назовем ее корнем. Научимся решать задачу при условии, что для любого v Rv > 1 и нет запросов второго типа. Для каждой вершины кроме корня мы определили ее предка как соседа наиболее близкого к корню. Пусть у нас был запрос первого типа от вершины a до вершины b с иходным числом x. Разобьем путь на две вертикальные части, одна из которых приближается к корню, а другая отдаляется. Найдем все ребра на этом пути. Для этого посчитаем глубину каждой вершины как расстояние до корня. Теперь будем параллельно подниматься в дереве из обеих вершин, пока не встретимся в общей. Если в ходе такого подъема мы прошли более 64 ребер, то в ходе замен мы получим x = 0 и мы можем на текущем шаге остановить алгоритм поиска. Таким образом, мы совершим не более O(log(x)) операций. Перейдем к задаче, где Rv > 0. Заметим, что наше предыдущее решение в таком случае может работать за O(n). Так как при прохождении по ребру с Rv = 1 наше значение не меняется. Сведем эту задачу к выше рассмотренной. Сожмем граф, то есть уберем все единичные ребра. Для этого запустим dfs от корня и будем хранить самое глубокое ребро на пути от корня до вершины с Rv > 1. Вспомним, что у нас были запросы уменьшения Rv. Будем поддерживать ближайшего предка Pv c RPv > 1. Воспользуемся идеей сжатия путей. При ответе на запрос первого типа будем пересчитывать Pv. Введем рекурсивную функцию F(v). Которая возвращает v, если Rv > 1, иначе выполняет присвоение Pv = F(Pv) и возвращает F(Pv). Каждое ребро мы удалим 1 раз, значит суммарно вызов всех функций F(v) работает O(n).Итоговое время работы O(logx) на запрос первого типа и O(1) в среднем на запрос второго типа.593E - Strange Calculation and CatsНаучимся решать задачу для маленьких t. Воспользуемся стандартной динамикой dpx, y, t = количеству способов попасть в клетку (x; y) в момент времени t. Пересчет это сумма по всем допустимым способам попасть в клетку (x; y) в момент времени t – 1. Заметим, что такую динамику можно считать при помощи возведения матрицы в степень. Заведем матрицу переходов, Ti, j = 1, если мы можем попасть из клетки i в клетку j. Пусть у нас был вектор G, где Gi равно количеству способов попасть в клетку i. Тогда новый вектор G' через dt секунд G' = G * (Tdt).Таким образом мы научились решать задачу без изменений за O(log dt * S3), где dt — момент времени, S – площадь. Рассмотрим, что происходит в момент добавления и удаления кота. При таких запросах изменяется матрица переходов. Между этими запросами T постоянная, значит мы можем возводить матрицу в степень. Таким образом, в момент изменения мы пересчитываем T, а между изменениями возводим матрицу в степень. Решение за O(m * S3 log dt), m – количество запросов",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21406",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 593\\s*E"
          },
          "content_length": 4985
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 1",
          "code": "delayed 10 mins",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 2",
          "code": "delayed 5 mins",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 3",
          "code": "Problem B. Anton and Lines\n*****\nx' is NOT guaranteed (and is NOT required) to be integer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 4",
          "code": "Problem B. Anton and Lines\n*****\nx' is NOT guaranteed (and is NOT required) to be integer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 5",
          "code": "y1[i] = k[i] * x1 + b[i];\ny2[i] = k[i] * x2 + b[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 6",
          "code": "y1[i] = k[i] * x1 + b[i];\ny2[i] = k[i] * x2 + b[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 7",
          "code": "y1[i] < y1[j] && y2[i] > y2[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 8",
          "code": "y1[i] < y1[j] && y2[i] > y2[j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 9",
          "code": "y2[j] > y2[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 10",
          "code": "temp1:=lines[1,i]-lines[1,j];\ntemp2:=lines[2,j]-lines[2,i];\nif temp1<>0 \n  then temp3:=temp2/temp1 \n  else temp3:=0;\nif (temp3<x2)and(temp3>x1)\n  then ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 11",
          "code": "temp1:=lines[1,i]-lines[1,j];\ntemp2:=lines[2,j]-lines[2,i];\nif temp1<>0 \n  then temp3:=temp2/temp1 \n  else temp3:=0;\nif (temp3<x2)and(temp3>x1)\n  then ....",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 12",
          "code": "// a path from a to b. Initial value is y.\nlca = getLca(a, b)\n\nwhile (y > 0 && depth[a] > depth[lca])\n    // an edge e connects a and a's parent\n    if e.weight > 1\n         y /= e.weight\n         a = parent[a]\n    else\n         a = parent[a] // ***\n// do the same thing with b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 13",
          "code": "// a path from a to b. Initial value is y.\nlca = getLca(a, b)\n\nwhile (y > 0 && depth[a] > depth[lca])\n    // an edge e connects a and a's parent\n    if e.weight > 1\n         y /= e.weight\n         a = parent[a]\n    else\n         a = parent[a] // ***\n// do the same thing with b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 14",
          "code": "for each node u\n    for each child v of u\n        if e(u,v).weight == 1\n              g[v] = find(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 15",
          "code": "for each node u\n    for each child v of u\n        if e(u,v).weight == 1\n              g[v] = find(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 16",
          "code": "// update an edge e = (u, v). u is a parent of v.\n// new cost = c\n\nif c == 1\n    g[v] = find(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 17",
          "code": "// update an edge e = (u, v). u is a parent of v.\n// new cost = c\n\nif c == 1\n    g[v] = find(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 18",
          "code": "(0+(t-1)*(10+0*(t-2)))\n(10+(t-1)*((0-10)+10*(t-2)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Div. 2) - Codeforces - Code 19",
          "code": "(0+(t-1)*(10+0*(t-2)))\n(10+(t-1)*((0-10)+10*(t-2)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 1",
          "code": "pair<ll,ll> a[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 2",
          "code": "i,j (i<j-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 3",
          "code": "if (sign(a[i].first-a[i+1].first)*sign(a[i].second-a[i+1].second)<0) ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 4",
          "code": "Y = a * X + b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 5",
          "code": "([Yi1, Yi2])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 6",
          "code": "Yi1 <= Y(i+1)1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 7",
          "code": "Yi2 >= Y(i+1)2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 8",
          "code": "stable_sort",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 9",
          "code": "#define MXN 1000000000000000000LL\n\nlong long mrg(long long x, long long y)\n{\n\tif( x * y < x || x * y < y) return MXN + 1LL;\n\n\treturn x * y;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 10",
          "code": "#define MXN 1000000000000000000LL\n\nlong long mrg(long long x, long long y)\n{\n\tif( x * y < x || x * y < y) return MXN + 1LL;\n\n\treturn x * y;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 11",
          "code": "#define MXN 1000000000000000000LL\n\nlong long mrg(long long x, long long y)\n{\n\tif((x * y)/y != x ) return MXN + 1LL;\n\n\treturn x * y;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 12",
          "code": "#define MXN 1000000000000000000LL\n\nlong long mrg(long long x, long long y)\n{\n\tif((x * y)/y != x ) return MXN + 1LL;\n\n\treturn x * y;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 13",
          "code": "x > 0 ? (y < 1) : (y > 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #329 (Editorial) - Codeforces - Code 14",
          "code": "unsigned long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21406",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 10000, \"q\");\n    inf.readEoln();\n    \n    ensuref(1 <= n * m && n * m <= 20, \"n * m must satisfy 1 <= n * m <= 20, but n=%d, m=%d\", n, m);\n    \n    int prev_ti = 1;\n    vector<vector<bool>> cell_state(n + 1, vector<bool>(m + 1, false));\n    \n    for (int i = 1; i <= q; ++i) {\n        int tpi = inf.readInt(1, 3, \"tpi\");\n        inf.readSpace();\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, m, \"yi\");\n        inf.readSpace();\n        int ti = inf.readInt(2, 1000000000, \"ti\");\n        inf.readEoln();\n        \n        ensuref(ti > prev_ti, \"Time ti must be strictly increasing. At event %d, ti=%d, prev_ti=%d\", i, ti, prev_ti);\n        prev_ti = ti;\n        \n        if (tpi == 1) {\n            // Invitation\n            ensuref(cell_state[xi][yi] == false, \"Cell (%d, %d) must be unoccupied at time %d when Gosha is invited\", xi, yi, ti);\n        } else if (tpi == 2) {\n            // Cat appears\n            ensuref(cell_state[xi][yi] == false, \"Cell (%d, %d) must be unoccupied at time %d before the cat appears\", xi, yi, ti);\n            cell_state[xi][yi] = true;\n        } else if (tpi == 3) {\n            // Cat leaves\n            ensuref(cell_state[xi][yi] == true, \"Cell (%d, %d) must be occupied at time %d before the cat leaves\", xi, yi, ti);\n            cell_state[xi][yi] = false;\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 10000, \"q\");\n    inf.readEoln();\n    \n    ensuref(1 <= n * m && n * m <= 20, \"n * m must satisfy 1 <= n * m <= 20, but n=%d, m=%d\", n, m);\n    \n    int prev_ti = 1;\n    vector<vector<bool>> cell_state(n + 1, vector<bool>(m + 1, false));\n    \n    for (int i = 1; i <= q; ++i) {\n        int tpi = inf.readInt(1, 3, \"tpi\");\n        inf.readSpace();\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, m, \"yi\");\n        inf.readSpace();\n        int ti = inf.readInt(2, 1000000000, \"ti\");\n        inf.readEoln();\n        \n        ensuref(ti > prev_ti, \"Time ti must be strictly increasing. At event %d, ti=%d, prev_ti=%d\", i, ti, prev_ti);\n        prev_ti = ti;\n        \n        if (tpi == 1) {\n            // Invitation\n            ensuref(cell_state[xi][yi] == false, \"Cell (%d, %d) must be unoccupied at time %d when Gosha is invited\", xi, yi, ti);\n        } else if (tpi == 2) {\n            // Cat appears\n            ensuref(cell_state[xi][yi] == false, \"Cell (%d, %d) must be unoccupied at time %d before the cat appears\", xi, yi, ti);\n            cell_state[xi][yi] = true;\n        } else if (tpi == 3) {\n            // Cat leaves\n            ensuref(cell_state[xi][yi] == true, \"Cell (%d, %d) must be occupied at time %d before the cat leaves\", xi, yi, ti);\n            cell_state[xi][yi] = false;\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 10000, \"q\");\n    inf.readEoln();\n    \n    ensuref(1 <= n * m && n * m <= 20, \"n * m must satisfy 1 <= n * m <= 20, but n=%d, m=%d\", n, m);\n    \n    int prev_ti = 1;\n    vector<vector<bool>> cell_state(n + 1, vector<bool>(m + 1, false));\n    \n    for (int i = 1; i <= q; ++i) {\n        int tpi = inf.readInt(1, 3, \"tpi\");\n        inf.readSpace();\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, m, \"yi\");\n        inf.readSpace();\n        int ti = inf.readInt(2, 1000000000, \"ti\");\n        inf.readEoln();\n        \n        ensuref(ti > prev_ti, \"Time ti must be strictly increasing. At event %d, ti=%d, prev_ti=%d\", i, ti, prev_ti);\n        prev_ti = ti;\n        \n        if (tpi == 1) {\n            // Invitation\n            ensuref(cell_state[xi][yi] == false, \"Cell (%d, %d) must be unoccupied at time %d when Gosha is invited\", xi, yi, ti);\n        } else if (tpi == 2) {\n            // Cat appears\n            ensuref(cell_state[xi][yi] == false, \"Cell (%d, %d) must be unoccupied at time %d before the cat appears\", xi, yi, ti);\n            cell_state[xi][yi] = true;\n        } else if (tpi == 3) {\n            // Cat leaves\n            ensuref(cell_state[xi][yi] == true, \"Cell (%d, %d) must be occupied at time %d before the cat leaves\", xi, yi, ti);\n            cell_state[xi][yi] = false;\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1); // number of rows\n    int m = opt<int>(\"m\", 1); // number of columns\n    int q = opt<int>(\"q\", 1); // number of events\n    string type = opt<string>(\"type\", \"simple\"); // type of test case\n\n    // Enforce constraints\n    n = max(1, min(n, 20));\n    m = max(1, min(m, 20));\n    if (n * m > 20) {\n        m = 20 / n;\n        if (m == 0) m = 1;\n        n = 20 / m;\n    }\n\n    q = max(1, min(q, 10000));\n\n    vector<tuple<int, int, int, int>> events; // stores events: (tpi, xi, yi, ti)\n    int currentTime = 2; // time starts from 2\n\n    if (type == \"simple\") {\n        // Minimal case: one invitation to (1,1) at time 2\n        events.push_back(make_tuple(1, 1, 1, currentTime));\n        currentTime++;\n    } else if (type == \"max_size\") {\n        // Maximal grid size: n*m = 20\n        // Generate invitations and random cat events\n        int invCount = q / 10 + 1;\n        int catEventCount = q - invCount;\n\n        // Generate invitations\n        for (int i = 0; i < invCount; ++i) {\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, m);\n            int ti = currentTime;\n            currentTime += rnd.next(1, 5);\n            events.push_back(make_tuple(1, xi, yi, ti));\n        }\n\n        // Generate cat events\n        for (int i = 0; i < catEventCount; ++i) {\n            int tpi = rnd.next(2, 3);\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, m);\n            int ti = currentTime;\n            currentTime += rnd.next(1, 5);\n            events.push_back(make_tuple(tpi, xi, yi, ti));\n        }\n\n    } else if (type == \"max_events\") {\n        // Maximal number of events\n        for (int i = 0; i < q; ++i) {\n            int tpi = 1;\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, m);\n            int ti = currentTime;\n            currentTime += 1;\n            events.push_back(make_tuple(tpi, xi, yi, ti));\n        }\n    } else if (type == \"max_time\") {\n        // Maximal time t_i\n        for (int i = 0; i < q; ++i) {\n            int tpi = rnd.next(1, 3);\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, m);\n            int ti = currentTime;\n            currentTime += rnd.next(1e8, 1e8 + 10);\n            if (currentTime > 1e9) currentTime = 1e9;\n            events.push_back(make_tuple(tpi, xi, yi, ti));\n        }\n    } else if (type == \"multiple_invitations\") {\n        // Multiple invitations\n        for (int i = 0; i < q; ++i) {\n            int tpi = (i % 2 == 0) ? 1 : rnd.next(2, 3);\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, m);\n            int ti = currentTime;\n            currentTime += rnd.next(1, 5);\n            events.push_back(make_tuple(tpi, xi, yi, ti));\n        }\n    } else if (type == \"cats_blocking\") {\n        // Cats blocking path\n        // Create path from (1,1) to (n,m)\n        vector<pair<int, int>> path;\n        int x = 1, y = 1;\n        path.push_back({x, y});\n        while (x < n || y < m) {\n            if (x < n && (y == m || rnd.next(0, 1))) x++;\n            else y++;\n            path.push_back({x, y});\n        }\n\n        // Block adjacent cells with cats\n        set<pair<int, int>> blockedCells;\n        for (auto cell : path) {\n            int xi = cell.first;\n            int yi = cell.second;\n            for (int dx = -1; dx <= 1; ++dx) {\n                for (int dy = -1; dy <=1; ++dy) {\n                    if (abs(dx) + abs(dy) != 1) continue;\n                    int nx = xi + dx;\n                    int ny = yi + dy;\n                    if (nx >= 1 && nx <= n && ny >=1 && ny <= m)\n                        blockedCells.insert({nx, ny});\n                }\n            }\n        }\n        for (auto cell : path) blockedCells.erase(cell);\n\n        for (auto cell : blockedCells) {\n            int xi = cell.first;\n            int yi = cell.second;\n            int ti = currentTime;\n            currentTime += 1;\n            events.push_back(make_tuple(2, xi, yi, ti));\n        }\n        currentTime += 1;\n        events.push_back(make_tuple(1, n, m, currentTime));\n        currentTime += 1;\n    } else if (type == \"unreachable\") {\n        // Destination unreachable\n        for (int xi = 1; xi <= n; ++xi) {\n            for (int yi = 1; yi <= m; ++yi) {\n                if (xi == 1 && yi == 1) continue;\n                if (xi == n && yi == m) continue;\n                int ti = currentTime;\n                currentTime += 1;\n                events.push_back(make_tuple(2, xi, yi, ti));\n            }\n        }\n        currentTime += 1;\n        events.push_back(make_tuple(1, n, m, currentTime));\n        currentTime += 1;\n    } else if (type == \"complex_cats\") {\n        // Complex cat movement\n        for (int i = 0; i < q; ++i) {\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, m);\n            int ti = currentTime;\n            int tpi = (i % 3 == 0) ? 2 : ((i % 3 == 1) ? 3 : 1);\n            currentTime += rnd.next(1, 3);\n            events.push_back(make_tuple(tpi, xi, yi, ti));\n        }\n    } else {\n        // Random events\n        for (int i = 0; i < q; ++i) {\n            int tpi = rnd.next(1, 3);\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, m);\n            int ti = currentTime;\n            currentTime += rnd.next(1, 5);\n            events.push_back(make_tuple(tpi, xi, yi, ti));\n        }\n    }\n\n    // Output\n    // Enforce ti < ti+1\n    sort(events.begin(), events.end(), [](const tuple<int,int,int,int>& a, const tuple<int,int,int,int>& b) {\n        return get<3>(a) < get<3>(b);\n    });\n    printf(\"%d %d %d\\n\", n, m, (int)events.size());\n    for (auto e : events) {\n        int tpi = get<0>(e);\n        int xi = get<1>(e);\n        int yi = get<2>(e);\n        int ti = get<3>(e);\n        printf(\"%d %d %d %d\\n\", tpi, xi, yi, ti);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1); // number of rows\n    int m = opt<int>(\"m\", 1); // number of columns\n    int q = opt<int>(\"q\", 1); // number of events\n    string type = opt<string>(\"type\", \"simple\"); // type of test case\n\n    // Enforce constraints\n    n = max(1, min(n, 20));\n    m = max(1, min(m, 20));\n    if (n * m > 20) {\n        m = 20 / n;\n        if (m == 0) m = 1;\n        n = 20 / m;\n    }\n\n    q = max(1, min(q, 10000));\n\n    vector<tuple<int, int, int, int>> events; // stores events: (tpi, xi, yi, ti)\n    int currentTime = 2; // time starts from 2\n\n    if (type == \"simple\") {\n        // Minimal case: one invitation to (1,1) at time 2\n        events.push_back(make_tuple(1, 1, 1, currentTime));\n        currentTime++;\n    } else if (type == \"max_size\") {\n        // Maximal grid size: n*m = 20\n        // Generate invitations and random cat events\n        int invCount = q / 10 + 1;\n        int catEventCount = q - invCount;\n\n        // Generate invitations\n        for (int i = 0; i < invCount; ++i) {\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, m);\n            int ti = currentTime;\n            currentTime += rnd.next(1, 5);\n            events.push_back(make_tuple(1, xi, yi, ti));\n        }\n\n        // Generate cat events\n        for (int i = 0; i < catEventCount; ++i) {\n            int tpi = rnd.next(2, 3);\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, m);\n            int ti = currentTime;\n            currentTime += rnd.next(1, 5);\n            events.push_back(make_tuple(tpi, xi, yi, ti));\n        }\n\n    } else if (type == \"max_events\") {\n        // Maximal number of events\n        for (int i = 0; i < q; ++i) {\n            int tpi = 1;\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, m);\n            int ti = currentTime;\n            currentTime += 1;\n            events.push_back(make_tuple(tpi, xi, yi, ti));\n        }\n    } else if (type == \"max_time\") {\n        // Maximal time t_i\n        for (int i = 0; i < q; ++i) {\n            int tpi = rnd.next(1, 3);\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, m);\n            int ti = currentTime;\n            currentTime += rnd.next(1e8, 1e8 + 10);\n            if (currentTime > 1e9) currentTime = 1e9;\n            events.push_back(make_tuple(tpi, xi, yi, ti));\n        }\n    } else if (type == \"multiple_invitations\") {\n        // Multiple invitations\n        for (int i = 0; i < q; ++i) {\n            int tpi = (i % 2 == 0) ? 1 : rnd.next(2, 3);\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, m);\n            int ti = currentTime;\n            currentTime += rnd.next(1, 5);\n            events.push_back(make_tuple(tpi, xi, yi, ti));\n        }\n    } else if (type == \"cats_blocking\") {\n        // Cats blocking path\n        // Create path from (1,1) to (n,m)\n        vector<pair<int, int>> path;\n        int x = 1, y = 1;\n        path.push_back({x, y});\n        while (x < n || y < m) {\n            if (x < n && (y == m || rnd.next(0, 1))) x++;\n            else y++;\n            path.push_back({x, y});\n        }\n\n        // Block adjacent cells with cats\n        set<pair<int, int>> blockedCells;\n        for (auto cell : path) {\n            int xi = cell.first;\n            int yi = cell.second;\n            for (int dx = -1; dx <= 1; ++dx) {\n                for (int dy = -1; dy <=1; ++dy) {\n                    if (abs(dx) + abs(dy) != 1) continue;\n                    int nx = xi + dx;\n                    int ny = yi + dy;\n                    if (nx >= 1 && nx <= n && ny >=1 && ny <= m)\n                        blockedCells.insert({nx, ny});\n                }\n            }\n        }\n        for (auto cell : path) blockedCells.erase(cell);\n\n        for (auto cell : blockedCells) {\n            int xi = cell.first;\n            int yi = cell.second;\n            int ti = currentTime;\n            currentTime += 1;\n            events.push_back(make_tuple(2, xi, yi, ti));\n        }\n        currentTime += 1;\n        events.push_back(make_tuple(1, n, m, currentTime));\n        currentTime += 1;\n    } else if (type == \"unreachable\") {\n        // Destination unreachable\n        for (int xi = 1; xi <= n; ++xi) {\n            for (int yi = 1; yi <= m; ++yi) {\n                if (xi == 1 && yi == 1) continue;\n                if (xi == n && yi == m) continue;\n                int ti = currentTime;\n                currentTime += 1;\n                events.push_back(make_tuple(2, xi, yi, ti));\n            }\n        }\n        currentTime += 1;\n        events.push_back(make_tuple(1, n, m, currentTime));\n        currentTime += 1;\n    } else if (type == \"complex_cats\") {\n        // Complex cat movement\n        for (int i = 0; i < q; ++i) {\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, m);\n            int ti = currentTime;\n            int tpi = (i % 3 == 0) ? 2 : ((i % 3 == 1) ? 3 : 1);\n            currentTime += rnd.next(1, 3);\n            events.push_back(make_tuple(tpi, xi, yi, ti));\n        }\n    } else {\n        // Random events\n        for (int i = 0; i < q; ++i) {\n            int tpi = rnd.next(1, 3);\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, m);\n            int ti = currentTime;\n            currentTime += rnd.next(1, 5);\n            events.push_back(make_tuple(tpi, xi, yi, ti));\n        }\n    }\n\n    // Output\n    // Enforce ti < ti+1\n    sort(events.begin(), events.end(), [](const tuple<int,int,int,int>& a, const tuple<int,int,int,int>& b) {\n        return get<3>(a) < get<3>(b);\n    });\n    printf(\"%d %d %d\\n\", n, m, (int)events.size());\n    for (auto e : events) {\n        int tpi = get<0>(e);\n        int xi = get<1>(e);\n        int yi = get<2>(e);\n        int ti = get<3>(e);\n        printf(\"%d %d %d %d\\n\", tpi, xi, yi, ti);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -q 1 -type simple\n./gen -n 5 -m 4 -q 10 -type max_size\n./gen -n 3 -m 7 -q 10000 -type max_events\n./gen -n 4 -m 5 -q 100 -type max_time\n./gen -n 3 -m 3 -q 50 -type multiple_invitations\n./gen -n 4 -m 5 -q 30 -type cats_blocking\n./gen -n 4 -m 5 -q 30 -type unreachable\n./gen -n 4 -m 5 -q 100 -type complex_cats\n./gen -n 4 -m 5 -q 50 -type default\n./gen -n 2 -m 10 -q 1 -type simple\n./gen -n 4 -m 5 -q 10\n./gen -n 5 -m 4 -q 100 -type cats_blocking\n./gen -n 5 -m 4 -q 10000 -type max_events\n./gen -n 5 -m 4 -q 10000 -type max_time\n./gen -n 3 -m 6 -q 10000 -type multiple_invitations\n./gen -n 3 -m 6 -q 100 -type unreachable\n./gen -n 3 -m 6 -q 100 -type complex_cats\n./gen -n 1 -m 20 -q 200 -type default\n./gen -n 20 -m 1 -q 200 -type default\n./gen -n 4 -m 5 -q 1000 -type complex_cats\n./gen -n 1 -m 1 -q 10000 -type max_events\n./gen -n 4 -m 5 -q 10000 -type multiple_invitations\n./gen -n 4 -m 5 -q 10000 -type cats_blocking\n./gen -n 4 -m 5 -q 10000 -type unreachable\n./gen -n 4 -m 5 -q 10000 -type default\n./gen -n 2 -m 10 -q 1 -type max_size\n./gen -n 4 -m 5 -q 1000 -type cats_blocking\n./gen -n 5 -m 4 -q 9999 -type cats_blocking\n./gen -n 2 -m 10 -q 9999 -type unreachable\n./gen -n 1 -m 20 -q 10000 -type multiple_invitations\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:55:03.947969",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "594/A",
      "title": "A. Warrior and Archer",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line on the input contains a single integer n (2 ≤ n ≤ 200 000, n is even) — the number of positions available initially. The second line contains n distinct integers x1, x2, ..., xn (0 ≤ xi ≤ 109), giving the coordinates of the corresponding positions.",
      "output_spec": "OutputPrint the distance between the warrior and the archer at the beginning of the fight, provided that both Vova and Lesha play optimally.",
      "sample_tests": "ExamplesInputCopy60 1 3 7 15 31OutputCopy7InputCopy273 37OutputCopy36",
      "description": "A. Warrior and Archer\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line on the input contains a single integer n (2 ≤ n ≤ 200 000, n is even) — the number of positions available initially. The second line contains n distinct integers x1, x2, ..., xn (0 ≤ xi ≤ 109), giving the coordinates of the corresponding positions.\n\nOutputPrint the distance between the warrior and the archer at the beginning of the fight, provided that both Vova and Lesha play optimally.\n\nInputCopy60 1 3 7 15 31OutputCopy7InputCopy273 37OutputCopy36\n\nInputCopy60 1 3 7 15 31\n\nOutputCopy7\n\nInputCopy273 37\n\nOutputCopy36\n\nNoteIn the first sample one of the optimum behavior of the players looks like that:  Vova bans the position at coordinate 15;  Lesha bans the position at coordinate 3;  Vova bans the position at coordinate 31;  Lesha bans the position at coordinate 1. After these actions only positions 0 and 7 will remain, and the distance between them is equal to 7.In the second sample there are only two possible positions, so there will be no bans.",
      "solutions": [
        {
          "title": "Codeforces Round #330 - Codeforces",
          "content": "Good time of day, Codeforces!I am glad to announce that this Sunday, 8th November at 19:30 MSK, Codeforces Round #330 for both divisions will take place.The problemset of the round has been prepared for you with pleasure by Alex fcspartakm Frolov and me, Dan Sagunov. We want to thank the coordinator of Codeforces Gleb GlebsHP Evstropov for his valuable help in problem preparation, Mike MikeMirzayanov Mirzayanov for Codeforces and Polygon systems, Maria Delinur Belova for translating problem statements into English and Vladislav winger Isenbaev and Alex AlexFetisov Fetisov who have tested the round problemset.Every participant will be given two hours to solve five problems. We have tried to make the round problemset variative and interesting and therefore we strongly recommend to read all the problem statements during the round. Scoring will be announced later as always.We wish good luck and high rating to everyone!UPD. We are sorry again for the mistake in Cdiv2/Adiv1 problem: jury's solution is working wrong in odd n case. We are hoping that other problems was (or will be such in upsolving) interesting and useful.Anyway, let's congratulate the round winners:First division winners: jcvb 2222 KAN second division winners: Tagrimar fsps60312 uhateme Editorial could be found here.UPD. Problem Cdiv2/Adiv1 was fixed and now it has the statement and solution which jury meant it to be. Problem has been returned to the contest, so feel free to upsolve it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21464",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1470
        },
        {
          "title": "Codeforces Round #330 (Div.1 + Div.2) Editorial - Codeforces",
          "content": "595A — Vitaly and Night It was easy realization problem. Let's increase the variable i from 1 to n, and inside let's increase the variable j from 1 to 2·m. On every iteration we will increase the variable j on 2. If on current iteration a[i][j] = '1' or a[i][j + 1] = '1' let's increase the answer on one. Asymptotic behavior of this solution — O(nm). 595B — Pasha and Phone Let's calculate the answer to every block separately from each other and multiply the answer to the previous blocks to the answer for current block.For the block with length equals to k we can calculate the answer in the following way. Let for this block the number must be divided on x and must not starts with digit y. Then the answer for this block — the number of numbers containing exactly k digits and which divisible by x, subtract the number of numbers which have the first digit equals to y and containing exactly k digits and plus the number of numbers which have the first digit equals to y - 1 (only if y > 0) and containing exactly k digits.Asymptotic behavior of this solution — O(n / k). 594A — Warrior and Archer Let's sort the points by increasing x coordinate and work with sorted points array next.Let's suppose that after optimal playing points numbered l and r (l < r) are left. It's true that the first player didn't ban any of the points numbered i l < i < r, otherwise he could change his corresponding move to point l or point r (one could prove it doesn't depend on second player optimal moves) and change the optimal answer. It turns out that all the points banned by the first player have numbers outside of [l, r] segment, therefore . We should notice that if the first player choosed any [l, r] for , he could always make the final points numbers located inside this segment.The second player wants to make (he couldn't make less), what is equivalent if he always ban points inside final [l, r] segment (numbered l < i < r). As soon as the second player doesn't know what segment first player have chosen after every of his moves, he must detect a point which satisfies him in every first player choice. It's true number of this point is the median of set of point numbers left (the odd number) after the first player move. The number of moves of the first player left is lesser by one than moves of the second player, so the first player later could ban some points from the left and some points from the right, except three middle points. Two of it (leftmost and rightmost ones) shouldn't be banned by the second player as soon as it could increase the size of banned points from the left (or from the right), but third middle point satisfies the second player in every first player choice. This way the second player always bans the point inside final point segment.Thus the answer is the minimum between every of values.594B — Max and Bike The main proposition to solve this problem — in the middle of every competition the sensor must be or in the top point of the wheel or in the bottom point of the wheel.To calculate the answer we need to use binary search. If the center of the wheel moved on the distance c, then the sensor moved on the distance c + rsin(c / r), if the sensor was on the top point of the wheel in the middle, or on the distance c - rsin(c / r), if the sensor was on the bottom point of the wheel in the middle, where r — the radius of the wheel. Asymptotic behavior of this solution — . 594С — Edo and Magnets Let's find the centers of every rectangle and multiple them of 2 (to make all coordinates integers).Then we need to by the rectangle door, which contains all dots, but the lengths of the sides of this door must be rounded up to the nearest integers. Now, let's delete the magnets from the door one by one, gradually the door will decrease. Obviously every time optimal to delete only dots, which owned to the sides of the rectangle. Let's brute 4k ways, how we will do delete the magnets. We will do it with helps of recursion, every time we will delete point with minimum or maximum value of the coordinates. If we will store 4 arrays (or 2 deques) we can do it with asymptotic O(1). Such a solution works O(4k). It can be easily shown that this algorithm delete always some number of the leftmost, rightmost, uppermost and lowermost points. So we can brute how k will distributed between this values and we can model the deleting with helps of 4 arrays. This solution has asymptotic behavior O(k4). 594D — REQ To calculate the answer on every query let's use the formula , where p1, p2, ..., pk — all prime numbers which divided n. We make all calculations by the module 109 + 7 Let's suppose that we solving problem for fix left end l of the range. Every query now is a query on the prefix of the array. Then in formula for every prime p we need to know only about the leftmost position of it. Let's convert the query in the query of the multiple on the prefix: at first init Fenwick tree with ones, then make the multiplication in points l, l + 1, ..., n with value of the elements al, al + 1, ..., an. For every leftmost positions of prime p make in position i the multiplication in point i on the . This prepare can be done with asymptotic , where C — the maximum value of the element (this logarithm — the number of prime divisors of some ai). We interest in all leftmost ends, because of that let's know how to go from the one end to the other. Let we know all about the end l — how to update the end l + 1? Let's make the multiplication in the Fenwick tree in the point l on the value al - 1. Also we are not interesting in all prime numbers inside al, so let's make the multiplications in point l on the all values . But every of this prime numbers can have other entries which now becoming the leftmost. Add them with the multiplication which described above. With helps of sort the transition between leftmost ends can be done in . To answer to the queries we need to sort them in correct order (or add them in the dynamic array), and to the get the answer to the query we will make iterations. So total asymptotic behavior of solution is iterations and additional memory. 594E — Cutting the Line Let's describe the greedy algorithm, which allows to solve the problem for every k > 2 for every string S.Let's think, that we always reverse some prefix of the string S (may be with length equals to one). Because we want to minimize lexicographically the string it is easy to confirm that we will reverse such a prefixes, which prefix (after reversing) is equals to the minimal lexicographically suffix of the reverse string S (let it be Sr) — this is prefix, which length equals to the length of the minimum suffix Sr (the reverse operation of the prefix S equals to change it with suffix Sr).Let the lexicographically minimal suffix of the string Sr is s. It can be shown, that there are no 2 entries s in Sr which intersects, because of that the string s will be with period and minimal suffix will with less length. So, the string Sr looks like tpsaptp - 1sap - 1tp - 2... t1sa1, where sx means the concatenation of the string s x times, a1, a2, ..., ap — integers, and the strings t1, t2, ..., tp — some non-empty (exclude may be tp) strings, which do not contain the s inside.If we reverse some needed prefix of the string s, we will go to the string S', and the minimal suffix s' of the reversing string S'r can't be lexicographically less than s, because of that we need to make s' equals to s. It will helps us to increase prefix which look like sb in the answer (and we will can minimize it too). it is easy to show, that maximum b, which we can get equals to a1 in case p = 1 и (in case if p \\geq 2$). After such operations the prefix of the answer will looks like sa1saitisai - 1... sa2t2. Because t_{i} — non-empty strings we can not to increase the number of concatenations s in the prefix of the answer. The reversing of the second prefix (sai...) can be done because k > 2.From the information described above we know that if k > 2 for lost string we need always reverse prefix, which after reversing is equals to the suffix of the string Sr which looks like sa1. To find this suffix every time, we need only once to build Lindon decomposition (with helps of Duval's algorithm) of the reverse string and carefully unite the equals strings. Only one case is lost — prefix of the lost string does not need to be reverse — we can make the concatenation of the consecutive reverse prefixes with length equals to 1.Because for k = 1 the problem is very easy, we need to solve it for k = 2 — cut the string on the two pieces (prefix and suffix) and some way of their reverse. The case when nothing reverse is not interesting, let's look on other cases: Prefix do not reverse. In this case always reversing suffix. Two variants of the string with reverse suffix we can compare with O(1) with helps of z-function of the string Sr#S. Prefix reverse. To solve this case we can use approvals from the editorial of the problem F Yandex.Algorithm 2015 Round 2.2 which was written by GlebsHP and check only 2 ways of reversing prefix. We need for them to brute the reverse of suffixes. It is only need in the end to choose from 2 cases better answer. Asymptotic behavior of the solution is O(|s|).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21487",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 594\\s*A"
          },
          "content_length": 9251
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #330 - Codeforces - Code 1",
          "code": "Codeforces Round 330",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 2",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 3",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 4",
          "code": "5\n1 3 6 7 15",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 5",
          "code": "5\n1 3 6 7 15",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 6",
          "code": "spent one hour on the C --> :C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 7",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 8",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 9",
          "code": "a[i + N / 2] - a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 10",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 11",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 12",
          "code": "5\n1 7 100 130 131",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 13",
          "code": "5\n1 7 100 130 131",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 14",
          "code": "long long int a = pow(21.0, 14);\n    cout << a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 15",
          "code": "long long int a = pow(21.0, 14);\n    cout << a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 16",
          "code": "int exp (int b, int p) {\n   if (p == 0) {\n      return 1;\n   } else if (p % 2 == 1) {\n      return b * exp(b * b, p >> 1);\n   } else { // if (p % 2 == 0)\n      return exp(b * b, p >> 1);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 17",
          "code": "int exp (int b, int p) {\n   if (p == 0) {\n      return 1;\n   } else if (p % 2 == 1) {\n      return b * exp(b * b, p >> 1);\n   } else { // if (p % 2 == 0)\n      return exp(b * b, p >> 1);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 18",
          "code": "6\n0 1 2 5 6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 19",
          "code": "6\n0 1 2 5 6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 20",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,s,t,r,v;\nconst double pi=acos(-1.0);\ndouble C;\ndouble g(double L)\n{\n    double s=0.5*L,t;\n    while(1)\n    {\n        t=s-(s+2*r*sin(s/(2*r))-L)/(1+cos(s/(2*r)));\n        if(fabs(s-t)<1e-6)return t;\n        s=t;\n    }\n}\ndouble f(double len)\n{\n    double ll=floor(len/C)*C;\n    return (ll+g(len-ll))/v;\n}\nint main()\n{\n    int i,j,k;\n    scanf(\"%d%d%d\",&n,&r,&v);\n    C=2*pi*r;\n    while(n--)\n    {\n        scanf(\"%d%d\",&s,&t);\n        printf(\"%.15lf\\n\",f(t-s));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 21",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,s,t,r,v;\nconst double pi=acos(-1.0);\ndouble C;\ndouble g(double L)\n{\n    double s=0.5*L,t;\n    while(1)\n    {\n        t=s-(s+2*r*sin(s/(2*r))-L)/(1+cos(s/(2*r)));\n        if(fabs(s-t)<1e-6)return t;\n        s=t;\n    }\n}\ndouble f(double len)\n{\n    double ll=floor(len/C)*C;\n    return (ll+g(len-ll))/v;\n}\nint main()\n{\n    int i,j,k;\n    scanf(\"%d%d%d\",&n,&r,&v);\n    C=2*pi*r;\n    while(n--)\n    {\n        scanf(\"%d%d\",&s,&t);\n        printf(\"%.15lf\\n\",f(t-s));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 22",
          "code": "7\n1 2 3 4 50 125 140",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 23",
          "code": "7\n1 2 3 4 50 125 140",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 (Div.1 + Div.2) Editorial - Codeforces - Code 1",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 (Div.1 + Div.2) Editorial - Codeforces - Code 2",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000);\n    ensuref(n % 2 == 0, \"n must be even\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 0, 1000000000);\n    inf.readEoln();\n\n    set<int> s(x.begin(), x.end());\n    ensuref((int)s.size() == n, \"x_i are not distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000);\n    ensuref(n % 2 == 0, \"n must be even\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 0, 1000000000);\n    inf.readEoln();\n\n    set<int> s(x.begin(), x.end());\n    ensuref((int)s.size() == n, \"x_i are not distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 200000);\n    ensuref(n % 2 == 0, \"n must be even\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, 0, 1000000000);\n    inf.readEoln();\n\n    set<int> s(x.begin(), x.end());\n    ensuref((int)s.size() == n, \"x_i are not distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    ensure(n % 2 == 0); // n must be even\n\n    vector<int> x(n);\n\n    if (type == \"random\") {\n        set<int> s;\n        while (int(s.size()) < n) {\n            int val = rnd.next(0, (int)1e9);\n            s.insert(val);\n        }\n        x.assign(s.begin(), s.end());\n        shuffle(x.begin(), x.end());\n    } else if (type == \"increasing\") {\n        // Generate increasing sequence\n        int max_start = (int)(1e9) - n;\n        int start = rnd.next(0, max_start);\n        for (int i = 0; i < n; ++i) {\n            x[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        // Generate decreasing sequence\n        int min_start = n;\n        int start = rnd.next(n, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            x[i] = start - i;\n        }\n    } else if (type == \"extremes\") {\n        // Alternate between small and large values\n        for (int i = 0; i < n / 2; ++i) {\n            x[2 * i] = i; // small values\n            x[2 * i + 1] = (int)1e9 - i; // large values\n        }\n    } else if (type == \"cluster\") {\n        // Positions clustered around a central value\n        int c = rnd.next(n / 2, (int)1e9 - n / 2);\n        for (int i = 0; i < n; ++i) {\n            x[i] = c - n / 2 + i;\n        }\n    } else if (type == \"alternated\") {\n        // Alternate between small and large values\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                x[i] = i / 2;\n            } else {\n                x[i] = (int)1e9 - i / 2;\n            }\n        }\n    } else if (type == \"arithmetic\") {\n        // Positions in arithmetic progression\n        int max_d = std::max(1, (((int)1e9 - n) / n));\n        int a0 = rnd.next(0, (int)1e9 - n * max_d);\n        int d = rnd.next(1, max_d);\n        for (int i = 0; i < n; ++i) {\n            x[i] = a0 + i * d;\n        }\n    } else {\n        // default to random\n        set<int> s;\n        while (int(s.size()) < n) {\n            int val = rnd.next(0, (int)1e9);\n            s.insert(val);\n        }\n        x.assign(s.begin(), s.end());\n        shuffle(x.begin(), x.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output positions\n    for (int i = 0; i < x.size(); ++i) {\n        printf(\"%d%c\", x[i], \" \\n\"[i + 1 == x.size()]);\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    ensure(n % 2 == 0); // n must be even\n\n    vector<int> x(n);\n\n    if (type == \"random\") {\n        set<int> s;\n        while (int(s.size()) < n) {\n            int val = rnd.next(0, (int)1e9);\n            s.insert(val);\n        }\n        x.assign(s.begin(), s.end());\n        shuffle(x.begin(), x.end());\n    } else if (type == \"increasing\") {\n        // Generate increasing sequence\n        int max_start = (int)(1e9) - n;\n        int start = rnd.next(0, max_start);\n        for (int i = 0; i < n; ++i) {\n            x[i] = start + i;\n        }\n    } else if (type == \"decreasing\") {\n        // Generate decreasing sequence\n        int min_start = n;\n        int start = rnd.next(n, (int)1e9);\n        for (int i = 0; i < n; ++i) {\n            x[i] = start - i;\n        }\n    } else if (type == \"extremes\") {\n        // Alternate between small and large values\n        for (int i = 0; i < n / 2; ++i) {\n            x[2 * i] = i; // small values\n            x[2 * i + 1] = (int)1e9 - i; // large values\n        }\n    } else if (type == \"cluster\") {\n        // Positions clustered around a central value\n        int c = rnd.next(n / 2, (int)1e9 - n / 2);\n        for (int i = 0; i < n; ++i) {\n            x[i] = c - n / 2 + i;\n        }\n    } else if (type == \"alternated\") {\n        // Alternate between small and large values\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                x[i] = i / 2;\n            } else {\n                x[i] = (int)1e9 - i / 2;\n            }\n        }\n    } else if (type == \"arithmetic\") {\n        // Positions in arithmetic progression\n        int max_d = std::max(1, (((int)1e9 - n) / n));\n        int a0 = rnd.next(0, (int)1e9 - n * max_d);\n        int d = rnd.next(1, max_d);\n        for (int i = 0; i < n; ++i) {\n            x[i] = a0 + i * d;\n        }\n    } else {\n        // default to random\n        set<int> s;\n        while (int(s.size()) < n) {\n            int val = rnd.next(0, (int)1e9);\n            s.insert(val);\n        }\n        x.assign(s.begin(), s.end());\n        shuffle(x.begin(), x.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output positions\n    for (int i = 0; i < x.size(); ++i) {\n        printf(\"%d%c\", x[i], \" \\n\"[i + 1 == x.size()]);\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type extremes\n./gen -n 2 -type cluster\n./gen -n 2 -type arithmetic\n\n./gen -n 4 -type extremes\n\n./gen -n 10 -type random\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type cluster\n\n./gen -n 1000 -type random\n./gen -n 1000 -type alternated\n./gen -n 1000 -type extremes\n\n./gen -n 2000 -type arithmetic\n\n./gen -n 10000 -type random\n./gen -n 10000 -type increasing\n./gen -n 10000 -type decreasing\n\n./gen -n 50000 -type cluster\n./gen -n 50000 -type alternated\n\n./gen -n 100000 -type random\n./gen -n 100000 -type increasing\n./gen -n 100000 -type decreasing\n./gen -n 100000 -type arithmetic\n\n./gen -n 200000 -type cluster\n./gen -n 200000 -type alternated\n./gen -n 200000 -type extremes\n./gen -n 200000 -type random\n./gen -n 200000 -type increasing\n./gen -n 200000 -type decreasing\n./gen -n 200000 -type arithmetic\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:55:05.603852",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "594/B",
      "title": "B. Max and Bike",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, r and v (1 ≤ n ≤ 100 000, 1 ≤ r, v ≤ 109) — the number of competitions, the radius of the front wheel of Max's bike and his maximum speed, respectively. Next n lines contain the descriptions of the contests. The i-th line contains two integers si and fi (1 ≤ si < fi ≤ 109) — the coordinate of the start and the coordinate of the finish on the i-th competition.",
      "output_spec": "OutputPrint n real numbers, the i-th number should be equal to the minimum possible time measured by the time counter. Your answer will be considered correct if its absolute or relative error will not exceed 10 - 6. Namely: let's assume that your answer equals a, and the answer of the jury is b. The checker program will consider your answer correct if .",
      "sample_tests": "ExamplesInputCopy2 1 21 105 9OutputCopy3.8496447105021.106060157705",
      "description": "B. Max and Bike\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains three integers n, r and v (1 ≤ n ≤ 100 000, 1 ≤ r, v ≤ 109) — the number of competitions, the radius of the front wheel of Max's bike and his maximum speed, respectively. Next n lines contain the descriptions of the contests. The i-th line contains two integers si and fi (1 ≤ si < fi ≤ 109) — the coordinate of the start and the coordinate of the finish on the i-th competition.\n\nOutputPrint n real numbers, the i-th number should be equal to the minimum possible time measured by the time counter. Your answer will be considered correct if its absolute or relative error will not exceed 10 - 6. Namely: let's assume that your answer equals a, and the answer of the jury is b. The checker program will consider your answer correct if .\n\nInputCopy2 1 21 105 9OutputCopy3.8496447105021.106060157705\n\nInputCopy2 1 21 105 9\n\nOutputCopy3.8496447105021.106060157705",
      "solutions": [
        {
          "title": "Codeforces Round #330 - Codeforces",
          "content": "Good time of day, Codeforces!I am glad to announce that this Sunday, 8th November at 19:30 MSK, Codeforces Round #330 for both divisions will take place.The problemset of the round has been prepared for you with pleasure by Alex fcspartakm Frolov and me, Dan Sagunov. We want to thank the coordinator of Codeforces Gleb GlebsHP Evstropov for his valuable help in problem preparation, Mike MikeMirzayanov Mirzayanov for Codeforces and Polygon systems, Maria Delinur Belova for translating problem statements into English and Vladislav winger Isenbaev and Alex AlexFetisov Fetisov who have tested the round problemset.Every participant will be given two hours to solve five problems. We have tried to make the round problemset variative and interesting and therefore we strongly recommend to read all the problem statements during the round. Scoring will be announced later as always.We wish good luck and high rating to everyone!UPD. We are sorry again for the mistake in Cdiv2/Adiv1 problem: jury's solution is working wrong in odd n case. We are hoping that other problems was (or will be such in upsolving) interesting and useful.Anyway, let's congratulate the round winners:First division winners: jcvb 2222 KAN second division winners: Tagrimar fsps60312 uhateme Editorial could be found here.UPD. Problem Cdiv2/Adiv1 was fixed and now it has the statement and solution which jury meant it to be. Problem has been returned to the contest, so feel free to upsolve it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21464",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1470
        },
        {
          "title": "Codeforces Round #330 (Div.1 + Div.2) Editorial - Codeforces",
          "content": "595A — Vitaly and Night It was easy realization problem. Let's increase the variable i from 1 to n, and inside let's increase the variable j from 1 to 2·m. On every iteration we will increase the variable j on 2. If on current iteration a[i][j] = '1' or a[i][j + 1] = '1' let's increase the answer on one. Asymptotic behavior of this solution — O(nm). 595B — Pasha and Phone Let's calculate the answer to every block separately from each other and multiply the answer to the previous blocks to the answer for current block.For the block with length equals to k we can calculate the answer in the following way. Let for this block the number must be divided on x and must not starts with digit y. Then the answer for this block — the number of numbers containing exactly k digits and which divisible by x, subtract the number of numbers which have the first digit equals to y and containing exactly k digits and plus the number of numbers which have the first digit equals to y - 1 (only if y > 0) and containing exactly k digits.Asymptotic behavior of this solution — O(n / k). 594A — Warrior and Archer Let's sort the points by increasing x coordinate and work with sorted points array next.Let's suppose that after optimal playing points numbered l and r (l < r) are left. It's true that the first player didn't ban any of the points numbered i l < i < r, otherwise he could change his corresponding move to point l or point r (one could prove it doesn't depend on second player optimal moves) and change the optimal answer. It turns out that all the points banned by the first player have numbers outside of [l, r] segment, therefore . We should notice that if the first player choosed any [l, r] for , he could always make the final points numbers located inside this segment.The second player wants to make (he couldn't make less), what is equivalent if he always ban points inside final [l, r] segment (numbered l < i < r). As soon as the second player doesn't know what segment first player have chosen after every of his moves, he must detect a point which satisfies him in every first player choice. It's true number of this point is the median of set of point numbers left (the odd number) after the first player move. The number of moves of the first player left is lesser by one than moves of the second player, so the first player later could ban some points from the left and some points from the right, except three middle points. Two of it (leftmost and rightmost ones) shouldn't be banned by the second player as soon as it could increase the size of banned points from the left (or from the right), but third middle point satisfies the second player in every first player choice. This way the second player always bans the point inside final point segment.Thus the answer is the minimum between every of values.594B — Max and Bike The main proposition to solve this problem — in the middle of every competition the sensor must be or in the top point of the wheel or in the bottom point of the wheel.To calculate the answer we need to use binary search. If the center of the wheel moved on the distance c, then the sensor moved on the distance c + rsin(c / r), if the sensor was on the top point of the wheel in the middle, or on the distance c - rsin(c / r), if the sensor was on the bottom point of the wheel in the middle, where r — the radius of the wheel. Asymptotic behavior of this solution — . 594С — Edo and Magnets Let's find the centers of every rectangle and multiple them of 2 (to make all coordinates integers).Then we need to by the rectangle door, which contains all dots, but the lengths of the sides of this door must be rounded up to the nearest integers. Now, let's delete the magnets from the door one by one, gradually the door will decrease. Obviously every time optimal to delete only dots, which owned to the sides of the rectangle. Let's brute 4k ways, how we will do delete the magnets. We will do it with helps of recursion, every time we will delete point with minimum or maximum value of the coordinates. If we will store 4 arrays (or 2 deques) we can do it with asymptotic O(1). Such a solution works O(4k). It can be easily shown that this algorithm delete always some number of the leftmost, rightmost, uppermost and lowermost points. So we can brute how k will distributed between this values and we can model the deleting with helps of 4 arrays. This solution has asymptotic behavior O(k4). 594D — REQ To calculate the answer on every query let's use the formula , where p1, p2, ..., pk — all prime numbers which divided n. We make all calculations by the module 109 + 7 Let's suppose that we solving problem for fix left end l of the range. Every query now is a query on the prefix of the array. Then in formula for every prime p we need to know only about the leftmost position of it. Let's convert the query in the query of the multiple on the prefix: at first init Fenwick tree with ones, then make the multiplication in points l, l + 1, ..., n with value of the elements al, al + 1, ..., an. For every leftmost positions of prime p make in position i the multiplication in point i on the . This prepare can be done with asymptotic , where C — the maximum value of the element (this logarithm — the number of prime divisors of some ai). We interest in all leftmost ends, because of that let's know how to go from the one end to the other. Let we know all about the end l — how to update the end l + 1? Let's make the multiplication in the Fenwick tree in the point l on the value al - 1. Also we are not interesting in all prime numbers inside al, so let's make the multiplications in point l on the all values . But every of this prime numbers can have other entries which now becoming the leftmost. Add them with the multiplication which described above. With helps of sort the transition between leftmost ends can be done in . To answer to the queries we need to sort them in correct order (or add them in the dynamic array), and to the get the answer to the query we will make iterations. So total asymptotic behavior of solution is iterations and additional memory. 594E — Cutting the Line Let's describe the greedy algorithm, which allows to solve the problem for every k > 2 for every string S.Let's think, that we always reverse some prefix of the string S (may be with length equals to one). Because we want to minimize lexicographically the string it is easy to confirm that we will reverse such a prefixes, which prefix (after reversing) is equals to the minimal lexicographically suffix of the reverse string S (let it be Sr) — this is prefix, which length equals to the length of the minimum suffix Sr (the reverse operation of the prefix S equals to change it with suffix Sr).Let the lexicographically minimal suffix of the string Sr is s. It can be shown, that there are no 2 entries s in Sr which intersects, because of that the string s will be with period and minimal suffix will with less length. So, the string Sr looks like tpsaptp - 1sap - 1tp - 2... t1sa1, where sx means the concatenation of the string s x times, a1, a2, ..., ap — integers, and the strings t1, t2, ..., tp — some non-empty (exclude may be tp) strings, which do not contain the s inside.If we reverse some needed prefix of the string s, we will go to the string S', and the minimal suffix s' of the reversing string S'r can't be lexicographically less than s, because of that we need to make s' equals to s. It will helps us to increase prefix which look like sb in the answer (and we will can minimize it too). it is easy to show, that maximum b, which we can get equals to a1 in case p = 1 и (in case if p \\geq 2$). After such operations the prefix of the answer will looks like sa1saitisai - 1... sa2t2. Because t_{i} — non-empty strings we can not to increase the number of concatenations s in the prefix of the answer. The reversing of the second prefix (sai...) can be done because k > 2.From the information described above we know that if k > 2 for lost string we need always reverse prefix, which after reversing is equals to the suffix of the string Sr which looks like sa1. To find this suffix every time, we need only once to build Lindon decomposition (with helps of Duval's algorithm) of the reverse string and carefully unite the equals strings. Only one case is lost — prefix of the lost string does not need to be reverse — we can make the concatenation of the consecutive reverse prefixes with length equals to 1.Because for k = 1 the problem is very easy, we need to solve it for k = 2 — cut the string on the two pieces (prefix and suffix) and some way of their reverse. The case when nothing reverse is not interesting, let's look on other cases: Prefix do not reverse. In this case always reversing suffix. Two variants of the string with reverse suffix we can compare with O(1) with helps of z-function of the string Sr#S. Prefix reverse. To solve this case we can use approvals from the editorial of the problem F Yandex.Algorithm 2015 Round 2.2 which was written by GlebsHP and check only 2 ways of reversing prefix. We need for them to brute the reverse of suffixes. It is only need in the end to choose from 2 cases better answer. Asymptotic behavior of the solution is O(|s|).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21487",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 594\\s*B"
          },
          "content_length": 9251
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #330 - Codeforces - Code 1",
          "code": "Codeforces Round 330",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 2",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 3",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 4",
          "code": "5\n1 3 6 7 15",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 5",
          "code": "5\n1 3 6 7 15",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 6",
          "code": "spent one hour on the C --> :C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 7",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 8",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 9",
          "code": "a[i + N / 2] - a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 10",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 11",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 12",
          "code": "5\n1 7 100 130 131",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 13",
          "code": "5\n1 7 100 130 131",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 14",
          "code": "long long int a = pow(21.0, 14);\n    cout << a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 15",
          "code": "long long int a = pow(21.0, 14);\n    cout << a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 16",
          "code": "int exp (int b, int p) {\n   if (p == 0) {\n      return 1;\n   } else if (p % 2 == 1) {\n      return b * exp(b * b, p >> 1);\n   } else { // if (p % 2 == 0)\n      return exp(b * b, p >> 1);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 17",
          "code": "int exp (int b, int p) {\n   if (p == 0) {\n      return 1;\n   } else if (p % 2 == 1) {\n      return b * exp(b * b, p >> 1);\n   } else { // if (p % 2 == 0)\n      return exp(b * b, p >> 1);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 18",
          "code": "6\n0 1 2 5 6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 19",
          "code": "6\n0 1 2 5 6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 20",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,s,t,r,v;\nconst double pi=acos(-1.0);\ndouble C;\ndouble g(double L)\n{\n    double s=0.5*L,t;\n    while(1)\n    {\n        t=s-(s+2*r*sin(s/(2*r))-L)/(1+cos(s/(2*r)));\n        if(fabs(s-t)<1e-6)return t;\n        s=t;\n    }\n}\ndouble f(double len)\n{\n    double ll=floor(len/C)*C;\n    return (ll+g(len-ll))/v;\n}\nint main()\n{\n    int i,j,k;\n    scanf(\"%d%d%d\",&n,&r,&v);\n    C=2*pi*r;\n    while(n--)\n    {\n        scanf(\"%d%d\",&s,&t);\n        printf(\"%.15lf\\n\",f(t-s));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 21",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,s,t,r,v;\nconst double pi=acos(-1.0);\ndouble C;\ndouble g(double L)\n{\n    double s=0.5*L,t;\n    while(1)\n    {\n        t=s-(s+2*r*sin(s/(2*r))-L)/(1+cos(s/(2*r)));\n        if(fabs(s-t)<1e-6)return t;\n        s=t;\n    }\n}\ndouble f(double len)\n{\n    double ll=floor(len/C)*C;\n    return (ll+g(len-ll))/v;\n}\nint main()\n{\n    int i,j,k;\n    scanf(\"%d%d%d\",&n,&r,&v);\n    C=2*pi*r;\n    while(n--)\n    {\n        scanf(\"%d%d\",&s,&t);\n        printf(\"%.15lf\\n\",f(t-s));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 22",
          "code": "7\n1 2 3 4 50 125 140",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 23",
          "code": "7\n1 2 3 4 50 125 140",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 (Div.1 + Div.2) Editorial - Codeforces - Code 1",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 (Div.1 + Div.2) Editorial - Codeforces - Code 2",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000000, \"r\");\n    inf.readSpace();\n    int v = inf.readInt(1, 1000000000, \"v\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int si = inf.readInt(1, 1000000000 - 1, \"si\");\n        inf.readSpace();\n        int fi = inf.readInt(si + 1, 1000000000, \"fi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000000, \"r\");\n    inf.readSpace();\n    int v = inf.readInt(1, 1000000000, \"v\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int si = inf.readInt(1, 1000000000 - 1, \"si\");\n        inf.readSpace();\n        int fi = inf.readInt(si + 1, 1000000000, \"fi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000000, \"r\");\n    inf.readSpace();\n    int v = inf.readInt(1, 1000000000, \"v\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int si = inf.readInt(1, 1000000000 - 1, \"si\");\n        inf.readSpace();\n        int fi = inf.readInt(si + 1, 1000000000, \"fi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(); // number of competitions\n    inf.readInt(); // read and ignore 'r'\n    inf.readInt(); // read and ignore 'v'\n    for(int i = 0; i < n; ++i){\n        inf.readInt(); // read and ignore 'si'\n        inf.readInt(); // read and ignore 'fi'\n    }\n\n    vector<double> juryAns(n);\n    for (int i = 0; i < n; ++i) {\n        juryAns[i] = ans.readDouble();\n    }\n    if (!ans.seekEof())\n        quitf(_fail, \"Jury output has extra data.\");\n\n    vector<double> partAns(n);\n    for (int i = 0; i < n; ++i) {\n        partAns[i] = ouf.readDouble();\n    }\n\n    if (!ouf.seekEof())\n        quitf(_wa, \"Extra data found in the output.\");\n\n    const double maxError = 1E-6;\n    for (int i = 0; i < n; ++i) {\n        double expected = juryAns[i];\n        double actual = partAns[i];\n        if (!doubleCompare(expected, actual, maxError))\n            quitf(_wa, \"Wrong answer at position %d: expected %.10f, found %.10f\", i + 1, expected, actual);\n    }\n\n    quitf(_ok, \"Accepted\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\");\n    int v = opt<int>(\"v\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> s(n), f(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            s[i] = rnd.next(1, (int)1e9 - 1);\n            f[i] = rnd.next(s[i] + 1, (int)1e9);\n        }\n    } else if (type == \"min_values\") {\n        for (int i = 0; i < n; i++) {\n            s[i] = 1;\n            f[i] = 2;\n        }\n    } else if (type == \"max_values\") {\n        for (int i = 0; i < n; i++) {\n            s[i] = rnd.next((int)1e9 - (int)1e6, (int)1e9 - 1);\n            f[i] = rnd.next(s[i] + 1, (int)1e9);\n        }\n    } else if (type == \"small_intervals\") {\n        for (int i = 0; i < n; i++) {\n            s[i] = rnd.next(1, (int)1e9 - 1000);\n            f[i] = s[i] + rnd.next(1, 1000);\n            if(f[i] > (int)1e9) f[i] = (int)1e9;\n        }\n    } else if (type == \"large_intervals\") {\n        for (int i = 0; i < n; i++) {\n            s[i] = rnd.next(1, (int)1e7);\n            f[i] = rnd.next((int)1e9 - (int)1e7, (int)1e9);\n            if(s[i] >= f[i]) s[i] = f[i] - 1;\n        }\n    } else if (type == \"same_si_fi\") {\n        int s_val = rnd.next(1, (int)1e9 - 1);\n        int f_val = rnd.next(s_val + 1, (int)1e9);\n        for (int i = 0; i < n; i++) {\n            s[i] = s_val;\n            f[i] = f_val;\n        }\n    } else if (type == \"arithmetic_progression\") {\n        int s0 = rnd.next(1, (int)1e9 - n*10);\n        for (int i = 0; i < n; i++) {\n            s[i] = s0 + i * 10;\n            f[i] = s[i] + 10;\n            if(f[i] > (int)1e9) f[i] = (int)1e9;\n        }\n    } else if (type == \"clustered\") {\n        int clusters = 10;\n        int cluster_size = n / clusters;\n        for (int c = 0; c < clusters; c++) {\n            int s_base = rnd.next(1, (int)1e9 - (int)1e6);\n            int f_base = s_base + rnd.next(1e3, 1e5);\n            for (int i = 0; i < cluster_size; i++) {\n                int idx = c * cluster_size + i;\n                if (idx >= n) break;\n                s[idx] = s_base + rnd.next(-1000, 1000);\n                f[idx] = f_base + rnd.next(-1000, 1000);\n                if (s[idx] < 1) s[idx] = 1;\n                if (f[idx] <= s[idx]) f[idx] = s[idx] + 1;\n                if (f[idx] > (int)1e9) f[idx] = (int)1e9;\n            }\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; i++) {\n            s[i] = rnd.next(1, (int)1e9 - 1);\n            f[i] = rnd.next(s[i] + 1, (int)1e9);\n        }\n    }\n\n    printf(\"%d %d %d\\n\", n, r, v);\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", s[i], f[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\");\n    int v = opt<int>(\"v\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> s(n), f(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            s[i] = rnd.next(1, (int)1e9 - 1);\n            f[i] = rnd.next(s[i] + 1, (int)1e9);\n        }\n    } else if (type == \"min_values\") {\n        for (int i = 0; i < n; i++) {\n            s[i] = 1;\n            f[i] = 2;\n        }\n    } else if (type == \"max_values\") {\n        for (int i = 0; i < n; i++) {\n            s[i] = rnd.next((int)1e9 - (int)1e6, (int)1e9 - 1);\n            f[i] = rnd.next(s[i] + 1, (int)1e9);\n        }\n    } else if (type == \"small_intervals\") {\n        for (int i = 0; i < n; i++) {\n            s[i] = rnd.next(1, (int)1e9 - 1000);\n            f[i] = s[i] + rnd.next(1, 1000);\n            if(f[i] > (int)1e9) f[i] = (int)1e9;\n        }\n    } else if (type == \"large_intervals\") {\n        for (int i = 0; i < n; i++) {\n            s[i] = rnd.next(1, (int)1e7);\n            f[i] = rnd.next((int)1e9 - (int)1e7, (int)1e9);\n            if(s[i] >= f[i]) s[i] = f[i] - 1;\n        }\n    } else if (type == \"same_si_fi\") {\n        int s_val = rnd.next(1, (int)1e9 - 1);\n        int f_val = rnd.next(s_val + 1, (int)1e9);\n        for (int i = 0; i < n; i++) {\n            s[i] = s_val;\n            f[i] = f_val;\n        }\n    } else if (type == \"arithmetic_progression\") {\n        int s0 = rnd.next(1, (int)1e9 - n*10);\n        for (int i = 0; i < n; i++) {\n            s[i] = s0 + i * 10;\n            f[i] = s[i] + 10;\n            if(f[i] > (int)1e9) f[i] = (int)1e9;\n        }\n    } else if (type == \"clustered\") {\n        int clusters = 10;\n        int cluster_size = n / clusters;\n        for (int c = 0; c < clusters; c++) {\n            int s_base = rnd.next(1, (int)1e9 - (int)1e6);\n            int f_base = s_base + rnd.next(1e3, 1e5);\n            for (int i = 0; i < cluster_size; i++) {\n                int idx = c * cluster_size + i;\n                if (idx >= n) break;\n                s[idx] = s_base + rnd.next(-1000, 1000);\n                f[idx] = f_base + rnd.next(-1000, 1000);\n                if (s[idx] < 1) s[idx] = 1;\n                if (f[idx] <= s[idx]) f[idx] = s[idx] + 1;\n                if (f[idx] > (int)1e9) f[idx] = (int)1e9;\n            }\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; i++) {\n            s[i] = rnd.next(1, (int)1e9 - 1);\n            f[i] = rnd.next(s[i] + 1, (int)1e9);\n        }\n    }\n\n    printf(\"%d %d %d\\n\", n, r, v);\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", s[i], f[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -r 1 -v 1 -type random\n./gen -n 5 -r 1000000000 -v 1000000000 -type random\n\n./gen -n 5 -r 1 -v 1 -type min_values\n./gen -n 5 -r 1000000000 -v 1000000000 -type max_values\n\n./gen -n 1000 -r 100000 -v 100000 -type small_intervals\n./gen -n 1000 -r 100000 -v 100000 -type large_intervals\n\n./gen -n 100000 -r 100000 -v 100000 -type random\n./gen -n 100000 -r 1000000000 -v 1000000000 -type small_intervals\n./gen -n 100000 -r 100000 -v 100000 -type same_si_fi\n./gen -n 100000 -r 100000 -v 100000 -type arithmetic_progression\n\n./gen -n 100000 -r 500000000 -v 500000000 -type clustered\n\n./gen -n 100000 -r 1 -v 1 -type max_values\n./gen -n 100000 -r 1000000000 -v 1000000000 -type min_values\n\n./gen -n 100000 -r 100000 -v 100000 -type small_intervals\n./gen -n 100000 -r 100000 -v 100000 -type large_intervals\n\n./gen -n 1 -r 1000000000 -v 1000000000 -type random\n\n./gen -n 1000 -r 1 -v 1000000000 -type random\n./gen -n 1000 -r 1000000000 -v 1 -type random\n\n./gen -n 1000 -r 100000 -v 1 -type random\n./gen -n 1000 -r 100000 -v 1000000000 -type random\n\n./gen -n 50000 -r 100000000 -v 100000000 -type clustered\n./gen -n 50000 -r 100000000 -v 100000000 -type same_si_fi\n./gen -n 50000 -r 100000000 -v 100000000 -type arithmetic_progression\n\n# Additional test cases\n\n./gen -n 2 -r 100 -v 50 -type small_intervals\n./gen -n 2 -r 1000000000 -v 1000000000 -type min_values\n./gen -n 100000 -r 1000000000 -v 1000000000 -type large_intervals\n./gen -n 100000 -r 1 -v 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:55:07.596570",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "594/C",
      "title": "C. Edo and Magnets",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1 ≤ n ≤ 100 000, 0 ≤ k ≤ min(10, n - 1)) — the number of magnets that Edo has and the maximum number of magnets Edo may not place on the refrigerator.Next n lines describe the initial plan of placing magnets. Each line contains four integers x1, y1, x2, y2 (1 ≤ x1 < x2 ≤ 109, 1 ≤ y1 < y2 ≤ 109) — the coordinates of the lower left and upper right corners of the current magnet. The magnets can partially overlap or even fully coincide.",
      "output_spec": "OutputPrint a single integer — the minimum area of the door of refrigerator, which can be used to place at least n - k magnets, preserving the relative positions.",
      "sample_tests": "ExamplesInputCopy3 11 1 2 22 2 3 33 3 4 4OutputCopy1InputCopy4 11 1 2 21 9 2 109 9 10 109 1 10 2OutputCopy64InputCopy3 01 1 2 21 1 1000000000 10000000001 3 8 12OutputCopy249999999000000001",
      "description": "C. Edo and Magnets\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n and k (1 ≤ n ≤ 100 000, 0 ≤ k ≤ min(10, n - 1)) — the number of magnets that Edo has and the maximum number of magnets Edo may not place on the refrigerator.Next n lines describe the initial plan of placing magnets. Each line contains four integers x1, y1, x2, y2 (1 ≤ x1 < x2 ≤ 109, 1 ≤ y1 < y2 ≤ 109) — the coordinates of the lower left and upper right corners of the current magnet. The magnets can partially overlap or even fully coincide.\n\nOutputPrint a single integer — the minimum area of the door of refrigerator, which can be used to place at least n - k magnets, preserving the relative positions.\n\nInputCopy3 11 1 2 22 2 3 33 3 4 4OutputCopy1InputCopy4 11 1 2 21 9 2 109 9 10 109 1 10 2OutputCopy64InputCopy3 01 1 2 21 1 1000000000 10000000001 3 8 12OutputCopy249999999000000001\n\nInputCopy3 11 1 2 22 2 3 33 3 4 4\n\nOutputCopy1\n\nInputCopy4 11 1 2 21 9 2 109 9 10 109 1 10 2\n\nOutputCopy64\n\nInputCopy3 01 1 2 21 1 1000000000 10000000001 3 8 12\n\nOutputCopy249999999000000001\n\nNoteIn the first test sample it is optimal to remove either the first or the third magnet. If we remove the first magnet, the centers of two others will lie at points (2.5, 2.5) and (3.5, 3.5). Thus, it is enough to buy a fridge with door width 1 and door height 1, the area of the door also equals one, correspondingly.In the second test sample it doesn't matter which magnet to remove, the answer will not change — we need a fridge with door width 8 and door height 8.In the third sample you cannot remove anything as k = 0.",
      "solutions": [
        {
          "title": "Codeforces Round #330 - Codeforces",
          "content": "Good time of day, Codeforces!I am glad to announce that this Sunday, 8th November at 19:30 MSK, Codeforces Round #330 for both divisions will take place.The problemset of the round has been prepared for you with pleasure by Alex fcspartakm Frolov and me, Dan Sagunov. We want to thank the coordinator of Codeforces Gleb GlebsHP Evstropov for his valuable help in problem preparation, Mike MikeMirzayanov Mirzayanov for Codeforces and Polygon systems, Maria Delinur Belova for translating problem statements into English and Vladislav winger Isenbaev and Alex AlexFetisov Fetisov who have tested the round problemset.Every participant will be given two hours to solve five problems. We have tried to make the round problemset variative and interesting and therefore we strongly recommend to read all the problem statements during the round. Scoring will be announced later as always.We wish good luck and high rating to everyone!UPD. We are sorry again for the mistake in Cdiv2/Adiv1 problem: jury's solution is working wrong in odd n case. We are hoping that other problems was (or will be such in upsolving) interesting and useful.Anyway, let's congratulate the round winners:First division winners: jcvb 2222 KAN second division winners: Tagrimar fsps60312 uhateme Editorial could be found here.UPD. Problem Cdiv2/Adiv1 was fixed and now it has the statement and solution which jury meant it to be. Problem has been returned to the contest, so feel free to upsolve it.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21464",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1470
        },
        {
          "title": "Codeforces Round #330 (Div.1 + Div.2) Editorial - Codeforces",
          "content": "595A — Vitaly and Night It was easy realization problem. Let's increase the variable i from 1 to n, and inside let's increase the variable j from 1 to 2·m. On every iteration we will increase the variable j on 2. If on current iteration a[i][j] = '1' or a[i][j + 1] = '1' let's increase the answer on one. Asymptotic behavior of this solution — O(nm). 595B — Pasha and Phone Let's calculate the answer to every block separately from each other and multiply the answer to the previous blocks to the answer for current block.For the block with length equals to k we can calculate the answer in the following way. Let for this block the number must be divided on x and must not starts with digit y. Then the answer for this block — the number of numbers containing exactly k digits and which divisible by x, subtract the number of numbers which have the first digit equals to y and containing exactly k digits and plus the number of numbers which have the first digit equals to y - 1 (only if y > 0) and containing exactly k digits.Asymptotic behavior of this solution — O(n / k). 594A — Warrior and Archer Let's sort the points by increasing x coordinate and work with sorted points array next.Let's suppose that after optimal playing points numbered l and r (l < r) are left. It's true that the first player didn't ban any of the points numbered i l < i < r, otherwise he could change his corresponding move to point l or point r (one could prove it doesn't depend on second player optimal moves) and change the optimal answer. It turns out that all the points banned by the first player have numbers outside of [l, r] segment, therefore . We should notice that if the first player choosed any [l, r] for , he could always make the final points numbers located inside this segment.The second player wants to make (he couldn't make less), what is equivalent if he always ban points inside final [l, r] segment (numbered l < i < r). As soon as the second player doesn't know what segment first player have chosen after every of his moves, he must detect a point which satisfies him in every first player choice. It's true number of this point is the median of set of point numbers left (the odd number) after the first player move. The number of moves of the first player left is lesser by one than moves of the second player, so the first player later could ban some points from the left and some points from the right, except three middle points. Two of it (leftmost and rightmost ones) shouldn't be banned by the second player as soon as it could increase the size of banned points from the left (or from the right), but third middle point satisfies the second player in every first player choice. This way the second player always bans the point inside final point segment.Thus the answer is the minimum between every of values.594B — Max and Bike The main proposition to solve this problem — in the middle of every competition the sensor must be or in the top point of the wheel or in the bottom point of the wheel.To calculate the answer we need to use binary search. If the center of the wheel moved on the distance c, then the sensor moved on the distance c + rsin(c / r), if the sensor was on the top point of the wheel in the middle, or on the distance c - rsin(c / r), if the sensor was on the bottom point of the wheel in the middle, where r — the radius of the wheel. Asymptotic behavior of this solution — . 594С — Edo and Magnets Let's find the centers of every rectangle and multiple them of 2 (to make all coordinates integers).Then we need to by the rectangle door, which contains all dots, but the lengths of the sides of this door must be rounded up to the nearest integers. Now, let's delete the magnets from the door one by one, gradually the door will decrease. Obviously every time optimal to delete only dots, which owned to the sides of the rectangle. Let's brute 4k ways, how we will do delete the magnets. We will do it with helps of recursion, every time we will delete point with minimum or maximum value of the coordinates. If we will store 4 arrays (or 2 deques) we can do it with asymptotic O(1). Such a solution works O(4k). It can be easily shown that this algorithm delete always some number of the leftmost, rightmost, uppermost and lowermost points. So we can brute how k will distributed between this values and we can model the deleting with helps of 4 arrays. This solution has asymptotic behavior O(k4). 594D — REQ To calculate the answer on every query let's use the formula , where p1, p2, ..., pk — all prime numbers which divided n. We make all calculations by the module 109 + 7 Let's suppose that we solving problem for fix left end l of the range. Every query now is a query on the prefix of the array. Then in formula for every prime p we need to know only about the leftmost position of it. Let's convert the query in the query of the multiple on the prefix: at first init Fenwick tree with ones, then make the multiplication in points l, l + 1, ..., n with value of the elements al, al + 1, ..., an. For every leftmost positions of prime p make in position i the multiplication in point i on the . This prepare can be done with asymptotic , where C — the maximum value of the element (this logarithm — the number of prime divisors of some ai). We interest in all leftmost ends, because of that let's know how to go from the one end to the other. Let we know all about the end l — how to update the end l + 1? Let's make the multiplication in the Fenwick tree in the point l on the value al - 1. Also we are not interesting in all prime numbers inside al, so let's make the multiplications in point l on the all values . But every of this prime numbers can have other entries which now becoming the leftmost. Add them with the multiplication which described above. With helps of sort the transition between leftmost ends can be done in . To answer to the queries we need to sort them in correct order (or add them in the dynamic array), and to the get the answer to the query we will make iterations. So total asymptotic behavior of solution is iterations and additional memory. 594E — Cutting the Line Let's describe the greedy algorithm, which allows to solve the problem for every k > 2 for every string S.Let's think, that we always reverse some prefix of the string S (may be with length equals to one). Because we want to minimize lexicographically the string it is easy to confirm that we will reverse such a prefixes, which prefix (after reversing) is equals to the minimal lexicographically suffix of the reverse string S (let it be Sr) — this is prefix, which length equals to the length of the minimum suffix Sr (the reverse operation of the prefix S equals to change it with suffix Sr).Let the lexicographically minimal suffix of the string Sr is s. It can be shown, that there are no 2 entries s in Sr which intersects, because of that the string s will be with period and minimal suffix will with less length. So, the string Sr looks like tpsaptp - 1sap - 1tp - 2... t1sa1, where sx means the concatenation of the string s x times, a1, a2, ..., ap — integers, and the strings t1, t2, ..., tp — some non-empty (exclude may be tp) strings, which do not contain the s inside.If we reverse some needed prefix of the string s, we will go to the string S', and the minimal suffix s' of the reversing string S'r can't be lexicographically less than s, because of that we need to make s' equals to s. It will helps us to increase prefix which look like sb in the answer (and we will can minimize it too). it is easy to show, that maximum b, which we can get equals to a1 in case p = 1 и (in case if p \\geq 2$). After such operations the prefix of the answer will looks like sa1saitisai - 1... sa2t2. Because t_{i} — non-empty strings we can not to increase the number of concatenations s in the prefix of the answer. The reversing of the second prefix (sai...) can be done because k > 2.From the information described above we know that if k > 2 for lost string we need always reverse prefix, which after reversing is equals to the suffix of the string Sr which looks like sa1. To find this suffix every time, we need only once to build Lindon decomposition (with helps of Duval's algorithm) of the reverse string and carefully unite the equals strings. Only one case is lost — prefix of the lost string does not need to be reverse — we can make the concatenation of the consecutive reverse prefixes with length equals to 1.Because for k = 1 the problem is very easy, we need to solve it for k = 2 — cut the string on the two pieces (prefix and suffix) and some way of their reverse. The case when nothing reverse is not interesting, let's look on other cases: Prefix do not reverse. In this case always reversing suffix. Two variants of the string with reverse suffix we can compare with O(1) with helps of z-function of the string Sr#S. Prefix reverse. To solve this case we can use approvals from the editorial of the problem F Yandex.Algorithm 2015 Round 2.2 which was written by GlebsHP and check only 2 ways of reversing prefix. We need for them to brute the reverse of suffixes. It is only need in the end to choose from 2 cases better answer. Asymptotic behavior of the solution is O(|s|).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21487",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 594 和字母"
          },
          "content_length": 9251
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #330 - Codeforces - Code 1",
          "code": "Codeforces Round 330",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 2",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 3",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 4",
          "code": "5\n1 3 6 7 15",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 5",
          "code": "5\n1 3 6 7 15",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 6",
          "code": "spent one hour on the C --> :C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 7",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 8",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 9",
          "code": "a[i + N / 2] - a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 10",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 11",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 12",
          "code": "5\n1 7 100 130 131",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 13",
          "code": "5\n1 7 100 130 131",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 14",
          "code": "long long int a = pow(21.0, 14);\n    cout << a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 15",
          "code": "long long int a = pow(21.0, 14);\n    cout << a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 16",
          "code": "int exp (int b, int p) {\n   if (p == 0) {\n      return 1;\n   } else if (p % 2 == 1) {\n      return b * exp(b * b, p >> 1);\n   } else { // if (p % 2 == 0)\n      return exp(b * b, p >> 1);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 17",
          "code": "int exp (int b, int p) {\n   if (p == 0) {\n      return 1;\n   } else if (p % 2 == 1) {\n      return b * exp(b * b, p >> 1);\n   } else { // if (p % 2 == 0)\n      return exp(b * b, p >> 1);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 18",
          "code": "6\n0 1 2 5 6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 19",
          "code": "6\n0 1 2 5 6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 20",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,s,t,r,v;\nconst double pi=acos(-1.0);\ndouble C;\ndouble g(double L)\n{\n    double s=0.5*L,t;\n    while(1)\n    {\n        t=s-(s+2*r*sin(s/(2*r))-L)/(1+cos(s/(2*r)));\n        if(fabs(s-t)<1e-6)return t;\n        s=t;\n    }\n}\ndouble f(double len)\n{\n    double ll=floor(len/C)*C;\n    return (ll+g(len-ll))/v;\n}\nint main()\n{\n    int i,j,k;\n    scanf(\"%d%d%d\",&n,&r,&v);\n    C=2*pi*r;\n    while(n--)\n    {\n        scanf(\"%d%d\",&s,&t);\n        printf(\"%.15lf\\n\",f(t-s));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 21",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,s,t,r,v;\nconst double pi=acos(-1.0);\ndouble C;\ndouble g(double L)\n{\n    double s=0.5*L,t;\n    while(1)\n    {\n        t=s-(s+2*r*sin(s/(2*r))-L)/(1+cos(s/(2*r)));\n        if(fabs(s-t)<1e-6)return t;\n        s=t;\n    }\n}\ndouble f(double len)\n{\n    double ll=floor(len/C)*C;\n    return (ll+g(len-ll))/v;\n}\nint main()\n{\n    int i,j,k;\n    scanf(\"%d%d%d\",&n,&r,&v);\n    C=2*pi*r;\n    while(n--)\n    {\n        scanf(\"%d%d\",&s,&t);\n        printf(\"%.15lf\\n\",f(t-s));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 22",
          "code": "7\n1 2 3 4 50 125 140",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 23",
          "code": "7\n1 2 3 4 50 125 140",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 (Div.1 + Div.2) Editorial - Codeforces - Code 1",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 (Div.1 + Div.2) Editorial - Codeforces - Code 2",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int max_k = n - 1;\n    if (max_k > 10) max_k = 10;\n    if (max_k < 0) max_k = 0;\n    int k = inf.readInt(0, max_k, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int x1 = inf.readInt(1, 1000000000, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(1, 1000000000, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(1, 1000000000, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(1, 1000000000, \"y2\");\n        inf.readEoln();\n\n        ensuref(x1 < x2, \"x1 must be less than x2, but x1=%d, x2=%d\", x1, x2);\n        ensuref(y1 < y2, \"y1 must be less than y2, but y1=%d, y2=%d\", y1, y2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int max_k = n - 1;\n    if (max_k > 10) max_k = 10;\n    if (max_k < 0) max_k = 0;\n    int k = inf.readInt(0, max_k, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int x1 = inf.readInt(1, 1000000000, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(1, 1000000000, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(1, 1000000000, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(1, 1000000000, \"y2\");\n        inf.readEoln();\n\n        ensuref(x1 < x2, \"x1 must be less than x2, but x1=%d, x2=%d\", x1, x2);\n        ensuref(y1 < y2, \"y1 must be less than y2, but y1=%d, y2=%d\", y1, y2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int max_k = n - 1;\n    if (max_k > 10) max_k = 10;\n    if (max_k < 0) max_k = 0;\n    int k = inf.readInt(0, max_k, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int x1 = inf.readInt(1, 1000000000, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(1, 1000000000, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(1, 1000000000, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(1, 1000000000, \"y2\");\n        inf.readEoln();\n\n        ensuref(x1 < x2, \"x1 must be less than x2, but x1=%d, x2=%d\", x1, x2);\n        ensuref(y1 < y2, \"y1 must be less than y2, but y1=%d, y2=%d\", y1, y2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Magnet {\n    int x1, y1, x2, y2;\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure k is within the constraints\n    k = max(0, min(k, min(10, n - 1)));\n\n    vector<Magnet> magnets(n);\n\n    if (type == \"random\") {\n        // Random positions and sizes\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(1, int(1e9) - 1);\n            int x2 = rnd.next(x1 + 1, int(1e9));\n            int y1 = rnd.next(1, int(1e9) - 1);\n            int y2 = rnd.next(y1 + 1, int(1e9));\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    } else if (type == \"overlap\") {\n        // All magnets overlap at the same location\n        int x1 = 1;\n        int y1 = 1;\n        int x2 = int(1e9);\n        int y2 = int(1e9);\n        for (int i = 0; i < n; ++i) {\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    } else if (type == \"line\") {\n        // Magnets arranged in a line\n        for (int i = 0; i < n; ++i) {\n            int x1 = i + 1;\n            int x2 = x1 + 1;\n            int y1 = 1;\n            int y2 = 2;\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    } else if (type == \"grid\") {\n        // Magnets arranged in a grid\n        int c = sqrt(n) + 1;\n        int r = (n + c - 1) / c;\n        int maxCoord = int(1e9) - 2;\n        int dx = max(1, maxCoord / c);\n        int dy = max(1, maxCoord / r);\n        for (int i = 0; i < n; ++i) {\n            int row = i / c;\n            int col = i % c;\n            int x1 = col * dx + 1;\n            int y1 = row * dy + 1;\n            int x2 = x1 + 1;\n            int y2 = y1 + 1;\n            x2 = min(x2, int(1e9));\n            y2 = min(y2, int(1e9));\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    } else if (type == \"remove\") {\n        // Magnets that can be removed to reduce area significantly\n        int cluster_size = n - k;\n        for (int i = 0; i < cluster_size; ++i) {\n            int x1 = rnd.next(1, int(1e5) - 1);\n            int x2 = x1 + rnd.next(1, 10);\n            int y1 = rnd.next(1, int(1e5) - 1);\n            int y2 = y1 + rnd.next(1, 10);\n            magnets[i] = {x1, y1, x2, y2};\n        }\n        for (int i = cluster_size; i < n; ++i) {\n            int x1 = rnd.next(int(1e9) - int(1e5), int(1e9) - 1);\n            int x2 = x1 + rnd.next(1, 10);\n            x2 = min(x2, int(1e9));\n            int y1 = rnd.next(int(1e9) - int(1e5), int(1e9) - 1);\n            int y2 = y1 + rnd.next(1, 10);\n            y2 = min(y2, int(1e9));\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    } else if (type == \"max_coords\") {\n        // Magnets with maximum coordinate values\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(int(1e9) - int(1e6), int(1e9) - 1);\n            int x2 = x1 + rnd.next(1, min(10, int(1e9) - x1));\n            x2 = min(x2, int(1e9));\n            int y1 = rnd.next(int(1e9) - int(1e6), int(1e9) - 1);\n            int y2 = y1 + rnd.next(1, min(10, int(1e9) - y1));\n            y2 = min(y2, int(1e9));\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    } else if (type == \"min_coords\") {\n        // Magnets with minimum coordinate values\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(1, 10);\n            int x2 = x1 + rnd.next(1, 10);\n            x2 = min(x2, int(1e9));\n            if (x2 <= x1) x2 = x1 + 1;\n            int y1 = rnd.next(1, 10);\n            int y2 = y1 + rnd.next(1, 10);\n            y2 = min(y2, int(1e9));\n            if (y2 <= y1) y2 = y1 + 1;\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    } else if (type == \"coincide\") {\n        // Multiple magnets fully coinciding\n        int unique_magnets = rnd.next(1, n);\n        vector<Magnet> unique_list(unique_magnets);\n        for (int i = 0; i < unique_magnets; ++i) {\n            int x1 = rnd.next(1, int(1e9) - 1);\n            int x2 = rnd.next(x1 + 1, int(1e9));\n            int y1 = rnd.next(1, int(1e9) - 1);\n            int y2 = rnd.next(y1 + 1, int(1e9));\n            unique_list[i] = {x1, y1, x2, y2};\n        }\n        for (int i = 0; i < n; ++i) {\n            int idx = rnd.next(0, unique_magnets - 1);\n            magnets[i] = unique_list[idx];\n        }\n    } else if (type == \"small\") {\n        // Magnets with minimal sizes\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(1, int(1e9) - 2);\n            int x2 = x1 + 1;\n            int y1 = rnd.next(1, int(1e9) - 2);\n            int y2 = y1 + 1;\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    } else if (type == \"large\") {\n        // Magnets with maximal sizes\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(1, 1000);\n            int x2 = int(1e9) - rnd.next(0, 999);\n            if (x2 <= x1) x2 = x1 + 1;\n            x2 = min(x2, int(1e9));\n            int y1 = rnd.next(1, 1000);\n            int y2 = int(1e9) - rnd.next(0, 999);\n            if (y2 <= y1) y2 = y1 + 1;\n            y2 = min(y2, int(1e9));\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    } else {\n        // Default to random if type is unknown\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(1, int(1e9) - 1);\n            int x2 = rnd.next(x1 + 1, int(1e9));\n            int y1 = rnd.next(1, int(1e9) - 1);\n            int y2 = rnd.next(y1 + 1, int(1e9));\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output the magnets\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d %d %d\\n\", magnets[i].x1, magnets[i].y1, magnets[i].x2, magnets[i].y2);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Magnet {\n    int x1, y1, x2, y2;\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure k is within the constraints\n    k = max(0, min(k, min(10, n - 1)));\n\n    vector<Magnet> magnets(n);\n\n    if (type == \"random\") {\n        // Random positions and sizes\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(1, int(1e9) - 1);\n            int x2 = rnd.next(x1 + 1, int(1e9));\n            int y1 = rnd.next(1, int(1e9) - 1);\n            int y2 = rnd.next(y1 + 1, int(1e9));\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    } else if (type == \"overlap\") {\n        // All magnets overlap at the same location\n        int x1 = 1;\n        int y1 = 1;\n        int x2 = int(1e9);\n        int y2 = int(1e9);\n        for (int i = 0; i < n; ++i) {\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    } else if (type == \"line\") {\n        // Magnets arranged in a line\n        for (int i = 0; i < n; ++i) {\n            int x1 = i + 1;\n            int x2 = x1 + 1;\n            int y1 = 1;\n            int y2 = 2;\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    } else if (type == \"grid\") {\n        // Magnets arranged in a grid\n        int c = sqrt(n) + 1;\n        int r = (n + c - 1) / c;\n        int maxCoord = int(1e9) - 2;\n        int dx = max(1, maxCoord / c);\n        int dy = max(1, maxCoord / r);\n        for (int i = 0; i < n; ++i) {\n            int row = i / c;\n            int col = i % c;\n            int x1 = col * dx + 1;\n            int y1 = row * dy + 1;\n            int x2 = x1 + 1;\n            int y2 = y1 + 1;\n            x2 = min(x2, int(1e9));\n            y2 = min(y2, int(1e9));\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    } else if (type == \"remove\") {\n        // Magnets that can be removed to reduce area significantly\n        int cluster_size = n - k;\n        for (int i = 0; i < cluster_size; ++i) {\n            int x1 = rnd.next(1, int(1e5) - 1);\n            int x2 = x1 + rnd.next(1, 10);\n            int y1 = rnd.next(1, int(1e5) - 1);\n            int y2 = y1 + rnd.next(1, 10);\n            magnets[i] = {x1, y1, x2, y2};\n        }\n        for (int i = cluster_size; i < n; ++i) {\n            int x1 = rnd.next(int(1e9) - int(1e5), int(1e9) - 1);\n            int x2 = x1 + rnd.next(1, 10);\n            x2 = min(x2, int(1e9));\n            int y1 = rnd.next(int(1e9) - int(1e5), int(1e9) - 1);\n            int y2 = y1 + rnd.next(1, 10);\n            y2 = min(y2, int(1e9));\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    } else if (type == \"max_coords\") {\n        // Magnets with maximum coordinate values\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(int(1e9) - int(1e6), int(1e9) - 1);\n            int x2 = x1 + rnd.next(1, min(10, int(1e9) - x1));\n            x2 = min(x2, int(1e9));\n            int y1 = rnd.next(int(1e9) - int(1e6), int(1e9) - 1);\n            int y2 = y1 + rnd.next(1, min(10, int(1e9) - y1));\n            y2 = min(y2, int(1e9));\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    } else if (type == \"min_coords\") {\n        // Magnets with minimum coordinate values\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(1, 10);\n            int x2 = x1 + rnd.next(1, 10);\n            x2 = min(x2, int(1e9));\n            if (x2 <= x1) x2 = x1 + 1;\n            int y1 = rnd.next(1, 10);\n            int y2 = y1 + rnd.next(1, 10);\n            y2 = min(y2, int(1e9));\n            if (y2 <= y1) y2 = y1 + 1;\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    } else if (type == \"coincide\") {\n        // Multiple magnets fully coinciding\n        int unique_magnets = rnd.next(1, n);\n        vector<Magnet> unique_list(unique_magnets);\n        for (int i = 0; i < unique_magnets; ++i) {\n            int x1 = rnd.next(1, int(1e9) - 1);\n            int x2 = rnd.next(x1 + 1, int(1e9));\n            int y1 = rnd.next(1, int(1e9) - 1);\n            int y2 = rnd.next(y1 + 1, int(1e9));\n            unique_list[i] = {x1, y1, x2, y2};\n        }\n        for (int i = 0; i < n; ++i) {\n            int idx = rnd.next(0, unique_magnets - 1);\n            magnets[i] = unique_list[idx];\n        }\n    } else if (type == \"small\") {\n        // Magnets with minimal sizes\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(1, int(1e9) - 2);\n            int x2 = x1 + 1;\n            int y1 = rnd.next(1, int(1e9) - 2);\n            int y2 = y1 + 1;\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    } else if (type == \"large\") {\n        // Magnets with maximal sizes\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(1, 1000);\n            int x2 = int(1e9) - rnd.next(0, 999);\n            if (x2 <= x1) x2 = x1 + 1;\n            x2 = min(x2, int(1e9));\n            int y1 = rnd.next(1, 1000);\n            int y2 = int(1e9) - rnd.next(0, 999);\n            if (y2 <= y1) y2 = y1 + 1;\n            y2 = min(y2, int(1e9));\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    } else {\n        // Default to random if type is unknown\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(1, int(1e9) - 1);\n            int x2 = rnd.next(x1 + 1, int(1e9));\n            int y1 = rnd.next(1, int(1e9) - 1);\n            int y2 = rnd.next(y1 + 1, int(1e9));\n            magnets[i] = {x1, y1, x2, y2};\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output the magnets\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d %d %d\\n\", magnets[i].x1, magnets[i].y1, magnets[i].x2, magnets[i].y2);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type random\n./gen -n 1 -k 0 -type overlap\n./gen -n 1 -k 0 -type line\n./gen -n 1 -k 0 -type grid\n\n./gen -n 2 -k 1 -type random\n./gen -n 2 -k 1 -type remove\n\n./gen -n 10 -k 0 -type random\n./gen -n 10 -k 1 -type overlap\n./gen -n 10 -k 2 -type line\n./gen -n 10 -k 3 -type grid\n\n./gen -n 100 -k 0 -type random\n./gen -n 100 -k 5 -type remove\n./gen -n 100 -k 10 -type coincide\n\n./gen -n 1000 -k 0 -type random\n./gen -n 1000 -k 10 -type max_coords\n./gen -n 1000 -k 10 -type min_coords\n./gen -n 1000 -k 10 -type large\n\n./gen -n 10000 -k 0 -type random\n./gen -n 10000 -k 10 -type small\n./gen -n 10000 -k 10 -type grid\n\n./gen -n 50000 -k 0 -type random\n./gen -n 50000 -k 10 -type remove\n\n./gen -n 100000 -k 0 -type random\n./gen -n 100000 -k 10 -type overlap\n./gen -n 100000 -k 10 -type line\n./gen -n 100000 -k 10 -type grid\n\n./gen -n 100000 -k 10 -type remove\n./gen -n 100000 -k 10 -type max_coords\n./gen -n 100000 -k 10 -type min_coords\n./gen -n 100000 -k 10 -type coincide\n./gen -n 100000 -k 10 -type small\n./gen -n 100000 -k 10 -type large\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:55:09.724042",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "594/D",
      "title": "D. REQ",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записано число n (1 ≤ n ≤ 200 000) — длина массива, данного Вовочке. Во второй строке содержатся n чисел a1, a2, ..., an (1 ≤ ai ≤ 106).В третьей строке содержится число q (1 ≤ q ≤ 200 000) — количество запросов. В следующих q строках по одному в каждой содержатся запросы. Каждый запрос определяется границами отрезка li и ri (1 ≤ li ≤ ri ≤ n).",
      "output_spec": "Выходные данныеВыведите q чисел — значение функции Эйлера для каждого из запросов, вычисленное по модулю 109 + 7.",
      "sample_tests": "ПримерыВходные данныеСкопировать101 2 3 4 5 6 7 8 9 1071 13 85 64 88 107 97 10Выходные данныеСкопировать14608815361921441152Входные данныеСкопировать724 63 13 52 6 10 163 54 71 72 43 62 6Выходные данныеСкопировать124876812939264112329984539136",
      "description": "ограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных записано число n (1 ≤ n ≤ 200 000) — длина массива, данного Вовочке. Во второй строке содержатся n чисел a1, a2, ..., an (1 ≤ ai ≤ 106).В третьей строке содержится число q (1 ≤ q ≤ 200 000) — количество запросов. В следующих q строках по одному в каждой содержатся запросы. Каждый запрос определяется границами отрезка li и ri (1 ≤ li ≤ ri ≤ n).\n\nВходные данные\n\nВыходные данныеВыведите q чисел — значение функции Эйлера для каждого из запросов, вычисленное по модулю 109 + 7.\n\nВыходные данные\n\nВходные данныеСкопировать101 2 3 4 5 6 7 8 9 1071 13 85 64 88 107 97 10Выходные данныеСкопировать14608815361921441152Входные данныеСкопировать724 63 13 52 6 10 163 54 71 72 43 62 6Выходные данныеСкопировать124876812939264112329984539136\n\nВходные данныеСкопировать101 2 3 4 5 6 7 8 9 1071 13 85 64 88 107 97 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать14608815361921441152\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать724 63 13 52 6 10 163 54 71 72 43 62 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать124876812939264112329984539136\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВо втором примере значения вычисляются так:  φ(13·52·6) = φ(4056) = 1248  φ(52·6·10·1) = φ(3120) = 768  φ(24·63·13·52·6·10·1) = φ(61326720) = 12939264  φ(63·13·52) = φ(42588) = 11232  φ(13·52·6·10) = φ(40560) = 9984  φ(63·13·52·6·10) = φ(2555280) = 539136",
      "solutions": [
        {
          "title": "Codeforces Round #330 - Codeforces",
          "content": "Добрый день, Codeforces!Рад сообщить, что в это воскресенье, 8го ноября в 19:30 MSK состоится Codeforces Round #330 для участников обоих дивизионов.Задачи для вас уже не в первый раз с удовольствием придумывали и готовили Александр fcspartakm Фролов и я, Данил Сагунов. Мы говорим спасибо координатору Codeforces Глебу GlebsHP Евстропову за существенную помощь в подготовке задач, Михаилу MikeMirzayanov Мирзаянову за системы Codeforces и Polygon, Марии Delinur Беловой за перевод условий на английский язык, а также Владиславу winger Исенбаеву и Александру AlexFetisov Фетисову за тестирование и прорешивание задач раунда.Каждому из участников раунда будет предоставлено два часа на решение пяти задач. Мы постарались сделать задачи разнообразными и интересными, и поэтому настоятельно рекомендуем прочитать все задачи во время раунда. Разбалловка, как и всегда, будет объявлена позднее.Желаем всем удачи и высокого рейтинга!UPD. Еще раз приносим свои извинения за задачу Cdiv2/Adiv1 — авторское решение неправильно работало в случае нечетных n. Мы очень надеемся, что остальные задачи контеста оказались (или окажутся в дорешивании) для вас полезными и интересными.В любом случае, хотим поздравить победителей раунда:Победители первого дивизиона: jcvb 2222 KAN победители второго дивизиона: Tagrimar fsps60312 uhateme Разбор задач можно найти здесь.UPD. Задача Cdiv2/Adiv1 была исправлена, и теперь имеет то условие и решение, которое предполагали авторы. Задача вернулась в соревнование и доступна для дорешивания.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21464",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1517
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces",
          "content": "595A — Виталий и ночь Простая задача на реализацию. Проитерируемся по i от 1 до n, а внутри проитерируемся по j от 1 до 2·m, причем на каждой итерации будем увеличивать j на два. Если на текущей итерации a[i][j] = '1' или a[i][j + 1] = '1' увеличим ответ на один. Асимптотика решения — O(nm). 595B — Паша и телефон Будем считать ответ для каждого блока отдельно и умножать ответ для предыдущих блоков на ответ для текущего блока, при этом не забывая брать результат перемножения по модулю. Для блока длины k ответ считается следующим образом. Пусть для этого блока число должно делиться на x и не должно начинаться с цифры y. Тогда ответ для этого блока — количество чисел из k цифр, делящихся на x, минус количество чисел, начинающихся с цифры y и состоящих из k цифр, плюс количество чисел, начинающихся с цифры y - 1 (только если y > 0) и состоящих из k цифр. Асимптотика решения — O(n / k). 594A — Воин и лучник Отсортируем все точки по возрастанию координаты x, далее будем работать с перенумерованными точками.Предположим, что при оптимальной игре после ходов игроков остались точки с номерами l и r (l < r). Утверждается, что первый игрок не запретил ни одну из точек с индексом l < i < r, ведь в противном случае он играл не оптимально и мог запретить точку l или точку r (можно показать, что это не зависит от оптимальных действий второго игрока), поменяв оптимальный ответ. Получается, что номера всех запрещенных первым игроком точек лежат вне отрезка [l, r], а значит . Заметим, что выбрав некоторую такую границу [l, r] при , первый игрок может всегда добиться того, чтобы точки в ответе лежали внутри этого отрезка.Второй игрок хочет добиться того, чтобы (меньше он сделать не может), то есть всегда запрещать точку, лежащую строго внутри [l, r]. Поскольку второй игрок не знает наперед, к каким точкам стремится игрок, после каждого хода первого игрока ему необходимо запрещать точку, которая лежит строго внутри каждой из возможных границ, образованных этими точками. Нетрудно показать, что эта точка является медианой оставшегося множества точек (а их нечетное количество), ведь количество оставшихся ходов первого игрока на единицу меньше количества ходов второго, и он сможет впоследствии запретить все, кроме трех медианных точек. Две крайние из них второму игроку запрещать нельзя, так как они могут впоследствии увеличить количество удаленных слева (или справа) первым игроком точек, а средняя из них как раз принадлежит всевозможным границам, которые мог выбрать первый игрок. Таким образом второй игрок всегда может свести ситуацию к .Ответ на задачу — минимум среди значений .594B — Максим и велосипед Главное утверждение для решения этой задачи — в середине дистанции каждого соревнования датчик должен находиться либо в самой верхней точке колеса, либо в самой нижней точке колеса. Для того, чтобы посчитать ответ, воспользуемся бинпоиском. Если центр колеса прошел расстояние c то датчик переместился на расстояние c + rsin(c / r), если в середине датчик находился сверху колеса, или на расстояние c - rsin(c / r), если в середине датчие находился снизу колеса, где r — это радиус колеса. Асимптотика решения — . 594С — Эдо и магниты Найдем центры прямоугольников и умножим их координаты на два, чтобы далее работать с целыми координатами. Тогда подходящим холодильником (для всех точек) является прямоугольник, содержащий все точки, но с длинами сторон, округленными вверх к ближайшему четному числу. Представим теперь, что удаляем магниты с холодильника последовательно, постепенно \"уменьшая\" прямоугольник. Очевидно, что каждый раз выгодно удалять только те точки, что лежат на какой-то из четырех сторон прямоугольника. Переберем 4k вариантов того, как мы будем это делать, с помощью рекурсии, каждый раз удаляя одну из еще не удаленных точек с максимальным или минимальным значением по одной из координат. Если мы будем поддерживать 4 массива (или два массива в виде дека), то это можно делать за O(1) амортизированно. Такое решение будет работать за O(4k). Можно также заметить, что описанный выше алгоритм удаляет всегда несколько самых правых, левых, верхних, и нижних точек. Можно перебрать, как k распределится среди этих величин и промоделировать удаление с помощью, например, описанных выше 4 массивов. Такое решение имеет асимптотику O(k4). 594D — REQ Для подсчета ответа на каждый запрос будем пользоваться формулой , где p1, p2, ..., pk — все простые, делящие n. Эту формулу каждый может попробовать доказать или воспользоваться уже существующими доказательствами. Все вычисления ниже производим по модулю 109 + 7 Предположим теперь, что мы решаем задачу для фиксированного левого конца отрезка l, отбросив все элементы левее. Любой запрос теперь превращается в запрос на префиксе массива. Тогда, судя по формуле, для каждого простого p нас интересует лишь его самое левое вхождение, потому что все остальные вхождения не будут влиять на правую часть в приведенной выше формуле. Превратим наш запрос на значение функции Эйлера в запрос произведения на префиксе: сначала проинициализируем дерево Фенвика произведений единицами, затем сделаем умножения в точках l, l + 1, ..., n значениями соответствующих элементов al, al + 1, ..., an, затем для каждого самого левого вхождения простого p в позицию i сделаем умножение в точке i на значение . Нетрудно убедиться, что теперь запрос на префиксе определенной длины даст правильный ответ для отрезка той же длины с левым концом в l. Такую подготовку для фиксированного левого конца можно осуществить за , где C — максимальное значение элемента (этот логарифм соответствует количеству простых в разложении какого-то из ai). Нас интересуют все левые концы, поэтому научимся переходить от одного из них к другому. В самом деле, пусть все было посчитано для левого конца l и мы хотим теперь перейти к левому концу l + 1. Нас перестает интересовать al внутри левой части формулы, поэтому сделаем умножение в дереве Фенвика в точке l на значение al - 1. Так же нас перестают интересовать все простые внутри al (а они, очевидно, самые левые среди своих вхождений), поэтому сделаем так же умножения в точке l на все значения . Однако у каждого из этих простых могли существовать другие вхождения, которые теперь станут самыми левыми. Добавим их с помощью умножений, описанных выше. С помощью сортировок (или векторов) переход между соседними левыми концами реализуется за суммарную . Чтобы правильно отвечать на запросы, их так же нужно правильно отсортировать (или поместить в динамический массив), и ответ на запрос будет совершать операций. Суммарная асимптотика всего решения операций и дополнительной памяти. 594E — Разрезание строки Опишем жадный алгоритм, который позволяет решить задачу при k > 2 для любой строки S.Будем считать, что мы всегда переворачиваем некоторый префикс строки S (возможно, длины 1, подробнее ниже). Поскольку мы стремимся минимизировать строку лексикографически, легко убедиться в том, что мы будем переворачивать такие и только такие префиксы, префикс которых (после переворачивания) совпадает с минимальным лексикографически суффиксом перевернутой строки S (обозначим ее Sr), в частности, это префикс, совпадающий по длине с минимальным суффиксом Sr (операция переворачивания префикса S равносильна замене его суффиксом Sr соответствующей длины).Обозначим минимальный лексикографически суффикс строки Sr как s. Можно показать, что никакие два вхождения s в Sr не пересекаются, так как в противном случае строка s была бы периодической, и минимальный суффикс имел бы меньшую длину. Значит, строка Sr имеет вид tpsaptp - 1sap - 1tp - 2... t1sa1, где sx означает конкатенацию строки s x раз, a1, a2, ..., ap — натуральные числа, а строки t1, t2, ..., tp — некоторые непустые (кроме, возможно, tp) строки, не содержащие s в качестве подстроки.Перевернув некоторый подходящий префикс строки S, мы перейдем к меньшей строке S', при этом минимальный суффикс s' этой перевернутой строки S'r не может быть лексикографически меньше, чем s (это каждый может доказать самостоятельно), поэтому мы стремимся сделать так, чтобы s' осталось равным s, что позволит увеличить префикс вида sb в ответе (а значит и минимизировать его). Легко доказать, что максимальное b, которое мы можем получить, равно a1 в случае p = 1 и (в случае, если p \\geq 2$). Действительно, после таких операций префикс ответа будет выглядеть как sa1saitisai - 1... sa2t2. Поскольку t_{i} — непустые строки, увеличить количество конкатенаций s в префиксе ответа никак не получится. Заметим, что переворот второго префикса (sai...) возможен, так как k > 2.Из описанных выше утверждений следует, что при k > 2 для оставшейся строки всегда следует переворачивать префикс, который после переворота совпадает с суффиксом строки Sr вида sa1. Чтобы находить этот суффикс каждый раз, достаточно один раз построить декомпозицию Линдона (с помощью алгоритма Дюваля) перевернутой исходной строки и аккуратно объединять равные строки в ней. Единственным случаем остается вариант, когда префикс оставшейся строки переворачивать не нужно — его можно обработать как конкатенацию последовательных переворачиваемых префиксов длины 1.Поскольку для k = 1 задача тривиальна, осталось решать задачу для k = 2, то есть деление строки на две части (префикс и суффикс) и какой-то способ их переворачивания. Случай, когда ничего не переворачивается, нам не интересен, рассмотрим два других случая: Префикс не переворачивается. В таком случае обязательно переворачивается суффикс. Два варианта строки с перевернутым суффиксом можно сравнивать за O(1) с помощью z-функции строки Sr#S. Префикс переворачивается. Для решения этого случая можно воспользоваться утверждениями из разбора задачи F Яндекс.Алгоритма 2015 из Раунда 2.2 авторства GlebsHP и рассмотреть только два варианта поворота префикса, перебрав для каждого из них все два варианта поворота суффикса. Остается выбрать из двух случаев лучший ответ. Итоговая асимптотика решения O(|s|).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21487",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 594\\s*D"
          },
          "content_length": 9891
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #330 - Codeforces - Code 1",
          "code": "Codeforces Round 330",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 2",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 3",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 4",
          "code": "5\n1 3 6 7 15",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 5",
          "code": "5\n1 3 6 7 15",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 6",
          "code": "spent one hour on the C --> :C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 7",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 8",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 9",
          "code": "a[i + N / 2] - a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 10",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 11",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 12",
          "code": "5\n1 7 100 130 131",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 13",
          "code": "5\n1 7 100 130 131",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 14",
          "code": "long long int a = pow(21.0, 14);\n    cout << a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 15",
          "code": "long long int a = pow(21.0, 14);\n    cout << a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 16",
          "code": "int exp (int b, int p) {\n   if (p == 0) {\n      return 1;\n   } else if (p % 2 == 1) {\n      return b * exp(b * b, p >> 1);\n   } else { // if (p % 2 == 0)\n      return exp(b * b, p >> 1);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 17",
          "code": "int exp (int b, int p) {\n   if (p == 0) {\n      return 1;\n   } else if (p % 2 == 1) {\n      return b * exp(b * b, p >> 1);\n   } else { // if (p % 2 == 0)\n      return exp(b * b, p >> 1);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 18",
          "code": "6\n0 1 2 5 6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 19",
          "code": "6\n0 1 2 5 6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 20",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,s,t,r,v;\nconst double pi=acos(-1.0);\ndouble C;\ndouble g(double L)\n{\n    double s=0.5*L,t;\n    while(1)\n    {\n        t=s-(s+2*r*sin(s/(2*r))-L)/(1+cos(s/(2*r)));\n        if(fabs(s-t)<1e-6)return t;\n        s=t;\n    }\n}\ndouble f(double len)\n{\n    double ll=floor(len/C)*C;\n    return (ll+g(len-ll))/v;\n}\nint main()\n{\n    int i,j,k;\n    scanf(\"%d%d%d\",&n,&r,&v);\n    C=2*pi*r;\n    while(n--)\n    {\n        scanf(\"%d%d\",&s,&t);\n        printf(\"%.15lf\\n\",f(t-s));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 21",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,s,t,r,v;\nconst double pi=acos(-1.0);\ndouble C;\ndouble g(double L)\n{\n    double s=0.5*L,t;\n    while(1)\n    {\n        t=s-(s+2*r*sin(s/(2*r))-L)/(1+cos(s/(2*r)));\n        if(fabs(s-t)<1e-6)return t;\n        s=t;\n    }\n}\ndouble f(double len)\n{\n    double ll=floor(len/C)*C;\n    return (ll+g(len-ll))/v;\n}\nint main()\n{\n    int i,j,k;\n    scanf(\"%d%d%d\",&n,&r,&v);\n    C=2*pi*r;\n    while(n--)\n    {\n        scanf(\"%d%d\",&s,&t);\n        printf(\"%.15lf\\n\",f(t-s));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 22",
          "code": "7\n1 2 3 4 50 125 140",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 23",
          "code": "7\n1 2 3 4 50 125 140",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 1",
          "code": "\"в середине дистанции каждого соревнования датчик должен находиться либо в самой верхней точке колеса, либо в самой нижней точке колеса\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 2",
          "code": "\"в середине дистанции каждого соревнования датчик должен находиться либо в самой верхней точке колеса, либо в самой нижней точке колеса\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 3",
          "code": "xd(t) = xc(t) + r * sin( v * t / r )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 4",
          "code": "vd(t) = v + v * cos( v * t / r )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 5",
          "code": "x + sin( x )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 6",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 7",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = 200000;\n    const int MAX_Q = 200000;\n    const int MAX_AI = 1000000;\n\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, MAX_AI, \"a_i\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, MAX_Q, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = 200000;\n    const int MAX_Q = 200000;\n    const int MAX_AI = 1000000;\n\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, MAX_AI, \"a_i\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, MAX_Q, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = 200000;\n    const int MAX_Q = 200000;\n    const int MAX_AI = 1000000;\n\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, MAX_AI, \"a_i\");\n    inf.readEoln();\n\n    int q = inf.readInt(1, MAX_Q, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int li = inf.readInt(1, n, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, n, \"ri\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for(int i = 2; i * 1ll * i <= n; ++i) {\n        if(n % i == 0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string typea = opt<string>(\"typea\", \"random_small\");\n    string typeq = opt<string>(\"typeq\", \"random\");\n\n    vector<int> a(n);\n\n    // Generate array a based on typea\n    if (typea == \"ones\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (typea == \"max\") {\n        fill(a.begin(), a.end(), 1000000);\n    } else if (typea == \"random_small\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 10);  // Small numbers\n    } else if (typea == \"random_large\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(500000, 1000000);  // Large numbers\n    } else if (typea == \"primes\") {\n        vector<int> primes;\n        const int MAX_PRIME = 1000000;\n        vector<bool> is_prime(MAX_PRIME+1, true);\n        is_prime[0] = is_prime[1] = false;\n        for(int i = 2; i <= MAX_PRIME; ++i) {\n            if(is_prime[i]) {\n                primes.push_back(i);\n                for(int j = 2*i; j <= MAX_PRIME; j += i)\n                    is_prime[j] = false;\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = primes[rnd.next(0, (int)primes.size()-1)];\n        }\n    } else if (typea == \"composite_small\") {\n        // Numbers with small composite numbers\n        for (int i = 0; i < n; ++i) {\n            int num;\n            do {\n                num = rnd.next(2, 100);\n            } while (is_prime(num));\n            a[i] = num;\n        }\n    } else if (typea == \"composite_large\") {\n        // Numbers with large composite numbers\n        for (int i = 0; i < n; ++i) {\n            int num;\n            do {\n                num = rnd.next(500000, 1000000);\n            } while (is_prime(num));\n            a[i] = num;\n        }\n    } else if (typea == \"power_of_small_prime\") {\n        // Numbers that are powers of small primes\n        vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n        for (int i = 0; i < n; ++i) {\n            int p = primes[rnd.next(0, (int)primes.size()-1)];\n            int e = rnd.next(1, 6);  // Exponent between 1 and 6\n            int num = 1;\n            for (int j = 0; j < e; ++j)\n                num *= p;\n            a[i] = num;\n        }\n    } else if (typea == \"repeating_numbers\") {\n        int num = rnd.next(2, 1000000);\n        fill(a.begin(), a.end(), num);\n    } else if (typea == \"alternating_numbers\") {\n        int num1 = rnd.next(2, 1000000);\n        int num2 = rnd.next(2, 1000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i%2 == 0) ? num1 : num2;\n        }\n    }\n\n    // Now generate queries\n    vector<pair<int, int>> queries(q);\n\n    if (typeq == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            queries[i] = make_pair(l, r);\n        }\n    } else if (typeq == \"full_range\") {\n        for (int i = 0; i < q; ++i) {\n            queries[i] = make_pair(1, n);\n        }\n    } else if (typeq == \"small_ranges\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int len = rnd.next(1, 10);\n            int r = min(n, l + len -1);\n            queries[i] = make_pair(l, r);\n        }\n    } else if (typeq == \"large_ranges\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n/2);\n            int r = rnd.next(n/2, n);\n            if (l > r) swap(l, r);\n            queries[i] = make_pair(l, r);\n        }\n    } else if (typeq == \"single_point\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            queries[i] = make_pair(l, l);\n        }\n    } else if (typeq == \"prefix_queries\") {\n        for (int i = 0; i < q; ++i) {\n            int r = rnd.next(1, n);\n            queries[i] = make_pair(1, r);\n        }\n    } else if (typeq == \"suffix_queries\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            queries[i] = make_pair(l, n);\n        }\n    } else if (typeq == \"overlap_queries\") {\n        int base_l = rnd.next(1, n/2);\n        int base_r = rnd.next(n/2+1, n);\n        for (int i = 0; i < q; ++i) {\n            int delta_l = rnd.next(0, 10);\n            int delta_r = rnd.next(0, 10);\n            int l = max(1, base_l - delta_l);\n            int r = min(n, base_r + delta_r);\n            queries[i] = make_pair(l, r);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], \" \\n\"[i==n-1]);\n\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i)\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for(int i = 2; i * 1ll * i <= n; ++i) {\n        if(n % i == 0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string typea = opt<string>(\"typea\", \"random_small\");\n    string typeq = opt<string>(\"typeq\", \"random\");\n\n    vector<int> a(n);\n\n    // Generate array a based on typea\n    if (typea == \"ones\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (typea == \"max\") {\n        fill(a.begin(), a.end(), 1000000);\n    } else if (typea == \"random_small\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 10);  // Small numbers\n    } else if (typea == \"random_large\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(500000, 1000000);  // Large numbers\n    } else if (typea == \"primes\") {\n        vector<int> primes;\n        const int MAX_PRIME = 1000000;\n        vector<bool> is_prime(MAX_PRIME+1, true);\n        is_prime[0] = is_prime[1] = false;\n        for(int i = 2; i <= MAX_PRIME; ++i) {\n            if(is_prime[i]) {\n                primes.push_back(i);\n                for(int j = 2*i; j <= MAX_PRIME; j += i)\n                    is_prime[j] = false;\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = primes[rnd.next(0, (int)primes.size()-1)];\n        }\n    } else if (typea == \"composite_small\") {\n        // Numbers with small composite numbers\n        for (int i = 0; i < n; ++i) {\n            int num;\n            do {\n                num = rnd.next(2, 100);\n            } while (is_prime(num));\n            a[i] = num;\n        }\n    } else if (typea == \"composite_large\") {\n        // Numbers with large composite numbers\n        for (int i = 0; i < n; ++i) {\n            int num;\n            do {\n                num = rnd.next(500000, 1000000);\n            } while (is_prime(num));\n            a[i] = num;\n        }\n    } else if (typea == \"power_of_small_prime\") {\n        // Numbers that are powers of small primes\n        vector<int> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n        for (int i = 0; i < n; ++i) {\n            int p = primes[rnd.next(0, (int)primes.size()-1)];\n            int e = rnd.next(1, 6);  // Exponent between 1 and 6\n            int num = 1;\n            for (int j = 0; j < e; ++j)\n                num *= p;\n            a[i] = num;\n        }\n    } else if (typea == \"repeating_numbers\") {\n        int num = rnd.next(2, 1000000);\n        fill(a.begin(), a.end(), num);\n    } else if (typea == \"alternating_numbers\") {\n        int num1 = rnd.next(2, 1000000);\n        int num2 = rnd.next(2, 1000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i%2 == 0) ? num1 : num2;\n        }\n    }\n\n    // Now generate queries\n    vector<pair<int, int>> queries(q);\n\n    if (typeq == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            queries[i] = make_pair(l, r);\n        }\n    } else if (typeq == \"full_range\") {\n        for (int i = 0; i < q; ++i) {\n            queries[i] = make_pair(1, n);\n        }\n    } else if (typeq == \"small_ranges\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            int len = rnd.next(1, 10);\n            int r = min(n, l + len -1);\n            queries[i] = make_pair(l, r);\n        }\n    } else if (typeq == \"large_ranges\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n/2);\n            int r = rnd.next(n/2, n);\n            if (l > r) swap(l, r);\n            queries[i] = make_pair(l, r);\n        }\n    } else if (typeq == \"single_point\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            queries[i] = make_pair(l, l);\n        }\n    } else if (typeq == \"prefix_queries\") {\n        for (int i = 0; i < q; ++i) {\n            int r = rnd.next(1, n);\n            queries[i] = make_pair(1, r);\n        }\n    } else if (typeq == \"suffix_queries\") {\n        for (int i = 0; i < q; ++i) {\n            int l = rnd.next(1, n);\n            queries[i] = make_pair(l, n);\n        }\n    } else if (typeq == \"overlap_queries\") {\n        int base_l = rnd.next(1, n/2);\n        int base_r = rnd.next(n/2+1, n);\n        for (int i = 0; i < q; ++i) {\n            int delta_l = rnd.next(0, 10);\n            int delta_r = rnd.next(0, 10);\n            int l = max(1, base_l - delta_l);\n            int r = min(n, base_r + delta_r);\n            queries[i] = make_pair(l, r);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], \" \\n\"[i==n-1]);\n\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i)\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -typea ones -typeq full_range\n./gen -n 1 -q 200000 -typea ones -typeq single_point\n./gen -n 200000 -q 1 -typea max -typeq full_range\n./gen -n 200000 -q 200000 -typea random_small -typeq random\n./gen -n 200000 -q 200000 -typea random_large -typeq random\n./gen -n 200000 -q 200000 -typea primes -typeq random\n./gen -n 200000 -q 200000 -typea composite_small -typeq random\n./gen -n 200000 -q 200000 -typea composite_large -typeq random\n./gen -n 200000 -q 200000 -typea power_of_small_prime -typeq random\n./gen -n 200000 -q 200000 -typea repeating_numbers -typeq random\n./gen -n 200000 -q 200000 -typea alternating_numbers -typeq random\n./gen -n 200000 -q 200000 -typea random_small -typeq small_ranges\n./gen -n 200000 -q 200000 -typea random_large -typeq large_ranges\n./gen -n 200000 -q 200000 -typea random_small -typeq prefix_queries\n./gen -n 200000 -q 200000 -typea random_large -typeq suffix_queries\n./gen -n 200000 -q 200000 -typea random_large -typeq overlap_queries\n./gen -n 200000 -q 200000 -typea composite_small -typeq random\n./gen -n 200000 -q 200000 -typea composite_small -typeq single_point\n./gen -n 200000 -q 200000 -typea composite_small -typeq full_range\n./gen -n 200000 -q 200000 -typea composite_large -typeq small_ranges\n./gen -n 200000 -q 200000 -typea ones -typeq random\n./gen -n 200000 -q 200000 -typea max -typeq random\n./gen -n 200000 -q 1 -typea random_small -typeq full_range\n./gen -n 2 -q 1 -typea ones -typeq full_range\n./gen -n 3 -q 3 -typea composite_small -typeq single_point\n./gen -n 100 -q 50 -typea composite_large -typeq small_ranges\n./gen -n 1000 -q 500 -typea primes -typeq random\n./gen -n 10000 -q 10000 -typea power_of_small_prime -typeq random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:55:11.550519",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "594/E",
      "title": "E. Разрезание строки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записана строка s (1 ≤ |s| ≤ 5 000 000), состоящая из строчных букв английского алфавита. Во второй строке содержится целое число k (1 ≤ k ≤ |s|) — максимальное количество частей в разбиении.",
      "output_spec": "Выходные данныеВ единственной строке выведите лексикографически минимальную строку s', которая может получиться в результате выполнения описанной операции.",
      "sample_tests": "ПримерыВходные данныеСкопироватьaba2Выходные данныеСкопироватьaabВходные данныеСкопироватьaaaabacaba2Выходные данныеСкопироватьaaaaabacabВходные данныеСкопироватьbababa1Выходные данныеСкопироватьabababВходные данныеСкопироватьabacabadabacaba4Выходные данныеСкопироватьaababacabacabad",
      "description": "E. Разрезание строки\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных записана строка s (1 ≤ |s| ≤ 5 000 000), состоящая из строчных букв английского алфавита. Во второй строке содержится целое число k (1 ≤ k ≤ |s|) — максимальное количество частей в разбиении.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите лексикографически минимальную строку s', которая может получиться в результате выполнения описанной операции.\n\nВыходные данные\n\nВходные данныеСкопироватьaba2Выходные данныеСкопироватьaabВходные данныеСкопироватьaaaabacaba2Выходные данныеСкопироватьaaaaabacabВходные данныеСкопироватьbababa1Выходные данныеСкопироватьabababВходные данныеСкопироватьabacabadabacaba4Выходные данныеСкопироватьaababacabacabad\n\nВходные данныеСкопироватьaba2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьaab\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьaaaabacaba2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьaaaaabacab\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьbababa1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьababab\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьabacabadabacaba4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьaababacabacabad\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #330 - Codeforces",
          "content": "Добрый день, Codeforces!Рад сообщить, что в это воскресенье, 8го ноября в 19:30 MSK состоится Codeforces Round #330 для участников обоих дивизионов.Задачи для вас уже не в первый раз с удовольствием придумывали и готовили Александр fcspartakm Фролов и я, Данил Сагунов. Мы говорим спасибо координатору Codeforces Глебу GlebsHP Евстропову за существенную помощь в подготовке задач, Михаилу MikeMirzayanov Мирзаянову за системы Codeforces и Polygon, Марии Delinur Беловой за перевод условий на английский язык, а также Владиславу winger Исенбаеву и Александру AlexFetisov Фетисову за тестирование и прорешивание задач раунда.Каждому из участников раунда будет предоставлено два часа на решение пяти задач. Мы постарались сделать задачи разнообразными и интересными, и поэтому настоятельно рекомендуем прочитать все задачи во время раунда. Разбалловка, как и всегда, будет объявлена позднее.Желаем всем удачи и высокого рейтинга!UPD. Еще раз приносим свои извинения за задачу Cdiv2/Adiv1 — авторское решение неправильно работало в случае нечетных n. Мы очень надеемся, что остальные задачи контеста оказались (или окажутся в дорешивании) для вас полезными и интересными.В любом случае, хотим поздравить победителей раунда:Победители первого дивизиона: jcvb 2222 KAN победители второго дивизиона: Tagrimar fsps60312 uhateme Разбор задач можно найти здесь.UPD. Задача Cdiv2/Adiv1 была исправлена, и теперь имеет то условие и решение, которое предполагали авторы. Задача вернулась в соревнование и доступна для дорешивания.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21464",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1517
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces",
          "content": "595A — Виталий и ночь Простая задача на реализацию. Проитерируемся по i от 1 до n, а внутри проитерируемся по j от 1 до 2·m, причем на каждой итерации будем увеличивать j на два. Если на текущей итерации a[i][j] = '1' или a[i][j + 1] = '1' увеличим ответ на один. Асимптотика решения — O(nm). 595B — Паша и телефон Будем считать ответ для каждого блока отдельно и умножать ответ для предыдущих блоков на ответ для текущего блока, при этом не забывая брать результат перемножения по модулю. Для блока длины k ответ считается следующим образом. Пусть для этого блока число должно делиться на x и не должно начинаться с цифры y. Тогда ответ для этого блока — количество чисел из k цифр, делящихся на x, минус количество чисел, начинающихся с цифры y и состоящих из k цифр, плюс количество чисел, начинающихся с цифры y - 1 (только если y > 0) и состоящих из k цифр. Асимптотика решения — O(n / k). 594A — Воин и лучник Отсортируем все точки по возрастанию координаты x, далее будем работать с перенумерованными точками.Предположим, что при оптимальной игре после ходов игроков остались точки с номерами l и r (l < r). Утверждается, что первый игрок не запретил ни одну из точек с индексом l < i < r, ведь в противном случае он играл не оптимально и мог запретить точку l или точку r (можно показать, что это не зависит от оптимальных действий второго игрока), поменяв оптимальный ответ. Получается, что номера всех запрещенных первым игроком точек лежат вне отрезка [l, r], а значит . Заметим, что выбрав некоторую такую границу [l, r] при , первый игрок может всегда добиться того, чтобы точки в ответе лежали внутри этого отрезка.Второй игрок хочет добиться того, чтобы (меньше он сделать не может), то есть всегда запрещать точку, лежащую строго внутри [l, r]. Поскольку второй игрок не знает наперед, к каким точкам стремится игрок, после каждого хода первого игрока ему необходимо запрещать точку, которая лежит строго внутри каждой из возможных границ, образованных этими точками. Нетрудно показать, что эта точка является медианой оставшегося множества точек (а их нечетное количество), ведь количество оставшихся ходов первого игрока на единицу меньше количества ходов второго, и он сможет впоследствии запретить все, кроме трех медианных точек. Две крайние из них второму игроку запрещать нельзя, так как они могут впоследствии увеличить количество удаленных слева (или справа) первым игроком точек, а средняя из них как раз принадлежит всевозможным границам, которые мог выбрать первый игрок. Таким образом второй игрок всегда может свести ситуацию к .Ответ на задачу — минимум среди значений .594B — Максим и велосипед Главное утверждение для решения этой задачи — в середине дистанции каждого соревнования датчик должен находиться либо в самой верхней точке колеса, либо в самой нижней точке колеса. Для того, чтобы посчитать ответ, воспользуемся бинпоиском. Если центр колеса прошел расстояние c то датчик переместился на расстояние c + rsin(c / r), если в середине датчик находился сверху колеса, или на расстояние c - rsin(c / r), если в середине датчие находился снизу колеса, где r — это радиус колеса. Асимптотика решения — . 594С — Эдо и магниты Найдем центры прямоугольников и умножим их координаты на два, чтобы далее работать с целыми координатами. Тогда подходящим холодильником (для всех точек) является прямоугольник, содержащий все точки, но с длинами сторон, округленными вверх к ближайшему четному числу. Представим теперь, что удаляем магниты с холодильника последовательно, постепенно \"уменьшая\" прямоугольник. Очевидно, что каждый раз выгодно удалять только те точки, что лежат на какой-то из четырех сторон прямоугольника. Переберем 4k вариантов того, как мы будем это делать, с помощью рекурсии, каждый раз удаляя одну из еще не удаленных точек с максимальным или минимальным значением по одной из координат. Если мы будем поддерживать 4 массива (или два массива в виде дека), то это можно делать за O(1) амортизированно. Такое решение будет работать за O(4k). Можно также заметить, что описанный выше алгоритм удаляет всегда несколько самых правых, левых, верхних, и нижних точек. Можно перебрать, как k распределится среди этих величин и промоделировать удаление с помощью, например, описанных выше 4 массивов. Такое решение имеет асимптотику O(k4). 594D — REQ Для подсчета ответа на каждый запрос будем пользоваться формулой , где p1, p2, ..., pk — все простые, делящие n. Эту формулу каждый может попробовать доказать или воспользоваться уже существующими доказательствами. Все вычисления ниже производим по модулю 109 + 7 Предположим теперь, что мы решаем задачу для фиксированного левого конца отрезка l, отбросив все элементы левее. Любой запрос теперь превращается в запрос на префиксе массива. Тогда, судя по формуле, для каждого простого p нас интересует лишь его самое левое вхождение, потому что все остальные вхождения не будут влиять на правую часть в приведенной выше формуле. Превратим наш запрос на значение функции Эйлера в запрос произведения на префиксе: сначала проинициализируем дерево Фенвика произведений единицами, затем сделаем умножения в точках l, l + 1, ..., n значениями соответствующих элементов al, al + 1, ..., an, затем для каждого самого левого вхождения простого p в позицию i сделаем умножение в точке i на значение . Нетрудно убедиться, что теперь запрос на префиксе определенной длины даст правильный ответ для отрезка той же длины с левым концом в l. Такую подготовку для фиксированного левого конца можно осуществить за , где C — максимальное значение элемента (этот логарифм соответствует количеству простых в разложении какого-то из ai). Нас интересуют все левые концы, поэтому научимся переходить от одного из них к другому. В самом деле, пусть все было посчитано для левого конца l и мы хотим теперь перейти к левому концу l + 1. Нас перестает интересовать al внутри левой части формулы, поэтому сделаем умножение в дереве Фенвика в точке l на значение al - 1. Так же нас перестают интересовать все простые внутри al (а они, очевидно, самые левые среди своих вхождений), поэтому сделаем так же умножения в точке l на все значения . Однако у каждого из этих простых могли существовать другие вхождения, которые теперь станут самыми левыми. Добавим их с помощью умножений, описанных выше. С помощью сортировок (или векторов) переход между соседними левыми концами реализуется за суммарную . Чтобы правильно отвечать на запросы, их так же нужно правильно отсортировать (или поместить в динамический массив), и ответ на запрос будет совершать операций. Суммарная асимптотика всего решения операций и дополнительной памяти. 594E — Разрезание строки Опишем жадный алгоритм, который позволяет решить задачу при k > 2 для любой строки S.Будем считать, что мы всегда переворачиваем некоторый префикс строки S (возможно, длины 1, подробнее ниже). Поскольку мы стремимся минимизировать строку лексикографически, легко убедиться в том, что мы будем переворачивать такие и только такие префиксы, префикс которых (после переворачивания) совпадает с минимальным лексикографически суффиксом перевернутой строки S (обозначим ее Sr), в частности, это префикс, совпадающий по длине с минимальным суффиксом Sr (операция переворачивания префикса S равносильна замене его суффиксом Sr соответствующей длины).Обозначим минимальный лексикографически суффикс строки Sr как s. Можно показать, что никакие два вхождения s в Sr не пересекаются, так как в противном случае строка s была бы периодической, и минимальный суффикс имел бы меньшую длину. Значит, строка Sr имеет вид tpsaptp - 1sap - 1tp - 2... t1sa1, где sx означает конкатенацию строки s x раз, a1, a2, ..., ap — натуральные числа, а строки t1, t2, ..., tp — некоторые непустые (кроме, возможно, tp) строки, не содержащие s в качестве подстроки.Перевернув некоторый подходящий префикс строки S, мы перейдем к меньшей строке S', при этом минимальный суффикс s' этой перевернутой строки S'r не может быть лексикографически меньше, чем s (это каждый может доказать самостоятельно), поэтому мы стремимся сделать так, чтобы s' осталось равным s, что позволит увеличить префикс вида sb в ответе (а значит и минимизировать его). Легко доказать, что максимальное b, которое мы можем получить, равно a1 в случае p = 1 и (в случае, если p \\geq 2$). Действительно, после таких операций префикс ответа будет выглядеть как sa1saitisai - 1... sa2t2. Поскольку t_{i} — непустые строки, увеличить количество конкатенаций s в префиксе ответа никак не получится. Заметим, что переворот второго префикса (sai...) возможен, так как k > 2.Из описанных выше утверждений следует, что при k > 2 для оставшейся строки всегда следует переворачивать префикс, который после переворота совпадает с суффиксом строки Sr вида sa1. Чтобы находить этот суффикс каждый раз, достаточно один раз построить декомпозицию Линдона (с помощью алгоритма Дюваля) перевернутой исходной строки и аккуратно объединять равные строки в ней. Единственным случаем остается вариант, когда префикс оставшейся строки переворачивать не нужно — его можно обработать как конкатенацию последовательных переворачиваемых префиксов длины 1.Поскольку для k = 1 задача тривиальна, осталось решать задачу для k = 2, то есть деление строки на две части (префикс и суффикс) и какой-то способ их переворачивания. Случай, когда ничего не переворачивается, нам не интересен, рассмотрим два других случая: Префикс не переворачивается. В таком случае обязательно переворачивается суффикс. Два варианта строки с перевернутым суффиксом можно сравнивать за O(1) с помощью z-функции строки Sr#S. Префикс переворачивается. Для решения этого случая можно воспользоваться утверждениями из разбора задачи F Яндекс.Алгоритма 2015 из Раунда 2.2 авторства GlebsHP и рассмотреть только два варианта поворота префикса, перебрав для каждого из них все два варианта поворота суффикса. Остается выбрать из двух случаев лучший ответ. Итоговая асимптотика решения O(|s|).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21487",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 594\\s*E"
          },
          "content_length": 9891
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #330 - Codeforces - Code 1",
          "code": "Codeforces Round 330",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 2",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 3",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 4",
          "code": "5\n1 3 6 7 15",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 5",
          "code": "5\n1 3 6 7 15",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 6",
          "code": "spent one hour on the C --> :C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 7",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 8",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 9",
          "code": "a[i + N / 2] - a[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 10",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 11",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 12",
          "code": "5\n1 7 100 130 131",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 13",
          "code": "5\n1 7 100 130 131",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 14",
          "code": "long long int a = pow(21.0, 14);\n    cout << a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 15",
          "code": "long long int a = pow(21.0, 14);\n    cout << a;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 16",
          "code": "int exp (int b, int p) {\n   if (p == 0) {\n      return 1;\n   } else if (p % 2 == 1) {\n      return b * exp(b * b, p >> 1);\n   } else { // if (p % 2 == 0)\n      return exp(b * b, p >> 1);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 17",
          "code": "int exp (int b, int p) {\n   if (p == 0) {\n      return 1;\n   } else if (p % 2 == 1) {\n      return b * exp(b * b, p >> 1);\n   } else { // if (p % 2 == 0)\n      return exp(b * b, p >> 1);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 18",
          "code": "6\n0 1 2 5 6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 19",
          "code": "6\n0 1 2 5 6 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 20",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,s,t,r,v;\nconst double pi=acos(-1.0);\ndouble C;\ndouble g(double L)\n{\n    double s=0.5*L,t;\n    while(1)\n    {\n        t=s-(s+2*r*sin(s/(2*r))-L)/(1+cos(s/(2*r)));\n        if(fabs(s-t)<1e-6)return t;\n        s=t;\n    }\n}\ndouble f(double len)\n{\n    double ll=floor(len/C)*C;\n    return (ll+g(len-ll))/v;\n}\nint main()\n{\n    int i,j,k;\n    scanf(\"%d%d%d\",&n,&r,&v);\n    C=2*pi*r;\n    while(n--)\n    {\n        scanf(\"%d%d\",&s,&t);\n        printf(\"%.15lf\\n\",f(t-s));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 21",
          "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,s,t,r,v;\nconst double pi=acos(-1.0);\ndouble C;\ndouble g(double L)\n{\n    double s=0.5*L,t;\n    while(1)\n    {\n        t=s-(s+2*r*sin(s/(2*r))-L)/(1+cos(s/(2*r)));\n        if(fabs(s-t)<1e-6)return t;\n        s=t;\n    }\n}\ndouble f(double len)\n{\n    double ll=floor(len/C)*C;\n    return (ll+g(len-ll))/v;\n}\nint main()\n{\n    int i,j,k;\n    scanf(\"%d%d%d\",&n,&r,&v);\n    C=2*pi*r;\n    while(n--)\n    {\n        scanf(\"%d%d\",&s,&t);\n        printf(\"%.15lf\\n\",f(t-s));\n    }\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 22",
          "code": "7\n1 2 3 4 50 125 140",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 - Codeforces - Code 23",
          "code": "7\n1 2 3 4 50 125 140",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21464",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 1",
          "code": "\"в середине дистанции каждого соревнования датчик должен находиться либо в самой верхней точке колеса, либо в самой нижней точке колеса\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 2",
          "code": "\"в середине дистанции каждого соревнования датчик должен находиться либо в самой верхней точке колеса, либо в самой нижней точке колеса\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 3",
          "code": "xd(t) = xc(t) + r * sin( v * t / r )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 4",
          "code": "vd(t) = v + v * cos( v * t / r )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 5",
          "code": "x + sin( x )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 6",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 7",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]+\", \"s\");\n    ensuref(1 <= (int)s.length() && (int)s.length() <= 5000000, \"The length of s must be between 1 and 5000000, but it is %d.\", (int)s.length());\n    int k = inf.readInt(1, (int)s.length(), \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]+\", \"s\");\n    ensuref(1 <= (int)s.length() && (int)s.length() <= 5000000, \"The length of s must be between 1 and 5000000, but it is %d.\", (int)s.length());\n    int k = inf.readInt(1, (int)s.length(), \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]+\", \"s\");\n    ensuref(1 <= (int)s.length() && (int)s.length() <= 5000000, \"The length of s must be between 1 and 5000000, but it is %d.\", (int)s.length());\n    int k = inf.readInt(1, (int)s.length(), \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test case for the following problem:\n\n    You are given a non-empty string s of lowercase English letters (|s| up to 5,000,000)\n    and an integer k (1 <= k <= |s|).\n    Exactly one operation is performed on s:\n       - Split s into m non-empty parts (m <= k).\n       - Some (possibly zero) parts may be reversed.\n       - Concatenate them in the original order to form s'.\n\n    The task is to find the lexicographically smallest possible s' after exactly one such operation.\n\n  Generator parameters:\n    -n {length of the string}\n    -k {maximum number of parts}\n    -type {random | repeated | palindrome | nearpal | zigzag}\n\n  After generating the string s, the generator prints two lines:\n    1) The string s\n    2) The integer k\n\n  Usage example:\n    ./gen -n 10 -k 5 -type random\n*/\n\nstatic const int ALPH_SIZE = 26; // 'a'..'z'\n\n// Generate a random character in [a..z].\nchar randChar() {\n    return char('a' + rnd.next(ALPH_SIZE));\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters.\n    int n = opt<int>(\"n\");\n    int K = opt<int>(\"k\"); // maximum number of parts\n    string type = opt<string>(\"type\", \"random\"); // default \"random\"\n\n    // Safety checks (not strictly necessary for testlib usage, but good practice).\n    // Ensure 1 <= n, 1 <= K <= n.\n    // The user of this generator should provide valid params, but let's be defensive.\n    if (n < 1) {\n        cerr << \"Error: n must be at least 1.\" << endl;\n        return 1;\n    }\n    if (K < 1 || K > n) {\n        cerr << \"Error: k must be between 1 and n.\" << endl;\n        return 1;\n    }\n\n    // We'll build our string s.\n    // The type parameter controls how we build it.\n    string s;\n    s.reserve(n);\n\n    if (type == \"random\") {\n        // Generate a purely random string of length n.\n        for (int i = 0; i < n; i++) {\n            s.push_back(randChar());\n        }\n    }\n    else if (type == \"repeated\") {\n        // Pick one random character and repeat it n times.\n        char c = randChar();\n        s.append(n, c);\n    }\n    else if (type == \"palindrome\") {\n        // Generate a palindromic string of length n.\n        // Fill first half randomly, then mirror it.\n        // If n is odd, the middle character is random.\n        int half = n / 2;\n        for (int i = 0; i < half; i++) {\n            s.push_back(randChar());\n        }\n        if (n % 2 == 1) {\n            s.push_back(randChar());\n        }\n        // mirror\n        for (int i = half - 1; i >= 0; i--) {\n            s.push_back(s[i]);\n        }\n    }\n    else if (type == \"nearpal\") {\n        // Generate a palindrome, but alter 1-2 characters slightly.\n        // This tests logic near palindromes.\n        int half = n / 2;\n        string temp;\n        temp.reserve(half);\n        for (int i = 0; i < half; i++) {\n            temp.push_back(randChar());\n        }\n        // Middle for odd lengths\n        char mid = 0;\n        if (n % 2 == 1) {\n            mid = randChar();\n        }\n        // Mirror\n        s = temp;\n        if (mid) {\n            s.push_back(mid);\n        }\n        for (int i = half - 1; i >= 0; i--) {\n            s.push_back(temp[i]);\n        }\n        // Now alter 1 or 2 random positions if possible, to break perfect symmetry slightly.\n        // We'll do at most 2 changes, ensure changes are minor and still in 'a'..'z'.\n        int changes = min(2, n); \n        for (int i = 0; i < changes; i++) {\n            int pos = rnd.next(n); // [0..n-1]\n            char oldC = s[pos];\n            char newC = randChar();\n            // Ensure newC != oldC if possible:\n            if (newC == oldC && ALPH_SIZE > 1) {\n                newC = char('a' + ( (oldC - 'a' + 1) % ALPH_SIZE ) );\n            }\n            s[pos] = newC;\n        }\n    }\n    else if (type == \"zigzag\") {\n        // Repetitive pattern like abc...zabc... until length n.\n        // Great for checking partial reversals.\n        for (int i = 0; i < n; i++) {\n            s.push_back(char('a' + (i % ALPH_SIZE)));\n        }\n    }\n    else {\n        // Default fallback: random\n        for (int i = 0; i < n; i++) {\n            s.push_back(randChar());\n        }\n    }\n\n    // Output the string, then the integer k on its own line (the problem's required format).\n    printf(\"%s\\n%d\\n\", s.c_str(), K);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test case for the following problem:\n\n    You are given a non-empty string s of lowercase English letters (|s| up to 5,000,000)\n    and an integer k (1 <= k <= |s|).\n    Exactly one operation is performed on s:\n       - Split s into m non-empty parts (m <= k).\n       - Some (possibly zero) parts may be reversed.\n       - Concatenate them in the original order to form s'.\n\n    The task is to find the lexicographically smallest possible s' after exactly one such operation.\n\n  Generator parameters:\n    -n {length of the string}\n    -k {maximum number of parts}\n    -type {random | repeated | palindrome | nearpal | zigzag}\n\n  After generating the string s, the generator prints two lines:\n    1) The string s\n    2) The integer k\n\n  Usage example:\n    ./gen -n 10 -k 5 -type random\n*/\n\nstatic const int ALPH_SIZE = 26; // 'a'..'z'\n\n// Generate a random character in [a..z].\nchar randChar() {\n    return char('a' + rnd.next(ALPH_SIZE));\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters.\n    int n = opt<int>(\"n\");\n    int K = opt<int>(\"k\"); // maximum number of parts\n    string type = opt<string>(\"type\", \"random\"); // default \"random\"\n\n    // Safety checks (not strictly necessary for testlib usage, but good practice).\n    // Ensure 1 <= n, 1 <= K <= n.\n    // The user of this generator should provide valid params, but let's be defensive.\n    if (n < 1) {\n        cerr << \"Error: n must be at least 1.\" << endl;\n        return 1;\n    }\n    if (K < 1 || K > n) {\n        cerr << \"Error: k must be between 1 and n.\" << endl;\n        return 1;\n    }\n\n    // We'll build our string s.\n    // The type parameter controls how we build it.\n    string s;\n    s.reserve(n);\n\n    if (type == \"random\") {\n        // Generate a purely random string of length n.\n        for (int i = 0; i < n; i++) {\n            s.push_back(randChar());\n        }\n    }\n    else if (type == \"repeated\") {\n        // Pick one random character and repeat it n times.\n        char c = randChar();\n        s.append(n, c);\n    }\n    else if (type == \"palindrome\") {\n        // Generate a palindromic string of length n.\n        // Fill first half randomly, then mirror it.\n        // If n is odd, the middle character is random.\n        int half = n / 2;\n        for (int i = 0; i < half; i++) {\n            s.push_back(randChar());\n        }\n        if (n % 2 == 1) {\n            s.push_back(randChar());\n        }\n        // mirror\n        for (int i = half - 1; i >= 0; i--) {\n            s.push_back(s[i]);\n        }\n    }\n    else if (type == \"nearpal\") {\n        // Generate a palindrome, but alter 1-2 characters slightly.\n        // This tests logic near palindromes.\n        int half = n / 2;\n        string temp;\n        temp.reserve(half);\n        for (int i = 0; i < half; i++) {\n            temp.push_back(randChar());\n        }\n        // Middle for odd lengths\n        char mid = 0;\n        if (n % 2 == 1) {\n            mid = randChar();\n        }\n        // Mirror\n        s = temp;\n        if (mid) {\n            s.push_back(mid);\n        }\n        for (int i = half - 1; i >= 0; i--) {\n            s.push_back(temp[i]);\n        }\n        // Now alter 1 or 2 random positions if possible, to break perfect symmetry slightly.\n        // We'll do at most 2 changes, ensure changes are minor and still in 'a'..'z'.\n        int changes = min(2, n); \n        for (int i = 0; i < changes; i++) {\n            int pos = rnd.next(n); // [0..n-1]\n            char oldC = s[pos];\n            char newC = randChar();\n            // Ensure newC != oldC if possible:\n            if (newC == oldC && ALPH_SIZE > 1) {\n                newC = char('a' + ( (oldC - 'a' + 1) % ALPH_SIZE ) );\n            }\n            s[pos] = newC;\n        }\n    }\n    else if (type == \"zigzag\") {\n        // Repetitive pattern like abc...zabc... until length n.\n        // Great for checking partial reversals.\n        for (int i = 0; i < n; i++) {\n            s.push_back(char('a' + (i % ALPH_SIZE)));\n        }\n    }\n    else {\n        // Default fallback: random\n        for (int i = 0; i < n; i++) {\n            s.push_back(randChar());\n        }\n    }\n\n    // Output the string, then the integer k on its own line (the problem's required format).\n    printf(\"%s\\n%d\\n\", s.c_str(), K);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are example commands (20+ total) to generate a variety of tests.\n# Each command prints the test case to stdout.\n\n# 1) Very small strings\n./gen -n 1 -k 1 -type random\n./gen -n 2 -k 1 -type random\n./gen -n 3 -k 3 -type repeated\n./gen -n 3 -k 2 -type palindrome\n\n# 2) Small to moderate strings\n./gen -n 5 -k 1 -type nearpal\n./gen -n 5 -k 5 -type zigzag\n./gen -n 6 -k 2 -type repeated\n./gen -n 7 -k 3 -type palindrome\n./gen -n 10 -k 10 -type random\n./gen -n 10 -k 5 -type nearpal\n\n# 3) Medium strings\n./gen -n 20 -k 1 -type palindrome\n./gen -n 20 -k 2 -type nearpal\n./gen -n 20 -k 20 -type zigzag\n./gen -n 30 -k 15 -type random\n./gen -n 50 -k 25 -type repeated\n./gen -n 50 -k 1 -type zigzag\n\n# 4) Larger strings\n./gen -n 100 -k 1 -type nearpal\n./gen -n 100 -k 50 -type palindrome\n./gen -n 200 -k 2 -type random\n./gen -n 300 -k 300 -type zigzag\n./gen -n 500 -k 250 -type repeated\n./gen -n 999 -k 1 -type random\n\n# 5) Even larger strings\n./gen -n 1000 -k 1 -type palindrome\n./gen -n 1000 -k 500 -type nearpal\n./gen -n 5000 -k 2 -type random\n./gen -n 9999 -k 5000 -type repeated\n./gen -n 10000 -k 10000 -type zigzag\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:55:14.048505",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "595/A",
      "title": "A. Vitaly and Night",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers n and m (1 ≤ n, m ≤ 100) — the number of floors in the house and the number of flats on each floor respectively.Next n lines describe the floors from top to bottom and contain 2·m characters each. If the i-th window of the given floor has lights on, then the i-th character of this line is '1', otherwise it is '0'.",
      "output_spec": "OutputPrint a single integer — the number of flats that have lights on in at least one window, that is, the flats where, according to Vitaly, people aren't sleeping.",
      "sample_tests": "ExamplesInputCopy2 20 0 0 11 0 1 1OutputCopy3InputCopy1 31 1 0 1 0 0OutputCopy2",
      "description": "A. Vitaly and Night\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains two integers n and m (1 ≤ n, m ≤ 100) — the number of floors in the house and the number of flats on each floor respectively.Next n lines describe the floors from top to bottom and contain 2·m characters each. If the i-th window of the given floor has lights on, then the i-th character of this line is '1', otherwise it is '0'.\n\nOutputPrint a single integer — the number of flats that have lights on in at least one window, that is, the flats where, according to Vitaly, people aren't sleeping.\n\nInputCopy2 20 0 0 11 0 1 1OutputCopy3InputCopy1 31 1 0 1 0 0OutputCopy2\n\nInputCopy2 20 0 0 11 0 1 1\n\nOutputCopy3\n\nInputCopy1 31 1 0 1 0 0\n\nOutputCopy2\n\nNoteIn the first test case the house has two floors, two flats on each floor. That is, in total there are 4 flats. The light isn't on only on the second floor in the left flat. That is, in both rooms of the flat the light is off.In the second test case the house has one floor and the first floor has three flats. The light is on in the leftmost flat (in both windows) and in the middle flat (in one window). In the right flat the light is off.",
      "solutions": [
        {
          "title": "Codeforces Round #330 (Div.1 + Div.2) Editorial - Codeforces",
          "content": "595A — Vitaly and Night It was easy realization problem. Let's increase the variable i from 1 to n, and inside let's increase the variable j from 1 to 2·m. On every iteration we will increase the variable j on 2. If on current iteration a[i][j] = '1' or a[i][j + 1] = '1' let's increase the answer on one. Asymptotic behavior of this solution — O(nm). 595B — Pasha and Phone Let's calculate the answer to every block separately from each other and multiply the answer to the previous blocks to the answer for current block.For the block with length equals to k we can calculate the answer in the following way. Let for this block the number must be divided on x and must not starts with digit y. Then the answer for this block — the number of numbers containing exactly k digits and which divisible by x, subtract the number of numbers which have the first digit equals to y and containing exactly k digits and plus the number of numbers which have the first digit equals to y - 1 (only if y > 0) and containing exactly k digits.Asymptotic behavior of this solution — O(n / k). 594A — Warrior and Archer Let's sort the points by increasing x coordinate and work with sorted points array next.Let's suppose that after optimal playing points numbered l and r (l < r) are left. It's true that the first player didn't ban any of the points numbered i l < i < r, otherwise he could change his corresponding move to point l or point r (one could prove it doesn't depend on second player optimal moves) and change the optimal answer. It turns out that all the points banned by the first player have numbers outside of [l, r] segment, therefore . We should notice that if the first player choosed any [l, r] for , he could always make the final points numbers located inside this segment.The second player wants to make (he couldn't make less), what is equivalent if he always ban points inside final [l, r] segment (numbered l < i < r). As soon as the second player doesn't know what segment first player have chosen after every of his moves, he must detect a point which satisfies him in every first player choice. It's true number of this point is the median of set of point numbers left (the odd number) after the first player move. The number of moves of the first player left is lesser by one than moves of the second player, so the first player later could ban some points from the left and some points from the right, except three middle points. Two of it (leftmost and rightmost ones) shouldn't be banned by the second player as soon as it could increase the size of banned points from the left (or from the right), but third middle point satisfies the second player in every first player choice. This way the second player always bans the point inside final point segment.Thus the answer is the minimum between every of values.594B — Max and Bike The main proposition to solve this problem — in the middle of every competition the sensor must be or in the top point of the wheel or in the bottom point of the wheel.To calculate the answer we need to use binary search. If the center of the wheel moved on the distance c, then the sensor moved on the distance c + rsin(c / r), if the sensor was on the top point of the wheel in the middle, or on the distance c - rsin(c / r), if the sensor was on the bottom point of the wheel in the middle, where r — the radius of the wheel. Asymptotic behavior of this solution — . 594С — Edo and Magnets Let's find the centers of every rectangle and multiple them of 2 (to make all coordinates integers).Then we need to by the rectangle door, which contains all dots, but the lengths of the sides of this door must be rounded up to the nearest integers. Now, let's delete the magnets from the door one by one, gradually the door will decrease. Obviously every time optimal to delete only dots, which owned to the sides of the rectangle. Let's brute 4k ways, how we will do delete the magnets. We will do it with helps of recursion, every time we will delete point with minimum or maximum value of the coordinates. If we will store 4 arrays (or 2 deques) we can do it with asymptotic O(1). Such a solution works O(4k). It can be easily shown that this algorithm delete always some number of the leftmost, rightmost, uppermost and lowermost points. So we can brute how k will distributed between this values and we can model the deleting with helps of 4 arrays. This solution has asymptotic behavior O(k4). 594D — REQ To calculate the answer on every query let's use the formula , where p1, p2, ..., pk — all prime numbers which divided n. We make all calculations by the module 109 + 7 Let's suppose that we solving problem for fix left end l of the range. Every query now is a query on the prefix of the array. Then in formula for every prime p we need to know only about the leftmost position of it. Let's convert the query in the query of the multiple on the prefix: at first init Fenwick tree with ones, then make the multiplication in points l, l + 1, ..., n with value of the elements al, al + 1, ..., an. For every leftmost positions of prime p make in position i the multiplication in point i on the . This prepare can be done with asymptotic , where C — the maximum value of the element (this logarithm — the number of prime divisors of some ai). We interest in all leftmost ends, because of that let's know how to go from the one end to the other. Let we know all about the end l — how to update the end l + 1? Let's make the multiplication in the Fenwick tree in the point l on the value al - 1. Also we are not interesting in all prime numbers inside al, so let's make the multiplications in point l on the all values . But every of this prime numbers can have other entries which now becoming the leftmost. Add them with the multiplication which described above. With helps of sort the transition between leftmost ends can be done in . To answer to the queries we need to sort them in correct order (or add them in the dynamic array), and to the get the answer to the query we will make iterations. So total asymptotic behavior of solution is iterations and additional memory. 594E — Cutting the Line Let's describe the greedy algorithm, which allows to solve the problem for every k > 2 for every string S.Let's think, that we always reverse some prefix of the string S (may be with length equals to one). Because we want to minimize lexicographically the string it is easy to confirm that we will reverse such a prefixes, which prefix (after reversing) is equals to the minimal lexicographically suffix of the reverse string S (let it be Sr) — this is prefix, which length equals to the length of the minimum suffix Sr (the reverse operation of the prefix S equals to change it with suffix Sr).Let the lexicographically minimal suffix of the string Sr is s. It can be shown, that there are no 2 entries s in Sr which intersects, because of that the string s will be with period and minimal suffix will with less length. So, the string Sr looks like tpsaptp - 1sap - 1tp - 2... t1sa1, where sx means the concatenation of the string s x times, a1, a2, ..., ap — integers, and the strings t1, t2, ..., tp — some non-empty (exclude may be tp) strings, which do not contain the s inside.If we reverse some needed prefix of the string s, we will go to the string S', and the minimal suffix s' of the reversing string S'r can't be lexicographically less than s, because of that we need to make s' equals to s. It will helps us to increase prefix which look like sb in the answer (and we will can minimize it too). it is easy to show, that maximum b, which we can get equals to a1 in case p = 1 и (in case if p \\geq 2$). After such operations the prefix of the answer will looks like sa1saitisai - 1... sa2t2. Because t_{i} — non-empty strings we can not to increase the number of concatenations s in the prefix of the answer. The reversing of the second prefix (sai...) can be done because k > 2.From the information described above we know that if k > 2 for lost string we need always reverse prefix, which after reversing is equals to the suffix of the string Sr which looks like sa1. To find this suffix every time, we need only once to build Lindon decomposition (with helps of Duval's algorithm) of the reverse string and carefully unite the equals strings. Only one case is lost — prefix of the lost string does not need to be reverse — we can make the concatenation of the consecutive reverse prefixes with length equals to 1.Because for k = 1 the problem is very easy, we need to solve it for k = 2 — cut the string on the two pieces (prefix and suffix) and some way of their reverse. The case when nothing reverse is not interesting, let's look on other cases: Prefix do not reverse. In this case always reversing suffix. Two variants of the string with reverse suffix we can compare with O(1) with helps of z-function of the string Sr#S. Prefix reverse. To solve this case we can use approvals from the editorial of the problem F Yandex.Algorithm 2015 Round 2.2 which was written by GlebsHP and check only 2 ways of reversing prefix. We need for them to brute the reverse of suffixes. It is only need in the end to choose from 2 cases better answer. Asymptotic behavior of the solution is O(|s|).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21487",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 595\\s*A"
          },
          "content_length": 9251
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #330 (Div.1 + Div.2) Editorial - Codeforces - Code 1",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 (Div.1 + Div.2) Editorial - Codeforces - Code 2",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        vector<int> vals = inf.readInts(2 * m, 0, 1);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        vector<int> vals = inf.readInts(2 * m, 0, 1);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        vector<int> vals = inf.readInts(2 * m, 0, 1);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, m);\n\n    for (int floor = 0; floor < n; ++floor) {\n        vector<int> windows(2 * m);\n\n        if (type == \"all_on\") {\n            fill(windows.begin(), windows.end(), 1);\n        } else if (type == \"all_off\") {\n            fill(windows.begin(), windows.end(), 0);\n        } else if (type == \"random\") {\n            for (int i = 0; i < 2 * m; ++i) {\n                windows[i] = rnd.next(0, 1);\n            }\n        } else if (type == \"alternate\") {\n            for (int i = 0; i < 2 * m; ++i) {\n                windows[i] = i % 2;\n            }\n        } else if (type == \"one_flat_on\") {\n            // All flats have both windows off except one flat\n            int flat_to_light = rnd.next(0, m - 1);\n            for (int i = 0; i < m; ++i) {\n                if (i == flat_to_light) {\n                    // Ensure at least one window is lit\n                    windows[2 * i] = 0;\n                    windows[2 * i + 1] = 0;\n                    windows[2 * i + rnd.next(0,1)] = 1;\n                } else {\n                    windows[2 * i] = 0;\n                    windows[2 * i + 1] = 0;\n                }\n            }\n        } else if (type == \"one_flat_off\") {\n            // All flats have at least one window on except one flat\n            int flat_to_off = rnd.next(0, m - 1);\n            for (int i = 0; i < m; ++i) {\n                if (i == flat_to_off) {\n                    windows[2 * i] = 0;\n                    windows[2 * i + 1] = 0;\n                } else {\n                    // Ensure at least one window is lit\n                    windows[2 * i] = rnd.next(0,1);\n                    windows[2 * i + 1] = rnd.next(0,1);\n                    if (windows[2 * i] == 0 && windows[2 * i + 1] == 0) {\n                        windows[2 * i + rnd.next(0,1)] = 1;\n                    }\n                }\n            }\n        } else if (type == \"left_half_on\") {\n            for (int i = 0; i < m; ++i) {\n                if (i < m / 2) {\n                    // Ensure at least one window is lit\n                    windows[2 * i] = rnd.next(0,1);\n                    windows[2 * i + 1] = rnd.next(0,1);\n                    if (windows[2 * i] == 0 && windows[2 * i + 1] == 0) {\n                        windows[2 * i + rnd.next(0,1)] = 1;\n                    }\n                } else {\n                    windows[2 * i] = 0;\n                    windows[2 * i + 1] = 0;\n                }\n            }\n        } else if (type == \"right_half_on\") {\n            for (int i = 0; i < m; ++i) {\n                if (i >= m / 2) {\n                    // Ensure at least one window is lit\n                    windows[2 * i] = rnd.next(0,1);\n                    windows[2 * i + 1] = rnd.next(0,1);\n                    if (windows[2 * i] == 0 && windows[2 * i + 1] == 0) {\n                        windows[2 * i + rnd.next(0,1)] = 1;\n                    }\n                } else {\n                    windows[2 * i] = 0;\n                    windows[2 * i + 1] = 0;\n                }\n            }\n        } else if (type == \"checkerboard\") {\n            for (int i = 0; i < m; ++i) {\n                windows[2 * i] = ((i + floor) % 2);\n                windows[2 * i + 1] = ((i + floor + 1) % 2);\n            }\n        } else {\n            // Default to random\n            for (int i = 0; i < 2 * m; ++i) {\n                windows[i] = rnd.next(0, 1);\n            }\n        }\n\n        // Output the windows for this floor\n        for (int i = 0; i < 2 * m; ++i) {\n            printf(\"%d%c\", windows[i], (i == 2 * m - 1) ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, m);\n\n    for (int floor = 0; floor < n; ++floor) {\n        vector<int> windows(2 * m);\n\n        if (type == \"all_on\") {\n            fill(windows.begin(), windows.end(), 1);\n        } else if (type == \"all_off\") {\n            fill(windows.begin(), windows.end(), 0);\n        } else if (type == \"random\") {\n            for (int i = 0; i < 2 * m; ++i) {\n                windows[i] = rnd.next(0, 1);\n            }\n        } else if (type == \"alternate\") {\n            for (int i = 0; i < 2 * m; ++i) {\n                windows[i] = i % 2;\n            }\n        } else if (type == \"one_flat_on\") {\n            // All flats have both windows off except one flat\n            int flat_to_light = rnd.next(0, m - 1);\n            for (int i = 0; i < m; ++i) {\n                if (i == flat_to_light) {\n                    // Ensure at least one window is lit\n                    windows[2 * i] = 0;\n                    windows[2 * i + 1] = 0;\n                    windows[2 * i + rnd.next(0,1)] = 1;\n                } else {\n                    windows[2 * i] = 0;\n                    windows[2 * i + 1] = 0;\n                }\n            }\n        } else if (type == \"one_flat_off\") {\n            // All flats have at least one window on except one flat\n            int flat_to_off = rnd.next(0, m - 1);\n            for (int i = 0; i < m; ++i) {\n                if (i == flat_to_off) {\n                    windows[2 * i] = 0;\n                    windows[2 * i + 1] = 0;\n                } else {\n                    // Ensure at least one window is lit\n                    windows[2 * i] = rnd.next(0,1);\n                    windows[2 * i + 1] = rnd.next(0,1);\n                    if (windows[2 * i] == 0 && windows[2 * i + 1] == 0) {\n                        windows[2 * i + rnd.next(0,1)] = 1;\n                    }\n                }\n            }\n        } else if (type == \"left_half_on\") {\n            for (int i = 0; i < m; ++i) {\n                if (i < m / 2) {\n                    // Ensure at least one window is lit\n                    windows[2 * i] = rnd.next(0,1);\n                    windows[2 * i + 1] = rnd.next(0,1);\n                    if (windows[2 * i] == 0 && windows[2 * i + 1] == 0) {\n                        windows[2 * i + rnd.next(0,1)] = 1;\n                    }\n                } else {\n                    windows[2 * i] = 0;\n                    windows[2 * i + 1] = 0;\n                }\n            }\n        } else if (type == \"right_half_on\") {\n            for (int i = 0; i < m; ++i) {\n                if (i >= m / 2) {\n                    // Ensure at least one window is lit\n                    windows[2 * i] = rnd.next(0,1);\n                    windows[2 * i + 1] = rnd.next(0,1);\n                    if (windows[2 * i] == 0 && windows[2 * i + 1] == 0) {\n                        windows[2 * i + rnd.next(0,1)] = 1;\n                    }\n                } else {\n                    windows[2 * i] = 0;\n                    windows[2 * i + 1] = 0;\n                }\n            }\n        } else if (type == \"checkerboard\") {\n            for (int i = 0; i < m; ++i) {\n                windows[2 * i] = ((i + floor) % 2);\n                windows[2 * i + 1] = ((i + floor + 1) % 2);\n            }\n        } else {\n            // Default to random\n            for (int i = 0; i < 2 * m; ++i) {\n                windows[i] = rnd.next(0, 1);\n            }\n        }\n\n        // Output the windows for this floor\n        for (int i = 0; i < 2 * m; ++i) {\n            printf(\"%d%c\", windows[i], (i == 2 * m - 1) ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type all_on\n./gen -n 1 -m 1 -type all_off\n./gen -n 100 -m 100 -type all_on\n./gen -n 100 -m 100 -type all_off\n./gen -n 50 -m 50 -type random\n./gen -n 10 -m 10 -type checkerboard\n./gen -n 100 -m 100 -type checkerboard\n./gen -n 100 -m 100 -type one_flat_on\n./gen -n 100 -m 100 -type one_flat_off\n./gen -n 100 -m 100 -type left_half_on\n./gen -n 100 -m 100 -type right_half_on\n./gen -n 100 -m 100 -type alternate\n./gen -n 1 -m 1 -type one_flat_on\n./gen -n 1 -m 1 -type one_flat_off\n./gen -n 1 -m 100 -type one_flat_off\n./gen -n 100 -m 1 -type one_flat_on\n./gen -n 1 -m 100 -type checkerboard\n./gen -n 1 -m 100 -type all_on\n./gen -n 100 -m 1 -type all_off\n./gen -n 20 -m 30 -type random\n./gen -n 30 -m 20 -type random\n./gen -n 50 -m 50 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 1 -m 1 -type random\n./gen -n 2 -m 2 -type checkerboard\n./gen -n 3 -m 3 -type checkerboard\n./gen -n 50 -m 50 -type left_half_on\n./gen -n 50 -m 50 -type right_half_on\n./gen -n 5 -m 5 -type random\n./gen -n 10 -m 10 -type random\n./gen -n 25 -m 75 -type random\n./gen -n 75 -m 25 -type random\n./gen -n 99 -m 99 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:55:15.715822",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "595/B",
      "title": "B. Pasha and Phone",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers n and k (1 ≤ n ≤ 100 000, 1 ≤ k ≤ min(n, 9)) — the length of all phone numbers and the length of each block, respectively. It is guaranteed that n is divisible by k.The second line of the input contains n / k space-separated positive integers — sequence a1, a2, ..., an / k (1 ≤ ai < 10k).The third line of the input contains n / k space-separated positive integers — sequence b1, b2, ..., bn / k (0 ≤ bi ≤ 9).",
      "output_spec": "OutputPrint a single integer — the number of good phone numbers of length n modulo 109 + 7.",
      "sample_tests": "ExamplesInputCopy6 238 56 497 3 4OutputCopy8InputCopy8 21 22 3 445 4 3 2OutputCopy32400",
      "description": "B. Pasha and Phone\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains two integers n and k (1 ≤ n ≤ 100 000, 1 ≤ k ≤ min(n, 9)) — the length of all phone numbers and the length of each block, respectively. It is guaranteed that n is divisible by k.The second line of the input contains n / k space-separated positive integers — sequence a1, a2, ..., an / k (1 ≤ ai < 10k).The third line of the input contains n / k space-separated positive integers — sequence b1, b2, ..., bn / k (0 ≤ bi ≤ 9).\n\nOutputPrint a single integer — the number of good phone numbers of length n modulo 109 + 7.\n\nInputCopy6 238 56 497 3 4OutputCopy8InputCopy8 21 22 3 445 4 3 2OutputCopy32400\n\nInputCopy6 238 56 497 3 4\n\nOutputCopy8\n\nInputCopy8 21 22 3 445 4 3 2\n\nOutputCopy32400\n\nNoteIn the first test sample good phone numbers are: 000000, 000098, 005600, 005698, 380000, 380098, 385600, 385698.",
      "solutions": [
        {
          "title": "Codeforces Round #330 (Div.1 + Div.2) Editorial - Codeforces",
          "content": "595A — Vitaly and Night It was easy realization problem. Let's increase the variable i from 1 to n, and inside let's increase the variable j from 1 to 2·m. On every iteration we will increase the variable j on 2. If on current iteration a[i][j] = '1' or a[i][j + 1] = '1' let's increase the answer on one. Asymptotic behavior of this solution — O(nm). 595B — Pasha and Phone Let's calculate the answer to every block separately from each other and multiply the answer to the previous blocks to the answer for current block.For the block with length equals to k we can calculate the answer in the following way. Let for this block the number must be divided on x and must not starts with digit y. Then the answer for this block — the number of numbers containing exactly k digits and which divisible by x, subtract the number of numbers which have the first digit equals to y and containing exactly k digits and plus the number of numbers which have the first digit equals to y - 1 (only if y > 0) and containing exactly k digits.Asymptotic behavior of this solution — O(n / k). 594A — Warrior and Archer Let's sort the points by increasing x coordinate and work with sorted points array next.Let's suppose that after optimal playing points numbered l and r (l < r) are left. It's true that the first player didn't ban any of the points numbered i l < i < r, otherwise he could change his corresponding move to point l or point r (one could prove it doesn't depend on second player optimal moves) and change the optimal answer. It turns out that all the points banned by the first player have numbers outside of [l, r] segment, therefore . We should notice that if the first player choosed any [l, r] for , he could always make the final points numbers located inside this segment.The second player wants to make (he couldn't make less), what is equivalent if he always ban points inside final [l, r] segment (numbered l < i < r). As soon as the second player doesn't know what segment first player have chosen after every of his moves, he must detect a point which satisfies him in every first player choice. It's true number of this point is the median of set of point numbers left (the odd number) after the first player move. The number of moves of the first player left is lesser by one than moves of the second player, so the first player later could ban some points from the left and some points from the right, except three middle points. Two of it (leftmost and rightmost ones) shouldn't be banned by the second player as soon as it could increase the size of banned points from the left (or from the right), but third middle point satisfies the second player in every first player choice. This way the second player always bans the point inside final point segment.Thus the answer is the minimum between every of values.594B — Max and Bike The main proposition to solve this problem — in the middle of every competition the sensor must be or in the top point of the wheel or in the bottom point of the wheel.To calculate the answer we need to use binary search. If the center of the wheel moved on the distance c, then the sensor moved on the distance c + rsin(c / r), if the sensor was on the top point of the wheel in the middle, or on the distance c - rsin(c / r), if the sensor was on the bottom point of the wheel in the middle, where r — the radius of the wheel. Asymptotic behavior of this solution — . 594С — Edo and Magnets Let's find the centers of every rectangle and multiple them of 2 (to make all coordinates integers).Then we need to by the rectangle door, which contains all dots, but the lengths of the sides of this door must be rounded up to the nearest integers. Now, let's delete the magnets from the door one by one, gradually the door will decrease. Obviously every time optimal to delete only dots, which owned to the sides of the rectangle. Let's brute 4k ways, how we will do delete the magnets. We will do it with helps of recursion, every time we will delete point with minimum or maximum value of the coordinates. If we will store 4 arrays (or 2 deques) we can do it with asymptotic O(1). Such a solution works O(4k). It can be easily shown that this algorithm delete always some number of the leftmost, rightmost, uppermost and lowermost points. So we can brute how k will distributed between this values and we can model the deleting with helps of 4 arrays. This solution has asymptotic behavior O(k4). 594D — REQ To calculate the answer on every query let's use the formula , where p1, p2, ..., pk — all prime numbers which divided n. We make all calculations by the module 109 + 7 Let's suppose that we solving problem for fix left end l of the range. Every query now is a query on the prefix of the array. Then in formula for every prime p we need to know only about the leftmost position of it. Let's convert the query in the query of the multiple on the prefix: at first init Fenwick tree with ones, then make the multiplication in points l, l + 1, ..., n with value of the elements al, al + 1, ..., an. For every leftmost positions of prime p make in position i the multiplication in point i on the . This prepare can be done with asymptotic , where C — the maximum value of the element (this logarithm — the number of prime divisors of some ai). We interest in all leftmost ends, because of that let's know how to go from the one end to the other. Let we know all about the end l — how to update the end l + 1? Let's make the multiplication in the Fenwick tree in the point l on the value al - 1. Also we are not interesting in all prime numbers inside al, so let's make the multiplications in point l on the all values . But every of this prime numbers can have other entries which now becoming the leftmost. Add them with the multiplication which described above. With helps of sort the transition between leftmost ends can be done in . To answer to the queries we need to sort them in correct order (or add them in the dynamic array), and to the get the answer to the query we will make iterations. So total asymptotic behavior of solution is iterations and additional memory. 594E — Cutting the Line Let's describe the greedy algorithm, which allows to solve the problem for every k > 2 for every string S.Let's think, that we always reverse some prefix of the string S (may be with length equals to one). Because we want to minimize lexicographically the string it is easy to confirm that we will reverse such a prefixes, which prefix (after reversing) is equals to the minimal lexicographically suffix of the reverse string S (let it be Sr) — this is prefix, which length equals to the length of the minimum suffix Sr (the reverse operation of the prefix S equals to change it with suffix Sr).Let the lexicographically minimal suffix of the string Sr is s. It can be shown, that there are no 2 entries s in Sr which intersects, because of that the string s will be with period and minimal suffix will with less length. So, the string Sr looks like tpsaptp - 1sap - 1tp - 2... t1sa1, where sx means the concatenation of the string s x times, a1, a2, ..., ap — integers, and the strings t1, t2, ..., tp — some non-empty (exclude may be tp) strings, which do not contain the s inside.If we reverse some needed prefix of the string s, we will go to the string S', and the minimal suffix s' of the reversing string S'r can't be lexicographically less than s, because of that we need to make s' equals to s. It will helps us to increase prefix which look like sb in the answer (and we will can minimize it too). it is easy to show, that maximum b, which we can get equals to a1 in case p = 1 и (in case if p \\geq 2$). After such operations the prefix of the answer will looks like sa1saitisai - 1... sa2t2. Because t_{i} — non-empty strings we can not to increase the number of concatenations s in the prefix of the answer. The reversing of the second prefix (sai...) can be done because k > 2.From the information described above we know that if k > 2 for lost string we need always reverse prefix, which after reversing is equals to the suffix of the string Sr which looks like sa1. To find this suffix every time, we need only once to build Lindon decomposition (with helps of Duval's algorithm) of the reverse string and carefully unite the equals strings. Only one case is lost — prefix of the lost string does not need to be reverse — we can make the concatenation of the consecutive reverse prefixes with length equals to 1.Because for k = 1 the problem is very easy, we need to solve it for k = 2 — cut the string on the two pieces (prefix and suffix) and some way of their reverse. The case when nothing reverse is not interesting, let's look on other cases: Prefix do not reverse. In this case always reversing suffix. Two variants of the string with reverse suffix we can compare with O(1) with helps of z-function of the string Sr#S. Prefix reverse. To solve this case we can use approvals from the editorial of the problem F Yandex.Algorithm 2015 Round 2.2 which was written by GlebsHP and check only 2 ways of reversing prefix. We need for them to brute the reverse of suffixes. It is only need in the end to choose from 2 cases better answer. Asymptotic behavior of the solution is O(|s|).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/21487",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 595\\s*B"
          },
          "content_length": 9251
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #330 (Div.1 + Div.2) Editorial - Codeforces - Code 1",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #330 (Div.1 + Div.2) Editorial - Codeforces - Code 2",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint power10(int k) {\n    int res = 1;\n    for (int i = 0; i < k; ++i) {\n        res *= 10;\n    }\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, min(n, 9), \"k\");\n    inf.readEoln();\n    \n    ensuref(n % k == 0, \"n must be divisible by k\");\n    \n    int num_blocks = n / k;\n    int max_ai = power10(k) - 1;  // 10^k - 1\n    vector<int> a = inf.readInts(num_blocks, 1, max_ai, \"a_i\");\n    inf.readEoln();\n    \n    vector<int> b = inf.readInts(num_blocks, 0, 9, \"b_i\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint power10(int k) {\n    int res = 1;\n    for (int i = 0; i < k; ++i) {\n        res *= 10;\n    }\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, min(n, 9), \"k\");\n    inf.readEoln();\n    \n    ensuref(n % k == 0, \"n must be divisible by k\");\n    \n    int num_blocks = n / k;\n    int max_ai = power10(k) - 1;  // 10^k - 1\n    vector<int> a = inf.readInts(num_blocks, 1, max_ai, \"a_i\");\n    inf.readEoln();\n    \n    vector<int> b = inf.readInts(num_blocks, 0, 9, \"b_i\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint power10(int k) {\n    int res = 1;\n    for (int i = 0; i < k; ++i) {\n        res *= 10;\n    }\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, min(n, 9), \"k\");\n    inf.readEoln();\n    \n    ensuref(n % k == 0, \"n must be divisible by k\");\n    \n    int num_blocks = n / k;\n    int max_ai = power10(k) - 1;  // 10^k - 1\n    vector<int> a = inf.readInts(num_blocks, 1, max_ai, \"a_i\");\n    inf.readEoln();\n    \n    vector<int> b = inf.readInts(num_blocks, 0, 9, \"b_i\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string b_type = opt<string>(\"b_type\", \"random\");\n    int a_value = opt<int>(\"a_value\", 1);\n    int b_value = opt<int>(\"b_value\", 0);\n\n    // Adjust n and k to fit the constraints\n    n = min(max(1, n), 100000);\n    k = min(max(1, k), min(n, 9));\n\n    // Ensure that n is divisible by k\n    if (n % k != 0) {\n        n -= n % k;\n    }\n\n    int m = n / k; // Number of blocks\n\n    vector<int> a(m);\n    vector<int> b(m);\n\n    int max_a = pow(10, k) - 1;\n\n    // Generate ai's\n    if (a_type == \"const\") {\n        int val = min(max(1, a_value), max_a);\n        for (int i = 0; i < m; ++i) {\n            a[i] = val;\n        }\n    } else if (a_type == \"min\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = 1;\n        }\n    } else if (a_type == \"max\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = max_a;\n        }\n    } else if (a_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    } else if (a_type == \"increasing\") {\n        int val = 1;\n        int step = max(1, (max_a - 1) / m);\n        for (int i = 0; i < m; ++i) {\n            a[i] = val;\n            val = min(val + step, max_a);\n        }\n    } else if (a_type == \"decreasing\") {\n        int val = max_a;\n        int step = max(1, (max_a - 1) / m);\n        for (int i = 0; i < m; ++i) {\n            a[i] = val;\n            val = max(val - step, 1);\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    }\n\n    // Generate bi's\n    if (b_type == \"const\") {\n        int val = min(max(0, b_value), 9);\n        for (int i = 0; i < m; ++i) {\n            b[i] = val;\n        }\n    } else if (b_type == \"min\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = 0;\n        }\n    } else if (b_type == \"max\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = 9;\n        }\n    } else if (b_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(0, 9);\n        }\n    } else if (b_type == \"increasing\") {\n        int val = 0;\n        for (int i = 0; i < m; ++i) {\n            b[i] = val % 10;\n            val++;\n        }\n    } else if (b_type == \"decreasing\") {\n        int val = 9;\n        for (int i = 0; i < m; ++i) {\n            b[i] = val % 10;\n            val--;\n            if (val < 0) val = 9;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(0,9);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output ai's\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < m) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Output bi's\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", b[i]);\n        if (i + 1 < m) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string b_type = opt<string>(\"b_type\", \"random\");\n    int a_value = opt<int>(\"a_value\", 1);\n    int b_value = opt<int>(\"b_value\", 0);\n\n    // Adjust n and k to fit the constraints\n    n = min(max(1, n), 100000);\n    k = min(max(1, k), min(n, 9));\n\n    // Ensure that n is divisible by k\n    if (n % k != 0) {\n        n -= n % k;\n    }\n\n    int m = n / k; // Number of blocks\n\n    vector<int> a(m);\n    vector<int> b(m);\n\n    int max_a = pow(10, k) - 1;\n\n    // Generate ai's\n    if (a_type == \"const\") {\n        int val = min(max(1, a_value), max_a);\n        for (int i = 0; i < m; ++i) {\n            a[i] = val;\n        }\n    } else if (a_type == \"min\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = 1;\n        }\n    } else if (a_type == \"max\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = max_a;\n        }\n    } else if (a_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    } else if (a_type == \"increasing\") {\n        int val = 1;\n        int step = max(1, (max_a - 1) / m);\n        for (int i = 0; i < m; ++i) {\n            a[i] = val;\n            val = min(val + step, max_a);\n        }\n    } else if (a_type == \"decreasing\") {\n        int val = max_a;\n        int step = max(1, (max_a - 1) / m);\n        for (int i = 0; i < m; ++i) {\n            a[i] = val;\n            val = max(val - step, 1);\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    }\n\n    // Generate bi's\n    if (b_type == \"const\") {\n        int val = min(max(0, b_value), 9);\n        for (int i = 0; i < m; ++i) {\n            b[i] = val;\n        }\n    } else if (b_type == \"min\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = 0;\n        }\n    } else if (b_type == \"max\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = 9;\n        }\n    } else if (b_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(0, 9);\n        }\n    } else if (b_type == \"increasing\") {\n        int val = 0;\n        for (int i = 0; i < m; ++i) {\n            b[i] = val % 10;\n            val++;\n        }\n    } else if (b_type == \"decreasing\") {\n        int val = 9;\n        for (int i = 0; i < m; ++i) {\n            b[i] = val % 10;\n            val--;\n            if (val < 0) val = 9;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(0,9);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Output ai's\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < m) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Output bi's\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", b[i]);\n        if (i + 1 < m) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -a_type const -a_value 1 -b_type const -b_value 0\n./gen -n 10 -k 1 -a_type const -a_value 1 -b_type const -b_value 0\n./gen -n 10 -k 2 -a_type random -b_type random\n./gen -n 20 -k 5 -a_type min -b_type max\n./gen -n 30 -k 3 -a_type max -b_type min\n./gen -n 40 -k 4 -a_type const -a_value 9999 -b_type const -b_value 9\n./gen -n 50 -k 5 -a_type increasing -b_type decreasing\n./gen -n 60 -k 6 -a_type decreasing -b_type increasing\n./gen -n 70 -k 7 -a_type random -b_type random\n./gen -n 80 -k 8 -a_type const -a_value 1 -b_type random\n./gen -n 90 -k 9 -a_type random -b_type const -b_value 0\n./gen -n 100000 -k 1 -a_type const -a_value 1 -b_type const -b_value 0\n./gen -n 100000 -k 9 -a_type random -b_type random\n./gen -n 99999 -k 9 -a_type const -a_value 1 -b_type const -b_value 9\n./gen -n 100000 -k 5 -a_type max -b_type max\n./gen -n 100000 -k 1 -a_type min -b_type min\n./gen -n 100000 -k 2 -a_type random -b_type random\n./gen -n 99998 -k 2 -a_type increasing -b_type decreasing\n./gen -n 99996 -k 4 -a_type decreasing -b_type increasing\n./gen -n 100000 -k 5 -a_type random -b_type increasing\n./gen -n 100000 -k 5 -a_type random -b_type decreasing\n./gen -n 100000 -k 3 -a_type const -a_value 10 -b_type const -b_value 5\n./gen -n 100000 -k 8 -a_type const -a_value 1 -b_type random\n./gen -n 100000 -k 9 -a_type const -a_value 999999999 -b_type const -b_value 0\n./gen -n 100000 -k 9 -a_type random -b_type const -b_value 9\n./gen -n 99999 -k 3 -a_type const -a_value 1 -b_type increasing\n./gen -n 99999 -k 3 -a_type const -a_value 999 -b_type decreasing\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:55:17.358499",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "595/C",
      "title": "C. Warrior and Archer",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line on the input contains a single integer n (2 ≤ n ≤ 200 000, n is even) — the number of positions available initially. The second line contains n distinct integers x1, x2, ..., xn (0 ≤ xi ≤ 109), giving the coordinates of the corresponding positions.",
      "output_spec": "OutputPrint the distance between the warrior and the archer at the beginning of the fight, provided that both Vova and Lesha play optimally.",
      "sample_tests": "ExamplesInputCopy60 1 3 7 15 31OutputCopy7InputCopy273 37OutputCopy36",
      "description": "C. Warrior and Archer\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line on the input contains a single integer n (2 ≤ n ≤ 200 000, n is even) — the number of positions available initially. The second line contains n distinct integers x1, x2, ..., xn (0 ≤ xi ≤ 109), giving the coordinates of the corresponding positions.\n\nOutputPrint the distance between the warrior and the archer at the beginning of the fight, provided that both Vova and Lesha play optimally.\n\nInputCopy60 1 3 7 15 31OutputCopy7InputCopy273 37OutputCopy36\n\nInputCopy60 1 3 7 15 31\n\nOutputCopy7\n\nInputCopy273 37\n\nOutputCopy36\n\nNoteIn the first sample one of the optimum behavior of the players looks like that:  Vova bans the position at coordinate 15;  Lesha bans the position at coordinate 3;  Vova bans the position at coordinate 31;  Lesha bans the position at coordinate 1. After these actions only positions 0 and 7 will remain, and the distance between them is equal to 7.In the second sample there are only two possible positions, so there will be no bans.",
      "solutions": [
        {
          "title": "Codeforces Round #330 (Div.1 + Div.2) Editorial - Codeforces",
          "content": "595A — Vitaly and Night It was easy realization problem. Let's increase the variable i from 1 to n, and inside let's increase the variable j from 1 to 2·m. On every iteration we will increase the variable j on 2. If on current iteration a[i][j] = '1' or a[i][j + 1] = '1' let's increase the answer on one. Asymptotic behavior of this solution — O(nm). 595B — Pasha and Phone Let's calculate the answer to every block separately from each other and multiply the answer to the previous blocks to the answer for current block.For the block with length equals to k we can calculate the answer in the following way. Let for this block the number must be divided on x and must not starts with digit y. Then the answer for this block — the number of numbers containing exactly k digits and which divisible by x, subtract the number of numbers which have the first digit equals to y and containing exactly k digits and plus the number of numbers which have the first digit equals to y - 1 (only if y > 0) and containing exactly k digits.Asymptotic behavior of this solution — O(n / k). 594A — Warrior and Archer Let's sort the points by increasing x coordinate and work with sorted points array next.Let's suppose that after optimal playing points numbered l and r (l < r) are left. It's true that the first player didn't ban any of the points numbered i l < i < r, otherwise he could change his corresponding move to point l or point r (one could prove it doesn't depend on second player optimal moves) and change the optimal answer. It turns out that all the points banned by the first player have numbers outside of [l, r] segment, therefore . We should notice that if the first player choosed any [l, r] for , he could always make the final points numbers located inside this segment.The second player wants to make (he couldn't make less), what is equivalent if he always ban points inside final [l, r] segment (numbered l < i < r). As soon as the second player doesn't know what segment first player have chosen after every of his moves, he must detect a point which satisfies him in every first player choice. It's true number of this point is the median of set of point numbers left (the odd number) after the first player move. The number of moves of the first player left is lesser by one than moves of the second player, so the first player later could ban some points from the left and some points from the right, except three middle points. Two of it (leftmost and rightmost ones) shouldn't be banned by the second player as soon as it could increase the size of banned points from the left (or from the right), but third middle point satisfies the second player in every first player choice. This way the second player always bans the point inside final point segment.Thus the answer is the minimum between every of values.594B — Max and Bike The main proposition to solve this problem — in the middle of every competition the sensor must be or in the top point of the wheel or in the bottom point of the wheel.To calculate the answer we need to use binary search. If the center of the wheel moved on the distance c, then the sensor moved on the distance c + rsin(c / r), if the sensor was on the top point of the wheel in the middle, or on the distance c - rsin(c / r), if the sensor was on the bottom point of the wheel in the middle, where r — the radius of the wheel. Asymptotic behavior of this solution — . 594С — Edo and Magnets Let's find the centers of every rectangle and multiple them of 2 (to make all coordinates integers).Then we need to by the rectangle door, which contains all dots, but the lengths of the sides of this door must be rounded up to the nearest integers. Now, let's delete the magnets from the door one by one, gradually the door will decrease. Obviously every time optimal to delete only dots, which owned to the sides of the rectangle. Let's brute 4k ways, how we will do delete the magnets. We will do it with helps of recursion, every time we will delete point with minimum or maximum value of the coordinates. If we will store 4 arrays (or 2 deques) we can do it with asymptotic O(1). Such a solution works O(4k). It can be easily shown that this algorithm delete always some number of the leftmost, rightmost, uppermost and lowermost points. So we can brute how k will distributed between this values and we can model the deleting with helps of 4 arrays. This solution has asymptotic behavior O(k4). 594D — REQ To calculate the answer on every query let's use the formula , where p1, p2, ..., pk — all prime numbers which divided n. We make all calculations by the module 109 + 7 Let's suppose that we solving problem for fix left end l of the range. Every query now is a query on the prefix of the array. Then in formula for every prime p we need to know only about the leftmost position of it. Let's convert the query in the query of the multiple on the prefix: at first init Fenwick tree with ones, then make the multiplication in points l, l + 1, ..., n with value of the elements al, al + 1, ..., an. For every leftmost positions of prime p make in position i the multiplication in point i on the . This prepare can be done with asymptotic , where C — the maximum value of the element (this logarithm — the number of prime divisors of some ai). We interest in all leftmost ends, because of that let's know how to go from the one end to the other. Let we know all about the end l — how to update the end l + 1? Let's make the multiplication in the Fenwick tree in the point l on the value al - 1. Also we are not interesting in all prime numbers inside al, so let's make the multiplications in point l on the all values . But every of this prime numbers can have other entries which now becoming the leftmost. Add them with the multiplication which described above. With helps of sort the transition between leftmost ends can be done in . To answer to the queries we need to sort them in correct order (or add them in the dynamic array), and to the get the answer to the query we will make iterations. So total asymptotic behavior of solution is iterations and additional memory. 594E — Cutting the Line Let's describe the greedy algorithm, which allows to solve the problem for every k > 2 for every string S.Let's think, that we always reverse some prefix of the string S (may be with length equals to one). Because we want to minimize lexicographically the string it is easy to confirm that we will reverse such a prefixes, which prefix (after reversing) is equals to the minimal lexicographically suffix of the reverse string S (let it be Sr) — this is prefix, which length equals to the length of the minimum suffix Sr (the reverse operation of the prefix S equals to change it with suffix Sr).Let the lexicographically minimal suffix of the string Sr is s. It can be shown, that there are no 2 entries s in Sr which intersects, because of that the string s will be with period and minimal suffix will with less length. So, the string Sr looks like tpsaptp - 1sap - 1tp - 2... t1sa1, where sx means the concatenation of the string s x times, a1, a2, ..., ap — integers, and the strings t1, t2, ..., tp — some non-empty (exclude may be tp) strings, which do not contain the s inside.If we reverse some needed prefix of the string s, we will go to the string S', and the minimal suffix s' of the reversing string S'r can't be lexicographically less than s, because of that we need to make s' equals to s. It will helps us to increase prefix which look like sb in the answer (and we will can minimize it too). it is easy to show, that maximum b, which we can get equals to a1 in case p = 1 и (in case if p \\geq 2$). After such operations the prefix of the answer will looks like sa1saitisai - 1... sa2t2. Because t_{i} — non-empty strings we can not to increase the number of concatenations s in the prefix of the answer. The reversing of the second prefix (sai...) can be done because k > 2.From the information described above we know that if k > 2 for lost string we need always reverse prefix, which after reversing is equals to the suffix of the string Sr which looks like sa1. To find this suffix every time, we need only once to build Lindon decomposition (with helps of Duval's algorithm) of the reverse string and carefully unite the equals strings. Only one case is lost — prefix of the lost string does not need to be reverse — we can make the concatenation of the consecutive reverse prefixes with length equals to 1.Because for k = 1 the problem is very easy, we need to solve it for k = 2 — cut the string on the two pieces (prefix and suffix) and some way of their reverse. The case when nothing reverse is not interesting, let's look on other cases: Prefix do not reverse. In this case always reversing suffix. Two variants of the string with reverse suffix we can compare with O(1) with helps of z-function of the string Sr#S. Prefix reverse. To solve this case we can use approvals from the editorial of the problem F Yandex.Algorithm 2015 Round 2.2 which was written by GlebsHP and check only 2 ways of reversing prefix. We need for them to brute the reverse of suffixes. It is only need in the end to choose from 2 cases better answer. Asymptotic behavior of the solution is O(|s|).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/21487",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 595 和字母"
          },
          "content_length": 9251
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #330 (Div.1 + Div.2) Editorial - Codeforces - Code 1",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #330 (Div.1 + Div.2) Editorial - Codeforces - Code 2",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 200000, \"n\");\n    ensuref(n % 2 == 0, \"n must be even, but n == %d\", n);\n    inf.readEoln();\n    \n    vector<int> x = inf.readInts(n, 0, 1000000000, \"x_i\");\n    inf.readEoln();\n    \n    unordered_set<int> s(x.begin(), x.end());\n    ensuref(int(s.size()) == n, \"All x_i must be distinct, but found %d distinct values out of %d\", int(s.size()), n);\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 200000, \"n\");\n    ensuref(n % 2 == 0, \"n must be even, but n == %d\", n);\n    inf.readEoln();\n    \n    vector<int> x = inf.readInts(n, 0, 1000000000, \"x_i\");\n    inf.readEoln();\n    \n    unordered_set<int> s(x.begin(), x.end());\n    ensuref(int(s.size()) == n, \"All x_i must be distinct, but found %d distinct values out of %d\", int(s.size()), n);\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 200000, \"n\");\n    ensuref(n % 2 == 0, \"n must be even, but n == %d\", n);\n    inf.readEoln();\n    \n    vector<int> x = inf.readInts(n, 0, 1000000000, \"x_i\");\n    inf.readEoln();\n    \n    unordered_set<int> s(x.begin(), x.end());\n    ensuref(int(s.size()) == n, \"All x_i must be distinct, but found %d distinct values out of %d\", int(s.size()), n);\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n % 2 != 0) {\n        fprintf(stderr, \"Error: n must be even.\\n\");\n        return 1;\n    }\n\n    vector<int> positions;\n\n    if (type == \"small_random\") {\n        /* Generate small random positions */\n        n = min(n, 10);\n        for (int i = 0; i < n; ++i) {\n            positions.push_back(rnd.next(0, 100));\n        }\n    } else if (type == \"large_random\") {\n        /* Generate large random positions */\n        n = max(n, 200000);\n        for (int i = 0; i < n; ++i) {\n            positions.push_back(rnd.next(0, int(1e9)));\n        }\n    } else if (type == \"clustered\") {\n        /* Generate positions clustered around a point */\n        int center = rnd.next(int(1e8), int(9e8));\n        int spread = opt<int>(\"spread\", 10);\n        for (int i = 0; i < n; ++i) {\n            positions.push_back(center + rnd.next(-spread, spread) + i);\n        }\n    } else if (type == \"spread\") {\n        /* Generate positions spread across the range [0, 1e9] */\n        int min_step = max(1, int(1e9 / n));\n        for (int i = 0; i < n; ++i) {\n            int pos = rnd.next(i * min_step, min(int(1e9) - 1, (i + 1) * min_step - 1));\n            positions.push_back(pos);\n        }\n    } else if (type == \"ascending\") {\n        /* Generate positions in ascending order */\n        int current = 0;\n        int max_step = max(1, int(1e9 / n));\n        for (int i = 0; i < n; ++i) {\n            current += rnd.next(1, max_step);\n            positions.push_back(current);\n        }\n    } else if (type == \"descending\") {\n        /* Generate positions in descending order */\n        int current = int(1e9);\n        int max_step = max(1, int(1e9 / n));\n        for (int i = 0; i < n; ++i) {\n            current -= rnd.next(1, max_step);\n            positions.push_back(current);\n        }\n    } else if (type == \"min_positions\") {\n        /* Generate positions close to 0 */\n        for (int i = 0; i < n; ++i) {\n            positions.push_back(i);\n        }\n    } else if (type == \"max_positions\") {\n        /* Generate positions close to 1e9 */\n        int base = int(1e9) - n - 1;\n        for (int i = 0; i < n; ++i) {\n            positions.push_back(base + i);\n        }\n    } else if (type == \"extremes\") {\n        /* Positions are either very low or very high */\n        for (int i = 0; i < n / 2; ++i) {\n            positions.push_back(i); // positions close to 0\n            positions.push_back(int(1e9) - i); // positions close to 1e9\n        }\n    } else if (type == \"alternating\") {\n        /* Positions alternate between low and high values */\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                positions.push_back(rnd.next(0, int(1e5)) + i);\n            else\n                positions.push_back(rnd.next(int(1e9) - int(1e5), int(1e9)) - i);\n        }\n    } else if (type == \"constant_positions\") {\n        /* Positions are very close to each other */\n        int base = rnd.next(0, int(1e9 - n - 1));\n        for (int i = 0; i < n; ++i) {\n            positions.push_back(base + i);\n        }\n    } else if (type == \"arithmetic_progression\") {\n        /* Positions in arithmetic progression */\n        int start = rnd.next(0, int(1e9 / 2));\n        int diff = rnd.next(1, max(1, int(1e9 / n)));\n        for (int i = 0; i < n; ++i) {\n            positions.push_back(start + i * diff);\n        }\n    } else {\n        /* Default random positions */\n        for (int i = 0; i < n; ++i) {\n            positions.push_back(rnd.next(0, int(1e9)));\n        }\n    }\n\n    /* Ensure positions are distinct and within [0, 1e9] */\n    set<int> posSet(positions.begin(), positions.end());\n    while ((int)posSet.size() < n) {\n        int newPos = rnd.next(0, int(1e9));\n        if (!posSet.count(newPos)) {\n            posSet.insert(newPos);\n        }\n    }\n    positions.assign(posSet.begin(), posSet.end());\n\n    /* Shuffle positions */\n    shuffle(positions.begin(), positions.end());\n\n    /* Output the test case */\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", positions[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n % 2 != 0) {\n        fprintf(stderr, \"Error: n must be even.\\n\");\n        return 1;\n    }\n\n    vector<int> positions;\n\n    if (type == \"small_random\") {\n        /* Generate small random positions */\n        n = min(n, 10);\n        for (int i = 0; i < n; ++i) {\n            positions.push_back(rnd.next(0, 100));\n        }\n    } else if (type == \"large_random\") {\n        /* Generate large random positions */\n        n = max(n, 200000);\n        for (int i = 0; i < n; ++i) {\n            positions.push_back(rnd.next(0, int(1e9)));\n        }\n    } else if (type == \"clustered\") {\n        /* Generate positions clustered around a point */\n        int center = rnd.next(int(1e8), int(9e8));\n        int spread = opt<int>(\"spread\", 10);\n        for (int i = 0; i < n; ++i) {\n            positions.push_back(center + rnd.next(-spread, spread) + i);\n        }\n    } else if (type == \"spread\") {\n        /* Generate positions spread across the range [0, 1e9] */\n        int min_step = max(1, int(1e9 / n));\n        for (int i = 0; i < n; ++i) {\n            int pos = rnd.next(i * min_step, min(int(1e9) - 1, (i + 1) * min_step - 1));\n            positions.push_back(pos);\n        }\n    } else if (type == \"ascending\") {\n        /* Generate positions in ascending order */\n        int current = 0;\n        int max_step = max(1, int(1e9 / n));\n        for (int i = 0; i < n; ++i) {\n            current += rnd.next(1, max_step);\n            positions.push_back(current);\n        }\n    } else if (type == \"descending\") {\n        /* Generate positions in descending order */\n        int current = int(1e9);\n        int max_step = max(1, int(1e9 / n));\n        for (int i = 0; i < n; ++i) {\n            current -= rnd.next(1, max_step);\n            positions.push_back(current);\n        }\n    } else if (type == \"min_positions\") {\n        /* Generate positions close to 0 */\n        for (int i = 0; i < n; ++i) {\n            positions.push_back(i);\n        }\n    } else if (type == \"max_positions\") {\n        /* Generate positions close to 1e9 */\n        int base = int(1e9) - n - 1;\n        for (int i = 0; i < n; ++i) {\n            positions.push_back(base + i);\n        }\n    } else if (type == \"extremes\") {\n        /* Positions are either very low or very high */\n        for (int i = 0; i < n / 2; ++i) {\n            positions.push_back(i); // positions close to 0\n            positions.push_back(int(1e9) - i); // positions close to 1e9\n        }\n    } else if (type == \"alternating\") {\n        /* Positions alternate between low and high values */\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                positions.push_back(rnd.next(0, int(1e5)) + i);\n            else\n                positions.push_back(rnd.next(int(1e9) - int(1e5), int(1e9)) - i);\n        }\n    } else if (type == \"constant_positions\") {\n        /* Positions are very close to each other */\n        int base = rnd.next(0, int(1e9 - n - 1));\n        for (int i = 0; i < n; ++i) {\n            positions.push_back(base + i);\n        }\n    } else if (type == \"arithmetic_progression\") {\n        /* Positions in arithmetic progression */\n        int start = rnd.next(0, int(1e9 / 2));\n        int diff = rnd.next(1, max(1, int(1e9 / n)));\n        for (int i = 0; i < n; ++i) {\n            positions.push_back(start + i * diff);\n        }\n    } else {\n        /* Default random positions */\n        for (int i = 0; i < n; ++i) {\n            positions.push_back(rnd.next(0, int(1e9)));\n        }\n    }\n\n    /* Ensure positions are distinct and within [0, 1e9] */\n    set<int> posSet(positions.begin(), positions.end());\n    while ((int)posSet.size() < n) {\n        int newPos = rnd.next(0, int(1e9));\n        if (!posSet.count(newPos)) {\n            posSet.insert(newPos);\n        }\n    }\n    positions.assign(posSet.begin(), posSet.end());\n\n    /* Shuffle positions */\n    shuffle(positions.begin(), positions.end());\n\n    /* Output the test case */\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", positions[i], i + 1 == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type small_random\n./gen -n 4 -type small_random\n./gen -n 6 -type small_random\n\n./gen -n 10 -type small_random\n./gen -n 100 -type small_random\n\n./gen -n 2 -type min_positions\n./gen -n 4 -type min_positions\n\n./gen -n 6 -type max_positions\n./gen -n 100 -type max_positions\n\n./gen -n 200000 -type large_random\n\n./gen -n 200000 -type clustered -spread 0\n./gen -n 200000 -type clustered -spread 1\n./gen -n 200000 -type clustered -spread 1000\n\n./gen -n 200000 -type spread\n\n./gen -n 200000 -type ascending\n./gen -n 200000 -type descending\n\n./gen -n 200000 -type min_positions\n./gen -n 200000 -type max_positions\n\n./gen -n 200000 -type extremes\n\n./gen -n 200000 -type alternating\n\n./gen -n 200000 -type constant_positions\n\n./gen -n 2 -type extremes\n\n./gen -n 4 -type min_positions\n\n./gen -n 4 -type max_positions\n\n./gen -n 6 -type constant_positions\n\n./gen -n 10 -type arithmetic_progression\n\n./gen -n 100000 -type arithmetic_progression\n\n./gen -n 200000 -type arithmetic_progression\n\n./gen -n 199998 -type spread\n\n./gen -n 200000 -type random\n\n./gen -n 2 -type random\n\n./gen -n 200000 -type small_random\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:55:19.473183",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "595/D",
      "title": "D. Максим и велосипед",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано три целых числа n, r и v (1 ≤ n ≤ 100 000, 1 ≤ r, v ≤ 109) — количество соревнований, радиус переднего колеса велосипеда Максима и максимальная скорость, которую он может развить, соответственно. В следующих n строках содержатся описания соревнований. В i-й строке содержится два целых числа si и fi (1 ≤ si < fi ≤ 109) — координата старта и координата финиша i-го соревнования соответственно.",
      "output_spec": "Выходные данныеВыведите n вещественных чисел, i-е число должно равняться минимальному времени, за которое Максим сможет проехать дистанцию i-го соревнования. Ваш ответ будет считаться правильным, если его абсолютная или относительная ошибка не будет превосходить 10 - 6. А именно: пусть ваш ответ равен a, а ответ жюри — b. Проверяющая программа будет считать ваш ответ правильным, если .",
      "sample_tests": "ПримерыВходные данныеСкопировать2 1 21 105 9Выходные данныеСкопировать3.8496447105021.106060157705",
      "description": "D. Максим и велосипед\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке задано три целых числа n, r и v (1 ≤ n ≤ 100 000, 1 ≤ r, v ≤ 109) — количество соревнований, радиус переднего колеса велосипеда Максима и максимальная скорость, которую он может развить, соответственно. В следующих n строках содержатся описания соревнований. В i-й строке содержится два целых числа si и fi (1 ≤ si < fi ≤ 109) — координата старта и координата финиша i-го соревнования соответственно.\n\nВходные данные\n\nВыходные данныеВыведите n вещественных чисел, i-е число должно равняться минимальному времени, за которое Максим сможет проехать дистанцию i-го соревнования. Ваш ответ будет считаться правильным, если его абсолютная или относительная ошибка не будет превосходить 10 - 6. А именно: пусть ваш ответ равен a, а ответ жюри — b. Проверяющая программа будет считать ваш ответ правильным, если .\n\nВыходные данные\n\nВходные данныеСкопировать2 1 21 105 9Выходные данныеСкопировать3.8496447105021.106060157705\n\nВходные данныеСкопировать2 1 21 105 9\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3.8496447105021.106060157705\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces",
          "content": "595A — Виталий и ночь Простая задача на реализацию. Проитерируемся по i от 1 до n, а внутри проитерируемся по j от 1 до 2·m, причем на каждой итерации будем увеличивать j на два. Если на текущей итерации a[i][j] = '1' или a[i][j + 1] = '1' увеличим ответ на один. Асимптотика решения — O(nm). 595B — Паша и телефон Будем считать ответ для каждого блока отдельно и умножать ответ для предыдущих блоков на ответ для текущего блока, при этом не забывая брать результат перемножения по модулю. Для блока длины k ответ считается следующим образом. Пусть для этого блока число должно делиться на x и не должно начинаться с цифры y. Тогда ответ для этого блока — количество чисел из k цифр, делящихся на x, минус количество чисел, начинающихся с цифры y и состоящих из k цифр, плюс количество чисел, начинающихся с цифры y - 1 (только если y > 0) и состоящих из k цифр. Асимптотика решения — O(n / k). 594A — Воин и лучник Отсортируем все точки по возрастанию координаты x, далее будем работать с перенумерованными точками.Предположим, что при оптимальной игре после ходов игроков остались точки с номерами l и r (l < r). Утверждается, что первый игрок не запретил ни одну из точек с индексом l < i < r, ведь в противном случае он играл не оптимально и мог запретить точку l или точку r (можно показать, что это не зависит от оптимальных действий второго игрока), поменяв оптимальный ответ. Получается, что номера всех запрещенных первым игроком точек лежат вне отрезка [l, r], а значит . Заметим, что выбрав некоторую такую границу [l, r] при , первый игрок может всегда добиться того, чтобы точки в ответе лежали внутри этого отрезка.Второй игрок хочет добиться того, чтобы (меньше он сделать не может), то есть всегда запрещать точку, лежащую строго внутри [l, r]. Поскольку второй игрок не знает наперед, к каким точкам стремится игрок, после каждого хода первого игрока ему необходимо запрещать точку, которая лежит строго внутри каждой из возможных границ, образованных этими точками. Нетрудно показать, что эта точка является медианой оставшегося множества точек (а их нечетное количество), ведь количество оставшихся ходов первого игрока на единицу меньше количества ходов второго, и он сможет впоследствии запретить все, кроме трех медианных точек. Две крайние из них второму игроку запрещать нельзя, так как они могут впоследствии увеличить количество удаленных слева (или справа) первым игроком точек, а средняя из них как раз принадлежит всевозможным границам, которые мог выбрать первый игрок. Таким образом второй игрок всегда может свести ситуацию к .Ответ на задачу — минимум среди значений .594B — Максим и велосипед Главное утверждение для решения этой задачи — в середине дистанции каждого соревнования датчик должен находиться либо в самой верхней точке колеса, либо в самой нижней точке колеса. Для того, чтобы посчитать ответ, воспользуемся бинпоиском. Если центр колеса прошел расстояние c то датчик переместился на расстояние c + rsin(c / r), если в середине датчик находился сверху колеса, или на расстояние c - rsin(c / r), если в середине датчие находился снизу колеса, где r — это радиус колеса. Асимптотика решения — . 594С — Эдо и магниты Найдем центры прямоугольников и умножим их координаты на два, чтобы далее работать с целыми координатами. Тогда подходящим холодильником (для всех точек) является прямоугольник, содержащий все точки, но с длинами сторон, округленными вверх к ближайшему четному числу. Представим теперь, что удаляем магниты с холодильника последовательно, постепенно \"уменьшая\" прямоугольник. Очевидно, что каждый раз выгодно удалять только те точки, что лежат на какой-то из четырех сторон прямоугольника. Переберем 4k вариантов того, как мы будем это делать, с помощью рекурсии, каждый раз удаляя одну из еще не удаленных точек с максимальным или минимальным значением по одной из координат. Если мы будем поддерживать 4 массива (или два массива в виде дека), то это можно делать за O(1) амортизированно. Такое решение будет работать за O(4k). Можно также заметить, что описанный выше алгоритм удаляет всегда несколько самых правых, левых, верхних, и нижних точек. Можно перебрать, как k распределится среди этих величин и промоделировать удаление с помощью, например, описанных выше 4 массивов. Такое решение имеет асимптотику O(k4). 594D — REQ Для подсчета ответа на каждый запрос будем пользоваться формулой , где p1, p2, ..., pk — все простые, делящие n. Эту формулу каждый может попробовать доказать или воспользоваться уже существующими доказательствами. Все вычисления ниже производим по модулю 109 + 7 Предположим теперь, что мы решаем задачу для фиксированного левого конца отрезка l, отбросив все элементы левее. Любой запрос теперь превращается в запрос на префиксе массива. Тогда, судя по формуле, для каждого простого p нас интересует лишь его самое левое вхождение, потому что все остальные вхождения не будут влиять на правую часть в приведенной выше формуле. Превратим наш запрос на значение функции Эйлера в запрос произведения на префиксе: сначала проинициализируем дерево Фенвика произведений единицами, затем сделаем умножения в точках l, l + 1, ..., n значениями соответствующих элементов al, al + 1, ..., an, затем для каждого самого левого вхождения простого p в позицию i сделаем умножение в точке i на значение . Нетрудно убедиться, что теперь запрос на префиксе определенной длины даст правильный ответ для отрезка той же длины с левым концом в l. Такую подготовку для фиксированного левого конца можно осуществить за , где C — максимальное значение элемента (этот логарифм соответствует количеству простых в разложении какого-то из ai). Нас интересуют все левые концы, поэтому научимся переходить от одного из них к другому. В самом деле, пусть все было посчитано для левого конца l и мы хотим теперь перейти к левому концу l + 1. Нас перестает интересовать al внутри левой части формулы, поэтому сделаем умножение в дереве Фенвика в точке l на значение al - 1. Так же нас перестают интересовать все простые внутри al (а они, очевидно, самые левые среди своих вхождений), поэтому сделаем так же умножения в точке l на все значения . Однако у каждого из этих простых могли существовать другие вхождения, которые теперь станут самыми левыми. Добавим их с помощью умножений, описанных выше. С помощью сортировок (или векторов) переход между соседними левыми концами реализуется за суммарную . Чтобы правильно отвечать на запросы, их так же нужно правильно отсортировать (или поместить в динамический массив), и ответ на запрос будет совершать операций. Суммарная асимптотика всего решения операций и дополнительной памяти. 594E — Разрезание строки Опишем жадный алгоритм, который позволяет решить задачу при k > 2 для любой строки S.Будем считать, что мы всегда переворачиваем некоторый префикс строки S (возможно, длины 1, подробнее ниже). Поскольку мы стремимся минимизировать строку лексикографически, легко убедиться в том, что мы будем переворачивать такие и только такие префиксы, префикс которых (после переворачивания) совпадает с минимальным лексикографически суффиксом перевернутой строки S (обозначим ее Sr), в частности, это префикс, совпадающий по длине с минимальным суффиксом Sr (операция переворачивания префикса S равносильна замене его суффиксом Sr соответствующей длины).Обозначим минимальный лексикографически суффикс строки Sr как s. Можно показать, что никакие два вхождения s в Sr не пересекаются, так как в противном случае строка s была бы периодической, и минимальный суффикс имел бы меньшую длину. Значит, строка Sr имеет вид tpsaptp - 1sap - 1tp - 2... t1sa1, где sx означает конкатенацию строки s x раз, a1, a2, ..., ap — натуральные числа, а строки t1, t2, ..., tp — некоторые непустые (кроме, возможно, tp) строки, не содержащие s в качестве подстроки.Перевернув некоторый подходящий префикс строки S, мы перейдем к меньшей строке S', при этом минимальный суффикс s' этой перевернутой строки S'r не может быть лексикографически меньше, чем s (это каждый может доказать самостоятельно), поэтому мы стремимся сделать так, чтобы s' осталось равным s, что позволит увеличить префикс вида sb в ответе (а значит и минимизировать его). Легко доказать, что максимальное b, которое мы можем получить, равно a1 в случае p = 1 и (в случае, если p \\geq 2$). Действительно, после таких операций префикс ответа будет выглядеть как sa1saitisai - 1... sa2t2. Поскольку t_{i} — непустые строки, увеличить количество конкатенаций s в префиксе ответа никак не получится. Заметим, что переворот второго префикса (sai...) возможен, так как k > 2.Из описанных выше утверждений следует, что при k > 2 для оставшейся строки всегда следует переворачивать префикс, который после переворота совпадает с суффиксом строки Sr вида sa1. Чтобы находить этот суффикс каждый раз, достаточно один раз построить декомпозицию Линдона (с помощью алгоритма Дюваля) перевернутой исходной строки и аккуратно объединять равные строки в ней. Единственным случаем остается вариант, когда префикс оставшейся строки переворачивать не нужно — его можно обработать как конкатенацию последовательных переворачиваемых префиксов длины 1.Поскольку для k = 1 задача тривиальна, осталось решать задачу для k = 2, то есть деление строки на две части (префикс и суффикс) и какой-то способ их переворачивания. Случай, когда ничего не переворачивается, нам не интересен, рассмотрим два других случая: Префикс не переворачивается. В таком случае обязательно переворачивается суффикс. Два варианта строки с перевернутым суффиксом можно сравнивать за O(1) с помощью z-функции строки Sr#S. Префикс переворачивается. Для решения этого случая можно воспользоваться утверждениями из разбора задачи F Яндекс.Алгоритма 2015 из Раунда 2.2 авторства GlebsHP и рассмотреть только два варианта поворота префикса, перебрав для каждого из них все два варианта поворота суффикса. Остается выбрать из двух случаев лучший ответ. Итоговая асимптотика решения O(|s|).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/21487",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 595 和字母"
          },
          "content_length": 9891
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 1",
          "code": "\"в середине дистанции каждого соревнования датчик должен находиться либо в самой верхней точке колеса, либо в самой нижней точке колеса\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 2",
          "code": "\"в середине дистанции каждого соревнования датчик должен находиться либо в самой верхней точке колеса, либо в самой нижней точке колеса\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 3",
          "code": "xd(t) = xc(t) + r * sin( v * t / r )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 4",
          "code": "vd(t) = v + v * cos( v * t / r )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 5",
          "code": "x + sin( x )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 6",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #330 (Div.1 + Div. 2) - Codeforces - Code 7",
          "code": "5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/21487",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000000, \"r\");\n    inf.readSpace();\n    int v = inf.readInt(1, 1000000000, \"v\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int s_i = inf.readInt(1, 1000000000 - 1, \"s_i\");  // s_i ∈ [1, 1e9 - 1]\n        inf.readSpace();\n        int f_i = inf.readInt(s_i + 1, 1000000000, \"f_i\");  // f_i ∈ [s_i + 1, 1e9]\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000000, \"r\");\n    inf.readSpace();\n    int v = inf.readInt(1, 1000000000, \"v\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int s_i = inf.readInt(1, 1000000000 - 1, \"s_i\");  // s_i ∈ [1, 1e9 - 1]\n        inf.readSpace();\n        int f_i = inf.readInt(s_i + 1, 1000000000, \"f_i\");  // f_i ∈ [s_i + 1, 1e9]\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000000, \"r\");\n    inf.readSpace();\n    int v = inf.readInt(1, 1000000000, \"v\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int s_i = inf.readInt(1, 1000000000 - 1, \"s_i\");  // s_i ∈ [1, 1e9 - 1]\n        inf.readSpace();\n        int f_i = inf.readInt(s_i + 1, 1000000000, \"f_i\");  // f_i ∈ [s_i + 1, 1e9]\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\");\n    int v = opt<int>(\"v\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> competitions;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            int si = rnd.next(1, int(1e9) - 1);\n            int fi = rnd.next(si + 1, int(1e9));\n            competitions.push_back({si, fi});\n        }\n    } else if (type == \"min_gap\") {\n        for (int i = 0; i < n; i++) {\n            int si = rnd.next(1, int(1e9) - 1);\n            int fi = si + 1;\n            if (fi > int(1e9)) fi = int(1e9);\n            competitions.push_back({si, fi});\n        }\n    } else if (type == \"max_gap\") {\n        for (int i = 0; i < n; i++) {\n            int si = 1;\n            int fi = int(1e9);\n            competitions.push_back({si, fi});\n        }\n    } else if (type == \"same\") {\n        int si = rnd.next(1, int(1e9) - 1);\n        int fi = rnd.next(si + 1, int(1e9));\n        for (int i = 0; i < n; i++) {\n            competitions.push_back({si, fi});\n        }\n    } else if (type == \"increasing\") {\n        int si = 1;\n        for (int i = 0; i < n; i++) {\n            int maxFi = si + int(1e7);\n            if (maxFi > int(1e9)) maxFi = int(1e9);\n            int fi = rnd.next(si + 1, maxFi);\n            competitions.push_back({si, fi});\n            si = fi + 1;\n            if (si >= int(1e9)) si = int(1e9) - 1;\n        }\n    } else if (type == \"decreasing\") {\n        int fi = int(1e9);\n        for (int i = 0; i < n; i++) {\n            int minSi = fi - int(1e7);\n            if (minSi < 1) minSi = 1;\n            int si = rnd.next(minSi, fi - 1);\n            competitions.push_back({si, fi});\n            fi = si - 1;\n            if (fi <= 1) fi = 2;\n        }\n    } else {\n        for (int i = 0; i < n; i++) {\n            int si = rnd.next(1, int(1e9) - 1);\n            int fi = rnd.next(si + 1, int(1e9));\n            competitions.push_back({si, fi});\n        }\n    }\n\n    // Output n, r, v\n    printf(\"%d %d %d\\n\", n, r, v);\n\n    // Output competitions\n    for (int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", competitions[i].first, competitions[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\");\n    int v = opt<int>(\"v\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> competitions;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            int si = rnd.next(1, int(1e9) - 1);\n            int fi = rnd.next(si + 1, int(1e9));\n            competitions.push_back({si, fi});\n        }\n    } else if (type == \"min_gap\") {\n        for (int i = 0; i < n; i++) {\n            int si = rnd.next(1, int(1e9) - 1);\n            int fi = si + 1;\n            if (fi > int(1e9)) fi = int(1e9);\n            competitions.push_back({si, fi});\n        }\n    } else if (type == \"max_gap\") {\n        for (int i = 0; i < n; i++) {\n            int si = 1;\n            int fi = int(1e9);\n            competitions.push_back({si, fi});\n        }\n    } else if (type == \"same\") {\n        int si = rnd.next(1, int(1e9) - 1);\n        int fi = rnd.next(si + 1, int(1e9));\n        for (int i = 0; i < n; i++) {\n            competitions.push_back({si, fi});\n        }\n    } else if (type == \"increasing\") {\n        int si = 1;\n        for (int i = 0; i < n; i++) {\n            int maxFi = si + int(1e7);\n            if (maxFi > int(1e9)) maxFi = int(1e9);\n            int fi = rnd.next(si + 1, maxFi);\n            competitions.push_back({si, fi});\n            si = fi + 1;\n            if (si >= int(1e9)) si = int(1e9) - 1;\n        }\n    } else if (type == \"decreasing\") {\n        int fi = int(1e9);\n        for (int i = 0; i < n; i++) {\n            int minSi = fi - int(1e7);\n            if (minSi < 1) minSi = 1;\n            int si = rnd.next(minSi, fi - 1);\n            competitions.push_back({si, fi});\n            fi = si - 1;\n            if (fi <= 1) fi = 2;\n        }\n    } else {\n        for (int i = 0; i < n; i++) {\n            int si = rnd.next(1, int(1e9) - 1);\n            int fi = rnd.next(si + 1, int(1e9));\n            competitions.push_back({si, fi});\n        }\n    }\n\n    // Output n, r, v\n    printf(\"%d %d %d\\n\", n, r, v);\n\n    // Output competitions\n    for (int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", competitions[i].first, competitions[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -r 1 -v 1 -type random\n./gen -n 1 -r 1000000000 -v 1000000000 -type random\n\n./gen -n 10 -r 1 -v 1 -type min_gap\n./gen -n 10 -r 1000000000 -v 1000000000 -type min_gap\n\n./gen -n 100 -r 1 -v 1 -type max_gap\n./gen -n 100 -r 1000000000 -v 1000000000 -type max_gap\n\n./gen -n 1000 -r 1 -v 1000000000 -type same\n./gen -n 1000 -r 1000000000 -v 1 -type same\n\n./gen -n 10000 -r 1 -v 1 -type increasing\n./gen -n 10000 -r 1000000000 -v 1000000000 -type increasing\n\n./gen -n 100000 -r 1 -v 1 -type decreasing\n./gen -n 100000 -r 1000000000 -v 1000000000 -type decreasing\n\n./gen -n 100000 -r 123456789 -v 987654321 -type random\n./gen -n 100000 -r 1 -v 1000000000 -type random\n./gen -n 100000 -r 1000000000 -v 1 -type random\n\n./gen -n 1 -r 1000000000 -v 1 -type max_gap\n./gen -n 100000 -r 1 -v 1 -type min_gap\n\n./gen -n 99999 -r 999999999 -v 999999999 -type decreasing\n\n./gen -n 100000 -r 10 -v 1000000000 -type random\n./gen -n 100000 -r 1000000000 -v 10 -type random\n./gen -n 100000 -r 1000000 -v 1000000 -type random\n\n./gen -n 100000 -r 123456789 -v 987654321 -type min_gap\n./gen -n 100000 -r 987654321 -v 123456789 -type max_gap\n\n./gen -n 100000 -r 1 -v 1000000000 -type same\n./gen -n 100000 -r 1000000000 -v 1 -type same\n\n./gen -n 100000 -r 1000000000 -v 1000000000 -type increasing\n\n./gen -n 1 -r 1 -v 1000000000 -type min_gap\n\n./gen -n 100000 -r 1000000000 -v 1 -type random\n\n./gen -n 100000 -r 1000000000 -v 1000000000 -type decreasing\n\n./gen -n 100000 -r 1 -v 1 -type random\n\n./gen -n 100000 -r 1000000000 -v 1000000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:55:21.574093",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}