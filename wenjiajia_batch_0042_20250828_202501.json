{
  "metadata": {
    "batch_number": 42,
    "batch_size": 100,
    "problems_in_batch": 100,
    "total_processed": 4300,
    "created_at": "2025-08-28T20:25:01.708071",
    "format": "wenjiajia_v1.0_incremental"
  },
  "problems": [
    {
      "problem_id": "397/C",
      "title": "C. On Number of Decompositions into Multipliers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains positive integer n (1 ≤ n ≤ 500). The second line contains space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109).",
      "output_spec": "OutputIn a single line print a single number k — the number of distinct decompositions of number m into n ordered multipliers modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy115OutputCopy1InputCopy31 1 2OutputCopy3InputCopy25 7OutputCopy4",
      "description": "C. On Number of Decompositions into Multipliers\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains positive integer n (1 ≤ n ≤ 500). The second line contains space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109).\n\nOutputIn a single line print a single number k — the number of distinct decompositions of number m into n ordered multipliers modulo 1000000007 (109 + 7).\n\nInputCopy115OutputCopy1InputCopy31 1 2OutputCopy3InputCopy25 7OutputCopy4\n\nInputCopy115\n\nOutputCopy1\n\nInputCopy31 1 2\n\nOutputCopy3\n\nInputCopy25 7\n\nOutputCopy4\n\nNoteIn the second sample, the get a decomposition of number 2, you need any one number out of three to equal 2, and the rest to equal 1.In the third sample, the possible ways of decomposing into ordered multipliers are [7,5], [5,7], [1,35], [35,1].A decomposition of positive integer m into n ordered multipliers is a cortege of positive integers b = {b1, b2, ... bn} such that . Two decompositions b and c are considered different, if there exists index i such that bi ≠ ci.",
      "solutions": [
        {
          "title": "Codeforces Round #232 Editorial (restored) - Codeforces",
          "content": "Div2-ACreate an array used of 100 elements. i-th element for the segment (i, i + 1).For every student except Alexey set used[i]  =  true for each segment (i,  i  +  1) in the segment of that student. After that for each subsegment (i,  i  +  1) of Alexey's segment add 1 to result if used[i]  =  false.Div2-BFirst of all, calculate how many L's we can bring so that the result will not exceed N. It's .Now, if R·K  ≥  N we may increase any of K numbers by 1. At some moment sum will be equal to N becase sum of K R's is greater than N. So answer in this case is YES.If R·K  <  N, we can't get K or less numbers because their sum is less than N. But we can't get more than K numbers too, because their sum is more than N. So answer is NO.Complexity: O(1) for every query. Overall complexity: O(t).Div1-A/Div2-CLet's factorize all n numbers into prime factors. Now we should solve the problem for every prime independently and multiply these answers. The number of ways to split pk into n multipliers, where p is prime, is equal to C(k  +  n  -  1,  n  -  1) (it can be obtained using the method of stars and bars, you can read about it here, choose 'combinatorics'). So we have a solution that needs time.Div1-B/Div2-DFirst of all, let's consider n  +  1  =  p is prime. Then we can prove by induction that the answer is . Base for p  =  3 is obvious. If this equality holds for p, and q is the next prime, then answer for q is equal to answer for p plus q  -  p equal summands , that is , that's we wanted to prove.Next using that the distance between two consecutive primes not exceeding 109 does not exceed 300, we can find the answer as a sum of the answer for the maximal prime not exceeding n and several equal summands . We see that the denominator is a divisor of 2pq, which fits in long long.Div1-C/Div2-EWe can write all vertices in the list in order of dfs, then the descendants of the vertex from a segment of this list. Let's count for every vertex its distance to the root level[v].Let's create two segment trees st1 and st2. If we are given a query of the first type, in st1 we add x  +  level[v]·k to the segment corresponding to the vertex v, in st2 we add k to the segment corresponding to the vertex v.If we are given a query of the second type, we write st1.get(v) - st2.get(v) * level[v].The complexity is O(qlogn).You can use any other data stucture that allows to add to the segment and to find a value of an arbitrary element.Also there exists a solution using Heavy-Light decomposition.Div1-DLet's prove a useful fact: sum of number of invertions for all permutations of size k is equal to . The prove is simple: let's change in permutation p for every i pi to k  +  1  -  pi. Then the sum of number of invertions of the first and the second permutations is , and our conversion of the permutation is a biection.Now we suppose that we are given a permutation of numbers from 0 to n  -  1.Let's go at p from left to right. What permutations are less than p? Permutations having first number less than p0. If the first number is a  <  p0, than in every such permutation there are a inversions of form (first element, some other element). So in all permutations beginning with a there are a·(n  -  1)! inversions of this from. Moreover, there are inversions not including the first element, their sum is sumAll[n  -  1]. Then, counting sum for all a we have inversions. Permutations beginning with p0. At first, we should count the number of inversions, beginning in p0. There are cnt·p0 of this form, where cnt is the number of permutations beginning with p0 and not exceeding p. Then we should count the inversions not beginning in the beginning. But it is the same problem! The only exception is that if p1  >  p0, there are p1  -  1 available numbers less than p1, but not p1. So we get a solution: go from left to right, keep already used numbers in Fenwick tree, and then solve the same problem, assuming that the first number is not pi but pi - (the number of used numbers less than pi). The last we should do is to count the number of permutations not exceeding the suffix of p and beginning the same. It can be precomputed, if we go from right to left. In this case we should do the same as in the first part of solution, but consider that the minimal number is a number of already used numbers less than current.Div1-EWe will describe an algorithm and then understand why it works.For every prime we will maintain a list of intervals. At the first moment for every pi we add in its list interval [0;ai), other primes have an empty list.Then we go from big primes to small. Let's consider that current prime is p. If in its list there exists an interval [x;y), $x < k, y > k$, we divide it into two parts [x;k) and [k;y).Then for every interval [x;y), x  ≥  k (in fact, in this case x  =  k) we add to the answer for p y  -  x. For intervals, where y  ≤  k, we add to list of every prime divisor of p  -  1 invterval [x  +  1,  y  +  1). If p  -  1 has some prime if more than first power, we should add this segment several times.After that we should conduct a \"union with displacement\" operation for every prime which list was changed. If in one list there are 2 invervals [x,  y), [z,  t) so that y  ≤  z  >  x, we replace them with one interval [x,  y  +  t  -  z) (so we added t  -  z to the right border of the first interval). Then we go to next (lesser) p.Why does it works? If we take function φ one time, for every prime p which divides n, n is divided by p and multiplied by p  -  1 (or, the same, by all prime divisors p  -  1 in corresponding powers).Now we can observe that intervals in lists contains the numbers of iterations, when the number contains the corresponding prime number. Bigger primes do not affect smaller, so we can process them earlier. If after i-th iteration the number contains prime number p, after i  +  1-th iteration it contains prime divisors of p  -  1, and we add segments in accordance with this. The k-th iteration is the last, so the existence of the interval [k,  x) means that after k-th iteration we have (x  -  k)-th power of this prime. From this it is clear why we unite the intervals if that way.Why does it work fast? Because we precalculated the minimal prime divisor of each number up to MAXPRIME using linear Eratosthenes sieve. (Well, it's not necessary) Because for each prime there's no more than intervals, because for each [a,  b) range . Practically there is no more than 6 segments at once. Any questions about the editorial are welcome! Especially the English one :)This post was restored from google cache, and I have edited formula once again. If you notice some mistake, please send be a private message.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10713",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6701
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #232 Editorial (restored) - Codeforces - Code 1",
          "code": "st1.get(v) - st2.get(v) * level[v]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10713",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a small prime number\nlong long generate_small_prime() {\n    vector<int> small_primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,\n                                79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173};\n    return small_primes[rnd.next(0, (int)small_primes.size() -1)];\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    long long max_ai = opt<long long>(\"max_ai\", 1000000000);\n\n    vector<long long> a(n);\n\n    if (type == \"all_ones\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"all_max\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = max_ai;\n    } else if (type == \"alternating_one_max\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? 1 : max_ai;\n    } else if (type == \"primes\") {\n        // Generate n random small primes less than max_ai\n        for(int i = 0; i < n; ++i) {\n            a[i] = generate_small_prime();\n        }\n    } else if (type == \"composites\") {\n        // Generate n composite numbers\n        for(int i = 0; i < n; ++i) {\n            long long p = rnd.next(2LL, min(max_ai/2, 1000000LL));\n            long long q = rnd.next(2LL, min(max_ai/p, 1000000LL));\n            a[i] = p * q;\n        }\n    } else if (type == \"big_product\") {\n        // Generate n numbers close to sqrt(max_ai)\n        long long val = sqrt(max_ai);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"small_random\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1LL, min(max_ai, 1000LL));\n    } else {\n        // Random\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1LL, max_ai);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i)\n        printf(\"%lld%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a small prime number\nlong long generate_small_prime() {\n    vector<int> small_primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,\n                                79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173};\n    return small_primes[rnd.next(0, (int)small_primes.size() -1)];\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    long long max_ai = opt<long long>(\"max_ai\", 1000000000);\n\n    vector<long long> a(n);\n\n    if (type == \"all_ones\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"all_max\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = max_ai;\n    } else if (type == \"alternating_one_max\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? 1 : max_ai;\n    } else if (type == \"primes\") {\n        // Generate n random small primes less than max_ai\n        for(int i = 0; i < n; ++i) {\n            a[i] = generate_small_prime();\n        }\n    } else if (type == \"composites\") {\n        // Generate n composite numbers\n        for(int i = 0; i < n; ++i) {\n            long long p = rnd.next(2LL, min(max_ai/2, 1000000LL));\n            long long q = rnd.next(2LL, min(max_ai/p, 1000000LL));\n            a[i] = p * q;\n        }\n    } else if (type == \"big_product\") {\n        // Generate n numbers close to sqrt(max_ai)\n        long long val = sqrt(max_ai);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"small_random\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1LL, min(max_ai, 1000LL));\n    } else {\n        // Random\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1LL, max_ai);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i)\n        printf(\"%lld%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_ones\n./gen -n 1 -type all_max\n./gen -n 1 -type random\n\n./gen -n 2 -type all_ones\n./gen -n 2 -type random\n./gen -n 2 -type primes\n\n./gen -n 3 -type random\n./gen -n 3 -type composites\n\n./gen -n 10 -type all_ones\n./gen -n 10 -type alternating_one_max\n\n./gen -n 100 -type random\n./gen -n 100 -type small_random\n\n./gen -n 500 -type all_max -max_ai 1000000000\n\n./gen -n 499 -type big_product\n\n./gen -n 500 -type primes\n\n./gen -n 500 -type composites\n\n./gen -n 500 -type random\n\n./gen -n 500 -type small_random\n\n./gen -n 500 -type alternating_one_max\n\n./gen -n 500 -type all_ones\n\n./gen -n 500 -type alternating_one_max -max_ai 1\n\n./gen -n 500 -type all_ones\n\n./gen -n 500 -type all_max -max_ai 1\n\n./gen -n 150 -type big_product -max_ai 1000000\n\n./gen -n 500 -type big_product\n\n./gen -n 500 -type random\n\n./gen -n 500 -type random -max_ai 2\n\n./gen -n 500 -type small_random\n\n./gen -n 500 -type small_random -max_ai 1000\n\n./gen -n 500 -type small_random -max_ai 10\n\n./gen -n 500 -type random -max_ai 1\n\n./gen -n 500 -type random -max_ai 1000000000\n\n./gen -n 500 -type random -max_ai 999999999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:31.913256",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "397/D",
      "title": "D. О сумме дробей",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано целое число t (1 ≤ t ≤ 500) — количество тестов. В каждой из следующих t строк входных данных вводится целое число n (2 ≤ n ≤ 109).",
      "output_spec": "Выходные данныеВыведите t строк: в i-й из них должен содержатся ответ на i-й тест в виде несократимой дроби «p/q», где p, q — целые числа, q > 0.",
      "sample_tests": "ПримерыВходные данныеСкопировать223Выходные данныеСкопировать1/67/30",
      "description": "D. О сумме дробей\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке задано целое число t (1 ≤ t ≤ 500) — количество тестов. В каждой из следующих t строк входных данных вводится целое число n (2 ≤ n ≤ 109).\n\nВходные данные\n\nВыходные данныеВыведите t строк: в i-й из них должен содержатся ответ на i-й тест в виде несократимой дроби «p/q», где p, q — целые числа, q > 0.\n\nВыходные данные\n\nВходные данныеСкопировать223Выходные данныеСкопировать1/67/30\n\nВходные данныеСкопировать223\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1/67/30\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #232 Editorial (restored) - Codeforces",
          "content": "Div2-AЗаводим массив used на 100 элементов и заполняем его таким образом: used[i]  =  1, если хотя бы один из однокашников Алексея претендует на часть (i,  i  +  1). Далее проходимся циклом от l1 до r1  -  1 и находим количество тех i, для которых used[i]  =  0. Это и будет ответом.Эту задачу можно решать и за O(nlogn), используя сортировку событий или просто сортировку и линейное решение далее. Такое решение будет находить требуемую величину сразу для всех отрезков.Div2-BПосчитаем, сколько раз по L мы можем взять, не превысив N. Это количество равно .Тогда, если R·K  ≥  N, будем увеличивать какое-то из K чисел на 1, в какой-то момент у нас получится в сумме N, так в итоге будет больше. Значит ответ — YES.В обратном случае, если мы возьмем не больше K чисел, то их сумма меньше N. Если взять больше K чисел, то сумма будет больше N. Значит ответ — NO.Сложность ответа на 1 запрос: O(1).Div1-A/Div2-CРазложим все данные n чисел на простые множители. Теперь нам нужно решить задачу отдельно по каждому простому, а потом перемножить ответы для различных простых. Количество способов разбить pk, где p — простое, на n множителей равно C(k + n - 1,  n - 1) (Это можно получить методом шаров и перегородок, подробнее здесь, выбрать combinatorics). Таким образом, получаем решение за .Div1-B/Div2-DПусть для начала n  +  1  =  p — простое. Докажем по индукции, что в этом случае ответ — . При p  =  3 — очевидно. Пусть это равенство доказано для p, а q — следующее простое. Тогда ответ для q — это ответ для p плюс q  -  p одинаковых слагаемых вида , то есть , что и требовалось доказать.Далее, воспользовавшись тем, что между любыми соседними простыми числами, не превосходящими 109, разница не более нескольких сотен, находим ответ, как ответ для наибольшего (явно проверяем числа на простоту за корень) не превосходящего простого плюс . Отсюда же замечаем, что в ответе знаменатель это 2pq (или его делитель), что влазит в int64.Div1-C/Div2-EЗапишем все вершины в порядке обхода dfs'а, тогда потомки одной вершины образуют подотрезок. Запомним также для каждой вершины расстояние от нее до корня level[v].Заведем два дерева отрезков (ДО). При запросе на изменения в первом ДО добавим на отрезке, соответствующем потомкам вершины v, x  +  level[v]·k, а во втором ДО на том же отрезке добавим k.Тогда, если обозначим первое ДО как st1, второе ДО как st2, то при запросе второго типа в вершине v нужно вывести st1.get(v)  -  st2.get(v)  *  level[v].Сложность: O(qlogn)Вместо дерева отрезков можно использовать другие структуры данных, поддерживающие добавление на отрезке и запрос в одном элементе. Также в комментариях приведен способ несколько другой реализации: http://codeforces.com/blog/entry/10961#comment-162286Также существует решение с Heavy-Light декомпозицией.Div1-DЗаметим полезный факт: если взять все перестановки длины k, то сумма количеств инверсий в них будет равна . Доказывается он очень просто: если в перестановке p для каждого i заменим pi на k  +  1  -  pi, то сумма количеств инверсий p и новой перестановки будет равна , и при этом наше преобразование является биекцией.Далее будем считать, что все перестановки на числах от 0 до n  -  1, а не от 1 до n, как в условии. Ясно, что в этом нет никакой разницы.Пойдем по перестановке с начала. Какие перестановки бывают меньше данной? Те, у которых первое число меньше, чем p0. Пусть первое число a  <  p0, тогда в каждой такой перестановке a инверсий вида (первый элемент, еще какой-то элемент). То есть всего во всех перестановках с первым числом a их a·(n  -  1)!. Кроме того, есть инверсии среди элементов, не содержащих первый. Их суммарно sumAll[n  -  1]. Тогда суммарно по всем a получаем инверсий: . Перестановки, которые начинаются на p0: Во-первых, нужно учесть кол-во инверсий, начинающихся в начале. Их cnt·p0, где cnt — количество перестановок, начинающихся на p0 и не больших данной. Во-вторых, нужно учесть инверсии \"не в начале\". Но это такая же задача! Единственное исключение — меньше числа p1 может быть доступно не p1 чисел, а меньше на 1, если p1  >  p0. Отсюда получаем решение: итерируемся с начала, запоминаем в дереве Фенвика числа, которые уже использованы, далее решаем такую же задачу, но считаем что первое число это pi - (кол-во уже использованных чисел, меньших чем pi). Осталось посчитать количество перестановок, не больших чем суффикс данной и начинающихся также. Это можно легко пересчитывать, если двигаться не вперед, а назад. В таком случае нужно делать то же самое, но минимальное число считать равным количеству уже использованных чисел, меньше данного.Div1-EОпишем алгоритм, а потом поймем, почему он делает то, что нужно.Заведем для каждого простого числа список полуинтервалов. Изначально для каждого простого pi, имеющегося в инпуте, положим туда [0;ai). У всех остальных простых оставим список пустым.Далее, будем итерироваться по всем простым в порядке убывания. Пусть текущее простое p. Если в его списке есть полуинтервал вида [x;y), $x < k, y > k$, разделим его на 2 полуинтервала [x;k) и [k;y).Далее для каждого полуинтервала [x;y), x  ≥  k (на самом деле, x  >  k не бывает) добавим к ответу для p величину y  -  x, а для полуинтервалов y  ≤  k добавим к списку каждого из простых делителей числа p  -  1 полуинтервал [x  +  1,  y  +  1). В случае, если p  -  1 делится на больше чем первую степень какого-то простого, нужно добавить такой отрезок несколько раз.После этого нужно провести операцию \"объединения со смещением\" для всех простых, у которых изменился список. Если в одном списке существуют 2 полуинтервала [x,  y), [z,  t) при y  ≥  z  >  x, то их нужно заменить на 1 полуинтервал [x,  y  +  t  -  z) (т.е добавить t  -  z к концу первого из них). Далее переходим к следующему (меньшему) p.Почему это работает? Вспомним сперва, что происходит с числом n при одной итерации взятия φ. Для любого p, которое входит хотя бы 1 раз в разложение числа n, n делится на p и умножается на p  -  1 (или, что тоже самое, на все простые числа p  -  1 в соответсвующих степенях).Теперь поймем, что полуинтервалы, которые мы поддерживали для чисел — это то, после каких по счету итераций число содержало в себе данный простой множитель. На большие простые меньшие никак не влияют, поэтому их можно рассматривать раньше. Если после i-ой итерации число содержало простой множитель p, то после i  +  1-й оно будет содержать простые делители p  -  1, поэтому мы именно таким образом передаем отрезки. Итерация с номером k — последняя, поэтому полуинтервал [k,  x) означает, что после k-ой итерации останется степень x  -  k данного простого. Отсюда понятно, почему нужно объединять отрезки со смещением, как описано выше.Почему это работает быстро?Потому что мы предподсчитали решетом за линию минимальный делитель каждого числа и раскладываем число на простые за кол-во простых в нем. (На самом деле это делать не обязательно)Потому что для каждого простого отрезков одновременно, очевидно, не более чем log(MAXP) =  20, ибо для каждого [a,  b) выполняется a  ≤  log(MAXP)  +  1. Если чуть подумать, то их не более чем половина от этого, ибо 2 отрезка не начинаются в подряд идущих числах. Экспериментально, их не более 6.Несколько другой подход к этой задаче описан в комментариях: http://codeforces.com/blog/entry/10961#comment-162236Авторы не уверены, что в разборе все решения написаны понятно, поэтому любые вопросы по нему приветствуются!Пост был восстановлен из кэша google, формулы были оформлены заново, поэтому, если видите ошибку в них, пожалуйста, пишите мне в личку.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10713",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 7498
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 500, \"t\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; i++) {\n        int n = inf.readInt(2, 1000000000, \"n\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 500, \"t\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; i++) {\n        int n = inf.readInt(2, 1000000000, \"n\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 500, \"t\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; i++) {\n        int n = inf.readInt(2, 1000000000, \"n\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll mod_pow(ll a, ll b, ll mod) {\n    ll result = 1;\n    a %= mod;\n    while (b) {\n        if (b & 1) result = (result * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return result;\n}\n\nbool is_prime(ll n) {\n    if (n < 2) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0) return false;\n    vector<ll> bases = {2, 3, 5, 7, 11};\n    ll d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        s++;\n    }\n    for (ll a : bases) {\n        if (a >= n) continue;\n        ll x = mod_pow(a, d, n);\n        if (x == 1 || x == n - 1) continue;\n        bool composite = true;\n        for (int r = 1; r < s; ++r) {\n            x = (x * x) % n;\n            if (x == n - 1) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<ll> test_cases;\n\n    if (type == \"small\") {\n        for (int i = 0; i < t; ++i) {\n            ll n = rnd.next(2, 1000);\n            test_cases.push_back(n);\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < t; ++i) {\n            ll n = rnd.next(2LL, 1000000000LL);\n            test_cases.push_back(n);\n        }\n    } else if (type == \"prime\") {\n        for (int i = 0; i < t; ++i) {\n            ll n;\n            do {\n                n = rnd.next(2LL, 1000000000LL);\n            } while (!is_prime(n));\n            test_cases.push_back(n);\n        }\n    } else if (type == \"composite\") {\n        for (int i = 0; i < t; ++i) {\n            ll n;\n            do {\n                n = rnd.next(2LL, 1000000000LL);\n            } while (is_prime(n));\n            test_cases.push_back(n);\n        }\n    } else if (type == \"edge\") {\n        test_cases.push_back(2);\n        test_cases.push_back(1000000000LL);\n    } else if (type == \"before_prime\") {\n        for (int i = 0; i < t; ++i) {\n            ll p;\n            do {\n                p = rnd.next(3LL, 1000000000LL);\n            } while (!is_prime(p));\n            ll n = p - 1;\n            if (n < 2) n = 2LL;\n            test_cases.push_back(n);\n        }\n    } else if (type == \"after_prime\") {\n        for (int i = 0; i < t; ++i) {\n            ll p;\n            do {\n                p = rnd.next(2LL, 1000000000LL - 1);\n            } while (!is_prime(p));\n            ll n = p + 1;\n            if (n > 1000000000LL) n = 1000000000LL;\n            test_cases.push_back(n);\n        }\n    } else {\n        for (int i = 0; i < t; ++i) {\n            ll n = rnd.next(2LL, 1000000000LL);\n            test_cases.push_back(n);\n        }\n    }\n\n    printf(\"%d\\n\", (int)test_cases.size());\n    for (auto n : test_cases) {\n        printf(\"%lld\\n\", n);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll mod_pow(ll a, ll b, ll mod) {\n    ll result = 1;\n    a %= mod;\n    while (b) {\n        if (b & 1) result = (result * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return result;\n}\n\nbool is_prime(ll n) {\n    if (n < 2) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0) return false;\n    vector<ll> bases = {2, 3, 5, 7, 11};\n    ll d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        s++;\n    }\n    for (ll a : bases) {\n        if (a >= n) continue;\n        ll x = mod_pow(a, d, n);\n        if (x == 1 || x == n - 1) continue;\n        bool composite = true;\n        for (int r = 1; r < s; ++r) {\n            x = (x * x) % n;\n            if (x == n - 1) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<ll> test_cases;\n\n    if (type == \"small\") {\n        for (int i = 0; i < t; ++i) {\n            ll n = rnd.next(2, 1000);\n            test_cases.push_back(n);\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < t; ++i) {\n            ll n = rnd.next(2LL, 1000000000LL);\n            test_cases.push_back(n);\n        }\n    } else if (type == \"prime\") {\n        for (int i = 0; i < t; ++i) {\n            ll n;\n            do {\n                n = rnd.next(2LL, 1000000000LL);\n            } while (!is_prime(n));\n            test_cases.push_back(n);\n        }\n    } else if (type == \"composite\") {\n        for (int i = 0; i < t; ++i) {\n            ll n;\n            do {\n                n = rnd.next(2LL, 1000000000LL);\n            } while (is_prime(n));\n            test_cases.push_back(n);\n        }\n    } else if (type == \"edge\") {\n        test_cases.push_back(2);\n        test_cases.push_back(1000000000LL);\n    } else if (type == \"before_prime\") {\n        for (int i = 0; i < t; ++i) {\n            ll p;\n            do {\n                p = rnd.next(3LL, 1000000000LL);\n            } while (!is_prime(p));\n            ll n = p - 1;\n            if (n < 2) n = 2LL;\n            test_cases.push_back(n);\n        }\n    } else if (type == \"after_prime\") {\n        for (int i = 0; i < t; ++i) {\n            ll p;\n            do {\n                p = rnd.next(2LL, 1000000000LL - 1);\n            } while (!is_prime(p));\n            ll n = p + 1;\n            if (n > 1000000000LL) n = 1000000000LL;\n            test_cases.push_back(n);\n        }\n    } else {\n        for (int i = 0; i < t; ++i) {\n            ll n = rnd.next(2LL, 1000000000LL);\n            test_cases.push_back(n);\n        }\n    }\n\n    printf(\"%d\\n\", (int)test_cases.size());\n    for (auto n : test_cases) {\n        printf(\"%lld\\n\", n);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -type small\n./gen -t 1 -type prime\n./gen -t 1 -type composite\n./gen -t 1 -type before_prime\n./gen -t 1 -type after_prime\n./gen -t 1 -type random\n\n./gen -t 5 -type small\n./gen -t 5 -type prime\n./gen -t 5 -type composite\n./gen -t 5 -type before_prime\n./gen -t 5 -type after_prime\n./gen -t 5 -type random\n\n./gen -t 100 -type small\n./gen -t 100 -type prime\n./gen -t 100 -type composite\n./gen -t 100 -type before_prime\n./gen -t 100 -type after_prime\n./gen -t 100 -type random\n\n./gen -t 500 -type small\n./gen -t 500 -type prime\n./gen -t 500 -type composite\n./gen -t 500 -type before_prime\n./gen -t 500 -type after_prime\n./gen -t 500 -type random\n\n./gen -type edge\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:34.315074",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "397/E",
      "title": "E. On Changing Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 3·105) — the number of vertices in the tree. The second line contains n - 1 integers p2, p3, ... pn (1 ≤ pi < i), where pi is the number of the vertex that is the parent of vertex i in the tree.The third line contains integer q (1 ≤ q ≤ 3·105) — the number of queries. Next q lines contain the queries, one per line. The first number in the line is type. It represents the type of the query. If type = 1, then next follow space-separated integers v, x, k (1 ≤ v ≤ n; 0 ≤ x < 109 + 7; 0 ≤ k < 109 + 7). If type = 2, then next follows integer v (1 ≤ v ≤ n) — the vertex where you need to find the value of the number.",
      "output_spec": "OutputFor each query of the second type print on a single line the number written in the vertex from the query. Print the number modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy31 131 1 2 12 12 2OutputCopy21",
      "description": "E. On Changing Tree\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 3·105) — the number of vertices in the tree. The second line contains n - 1 integers p2, p3, ... pn (1 ≤ pi < i), where pi is the number of the vertex that is the parent of vertex i in the tree.The third line contains integer q (1 ≤ q ≤ 3·105) — the number of queries. Next q lines contain the queries, one per line. The first number in the line is type. It represents the type of the query. If type = 1, then next follow space-separated integers v, x, k (1 ≤ v ≤ n; 0 ≤ x < 109 + 7; 0 ≤ k < 109 + 7). If type = 2, then next follows integer v (1 ≤ v ≤ n) — the vertex where you need to find the value of the number.\n\nOutputFor each query of the second type print on a single line the number written in the vertex from the query. Print the number modulo 1000000007 (109 + 7).\n\nInputCopy31 131 1 2 12 12 2OutputCopy21\n\nInputCopy31 131 1 2 12 12 2\n\nOutputCopy21\n\nNoteYou can read about a rooted tree here: http://en.wikipedia.org/wiki/Tree_(graph_theory).",
      "solutions": [
        {
          "title": "Codeforces Round #232 Editorial (restored) - Codeforces",
          "content": "Div2-ACreate an array used of 100 elements. i-th element for the segment (i, i + 1).For every student except Alexey set used[i]  =  true for each segment (i,  i  +  1) in the segment of that student. After that for each subsegment (i,  i  +  1) of Alexey's segment add 1 to result if used[i]  =  false.Div2-BFirst of all, calculate how many L's we can bring so that the result will not exceed N. It's .Now, if R·K  ≥  N we may increase any of K numbers by 1. At some moment sum will be equal to N becase sum of K R's is greater than N. So answer in this case is YES.If R·K  <  N, we can't get K or less numbers because their sum is less than N. But we can't get more than K numbers too, because their sum is more than N. So answer is NO.Complexity: O(1) for every query. Overall complexity: O(t).Div1-A/Div2-CLet's factorize all n numbers into prime factors. Now we should solve the problem for every prime independently and multiply these answers. The number of ways to split pk into n multipliers, where p is prime, is equal to C(k  +  n  -  1,  n  -  1) (it can be obtained using the method of stars and bars, you can read about it here, choose 'combinatorics'). So we have a solution that needs time.Div1-B/Div2-DFirst of all, let's consider n  +  1  =  p is prime. Then we can prove by induction that the answer is . Base for p  =  3 is obvious. If this equality holds for p, and q is the next prime, then answer for q is equal to answer for p plus q  -  p equal summands , that is , that's we wanted to prove.Next using that the distance between two consecutive primes not exceeding 109 does not exceed 300, we can find the answer as a sum of the answer for the maximal prime not exceeding n and several equal summands . We see that the denominator is a divisor of 2pq, which fits in long long.Div1-C/Div2-EWe can write all vertices in the list in order of dfs, then the descendants of the vertex from a segment of this list. Let's count for every vertex its distance to the root level[v].Let's create two segment trees st1 and st2. If we are given a query of the first type, in st1 we add x  +  level[v]·k to the segment corresponding to the vertex v, in st2 we add k to the segment corresponding to the vertex v.If we are given a query of the second type, we write st1.get(v) - st2.get(v) * level[v].The complexity is O(qlogn).You can use any other data stucture that allows to add to the segment and to find a value of an arbitrary element.Also there exists a solution using Heavy-Light decomposition.Div1-DLet's prove a useful fact: sum of number of invertions for all permutations of size k is equal to . The prove is simple: let's change in permutation p for every i pi to k  +  1  -  pi. Then the sum of number of invertions of the first and the second permutations is , and our conversion of the permutation is a biection.Now we suppose that we are given a permutation of numbers from 0 to n  -  1.Let's go at p from left to right. What permutations are less than p? Permutations having first number less than p0. If the first number is a  <  p0, than in every such permutation there are a inversions of form (first element, some other element). So in all permutations beginning with a there are a·(n  -  1)! inversions of this from. Moreover, there are inversions not including the first element, their sum is sumAll[n  -  1]. Then, counting sum for all a we have inversions. Permutations beginning with p0. At first, we should count the number of inversions, beginning in p0. There are cnt·p0 of this form, where cnt is the number of permutations beginning with p0 and not exceeding p. Then we should count the inversions not beginning in the beginning. But it is the same problem! The only exception is that if p1  >  p0, there are p1  -  1 available numbers less than p1, but not p1. So we get a solution: go from left to right, keep already used numbers in Fenwick tree, and then solve the same problem, assuming that the first number is not pi but pi - (the number of used numbers less than pi). The last we should do is to count the number of permutations not exceeding the suffix of p and beginning the same. It can be precomputed, if we go from right to left. In this case we should do the same as in the first part of solution, but consider that the minimal number is a number of already used numbers less than current.Div1-EWe will describe an algorithm and then understand why it works.For every prime we will maintain a list of intervals. At the first moment for every pi we add in its list interval [0;ai), other primes have an empty list.Then we go from big primes to small. Let's consider that current prime is p. If in its list there exists an interval [x;y), $x < k, y > k$, we divide it into two parts [x;k) and [k;y).Then for every interval [x;y), x  ≥  k (in fact, in this case x  =  k) we add to the answer for p y  -  x. For intervals, where y  ≤  k, we add to list of every prime divisor of p  -  1 invterval [x  +  1,  y  +  1). If p  -  1 has some prime if more than first power, we should add this segment several times.After that we should conduct a \"union with displacement\" operation for every prime which list was changed. If in one list there are 2 invervals [x,  y), [z,  t) so that y  ≤  z  >  x, we replace them with one interval [x,  y  +  t  -  z) (so we added t  -  z to the right border of the first interval). Then we go to next (lesser) p.Why does it works? If we take function φ one time, for every prime p which divides n, n is divided by p and multiplied by p  -  1 (or, the same, by all prime divisors p  -  1 in corresponding powers).Now we can observe that intervals in lists contains the numbers of iterations, when the number contains the corresponding prime number. Bigger primes do not affect smaller, so we can process them earlier. If after i-th iteration the number contains prime number p, after i  +  1-th iteration it contains prime divisors of p  -  1, and we add segments in accordance with this. The k-th iteration is the last, so the existence of the interval [k,  x) means that after k-th iteration we have (x  -  k)-th power of this prime. From this it is clear why we unite the intervals if that way.Why does it work fast? Because we precalculated the minimal prime divisor of each number up to MAXPRIME using linear Eratosthenes sieve. (Well, it's not necessary) Because for each prime there's no more than intervals, because for each [a,  b) range . Practically there is no more than 6 segments at once. Any questions about the editorial are welcome! Especially the English one :)This post was restored from google cache, and I have edited formula once again. If you notice some mistake, please send be a private message.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10713",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6701
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #232 Editorial (restored) - Codeforces - Code 1",
          "code": "st1.get(v) - st2.get(v) * level[v]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10713",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n\n    for (int i = 2; i <= n; i++) {\n        int p_i = inf.readInt(1, i - 1, \"p_i\");\n        if (i < n)\n            inf.readSpace();\n        else\n            inf.readEoln();\n    }\n\n    int q = inf.readInt(1, 300000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int type = inf.readInt(1, 2, \"type\");\n        if (type == 1) {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readSpace();\n            int x = inf.readInt(0, 1000000006, \"x\");\n            inf.readSpace();\n            int k = inf.readInt(0, 1000000006, \"k\");\n        } else {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n\n    for (int i = 2; i <= n; i++) {\n        int p_i = inf.readInt(1, i - 1, \"p_i\");\n        if (i < n)\n            inf.readSpace();\n        else\n            inf.readEoln();\n    }\n\n    int q = inf.readInt(1, 300000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int type = inf.readInt(1, 2, \"type\");\n        if (type == 1) {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readSpace();\n            int x = inf.readInt(0, 1000000006, \"x\");\n            inf.readSpace();\n            int k = inf.readInt(0, 1000000006, \"k\");\n        } else {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n\n    for (int i = 2; i <= n; i++) {\n        int p_i = inf.readInt(1, i - 1, \"p_i\");\n        if (i < n)\n            inf.readSpace();\n        else\n            inf.readEoln();\n    }\n\n    int q = inf.readInt(1, 300000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int type = inf.readInt(1, 2, \"type\");\n        if (type == 1) {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readSpace();\n            int x = inf.readInt(0, 1000000006, \"x\");\n            inf.readSpace();\n            int k = inf.readInt(0, 1000000006, \"k\");\n        } else {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    // Parse arguments\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string tree_type = opt<string>(\"treetype\", \"random\"); // chain, star, balanced, random\n    string query_type = opt<string>(\"querytype\", \"random\"); // alltype1, alltype2, mixed, negxik\n    int x_max = opt<int>(\"xmax\", 1000000006);\n    int k_max = opt<int>(\"kmax\", 1000000006);\n    \n    // Generate tree\n    vector<int> p(n + 1); // p[2..n]\n    if (tree_type == \"chain\") {\n        for (int i = 2; i <= n; ++i)\n            p[i] = i - 1;\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; ++i)\n            p[i] = 1;\n    } else if (tree_type == \"balanced\") {\n        // Build a balanced binary tree\n        for (int i = 2; i <= n; ++i)\n            p[i] = i / 2;\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i)\n            p[i] = rnd.next(1, i - 1);\n    }\n    \n    // Output n\n    printf(\"%d\\n\", n);\n    // Output parents p[2..n]\n    for (int i = 2; i <= n; ++i) {\n        printf(\"%d\", p[i]);\n        if (i != n) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    // Generate q queries\n    printf(\"%d\\n\", q);\n    \n    if (query_type == \"alltype1\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int x = rnd.next(0, x_max);\n            int k = rnd.next(0, k_max);\n            printf(\"1 %d %d %d\\n\", v, x, k);\n        }\n    } else if (query_type == \"alltype2\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            printf(\"2 %d\\n\", v);\n        }\n    } else if (query_type == \"mixed\") {\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 2);\n            if (type == 1) {\n                int v = rnd.next(1, n);\n                int x = rnd.next(0, x_max);\n                int k = rnd.next(0, k_max);\n                printf(\"1 %d %d %d\\n\", v, x, k);\n            } else {\n                int v = rnd.next(1, n);\n                printf(\"2 %d\\n\", v);\n            }\n        }\n    } else if (query_type == \"negxik\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int max_depth = 20; // Limit depth to prevent overflow\n            int depth = rnd.next(1, max_depth);\n            int k = rnd.next(1, min(k_max, 1000000006 / depth));\n            int x = rnd.next(0, k * depth);\n            printf(\"1 %d %d %d\\n\", v, x, k);\n        }\n    } else {\n        // default is random\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 2);\n            if (type == 1) {\n                int v = rnd.next(1, n);\n                int x = rnd.next(0, x_max);\n                int k = rnd.next(0, k_max);\n                printf(\"1 %d %d %d\\n\", v, x, k);\n            } else {\n                int v = rnd.next(1, n);\n                printf(\"2 %d\\n\", v);\n            }\n        }\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    // Parse arguments\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string tree_type = opt<string>(\"treetype\", \"random\"); // chain, star, balanced, random\n    string query_type = opt<string>(\"querytype\", \"random\"); // alltype1, alltype2, mixed, negxik\n    int x_max = opt<int>(\"xmax\", 1000000006);\n    int k_max = opt<int>(\"kmax\", 1000000006);\n    \n    // Generate tree\n    vector<int> p(n + 1); // p[2..n]\n    if (tree_type == \"chain\") {\n        for (int i = 2; i <= n; ++i)\n            p[i] = i - 1;\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; ++i)\n            p[i] = 1;\n    } else if (tree_type == \"balanced\") {\n        // Build a balanced binary tree\n        for (int i = 2; i <= n; ++i)\n            p[i] = i / 2;\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i)\n            p[i] = rnd.next(1, i - 1);\n    }\n    \n    // Output n\n    printf(\"%d\\n\", n);\n    // Output parents p[2..n]\n    for (int i = 2; i <= n; ++i) {\n        printf(\"%d\", p[i]);\n        if (i != n) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    // Generate q queries\n    printf(\"%d\\n\", q);\n    \n    if (query_type == \"alltype1\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int x = rnd.next(0, x_max);\n            int k = rnd.next(0, k_max);\n            printf(\"1 %d %d %d\\n\", v, x, k);\n        }\n    } else if (query_type == \"alltype2\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            printf(\"2 %d\\n\", v);\n        }\n    } else if (query_type == \"mixed\") {\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 2);\n            if (type == 1) {\n                int v = rnd.next(1, n);\n                int x = rnd.next(0, x_max);\n                int k = rnd.next(0, k_max);\n                printf(\"1 %d %d %d\\n\", v, x, k);\n            } else {\n                int v = rnd.next(1, n);\n                printf(\"2 %d\\n\", v);\n            }\n        }\n    } else if (query_type == \"negxik\") {\n        for (int i = 0; i < q; ++i) {\n            int v = rnd.next(1, n);\n            int max_depth = 20; // Limit depth to prevent overflow\n            int depth = rnd.next(1, max_depth);\n            int k = rnd.next(1, min(k_max, 1000000006 / depth));\n            int x = rnd.next(0, k * depth);\n            printf(\"1 %d %d %d\\n\", v, x, k);\n        }\n    } else {\n        // default is random\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 2);\n            if (type == 1) {\n                int v = rnd.next(1, n);\n                int x = rnd.next(0, x_max);\n                int k = rnd.next(0, k_max);\n                printf(\"1 %d %d %d\\n\", v, x, k);\n            } else {\n                int v = rnd.next(1, n);\n                printf(\"2 %d\\n\", v);\n            }\n        }\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -treetype chain -querytype alltype1\n./gen -n 1 -q 1 -treetype star -querytype alltype2\n\n./gen -n 10 -q 10 -treetype chain -querytype mixed\n./gen -n 10 -q 10 -treetype star -querytype mixed\n./gen -n 10 -q 10 -treetype balanced -querytype mixed\n./gen -n 10 -q 10 -treetype random -querytype mixed\n\n./gen -n 1000 -q 1000 -treetype chain -querytype alltype1\n./gen -n 1000 -q 1000 -treetype star -querytype alltype2\n./gen -n 1000 -q 1000 -treetype balanced -querytype random\n./gen -n 1000 -q 1000 -treetype random -querytype random\n\n./gen -n 100000 -q 100000 -treetype chain -querytype alltype1\n./gen -n 100000 -q 100000 -treetype star -querytype alltype2\n./gen -n 100000 -q 100000 -treetype balanced -querytype mixed\n./gen -n 100000 -q 100000 -treetype random -querytype mixed\n\n./gen -n 300000 -q 300000 -treetype chain -querytype mixed\n./gen -n 300000 -q 300000 -treetype star -querytype mixed\n./gen -n 300000 -q 300000 -treetype balanced -querytype mixed\n./gen -n 300000 -q 300000 -treetype random -querytype mixed\n\n./gen -n 100000 -q 100000 -treetype chain -querytype negxik -kmax 10\n./gen -n 100000 -q 100000 -treetype random -querytype negxik -kmax 10\n\n./gen -n 300000 -q 300000 -treetype random -querytype alltype1 -xmax 1000000006 -kmax 1000000006\n./gen -n 300000 -q 300000 -treetype random -querytype mixed -xmax 1000000006 -kmax 1000000006\n\n./gen -n 300000 -q 300000 -treetype random -querytype mixed -xmax 0 -kmax 0\n\n./gen -n 1000 -q 300000 -treetype random -querytype mixed\n\n./gen -n 300000 -q 1 -treetype random -querytype mixed\n\n./gen -n 1 -q 300000 -treetype random -querytype mixed\n\n./gen -n 300000 -q 300000 -treetype chain -querytype alltype1 -xmax 1000000006 -kmax 0\n\n./gen -n 300000 -q 300000 -treetype chain -querytype alltype2\n\n./gen -n 1000 -q 300000 -treetype random -querytype mixed\n\n./gen -n 300000 -q 300000 -treetype random -querytype negxik -kmax 100000\n\n./gen -n 300000 -q 300000 -treetype chain -querytype mixed -xmax 1000000006 -kmax 2\n\n./gen -n 300000 -q 300000 -treetype star -querytype mixed -xmax 1000000006 -kmax 2\n\n./gen -n 300000 -q 300000 -treetype balanced -querytype mixed -xmax 1000000006 -kmax 2\n\n./gen -n 300000 -q 300000 -treetype random -querytype mixed -xmax 1000000 -kmax 1000000\n\n./gen -n 1000 -q 300000 -treetype chain -querytype negxik -kmax 1000000006\n\n./gen -n 300000 -q 300000 -treetype random -querytype alltype1 -kmax 0\n\n./gen -n 300000 -q 300000 -treetype random -querytype alltype1 -xmax 0\n\n./gen -n 300000 -q 300000 -treetype random -querytype alltype2\n\n./gen -n 300000 -q 300000 -treetype random -querytype mixed\n\n./gen -n 300000 -q 300000 -treetype random -querytype mixed -kmax 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:36.300882",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "398/A",
      "title": "A. Карточки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке через пробел записаны два целых числа a и b (0 ≤ a, b ≤ 105; a + b ≥ 1) — количество карточек с «o» и количество карточек с «x».",
      "output_spec": "Выходные данныеВ первой строке выведите единственное целое число v — наибольший счет, которого может добиться ainta.Во второй строке выведите a + b символов, описывающих оптимальный ряд карточек. Если k-ая карта в ряду содержит символ «o», то k-ый символ должен равняться «o». Если k-тая карта в ряду содержит «x», то k-ый символ должен равняться «x». Количество символов «o» должно равняться a, а количество символов «x» должно равняться b. Если есть несколько способов максимизировать v, выведите любой из них.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных целых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 3Выходные данныеСкопировать-1xoxoxВходные данныеСкопировать4 0Выходные данныеСкопировать16ooooВходные данныеСкопировать0 4Выходные данныеСкопировать-16xxxx",
      "description": "A. Карточки\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке через пробел записаны два целых числа a и b (0 ≤ a, b ≤ 105; a + b ≥ 1) — количество карточек с «o» и количество карточек с «x».\n\nВходные данные\n\nВыходные данныеВ первой строке выведите единственное целое число v — наибольший счет, которого может добиться ainta.Во второй строке выведите a + b символов, описывающих оптимальный ряд карточек. Если k-ая карта в ряду содержит символ «o», то k-ый символ должен равняться «o». Если k-тая карта в ряду содержит «x», то k-ый символ должен равняться «x». Количество символов «o» должно равняться a, а количество символов «x» должно равняться b. Если есть несколько способов максимизировать v, выведите любой из них.Пожалуйста, не используйте спецификатор %lld для чтения или записи 64-битных целых чисел на С++. Рекомендуется использовать потоки cin, cout или спецификатор %I64d.\n\nВыходные данные\n\nВходные данныеСкопировать2 3Выходные данныеСкопировать-1xoxoxВходные данныеСкопировать4 0Выходные данныеСкопировать16ooooВходные данныеСкопировать0 4Выходные данныеСкопировать-16xxxx\n\nВходные данныеСкопировать2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1xoxox\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать16oooo\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать0 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-16xxxx\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces",
          "content": "First of all, sorry for being late :( I was quite depressed because of the server's chronic breakdown during the contest. Also, all the records for Round #233 was gone after the black day, so I thought not many people will be interested in the solution. I should have been more responsible for this. I really want to apologize for people who have been waiting for this editorial.During the contest, the only one user who solved this problem was: Petr. The contest was extended by 30 minutes, and if I remember correctly, he submitted the correct solution at about 2:25. So, congratulations to him!Now let me explain the solution. Let us start with the case when there is no hole. Given any permutation, I will prove that it takes only at most two seconds to sort it completely. Since every permutation can be decomposed into disjoint cycles (link), we only need to take care of each decomposed cycle. That is, we only need to sort a cycle of arbitrary length in two steps.Let's make a table of 3 rows and n columns. The first row will constitute the original, unsorted permutation. For each column, the next column will form the permutation after one second. The last column will be the sorted permutation. The following depicts the case where n = 5 and the permutation is a full cycle. 2 3 4 5 1\n? ? ? ? ?\n1 2 3 4 5Now we have to show that we can fill the second column properly. Let's just fill the first number in the second column randomly, say 4, and see what happens. 2 3 4 5 1\n4 ? ? ? ?\n1 2 3 4 5Because 4 replaces 2 in the second column, 2 replaces 4 and we are forced to put 2 below the 4 in first column. 2 3 4 5 1\n4 ? 2 ? ?\n1 2 3 4 5Likewise, 3 replaces 2 in the third column, so we should put 3 above 2 in the third column. 2 3 4 5 1\n4 3 2 ? ?\n1 2 3 4 5Repeating the process will finally give a complete, valid answer. 2 3 4 5 1\n4 3 2 1 5\n1 2 3 4 5Like the example above, filling the first number in the second column by any number will give a unique and valid answer. I won't prove it formally, but by experimenting with different examples you can see it indeed works :) So now we know that (i) any permutation can be sorted in 2 seconds and, additionally, (ii) if the permutation is a cycle, there are exactly n ways of doing it. Now let us see what happens if two disjoint cycles interact with each other. Try to fill the tables below and figure out what happens. First one is a disjoint union of cycles of length 4 and 5. Second one is a union of cycles of length 4 and 4. 2 3 4 5 1 7 8 9 6 2 3 4 1 6 7 8 5 \n8 ? ? ? ? ? ? ? ? 8 ? ? ? ? ? ? ? \n1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8By experimenting, you will see that if two disjoint cycles A and B interact (to be precise, when an element in A swaps place with another element in B), (i) the size of A and B are equal and in that case (ii) the number of ways to achieve a complete assignment for elements of A and B is exactly the size of A (or B). I won't prove it, but it can be done formally if one wishes to.Now we have the solution when there is no hole: decompose the permutation into disjoint cycles. Assume there are exactly ci cycles of length li for each i. Let a[c, l] be the number of ways to sort c cycles of length l completely. Then the answer will be , basically because only cycles of same length interact.To sort c cycles of length l, we can pair some of the cycles to interact with each other. Then each pair and unpaired cycle will contribute multiplicative factor l to the answer. Now we can derive a recursive formula for a[c, l]. Just take a cycle C and decide if it will be paired to different cycle or not. For the first case, C contributes multiplicative factor l and we can decide on the rest of c - 1 cycles, so there are total of l·a[c - 1, l] ways. For the second case, we have c - 1 ways to pair C with the other cycle, then the pair contributes factor l and we can decide on the remaining c - 2 cycles. This contributes l·(c - 1)·a[c - 2, l]. Adding up will give us the recursive formula. a[c, l] = l·a[c - 1, l] + l·(c - 1)·a[c - 2, l](I'm trying my best to explain the idea, but for this part i'm not quite satisfied with it. Ask or message me if you want more clear explanation)I will write the rest of the editorial tomorrow (my English is bad so it's quite hard to write), but I hope that this draft version will be helpful to you. Update It's almost been a year since I updated this editorial. I have nothing to say but that I was lazy... However, for the sake of completeness, I'll sketch up the rest of the solution.Computing every a[c, l] can be done in reasonable time: cl will be at most n / l and there will be total of values of a[c, l] to compute using the recursive formula above. Given a permutation, we can count the number of cycles cl of length l for each l and compute a[cl, l]. Since two cycles of different length cannot interact, the number of ways to sort the whole permutation will be the multiplication of a[cl, l]'s over all l. Finally, we have to deal with k ≤ 12 holes. The crucial observation is that with holes, the permutation decomposes into cycles and paths. Filling the holes will group the paths to disjoint cycles. Considering every 12! possible ways will give TLE. But if we note that the order of paths in a same group does not make a change in cycle's length, we can actually deploy a bitmask DP to consider all possible way to partition at most 12 paths. Just multiply some constant to each partition and sum over (I'll skip the details).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/11108",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5472
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces",
          "content": "Please write here if you had written some comments about any suggestions or questions on the announcement. There are a bunch of notification emails but I couldn't read most of them :(Here are the final top 100 : Div1, Div2. Congrats to the winners!(These links are all from google search cache, so it may be disappear) First of all, we are sorry to make this round unrated. This is an unexpected incident, and I believe that everyone in Codeforces would understand that. And second, we're sorry for estimating the difficulties of the problems wrong. Actually, I thought that somebody would get Accepted on 398A - Карточки within 5 minutes. But there wasn't any submissions during the first 4 minutes, and many people got wrong answer on pretests! I think almost everybody who solved this got at least one wrong answer.. I'm really sorry for measuring A easy. I think what cgy4ever said is right — it would be better not asking to print the sequence. At first, I purposed 398C - Дерево и массив as B(!!) because ainta solved it very easily than I expected. (I could hardly solve this, and thought it must be at least D, before I heard ainta's solution.) We're sorry for giving this problem the same score with 398B - Красим стену, which was much easier than 398C - Дерево и массив. Next time I'll remember that ainta is really a genius :) Congrats to four people who solved 398C - Дерево и массив during the contest! : cgy4ever, Shef, SillyHook06, and Qwaz. We are surprised that Petr solved 398E - Сортируем перестановки during the contest! Even though he implemented by Java, his solution is faster than ours :p Congratulations to him! Actually, we purposed an another problem for Div1-E, but the same problem popped out at OpenCup last Sunday, so we couldn't use that. Thanks to Gerald, who helped us preparing a new problem in such a short time. By the way, can you guess what problem was that? :D ... 399A - Страницы — Author : .o.You can solve this problem by just following the statement. First, print << if p - k > 1. Next, iterate all the integers from p - k to p + k, and print if the integer is in [1..n]. Finally, print >> if p + k < n. Time complexity: O(n). Code : 5926588 399B - Красные и синие шарики — Author : xtalclrChange the blue balls to bit 1, and blue balls to bit 0. Interpret the stack as an integer represented in binary digits. Now, one may see that a single operation decreases the integer by 1, and will be unavailable iff the integer becomes zero. So the answer will be 2a1 + 2a2 + ... + 2ak where the (ai + 1)-th (1 ≤ i ≤ k) ball is blue in the beginning. Time complexity: O(n) Code : 5926598 398A - Карточки — Author : .o.Let the number of o blocks p, and the number of x blocks q. It is obvious that |p - q| ≤ 1 and p, q ≤ n. So we can just iterate all p and q, and solve these two problems independently, and merge the answer.1. Maximize the value of x12 + x22 + ... + xp2 where x1 + x2 + ... + xp = a and xi ≥ 1. Assign a - p + 1 to x1, and assign 1 to x2, x3, ..., xp. The value is (a - p + 1)2 + (p - 1). 2. Minimize the value of y12 + y22 + ... + yq2 where y1 + y2 + ... + yq = b and yi ≥ 1. For all , assign to yi. For all , assign to yj. The value is . The proof is easy, so I won't do it. With this, we can solve the problem. We can print y1 xs, and then x1 os, ... Time complexity: O(n). Code : 5926607 Bonus: Is there any solution faster than O(n)? We tried to use ternary search, but we couldn't prove that was correct. 398B - Красим стену — Author : aintaThis can be solved by dynamic programming. Let T[i, j] the expected time when i rows and j columns doesn't have any painted cells inside.Let's see all the cases. If we carefully rearrange the order of rows and columns, we can divide the wall into 4 pieces. Choose a cell in rectangle 1. The size of this rectangle is i × j. The expectation value is T[i - 1, j - 1]. Choose a cell in rectangle 2. The size of this rectangle is i × (n - j). The expectation value is T[i - 1, j]. Choose a cell in rectangle 3. The size of this rectangle is (n - i) × j. The expectation value is T[i, j - 1]. Choose a cell in rectangle 4. The size of this rectangle is (n - i) × (n - j). The expectation value is T[i, j]. Merging these four cases, we can get:T[i, j] = 1 + {T[i - 1, j - 1] × i × j + T[i - 1, j] × i × (n - j) + T[i, j - 1] × (n - i) × j + T[i, j] × (n - i) × (n - j)} / n2Moving the T[i, j] on the right to the left, we can get the formula which can be used to calculate the value T[i, j]. There are some corner cases, like i = 0 or j = 0, but it can be simply handled. Time complexity: O(n2) Code : 5926617 398C - Дерево и массив — Author : .o.There are two intended solutions. One is easy, and the other is quite tricky.Easy SolutionMake a tree by the following method. For all , make an edge between vertex i and with weight 1. For all , make an edge between vertex i and i + 1 with weight . You can see that are all good pairs. In addition, (1, 3) is also a good pair. So we can print the answer.But, if n = 5, this method doesn't work because (1, 3) is not a good pair. In this case, one may solve by hand or using random algorithm. Time complexity: O(n) Code: 5926624 Bonus I: Is there any method to make more than good pairs? Bonus II: Is there any method that the maximum weight is relatively small and make at least good pairs? Tricky SolutionIf you got stuck with the problem, one can run any random algorithm that solves small cases, and merge these cases. With this approach, we can even limit the weight to a very small constant!But I think this is not a good solution, so I won't mention about unless anybody wants to know the details. I came up with this solution, and tried to purpose this as D. It seems all the 6 people who passed pretests during the contest didn't use this solution :) Time complexity: ??? Code : 5926632 398D - Мгновенные сообщения — Author : .o.Let xi an integer representing the state of the i-th user. If user i is online, xi  =  1, otherwise, xi  =  0. Also, let Si the set consisting of i-th friends.One can see that the queries become like this: Online/Offline: change the value of xi to 1  -  xi. Add: add u to set Sv, and v to set Su. Delete: delete u from set Sv, v from set Su. Count: calculate . Let's use sqrt-decomposition to perform these queries. Let user u heavy if |Su| ≥ C, or light otherwise. Also, we will define some arrays and sets: Hu is a set that stores friends with user u who are heavy users. O[u] stores the sum of . If the Online/Offline(u) query is given, If u is a light user: for all , change the value of O[v]. It takes O(|Su|) time. Otherwise: just update the state of itself. If the Add(u, v) query is given, If vertex u becomes heavy if we add this edge, for all , add v into Hw and update the value of O[w]. This can be done in O(C). If vertex u is still light even if we add the edge, update O[v]. This can be done in constant time. If vertex u is heavy (after the operations above), update Hv. Add u to set Sv, and v to set Su. If the Delete(u, v) query is given, Delete u from set Sv, and v from set Su. Update the value of O[*], Hu and Hv. Because for all |Hw| ≤  E| /  C, this can be done in O(|E| / C). If the counting query is given, will be the answer. Because |Hu| ≤ |E| / C, it will take O(|E| / C) time.So for each query, O(|E| / C) or O(C) time is required. To minimize the time, . Time complexity: Code : 5926635 We can also solve this by dividing the queries into parts. For each block, use O(n + m + q) time to build the online & offline state and the answer table for each vertices. For each query, you can use time to get the answer. If you want more details, please ask in the comments. Time complexity: Code : 5926640 398E - Сортируем перестановки — Author : xtalclr, eyTns, and great help of GeraldThe author is writing the solution, and it will come soon. Feel free to ask of or discuss about the solutions! Unfortunately, I don't know how to read or write Russian, so if you ask me in Russian, I can't response to it. (also, I think the Russian editorial won't be available..) Sorry for that.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10686",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 398\\s*A"
          },
          "content_length": 8084
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 1",
          "code": "2 3 4 5 1\n? ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 2",
          "code": "2 3 4 5 1\n? ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 3",
          "code": "2 3 4 5 1\n4 ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 4",
          "code": "2 3 4 5 1\n4 ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 5",
          "code": "2 3 4 5 1\n4 ? 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 6",
          "code": "2 3 4 5 1\n4 ? 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 7",
          "code": "2 3 4 5 1\n4 3 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 8",
          "code": "2 3 4 5 1\n4 3 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 9",
          "code": "2 3 4 5 1\n4 3 2 1 5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 10",
          "code": "2 3 4 5 1\n4 3 2 1 5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 11",
          "code": "2 3 4 5 1 7 8 9 6      2 3 4 1 6 7 8 5 \n8 ? ? ? ? ? ? ? ?      8 ? ? ? ? ? ? ? \n1 2 3 4 5 6 7 8 9      1 2 3 4 5 6 7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 12",
          "code": "2 3 4 5 1 7 8 9 6      2 3 4 1 6 7 8 5 \n8 ? ? ? ? ? ? ? ?      8 ? ? ? ? ? ? ? \n1 2 3 4 5 6 7 8 9      1 2 3 4 5 6 7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 1",
          "code": "unordered_set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 2",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 3",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 4",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 5",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 6",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 7",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(0, 100000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 100000, \"b\");\n    inf.readEoln();\n\n    ensuref(a + b >= 1, \"The sum of a and b must be at least 1, but a + b = %d\", a + b);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(0, 100000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 100000, \"b\");\n    inf.readEoln();\n\n    ensuref(a + b >= 1, \"The sum of a and b must be at least 1, but a + b = %d\", a + b);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(0, 100000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 100000, \"b\");\n    inf.readEoln();\n\n    ensuref(a + b >= 1, \"The sum of a and b must be at least 1, but a + b = %d\", a + b);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint a, b;\n\nlong long readAns(InStream& stream) {\n    // reads v\n    long long v = stream.readLong();\n\n    string s = stream.readToken(); // read arrangement string\n\n    // Validate s\n    if ((int)s.length() != a + b) {\n        stream.quitf(_wa, \"The arrangement length is %d, but expected %d\", (int)s.length(), a + b);\n    }\n\n    int count_o = 0, count_x = 0;\n\n    for (char c : s) {\n        if (c == 'o') {\n            count_o++;\n        } else if (c == 'x') {\n            count_x++;\n        } else {\n            stream.quitf(_wa, \"Invalid character '%c' in arrangement\", c);\n        }\n    }\n\n    if (count_o != a) {\n        stream.quitf(_wa, \"Number of 'o's in arrangement (%d) doesn't match expected (%d)\", count_o, a);\n    }\n    if (count_x != b) {\n        stream.quitf(_wa, \"Number of 'x's in arrangement (%d) doesn't match expected (%d)\", count_x, b);\n    }\n\n    // Compute the actual score from s\n    long long score = 0;\n    int len = s.length();\n\n    int i = 0;\n    while (i < len) {\n        char current_char = s[i];\n        int j = i;\n        while (j < len && s[j] == current_char) {\n            j++;\n        }\n        int block_length = j - i;\n        if (current_char == 'o') {\n            score += (long long)block_length * block_length;\n        } else if (current_char == 'x') {\n            score -= (long long)block_length * block_length;\n        }\n        i = j;\n    }\n\n    // Check that computed score equals v\n    if (score != v) {\n        stream.quitf(_wa, \"Computed score (%lld) does not match claimed score (%lld)\", score, v);\n    }\n\n    return v;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read a and b from inf\n    a = inf.readInt(0, 100000, \"a\");\n    b = inf.readInt(0, 100000, \"b\");\n\n    if (a + b < 1) {\n        quitf(_fail, \"a + b must be at least 1\");\n    }\n\n    long long v_jury = readAns(ans);\n    long long v_participant = readAns(ouf);\n\n    if (v_participant < v_jury) {\n        quitf(_wa, \"Participant's maximum score (%lld) is less than jury's maximum score (%lld)\", v_participant, v_jury);\n    } else if (v_participant == v_jury) {\n        quitf(_ok, \"Maximum score is %lld\", v_participant);\n    } else {\n        quitf(_fail, \"Participant's maximum score (%lld) is greater than jury's maximum score (%lld)\", v_participant, v_jury);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator outputs exactly one test (a single line) each time it is run.\n\n  Usage examples:\n    ./gen -type smallCorner1\n    ./gen -type randomSmall\n    ./gen -type randomLarge\n\n  It parses the parameter \"type\" (default = \"randomSmall\"), and depending on the type,\n  it will produce different pairs (a, b) within the required constraints:\n       0 <= a, b <= 100000\n       a + b >= 1\n*/\n\npair<int,int> randomPair(int Amax, int Bmax) {\n    // generate a random pair (a, b) in [0..Amax] x [0..Bmax], making sure a+b >= 1\n    while(true) {\n        int a = rnd.next(0, Amax);\n        int b = rnd.next(0, Bmax);\n        if(a + b >= 1) {\n            return make_pair(a, b);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // type of test we want to produce\n    string type = opt<string>(\"type\", \"randomSmall\");\n\n    // If you want to parametrize max ranges for your random pairs, you could also parse them:\n    //   int Amax = opt<int>(\"amax\", 100000);\n    //   int Bmax = opt<int>(\"bmax\", 100000);\n    // Here, for simplicity, we just hardcode some ranges.\n\n    int a = 0, b = 0; // final output\n\n    if (type == \"smallCorner1\") {\n        // a=0, b=1\n        a = 0; b = 1;\n    } else if (type == \"smallCorner2\") {\n        // a=1, b=0\n        a = 1; b = 0;\n    } else if (type == \"smallCorner3\") {\n        // a=5, b=0\n        a = 5; b = 0;\n    } else if (type == \"smallCorner4\") {\n        // a=0, b=5\n        a = 0; b = 5;\n    } else if (type == \"smallCorner5\") {\n        // a=1, b=1\n        a = 1; b = 1;\n    } else if (type == \"eq\") {\n        // a = b = 100\n        a = 100; b = 100;\n    } else if (type == \"eq2\") {\n        // a = b = 99999\n        a = 99999; b = 99999;\n    } else if (type == \"randomSmall\") {\n        // random in range up to 10\n        auto p = randomPair(10, 10);\n        a = p.first; b = p.second;\n    } else if (type == \"randomMed\") {\n        // random in range up to 100\n        auto p = randomPair(100, 100);\n        a = p.first; b = p.second;\n    } else if (type == \"randomLarge\") {\n        // random in range up to 100000\n        auto p = randomPair(100000, 100000);\n        a = p.first; b = p.second;\n    } else if (type == \"randomLarge2\") {\n        // random in range [50000..100000]\n        // We'll pick both a and b in [50000..100000] if possible, ensuring a+b >=1.\n        // But that trivially satisfies a+b >=1. Let's do it carefully:\n        // We'll do a random in [0..100000], b random in [50000..100000], or vice versa\n        // to mix it up. This is just an example, many variants are possible.\n        int half = 50000;\n        int pick = rnd.next(0, 1);\n        if (pick == 0) {\n            a = rnd.next(0, 100000);\n            b = rnd.next(half, 100000);\n        } else {\n            a = rnd.next(half, 100000);\n            b = rnd.next(0, 100000);\n        }\n        // ensure a+b >=1\n        if(a+b == 0) b = 1; // minimal fix\n    } else if (type == \"randomBigger\") {\n        // random in range [90000..100000]\n        // again, ensuring total >=1 is trivial except for a=b=0,\n        // so let's do it the same way\n        a = rnd.next(90000, 100000);\n        b = rnd.next(90000, 100000);\n    } else {\n        // default fallback: randomSmall\n        auto p = randomPair(10, 10);\n        a = p.first; b = p.second;\n    }\n\n    // Output the pair (a, b); this is the entire input to the solution.\n    cout << a << \" \" << b << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator outputs exactly one test (a single line) each time it is run.\n\n  Usage examples:\n    ./gen -type smallCorner1\n    ./gen -type randomSmall\n    ./gen -type randomLarge\n\n  It parses the parameter \"type\" (default = \"randomSmall\"), and depending on the type,\n  it will produce different pairs (a, b) within the required constraints:\n       0 <= a, b <= 100000\n       a + b >= 1\n*/\n\npair<int,int> randomPair(int Amax, int Bmax) {\n    // generate a random pair (a, b) in [0..Amax] x [0..Bmax], making sure a+b >= 1\n    while(true) {\n        int a = rnd.next(0, Amax);\n        int b = rnd.next(0, Bmax);\n        if(a + b >= 1) {\n            return make_pair(a, b);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // type of test we want to produce\n    string type = opt<string>(\"type\", \"randomSmall\");\n\n    // If you want to parametrize max ranges for your random pairs, you could also parse them:\n    //   int Amax = opt<int>(\"amax\", 100000);\n    //   int Bmax = opt<int>(\"bmax\", 100000);\n    // Here, for simplicity, we just hardcode some ranges.\n\n    int a = 0, b = 0; // final output\n\n    if (type == \"smallCorner1\") {\n        // a=0, b=1\n        a = 0; b = 1;\n    } else if (type == \"smallCorner2\") {\n        // a=1, b=0\n        a = 1; b = 0;\n    } else if (type == \"smallCorner3\") {\n        // a=5, b=0\n        a = 5; b = 0;\n    } else if (type == \"smallCorner4\") {\n        // a=0, b=5\n        a = 0; b = 5;\n    } else if (type == \"smallCorner5\") {\n        // a=1, b=1\n        a = 1; b = 1;\n    } else if (type == \"eq\") {\n        // a = b = 100\n        a = 100; b = 100;\n    } else if (type == \"eq2\") {\n        // a = b = 99999\n        a = 99999; b = 99999;\n    } else if (type == \"randomSmall\") {\n        // random in range up to 10\n        auto p = randomPair(10, 10);\n        a = p.first; b = p.second;\n    } else if (type == \"randomMed\") {\n        // random in range up to 100\n        auto p = randomPair(100, 100);\n        a = p.first; b = p.second;\n    } else if (type == \"randomLarge\") {\n        // random in range up to 100000\n        auto p = randomPair(100000, 100000);\n        a = p.first; b = p.second;\n    } else if (type == \"randomLarge2\") {\n        // random in range [50000..100000]\n        // We'll pick both a and b in [50000..100000] if possible, ensuring a+b >=1.\n        // But that trivially satisfies a+b >=1. Let's do it carefully:\n        // We'll do a random in [0..100000], b random in [50000..100000], or vice versa\n        // to mix it up. This is just an example, many variants are possible.\n        int half = 50000;\n        int pick = rnd.next(0, 1);\n        if (pick == 0) {\n            a = rnd.next(0, 100000);\n            b = rnd.next(half, 100000);\n        } else {\n            a = rnd.next(half, 100000);\n            b = rnd.next(0, 100000);\n        }\n        // ensure a+b >=1\n        if(a+b == 0) b = 1; // minimal fix\n    } else if (type == \"randomBigger\") {\n        // random in range [90000..100000]\n        // again, ensuring total >=1 is trivial except for a=b=0,\n        // so let's do it the same way\n        a = rnd.next(90000, 100000);\n        b = rnd.next(90000, 100000);\n    } else {\n        // default fallback: randomSmall\n        auto p = randomPair(10, 10);\n        a = p.first; b = p.second;\n    }\n\n    // Output the pair (a, b); this is the entire input to the solution.\n    cout << a << \" \" << b << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are about 20 distinct ways to run the generator.\n# Each command produces exactly one testcase.\n\n./gen -type smallCorner1\n./gen -type smallCorner2\n./gen -type smallCorner3\n./gen -type smallCorner4\n./gen -type smallCorner5\n\n./gen -type eq\n./gen -type eq2\n\n./gen -type randomSmall\n./gen -type randomSmall\n./gen -type randomSmall\n\n./gen -type randomMed\n./gen -type randomMed\n./gen -type randomMed\n\n./gen -type randomLarge\n./gen -type randomLarge\n./gen -type randomLarge\n\n./gen -type randomLarge2\n./gen -type randomLarge2\n\n./gen -type randomBigger\n./gen -type randomBigger\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:39.029879",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "398/B",
      "title": "B. Painting The Wall",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n ≤ 2·103; 0 ≤ m ≤ min(n2, 2·104)) — the size of the wall and the number of painted cells.Next m lines goes, each contains two integers ri and ci (1 ≤ ri, ci ≤ n) — the position of the painted cell. It is guaranteed that the positions are all distinct. Consider the rows of the table are numbered from 1 to n. Consider the columns of the table are numbered from 1 to n.",
      "output_spec": "OutputIn a single line print the expected time to paint the wall in minutes. Your answer will be considered correct if it has at most 10 - 4 absolute or relative error.",
      "sample_tests": "ExamplesInputCopy5 22 34 1OutputCopy11.7669491886InputCopy2 21 11 2OutputCopy2.0000000000InputCopy1 11 1OutputCopy0.0000000000",
      "description": "B. Painting The Wall\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n ≤ 2·103; 0 ≤ m ≤ min(n2, 2·104)) — the size of the wall and the number of painted cells.Next m lines goes, each contains two integers ri and ci (1 ≤ ri, ci ≤ n) — the position of the painted cell. It is guaranteed that the positions are all distinct. Consider the rows of the table are numbered from 1 to n. Consider the columns of the table are numbered from 1 to n.\n\nOutputIn a single line print the expected time to paint the wall in minutes. Your answer will be considered correct if it has at most 10 - 4 absolute or relative error.\n\nInputCopy5 22 34 1OutputCopy11.7669491886InputCopy2 21 11 2OutputCopy2.0000000000InputCopy1 11 1OutputCopy0.0000000000\n\nInputCopy5 22 34 1\n\nOutputCopy11.7669491886\n\nInputCopy2 21 11 2\n\nOutputCopy2.0000000000\n\nInputCopy1 11 1\n\nOutputCopy0.0000000000",
      "solutions": [
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces",
          "content": "First of all, sorry for being late :( I was quite depressed because of the server's chronic breakdown during the contest. Also, all the records for Round #233 was gone after the black day, so I thought not many people will be interested in the solution. I should have been more responsible for this. I really want to apologize for people who have been waiting for this editorial.During the contest, the only one user who solved this problem was: Petr. The contest was extended by 30 minutes, and if I remember correctly, he submitted the correct solution at about 2:25. So, congratulations to him!Now let me explain the solution. Let us start with the case when there is no hole. Given any permutation, I will prove that it takes only at most two seconds to sort it completely. Since every permutation can be decomposed into disjoint cycles (link), we only need to take care of each decomposed cycle. That is, we only need to sort a cycle of arbitrary length in two steps.Let's make a table of 3 rows and n columns. The first row will constitute the original, unsorted permutation. For each column, the next column will form the permutation after one second. The last column will be the sorted permutation. The following depicts the case where n = 5 and the permutation is a full cycle. 2 3 4 5 1\n? ? ? ? ?\n1 2 3 4 5Now we have to show that we can fill the second column properly. Let's just fill the first number in the second column randomly, say 4, and see what happens. 2 3 4 5 1\n4 ? ? ? ?\n1 2 3 4 5Because 4 replaces 2 in the second column, 2 replaces 4 and we are forced to put 2 below the 4 in first column. 2 3 4 5 1\n4 ? 2 ? ?\n1 2 3 4 5Likewise, 3 replaces 2 in the third column, so we should put 3 above 2 in the third column. 2 3 4 5 1\n4 3 2 ? ?\n1 2 3 4 5Repeating the process will finally give a complete, valid answer. 2 3 4 5 1\n4 3 2 1 5\n1 2 3 4 5Like the example above, filling the first number in the second column by any number will give a unique and valid answer. I won't prove it formally, but by experimenting with different examples you can see it indeed works :) So now we know that (i) any permutation can be sorted in 2 seconds and, additionally, (ii) if the permutation is a cycle, there are exactly n ways of doing it. Now let us see what happens if two disjoint cycles interact with each other. Try to fill the tables below and figure out what happens. First one is a disjoint union of cycles of length 4 and 5. Second one is a union of cycles of length 4 and 4. 2 3 4 5 1 7 8 9 6 2 3 4 1 6 7 8 5 \n8 ? ? ? ? ? ? ? ? 8 ? ? ? ? ? ? ? \n1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8By experimenting, you will see that if two disjoint cycles A and B interact (to be precise, when an element in A swaps place with another element in B), (i) the size of A and B are equal and in that case (ii) the number of ways to achieve a complete assignment for elements of A and B is exactly the size of A (or B). I won't prove it, but it can be done formally if one wishes to.Now we have the solution when there is no hole: decompose the permutation into disjoint cycles. Assume there are exactly ci cycles of length li for each i. Let a[c, l] be the number of ways to sort c cycles of length l completely. Then the answer will be , basically because only cycles of same length interact.To sort c cycles of length l, we can pair some of the cycles to interact with each other. Then each pair and unpaired cycle will contribute multiplicative factor l to the answer. Now we can derive a recursive formula for a[c, l]. Just take a cycle C and decide if it will be paired to different cycle or not. For the first case, C contributes multiplicative factor l and we can decide on the rest of c - 1 cycles, so there are total of l·a[c - 1, l] ways. For the second case, we have c - 1 ways to pair C with the other cycle, then the pair contributes factor l and we can decide on the remaining c - 2 cycles. This contributes l·(c - 1)·a[c - 2, l]. Adding up will give us the recursive formula. a[c, l] = l·a[c - 1, l] + l·(c - 1)·a[c - 2, l](I'm trying my best to explain the idea, but for this part i'm not quite satisfied with it. Ask or message me if you want more clear explanation)I will write the rest of the editorial tomorrow (my English is bad so it's quite hard to write), but I hope that this draft version will be helpful to you. Update It's almost been a year since I updated this editorial. I have nothing to say but that I was lazy... However, for the sake of completeness, I'll sketch up the rest of the solution.Computing every a[c, l] can be done in reasonable time: cl will be at most n / l and there will be total of values of a[c, l] to compute using the recursive formula above. Given a permutation, we can count the number of cycles cl of length l for each l and compute a[cl, l]. Since two cycles of different length cannot interact, the number of ways to sort the whole permutation will be the multiplication of a[cl, l]'s over all l. Finally, we have to deal with k ≤ 12 holes. The crucial observation is that with holes, the permutation decomposes into cycles and paths. Filling the holes will group the paths to disjoint cycles. Considering every 12! possible ways will give TLE. But if we note that the order of paths in a same group does not make a change in cycle's length, we can actually deploy a bitmask DP to consider all possible way to partition at most 12 paths. Just multiply some constant to each partition and sum over (I'll skip the details).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/11108",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5472
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces",
          "content": "Please write here if you had written some comments about any suggestions or questions on the announcement. There are a bunch of notification emails but I couldn't read most of them :(Here are the final top 100 : Div1, Div2. Congrats to the winners!(These links are all from google search cache, so it may be disappear) First of all, we are sorry to make this round unrated. This is an unexpected incident, and I believe that everyone in Codeforces would understand that. And second, we're sorry for estimating the difficulties of the problems wrong. Actually, I thought that somebody would get Accepted on 398A - Cards within 5 minutes. But there wasn't any submissions during the first 4 minutes, and many people got wrong answer on pretests! I think almost everybody who solved this got at least one wrong answer.. I'm really sorry for measuring A easy. I think what cgy4ever said is right — it would be better not asking to print the sequence. At first, I purposed 398C - Tree and Array as B(!!) because ainta solved it very easily than I expected. (I could hardly solve this, and thought it must be at least D, before I heard ainta's solution.) We're sorry for giving this problem the same score with 398B - Painting The Wall, which was much easier than 398C - Tree and Array. Next time I'll remember that ainta is really a genius :) Congrats to four people who solved 398C - Tree and Array during the contest! : cgy4ever, Shef, SillyHook06, and Qwaz. We are surprised that Petr solved 398E - Sorting Permutations during the contest! Even though he implemented by Java, his solution is faster than ours :p Congratulations to him! Actually, we purposed an another problem for Div1-E, but the same problem popped out at OpenCup last Sunday, so we couldn't use that. Thanks to Gerald, who helped us preparing a new problem in such a short time. By the way, can you guess what problem was that? :D ... 399A - Pages — Author : .o.You can solve this problem by just following the statement. First, print << if p - k > 1. Next, iterate all the integers from p - k to p + k, and print if the integer is in [1..n]. Finally, print >> if p + k < n. Time complexity: O(n). Code : 5926588 399B - Red and Blue Balls — Author : xtalclrChange the blue balls to bit 1, and blue balls to bit 0. Interpret the stack as an integer represented in binary digits. Now, one may see that a single operation decreases the integer by 1, and will be unavailable iff the integer becomes zero. So the answer will be 2a1 + 2a2 + ... + 2ak where the (ai + 1)-th (1 ≤ i ≤ k) ball is blue in the beginning. Time complexity: O(n) Code : 5926598 398A - Cards — Author : .o.Let the number of o blocks p, and the number of x blocks q. It is obvious that |p - q| ≤ 1 and p, q ≤ n. So we can just iterate all p and q, and solve these two problems independently, and merge the answer.1. Maximize the value of x12 + x22 + ... + xp2 where x1 + x2 + ... + xp = a and xi ≥ 1. Assign a - p + 1 to x1, and assign 1 to x2, x3, ..., xp. The value is (a - p + 1)2 + (p - 1). 2. Minimize the value of y12 + y22 + ... + yq2 where y1 + y2 + ... + yq = b and yi ≥ 1. For all , assign to yi. For all , assign to yj. The value is . The proof is easy, so I won't do it. With this, we can solve the problem. We can print y1 xs, and then x1 os, ... Time complexity: O(n). Code : 5926607 Bonus: Is there any solution faster than O(n)? We tried to use ternary search, but we couldn't prove that was correct. 398B - Painting The Wall — Author : aintaThis can be solved by dynamic programming. Let T[i, j] the expected time when i rows and j columns doesn't have any painted cells inside.Let's see all the cases. If we carefully rearrange the order of rows and columns, we can divide the wall into 4 pieces. Choose a cell in rectangle 1. The size of this rectangle is i × j. The expectation value is T[i - 1, j - 1]. Choose a cell in rectangle 2. The size of this rectangle is i × (n - j). The expectation value is T[i - 1, j]. Choose a cell in rectangle 3. The size of this rectangle is (n - i) × j. The expectation value is T[i, j - 1]. Choose a cell in rectangle 4. The size of this rectangle is (n - i) × (n - j). The expectation value is T[i, j]. Merging these four cases, we can get:T[i, j] = 1 + {T[i - 1, j - 1] × i × j + T[i - 1, j] × i × (n - j) + T[i, j - 1] × (n - i) × j + T[i, j] × (n - i) × (n - j)} / n2Moving the T[i, j] on the right to the left, we can get the formula which can be used to calculate the value T[i, j]. There are some corner cases, like i = 0 or j = 0, but it can be simply handled. Time complexity: O(n2) Code : 5926617 398C - Tree and Array — Author : .o.There are two intended solutions. One is easy, and the other is quite tricky.Easy SolutionMake a tree by the following method. For all , make an edge between vertex i and with weight 1. For all , make an edge between vertex i and i + 1 with weight . You can see that are all good pairs. In addition, (1, 3) is also a good pair. So we can print the answer.But, if n = 5, this method doesn't work because (1, 3) is not a good pair. In this case, one may solve by hand or using random algorithm. Time complexity: O(n) Code: 5926624 Bonus I: Is there any method to make more than good pairs? Bonus II: Is there any method that the maximum weight is relatively small and make at least good pairs? Tricky SolutionIf you got stuck with the problem, one can run any random algorithm that solves small cases, and merge these cases. With this approach, we can even limit the weight to a very small constant!But I think this is not a good solution, so I won't mention about unless anybody wants to know the details. I came up with this solution, and tried to purpose this as D. It seems all the 6 people who passed pretests during the contest didn't use this solution :) Time complexity: ??? Code : 5926632 398D - Instant Messanger — Author : .o.Let xi an integer representing the state of the i-th user. If user i is online, xi  =  1, otherwise, xi  =  0. Also, let Si the set consisting of i-th friends.One can see that the queries become like this: Online/Offline: change the value of xi to 1  -  xi. Add: add u to set Sv, and v to set Su. Delete: delete u from set Sv, v from set Su. Count: calculate . Let's use sqrt-decomposition to perform these queries. Let user u heavy if |Su| ≥ C, or light otherwise. Also, we will define some arrays and sets: Hu is a set that stores friends with user u who are heavy users. O[u] stores the sum of . If the Online/Offline(u) query is given, If u is a light user: for all , change the value of O[v]. It takes O(|Su|) time. Otherwise: just update the state of itself. If the Add(u, v) query is given, If vertex u becomes heavy if we add this edge, for all , add v into Hw and update the value of O[w]. This can be done in O(C). If vertex u is still light even if we add the edge, update O[v]. This can be done in constant time. If vertex u is heavy (after the operations above), update Hv. Add u to set Sv, and v to set Su. If the Delete(u, v) query is given, Delete u from set Sv, and v from set Su. Update the value of O[*], Hu and Hv. Because for all |Hw| ≤  E| /  C, this can be done in O(|E| / C). If the counting query is given, will be the answer. Because |Hu| ≤ |E| / C, it will take O(|E| / C) time.So for each query, O(|E| / C) or O(C) time is required. To minimize the time, . Time complexity: Code : 5926635 We can also solve this by dividing the queries into parts. For each block, use O(n + m + q) time to build the online & offline state and the answer table for each vertices. For each query, you can use time to get the answer. If you want more details, please ask in the comments. Time complexity: Code : 5926640 398E - Sorting Permutations — Author : xtalclr, eyTns, and great help of GeraldHere is the draft solution. Feel free to ask of or discuss about the solutions! Unfortunately, I don't know how to read or write Russian, so if you ask me in Russian, I can't response to it. (also, I think the Russian editorial won't be available..) Sorry for that.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10686",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 398\\s*B"
          },
          "content_length": 8039
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 1",
          "code": "2 3 4 5 1\n? ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 2",
          "code": "2 3 4 5 1\n? ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 3",
          "code": "2 3 4 5 1\n4 ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 4",
          "code": "2 3 4 5 1\n4 ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 5",
          "code": "2 3 4 5 1\n4 ? 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 6",
          "code": "2 3 4 5 1\n4 ? 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 7",
          "code": "2 3 4 5 1\n4 3 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 8",
          "code": "2 3 4 5 1\n4 3 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 9",
          "code": "2 3 4 5 1\n4 3 2 1 5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 10",
          "code": "2 3 4 5 1\n4 3 2 1 5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 11",
          "code": "2 3 4 5 1 7 8 9 6      2 3 4 1 6 7 8 5 \n8 ? ? ? ? ? ? ? ?      8 ? ? ? ? ? ? ? \n1 2 3 4 5 6 7 8 9      1 2 3 4 5 6 7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 12",
          "code": "2 3 4 5 1 7 8 9 6      2 3 4 1 6 7 8 5 \n8 ? ? ? ? ? ? ? ?      8 ? ? ? ? ? ? ? \n1 2 3 4 5 6 7 8 9      1 2 3 4 5 6 7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 1",
          "code": "unordered_set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 2",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 3",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 4",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 5",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 6",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 7",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int max_m = min(n * n, 20000);\n    int m = inf.readInt(0, max_m, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> positions;\n\n    for (int i = 0; i < m; i++) {\n        int ri = inf.readInt(1, n, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, n, \"ci\");\n        inf.readEoln();\n\n        pair<int, int> pos = make_pair(ri, ci);\n        ensuref(positions.count(pos) == 0, \"Duplicate position (%d, %d)\", ri, ci);\n        positions.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int max_m = min(n * n, 20000);\n    int m = inf.readInt(0, max_m, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> positions;\n\n    for (int i = 0; i < m; i++) {\n        int ri = inf.readInt(1, n, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, n, \"ci\");\n        inf.readEoln();\n\n        pair<int, int> pos = make_pair(ri, ci);\n        ensuref(positions.count(pos) == 0, \"Duplicate position (%d, %d)\", ri, ci);\n        positions.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int max_m = min(n * n, 20000);\n    int m = inf.readInt(0, max_m, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> positions;\n\n    for (int i = 0; i < m; i++) {\n        int ri = inf.readInt(1, n, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, n, \"ci\");\n        inf.readEoln();\n\n        pair<int, int> pos = make_pair(ri, ci);\n        ensuref(positions.count(pos) == 0, \"Duplicate position (%d, %d)\", ri, ci);\n        positions.insert(pos);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-4;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.5f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.5f', found: '%.5f', error = '%.5f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.5f', expected '%.5f', error '%.5f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0);\n    string type = opt<string>(\"type\", \"random\"); // 'random', 'fullrows', 'fullcols', 'onecellperrow', 'onecellpercol', 'diagonal', 'none'\n\n    int max_m = min(n * n, 20000);\n\n    // Ensure m is within valid range\n    m = min(m, max_m);\n\n    set<pair<int, int>> painted; // To store painted positions\n\n    if (type == \"none\") {\n        m = 0;\n    } else if (type == \"random\") {\n        // For large n*n, m ≤ 20000, so we can store m positions\n        while ((int)painted.size() < m) {\n            int r = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            painted.insert({r, c});\n        }\n    } else if (type == \"fullrows\") {\n        // Paint as many full rows as possible\n        int total_cells = min(m, max_m);\n        int full_rows = min(n, total_cells / n);\n        for (int r = 1; r <= full_rows; ++r) {\n            for (int c = 1; c <= n; ++c) {\n                painted.insert({r, c});\n            }\n        }\n        // If m > full_rows * n, paint random positions to reach m\n        while ((int)painted.size() < m) {\n            int r = rnd.next(full_rows + 1, n);\n            int c = rnd.next(1, n);\n            painted.insert({r, c});\n        }\n    } else if (type == \"fullcols\") {\n        // Paint as many full columns as possible\n        int total_cells = min(m, max_m);\n        int full_cols = min(n, total_cells / n);\n        for (int c = 1; c <= full_cols; ++c) {\n            for (int r = 1; r <= n; ++r) {\n                painted.insert({r, c});\n            }\n        }\n        // If m > full_cols * n, paint random positions to reach m\n        while ((int)painted.size() < m) {\n            int r = rnd.next(1, n);\n            int c = rnd.next(full_cols + 1, n);\n            painted.insert({r, c});\n        }\n    } else if (type == \"onecellperrow\") {\n        // Paint one cell per row\n        for (int r = 1; r <= n; ++r) {\n            int c = rnd.next(1, n);\n            painted.insert({r, c});\n        }\n        // If m > n, paint additional random positions\n        while ((int)painted.size() < m) {\n            int r = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            painted.insert({r, c});\n        }\n    } else if (type == \"onecellpercol\") {\n        // Paint one cell per column\n        for (int c = 1; c <= n; ++c) {\n            int r = rnd.next(1, n);\n            painted.insert({r, c});\n        }\n        // If m > n, paint additional random positions\n        while ((int)painted.size() < m) {\n            int r = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            painted.insert({r, c});\n        }\n    } else if (type == \"diagonal\") {\n        // m cannot exceed n\n        int diag_cells = min(n, m);\n        for (int i = 1; i <= diag_cells; ++i) {\n            painted.insert({i, i});\n        }\n        // If m > n, paint additional random positions\n        while ((int)painted.size() < m) {\n            int r = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            painted.insert({r, c});\n        }\n    } else {\n        // Default to random\n        while ((int)painted.size() < m) {\n            int r = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            painted.insert({r, c});\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the painted positions\n    for (const auto& p : painted) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0);\n    string type = opt<string>(\"type\", \"random\"); // 'random', 'fullrows', 'fullcols', 'onecellperrow', 'onecellpercol', 'diagonal', 'none'\n\n    int max_m = min(n * n, 20000);\n\n    // Ensure m is within valid range\n    m = min(m, max_m);\n\n    set<pair<int, int>> painted; // To store painted positions\n\n    if (type == \"none\") {\n        m = 0;\n    } else if (type == \"random\") {\n        // For large n*n, m ≤ 20000, so we can store m positions\n        while ((int)painted.size() < m) {\n            int r = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            painted.insert({r, c});\n        }\n    } else if (type == \"fullrows\") {\n        // Paint as many full rows as possible\n        int total_cells = min(m, max_m);\n        int full_rows = min(n, total_cells / n);\n        for (int r = 1; r <= full_rows; ++r) {\n            for (int c = 1; c <= n; ++c) {\n                painted.insert({r, c});\n            }\n        }\n        // If m > full_rows * n, paint random positions to reach m\n        while ((int)painted.size() < m) {\n            int r = rnd.next(full_rows + 1, n);\n            int c = rnd.next(1, n);\n            painted.insert({r, c});\n        }\n    } else if (type == \"fullcols\") {\n        // Paint as many full columns as possible\n        int total_cells = min(m, max_m);\n        int full_cols = min(n, total_cells / n);\n        for (int c = 1; c <= full_cols; ++c) {\n            for (int r = 1; r <= n; ++r) {\n                painted.insert({r, c});\n            }\n        }\n        // If m > full_cols * n, paint random positions to reach m\n        while ((int)painted.size() < m) {\n            int r = rnd.next(1, n);\n            int c = rnd.next(full_cols + 1, n);\n            painted.insert({r, c});\n        }\n    } else if (type == \"onecellperrow\") {\n        // Paint one cell per row\n        for (int r = 1; r <= n; ++r) {\n            int c = rnd.next(1, n);\n            painted.insert({r, c});\n        }\n        // If m > n, paint additional random positions\n        while ((int)painted.size() < m) {\n            int r = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            painted.insert({r, c});\n        }\n    } else if (type == \"onecellpercol\") {\n        // Paint one cell per column\n        for (int c = 1; c <= n; ++c) {\n            int r = rnd.next(1, n);\n            painted.insert({r, c});\n        }\n        // If m > n, paint additional random positions\n        while ((int)painted.size() < m) {\n            int r = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            painted.insert({r, c});\n        }\n    } else if (type == \"diagonal\") {\n        // m cannot exceed n\n        int diag_cells = min(n, m);\n        for (int i = 1; i <= diag_cells; ++i) {\n            painted.insert({i, i});\n        }\n        // If m > n, paint additional random positions\n        while ((int)painted.size() < m) {\n            int r = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            painted.insert({r, c});\n        }\n    } else {\n        // Default to random\n        while ((int)painted.size() < m) {\n            int r = rnd.next(1, n);\n            int c = rnd.next(1, n);\n            painted.insert({r, c});\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the painted positions\n    for (const auto& p : painted) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 0 -type none\n./gen -n 1 -m 1 -type random\n./gen -n 2 -m 0 -type none\n./gen -n 5 -m 3 -type random\n./gen -n 5 -m 25 -type random\n./gen -n 10 -m 50 -type random\n./gen -n 50 -m 2500 -type fullcols\n./gen -n 100 -m 0 -type none\n./gen -n 100 -m 10000 -type random\n./gen -n 141 -m 19881 -type random\n./gen -n 142 -m 20000 -type random\n./gen -n 1000 -m 0 -type none\n./gen -n 1000 -m 20000 -type random\n./gen -n 1000 -m 20000 -type fullrows\n./gen -n 1000 -m 20000 -type fullcols\n./gen -n 2000 -m 0 -type none\n./gen -n 2000 -m 20000 -type random\n./gen -n 2000 -m 20000 -type fullrows\n./gen -n 2000 -m 20000 -type fullcols\n./gen -n 2000 -m 2000 -type onecellperrow\n./gen -n 2000 -m 2000 -type onecellpercol\n./gen -n 2000 -m 20000 -type onecellperrow\n./gen -n 2000 -m 20000 -type onecellpercol\n./gen -n 2000 -m 1999 -type onecellperrow\n./gen -n 2000 -m 1999 -type onecellpercol\n./gen -n 2000 -m 20000 -type diagonal\n./gen -n 2000 -m 10 -type random\n./gen -n 2000 -m 20000 -type random\n./gen -n 2000 -m 0 -type none\n./gen -n 2000 -m 1 -type random\n./gen -n 2000 -m 1 -type diagonal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:41.299207",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "398/C",
      "title": "C. Tree and Array",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (5 ≤ n ≤ 105).",
      "output_spec": "OutputPrint n - 1 lines containing the description of the edges. The i-th line should contain three space-separated integers ui, vi, ci (1 ≤ ui < vi ≤ n; 1 ≤ ci ≤ 105) — two vertices connected by the edge, and the weight of the edge.Next print  lines containing the good pairs. The k-th line should contain two space-separated integers xk and yk (1 ≤ xk < yk ≤ n). Of course, xk, yk must be a good pair. All pairs should be distinct — that is, for all j, k , xj ≠ xk or yj ≠ yk must be satisfied.If there are many correct solutions, print any of them.",
      "sample_tests": "ExamplesInputCopy7OutputCopy1 4 11 2 22 3 53 5 32 6 26 7 34 55 65 7",
      "description": "C. Tree and Array\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (5 ≤ n ≤ 105).\n\nOutputPrint n - 1 lines containing the description of the edges. The i-th line should contain three space-separated integers ui, vi, ci (1 ≤ ui < vi ≤ n; 1 ≤ ci ≤ 105) — two vertices connected by the edge, and the weight of the edge.Next print  lines containing the good pairs. The k-th line should contain two space-separated integers xk and yk (1 ≤ xk < yk ≤ n). Of course, xk, yk must be a good pair. All pairs should be distinct — that is, for all j, k , xj ≠ xk or yj ≠ yk must be satisfied.If there are many correct solutions, print any of them.\n\nInputCopy7OutputCopy1 4 11 2 22 3 53 5 32 6 26 7 34 55 65 7\n\nOutputCopy1 4 11 2 22 3 53 5 32 6 26 7 34 55 65 7\n\nNote⌊x⌋ is the largest integer not greater than x.You can find the definition of a tree by the following link: http://en.wikipedia.org/wiki/Tree_(graph_theory)You can also find the definition of the shortest path by the following link: http://en.wikipedia.org/wiki/Shortest_path_problemThe tree and the array t in the sample output look like this:",
      "solutions": [
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces",
          "content": "First of all, sorry for being late :( I was quite depressed because of the server's chronic breakdown during the contest. Also, all the records for Round #233 was gone after the black day, so I thought not many people will be interested in the solution. I should have been more responsible for this. I really want to apologize for people who have been waiting for this editorial.During the contest, the only one user who solved this problem was: Petr. The contest was extended by 30 minutes, and if I remember correctly, he submitted the correct solution at about 2:25. So, congratulations to him!Now let me explain the solution. Let us start with the case when there is no hole. Given any permutation, I will prove that it takes only at most two seconds to sort it completely. Since every permutation can be decomposed into disjoint cycles (link), we only need to take care of each decomposed cycle. That is, we only need to sort a cycle of arbitrary length in two steps.Let's make a table of 3 rows and n columns. The first row will constitute the original, unsorted permutation. For each column, the next column will form the permutation after one second. The last column will be the sorted permutation. The following depicts the case where n = 5 and the permutation is a full cycle. 2 3 4 5 1\n? ? ? ? ?\n1 2 3 4 5Now we have to show that we can fill the second column properly. Let's just fill the first number in the second column randomly, say 4, and see what happens. 2 3 4 5 1\n4 ? ? ? ?\n1 2 3 4 5Because 4 replaces 2 in the second column, 2 replaces 4 and we are forced to put 2 below the 4 in first column. 2 3 4 5 1\n4 ? 2 ? ?\n1 2 3 4 5Likewise, 3 replaces 2 in the third column, so we should put 3 above 2 in the third column. 2 3 4 5 1\n4 3 2 ? ?\n1 2 3 4 5Repeating the process will finally give a complete, valid answer. 2 3 4 5 1\n4 3 2 1 5\n1 2 3 4 5Like the example above, filling the first number in the second column by any number will give a unique and valid answer. I won't prove it formally, but by experimenting with different examples you can see it indeed works :) So now we know that (i) any permutation can be sorted in 2 seconds and, additionally, (ii) if the permutation is a cycle, there are exactly n ways of doing it. Now let us see what happens if two disjoint cycles interact with each other. Try to fill the tables below and figure out what happens. First one is a disjoint union of cycles of length 4 and 5. Second one is a union of cycles of length 4 and 4. 2 3 4 5 1 7 8 9 6 2 3 4 1 6 7 8 5 \n8 ? ? ? ? ? ? ? ? 8 ? ? ? ? ? ? ? \n1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8By experimenting, you will see that if two disjoint cycles A and B interact (to be precise, when an element in A swaps place with another element in B), (i) the size of A and B are equal and in that case (ii) the number of ways to achieve a complete assignment for elements of A and B is exactly the size of A (or B). I won't prove it, but it can be done formally if one wishes to.Now we have the solution when there is no hole: decompose the permutation into disjoint cycles. Assume there are exactly ci cycles of length li for each i. Let a[c, l] be the number of ways to sort c cycles of length l completely. Then the answer will be , basically because only cycles of same length interact.To sort c cycles of length l, we can pair some of the cycles to interact with each other. Then each pair and unpaired cycle will contribute multiplicative factor l to the answer. Now we can derive a recursive formula for a[c, l]. Just take a cycle C and decide if it will be paired to different cycle or not. For the first case, C contributes multiplicative factor l and we can decide on the rest of c - 1 cycles, so there are total of l·a[c - 1, l] ways. For the second case, we have c - 1 ways to pair C with the other cycle, then the pair contributes factor l and we can decide on the remaining c - 2 cycles. This contributes l·(c - 1)·a[c - 2, l]. Adding up will give us the recursive formula. a[c, l] = l·a[c - 1, l] + l·(c - 1)·a[c - 2, l](I'm trying my best to explain the idea, but for this part i'm not quite satisfied with it. Ask or message me if you want more clear explanation)I will write the rest of the editorial tomorrow (my English is bad so it's quite hard to write), but I hope that this draft version will be helpful to you. Update It's almost been a year since I updated this editorial. I have nothing to say but that I was lazy... However, for the sake of completeness, I'll sketch up the rest of the solution.Computing every a[c, l] can be done in reasonable time: cl will be at most n / l and there will be total of values of a[c, l] to compute using the recursive formula above. Given a permutation, we can count the number of cycles cl of length l for each l and compute a[cl, l]. Since two cycles of different length cannot interact, the number of ways to sort the whole permutation will be the multiplication of a[cl, l]'s over all l. Finally, we have to deal with k ≤ 12 holes. The crucial observation is that with holes, the permutation decomposes into cycles and paths. Filling the holes will group the paths to disjoint cycles. Considering every 12! possible ways will give TLE. But if we note that the order of paths in a same group does not make a change in cycle's length, we can actually deploy a bitmask DP to consider all possible way to partition at most 12 paths. Just multiply some constant to each partition and sum over (I'll skip the details).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11108",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5472
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces",
          "content": "Please write here if you had written some comments about any suggestions or questions on the announcement. There are a bunch of notification emails but I couldn't read most of them :(Here are the final top 100 : Div1, Div2. Congrats to the winners!(These links are all from google search cache, so it may be disappear) First of all, we are sorry to make this round unrated. This is an unexpected incident, and I believe that everyone in Codeforces would understand that. And second, we're sorry for estimating the difficulties of the problems wrong. Actually, I thought that somebody would get Accepted on 398A - Cards within 5 minutes. But there wasn't any submissions during the first 4 minutes, and many people got wrong answer on pretests! I think almost everybody who solved this got at least one wrong answer.. I'm really sorry for measuring A easy. I think what cgy4ever said is right — it would be better not asking to print the sequence. At first, I purposed 398C - Tree and Array as B(!!) because ainta solved it very easily than I expected. (I could hardly solve this, and thought it must be at least D, before I heard ainta's solution.) We're sorry for giving this problem the same score with 398B - Painting The Wall, which was much easier than 398C - Tree and Array. Next time I'll remember that ainta is really a genius :) Congrats to four people who solved 398C - Tree and Array during the contest! : cgy4ever, Shef, SillyHook06, and Qwaz. We are surprised that Petr solved 398E - Sorting Permutations during the contest! Even though he implemented by Java, his solution is faster than ours :p Congratulations to him! Actually, we purposed an another problem for Div1-E, but the same problem popped out at OpenCup last Sunday, so we couldn't use that. Thanks to Gerald, who helped us preparing a new problem in such a short time. By the way, can you guess what problem was that? :D ... 399A - Pages — Author : .o.You can solve this problem by just following the statement. First, print << if p - k > 1. Next, iterate all the integers from p - k to p + k, and print if the integer is in [1..n]. Finally, print >> if p + k < n. Time complexity: O(n). Code : 5926588 399B - Red and Blue Balls — Author : xtalclrChange the blue balls to bit 1, and blue balls to bit 0. Interpret the stack as an integer represented in binary digits. Now, one may see that a single operation decreases the integer by 1, and will be unavailable iff the integer becomes zero. So the answer will be 2a1 + 2a2 + ... + 2ak where the (ai + 1)-th (1 ≤ i ≤ k) ball is blue in the beginning. Time complexity: O(n) Code : 5926598 398A - Cards — Author : .o.Let the number of o blocks p, and the number of x blocks q. It is obvious that |p - q| ≤ 1 and p, q ≤ n. So we can just iterate all p and q, and solve these two problems independently, and merge the answer.1. Maximize the value of x12 + x22 + ... + xp2 where x1 + x2 + ... + xp = a and xi ≥ 1. Assign a - p + 1 to x1, and assign 1 to x2, x3, ..., xp. The value is (a - p + 1)2 + (p - 1). 2. Minimize the value of y12 + y22 + ... + yq2 where y1 + y2 + ... + yq = b and yi ≥ 1. For all , assign to yi. For all , assign to yj. The value is . The proof is easy, so I won't do it. With this, we can solve the problem. We can print y1 xs, and then x1 os, ... Time complexity: O(n). Code : 5926607 Bonus: Is there any solution faster than O(n)? We tried to use ternary search, but we couldn't prove that was correct. 398B - Painting The Wall — Author : aintaThis can be solved by dynamic programming. Let T[i, j] the expected time when i rows and j columns doesn't have any painted cells inside.Let's see all the cases. If we carefully rearrange the order of rows and columns, we can divide the wall into 4 pieces. Choose a cell in rectangle 1. The size of this rectangle is i × j. The expectation value is T[i - 1, j - 1]. Choose a cell in rectangle 2. The size of this rectangle is i × (n - j). The expectation value is T[i - 1, j]. Choose a cell in rectangle 3. The size of this rectangle is (n - i) × j. The expectation value is T[i, j - 1]. Choose a cell in rectangle 4. The size of this rectangle is (n - i) × (n - j). The expectation value is T[i, j]. Merging these four cases, we can get:T[i, j] = 1 + {T[i - 1, j - 1] × i × j + T[i - 1, j] × i × (n - j) + T[i, j - 1] × (n - i) × j + T[i, j] × (n - i) × (n - j)} / n2Moving the T[i, j] on the right to the left, we can get the formula which can be used to calculate the value T[i, j]. There are some corner cases, like i = 0 or j = 0, but it can be simply handled. Time complexity: O(n2) Code : 5926617 398C - Tree and Array — Author : .o.There are two intended solutions. One is easy, and the other is quite tricky.Easy SolutionMake a tree by the following method. For all , make an edge between vertex i and with weight 1. For all , make an edge between vertex i and i + 1 with weight . You can see that are all good pairs. In addition, (1, 3) is also a good pair. So we can print the answer.But, if n = 5, this method doesn't work because (1, 3) is not a good pair. In this case, one may solve by hand or using random algorithm. Time complexity: O(n) Code: 5926624 Bonus I: Is there any method to make more than good pairs? Bonus II: Is there any method that the maximum weight is relatively small and make at least good pairs? Tricky SolutionIf you got stuck with the problem, one can run any random algorithm that solves small cases, and merge these cases. With this approach, we can even limit the weight to a very small constant!But I think this is not a good solution, so I won't mention about unless anybody wants to know the details. I came up with this solution, and tried to purpose this as D. It seems all the 6 people who passed pretests during the contest didn't use this solution :) Time complexity: ??? Code : 5926632 398D - Instant Messanger — Author : .o.Let xi an integer representing the state of the i-th user. If user i is online, xi  =  1, otherwise, xi  =  0. Also, let Si the set consisting of i-th friends.One can see that the queries become like this: Online/Offline: change the value of xi to 1  -  xi. Add: add u to set Sv, and v to set Su. Delete: delete u from set Sv, v from set Su. Count: calculate . Let's use sqrt-decomposition to perform these queries. Let user u heavy if |Su| ≥ C, or light otherwise. Also, we will define some arrays and sets: Hu is a set that stores friends with user u who are heavy users. O[u] stores the sum of . If the Online/Offline(u) query is given, If u is a light user: for all , change the value of O[v]. It takes O(|Su|) time. Otherwise: just update the state of itself. If the Add(u, v) query is given, If vertex u becomes heavy if we add this edge, for all , add v into Hw and update the value of O[w]. This can be done in O(C). If vertex u is still light even if we add the edge, update O[v]. This can be done in constant time. If vertex u is heavy (after the operations above), update Hv. Add u to set Sv, and v to set Su. If the Delete(u, v) query is given, Delete u from set Sv, and v from set Su. Update the value of O[*], Hu and Hv. Because for all |Hw| ≤  E| /  C, this can be done in O(|E| / C). If the counting query is given, will be the answer. Because |Hu| ≤ |E| / C, it will take O(|E| / C) time.So for each query, O(|E| / C) or O(C) time is required. To minimize the time, . Time complexity: Code : 5926635 We can also solve this by dividing the queries into parts. For each block, use O(n + m + q) time to build the online & offline state and the answer table for each vertices. For each query, you can use time to get the answer. If you want more details, please ask in the comments. Time complexity: Code : 5926640 398E - Sorting Permutations — Author : xtalclr, eyTns, and great help of GeraldHere is the draft solution. Feel free to ask of or discuss about the solutions! Unfortunately, I don't know how to read or write Russian, so if you ask me in Russian, I can't response to it. (also, I think the Russian editorial won't be available..) Sorry for that.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10686",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 398\\s*C"
          },
          "content_length": 8039
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 1",
          "code": "2 3 4 5 1\n? ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 2",
          "code": "2 3 4 5 1\n? ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 3",
          "code": "2 3 4 5 1\n4 ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 4",
          "code": "2 3 4 5 1\n4 ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 5",
          "code": "2 3 4 5 1\n4 ? 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 6",
          "code": "2 3 4 5 1\n4 ? 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 7",
          "code": "2 3 4 5 1\n4 3 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 8",
          "code": "2 3 4 5 1\n4 3 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 9",
          "code": "2 3 4 5 1\n4 3 2 1 5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 10",
          "code": "2 3 4 5 1\n4 3 2 1 5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 11",
          "code": "2 3 4 5 1 7 8 9 6      2 3 4 1 6 7 8 5 \n8 ? ? ? ? ? ? ? ?      8 ? ? ? ? ? ? ? \n1 2 3 4 5 6 7 8 9      1 2 3 4 5 6 7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 12",
          "code": "2 3 4 5 1 7 8 9 6      2 3 4 1 6 7 8 5 \n8 ? ? ? ? ? ? ? ?      8 ? ? ? ? ? ? ? \n1 2 3 4 5 6 7 8 9      1 2 3 4 5 6 7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 1",
          "code": "unordered_set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 2",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 3",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 4",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 5",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 6",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 7",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(5, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(5, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(5, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\nconst int LOGN = 18;\n\nvector<pair<int, int>> adj[MAXN]; // adjacency list with weights\nint parent[MAXN][LOGN]; // parent[u][k] = 2^k-th ancestor of u\nint depth[MAXN];\nlong long dist[MAXN]; // distance from root node\n\nint n;\nlong long t[MAXN];\nlong long prefix_t[MAXN];\n\nvoid dfs(int u, int p) {\n    parent[u][0] = p;\n    for (int k = 1; k < LOGN; k++) {\n        parent[u][k] = parent[parent[u][k - 1]][k - 1];\n    }\n    for (auto &edge : adj[u]) {\n        int v = edge.first;\n        int w = edge.second;\n        if (v != p) {\n            depth[v] = depth[u] + 1;\n            dist[v] = dist[u] + w;\n            dfs(v, u);\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v]) swap(u, v);\n    for (int k = LOGN - 1; k >= 0; k--) {\n        if (depth[u] - (1 << k) >= depth[v]) {\n            u = parent[u][k];\n        }\n    }\n    if (u == v) return u;\n    for (int k = LOGN - 1; k >= 0; k--) {\n        if (parent[u][k] != parent[v][k]) {\n            u = parent[u][k];\n            v = parent[v][k];\n        }\n    }\n    return parent[u][0];\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    n = inf.readInt(5, 100000, \"n\");\n    // Initialize\n    for (int i = 1; i <= n; i++) {\n        adj[i].clear();\n    }\n    int m = n - 1;\n    vector<int> u_list(m), v_list(m), c_list(m);\n    vector<int> parent_union_find(n + 1);\n\n    for (int i = 1; i <= n; i++) {\n        parent_union_find[i] = i;\n    }\n\n    function<int(int)> find = [&](int x) {\n        if (parent_union_find[x] != x) {\n            parent_union_find[x] = find(parent_union_find[x]);\n        }\n        return parent_union_find[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return false;\n        parent_union_find[y] = x;\n        return true;\n    };\n\n    // Read edges\n    for (int i = 0; i < m; i++) {\n        int u = ouf.readInt(1, n, format(\"u[%d]\", i + 1).c_str());\n        int v = ouf.readInt(1, n, format(\"v[%d]\", i + 1).c_str());\n        if (u >= v) {\n            ouf.quitf(_wa, \"Edge %d: u (%d) is not less than v (%d)\", i + 1, u, v);\n        }\n        int c = ouf.readInt(1, 100000, format(\"c[%d]\", i + 1).c_str());\n        u_list[i] = u;\n        v_list[i] = v;\n        c_list[i] = c;\n        if (!unite(u, v)) {\n            ouf.quitf(_wa, \"Edge %d: adding edge (%d, %d) creates a cycle\", i + 1, u, v);\n        }\n        adj[u].push_back({v, c});\n        adj[v].push_back({u, c});\n    }\n    // Check if the graph is connected\n    int connected_components = 0;\n    for (int i = 1; i <= n; i++) {\n        if (find(i) == i) {\n            connected_components++;\n        }\n    }\n    if (connected_components != 1) {\n        ouf.quitf(_wa, \"The graph is not connected\");\n    }\n\n    // Build the difference array\n    vector<long long> diff(n + 2, 0); // using 1-based index\n\n    for (int i = 0; i < m; i++) {\n        int u = u_list[i];\n        int v = v_list[i];\n        int c = c_list[i];\n        diff[u] += c;\n        diff[v + 1] -= c;\n    }\n\n    // Compute t[i]\n    for (int i = 1; i <= n; i++) {\n        diff[i] += diff[i - 1];\n        t[i] = diff[i];\n    }\n\n    // Compute prefix sums of t\n    prefix_t[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        prefix_t[i] = prefix_t[i - 1] + t[i];\n    }\n\n    // Build depth and dist arrays\n    depth[1] = 0;\n    dist[1] = 0;\n    dfs(1, 0);\n\n    // Read k = floor(n / 2)\n    int k = n / 2;\n    set<pair<int, int>> good_pairs;\n    for (int i = 0; i < k; i++) {\n        int x = ouf.readInt(1, n, format(\"x[%d]\", i + 1).c_str());\n        int y = ouf.readInt(1, n, format(\"y[%d]\", i + 1).c_str());\n        if (x >= y) {\n            ouf.quitf(_wa, \"Pair %d: x (%d) is not less than y (%d)\", i +1, x, y);\n        }\n        if (good_pairs.count({x, y})) {\n            ouf.quitf(_wa, \"Pair %d: pair (%d, %d) is not distinct\", i +1, x, y);\n        }\n        if (x < 1 || x > n || y < 1 || y > n) {\n            ouf.quitf(_wa, \"Pair %d: x (%d) or y (%d) is out of range\", i + 1, x, y);\n        }\n        good_pairs.insert({x, y});\n        // Compute d(x, y)\n        int l = lca(x, y);\n        long long d_xy = dist[x] + dist[y] - 2 * dist[l];\n        long long s = prefix_t[y] - prefix_t[x - 1];\n        if (d_xy != s) {\n            ouf.quitf(_wa, \"Pair %d: d(%d, %d) = %lld, sum of t[%d..%d] = %lld; they are not equal\", i + 1, x, y, d_xy, x, y, s);\n        }\n    }\n\n    // All checks passed\n    ouf.quitf(_ok, \"Correct solution\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Mandatory for using testlib with a generator.\n    registerGen(argc, argv, 1);\n\n    /*\n      The problem states that the only input is a single integer n,\n      with 5 ≤ n ≤ 100000 (1e5).\n\n      This generator, at a high level, will produce exactly one line\n      containing a valid n, based on parameters provided from the\n      command line.  \n\n      Usage examples (see the bash commands below):\n      1)  ./gen -n 10 -type fixed\n           => will output \"10\"\n      2)  ./gen -type min\n           => will output \"5\"\n      3)  ./gen -type max\n           => will output \"100000\"\n      4)  ./gen -type random\n           => will output a random n in [5 .. 100000]\n    */\n\n    // Parse parameters from the command line:\n    int n = opt<int>(\"n\", 10);             // Default n = 10 if not supplied\n    string type = opt<string>(\"type\", \"fixed\");\n\n    // Adjust n depending on \"type\"\n    if (type == \"min\") {\n        // Minimum boundary\n        n = 5;\n    } \n    else if (type == \"max\") {\n        // Maximum boundary\n        n = 100000;\n    }\n    else if (type == \"random\") {\n        // Generate a random n in [5 .. 100000]\n        const int MINN = 5, MAXN = 100000;\n        n = rnd.next(MINN, MAXN);\n    }\n    // Otherwise, \"type == fixed\" => just use the user-supplied -n.\n\n    // Ensure constraints:\n    // (Not strictly necessary if the user does not pass invalid args, \n    //  but just in case:)\n    n = max(n, 5);\n    n = min(n, 100000);\n\n    // Print the test case (which, for this problem, is just one integer).\n    cout << n << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Mandatory for using testlib with a generator.\n    registerGen(argc, argv, 1);\n\n    /*\n      The problem states that the only input is a single integer n,\n      with 5 ≤ n ≤ 100000 (1e5).\n\n      This generator, at a high level, will produce exactly one line\n      containing a valid n, based on parameters provided from the\n      command line.  \n\n      Usage examples (see the bash commands below):\n      1)  ./gen -n 10 -type fixed\n           => will output \"10\"\n      2)  ./gen -type min\n           => will output \"5\"\n      3)  ./gen -type max\n           => will output \"100000\"\n      4)  ./gen -type random\n           => will output a random n in [5 .. 100000]\n    */\n\n    // Parse parameters from the command line:\n    int n = opt<int>(\"n\", 10);             // Default n = 10 if not supplied\n    string type = opt<string>(\"type\", \"fixed\");\n\n    // Adjust n depending on \"type\"\n    if (type == \"min\") {\n        // Minimum boundary\n        n = 5;\n    } \n    else if (type == \"max\") {\n        // Maximum boundary\n        n = 100000;\n    }\n    else if (type == \"random\") {\n        // Generate a random n in [5 .. 100000]\n        const int MINN = 5, MAXN = 100000;\n        n = rnd.next(MINN, MAXN);\n    }\n    // Otherwise, \"type == fixed\" => just use the user-supplied -n.\n\n    // Ensure constraints:\n    // (Not strictly necessary if the user does not pass invalid args, \n    //  but just in case:)\n    n = max(n, 5);\n    n = min(n, 100000);\n\n    // Print the test case (which, for this problem, is just one integer).\n    cout << n << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# 1) Smallest valid n\n./gen -type min\n\n# 2) Largest valid n\n./gen -type max\n\n# 3) A fixed value for n = 5\n./gen -n 5 -type fixed\n\n# 4) A fixed value for n = 6\n./gen -n 6 -type fixed\n\n# 5) A fixed value for n = 7\n./gen -n 7 -type fixed\n\n# 6) A fixed value for n = 10\n./gen -n 10 -type fixed\n\n# 7) A fixed value for n = 11\n./gen -n 11 -type fixed\n\n# 8) A fixed value for n = 50\n./gen -n 50 -type fixed\n\n# 9) A fixed value for n = 99\n./gen -n 99 -type fixed\n\n# 10) A fixed value for n = 100\n./gen -n 100 -type fixed\n\n# 11) A fixed value for n = 99999\n./gen -n 99999 -type fixed\n\n# 12) Another large fixed\n./gen -n 99998 -type fixed\n\n# 13) Random n in [5..100000]\n./gen -type random\n\n# 14) Another random\n./gen -type random\n\n# 15) Another random\n./gen -type random\n\n# 16) A medium fixed n = 1234\n./gen -n 1234 -type fixed\n\n# 17) Another medium fixed n = 2022\n./gen -n 2022 -type fixed\n\n# 18) Another medium fixed n = 50000\n./gen -n 50000 -type fixed\n\n# 19) Another random\n./gen -type random\n\n# 20) Another random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:43.670108",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "398/D",
      "title": "D. Instant Messanger",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers n, m and q (1 ≤ n ≤ 50000; 1 ≤ m ≤ 150000; 1 ≤ q ≤ 250000) — the number of users, the number of pairs of friends, and the number of queries.The second line contains an integer o (1 ≤ o ≤ n) — the number of online users at the beginning. The third line contains o space-separated integers x1, x2, ..., xo (1 ≤ xi ≤ n) — the ids of the online users. It is guaranteed that these values are distinct.Each of the next m lines contains two space-separated integers ai and bi (1 ≤ ai, bi ≤ n; ai ≠ bi) — the ids of two users who are friends at the beginning. It is guaranteed there are no multiple friendship given in the input. Note that the friendship is bidirectional.Next q lines describe the q queries in the format:  \"O u\" (1 ≤ u ≤ n) : Call online(u). It is guaranteed that user u was offline just before the function call.  \"F u\" (1 ≤ u ≤ n) : Call offline(u). It is guaranteed that user u was online just before the function call.  \"A u v\" (1 ≤ u, v ≤ n; u ≠ v) : Call add_friend(u, v). It is guaranteed that these two users weren't friends just before the function call.  \"D u v\" (1 ≤ u, v ≤ n; u ≠ v) : Call del_friend(u, v). It is guaranteed that these two users were friends just before the function call.  \"C u\" (1 ≤ u ≤ n) : Call count_online_friends(u) and print the result in a single line.",
      "output_spec": "OutputFor each count_online_friends(u) query, print the required answer in a single line.",
      "sample_tests": "ExamplesInputCopy5 2 9141 33 4C 3A 2 5O 1D 1 3A 1 2A 4 2C 2F 4C 2OutputCopy121",
      "description": "D. Instant Messanger\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers n, m and q (1 ≤ n ≤ 50000; 1 ≤ m ≤ 150000; 1 ≤ q ≤ 250000) — the number of users, the number of pairs of friends, and the number of queries.The second line contains an integer o (1 ≤ o ≤ n) — the number of online users at the beginning. The third line contains o space-separated integers x1, x2, ..., xo (1 ≤ xi ≤ n) — the ids of the online users. It is guaranteed that these values are distinct.Each of the next m lines contains two space-separated integers ai and bi (1 ≤ ai, bi ≤ n; ai ≠ bi) — the ids of two users who are friends at the beginning. It is guaranteed there are no multiple friendship given in the input. Note that the friendship is bidirectional.Next q lines describe the q queries in the format:  \"O u\" (1 ≤ u ≤ n) : Call online(u). It is guaranteed that user u was offline just before the function call.  \"F u\" (1 ≤ u ≤ n) : Call offline(u). It is guaranteed that user u was online just before the function call.  \"A u v\" (1 ≤ u, v ≤ n; u ≠ v) : Call add_friend(u, v). It is guaranteed that these two users weren't friends just before the function call.  \"D u v\" (1 ≤ u, v ≤ n; u ≠ v) : Call del_friend(u, v). It is guaranteed that these two users were friends just before the function call.  \"C u\" (1 ≤ u ≤ n) : Call count_online_friends(u) and print the result in a single line.\n\nOutputFor each count_online_friends(u) query, print the required answer in a single line.\n\nInputCopy5 2 9141 33 4C 3A 2 5O 1D 1 3A 1 2A 4 2C 2F 4C 2OutputCopy121\n\nInputCopy5 2 9141 33 4C 3A 2 5O 1D 1 3A 1 2A 4 2C 2F 4C 2\n\nOutputCopy121",
      "solutions": [
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces",
          "content": "First of all, sorry for being late :( I was quite depressed because of the server's chronic breakdown during the contest. Also, all the records for Round #233 was gone after the black day, so I thought not many people will be interested in the solution. I should have been more responsible for this. I really want to apologize for people who have been waiting for this editorial.During the contest, the only one user who solved this problem was: Petr. The contest was extended by 30 minutes, and if I remember correctly, he submitted the correct solution at about 2:25. So, congratulations to him!Now let me explain the solution. Let us start with the case when there is no hole. Given any permutation, I will prove that it takes only at most two seconds to sort it completely. Since every permutation can be decomposed into disjoint cycles (link), we only need to take care of each decomposed cycle. That is, we only need to sort a cycle of arbitrary length in two steps.Let's make a table of 3 rows and n columns. The first row will constitute the original, unsorted permutation. For each column, the next column will form the permutation after one second. The last column will be the sorted permutation. The following depicts the case where n = 5 and the permutation is a full cycle. 2 3 4 5 1\n? ? ? ? ?\n1 2 3 4 5Now we have to show that we can fill the second column properly. Let's just fill the first number in the second column randomly, say 4, and see what happens. 2 3 4 5 1\n4 ? ? ? ?\n1 2 3 4 5Because 4 replaces 2 in the second column, 2 replaces 4 and we are forced to put 2 below the 4 in first column. 2 3 4 5 1\n4 ? 2 ? ?\n1 2 3 4 5Likewise, 3 replaces 2 in the third column, so we should put 3 above 2 in the third column. 2 3 4 5 1\n4 3 2 ? ?\n1 2 3 4 5Repeating the process will finally give a complete, valid answer. 2 3 4 5 1\n4 3 2 1 5\n1 2 3 4 5Like the example above, filling the first number in the second column by any number will give a unique and valid answer. I won't prove it formally, but by experimenting with different examples you can see it indeed works :) So now we know that (i) any permutation can be sorted in 2 seconds and, additionally, (ii) if the permutation is a cycle, there are exactly n ways of doing it. Now let us see what happens if two disjoint cycles interact with each other. Try to fill the tables below and figure out what happens. First one is a disjoint union of cycles of length 4 and 5. Second one is a union of cycles of length 4 and 4. 2 3 4 5 1 7 8 9 6 2 3 4 1 6 7 8 5 \n8 ? ? ? ? ? ? ? ? 8 ? ? ? ? ? ? ? \n1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8By experimenting, you will see that if two disjoint cycles A and B interact (to be precise, when an element in A swaps place with another element in B), (i) the size of A and B are equal and in that case (ii) the number of ways to achieve a complete assignment for elements of A and B is exactly the size of A (or B). I won't prove it, but it can be done formally if one wishes to.Now we have the solution when there is no hole: decompose the permutation into disjoint cycles. Assume there are exactly ci cycles of length li for each i. Let a[c, l] be the number of ways to sort c cycles of length l completely. Then the answer will be , basically because only cycles of same length interact.To sort c cycles of length l, we can pair some of the cycles to interact with each other. Then each pair and unpaired cycle will contribute multiplicative factor l to the answer. Now we can derive a recursive formula for a[c, l]. Just take a cycle C and decide if it will be paired to different cycle or not. For the first case, C contributes multiplicative factor l and we can decide on the rest of c - 1 cycles, so there are total of l·a[c - 1, l] ways. For the second case, we have c - 1 ways to pair C with the other cycle, then the pair contributes factor l and we can decide on the remaining c - 2 cycles. This contributes l·(c - 1)·a[c - 2, l]. Adding up will give us the recursive formula. a[c, l] = l·a[c - 1, l] + l·(c - 1)·a[c - 2, l](I'm trying my best to explain the idea, but for this part i'm not quite satisfied with it. Ask or message me if you want more clear explanation)I will write the rest of the editorial tomorrow (my English is bad so it's quite hard to write), but I hope that this draft version will be helpful to you. Update It's almost been a year since I updated this editorial. I have nothing to say but that I was lazy... However, for the sake of completeness, I'll sketch up the rest of the solution.Computing every a[c, l] can be done in reasonable time: cl will be at most n / l and there will be total of values of a[c, l] to compute using the recursive formula above. Given a permutation, we can count the number of cycles cl of length l for each l and compute a[cl, l]. Since two cycles of different length cannot interact, the number of ways to sort the whole permutation will be the multiplication of a[cl, l]'s over all l. Finally, we have to deal with k ≤ 12 holes. The crucial observation is that with holes, the permutation decomposes into cycles and paths. Filling the holes will group the paths to disjoint cycles. Considering every 12! possible ways will give TLE. But if we note that the order of paths in a same group does not make a change in cycle's length, we can actually deploy a bitmask DP to consider all possible way to partition at most 12 paths. Just multiply some constant to each partition and sum over (I'll skip the details).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11108",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5472
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces",
          "content": "Please write here if you had written some comments about any suggestions or questions on the announcement. There are a bunch of notification emails but I couldn't read most of them :(Here are the final top 100 : Div1, Div2. Congrats to the winners!(These links are all from google search cache, so it may be disappear) First of all, we are sorry to make this round unrated. This is an unexpected incident, and I believe that everyone in Codeforces would understand that. And second, we're sorry for estimating the difficulties of the problems wrong. Actually, I thought that somebody would get Accepted on 398A - Cards within 5 minutes. But there wasn't any submissions during the first 4 minutes, and many people got wrong answer on pretests! I think almost everybody who solved this got at least one wrong answer.. I'm really sorry for measuring A easy. I think what cgy4ever said is right — it would be better not asking to print the sequence. At first, I purposed 398C - Tree and Array as B(!!) because ainta solved it very easily than I expected. (I could hardly solve this, and thought it must be at least D, before I heard ainta's solution.) We're sorry for giving this problem the same score with 398B - Painting The Wall, which was much easier than 398C - Tree and Array. Next time I'll remember that ainta is really a genius :) Congrats to four people who solved 398C - Tree and Array during the contest! : cgy4ever, Shef, SillyHook06, and Qwaz. We are surprised that Petr solved 398E - Sorting Permutations during the contest! Even though he implemented by Java, his solution is faster than ours :p Congratulations to him! Actually, we purposed an another problem for Div1-E, but the same problem popped out at OpenCup last Sunday, so we couldn't use that. Thanks to Gerald, who helped us preparing a new problem in such a short time. By the way, can you guess what problem was that? :D ... 399A - Pages — Author : .o.You can solve this problem by just following the statement. First, print << if p - k > 1. Next, iterate all the integers from p - k to p + k, and print if the integer is in [1..n]. Finally, print >> if p + k < n. Time complexity: O(n). Code : 5926588 399B - Red and Blue Balls — Author : xtalclrChange the blue balls to bit 1, and blue balls to bit 0. Interpret the stack as an integer represented in binary digits. Now, one may see that a single operation decreases the integer by 1, and will be unavailable iff the integer becomes zero. So the answer will be 2a1 + 2a2 + ... + 2ak where the (ai + 1)-th (1 ≤ i ≤ k) ball is blue in the beginning. Time complexity: O(n) Code : 5926598 398A - Cards — Author : .o.Let the number of o blocks p, and the number of x blocks q. It is obvious that |p - q| ≤ 1 and p, q ≤ n. So we can just iterate all p and q, and solve these two problems independently, and merge the answer.1. Maximize the value of x12 + x22 + ... + xp2 where x1 + x2 + ... + xp = a and xi ≥ 1. Assign a - p + 1 to x1, and assign 1 to x2, x3, ..., xp. The value is (a - p + 1)2 + (p - 1). 2. Minimize the value of y12 + y22 + ... + yq2 where y1 + y2 + ... + yq = b and yi ≥ 1. For all , assign to yi. For all , assign to yj. The value is . The proof is easy, so I won't do it. With this, we can solve the problem. We can print y1 xs, and then x1 os, ... Time complexity: O(n). Code : 5926607 Bonus: Is there any solution faster than O(n)? We tried to use ternary search, but we couldn't prove that was correct. 398B - Painting The Wall — Author : aintaThis can be solved by dynamic programming. Let T[i, j] the expected time when i rows and j columns doesn't have any painted cells inside.Let's see all the cases. If we carefully rearrange the order of rows and columns, we can divide the wall into 4 pieces. Choose a cell in rectangle 1. The size of this rectangle is i × j. The expectation value is T[i - 1, j - 1]. Choose a cell in rectangle 2. The size of this rectangle is i × (n - j). The expectation value is T[i - 1, j]. Choose a cell in rectangle 3. The size of this rectangle is (n - i) × j. The expectation value is T[i, j - 1]. Choose a cell in rectangle 4. The size of this rectangle is (n - i) × (n - j). The expectation value is T[i, j]. Merging these four cases, we can get:T[i, j] = 1 + {T[i - 1, j - 1] × i × j + T[i - 1, j] × i × (n - j) + T[i, j - 1] × (n - i) × j + T[i, j] × (n - i) × (n - j)} / n2Moving the T[i, j] on the right to the left, we can get the formula which can be used to calculate the value T[i, j]. There are some corner cases, like i = 0 or j = 0, but it can be simply handled. Time complexity: O(n2) Code : 5926617 398C - Tree and Array — Author : .o.There are two intended solutions. One is easy, and the other is quite tricky.Easy SolutionMake a tree by the following method. For all , make an edge between vertex i and with weight 1. For all , make an edge between vertex i and i + 1 with weight . You can see that are all good pairs. In addition, (1, 3) is also a good pair. So we can print the answer.But, if n = 5, this method doesn't work because (1, 3) is not a good pair. In this case, one may solve by hand or using random algorithm. Time complexity: O(n) Code: 5926624 Bonus I: Is there any method to make more than good pairs? Bonus II: Is there any method that the maximum weight is relatively small and make at least good pairs? Tricky SolutionIf you got stuck with the problem, one can run any random algorithm that solves small cases, and merge these cases. With this approach, we can even limit the weight to a very small constant!But I think this is not a good solution, so I won't mention about unless anybody wants to know the details. I came up with this solution, and tried to purpose this as D. It seems all the 6 people who passed pretests during the contest didn't use this solution :) Time complexity: ??? Code : 5926632 398D - Instant Messanger — Author : .o.Let xi an integer representing the state of the i-th user. If user i is online, xi  =  1, otherwise, xi  =  0. Also, let Si the set consisting of i-th friends.One can see that the queries become like this: Online/Offline: change the value of xi to 1  -  xi. Add: add u to set Sv, and v to set Su. Delete: delete u from set Sv, v from set Su. Count: calculate . Let's use sqrt-decomposition to perform these queries. Let user u heavy if |Su| ≥ C, or light otherwise. Also, we will define some arrays and sets: Hu is a set that stores friends with user u who are heavy users. O[u] stores the sum of . If the Online/Offline(u) query is given, If u is a light user: for all , change the value of O[v]. It takes O(|Su|) time. Otherwise: just update the state of itself. If the Add(u, v) query is given, If vertex u becomes heavy if we add this edge, for all , add v into Hw and update the value of O[w]. This can be done in O(C). If vertex u is still light even if we add the edge, update O[v]. This can be done in constant time. If vertex u is heavy (after the operations above), update Hv. Add u to set Sv, and v to set Su. If the Delete(u, v) query is given, Delete u from set Sv, and v from set Su. Update the value of O[*], Hu and Hv. Because for all |Hw| ≤  E| /  C, this can be done in O(|E| / C). If the counting query is given, will be the answer. Because |Hu| ≤ |E| / C, it will take O(|E| / C) time.So for each query, O(|E| / C) or O(C) time is required. To minimize the time, . Time complexity: Code : 5926635 We can also solve this by dividing the queries into parts. For each block, use O(n + m + q) time to build the online & offline state and the answer table for each vertices. For each query, you can use time to get the answer. If you want more details, please ask in the comments. Time complexity: Code : 5926640 398E - Sorting Permutations — Author : xtalclr, eyTns, and great help of GeraldHere is the draft solution. Feel free to ask of or discuss about the solutions! Unfortunately, I don't know how to read or write Russian, so if you ask me in Russian, I can't response to it. (also, I think the Russian editorial won't be available..) Sorry for that.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10686",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 398\\s*D"
          },
          "content_length": 8039
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 1",
          "code": "2 3 4 5 1\n? ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 2",
          "code": "2 3 4 5 1\n? ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 3",
          "code": "2 3 4 5 1\n4 ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 4",
          "code": "2 3 4 5 1\n4 ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 5",
          "code": "2 3 4 5 1\n4 ? 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 6",
          "code": "2 3 4 5 1\n4 ? 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 7",
          "code": "2 3 4 5 1\n4 3 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 8",
          "code": "2 3 4 5 1\n4 3 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 9",
          "code": "2 3 4 5 1\n4 3 2 1 5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 10",
          "code": "2 3 4 5 1\n4 3 2 1 5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 11",
          "code": "2 3 4 5 1 7 8 9 6      2 3 4 1 6 7 8 5 \n8 ? ? ? ? ? ? ? ?      8 ? ? ? ? ? ? ? \n1 2 3 4 5 6 7 8 9      1 2 3 4 5 6 7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 12",
          "code": "2 3 4 5 1 7 8 9 6      2 3 4 1 6 7 8 5 \n8 ? ? ? ? ? ? ? ?      8 ? ? ? ? ? ? ? \n1 2 3 4 5 6 7 8 9      1 2 3 4 5 6 7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 1",
          "code": "unordered_set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 2",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 3",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 4",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 5",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 6",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 7",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 50000;\nconst int MAX_M = 150000;\nconst int MAX_Q = 250000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 150000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 250000, \"q\");\n    inf.readEoln();\n\n    int n_max = 50000;\n    assert(n <= n_max);\n\n    int o = inf.readInt(1, n, \"o\");\n    inf.readEoln();\n\n    vector<int> online_users = inf.readInts(o, 1, n, \"online_users\");\n    inf.readEoln();\n\n    // Check that online_users are distinct\n    {\n        set<int> online_set(online_users.begin(), online_users.end());\n        ensuref((int)online_set.size() == o, \"Online users must be distinct\");\n    }\n\n    // Initialize online status\n    vector<bool> online(n + 1, false);\n    for (int u : online_users) {\n        online[u] = true;\n    }\n\n    // Initialize friendship data structures\n    vector<unordered_set<int>> friends(n + 1);\n    set<pair<int, int>> friendship_set; // To check duplicates\n\n    // Read m friendship pairs\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Friendship cannot be between user %d and itself\", a);\n\n        // Check for duplicate friendship\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> p = make_pair(u, v);\n        ensuref(friendship_set.count(p) == 0, \"Duplicate friendship between %d and %d\", u, v);\n        friendship_set.insert(p);\n\n        friends[a].insert(b);\n        friends[b].insert(a);\n    }\n\n    // Process q queries\n    for (int i = 0; i < q; ++i) {\n        string cmd = inf.readToken();\n        ensuref(cmd == \"O\" || cmd == \"F\" || cmd == \"A\" || cmd == \"D\" || cmd == \"C\", \"Invalid command: %s\", cmd.c_str());\n        if (cmd == \"O\" || cmd == \"F\" || cmd == \"C\") {\n            inf.readSpace();\n            int u = inf.readInt(1, n, \"u\");\n            inf.readEoln();\n            if (cmd == \"O\") {\n                ensuref(!online[u], \"User %d is already online\", u);\n                online[u] = true;\n            } else if (cmd == \"F\") {\n                ensuref(online[u], \"User %d is already offline\", u);\n                online[u] = false;\n            } else if (cmd == \"C\") {\n                // No need to check anything extra\n            }\n        } else if (cmd == \"A\" || cmd == \"D\") {\n            inf.readSpace();\n            int u = inf.readInt(1, n, \"u\");\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readEoln();\n            ensuref(u != v, \"Users %d and %d must be different\", u, v);\n            if (cmd == \"A\") {\n                ensuref(friends[u].count(v) == 0, \"Users %d and %d are already friends\", u, v);\n                friends[u].insert(v);\n                friends[v].insert(u);\n            } else if (cmd == \"D\") {\n                ensuref(friends[u].count(v) == 1, \"Users %d and %d are not friends\", u, v);\n                friends[u].erase(v);\n                friends[v].erase(u);\n            }\n        } else {\n            ensuref(false, \"Invalid command: %s\", cmd.c_str());\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 50000;\nconst int MAX_M = 150000;\nconst int MAX_Q = 250000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 150000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 250000, \"q\");\n    inf.readEoln();\n\n    int n_max = 50000;\n    assert(n <= n_max);\n\n    int o = inf.readInt(1, n, \"o\");\n    inf.readEoln();\n\n    vector<int> online_users = inf.readInts(o, 1, n, \"online_users\");\n    inf.readEoln();\n\n    // Check that online_users are distinct\n    {\n        set<int> online_set(online_users.begin(), online_users.end());\n        ensuref((int)online_set.size() == o, \"Online users must be distinct\");\n    }\n\n    // Initialize online status\n    vector<bool> online(n + 1, false);\n    for (int u : online_users) {\n        online[u] = true;\n    }\n\n    // Initialize friendship data structures\n    vector<unordered_set<int>> friends(n + 1);\n    set<pair<int, int>> friendship_set; // To check duplicates\n\n    // Read m friendship pairs\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Friendship cannot be between user %d and itself\", a);\n\n        // Check for duplicate friendship\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> p = make_pair(u, v);\n        ensuref(friendship_set.count(p) == 0, \"Duplicate friendship between %d and %d\", u, v);\n        friendship_set.insert(p);\n\n        friends[a].insert(b);\n        friends[b].insert(a);\n    }\n\n    // Process q queries\n    for (int i = 0; i < q; ++i) {\n        string cmd = inf.readToken();\n        ensuref(cmd == \"O\" || cmd == \"F\" || cmd == \"A\" || cmd == \"D\" || cmd == \"C\", \"Invalid command: %s\", cmd.c_str());\n        if (cmd == \"O\" || cmd == \"F\" || cmd == \"C\") {\n            inf.readSpace();\n            int u = inf.readInt(1, n, \"u\");\n            inf.readEoln();\n            if (cmd == \"O\") {\n                ensuref(!online[u], \"User %d is already online\", u);\n                online[u] = true;\n            } else if (cmd == \"F\") {\n                ensuref(online[u], \"User %d is already offline\", u);\n                online[u] = false;\n            } else if (cmd == \"C\") {\n                // No need to check anything extra\n            }\n        } else if (cmd == \"A\" || cmd == \"D\") {\n            inf.readSpace();\n            int u = inf.readInt(1, n, \"u\");\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readEoln();\n            ensuref(u != v, \"Users %d and %d must be different\", u, v);\n            if (cmd == \"A\") {\n                ensuref(friends[u].count(v) == 0, \"Users %d and %d are already friends\", u, v);\n                friends[u].insert(v);\n                friends[v].insert(u);\n            } else if (cmd == \"D\") {\n                ensuref(friends[u].count(v) == 1, \"Users %d and %d are not friends\", u, v);\n                friends[u].erase(v);\n                friends[v].erase(u);\n            }\n        } else {\n            ensuref(false, \"Invalid command: %s\", cmd.c_str());\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 50000;\nconst int MAX_M = 150000;\nconst int MAX_Q = 250000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 150000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 250000, \"q\");\n    inf.readEoln();\n\n    int n_max = 50000;\n    assert(n <= n_max);\n\n    int o = inf.readInt(1, n, \"o\");\n    inf.readEoln();\n\n    vector<int> online_users = inf.readInts(o, 1, n, \"online_users\");\n    inf.readEoln();\n\n    // Check that online_users are distinct\n    {\n        set<int> online_set(online_users.begin(), online_users.end());\n        ensuref((int)online_set.size() == o, \"Online users must be distinct\");\n    }\n\n    // Initialize online status\n    vector<bool> online(n + 1, false);\n    for (int u : online_users) {\n        online[u] = true;\n    }\n\n    // Initialize friendship data structures\n    vector<unordered_set<int>> friends(n + 1);\n    set<pair<int, int>> friendship_set; // To check duplicates\n\n    // Read m friendship pairs\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Friendship cannot be between user %d and itself\", a);\n\n        // Check for duplicate friendship\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> p = make_pair(u, v);\n        ensuref(friendship_set.count(p) == 0, \"Duplicate friendship between %d and %d\", u, v);\n        friendship_set.insert(p);\n\n        friends[a].insert(b);\n        friends[b].insert(a);\n    }\n\n    // Process q queries\n    for (int i = 0; i < q; ++i) {\n        string cmd = inf.readToken();\n        ensuref(cmd == \"O\" || cmd == \"F\" || cmd == \"A\" || cmd == \"D\" || cmd == \"C\", \"Invalid command: %s\", cmd.c_str());\n        if (cmd == \"O\" || cmd == \"F\" || cmd == \"C\") {\n            inf.readSpace();\n            int u = inf.readInt(1, n, \"u\");\n            inf.readEoln();\n            if (cmd == \"O\") {\n                ensuref(!online[u], \"User %d is already online\", u);\n                online[u] = true;\n            } else if (cmd == \"F\") {\n                ensuref(online[u], \"User %d is already offline\", u);\n                online[u] = false;\n            } else if (cmd == \"C\") {\n                // No need to check anything extra\n            }\n        } else if (cmd == \"A\" || cmd == \"D\") {\n            inf.readSpace();\n            int u = inf.readInt(1, n, \"u\");\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readEoln();\n            ensuref(u != v, \"Users %d and %d must be different\", u, v);\n            if (cmd == \"A\") {\n                ensuref(friends[u].count(v) == 0, \"Users %d and %d are already friends\", u, v);\n                friends[u].insert(v);\n                friends[v].insert(u);\n            } else if (cmd == \"D\") {\n                ensuref(friends[u].count(v) == 1, \"Users %d and %d are not friends\", u, v);\n                friends[u].erase(v);\n                friends[v].erase(u);\n            }\n        } else {\n            ensuref(false, \"Invalid command: %s\", cmd.c_str());\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  Generator for the \"aintalk\" problem.\n\n  This generator will produce:\n  1) An initial number of users n, number of friendships m, and number of queries q.\n  2) A set of \"o\" users who are initially online.\n  3) Exactly m friendship pairs (no duplicates).\n  4) Exactly q valid queries.\n\n  Usage sample:\n    ./gen -n 10 -m 5 -q 10 -o 3 -structure star -queries random\n*/\n\nstatic const int MAXN = 50000;\nstatic const int MAXM = 150000;\nstatic const int MAXQ = 250000;\n\n// Edge hash, so we can store edges in an unordered_set of 64-bit\n// (where high 32 bits is one vertex, low 32 bits is the other).\n// We store edges in (min, max) form to avoid directional duplication.\nstatic inline long long encodeEdge(int u, int v) {\n    if (u > v) std::swap(u,v);\n    // pack u and v into 64-bit\n    return (1LL * u << 32) | (1LL * v);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // 1. Parse parameters from command line.\n    int n = opt<int>(\"n\");   // number of users\n    int m = opt<int>(\"m\");   // initial friendships\n    int q = opt<int>(\"q\");   // number of queries\n    int o = opt<int>(\"o\", -1); // number of online users initially, -1 => random\n    string structure = opt<string>(\"structure\", \"random\");  // how we build initial friendships\n    string queriesType = opt<string>(\"queries\", \"random\");  // how queries are generated\n\n    // Enforce constraints in the generator (light checks).\n    // We assume the user of the generator respects them. \n    // But let's do minimal checks to avoid obvious mistakes.\n    n = max(1, min(n, MAXN));\n    m = max(0, min(m, min(MAXM, (int)((long long)n*(n-1)/2))));\n    q = max(0, min(q, MAXQ));\n\n    // 2. Decide how many users are initially online.\n    // If o == -1, pick random from [1..n].\n    if (o == -1) {\n        o = rnd.next(1, n);\n    } else {\n        o = max(1, min(o, n));\n    }\n\n    // 3. Build the initial set of online users.\n    // We'll pick 'o' distinct random users out of [1..n].\n    // We'll store them in a vector \"onlineList\". Also store a bool array for quick checks.\n    vector<bool> isOnline(n, false);\n    // pick o distinct\n    // to do that, we can pick [0..n-1], shuffle, take first o\n    vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    shuffle(idx.begin(), idx.end());\n    for (int i = 0; i < o; i++) {\n        isOnline[idx[i]] = true;\n    }\n\n    // 4. Build the initial edges, according to \"structure\".\n    // We'll store them in an unordered_set<long long> so there's no duplication.\n    // Then we'll convert them to a vector to output.\n    unordered_set<long long> E;\n    E.reserve(m*2);\n\n    // Helper function to add an edge safely:\n    auto tryAddEdge = [&](int u, int v) {\n        if (u == v) return false;\n        if (u > v) std::swap(u,v);\n        long long code = encodeEdge(u,v);\n        if (E.count(code)) return false;\n        E.insert(code);\n        return true;\n    };\n\n    // We will fill up to m edges in distinct ways.\n    // Then if we still have fewer than m edges, we fill the rest with random.\n    auto fillRandomEdges = [&](int need) {\n        while ((int)E.size() < need) {\n            int u = rnd.next(0, n-1);\n            int v = rnd.next(0, n-1);\n            if (u != v) {\n                tryAddEdge(u,v);\n            }\n        }\n    };\n\n    if (structure == \"line\") {\n        // First connect in a line: (0-1), (1-2), ..., (n-2,n-1).\n        // That is n-1 edges if n>1\n        // Then fill the rest with random.\n        for (int i = 0; i+1 < n; i++) {\n            if ((int)E.size() < m) {\n                tryAddEdge(i, i+1);\n            } else {\n                break;\n            }\n        }\n        if ((int)E.size() < m) {\n            fillRandomEdges(m);\n        }\n    }\n    else if (structure == \"star\") {\n        // Pick 0 as center, connect (0,i) for i=1..n-1\n        // That is n-1 edges if n>1\n        // Then fill rest with random\n        for (int i = 1; i < n; i++) {\n            if ((int)E.size() < m) {\n                tryAddEdge(0, i);\n            } else {\n                break;\n            }\n        }\n        if ((int)E.size() < m) {\n            fillRandomEdges(m);\n        }\n    }\n    else {\n        // \"random\"\n        fillRandomEdges(m);\n    }\n\n    // Now we have our initial edges in E.\n\n    // 5. Output the first line: n, m, q\n    printf(\"%d %d %d\\n\", n, (int)E.size(), q);\n\n    // 6. Output 'o', then the ids of the online users (1-based).\n    printf(\"%d\\n\", o);\n    int countOut = 0;\n    for (int i = 0; i < n; i++) {\n        if (isOnline[i]) {\n            countOut++;\n            printf(\"%d\", i+1);\n            if (countOut < o) printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    // 7. Output the edges\n    // E is 0-based internally, problem statement is 1-based\n    // We have exactly E.size() edges\n    vector<pair<int,int>> edges;\n    edges.reserve(E.size());\n    for (auto &code : E) {\n        int u = int(code >> 32);\n        int v = int(code & 0xffffffffLL);\n        edges.push_back({u,v});\n    }\n    // shuffle edges to randomize output order if you like\n    shuffle(edges.begin(), edges.end());\n    for (auto &ed : edges) {\n        printf(\"%d %d\\n\", ed.first+1, ed.second+1);\n    }\n\n    // We'll keep adjacency for queries. \n    // This must be fast to update, so let's use vector<unordered_set<int>>.\n    // Also track how many are online/offline.\n    vector< unordered_set<int> > adj(n);\n    for (auto &ed : edges) {\n        adj[ed.first].insert(ed.second);\n        adj[ed.second].insert(ed.first);\n    }\n\n    // 8. Generate q queries. We'll produce them at random, but ensure validity.\n    // We'll track who is online/offline in isOnline[].\n    // For \"A u v\", we must ensure u,v not friends\n    // For \"D u v\", we must ensure u,v are friends\n    // For \"O u\", user must be offline\n    // For \"F u\", user must be online\n    // For \"C u\", always valid\n\n    // We'll do it with some probabilities. \n    // We'll try up to 50 attempts for each query type; if it fails, pick a different type.\n    // This code is somewhat large, but a standard approach for random generation.\n    \n    vector<int> onlineUsers, offlineUsers;\n    onlineUsers.reserve(n);\n    offlineUsers.reserve(n);\n\n    // helper to rebuild onlineUsers / offlineUsers\n    auto rebuildStatus = [&](void){\n        onlineUsers.clear();\n        offlineUsers.clear();\n        for (int i = 0; i < n; i++){\n            if (isOnline[i]) onlineUsers.push_back(i);\n            else offlineUsers.push_back(i);\n        }\n    };\n\n    rebuildStatus();\n\n    // We'll define possible query types with some weights:\n    //  20% O, 20% F, 10% A, 10% D, 40% C\n    // You can tweak these ratios as needed.\n    vector<char> types = {'O','F','A','D','C'};\n    vector<int> w = {20,20,10,10,40}; // weights\n    int wsum = accumulate(w.begin(), w.end(), 0);\n\n    // For efficiency, we'll store edges in an unordered_set<long long> (E) \n    // that we keep updating. We already have that, so let's keep it and modify as we go.\n\n    for (int i = 0; i < q; i++) {\n        // repeatedly pick a random type until we succeed\n        bool done = false;\n        for (int attempt = 0; attempt < 50 && !done; attempt++) {\n            int pick = rnd.next(wsum);\n            char Q = 0;\n            for (int j = 0; j < (int)types.size(); j++){\n                if (pick < w[j]) {\n                    Q = types[j];\n                    break;\n                }\n                pick -= w[j];\n            }\n            if (Q == 0) Q = 'C'; // fallback\n\n            if (Q == 'O') {\n                // we need at least one offline user\n                if (!offlineUsers.empty()) {\n                    int u = offlineUsers[rnd.next((int)offlineUsers.size())];\n                    // print \"O u\"\n                    printf(\"O %d\\n\", u+1);\n                    // update isOnline[u] = true\n                    isOnline[u] = true;\n                    // update sets\n                    rebuildStatus();\n                    done = true;\n                }\n            }\n            else if (Q == 'F') {\n                // we need at least one online user\n                if (!onlineUsers.empty()) {\n                    int u = onlineUsers[rnd.next((int)onlineUsers.size())];\n                    // print \"F u\"\n                    printf(\"F %d\\n\", u+1);\n                    // update isOnline[u] = false\n                    isOnline[u] = false;\n                    // update sets\n                    rebuildStatus();\n                    done = true;\n                }\n            }\n            else if (Q == 'A') {\n                // we need a pair of users (u,v) that is not friends\n                if ((int)E.size() < (int)((long long)n*(n-1)/2)) {\n                    // try picking random u,v\n                    bool success = false;\n                    for (int tries=0; tries<50; tries++){\n                        int u = rnd.next(0, n-1);\n                        int v = rnd.next(0, n-1);\n                        if (u != v) {\n                            long long code = encodeEdge(u,v);\n                            if (!E.count(code)) {\n                                // success\n                                printf(\"A %d %d\\n\", u+1, v+1);\n                                E.insert(code);\n                                adj[u].insert(v);\n                                adj[v].insert(u);\n                                success = true;\n                                done = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            else if (Q == 'D') {\n                // we need a pair of users (u,v) that IS friends\n                if (!E.empty()) {\n                    // pick random edge from E\n                    // but storing E in a large unordered_set, we need a random element\n                    // We'll convert E to vector only if we must (too big for large m, but let's do it).\n                    // We'll do a small approach: we can do a random jump from the edges vector we had (edges) \n                    // but we are not removing from edges vector for \"D\" queries. We'll keep a dynamic vector or do a method.\n                    // Let's keep a dynamic array of existing edges to pick from. We'll do something simple:\n                    // We'll pick a random offset in E by iterating. This is O(1) on average in C++17 for an unordered set, but not guaranteed.\n                    // For simplicity, let's do a small loop. It's not perfect for very large E, but should be okay for a generator.\n\n                    // once we pick an edge, we'll remove it from E, adj, etc.\n                    long long chosen = 0;\n                    // pick random index r in [0, E.size()-1]\n                    int r = rnd.next(0, (int)E.size()-1);\n                    // we must iterate E up to r steps\n                    int cnt = 0;\n                    for (auto &code : E) {\n                        if (cnt == r) {\n                            chosen = code;\n                            break;\n                        }\n                        cnt++;\n                    }\n                    int u = int(chosen >> 32);\n                    int v = int(chosen & 0xffffffffLL);\n                    printf(\"D %d %d\\n\", u+1, v+1);\n                    E.erase(chosen);\n                    adj[u].erase(v);\n                    adj[v].erase(u);\n                    done = true;\n                }\n            }\n            else { \n                // 'C'\n                // always valid\n                // pick any user random\n                int u = rnd.next(0, n-1);\n                printf(\"C %d\\n\", u+1);\n                done = true;\n            }\n        }\n        // if still not done, produce a guaranteed \"C\" query as fallback\n        if (!done) {\n            int u = rnd.next(0, n-1);\n            printf(\"C %d\\n\", u+1);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  Generator for the \"aintalk\" problem.\n\n  This generator will produce:\n  1) An initial number of users n, number of friendships m, and number of queries q.\n  2) A set of \"o\" users who are initially online.\n  3) Exactly m friendship pairs (no duplicates).\n  4) Exactly q valid queries.\n\n  Usage sample:\n    ./gen -n 10 -m 5 -q 10 -o 3 -structure star -queries random\n*/\n\nstatic const int MAXN = 50000;\nstatic const int MAXM = 150000;\nstatic const int MAXQ = 250000;\n\n// Edge hash, so we can store edges in an unordered_set of 64-bit\n// (where high 32 bits is one vertex, low 32 bits is the other).\n// We store edges in (min, max) form to avoid directional duplication.\nstatic inline long long encodeEdge(int u, int v) {\n    if (u > v) std::swap(u,v);\n    // pack u and v into 64-bit\n    return (1LL * u << 32) | (1LL * v);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // 1. Parse parameters from command line.\n    int n = opt<int>(\"n\");   // number of users\n    int m = opt<int>(\"m\");   // initial friendships\n    int q = opt<int>(\"q\");   // number of queries\n    int o = opt<int>(\"o\", -1); // number of online users initially, -1 => random\n    string structure = opt<string>(\"structure\", \"random\");  // how we build initial friendships\n    string queriesType = opt<string>(\"queries\", \"random\");  // how queries are generated\n\n    // Enforce constraints in the generator (light checks).\n    // We assume the user of the generator respects them. \n    // But let's do minimal checks to avoid obvious mistakes.\n    n = max(1, min(n, MAXN));\n    m = max(0, min(m, min(MAXM, (int)((long long)n*(n-1)/2))));\n    q = max(0, min(q, MAXQ));\n\n    // 2. Decide how many users are initially online.\n    // If o == -1, pick random from [1..n].\n    if (o == -1) {\n        o = rnd.next(1, n);\n    } else {\n        o = max(1, min(o, n));\n    }\n\n    // 3. Build the initial set of online users.\n    // We'll pick 'o' distinct random users out of [1..n].\n    // We'll store them in a vector \"onlineList\". Also store a bool array for quick checks.\n    vector<bool> isOnline(n, false);\n    // pick o distinct\n    // to do that, we can pick [0..n-1], shuffle, take first o\n    vector<int> idx(n);\n    iota(idx.begin(), idx.end(), 0);\n    shuffle(idx.begin(), idx.end());\n    for (int i = 0; i < o; i++) {\n        isOnline[idx[i]] = true;\n    }\n\n    // 4. Build the initial edges, according to \"structure\".\n    // We'll store them in an unordered_set<long long> so there's no duplication.\n    // Then we'll convert them to a vector to output.\n    unordered_set<long long> E;\n    E.reserve(m*2);\n\n    // Helper function to add an edge safely:\n    auto tryAddEdge = [&](int u, int v) {\n        if (u == v) return false;\n        if (u > v) std::swap(u,v);\n        long long code = encodeEdge(u,v);\n        if (E.count(code)) return false;\n        E.insert(code);\n        return true;\n    };\n\n    // We will fill up to m edges in distinct ways.\n    // Then if we still have fewer than m edges, we fill the rest with random.\n    auto fillRandomEdges = [&](int need) {\n        while ((int)E.size() < need) {\n            int u = rnd.next(0, n-1);\n            int v = rnd.next(0, n-1);\n            if (u != v) {\n                tryAddEdge(u,v);\n            }\n        }\n    };\n\n    if (structure == \"line\") {\n        // First connect in a line: (0-1), (1-2), ..., (n-2,n-1).\n        // That is n-1 edges if n>1\n        // Then fill the rest with random.\n        for (int i = 0; i+1 < n; i++) {\n            if ((int)E.size() < m) {\n                tryAddEdge(i, i+1);\n            } else {\n                break;\n            }\n        }\n        if ((int)E.size() < m) {\n            fillRandomEdges(m);\n        }\n    }\n    else if (structure == \"star\") {\n        // Pick 0 as center, connect (0,i) for i=1..n-1\n        // That is n-1 edges if n>1\n        // Then fill rest with random\n        for (int i = 1; i < n; i++) {\n            if ((int)E.size() < m) {\n                tryAddEdge(0, i);\n            } else {\n                break;\n            }\n        }\n        if ((int)E.size() < m) {\n            fillRandomEdges(m);\n        }\n    }\n    else {\n        // \"random\"\n        fillRandomEdges(m);\n    }\n\n    // Now we have our initial edges in E.\n\n    // 5. Output the first line: n, m, q\n    printf(\"%d %d %d\\n\", n, (int)E.size(), q);\n\n    // 6. Output 'o', then the ids of the online users (1-based).\n    printf(\"%d\\n\", o);\n    int countOut = 0;\n    for (int i = 0; i < n; i++) {\n        if (isOnline[i]) {\n            countOut++;\n            printf(\"%d\", i+1);\n            if (countOut < o) printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    // 7. Output the edges\n    // E is 0-based internally, problem statement is 1-based\n    // We have exactly E.size() edges\n    vector<pair<int,int>> edges;\n    edges.reserve(E.size());\n    for (auto &code : E) {\n        int u = int(code >> 32);\n        int v = int(code & 0xffffffffLL);\n        edges.push_back({u,v});\n    }\n    // shuffle edges to randomize output order if you like\n    shuffle(edges.begin(), edges.end());\n    for (auto &ed : edges) {\n        printf(\"%d %d\\n\", ed.first+1, ed.second+1);\n    }\n\n    // We'll keep adjacency for queries. \n    // This must be fast to update, so let's use vector<unordered_set<int>>.\n    // Also track how many are online/offline.\n    vector< unordered_set<int> > adj(n);\n    for (auto &ed : edges) {\n        adj[ed.first].insert(ed.second);\n        adj[ed.second].insert(ed.first);\n    }\n\n    // 8. Generate q queries. We'll produce them at random, but ensure validity.\n    // We'll track who is online/offline in isOnline[].\n    // For \"A u v\", we must ensure u,v not friends\n    // For \"D u v\", we must ensure u,v are friends\n    // For \"O u\", user must be offline\n    // For \"F u\", user must be online\n    // For \"C u\", always valid\n\n    // We'll do it with some probabilities. \n    // We'll try up to 50 attempts for each query type; if it fails, pick a different type.\n    // This code is somewhat large, but a standard approach for random generation.\n    \n    vector<int> onlineUsers, offlineUsers;\n    onlineUsers.reserve(n);\n    offlineUsers.reserve(n);\n\n    // helper to rebuild onlineUsers / offlineUsers\n    auto rebuildStatus = [&](void){\n        onlineUsers.clear();\n        offlineUsers.clear();\n        for (int i = 0; i < n; i++){\n            if (isOnline[i]) onlineUsers.push_back(i);\n            else offlineUsers.push_back(i);\n        }\n    };\n\n    rebuildStatus();\n\n    // We'll define possible query types with some weights:\n    //  20% O, 20% F, 10% A, 10% D, 40% C\n    // You can tweak these ratios as needed.\n    vector<char> types = {'O','F','A','D','C'};\n    vector<int> w = {20,20,10,10,40}; // weights\n    int wsum = accumulate(w.begin(), w.end(), 0);\n\n    // For efficiency, we'll store edges in an unordered_set<long long> (E) \n    // that we keep updating. We already have that, so let's keep it and modify as we go.\n\n    for (int i = 0; i < q; i++) {\n        // repeatedly pick a random type until we succeed\n        bool done = false;\n        for (int attempt = 0; attempt < 50 && !done; attempt++) {\n            int pick = rnd.next(wsum);\n            char Q = 0;\n            for (int j = 0; j < (int)types.size(); j++){\n                if (pick < w[j]) {\n                    Q = types[j];\n                    break;\n                }\n                pick -= w[j];\n            }\n            if (Q == 0) Q = 'C'; // fallback\n\n            if (Q == 'O') {\n                // we need at least one offline user\n                if (!offlineUsers.empty()) {\n                    int u = offlineUsers[rnd.next((int)offlineUsers.size())];\n                    // print \"O u\"\n                    printf(\"O %d\\n\", u+1);\n                    // update isOnline[u] = true\n                    isOnline[u] = true;\n                    // update sets\n                    rebuildStatus();\n                    done = true;\n                }\n            }\n            else if (Q == 'F') {\n                // we need at least one online user\n                if (!onlineUsers.empty()) {\n                    int u = onlineUsers[rnd.next((int)onlineUsers.size())];\n                    // print \"F u\"\n                    printf(\"F %d\\n\", u+1);\n                    // update isOnline[u] = false\n                    isOnline[u] = false;\n                    // update sets\n                    rebuildStatus();\n                    done = true;\n                }\n            }\n            else if (Q == 'A') {\n                // we need a pair of users (u,v) that is not friends\n                if ((int)E.size() < (int)((long long)n*(n-1)/2)) {\n                    // try picking random u,v\n                    bool success = false;\n                    for (int tries=0; tries<50; tries++){\n                        int u = rnd.next(0, n-1);\n                        int v = rnd.next(0, n-1);\n                        if (u != v) {\n                            long long code = encodeEdge(u,v);\n                            if (!E.count(code)) {\n                                // success\n                                printf(\"A %d %d\\n\", u+1, v+1);\n                                E.insert(code);\n                                adj[u].insert(v);\n                                adj[v].insert(u);\n                                success = true;\n                                done = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            else if (Q == 'D') {\n                // we need a pair of users (u,v) that IS friends\n                if (!E.empty()) {\n                    // pick random edge from E\n                    // but storing E in a large unordered_set, we need a random element\n                    // We'll convert E to vector only if we must (too big for large m, but let's do it).\n                    // We'll do a small approach: we can do a random jump from the edges vector we had (edges) \n                    // but we are not removing from edges vector for \"D\" queries. We'll keep a dynamic vector or do a method.\n                    // Let's keep a dynamic array of existing edges to pick from. We'll do something simple:\n                    // We'll pick a random offset in E by iterating. This is O(1) on average in C++17 for an unordered set, but not guaranteed.\n                    // For simplicity, let's do a small loop. It's not perfect for very large E, but should be okay for a generator.\n\n                    // once we pick an edge, we'll remove it from E, adj, etc.\n                    long long chosen = 0;\n                    // pick random index r in [0, E.size()-1]\n                    int r = rnd.next(0, (int)E.size()-1);\n                    // we must iterate E up to r steps\n                    int cnt = 0;\n                    for (auto &code : E) {\n                        if (cnt == r) {\n                            chosen = code;\n                            break;\n                        }\n                        cnt++;\n                    }\n                    int u = int(chosen >> 32);\n                    int v = int(chosen & 0xffffffffLL);\n                    printf(\"D %d %d\\n\", u+1, v+1);\n                    E.erase(chosen);\n                    adj[u].erase(v);\n                    adj[v].erase(u);\n                    done = true;\n                }\n            }\n            else { \n                // 'C'\n                // always valid\n                // pick any user random\n                int u = rnd.next(0, n-1);\n                printf(\"C %d\\n\", u+1);\n                done = true;\n            }\n        }\n        // if still not done, produce a guaranteed \"C\" query as fallback\n        if (!done) {\n            int u = rnd.next(0, n-1);\n            printf(\"C %d\\n\", u+1);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are sample commands (20+) showing how to run this generator\n# with various parameters. They produce different sizes and structures,\n# covering corner cases such as small n, large n, zero m, large m,\n# and different patterns of queries.\n\n./gen -n 1 -m 0 -q 3 -o 1 -structure random -queries random\n./gen -n 2 -m 1 -q 5 -o 1 -structure line   -queries random\n./gen -n 5 -m 0 -q 5 -o 2 -structure star   -queries random\n./gen -n 5 -m 4 -q 10 -o 3 -structure random -queries random\n\n./gen -n 10 -m 9 -q 10 -o 5 -structure line  -queries random\n./gen -n 10 -m 9 -q 10 -o 5 -structure star  -queries random\n./gen -n 10 -m 9 -q 10 -o 5 -structure random -queries random\n\n./gen -n 12 -m 3 -q 20 -o 4 -structure random -queries random\n./gen -n 12 -m 11 -q 20 -o 6 -structure line  -queries random\n\n./gen -n 20 -m 19 -q 20 -o 5 -structure star  -queries random\n./gen -n 20 -m 0  -q 20 -o 5 -structure random -queries random\n./gen -n 20 -m 30 -q 30 -o 10 -structure random -queries random\n\n./gen -n 50 -m 49 -q 50 -o 10 -structure line  -queries random\n./gen -n 50 -m 49 -q 50 -o 10 -structure star  -queries random\n\n# Larger tests\n./gen -n 100 -m 0 -q 50 -o 10 -structure random -queries random\n./gen -n 100 -m 99 -q 100 -o 20 -structure line -queries random\n./gen -n 100 -m 99 -q 100 -o 50 -structure star -queries random\n./gen -n 200 -m 180 -q 200 -o 100 -structure random -queries random\n\n# Even larger tests\n./gen -n 1000 -m 500 -q 1000 -o 200 -structure random -queries random\n./gen -n 5000 -m 1000 -q 2000 -o 1000 -structure random -queries random\n./gen -n 10000 -m 10000 -q 20000 -o 5000 -structure random -queries random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:45.908509",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "398/E",
      "title": "E. Sorting Permutations",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n (1 ≤ n ≤ 105) and k (0 ≤ k ≤ 12). The second line contains the permutation sequence a1, ..., an (0 ≤ ai ≤ n). If a number is not yet determined, it is denoted as 0. There are exactly k zeroes. All the numbers ai that aren't equal to zero are distinct.",
      "output_spec": "OutputPrint the total sum of the number of ways modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy5 01 5 2 4 3OutputCopy6InputCopy5 21 0 2 4 0OutputCopy7",
      "description": "E. Sorting Permutations\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n (1 ≤ n ≤ 105) and k (0 ≤ k ≤ 12). The second line contains the permutation sequence a1, ..., an (0 ≤ ai ≤ n). If a number is not yet determined, it is denoted as 0. There are exactly k zeroes. All the numbers ai that aren't equal to zero are distinct.\n\nOutputPrint the total sum of the number of ways modulo 1000000007 (109 + 7).\n\nInputCopy5 01 5 2 4 3OutputCopy6InputCopy5 21 0 2 4 0OutputCopy7\n\nInputCopy5 01 5 2 4 3\n\nOutputCopy6\n\nInputCopy5 21 0 2 4 0\n\nOutputCopy7",
      "solutions": [
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces",
          "content": "First of all, sorry for being late :( I was quite depressed because of the server's chronic breakdown during the contest. Also, all the records for Round #233 was gone after the black day, so I thought not many people will be interested in the solution. I should have been more responsible for this. I really want to apologize for people who have been waiting for this editorial.During the contest, the only one user who solved this problem was: Petr. The contest was extended by 30 minutes, and if I remember correctly, he submitted the correct solution at about 2:25. So, congratulations to him!Now let me explain the solution. Let us start with the case when there is no hole. Given any permutation, I will prove that it takes only at most two seconds to sort it completely. Since every permutation can be decomposed into disjoint cycles (link), we only need to take care of each decomposed cycle. That is, we only need to sort a cycle of arbitrary length in two steps.Let's make a table of 3 rows and n columns. The first row will constitute the original, unsorted permutation. For each column, the next column will form the permutation after one second. The last column will be the sorted permutation. The following depicts the case where n = 5 and the permutation is a full cycle. 2 3 4 5 1\n? ? ? ? ?\n1 2 3 4 5Now we have to show that we can fill the second column properly. Let's just fill the first number in the second column randomly, say 4, and see what happens. 2 3 4 5 1\n4 ? ? ? ?\n1 2 3 4 5Because 4 replaces 2 in the second column, 2 replaces 4 and we are forced to put 2 below the 4 in first column. 2 3 4 5 1\n4 ? 2 ? ?\n1 2 3 4 5Likewise, 3 replaces 2 in the third column, so we should put 3 above 2 in the third column. 2 3 4 5 1\n4 3 2 ? ?\n1 2 3 4 5Repeating the process will finally give a complete, valid answer. 2 3 4 5 1\n4 3 2 1 5\n1 2 3 4 5Like the example above, filling the first number in the second column by any number will give a unique and valid answer. I won't prove it formally, but by experimenting with different examples you can see it indeed works :) So now we know that (i) any permutation can be sorted in 2 seconds and, additionally, (ii) if the permutation is a cycle, there are exactly n ways of doing it. Now let us see what happens if two disjoint cycles interact with each other. Try to fill the tables below and figure out what happens. First one is a disjoint union of cycles of length 4 and 5. Second one is a union of cycles of length 4 and 4. 2 3 4 5 1 7 8 9 6 2 3 4 1 6 7 8 5 \n8 ? ? ? ? ? ? ? ? 8 ? ? ? ? ? ? ? \n1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8By experimenting, you will see that if two disjoint cycles A and B interact (to be precise, when an element in A swaps place with another element in B), (i) the size of A and B are equal and in that case (ii) the number of ways to achieve a complete assignment for elements of A and B is exactly the size of A (or B). I won't prove it, but it can be done formally if one wishes to.Now we have the solution when there is no hole: decompose the permutation into disjoint cycles. Assume there are exactly ci cycles of length li for each i. Let a[c, l] be the number of ways to sort c cycles of length l completely. Then the answer will be , basically because only cycles of same length interact.To sort c cycles of length l, we can pair some of the cycles to interact with each other. Then each pair and unpaired cycle will contribute multiplicative factor l to the answer. Now we can derive a recursive formula for a[c, l]. Just take a cycle C and decide if it will be paired to different cycle or not. For the first case, C contributes multiplicative factor l and we can decide on the rest of c - 1 cycles, so there are total of l·a[c - 1, l] ways. For the second case, we have c - 1 ways to pair C with the other cycle, then the pair contributes factor l and we can decide on the remaining c - 2 cycles. This contributes l·(c - 1)·a[c - 2, l]. Adding up will give us the recursive formula. a[c, l] = l·a[c - 1, l] + l·(c - 1)·a[c - 2, l](I'm trying my best to explain the idea, but for this part i'm not quite satisfied with it. Ask or message me if you want more clear explanation)I will write the rest of the editorial tomorrow (my English is bad so it's quite hard to write), but I hope that this draft version will be helpful to you. Update It's almost been a year since I updated this editorial. I have nothing to say but that I was lazy... However, for the sake of completeness, I'll sketch up the rest of the solution.Computing every a[c, l] can be done in reasonable time: cl will be at most n / l and there will be total of values of a[c, l] to compute using the recursive formula above. Given a permutation, we can count the number of cycles cl of length l for each l and compute a[cl, l]. Since two cycles of different length cannot interact, the number of ways to sort the whole permutation will be the multiplication of a[cl, l]'s over all l. Finally, we have to deal with k ≤ 12 holes. The crucial observation is that with holes, the permutation decomposes into cycles and paths. Filling the holes will group the paths to disjoint cycles. Considering every 12! possible ways will give TLE. But if we note that the order of paths in a same group does not make a change in cycle's length, we can actually deploy a bitmask DP to consider all possible way to partition at most 12 paths. Just multiply some constant to each partition and sum over (I'll skip the details).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11108",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 5472
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces",
          "content": "Please write here if you had written some comments about any suggestions or questions on the announcement. There are a bunch of notification emails but I couldn't read most of them :(Here are the final top 100 : Div1, Div2. Congrats to the winners!(These links are all from google search cache, so it may be disappear) First of all, we are sorry to make this round unrated. This is an unexpected incident, and I believe that everyone in Codeforces would understand that. And second, we're sorry for estimating the difficulties of the problems wrong. Actually, I thought that somebody would get Accepted on 398A - Cards within 5 minutes. But there wasn't any submissions during the first 4 minutes, and many people got wrong answer on pretests! I think almost everybody who solved this got at least one wrong answer.. I'm really sorry for measuring A easy. I think what cgy4ever said is right — it would be better not asking to print the sequence. At first, I purposed 398C - Tree and Array as B(!!) because ainta solved it very easily than I expected. (I could hardly solve this, and thought it must be at least D, before I heard ainta's solution.) We're sorry for giving this problem the same score with 398B - Painting The Wall, which was much easier than 398C - Tree and Array. Next time I'll remember that ainta is really a genius :) Congrats to four people who solved 398C - Tree and Array during the contest! : cgy4ever, Shef, SillyHook06, and Qwaz. We are surprised that Petr solved 398E - Sorting Permutations during the contest! Even though he implemented by Java, his solution is faster than ours :p Congratulations to him! Actually, we purposed an another problem for Div1-E, but the same problem popped out at OpenCup last Sunday, so we couldn't use that. Thanks to Gerald, who helped us preparing a new problem in such a short time. By the way, can you guess what problem was that? :D ... 399A - Pages — Author : .o.You can solve this problem by just following the statement. First, print << if p - k > 1. Next, iterate all the integers from p - k to p + k, and print if the integer is in [1..n]. Finally, print >> if p + k < n. Time complexity: O(n). Code : 5926588 399B - Red and Blue Balls — Author : xtalclrChange the blue balls to bit 1, and blue balls to bit 0. Interpret the stack as an integer represented in binary digits. Now, one may see that a single operation decreases the integer by 1, and will be unavailable iff the integer becomes zero. So the answer will be 2a1 + 2a2 + ... + 2ak where the (ai + 1)-th (1 ≤ i ≤ k) ball is blue in the beginning. Time complexity: O(n) Code : 5926598 398A - Cards — Author : .o.Let the number of o blocks p, and the number of x blocks q. It is obvious that |p - q| ≤ 1 and p, q ≤ n. So we can just iterate all p and q, and solve these two problems independently, and merge the answer.1. Maximize the value of x12 + x22 + ... + xp2 where x1 + x2 + ... + xp = a and xi ≥ 1. Assign a - p + 1 to x1, and assign 1 to x2, x3, ..., xp. The value is (a - p + 1)2 + (p - 1). 2. Minimize the value of y12 + y22 + ... + yq2 where y1 + y2 + ... + yq = b and yi ≥ 1. For all , assign to yi. For all , assign to yj. The value is . The proof is easy, so I won't do it. With this, we can solve the problem. We can print y1 xs, and then x1 os, ... Time complexity: O(n). Code : 5926607 Bonus: Is there any solution faster than O(n)? We tried to use ternary search, but we couldn't prove that was correct. 398B - Painting The Wall — Author : aintaThis can be solved by dynamic programming. Let T[i, j] the expected time when i rows and j columns doesn't have any painted cells inside.Let's see all the cases. If we carefully rearrange the order of rows and columns, we can divide the wall into 4 pieces. Choose a cell in rectangle 1. The size of this rectangle is i × j. The expectation value is T[i - 1, j - 1]. Choose a cell in rectangle 2. The size of this rectangle is i × (n - j). The expectation value is T[i - 1, j]. Choose a cell in rectangle 3. The size of this rectangle is (n - i) × j. The expectation value is T[i, j - 1]. Choose a cell in rectangle 4. The size of this rectangle is (n - i) × (n - j). The expectation value is T[i, j]. Merging these four cases, we can get:T[i, j] = 1 + {T[i - 1, j - 1] × i × j + T[i - 1, j] × i × (n - j) + T[i, j - 1] × (n - i) × j + T[i, j] × (n - i) × (n - j)} / n2Moving the T[i, j] on the right to the left, we can get the formula which can be used to calculate the value T[i, j]. There are some corner cases, like i = 0 or j = 0, but it can be simply handled. Time complexity: O(n2) Code : 5926617 398C - Tree and Array — Author : .o.There are two intended solutions. One is easy, and the other is quite tricky.Easy SolutionMake a tree by the following method. For all , make an edge between vertex i and with weight 1. For all , make an edge between vertex i and i + 1 with weight . You can see that are all good pairs. In addition, (1, 3) is also a good pair. So we can print the answer.But, if n = 5, this method doesn't work because (1, 3) is not a good pair. In this case, one may solve by hand or using random algorithm. Time complexity: O(n) Code: 5926624 Bonus I: Is there any method to make more than good pairs? Bonus II: Is there any method that the maximum weight is relatively small and make at least good pairs? Tricky SolutionIf you got stuck with the problem, one can run any random algorithm that solves small cases, and merge these cases. With this approach, we can even limit the weight to a very small constant!But I think this is not a good solution, so I won't mention about unless anybody wants to know the details. I came up with this solution, and tried to purpose this as D. It seems all the 6 people who passed pretests during the contest didn't use this solution :) Time complexity: ??? Code : 5926632 398D - Instant Messanger — Author : .o.Let xi an integer representing the state of the i-th user. If user i is online, xi  =  1, otherwise, xi  =  0. Also, let Si the set consisting of i-th friends.One can see that the queries become like this: Online/Offline: change the value of xi to 1  -  xi. Add: add u to set Sv, and v to set Su. Delete: delete u from set Sv, v from set Su. Count: calculate . Let's use sqrt-decomposition to perform these queries. Let user u heavy if |Su| ≥ C, or light otherwise. Also, we will define some arrays and sets: Hu is a set that stores friends with user u who are heavy users. O[u] stores the sum of . If the Online/Offline(u) query is given, If u is a light user: for all , change the value of O[v]. It takes O(|Su|) time. Otherwise: just update the state of itself. If the Add(u, v) query is given, If vertex u becomes heavy if we add this edge, for all , add v into Hw and update the value of O[w]. This can be done in O(C). If vertex u is still light even if we add the edge, update O[v]. This can be done in constant time. If vertex u is heavy (after the operations above), update Hv. Add u to set Sv, and v to set Su. If the Delete(u, v) query is given, Delete u from set Sv, and v from set Su. Update the value of O[*], Hu and Hv. Because for all |Hw| ≤  E| /  C, this can be done in O(|E| / C). If the counting query is given, will be the answer. Because |Hu| ≤ |E| / C, it will take O(|E| / C) time.So for each query, O(|E| / C) or O(C) time is required. To minimize the time, . Time complexity: Code : 5926635 We can also solve this by dividing the queries into parts. For each block, use O(n + m + q) time to build the online & offline state and the answer table for each vertices. For each query, you can use time to get the answer. If you want more details, please ask in the comments. Time complexity: Code : 5926640 398E - Sorting Permutations — Author : xtalclr, eyTns, and great help of GeraldHere is the draft solution. Feel free to ask of or discuss about the solutions! Unfortunately, I don't know how to read or write Russian, so if you ask me in Russian, I can't response to it. (also, I think the Russian editorial won't be available..) Sorry for that.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10686",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 398\\s*E"
          },
          "content_length": 8039
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 1",
          "code": "2 3 4 5 1\n? ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 2",
          "code": "2 3 4 5 1\n? ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 3",
          "code": "2 3 4 5 1\n4 ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 4",
          "code": "2 3 4 5 1\n4 ? ? ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 5",
          "code": "2 3 4 5 1\n4 ? 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 6",
          "code": "2 3 4 5 1\n4 ? 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 7",
          "code": "2 3 4 5 1\n4 3 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 8",
          "code": "2 3 4 5 1\n4 3 2 ? ?\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 9",
          "code": "2 3 4 5 1\n4 3 2 1 5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 10",
          "code": "2 3 4 5 1\n4 3 2 1 5\n1 2 3 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 11",
          "code": "2 3 4 5 1 7 8 9 6      2 3 4 1 6 7 8 5 \n8 ? ? ? ? ? ? ? ?      8 ? ? ? ? ? ? ? \n1 2 3 4 5 6 7 8 9      1 2 3 4 5 6 7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 1E Editorial - Codeforces - Code 12",
          "code": "2 3 4 5 1 7 8 9 6      2 3 4 1 6 7 8 5 \n8 ? ? ? ? ? ? ? ?      8 ? ? ? ? ? ? ? \n1 2 3 4 5 6 7 8 9      1 2 3 4 5 6 7 8",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11108",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 1",
          "code": "unordered_set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 2",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 3",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 4",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 5",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 6",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 7",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 12, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, n, \"a\");\n    inf.readEoln();\n\n    int zeros = count(a.begin(), a.end(), 0);\n    ensuref(zeros == k, \"Number of zeros in a (%d) doesn't match k (%d)\", zeros, k);\n\n    set<int> s;\n    for (int ai : a) {\n        if (ai != 0) {\n            ensuref(s.count(ai) == 0, \"Duplicate non-zero element %d found in 'a'\", ai);\n            s.insert(ai);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 12, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, n, \"a\");\n    inf.readEoln();\n\n    int zeros = count(a.begin(), a.end(), 0);\n    ensuref(zeros == k, \"Number of zeros in a (%d) doesn't match k (%d)\", zeros, k);\n\n    set<int> s;\n    for (int ai : a) {\n        if (ai != 0) {\n            ensuref(s.count(ai) == 0, \"Duplicate non-zero element %d found in 'a'\", ai);\n            s.insert(ai);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 12, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, n, \"a\");\n    inf.readEoln();\n\n    int zeros = count(a.begin(), a.end(), 0);\n    ensuref(zeros == k, \"Number of zeros in a (%d) doesn't match k (%d)\", zeros, k);\n\n    set<int> s;\n    for (int ai : a) {\n        if (ai != 0) {\n            ensuref(s.count(ai) == 0, \"Duplicate non-zero element %d found in 'a'\", ai);\n            s.insert(ai);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 100000);\n    ensure(0 <= k && k <= 12 && k <= n);\n\n    vector<int> numbers; // numbers from 1 to n\n    for(int i = 1; i <= n; ++i)\n        numbers.push_back(i);\n\n    vector<int> missing_numbers;\n    if (type == \"sorted\") {\n        // Missing numbers are the largest k numbers\n        missing_numbers.assign(numbers.end() - k, numbers.end());\n        numbers.erase(numbers.end() - k, numbers.end());\n    } else if (type == \"reversed\") {\n        // Missing numbers are the smallest k numbers\n        missing_numbers.assign(numbers.begin(), numbers.begin() + k);\n        numbers.erase(numbers.begin(), numbers.begin() + k);\n    } else { // random and other types\n        shuffle(numbers.begin(), numbers.end());\n        missing_numbers.assign(numbers.begin(), numbers.begin() + k);\n        numbers.erase(numbers.begin(), numbers.begin() + k);\n    }\n\n    // Now perm_numbers contains n - k numbers\n    vector<int> perm_numbers = numbers;\n\n    if (type == \"sorted\") {\n        // Already sorted\n        sort(perm_numbers.begin(), perm_numbers.end());\n    } else if (type == \"reversed\") {\n        // Reversed order\n        sort(perm_numbers.rbegin(), perm_numbers.rend());\n    } else {\n        // Shuffle for random and other types\n        shuffle(perm_numbers.begin(), perm_numbers.end());\n    }\n\n    // Create permutation with zeros at random positions\n    vector<int> positions(n);\n    for(int i = 0; i < n; ++i)\n        positions[i] = i;\n\n    // Select k positions for zeros\n    shuffle(positions.begin(), positions.end());\n    vector<int> zero_positions(positions.begin(), positions.begin() + k);\n    set<int> zero_positions_set(zero_positions.begin(), zero_positions.end());\n\n    vector<int> perm(n);\n    int idx = 0; // Index in perm_numbers\n    for(int i = 0; i < n; ++i) {\n        if(zero_positions_set.count(i)) {\n            perm[i] = 0;\n        } else {\n            perm[i] = perm_numbers[idx++];\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", perm[i], (i == n -1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 100000);\n    ensure(0 <= k && k <= 12 && k <= n);\n\n    vector<int> numbers; // numbers from 1 to n\n    for(int i = 1; i <= n; ++i)\n        numbers.push_back(i);\n\n    vector<int> missing_numbers;\n    if (type == \"sorted\") {\n        // Missing numbers are the largest k numbers\n        missing_numbers.assign(numbers.end() - k, numbers.end());\n        numbers.erase(numbers.end() - k, numbers.end());\n    } else if (type == \"reversed\") {\n        // Missing numbers are the smallest k numbers\n        missing_numbers.assign(numbers.begin(), numbers.begin() + k);\n        numbers.erase(numbers.begin(), numbers.begin() + k);\n    } else { // random and other types\n        shuffle(numbers.begin(), numbers.end());\n        missing_numbers.assign(numbers.begin(), numbers.begin() + k);\n        numbers.erase(numbers.begin(), numbers.begin() + k);\n    }\n\n    // Now perm_numbers contains n - k numbers\n    vector<int> perm_numbers = numbers;\n\n    if (type == \"sorted\") {\n        // Already sorted\n        sort(perm_numbers.begin(), perm_numbers.end());\n    } else if (type == \"reversed\") {\n        // Reversed order\n        sort(perm_numbers.rbegin(), perm_numbers.rend());\n    } else {\n        // Shuffle for random and other types\n        shuffle(perm_numbers.begin(), perm_numbers.end());\n    }\n\n    // Create permutation with zeros at random positions\n    vector<int> positions(n);\n    for(int i = 0; i < n; ++i)\n        positions[i] = i;\n\n    // Select k positions for zeros\n    shuffle(positions.begin(), positions.end());\n    vector<int> zero_positions(positions.begin(), positions.begin() + k);\n    set<int> zero_positions_set(zero_positions.begin(), zero_positions.end());\n\n    vector<int> perm(n);\n    int idx = 0; // Index in perm_numbers\n    for(int i = 0; i < n; ++i) {\n        if(zero_positions_set.count(i)) {\n            perm[i] = 0;\n        } else {\n            perm[i] = perm_numbers[idx++];\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, k);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", perm[i], (i == n -1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type sorted\n./gen -n 1 -k 1 -type sorted\n./gen -n 2 -k 0 -type sorted\n./gen -n 2 -k 1 -type sorted\n./gen -n 2 -k 2 -type sorted\n\n./gen -n 10 -k 0 -type random\n./gen -n 10 -k 5 -type random\n./gen -n 10 -k 10 -type random\n\n./gen -n 500 -k 0 -type sorted\n./gen -n 500 -k 5 -type sorted\n./gen -n 500 -k 12 -type sorted\n\n./gen -n 1000 -k 0 -type reversed\n./gen -n 1000 -k 5 -type reversed\n./gen -n 1000 -k 12 -type reversed\n\n./gen -n 5000 -k 0 -type random\n./gen -n 5000 -k 12 -type random\n\n./gen -n 100000 -k 0 -type random\n./gen -n 100000 -k 12 -type random\n\n./gen -n 99999 -k 12 -type random\n\n./gen -n 10000 -k 12 -type maxways\n./gen -n 100000 -k 12 -type maxways\n\n./gen -n 10000 -k 0 -type sorted\n./gen -n 10000 -k 12 -type sorted\n\n./gen -n 10000 -k 0 -type reversed\n./gen -n 10000 -k 12 -type reversed\n\n./gen -n 100000 -k 1 -type random\n./gen -n 100000 -k 2 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:47.905191",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "399/A",
      "title": "A. Страницы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой и единственной строке содержатся три целых числа n, p, k (3 ≤ n ≤ 100; 1 ≤ p ≤ n; 1 ≤ k ≤ n)",
      "output_spec": "Выходные данныеВыведите надлежащую строку навигации. Следуйте формату вывода из тестовых примеров.",
      "sample_tests": "ПримерыВходные данныеСкопировать17 5 2Выходные данныеСкопировать<< 3 4 (5) 6 7 >> Входные данныеСкопировать6 5 2Выходные данныеСкопировать<< 3 4 (5) 6 Входные данныеСкопировать6 1 2Выходные данныеСкопировать(1) 2 3 >> Входные данныеСкопировать6 2 2Выходные данныеСкопировать1 (2) 3 4 >>Входные данныеСкопировать9 6 3Выходные данныеСкопировать<< 3 4 5 (6) 7 8 9Входные данныеСкопировать10 6 3Выходные данныеСкопировать<< 3 4 5 (6) 7 8 9 >>Входные данныеСкопировать8 5 4Выходные данныеСкопировать1 2 3 4 (5) 6 7 8",
      "description": "A. Страницы\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой и единственной строке содержатся три целых числа n, p, k (3 ≤ n ≤ 100; 1 ≤ p ≤ n; 1 ≤ k ≤ n)\n\nВходные данные\n\nВыходные данныеВыведите надлежащую строку навигации. Следуйте формату вывода из тестовых примеров.\n\nВыходные данные\n\nВходные данныеСкопировать17 5 2Выходные данныеСкопировать<< 3 4 (5) 6 7 >> Входные данныеСкопировать6 5 2Выходные данныеСкопировать<< 3 4 (5) 6 Входные данныеСкопировать6 1 2Выходные данныеСкопировать(1) 2 3 >> Входные данныеСкопировать6 2 2Выходные данныеСкопировать1 (2) 3 4 >>Входные данныеСкопировать9 6 3Выходные данныеСкопировать<< 3 4 5 (6) 7 8 9Входные данныеСкопировать10 6 3Выходные данныеСкопировать<< 3 4 5 (6) 7 8 9 >>Входные данныеСкопировать8 5 4Выходные данныеСкопировать1 2 3 4 (5) 6 7 8\n\nВходные данныеСкопировать17 5 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать<< 3 4 (5) 6 7 >>\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 5 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать<< 3 4 (5) 6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать(1) 2 3 >>\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 (2) 3 4 >>\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать9 6 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать<< 3 4 5 (6) 7 8 9\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 6 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать<< 3 4 5 (6) 7 8 9 >>\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать8 5 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 2 3 4 (5) 6 7 8\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #233 Editorial - Codeforces",
          "content": "Please write here if you had written some comments about any suggestions or questions on the announcement. There are a bunch of notification emails but I couldn't read most of them :(Here are the final top 100 : Div1, Div2. Congrats to the winners!(These links are all from google search cache, so it may be disappear) First of all, we are sorry to make this round unrated. This is an unexpected incident, and I believe that everyone in Codeforces would understand that. And second, we're sorry for estimating the difficulties of the problems wrong. Actually, I thought that somebody would get Accepted on 398A - Карточки within 5 minutes. But there wasn't any submissions during the first 4 minutes, and many people got wrong answer on pretests! I think almost everybody who solved this got at least one wrong answer.. I'm really sorry for measuring A easy. I think what cgy4ever said is right — it would be better not asking to print the sequence. At first, I purposed 398C - Дерево и массив as B(!!) because ainta solved it very easily than I expected. (I could hardly solve this, and thought it must be at least D, before I heard ainta's solution.) We're sorry for giving this problem the same score with 398B - Красим стену, which was much easier than 398C - Дерево и массив. Next time I'll remember that ainta is really a genius :) Congrats to four people who solved 398C - Дерево и массив during the contest! : cgy4ever, Shef, SillyHook06, and Qwaz. We are surprised that Petr solved 398E - Сортируем перестановки during the contest! Even though he implemented by Java, his solution is faster than ours :p Congratulations to him! Actually, we purposed an another problem for Div1-E, but the same problem popped out at OpenCup last Sunday, so we couldn't use that. Thanks to Gerald, who helped us preparing a new problem in such a short time. By the way, can you guess what problem was that? :D ... 399A - Страницы — Author : .o.You can solve this problem by just following the statement. First, print << if p - k > 1. Next, iterate all the integers from p - k to p + k, and print if the integer is in [1..n]. Finally, print >> if p + k < n. Time complexity: O(n). Code : 5926588 399B - Красные и синие шарики — Author : xtalclrChange the blue balls to bit 1, and blue balls to bit 0. Interpret the stack as an integer represented in binary digits. Now, one may see that a single operation decreases the integer by 1, and will be unavailable iff the integer becomes zero. So the answer will be 2a1 + 2a2 + ... + 2ak where the (ai + 1)-th (1 ≤ i ≤ k) ball is blue in the beginning. Time complexity: O(n) Code : 5926598 398A - Карточки — Author : .o.Let the number of o blocks p, and the number of x blocks q. It is obvious that |p - q| ≤ 1 and p, q ≤ n. So we can just iterate all p and q, and solve these two problems independently, and merge the answer.1. Maximize the value of x12 + x22 + ... + xp2 where x1 + x2 + ... + xp = a and xi ≥ 1. Assign a - p + 1 to x1, and assign 1 to x2, x3, ..., xp. The value is (a - p + 1)2 + (p - 1). 2. Minimize the value of y12 + y22 + ... + yq2 where y1 + y2 + ... + yq = b and yi ≥ 1. For all , assign to yi. For all , assign to yj. The value is . The proof is easy, so I won't do it. With this, we can solve the problem. We can print y1 xs, and then x1 os, ... Time complexity: O(n). Code : 5926607 Bonus: Is there any solution faster than O(n)? We tried to use ternary search, but we couldn't prove that was correct. 398B - Красим стену — Author : aintaThis can be solved by dynamic programming. Let T[i, j] the expected time when i rows and j columns doesn't have any painted cells inside.Let's see all the cases. If we carefully rearrange the order of rows and columns, we can divide the wall into 4 pieces. Choose a cell in rectangle 1. The size of this rectangle is i × j. The expectation value is T[i - 1, j - 1]. Choose a cell in rectangle 2. The size of this rectangle is i × (n - j). The expectation value is T[i - 1, j]. Choose a cell in rectangle 3. The size of this rectangle is (n - i) × j. The expectation value is T[i, j - 1]. Choose a cell in rectangle 4. The size of this rectangle is (n - i) × (n - j). The expectation value is T[i, j]. Merging these four cases, we can get:T[i, j] = 1 + {T[i - 1, j - 1] × i × j + T[i - 1, j] × i × (n - j) + T[i, j - 1] × (n - i) × j + T[i, j] × (n - i) × (n - j)} / n2Moving the T[i, j] on the right to the left, we can get the formula which can be used to calculate the value T[i, j]. There are some corner cases, like i = 0 or j = 0, but it can be simply handled. Time complexity: O(n2) Code : 5926617 398C - Дерево и массив — Author : .o.There are two intended solutions. One is easy, and the other is quite tricky.Easy SolutionMake a tree by the following method. For all , make an edge between vertex i and with weight 1. For all , make an edge between vertex i and i + 1 with weight . You can see that are all good pairs. In addition, (1, 3) is also a good pair. So we can print the answer.But, if n = 5, this method doesn't work because (1, 3) is not a good pair. In this case, one may solve by hand or using random algorithm. Time complexity: O(n) Code: 5926624 Bonus I: Is there any method to make more than good pairs? Bonus II: Is there any method that the maximum weight is relatively small and make at least good pairs? Tricky SolutionIf you got stuck with the problem, one can run any random algorithm that solves small cases, and merge these cases. With this approach, we can even limit the weight to a very small constant!But I think this is not a good solution, so I won't mention about unless anybody wants to know the details. I came up with this solution, and tried to purpose this as D. It seems all the 6 people who passed pretests during the contest didn't use this solution :) Time complexity: ??? Code : 5926632 398D - Мгновенные сообщения — Author : .o.Let xi an integer representing the state of the i-th user. If user i is online, xi  =  1, otherwise, xi  =  0. Also, let Si the set consisting of i-th friends.One can see that the queries become like this: Online/Offline: change the value of xi to 1  -  xi. Add: add u to set Sv, and v to set Su. Delete: delete u from set Sv, v from set Su. Count: calculate . Let's use sqrt-decomposition to perform these queries. Let user u heavy if |Su| ≥ C, or light otherwise. Also, we will define some arrays and sets: Hu is a set that stores friends with user u who are heavy users. O[u] stores the sum of . If the Online/Offline(u) query is given, If u is a light user: for all , change the value of O[v]. It takes O(|Su|) time. Otherwise: just update the state of itself. If the Add(u, v) query is given, If vertex u becomes heavy if we add this edge, for all , add v into Hw and update the value of O[w]. This can be done in O(C). If vertex u is still light even if we add the edge, update O[v]. This can be done in constant time. If vertex u is heavy (after the operations above), update Hv. Add u to set Sv, and v to set Su. If the Delete(u, v) query is given, Delete u from set Sv, and v from set Su. Update the value of O[*], Hu and Hv. Because for all |Hw| ≤  E| /  C, this can be done in O(|E| / C). If the counting query is given, will be the answer. Because |Hu| ≤ |E| / C, it will take O(|E| / C) time.So for each query, O(|E| / C) or O(C) time is required. To minimize the time, . Time complexity: Code : 5926635 We can also solve this by dividing the queries into parts. For each block, use O(n + m + q) time to build the online & offline state and the answer table for each vertices. For each query, you can use time to get the answer. If you want more details, please ask in the comments. Time complexity: Code : 5926640 398E - Сортируем перестановки — Author : xtalclr, eyTns, and great help of GeraldThe author is writing the solution, and it will come soon. Feel free to ask of or discuss about the solutions! Unfortunately, I don't know how to read or write Russian, so if you ask me in Russian, I can't response to it. (also, I think the Russian editorial won't be available..) Sorry for that.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10686",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 399\\s*A"
          },
          "content_length": 8084
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 1",
          "code": "unordered_set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 2",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 3",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 4",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 5",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 6",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 7",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(1, n, \"p\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(1, n, \"p\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(1, n, \"p\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isInteger(const string &s)\n{\n    if(s.empty()) return false;\n    for (char c : s) {\n        if (!isdigit(c)) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n_min = 3, n_max = 100;\n    string n_s = opt<string>(\"n\", \"random\");\n    string p_s = opt<string>(\"p\", \"random\");\n    string k_s = opt<string>(\"k\", \"random\");\n\n    int n;\n    if (n_s == \"random\") {\n        n = rnd.next(n_min, n_max);\n    } else if (isInteger(n_s)) {\n        n = stoi(n_s);\n        if (n < n_min || n > n_max) {\n            cerr << \"Error: n out of bounds\" << endl;\n            return 1;\n        }\n    } else {\n        cerr << \"Invalid n parameter\" << endl;\n        return 1;\n    }\n\n    int p;\n    if (p_s == \"first\") {\n        p = 1;\n    } else if (p_s == \"last\") {\n        p = n;\n    } else if (p_s == \"middle\") {\n        p = n / 2;\n    } else if (p_s == \"random\") {\n        p = rnd.next(1, n);\n    } else if (isInteger(p_s)) {\n        p = stoi(p_s);\n        if (p < 1 || p > n) {\n            cerr << \"Error: p out of bounds\" << endl;\n            return 1;\n        }\n    } else {\n        cerr << \"Invalid p parameter\" << endl;\n        return 1;\n    }\n\n    int k;\n    if (k_s == \"small\") {\n        k = 1;\n    } else if (k_s == \"large\") {\n        k = n;\n    } else if (k_s == \"half\") {\n        k = n / 2;\n    } else if (k_s == \"random\") {\n        k = rnd.next(1, n);\n    } else if (isInteger(k_s)) {\n        k = stoi(k_s);\n        if (k < 1 || k > n) {\n            cerr << \"Error: k out of bounds\" << endl;\n            return 1;\n        }\n    } else {\n        cerr << \"Invalid k parameter\" << endl;\n        return 1;\n    }\n\n    printf(\"%d %d %d\\n\", n, p, k);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isInteger(const string &s)\n{\n    if(s.empty()) return false;\n    for (char c : s) {\n        if (!isdigit(c)) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n_min = 3, n_max = 100;\n    string n_s = opt<string>(\"n\", \"random\");\n    string p_s = opt<string>(\"p\", \"random\");\n    string k_s = opt<string>(\"k\", \"random\");\n\n    int n;\n    if (n_s == \"random\") {\n        n = rnd.next(n_min, n_max);\n    } else if (isInteger(n_s)) {\n        n = stoi(n_s);\n        if (n < n_min || n > n_max) {\n            cerr << \"Error: n out of bounds\" << endl;\n            return 1;\n        }\n    } else {\n        cerr << \"Invalid n parameter\" << endl;\n        return 1;\n    }\n\n    int p;\n    if (p_s == \"first\") {\n        p = 1;\n    } else if (p_s == \"last\") {\n        p = n;\n    } else if (p_s == \"middle\") {\n        p = n / 2;\n    } else if (p_s == \"random\") {\n        p = rnd.next(1, n);\n    } else if (isInteger(p_s)) {\n        p = stoi(p_s);\n        if (p < 1 || p > n) {\n            cerr << \"Error: p out of bounds\" << endl;\n            return 1;\n        }\n    } else {\n        cerr << \"Invalid p parameter\" << endl;\n        return 1;\n    }\n\n    int k;\n    if (k_s == \"small\") {\n        k = 1;\n    } else if (k_s == \"large\") {\n        k = n;\n    } else if (k_s == \"half\") {\n        k = n / 2;\n    } else if (k_s == \"random\") {\n        k = rnd.next(1, n);\n    } else if (isInteger(k_s)) {\n        k = stoi(k_s);\n        if (k < 1 || k > n) {\n            cerr << \"Error: k out of bounds\" << endl;\n            return 1;\n        }\n    } else {\n        cerr << \"Invalid k parameter\" << endl;\n        return 1;\n    }\n\n    printf(\"%d %d %d\\n\", n, p, k);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen\n./gen -n random -p random -k random\n./gen -n 3 -p 1 -k 1\n./gen -n 100 -p middle -k half\n./gen -n 100 -p first -k half\n./gen -n 100 -p last -k half\n./gen -n 50 -p random -k small\n./gen -n 100 -p random -k large\n./gen -n 100 -p random -k 1\n./gen -n 100 -p random -k 99\n./gen -n 10 -p 1 -k 5\n./gen -n 10 -p 10 -k 5\n./gen -n 10 -p 5 -k 5\n./gen -n 10 -p 5 -k 1\n./gen -n 10 -p 5 -k 9\n./gen -n 10 -p 5 -k 10\n./gen -n 3 -p 3 -k 1\n./gen -n 3 -p 1 -k 2\n./gen -n 100 -p 1 -k half\n./gen -n 100 -p 100 -k half\n./gen -n 100 -p middle -k small\n./gen -n 50 -p random -k half\n./gen -n random -p first -k random\n./gen -n random -p last -k random\n./gen -n random -p middle -k random\n./gen -n random -p random -k half\n./gen -n random -p random -k small\n./gen -n random -p random -k large\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:50.264031",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "399/B",
      "title": "B. Red and Blue Balls",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test0.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 50) — the number of balls inside the stack.The second line contains a string s (|s| = n) describing the initial state of the stack. The i-th character of the string s denotes the color of the i-th ball (we'll number the balls from top to bottom of the stack). If the character is \"R\", the color is red. If the character is \"B\", the color is blue.",
      "output_spec": "OutputPrint the maximum number of operations ainta can repeatedly apply.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy3RBROutputCopy2InputCopy4RBBROutputCopy6InputCopy5RBBRROutputCopy6",
      "description": "B. Red and Blue Balls\n\ntime limit per test0.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 50) — the number of balls inside the stack.The second line contains a string s (|s| = n) describing the initial state of the stack. The i-th character of the string s denotes the color of the i-th ball (we'll number the balls from top to bottom of the stack). If the character is \"R\", the color is red. If the character is \"B\", the color is blue.\n\nOutputPrint the maximum number of operations ainta can repeatedly apply.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy3RBROutputCopy2InputCopy4RBBROutputCopy6InputCopy5RBBRROutputCopy6\n\nInputCopy3RBR\n\nOutputCopy2\n\nInputCopy4RBBR\n\nOutputCopy6\n\nInputCopy5RBBRR\n\nOutputCopy6\n\nNoteThe first example is depicted below.The explanation how user ainta applies the first operation. He pops out one red ball, changes the color of the ball in the middle from blue to red, and pushes one blue ball.  The explanation how user ainta applies the second operation. He will not pop out red balls, he simply changes the color of the ball on the top from blue to red.  From now on, ainta can't apply any operation because there are no blue balls inside the stack. ainta applied two operations, so the answer is 2.The second example is depicted below. The blue arrow denotes a single operation.",
      "solutions": [
        {
          "title": "Codeforces Round #233 Editorial - Codeforces",
          "content": "Please write here if you had written some comments about any suggestions or questions on the announcement. There are a bunch of notification emails but I couldn't read most of them :(Here are the final top 100 : Div1, Div2. Congrats to the winners!(These links are all from google search cache, so it may be disappear) First of all, we are sorry to make this round unrated. This is an unexpected incident, and I believe that everyone in Codeforces would understand that. And second, we're sorry for estimating the difficulties of the problems wrong. Actually, I thought that somebody would get Accepted on 398A - Cards within 5 minutes. But there wasn't any submissions during the first 4 minutes, and many people got wrong answer on pretests! I think almost everybody who solved this got at least one wrong answer.. I'm really sorry for measuring A easy. I think what cgy4ever said is right — it would be better not asking to print the sequence. At first, I purposed 398C - Tree and Array as B(!!) because ainta solved it very easily than I expected. (I could hardly solve this, and thought it must be at least D, before I heard ainta's solution.) We're sorry for giving this problem the same score with 398B - Painting The Wall, which was much easier than 398C - Tree and Array. Next time I'll remember that ainta is really a genius :) Congrats to four people who solved 398C - Tree and Array during the contest! : cgy4ever, Shef, SillyHook06, and Qwaz. We are surprised that Petr solved 398E - Sorting Permutations during the contest! Even though he implemented by Java, his solution is faster than ours :p Congratulations to him! Actually, we purposed an another problem for Div1-E, but the same problem popped out at OpenCup last Sunday, so we couldn't use that. Thanks to Gerald, who helped us preparing a new problem in such a short time. By the way, can you guess what problem was that? :D ... 399A - Pages — Author : .o.You can solve this problem by just following the statement. First, print << if p - k > 1. Next, iterate all the integers from p - k to p + k, and print if the integer is in [1..n]. Finally, print >> if p + k < n. Time complexity: O(n). Code : 5926588 399B - Red and Blue Balls — Author : xtalclrChange the blue balls to bit 1, and blue balls to bit 0. Interpret the stack as an integer represented in binary digits. Now, one may see that a single operation decreases the integer by 1, and will be unavailable iff the integer becomes zero. So the answer will be 2a1 + 2a2 + ... + 2ak where the (ai + 1)-th (1 ≤ i ≤ k) ball is blue in the beginning. Time complexity: O(n) Code : 5926598 398A - Cards — Author : .o.Let the number of o blocks p, and the number of x blocks q. It is obvious that |p - q| ≤ 1 and p, q ≤ n. So we can just iterate all p and q, and solve these two problems independently, and merge the answer.1. Maximize the value of x12 + x22 + ... + xp2 where x1 + x2 + ... + xp = a and xi ≥ 1. Assign a - p + 1 to x1, and assign 1 to x2, x3, ..., xp. The value is (a - p + 1)2 + (p - 1). 2. Minimize the value of y12 + y22 + ... + yq2 where y1 + y2 + ... + yq = b and yi ≥ 1. For all , assign to yi. For all , assign to yj. The value is . The proof is easy, so I won't do it. With this, we can solve the problem. We can print y1 xs, and then x1 os, ... Time complexity: O(n). Code : 5926607 Bonus: Is there any solution faster than O(n)? We tried to use ternary search, but we couldn't prove that was correct. 398B - Painting The Wall — Author : aintaThis can be solved by dynamic programming. Let T[i, j] the expected time when i rows and j columns doesn't have any painted cells inside.Let's see all the cases. If we carefully rearrange the order of rows and columns, we can divide the wall into 4 pieces. Choose a cell in rectangle 1. The size of this rectangle is i × j. The expectation value is T[i - 1, j - 1]. Choose a cell in rectangle 2. The size of this rectangle is i × (n - j). The expectation value is T[i - 1, j]. Choose a cell in rectangle 3. The size of this rectangle is (n - i) × j. The expectation value is T[i, j - 1]. Choose a cell in rectangle 4. The size of this rectangle is (n - i) × (n - j). The expectation value is T[i, j]. Merging these four cases, we can get:T[i, j] = 1 + {T[i - 1, j - 1] × i × j + T[i - 1, j] × i × (n - j) + T[i, j - 1] × (n - i) × j + T[i, j] × (n - i) × (n - j)} / n2Moving the T[i, j] on the right to the left, we can get the formula which can be used to calculate the value T[i, j]. There are some corner cases, like i = 0 or j = 0, but it can be simply handled. Time complexity: O(n2) Code : 5926617 398C - Tree and Array — Author : .o.There are two intended solutions. One is easy, and the other is quite tricky.Easy SolutionMake a tree by the following method. For all , make an edge between vertex i and with weight 1. For all , make an edge between vertex i and i + 1 with weight . You can see that are all good pairs. In addition, (1, 3) is also a good pair. So we can print the answer.But, if n = 5, this method doesn't work because (1, 3) is not a good pair. In this case, one may solve by hand or using random algorithm. Time complexity: O(n) Code: 5926624 Bonus I: Is there any method to make more than good pairs? Bonus II: Is there any method that the maximum weight is relatively small and make at least good pairs? Tricky SolutionIf you got stuck with the problem, one can run any random algorithm that solves small cases, and merge these cases. With this approach, we can even limit the weight to a very small constant!But I think this is not a good solution, so I won't mention about unless anybody wants to know the details. I came up with this solution, and tried to purpose this as D. It seems all the 6 people who passed pretests during the contest didn't use this solution :) Time complexity: ??? Code : 5926632 398D - Instant Messanger — Author : .o.Let xi an integer representing the state of the i-th user. If user i is online, xi  =  1, otherwise, xi  =  0. Also, let Si the set consisting of i-th friends.One can see that the queries become like this: Online/Offline: change the value of xi to 1  -  xi. Add: add u to set Sv, and v to set Su. Delete: delete u from set Sv, v from set Su. Count: calculate . Let's use sqrt-decomposition to perform these queries. Let user u heavy if |Su| ≥ C, or light otherwise. Also, we will define some arrays and sets: Hu is a set that stores friends with user u who are heavy users. O[u] stores the sum of . If the Online/Offline(u) query is given, If u is a light user: for all , change the value of O[v]. It takes O(|Su|) time. Otherwise: just update the state of itself. If the Add(u, v) query is given, If vertex u becomes heavy if we add this edge, for all , add v into Hw and update the value of O[w]. This can be done in O(C). If vertex u is still light even if we add the edge, update O[v]. This can be done in constant time. If vertex u is heavy (after the operations above), update Hv. Add u to set Sv, and v to set Su. If the Delete(u, v) query is given, Delete u from set Sv, and v from set Su. Update the value of O[*], Hu and Hv. Because for all |Hw| ≤  E| /  C, this can be done in O(|E| / C). If the counting query is given, will be the answer. Because |Hu| ≤ |E| / C, it will take O(|E| / C) time.So for each query, O(|E| / C) or O(C) time is required. To minimize the time, . Time complexity: Code : 5926635 We can also solve this by dividing the queries into parts. For each block, use O(n + m + q) time to build the online & offline state and the answer table for each vertices. For each query, you can use time to get the answer. If you want more details, please ask in the comments. Time complexity: Code : 5926640 398E - Sorting Permutations — Author : xtalclr, eyTns, and great help of GeraldHere is the draft solution. Feel free to ask of or discuss about the solutions! Unfortunately, I don't know how to read or write Russian, so if you ask me in Russian, I can't response to it. (also, I think the Russian editorial won't be available..) Sorry for that.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10686",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 399\\s*B"
          },
          "content_length": 8039
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 1",
          "code": "unordered_set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 2",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 3",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 4",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 5",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 6",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 7",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[RB]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[RB]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[RB]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int blue_count = opt<int>(\"b\", -1); // Optional parameter for specifying the number of blue balls\n\n    string s(n, 'R'); // Initialize the stack with all red balls\n\n    if (type == \"all_red\") {\n        // Stack is already all red\n    } else if (type == \"all_blue\") {\n        s.assign(n, 'B');\n    } else if (type == \"alternating\") {\n        for(int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? 'R' : 'B';\n        }\n    } else if (type == \"single_blue_top\") {\n        s[0] = 'B';\n    } else if (type == \"single_blue_bottom\") {\n        s[n - 1] = 'B';\n    } else if (type == \"single_blue_middle\") {\n        s[n / 2] = 'B';\n    } else if (type == \"random\") {\n        if (blue_count == -1) {\n            // Randomly assign 'R' or 'B' to each position\n            for(int i = 0; i < n; ++i) {\n                s[i] = rnd.next(2) ? 'R' : 'B';\n            }\n        } else {\n            // Generate exactly blue_count blue balls\n            if (blue_count > n)\n                blue_count = n;\n            vector<char> balls(n, 'R');\n            for(int i = 0; i < blue_count; ++i) {\n                balls[i] = 'B';\n            }\n            shuffle(balls.begin(), balls.end());\n            s = string(balls.begin(), balls.end());\n        }\n    } else {\n        // Default to random if unknown type\n        for(int i = 0; i < n; ++i) {\n            s[i] = rnd.next(2) ? 'R' : 'B';\n        }\n    }\n\n    // Output n and s\n    printf(\"%d\\n%s\\n\", n, s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int blue_count = opt<int>(\"b\", -1); // Optional parameter for specifying the number of blue balls\n\n    string s(n, 'R'); // Initialize the stack with all red balls\n\n    if (type == \"all_red\") {\n        // Stack is already all red\n    } else if (type == \"all_blue\") {\n        s.assign(n, 'B');\n    } else if (type == \"alternating\") {\n        for(int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? 'R' : 'B';\n        }\n    } else if (type == \"single_blue_top\") {\n        s[0] = 'B';\n    } else if (type == \"single_blue_bottom\") {\n        s[n - 1] = 'B';\n    } else if (type == \"single_blue_middle\") {\n        s[n / 2] = 'B';\n    } else if (type == \"random\") {\n        if (blue_count == -1) {\n            // Randomly assign 'R' or 'B' to each position\n            for(int i = 0; i < n; ++i) {\n                s[i] = rnd.next(2) ? 'R' : 'B';\n            }\n        } else {\n            // Generate exactly blue_count blue balls\n            if (blue_count > n)\n                blue_count = n;\n            vector<char> balls(n, 'R');\n            for(int i = 0; i < blue_count; ++i) {\n                balls[i] = 'B';\n            }\n            shuffle(balls.begin(), balls.end());\n            s = string(balls.begin(), balls.end());\n        }\n    } else {\n        // Default to random if unknown type\n        for(int i = 0; i < n; ++i) {\n            s[i] = rnd.next(2) ? 'R' : 'B';\n        }\n    }\n\n    // Output n and s\n    printf(\"%d\\n%s\\n\", n, s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_red\n./gen -n 1 -type all_blue\n\n./gen -n 2 -type single_blue_top\n./gen -n 2 -type single_blue_bottom\n./gen -n 2 -type alternating\n\n./gen -n 3 -type single_blue_middle\n./gen -n 3 -type alternating\n\n./gen -n 5 -type all_red\n./gen -n 5 -type all_blue\n./gen -n 5 -type single_blue_top\n./gen -n 5 -type single_blue_middle\n./gen -n 5 -type single_blue_bottom\n\n./gen -n 10 -type random\n./gen -n 10 -type random -b 0\n./gen -n 10 -type random -b 1\n./gen -n 10 -type random -b 5\n./gen -n 10 -type random -b 10\n\n./gen -n 20 -type random\n./gen -n 20 -type random -b 1\n./gen -n 20 -type random -b 10\n./gen -n 20 -type random -b 19\n./gen -n 20 -type alternating\n\n./gen -n 30 -type random\n./gen -n 30 -type random -b 15\n./gen -n 30 -type random -b 0\n./gen -n 30 -type random -b 30\n\n./gen -n 50 -type all_red\n./gen -n 50 -type all_blue\n./gen -n 50 -type random\n./gen -n 50 -type random -b 1\n./gen -n 50 -type random -b 25\n./gen -n 50 -type random -b 49\n./gen -n 50 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:52.166287",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "399/C",
      "title": "C. Cards",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers a and b (0 ≤ a, b ≤ 105; a + b ≥ 1) — the number of \"o\" cards and the number of \"x\" cards.",
      "output_spec": "OutputIn the first line print a single integer v — the maximum score that ainta can obtain.In the second line print a + b characters describing the deck. If the k-th card of the deck contains \"o\", the k-th character must be \"o\". If the k-th card of the deck contains \"x\", the k-th character must be \"x\". The number of \"o\" characters must be equal to a, and the number of \"x \" characters must be equal to b. If there are many ways to maximize v, print any.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
      "sample_tests": "ExamplesInputCopy2 3OutputCopy-1xoxoxInputCopy4 0OutputCopy16ooooInputCopy0 4OutputCopy-16xxxx",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers a and b (0 ≤ a, b ≤ 105; a + b ≥ 1) — the number of \"o\" cards and the number of \"x\" cards.\n\nOutputIn the first line print a single integer v — the maximum score that ainta can obtain.In the second line print a + b characters describing the deck. If the k-th card of the deck contains \"o\", the k-th character must be \"o\". If the k-th card of the deck contains \"x\", the k-th character must be \"x\". The number of \"o\" characters must be equal to a, and the number of \"x \" characters must be equal to b. If there are many ways to maximize v, print any.Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\nInputCopy2 3OutputCopy-1xoxoxInputCopy4 0OutputCopy16ooooInputCopy0 4OutputCopy-16xxxx\n\nInputCopy2 3\n\nOutputCopy-1xoxox\n\nInputCopy4 0\n\nOutputCopy16oooo\n\nInputCopy0 4\n\nOutputCopy-16xxxx",
      "solutions": [
        {
          "title": "Codeforces Round #233 Editorial - Codeforces",
          "content": "Please write here if you had written some comments about any suggestions or questions on the announcement. There are a bunch of notification emails but I couldn't read most of them :(Here are the final top 100 : Div1, Div2. Congrats to the winners!(These links are all from google search cache, so it may be disappear) First of all, we are sorry to make this round unrated. This is an unexpected incident, and I believe that everyone in Codeforces would understand that. And second, we're sorry for estimating the difficulties of the problems wrong. Actually, I thought that somebody would get Accepted on 398A - Cards within 5 minutes. But there wasn't any submissions during the first 4 minutes, and many people got wrong answer on pretests! I think almost everybody who solved this got at least one wrong answer.. I'm really sorry for measuring A easy. I think what cgy4ever said is right — it would be better not asking to print the sequence. At first, I purposed 398C - Tree and Array as B(!!) because ainta solved it very easily than I expected. (I could hardly solve this, and thought it must be at least D, before I heard ainta's solution.) We're sorry for giving this problem the same score with 398B - Painting The Wall, which was much easier than 398C - Tree and Array. Next time I'll remember that ainta is really a genius :) Congrats to four people who solved 398C - Tree and Array during the contest! : cgy4ever, Shef, SillyHook06, and Qwaz. We are surprised that Petr solved 398E - Sorting Permutations during the contest! Even though he implemented by Java, his solution is faster than ours :p Congratulations to him! Actually, we purposed an another problem for Div1-E, but the same problem popped out at OpenCup last Sunday, so we couldn't use that. Thanks to Gerald, who helped us preparing a new problem in such a short time. By the way, can you guess what problem was that? :D ... 399A - Pages — Author : .o.You can solve this problem by just following the statement. First, print << if p - k > 1. Next, iterate all the integers from p - k to p + k, and print if the integer is in [1..n]. Finally, print >> if p + k < n. Time complexity: O(n). Code : 5926588 399B - Red and Blue Balls — Author : xtalclrChange the blue balls to bit 1, and blue balls to bit 0. Interpret the stack as an integer represented in binary digits. Now, one may see that a single operation decreases the integer by 1, and will be unavailable iff the integer becomes zero. So the answer will be 2a1 + 2a2 + ... + 2ak where the (ai + 1)-th (1 ≤ i ≤ k) ball is blue in the beginning. Time complexity: O(n) Code : 5926598 398A - Cards — Author : .o.Let the number of o blocks p, and the number of x blocks q. It is obvious that |p - q| ≤ 1 and p, q ≤ n. So we can just iterate all p and q, and solve these two problems independently, and merge the answer.1. Maximize the value of x12 + x22 + ... + xp2 where x1 + x2 + ... + xp = a and xi ≥ 1. Assign a - p + 1 to x1, and assign 1 to x2, x3, ..., xp. The value is (a - p + 1)2 + (p - 1). 2. Minimize the value of y12 + y22 + ... + yq2 where y1 + y2 + ... + yq = b and yi ≥ 1. For all , assign to yi. For all , assign to yj. The value is . The proof is easy, so I won't do it. With this, we can solve the problem. We can print y1 xs, and then x1 os, ... Time complexity: O(n). Code : 5926607 Bonus: Is there any solution faster than O(n)? We tried to use ternary search, but we couldn't prove that was correct. 398B - Painting The Wall — Author : aintaThis can be solved by dynamic programming. Let T[i, j] the expected time when i rows and j columns doesn't have any painted cells inside.Let's see all the cases. If we carefully rearrange the order of rows and columns, we can divide the wall into 4 pieces. Choose a cell in rectangle 1. The size of this rectangle is i × j. The expectation value is T[i - 1, j - 1]. Choose a cell in rectangle 2. The size of this rectangle is i × (n - j). The expectation value is T[i - 1, j]. Choose a cell in rectangle 3. The size of this rectangle is (n - i) × j. The expectation value is T[i, j - 1]. Choose a cell in rectangle 4. The size of this rectangle is (n - i) × (n - j). The expectation value is T[i, j]. Merging these four cases, we can get:T[i, j] = 1 + {T[i - 1, j - 1] × i × j + T[i - 1, j] × i × (n - j) + T[i, j - 1] × (n - i) × j + T[i, j] × (n - i) × (n - j)} / n2Moving the T[i, j] on the right to the left, we can get the formula which can be used to calculate the value T[i, j]. There are some corner cases, like i = 0 or j = 0, but it can be simply handled. Time complexity: O(n2) Code : 5926617 398C - Tree and Array — Author : .o.There are two intended solutions. One is easy, and the other is quite tricky.Easy SolutionMake a tree by the following method. For all , make an edge between vertex i and with weight 1. For all , make an edge between vertex i and i + 1 with weight . You can see that are all good pairs. In addition, (1, 3) is also a good pair. So we can print the answer.But, if n = 5, this method doesn't work because (1, 3) is not a good pair. In this case, one may solve by hand or using random algorithm. Time complexity: O(n) Code: 5926624 Bonus I: Is there any method to make more than good pairs? Bonus II: Is there any method that the maximum weight is relatively small and make at least good pairs? Tricky SolutionIf you got stuck with the problem, one can run any random algorithm that solves small cases, and merge these cases. With this approach, we can even limit the weight to a very small constant!But I think this is not a good solution, so I won't mention about unless anybody wants to know the details. I came up with this solution, and tried to purpose this as D. It seems all the 6 people who passed pretests during the contest didn't use this solution :) Time complexity: ??? Code : 5926632 398D - Instant Messanger — Author : .o.Let xi an integer representing the state of the i-th user. If user i is online, xi  =  1, otherwise, xi  =  0. Also, let Si the set consisting of i-th friends.One can see that the queries become like this: Online/Offline: change the value of xi to 1  -  xi. Add: add u to set Sv, and v to set Su. Delete: delete u from set Sv, v from set Su. Count: calculate . Let's use sqrt-decomposition to perform these queries. Let user u heavy if |Su| ≥ C, or light otherwise. Also, we will define some arrays and sets: Hu is a set that stores friends with user u who are heavy users. O[u] stores the sum of . If the Online/Offline(u) query is given, If u is a light user: for all , change the value of O[v]. It takes O(|Su|) time. Otherwise: just update the state of itself. If the Add(u, v) query is given, If vertex u becomes heavy if we add this edge, for all , add v into Hw and update the value of O[w]. This can be done in O(C). If vertex u is still light even if we add the edge, update O[v]. This can be done in constant time. If vertex u is heavy (after the operations above), update Hv. Add u to set Sv, and v to set Su. If the Delete(u, v) query is given, Delete u from set Sv, and v from set Su. Update the value of O[*], Hu and Hv. Because for all |Hw| ≤  E| /  C, this can be done in O(|E| / C). If the counting query is given, will be the answer. Because |Hu| ≤ |E| / C, it will take O(|E| / C) time.So for each query, O(|E| / C) or O(C) time is required. To minimize the time, . Time complexity: Code : 5926635 We can also solve this by dividing the queries into parts. For each block, use O(n + m + q) time to build the online & offline state and the answer table for each vertices. For each query, you can use time to get the answer. If you want more details, please ask in the comments. Time complexity: Code : 5926640 398E - Sorting Permutations — Author : xtalclr, eyTns, and great help of GeraldHere is the draft solution. Feel free to ask of or discuss about the solutions! Unfortunately, I don't know how to read or write Russian, so if you ask me in Russian, I can't response to it. (also, I think the Russian editorial won't be available..) Sorry for that.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10686",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 399 和字母"
          },
          "content_length": 8039
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 1",
          "code": "unordered_set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 2",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 3",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 4",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 5",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 6",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 7",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(0, 100000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 100000, \"b\");\n    inf.readEoln();\n    ensuref(a + b >= 1, \"At least one card must exist (a + b >= 1)\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(0, 100000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 100000, \"b\");\n    inf.readEoln();\n    ensuref(a + b >= 1, \"At least one card must exist (a + b >= 1)\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(0, 100000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 100000, \"b\");\n    inf.readEoln();\n    ensuref(a + b >= 1, \"At least one card must exist (a + b >= 1)\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long computeScore(const string& s) {\n    long long score = 0;\n    int n = s.size();\n    int i = 0;\n    while (i < n) {\n        char c = s[i];\n        if (c != 'o' && c != 'x')\n            return LLONG_MIN; // invalid character\n        int j = i;\n        while (j < n && s[j] == c)\n            ++j;\n        int len = j - i;\n        if (c == 'o')\n            score += 1LL * len * len;\n        else if (c == 'x')\n            score -= 1LL * len * len;\n        i = j;\n    }\n    return score;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input\n    int a = inf.readInt(0, 100000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(0, 100000, \"b\");\n    inf.readEoln();\n    if (a + b < 1)\n        quitf(_fail, \"Invalid input: a + b must be at least 1\");\n\n    // Read jury's answer\n    long long v_jury = ans.readLong();\n    ans.readEoln();\n    string s_jury = ans.readLine();\n\n    // Validate jury's arrangement\n    if ((int)s_jury.size() != a + b)\n        quitf(_fail, \"Jury's arrangement length (%d) is not equal to a + b (%d)\", (int)s_jury.size(), a + b);\n\n    int count_o = 0, count_x = 0;\n    for (char c : s_jury) {\n        if (c == 'o')\n            ++count_o;\n        else if (c == 'x')\n            ++count_x;\n        else\n            quitf(_fail, \"Jury's arrangement contains invalid character '%c'\", c);\n    }\n    if (count_o != a)\n        quitf(_fail, \"Jury's arrangement contains %d 'o's, expected %d\", count_o, a);\n    if (count_x != b)\n        quitf(_fail, \"Jury's arrangement contains %d 'x's, expected %d\", count_x, b);\n\n    long long score_jury = computeScore(s_jury);\n    if (score_jury != v_jury)\n        quitf(_fail, \"Jury's arrangement score (%lld) does not match jury's claimed value (%lld)\", score_jury, v_jury);\n\n    // Read participant's answer\n    long long v_participant = ouf.readLong();\n    ouf.readEoln();\n    string s_participant = ouf.readLine();\n\n    // Validate participant's arrangement\n    if ((int)s_participant.size() != a + b)\n        quitf(_wa, \"Participant's arrangement length (%d) is not equal to a + b (%d)\", (int)s_participant.size(), a + b);\n\n    count_o = 0;\n    count_x = 0;\n    for (char c : s_participant) {\n        if (c == 'o')\n            ++count_o;\n        else if (c == 'x')\n            ++count_x;\n        else\n            quitf(_wa, \"Participant's arrangement contains invalid character '%c'\", c);\n    }\n    if (count_o != a)\n        quitf(_wa, \"Participant's arrangement contains %d 'o's, expected %d\", count_o, a);\n    if (count_x != b)\n        quitf(_wa, \"Participant's arrangement contains %d 'x's, expected %d\", count_x, b);\n\n    long long score_participant = computeScore(s_participant);\n    if (score_participant != v_participant)\n        quitf(_wa, \"Participant's arrangement score (%lld) does not match participant's claimed value (%lld)\", score_participant, v_participant);\n\n    if (v_participant > v_jury)\n        quitf(_fail, \"Participant's score (%lld) is better than jury's score (%lld)\", v_participant, v_jury);\n    else if (v_participant < v_jury)\n        quitf(_wa, \"Participant's score (%lld) is less than the optimal score (%lld)\", v_participant, v_jury);\n    else\n        quitf(_ok, \"Correct. Participant's score matches the optimal score (%lld)\", v_participant);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (a == -1 || b == -1) {\n        // a or b not provided, generate according to type\n        if (type == \"max_a\") {\n            a = 100000;\n            b = 0;\n        } else if (type == \"max_b\") {\n            b = 100000;\n            a = 0;\n        } else if (type == \"both_max\") {\n            a = 100000;\n            b = 100000;\n        } else if (type == \"min_values\") {\n            a = 1;\n            b = 0;\n        } else if (type == \"edge_case_a_zero\") {\n            a = 0;\n            b = rnd.next(1, 100000);\n        } else if (type == \"edge_case_b_zero\") {\n            a = rnd.next(1, 100000);\n            b = 0;\n        } else if (type == \"random\") {\n            a = rnd.next(0, 100000);\n            b = rnd.next(0, 100000);\n            if (a + b == 0) { // ensure a+b ≥1\n                int flip = rnd.next(0,1);\n                if (flip == 0) a = 1;\n                else b = 1;\n            }\n        } else {\n            // Unknown type\n            cerr << \"Unknown type: \" << type << endl;\n            exit(1);\n        }\n    } else {\n        // a and b provided, check constraints\n        if (a < 0 || a > 100000 || b < 0 || b > 100000 || a + b < 1) {\n            cerr << \"Invalid values of a and b: \" << a << \" \" << b << endl;\n            exit(1);\n        }\n    }\n\n    // Output a and b\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (a == -1 || b == -1) {\n        // a or b not provided, generate according to type\n        if (type == \"max_a\") {\n            a = 100000;\n            b = 0;\n        } else if (type == \"max_b\") {\n            b = 100000;\n            a = 0;\n        } else if (type == \"both_max\") {\n            a = 100000;\n            b = 100000;\n        } else if (type == \"min_values\") {\n            a = 1;\n            b = 0;\n        } else if (type == \"edge_case_a_zero\") {\n            a = 0;\n            b = rnd.next(1, 100000);\n        } else if (type == \"edge_case_b_zero\") {\n            a = rnd.next(1, 100000);\n            b = 0;\n        } else if (type == \"random\") {\n            a = rnd.next(0, 100000);\n            b = rnd.next(0, 100000);\n            if (a + b == 0) { // ensure a+b ≥1\n                int flip = rnd.next(0,1);\n                if (flip == 0) a = 1;\n                else b = 1;\n            }\n        } else {\n            // Unknown type\n            cerr << \"Unknown type: \" << type << endl;\n            exit(1);\n        }\n    } else {\n        // a and b provided, check constraints\n        if (a < 0 || a > 100000 || b < 0 || b > 100000 || a + b < 1) {\n            cerr << \"Invalid values of a and b: \" << a << \" \" << b << endl;\n            exit(1);\n        }\n    }\n\n    // Output a and b\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Command to generate minimal values\n./gen -type min_values\n\n# Commands to generate maximal 'a' and 'b' values\n./gen -type max_a\n./gen -type max_b\n./gen -type both_max\n\n# Commands to generate edge cases where 'a' or 'b' is zero\n./gen -type edge_case_a_zero\n./gen -type edge_case_b_zero\n\n# Commands to generate specific small values\n./gen -a 0 -b 1\n./gen -a 1 -b 0\n./gen -a 1 -b 1\n./gen -a 2 -b 1\n./gen -a 1 -b 2\n./gen -a 5 -b 5\n./gen -a 10 -b 90\n./gen -a 90 -b 10\n\n# Commands to generate specific large values\n./gen -a 99999 -b 1\n./gen -a 1 -b 99999\n./gen -a 50000 -b 50000\n./gen -a 99999 -b 99999\n./gen -a 100000 -b 0\n./gen -a 0 -b 100000\n\n# Commands to generate random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Commands to generate edge cases where a + b equals 1\n./gen -a 1 -b 0\n./gen -a 0 -b 1\n\n# Commands to generate edge cases where 'a' and 'b' are small and equal\n./gen -a 1 -b 1\n./gen -a 2 -b 2\n./gen -a 3 -b 3\n./gen -a 4 -b 4\n./gen -a 5 -b 5\n\n# Commands to generate edge cases where 'a' is much larger than 'b' and vice versa\n./gen -a 100000 -b 1\n./gen -a 1 -b 100000\n./gen -a 100000 -b 2\n./gen -a 2 -b 100000\n\n# Commands to generate edge cases where both 'a' and 'b' are large but not maximum\n./gen -a 99998 -b 99998\n./gen -a 50000 -b 50000\n\n# Commands to generate edge cases where 'a' or 'b' is near zero\n./gen -a 1 -b 99999\n./gen -a 99999 -b 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:54.342899",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "399/D",
      "title": "D. Красим стену",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа, n и m (1 ≤ n ≤ 2·103; 0 ≤ m ≤ min(n2, 2·104)) — размер стены и количество изначально окрашенных ячеек.Затем следует m строк, в каждой записано по два целых числа, ri и ci (1 ≤ ri, ci ≤ n) — номер строки и номер столбца очередной окрашенной плитки на стене. Гарантируется, что все позиции окрашенных плиток различны.",
      "output_spec": "Выходные данныеВ единственной строке выведите математическое ожидание времени, необходимого на покраску стены, в минутах. Ваш ответ будет считаться правильным, если величина его абсолютной или относительной погрешности не превышает 10 - 4.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 22 34 1Выходные данныеСкопировать11.7669491886Входные данныеСкопировать2 21 11 2Выходные данныеСкопировать2.0000000000Входные данныеСкопировать1 11 1Выходные данныеСкопировать0.0000000000",
      "description": "D. Красим стену\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа, n и m (1 ≤ n ≤ 2·103; 0 ≤ m ≤ min(n2, 2·104)) — размер стены и количество изначально окрашенных ячеек.Затем следует m строк, в каждой записано по два целых числа, ri и ci (1 ≤ ri, ci ≤ n) — номер строки и номер столбца очередной окрашенной плитки на стене. Гарантируется, что все позиции окрашенных плиток различны.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите математическое ожидание времени, необходимого на покраску стены, в минутах. Ваш ответ будет считаться правильным, если величина его абсолютной или относительной погрешности не превышает 10 - 4.\n\nВыходные данные\n\nВходные данныеСкопировать5 22 34 1Выходные данныеСкопировать11.7669491886Входные данныеСкопировать2 21 11 2Выходные данныеСкопировать2.0000000000Входные данныеСкопировать1 11 1Выходные данныеСкопировать0.0000000000\n\nВходные данныеСкопировать5 22 34 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать11.7669491886\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 21 11 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2.0000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 11 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0.0000000000\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #233 Editorial - Codeforces",
          "content": "Please write here if you had written some comments about any suggestions or questions on the announcement. There are a bunch of notification emails but I couldn't read most of them :(Here are the final top 100 : Div1, Div2. Congrats to the winners!(These links are all from google search cache, so it may be disappear) First of all, we are sorry to make this round unrated. This is an unexpected incident, and I believe that everyone in Codeforces would understand that. And second, we're sorry for estimating the difficulties of the problems wrong. Actually, I thought that somebody would get Accepted on 398A - Карточки within 5 minutes. But there wasn't any submissions during the first 4 minutes, and many people got wrong answer on pretests! I think almost everybody who solved this got at least one wrong answer.. I'm really sorry for measuring A easy. I think what cgy4ever said is right — it would be better not asking to print the sequence. At first, I purposed 398C - Дерево и массив as B(!!) because ainta solved it very easily than I expected. (I could hardly solve this, and thought it must be at least D, before I heard ainta's solution.) We're sorry for giving this problem the same score with 398B - Красим стену, which was much easier than 398C - Дерево и массив. Next time I'll remember that ainta is really a genius :) Congrats to four people who solved 398C - Дерево и массив during the contest! : cgy4ever, Shef, SillyHook06, and Qwaz. We are surprised that Petr solved 398E - Сортируем перестановки during the contest! Even though he implemented by Java, his solution is faster than ours :p Congratulations to him! Actually, we purposed an another problem for Div1-E, but the same problem popped out at OpenCup last Sunday, so we couldn't use that. Thanks to Gerald, who helped us preparing a new problem in such a short time. By the way, can you guess what problem was that? :D ... 399A - Страницы — Author : .o.You can solve this problem by just following the statement. First, print << if p - k > 1. Next, iterate all the integers from p - k to p + k, and print if the integer is in [1..n]. Finally, print >> if p + k < n. Time complexity: O(n). Code : 5926588 399B - Красные и синие шарики — Author : xtalclrChange the blue balls to bit 1, and blue balls to bit 0. Interpret the stack as an integer represented in binary digits. Now, one may see that a single operation decreases the integer by 1, and will be unavailable iff the integer becomes zero. So the answer will be 2a1 + 2a2 + ... + 2ak where the (ai + 1)-th (1 ≤ i ≤ k) ball is blue in the beginning. Time complexity: O(n) Code : 5926598 398A - Карточки — Author : .o.Let the number of o blocks p, and the number of x blocks q. It is obvious that |p - q| ≤ 1 and p, q ≤ n. So we can just iterate all p and q, and solve these two problems independently, and merge the answer.1. Maximize the value of x12 + x22 + ... + xp2 where x1 + x2 + ... + xp = a and xi ≥ 1. Assign a - p + 1 to x1, and assign 1 to x2, x3, ..., xp. The value is (a - p + 1)2 + (p - 1). 2. Minimize the value of y12 + y22 + ... + yq2 where y1 + y2 + ... + yq = b and yi ≥ 1. For all , assign to yi. For all , assign to yj. The value is . The proof is easy, so I won't do it. With this, we can solve the problem. We can print y1 xs, and then x1 os, ... Time complexity: O(n). Code : 5926607 Bonus: Is there any solution faster than O(n)? We tried to use ternary search, but we couldn't prove that was correct. 398B - Красим стену — Author : aintaThis can be solved by dynamic programming. Let T[i, j] the expected time when i rows and j columns doesn't have any painted cells inside.Let's see all the cases. If we carefully rearrange the order of rows and columns, we can divide the wall into 4 pieces. Choose a cell in rectangle 1. The size of this rectangle is i × j. The expectation value is T[i - 1, j - 1]. Choose a cell in rectangle 2. The size of this rectangle is i × (n - j). The expectation value is T[i - 1, j]. Choose a cell in rectangle 3. The size of this rectangle is (n - i) × j. The expectation value is T[i, j - 1]. Choose a cell in rectangle 4. The size of this rectangle is (n - i) × (n - j). The expectation value is T[i, j]. Merging these four cases, we can get:T[i, j] = 1 + {T[i - 1, j - 1] × i × j + T[i - 1, j] × i × (n - j) + T[i, j - 1] × (n - i) × j + T[i, j] × (n - i) × (n - j)} / n2Moving the T[i, j] on the right to the left, we can get the formula which can be used to calculate the value T[i, j]. There are some corner cases, like i = 0 or j = 0, but it can be simply handled. Time complexity: O(n2) Code : 5926617 398C - Дерево и массив — Author : .o.There are two intended solutions. One is easy, and the other is quite tricky.Easy SolutionMake a tree by the following method. For all , make an edge between vertex i and with weight 1. For all , make an edge between vertex i and i + 1 with weight . You can see that are all good pairs. In addition, (1, 3) is also a good pair. So we can print the answer.But, if n = 5, this method doesn't work because (1, 3) is not a good pair. In this case, one may solve by hand or using random algorithm. Time complexity: O(n) Code: 5926624 Bonus I: Is there any method to make more than good pairs? Bonus II: Is there any method that the maximum weight is relatively small and make at least good pairs? Tricky SolutionIf you got stuck with the problem, one can run any random algorithm that solves small cases, and merge these cases. With this approach, we can even limit the weight to a very small constant!But I think this is not a good solution, so I won't mention about unless anybody wants to know the details. I came up with this solution, and tried to purpose this as D. It seems all the 6 people who passed pretests during the contest didn't use this solution :) Time complexity: ??? Code : 5926632 398D - Мгновенные сообщения — Author : .o.Let xi an integer representing the state of the i-th user. If user i is online, xi  =  1, otherwise, xi  =  0. Also, let Si the set consisting of i-th friends.One can see that the queries become like this: Online/Offline: change the value of xi to 1  -  xi. Add: add u to set Sv, and v to set Su. Delete: delete u from set Sv, v from set Su. Count: calculate . Let's use sqrt-decomposition to perform these queries. Let user u heavy if |Su| ≥ C, or light otherwise. Also, we will define some arrays and sets: Hu is a set that stores friends with user u who are heavy users. O[u] stores the sum of . If the Online/Offline(u) query is given, If u is a light user: for all , change the value of O[v]. It takes O(|Su|) time. Otherwise: just update the state of itself. If the Add(u, v) query is given, If vertex u becomes heavy if we add this edge, for all , add v into Hw and update the value of O[w]. This can be done in O(C). If vertex u is still light even if we add the edge, update O[v]. This can be done in constant time. If vertex u is heavy (after the operations above), update Hv. Add u to set Sv, and v to set Su. If the Delete(u, v) query is given, Delete u from set Sv, and v from set Su. Update the value of O[*], Hu and Hv. Because for all |Hw| ≤  E| /  C, this can be done in O(|E| / C). If the counting query is given, will be the answer. Because |Hu| ≤ |E| / C, it will take O(|E| / C) time.So for each query, O(|E| / C) or O(C) time is required. To minimize the time, . Time complexity: Code : 5926635 We can also solve this by dividing the queries into parts. For each block, use O(n + m + q) time to build the online & offline state and the answer table for each vertices. For each query, you can use time to get the answer. If you want more details, please ask in the comments. Time complexity: Code : 5926640 398E - Сортируем перестановки — Author : xtalclr, eyTns, and great help of GeraldThe author is writing the solution, and it will come soon. Feel free to ask of or discuss about the solutions! Unfortunately, I don't know how to read or write Russian, so if you ask me in Russian, I can't response to it. (also, I think the Russian editorial won't be available..) Sorry for that.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10686",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 399 和字母"
          },
          "content_length": 8084
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 1",
          "code": "unordered_set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 2",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 3",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 4",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 5",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 6",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 7",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int n_squared = n * n;\n    int max_m = min(n_squared, 20000);\n    int m = inf.readInt(0, max_m, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> positions;\n\n    for (int i = 0; i < m; ++i) {\n        int ri = inf.readInt(1, n, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, n, \"ci\");\n        inf.readEoln();\n\n        pair<int, int> pos = make_pair(ri, ci);\n        ensuref(positions.insert(pos).second, \"Duplicate position at line %d\", i + 2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int n_squared = n * n;\n    int max_m = min(n_squared, 20000);\n    int m = inf.readInt(0, max_m, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> positions;\n\n    for (int i = 0; i < m; ++i) {\n        int ri = inf.readInt(1, n, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, n, \"ci\");\n        inf.readEoln();\n\n        pair<int, int> pos = make_pair(ri, ci);\n        ensuref(positions.insert(pos).second, \"Duplicate position at line %d\", i + 2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int n_squared = n * n;\n    int max_m = min(n_squared, 20000);\n    int m = inf.readInt(0, max_m, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> positions;\n\n    for (int i = 0; i < m; ++i) {\n        int ri = inf.readInt(1, n, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, n, \"ci\");\n        inf.readEoln();\n\n        pair<int, int> pos = make_pair(ri, ci);\n        ensuref(positions.insert(pos).second, \"Duplicate position at line %d\", i + 2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-4;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.5f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.5f', found: '%.5f', error = '%.5f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.5f', expected '%.5f', error '%.5f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    int max_m = min(n * n, 20000);\n\n    vector<pair<int, int>> painted_cells;\n\n    if (type == \"empty\") {\n        m = 0;\n        // No painted cells\n    } else if (type == \"full\") {\n        m = max_m;\n        // Paint up to max_m cells\n        for (int i = 1; i <= n && (int)painted_cells.size() < m; ++i) {\n            for (int j = 1; j <= n && (int)painted_cells.size() < m; ++j) {\n                painted_cells.push_back({i, j});\n            }\n        }\n    } else if (type == \"diagonal\") {\n        m = min(n, max_m);\n        for (int i = 1; i <= n && (int)painted_cells.size() < m; ++i) {\n            painted_cells.push_back({i, i});\n        }\n    } else if (type == \"row\") {\n        m = min(n, max_m);\n        int row = rnd.next(1, n);\n        for (int j = 1; j <= n && (int)painted_cells.size() < m; ++j) {\n            painted_cells.push_back({row, j});\n        }\n    } else if (type == \"column\") {\n        m = min(n, max_m);\n        int col = rnd.next(1, n);\n        for (int i = 1; i <= n && (int)painted_cells.size() < m; ++i) {\n            painted_cells.push_back({i, col});\n        }\n    } else if (type == \"one_missing_row\") {\n        m = min((n - 1) * n, max_m);\n        int missing_row = rnd.next(1, n);\n        for (int i = 1; i <= n; ++i) {\n            if (i == missing_row) continue;\n            for (int j = 1; j <= n && (int)painted_cells.size() < m; ++j) {\n                painted_cells.push_back({i, j});\n            }\n        }\n    } else if (type == \"one_missing_column\") {\n        m = min(n * (n - 1), max_m);\n        int missing_col = rnd.next(1, n);\n        for (int j = 1; j <= n; ++j) {\n            if (j == missing_col) continue;\n            for (int i = 1; i <= n && (int)painted_cells.size() < m; ++i) {\n                painted_cells.push_back({i, j});\n            }\n        }\n    } else {\n        // Default to random\n        if (m == -1) {\n            m = rnd.next(0, max_m);\n        }\n        m = min(m, max_m);\n        set<pair<int, int>> positions;\n        while ((int)positions.size() < m) {\n            int i = rnd.next(1, n);\n            int j = rnd.next(1, n);\n            positions.insert({i, j});\n        }\n        painted_cells.assign(positions.begin(), positions.end());\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)painted_cells.size());\n\n    // Output the painted cells\n    for (auto& cell : painted_cells) {\n        printf(\"%d %d\\n\", cell.first, cell.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    int max_m = min(n * n, 20000);\n\n    vector<pair<int, int>> painted_cells;\n\n    if (type == \"empty\") {\n        m = 0;\n        // No painted cells\n    } else if (type == \"full\") {\n        m = max_m;\n        // Paint up to max_m cells\n        for (int i = 1; i <= n && (int)painted_cells.size() < m; ++i) {\n            for (int j = 1; j <= n && (int)painted_cells.size() < m; ++j) {\n                painted_cells.push_back({i, j});\n            }\n        }\n    } else if (type == \"diagonal\") {\n        m = min(n, max_m);\n        for (int i = 1; i <= n && (int)painted_cells.size() < m; ++i) {\n            painted_cells.push_back({i, i});\n        }\n    } else if (type == \"row\") {\n        m = min(n, max_m);\n        int row = rnd.next(1, n);\n        for (int j = 1; j <= n && (int)painted_cells.size() < m; ++j) {\n            painted_cells.push_back({row, j});\n        }\n    } else if (type == \"column\") {\n        m = min(n, max_m);\n        int col = rnd.next(1, n);\n        for (int i = 1; i <= n && (int)painted_cells.size() < m; ++i) {\n            painted_cells.push_back({i, col});\n        }\n    } else if (type == \"one_missing_row\") {\n        m = min((n - 1) * n, max_m);\n        int missing_row = rnd.next(1, n);\n        for (int i = 1; i <= n; ++i) {\n            if (i == missing_row) continue;\n            for (int j = 1; j <= n && (int)painted_cells.size() < m; ++j) {\n                painted_cells.push_back({i, j});\n            }\n        }\n    } else if (type == \"one_missing_column\") {\n        m = min(n * (n - 1), max_m);\n        int missing_col = rnd.next(1, n);\n        for (int j = 1; j <= n; ++j) {\n            if (j == missing_col) continue;\n            for (int i = 1; i <= n && (int)painted_cells.size() < m; ++i) {\n                painted_cells.push_back({i, j});\n            }\n        }\n    } else {\n        // Default to random\n        if (m == -1) {\n            m = rnd.next(0, max_m);\n        }\n        m = min(m, max_m);\n        set<pair<int, int>> positions;\n        while ((int)positions.size() < m) {\n            int i = rnd.next(1, n);\n            int j = rnd.next(1, n);\n            positions.insert({i, j});\n        }\n        painted_cells.assign(positions.begin(), positions.end());\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)painted_cells.size());\n\n    // Output the painted cells\n    for (auto& cell : painted_cells) {\n        printf(\"%d %d\\n\", cell.first, cell.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type empty\n./gen -n 1 -type full\n./gen -n 1 -type random\n./gen -n 1 -type diagonal\n./gen -n 1 -type row\n./gen -n 1 -type column\n\n./gen -n 2 -type empty\n./gen -n 2 -type full\n./gen -n 2 -type random\n./gen -n 2 -type diagonal\n./gen -n 2 -type row\n./gen -n 2 -type column\n\n./gen -n 10 -type empty\n./gen -n 10 -type full\n./gen -n 10 -type random\n./gen -n 10 -type diagonal\n./gen -n 10 -type row\n./gen -n 10 -type column\n\n./gen -n 50 -type random\n\n./gen -n 100 -type random\n./gen -n 100 -type one_missing_row\n./gen -n 100 -type one_missing_column\n\n./gen -n 500 -type random -m 20000\n\n./gen -n 1000 -type random -m 20000\n\n./gen -n 2000 -type empty\n\n./gen -n 2000 -type full\n\n./gen -n 2000 -type random -m 0\n\n./gen -n 2000 -type random -m 10000\n\n./gen -n 2000 -type random -m 20000\n\n./gen -n 2000 -type diagonal\n\n./gen -n 2000 -type one_missing_row\n\n./gen -n 2000 -type one_missing_column\n\n./gen -n 2000 -type random\n\n./gen -n 2000 -type random -m 15000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:56.439148",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "399/E",
      "title": "E. Дерево и массив",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит единственное целое число n (5 ≤ n ≤ 105).",
      "output_spec": "Выходные данныеВыведите n - 1 строк, содержащих описание ребер: i-я строка должна содержать три целых числа через пробел ui, vi, ci (1 ≤ ui < vi ≤ n; 1 ≤ ci ≤ 105) — две вершины, соединенные ребром дерева, и вес этого ребра.Дальше выведите  строк, содержащих хорошие пары. В k-й строке должны быть записаны два целых числа через пробел, xk и yk (1 ≤ xk < yk ≤ n). Конечно же, xk, yk должны образовывать хорошую пару. Все пары должны быть различны — иными словами, для всех j, k , должно выполняться условие xj ≠ xk или yj ≠ yk.Если существует несколько правильных ответов, разрешается вывести любой из них.",
      "sample_tests": "ПримерыВходные данныеСкопировать7Выходные данныеСкопировать1 4 11 2 22 3 53 5 32 6 26 7 34 55 65 7",
      "description": "E. Дерево и массив\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит единственное целое число n (5 ≤ n ≤ 105).\n\nВходные данные\n\nВыходные данныеВыведите n - 1 строк, содержащих описание ребер: i-я строка должна содержать три целых числа через пробел ui, vi, ci (1 ≤ ui < vi ≤ n; 1 ≤ ci ≤ 105) — две вершины, соединенные ребром дерева, и вес этого ребра.Дальше выведите  строк, содержащих хорошие пары. В k-й строке должны быть записаны два целых числа через пробел, xk и yk (1 ≤ xk < yk ≤ n). Конечно же, xk, yk должны образовывать хорошую пару. Все пары должны быть различны — иными словами, для всех j, k , должно выполняться условие xj ≠ xk или yj ≠ yk.Если существует несколько правильных ответов, разрешается вывести любой из них.\n\nВыходные данные\n\nВходные данныеСкопировать7Выходные данныеСкопировать1 4 11 2 22 3 53 5 32 6 26 7 34 55 65 7\n\nВходные данныеСкопировать7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 4 11 2 22 3 53 5 32 6 26 7 34 55 65 7\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечание⌊x⌋ — это наибольшее целое число, не превышающее x.Вы можете найти определение дерева по следующей ссылке: http://ru.wikipedia.org/wiki/Дерево_(теория_графов)Также вы можете найти определение кратчайшего пути по следующей ссылке: http://ru.wikipedia.org/wiki/Задача_о_кратчайшем_путиДерево и массив t в тестовом примере выглядят следующим образом:",
      "solutions": [
        {
          "title": "Codeforces Round #233 Editorial - Codeforces",
          "content": "Please write here if you had written some comments about any suggestions or questions on the announcement. There are a bunch of notification emails but I couldn't read most of them :(Here are the final top 100 : Div1, Div2. Congrats to the winners!(These links are all from google search cache, so it may be disappear) First of all, we are sorry to make this round unrated. This is an unexpected incident, and I believe that everyone in Codeforces would understand that. And second, we're sorry for estimating the difficulties of the problems wrong. Actually, I thought that somebody would get Accepted on 398A - Карточки within 5 minutes. But there wasn't any submissions during the first 4 minutes, and many people got wrong answer on pretests! I think almost everybody who solved this got at least one wrong answer.. I'm really sorry for measuring A easy. I think what cgy4ever said is right — it would be better not asking to print the sequence. At first, I purposed 398C - Дерево и массив as B(!!) because ainta solved it very easily than I expected. (I could hardly solve this, and thought it must be at least D, before I heard ainta's solution.) We're sorry for giving this problem the same score with 398B - Красим стену, which was much easier than 398C - Дерево и массив. Next time I'll remember that ainta is really a genius :) Congrats to four people who solved 398C - Дерево и массив during the contest! : cgy4ever, Shef, SillyHook06, and Qwaz. We are surprised that Petr solved 398E - Сортируем перестановки during the contest! Even though he implemented by Java, his solution is faster than ours :p Congratulations to him! Actually, we purposed an another problem for Div1-E, but the same problem popped out at OpenCup last Sunday, so we couldn't use that. Thanks to Gerald, who helped us preparing a new problem in such a short time. By the way, can you guess what problem was that? :D ... 399A - Страницы — Author : .o.You can solve this problem by just following the statement. First, print << if p - k > 1. Next, iterate all the integers from p - k to p + k, and print if the integer is in [1..n]. Finally, print >> if p + k < n. Time complexity: O(n). Code : 5926588 399B - Красные и синие шарики — Author : xtalclrChange the blue balls to bit 1, and blue balls to bit 0. Interpret the stack as an integer represented in binary digits. Now, one may see that a single operation decreases the integer by 1, and will be unavailable iff the integer becomes zero. So the answer will be 2a1 + 2a2 + ... + 2ak where the (ai + 1)-th (1 ≤ i ≤ k) ball is blue in the beginning. Time complexity: O(n) Code : 5926598 398A - Карточки — Author : .o.Let the number of o blocks p, and the number of x blocks q. It is obvious that |p - q| ≤ 1 and p, q ≤ n. So we can just iterate all p and q, and solve these two problems independently, and merge the answer.1. Maximize the value of x12 + x22 + ... + xp2 where x1 + x2 + ... + xp = a and xi ≥ 1. Assign a - p + 1 to x1, and assign 1 to x2, x3, ..., xp. The value is (a - p + 1)2 + (p - 1). 2. Minimize the value of y12 + y22 + ... + yq2 where y1 + y2 + ... + yq = b and yi ≥ 1. For all , assign to yi. For all , assign to yj. The value is . The proof is easy, so I won't do it. With this, we can solve the problem. We can print y1 xs, and then x1 os, ... Time complexity: O(n). Code : 5926607 Bonus: Is there any solution faster than O(n)? We tried to use ternary search, but we couldn't prove that was correct. 398B - Красим стену — Author : aintaThis can be solved by dynamic programming. Let T[i, j] the expected time when i rows and j columns doesn't have any painted cells inside.Let's see all the cases. If we carefully rearrange the order of rows and columns, we can divide the wall into 4 pieces. Choose a cell in rectangle 1. The size of this rectangle is i × j. The expectation value is T[i - 1, j - 1]. Choose a cell in rectangle 2. The size of this rectangle is i × (n - j). The expectation value is T[i - 1, j]. Choose a cell in rectangle 3. The size of this rectangle is (n - i) × j. The expectation value is T[i, j - 1]. Choose a cell in rectangle 4. The size of this rectangle is (n - i) × (n - j). The expectation value is T[i, j]. Merging these four cases, we can get:T[i, j] = 1 + {T[i - 1, j - 1] × i × j + T[i - 1, j] × i × (n - j) + T[i, j - 1] × (n - i) × j + T[i, j] × (n - i) × (n - j)} / n2Moving the T[i, j] on the right to the left, we can get the formula which can be used to calculate the value T[i, j]. There are some corner cases, like i = 0 or j = 0, but it can be simply handled. Time complexity: O(n2) Code : 5926617 398C - Дерево и массив — Author : .o.There are two intended solutions. One is easy, and the other is quite tricky.Easy SolutionMake a tree by the following method. For all , make an edge between vertex i and with weight 1. For all , make an edge between vertex i and i + 1 with weight . You can see that are all good pairs. In addition, (1, 3) is also a good pair. So we can print the answer.But, if n = 5, this method doesn't work because (1, 3) is not a good pair. In this case, one may solve by hand or using random algorithm. Time complexity: O(n) Code: 5926624 Bonus I: Is there any method to make more than good pairs? Bonus II: Is there any method that the maximum weight is relatively small and make at least good pairs? Tricky SolutionIf you got stuck with the problem, one can run any random algorithm that solves small cases, and merge these cases. With this approach, we can even limit the weight to a very small constant!But I think this is not a good solution, so I won't mention about unless anybody wants to know the details. I came up with this solution, and tried to purpose this as D. It seems all the 6 people who passed pretests during the contest didn't use this solution :) Time complexity: ??? Code : 5926632 398D - Мгновенные сообщения — Author : .o.Let xi an integer representing the state of the i-th user. If user i is online, xi  =  1, otherwise, xi  =  0. Also, let Si the set consisting of i-th friends.One can see that the queries become like this: Online/Offline: change the value of xi to 1  -  xi. Add: add u to set Sv, and v to set Su. Delete: delete u from set Sv, v from set Su. Count: calculate . Let's use sqrt-decomposition to perform these queries. Let user u heavy if |Su| ≥ C, or light otherwise. Also, we will define some arrays and sets: Hu is a set that stores friends with user u who are heavy users. O[u] stores the sum of . If the Online/Offline(u) query is given, If u is a light user: for all , change the value of O[v]. It takes O(|Su|) time. Otherwise: just update the state of itself. If the Add(u, v) query is given, If vertex u becomes heavy if we add this edge, for all , add v into Hw and update the value of O[w]. This can be done in O(C). If vertex u is still light even if we add the edge, update O[v]. This can be done in constant time. If vertex u is heavy (after the operations above), update Hv. Add u to set Sv, and v to set Su. If the Delete(u, v) query is given, Delete u from set Sv, and v from set Su. Update the value of O[*], Hu and Hv. Because for all |Hw| ≤  E| /  C, this can be done in O(|E| / C). If the counting query is given, will be the answer. Because |Hu| ≤ |E| / C, it will take O(|E| / C) time.So for each query, O(|E| / C) or O(C) time is required. To minimize the time, . Time complexity: Code : 5926635 We can also solve this by dividing the queries into parts. For each block, use O(n + m + q) time to build the online & offline state and the answer table for each vertices. For each query, you can use time to get the answer. If you want more details, please ask in the comments. Time complexity: Code : 5926640 398E - Сортируем перестановки — Author : xtalclr, eyTns, and great help of GeraldThe author is writing the solution, and it will come soon. Feel free to ask of or discuss about the solutions! Unfortunately, I don't know how to read or write Russian, so if you ask me in Russian, I can't response to it. (also, I think the Russian editorial won't be available..) Sorry for that.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10686",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 399 和字母"
          },
          "content_length": 8084
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 1",
          "code": "unordered_set",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 2",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 3",
          "code": "if (!big[a])\n{\n     for (auto b : status[a])\n         r += on[b];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 4",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 5",
          "code": "Firstly, we set M = 50000, and you just need to maintain bitset<M> B[M] and bitset<M> s:\ninitialization: for each x, set s[x] = 1; for each a b, set B[a][b] = B[b][a] = 1;\nquery:\nO u: s[u] = 1;\nF u: s[u] = 0;\nA u v: B[u][v] = B[v][u] = 1;\nD u v: B[u][v] = B[v][u] = 0;\nC u: print (B[u] & s).count();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 6",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #233 Editorial - Codeforces - Code 7",
          "code": "initialization: if (x < M / 2) s[x] = 1, if (b < M / 2) B[a][b] = 1, if (a < M / 2) B[b][a] = 1;\nquery:\nO u: if (u < M / 2) s[u] = 1;\nF u: if (u < M / 2) s[u] = 0;\nA u v: if (u < M / 2) B[v][u] = 1, if (v < M / 2) B[u][v] = 1;\nD u v: if (u < M / 2) B[v][u] = 0, if (v < M / 2) B[u][v] = 0;\nC u: the answer for this query += (B[u] & s).count();\nThen clear all B and clear s;\ninitialization: if (x >= M / 2) s[x - M/2] = 1, if (b >= M / 2) B[a][b - M/2] = 1, if (a >= M / 2) B[b][a - M/2] = 1;\nquery:\nO u: if (u >= M / 2) s[u - M/2] = 1;\nF u: if (u >= M / 2) s[u - M/2] = 0;\nA u v: if (u >= M / 2) B[v][u - M/2] = 1, if (v >= M / 2) B[u][v - M/2] = 1;\nD u v: if (u >= M / 2) B[v][u - M/2] = 0, if (v >= M / 2) B[u][v - M/2] = 0;\nC u: the answer for this query += (B[u] & s).count();\nFinally, print answers for each query C u.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10686",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(5, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(5, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(5, 100000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\nconst int MAXLOG = 17; // Since 2^17 > 1e5\n\nint n;\nvector<pair<int, int>> adj[MAXN]; // adj[node] = vector of {neighbor, weight}\nint depth[MAXN];\nint parent[MAXN][MAXLOG];\nlong long dist[MAXN]; // distance from root\nlong long t_incr[MAXN]; // For difference array of t[]\nlong long T[MAXN + 2]; // Prefix sums of t[]\n\nvoid dfs(int u, int p) {\n    for (auto &edge : adj[u]) {\n        int v = edge.first;\n        int w = edge.second;\n        if (v != p) {\n            depth[v] = depth[u] + 1;\n            parent[v][0] = u;\n            dist[v] = dist[u] + w;\n            dfs(v, u);\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v])\n        swap(u, v);\n    int diff = depth[u] - depth[v];\n    for (int k = 0; k < MAXLOG; k++) {\n        if (diff & (1 << k))\n            u = parent[u][k];\n    }\n    if (u == v)\n        return u;\n    for (int k = MAXLOG - 1; k >= 0; k--) {\n        if (parent[u][k] != parent[v][k]) {\n            u = parent[u][k];\n            v = parent[v][k];\n        }\n    }\n    return parent[u][0];\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    n = inf.readInt(5, 100000, \"n\");\n    // Read edges from participant output\n    vector<tuple<int,int,int>> edges;\n    for (int i = 0; i < n - 1; ++i) {\n        int u = ouf.readInt(1, n, format(\"u[%d]\", i+1).c_str());\n        int v = ouf.readInt(1, n, format(\"v[%d]\", i+1).c_str());\n        if (u >= v)\n            quitf(_wa, \"Edge %d has u >= v: u = %d, v = %d\", i+1, u, v);\n        int c = ouf.readInt(1, 100000, format(\"c[%d]\", i+1).c_str());\n        edges.push_back(make_tuple(u, v, c));\n    }\n    // Build the tree\n    // First, check that edges form a tree\n    \n    // Build adjacency list\n    for (int i = 1; i <= n; ++i)\n        adj[i].clear();\n    \n    for (auto &e : edges) {\n        int u, v, c;\n        tie(u,v,c) = e;\n        adj[u].push_back({v, c});\n        adj[v].push_back({u, c});\n    }\n    // Check connectedness and acyclicity via DFS\n    vector<bool> visited(n + 1, false);\n    function<void(int, int)> dfs_visit = [&](int u, int p) {\n        visited[u] = true;\n        for (auto &edge : adj[u]) {\n            int v = edge.first;\n            if (v != p) {\n                if (visited[v]) {\n                    quitf(_wa, \"Cycle detected between %d and %d\", u, v);\n                } else {\n                    dfs_visit(v, u);\n                }\n            }\n        }\n    };\n    dfs_visit(1, -1);\n    for (int i = 1; i <= n; ++i) {\n        if (!visited[i])\n            quitf(_wa, \"Graph is not connected, node %d is unreachable\", i);\n    }\n    // Initialize parent and dist arrays\n    depth[1] = 0;\n    dist[1] = 0;\n    parent[1][0] = 0;\n    dfs(1, 0);\n    // Build parents for binary lifting\n    for (int k = 1; k < MAXLOG; k++) {\n        for (int i = 1; i <= n; i++) {\n            int mid = parent[i][k - 1];\n            parent[i][k] = mid ? parent[mid][k - 1] : 0;\n        }\n    }\n    // Build t_incr[] array using difference array method\n    memset(t_incr, 0, sizeof(t_incr));\n    for (auto &e : edges) {\n        int u, v, c;\n        tie(u,v,c) = e;\n        t_incr[u] += c;\n        t_incr[v + 1] -= c;\n    }\n    // Build t[] and prefix sums T[]\n    vector<long long> t(n + 2, 0);\n    for (int i = 1; i <= n; ++i) {\n        t[i] = t_incr[i] + t[i - 1];\n    }\n    // Build T[]\n    T[0] = 0;\n    for (int i = 1; i <= n + 1; ++i) {\n        T[i] = T[i - 1] + t[i - 1];\n    }\n    // Read floor(n/2) pairs\n    int k = n / 2;\n    set<pair<int, int>> pair_set;\n    for (int i = 0; i < k; ++i) {\n        int xk = ouf.readInt(1, n, format(\"xk[%d]\", i + 1).c_str());\n        int yk = ouf.readInt(1, n, format(\"yk[%d]\", i + 1).c_str());\n        if (xk >= yk)\n            quitf(_wa, \"Pair %d has xk >= yk: xk = %d, yk = %d\", i + 1, xk, yk);\n        if (pair_set.count({xk, yk}))\n            quitf(_wa, \"Duplicate pair: %d %d\", xk, yk);\n        pair_set.insert({xk, yk});\n        // Compute d(xk, yk)\n        int l = lca(xk, yk);\n        long long dxy = dist[xk] + dist[yk] - 2LL * dist[l];\n        // Compute t[xk.. yk]\n        long long txy = T[yk + 1] - T[xk];\n        if (dxy != txy)\n            quitf(_wa, \"For pair %d (%d, %d), d(xk, yk) = %lld, t[xk.. yk] = %lld, they are not equal\", i+1, xk, yk, dxy, txy);\n    }\n    quitf(_ok, \"All pairs verified successfully\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single integer n on its standard output.\n  According to the problem statement, the solution code (written by contestants)\n  reads only an integer n from the input. Then it must output a weighted tree plus\n  some \"good pairs.\"\n\n  Constraints:\n    5 ≤ n ≤ 100000\n\n  Usage examples (see the list of bash commands below):\n    ./gen -n 10 -type small\n    ./gen -n 100000 -type large\n\n  Note:\n    - We do NOT set the random seed here; testlib does that automatically.\n    - We do NOT pass any random seed in the arguments or do any \"rnd.seed(...)\" calls.\n    - We simply output the integer n read from command-line arguments after parsing\n      them with \"opt<int>(\"n\")\".\n    - The parameter \"type\" can be used to differentiate test-case styles if you wish,\n      but here we only demonstrate reading it. You could tailor logic for \"type\"\n      if you wanted to clamp or alter n in special ways.\n*/\n\nint main(int argc, char* argv[]) {\n    // Register the generator. The \"1\" is the version used by testlib.\n    registerGen(argc, argv, 1);\n\n    // Read integer n from command line (defaults to 5 if not provided).\n    int n = opt<int>(\"n\", 5);\n\n    // Read a string parameter \"type\" (defaults to \"random\" if not provided).\n    // You could use this to tweak how you pick n, etc., but here we just read it.\n    string t = opt<string>(\"type\", \"random\");\n\n    // Ensure n is within the problem constraints: 5 ≤ n ≤ 100000\n    // (If needed, you could clamp or trigger an error if out of range.)\n    n = max(n, 5);\n    n = min(n, 100000);\n\n    // Output the single integer n (the entire test input).\n    cout << n << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single integer n on its standard output.\n  According to the problem statement, the solution code (written by contestants)\n  reads only an integer n from the input. Then it must output a weighted tree plus\n  some \"good pairs.\"\n\n  Constraints:\n    5 ≤ n ≤ 100000\n\n  Usage examples (see the list of bash commands below):\n    ./gen -n 10 -type small\n    ./gen -n 100000 -type large\n\n  Note:\n    - We do NOT set the random seed here; testlib does that automatically.\n    - We do NOT pass any random seed in the arguments or do any \"rnd.seed(...)\" calls.\n    - We simply output the integer n read from command-line arguments after parsing\n      them with \"opt<int>(\"n\")\".\n    - The parameter \"type\" can be used to differentiate test-case styles if you wish,\n      but here we only demonstrate reading it. You could tailor logic for \"type\"\n      if you wanted to clamp or alter n in special ways.\n*/\n\nint main(int argc, char* argv[]) {\n    // Register the generator. The \"1\" is the version used by testlib.\n    registerGen(argc, argv, 1);\n\n    // Read integer n from command line (defaults to 5 if not provided).\n    int n = opt<int>(\"n\", 5);\n\n    // Read a string parameter \"type\" (defaults to \"random\" if not provided).\n    // You could use this to tweak how you pick n, etc., but here we just read it.\n    string t = opt<string>(\"type\", \"random\");\n\n    // Ensure n is within the problem constraints: 5 ≤ n ≤ 100000\n    // (If needed, you could clamp or trigger an error if out of range.)\n    n = max(n, 5);\n    n = min(n, 100000);\n\n    // Output the single integer n (the entire test input).\n    cout << n << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type small\n./gen -n 6 -type small\n./gen -n 7 -type small\n./gen -n 10 -type random\n./gen -n 11 -type random\n./gen -n 12 -type random\n./gen -n 13 -type prime\n./gen -n 20 -type random\n./gen -n 25 -type random\n./gen -n 30 -type random\n./gen -n 50 -type medium\n./gen -n 99 -type random\n./gen -n 100 -type medium\n./gen -n 999 -type random\n./gen -n 1000 -type medium\n./gen -n 9999 -type random\n./gen -n 10000 -type large\n./gen -n 99999 -type large\n./gen -n 100000 -type extreme\n./gen -n 99990 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:21:58.347907",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "4/A",
      "title": "A. Арбуз",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 second",
      "memory_limit": "ограничение по памяти на тест64 megabytes",
      "input_spec": "Входные данныеВ первой и единственной строке входных данных записано целое число w (1 ≤ w ≤ 100) — вес купленного ребятами арбуза.",
      "output_spec": "Выходные данныеВыведите YES, если ребята смогут поделить арбуз на две части, каждая из которых весит четное число килограмм, и NO в противном случае.",
      "sample_tests": "ПримерыВходные данныеСкопировать8Выходные данныеСкопироватьYES",
      "description": "ограничение по времени на тест1 second\n\nограничение по времени на тест\n\nограничение по памяти на тест64 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой и единственной строке входных данных записано целое число w (1 ≤ w ≤ 100) — вес купленного ребятами арбуза.\n\nВходные данные\n\nВыходные данныеВыведите YES, если ребята смогут поделить арбуз на две части, каждая из которых весит четное число килограмм, и NO в противном случае.\n\nВыходные данные\n\nВходные данныеСкопировать8Выходные данныеСкопироватьYES\n\nВходные данныеСкопировать8\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеНапример, ребята могут поделить арбуз на две части размерами 2 и 6 килограммов соответственно (другой вариант — две части 4 и 4 килограмма).",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int w = inf.readInt(1, 100, \"w\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int w = inf.readInt(1, 100, \"w\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int w = inf.readInt(1, 100, \"w\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int w = opt<int>(\"w\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (w == -1) {\n        // 'w' not specified, determine based on 'type'\n        if (type == \"minimum\") {\n            // Minimum limit test case\n            w = 1;\n        } else if (type == \"maximum\") {\n            // Maximum limit test case\n            w = 100;\n        } else if (type == \"yes\") {\n            // Generate a 'YES' test case (w > 2 and even)\n            w = rnd.next(2, 50) * 2; // Generates even numbers from 4 to 100\n        } else if (type == \"no\") {\n            // Generate a 'NO' test case (w is odd or w = 2)\n            int options[] = {2, 1, 3, 5, 7, 99};\n            w = options[rnd.next(0, 5)];\n        } else if (type == \"odd\") {\n            // Generate a random odd number within [1, 99]\n            w = rnd.next(1, 50) * 2 - 1; // Odd numbers from 1 to 99\n            if (w > 99) w = 99;\n        } else if (type == \"even\") {\n            // Generate a random even number within [2, 100]\n            w = rnd.next(1, 50) * 2; // Even numbers from 2 to 100\n            if (w > 100) w = 100;\n        } else {\n            // Generate a random 'w' within [1, 100]\n            w = rnd.next(1, 100);\n        }\n    }\n\n    // Output 'w' ensuring it is within [1, 100]\n    printf(\"%d\\n\", w);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int w = opt<int>(\"w\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (w == -1) {\n        // 'w' not specified, determine based on 'type'\n        if (type == \"minimum\") {\n            // Minimum limit test case\n            w = 1;\n        } else if (type == \"maximum\") {\n            // Maximum limit test case\n            w = 100;\n        } else if (type == \"yes\") {\n            // Generate a 'YES' test case (w > 2 and even)\n            w = rnd.next(2, 50) * 2; // Generates even numbers from 4 to 100\n        } else if (type == \"no\") {\n            // Generate a 'NO' test case (w is odd or w = 2)\n            int options[] = {2, 1, 3, 5, 7, 99};\n            w = options[rnd.next(0, 5)];\n        } else if (type == \"odd\") {\n            // Generate a random odd number within [1, 99]\n            w = rnd.next(1, 50) * 2 - 1; // Odd numbers from 1 to 99\n            if (w > 99) w = 99;\n        } else if (type == \"even\") {\n            // Generate a random even number within [2, 100]\n            w = rnd.next(1, 50) * 2; // Even numbers from 2 to 100\n            if (w > 100) w = 100;\n        } else {\n            // Generate a random 'w' within [1, 100]\n            w = rnd.next(1, 100);\n        }\n    }\n\n    // Output 'w' ensuring it is within [1, 100]\n    printf(\"%d\\n\", w);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen --w 1\n./gen --w 2\n./gen --w 3\n./gen --w 4\n./gen --w 5\n./gen --w 6\n./gen --w 99\n./gen --w 100\n\n./gen --type minimum\n./gen --type maximum\n./gen --type yes\n./gen --type yes\n./gen --type yes\n\n./gen --type no\n./gen --type no\n./gen --type no\n\n./gen --type odd\n./gen --type even\n\n./gen --type random\n./gen --type random\n./gen --type random\n\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n./gen\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:00.590881",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "4/B",
      "title": "B. Перед экзаменом",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест0.5 second",
      "memory_limit": "ограничение по памяти на тест64 megabytes",
      "input_spec": "Входные данныеВ первой строке входных данных заданы два целых числа d, sumTime (1 ≤ d ≤ 30, 0 ≤ sumTime ≤ 240) — количество дней, в течение которых занимался Петя и общее количество часов, затраченных на подготовку. В следующих d строках содержится по два целых числа minTimei, maxTimei (0 ≤ minTimei ≤ maxTimei ≤ 8), записанных через пробел — минимальное и максимальное число часов, которое Петя мог потратить в i-ый день.",
      "output_spec": "Выходные данныеВыведите в первую строку YES, а во вторую d целых чисел через пробелы, каждое из которых — число часов, потраченных Петей на подготовку в соответствующий день. Если искомый список составить невозможно, то выведите NO в единственную строку выходных данных. Если решений несколько, выведите любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 485 7Выходные данныеСкопироватьNOВходные данныеСкопировать2 50 13 5Выходные данныеСкопироватьYES1 4",
      "description": "B. Перед экзаменом\n\nограничение по времени на тест0.5 second\n\nограничение по времени на тест\n\nограничение по памяти на тест64 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных заданы два целых числа d, sumTime (1 ≤ d ≤ 30, 0 ≤ sumTime ≤ 240) — количество дней, в течение которых занимался Петя и общее количество часов, затраченных на подготовку. В следующих d строках содержится по два целых числа minTimei, maxTimei (0 ≤ minTimei ≤ maxTimei ≤ 8), записанных через пробел — минимальное и максимальное число часов, которое Петя мог потратить в i-ый день.\n\nВходные данные\n\nВыходные данныеВыведите в первую строку YES, а во вторую d целых чисел через пробелы, каждое из которых — число часов, потраченных Петей на подготовку в соответствующий день. Если искомый список составить невозможно, то выведите NO в единственную строку выходных данных. Если решений несколько, выведите любое.\n\nВыходные данные\n\nВходные данныеСкопировать1 485 7Выходные данныеСкопироватьNOВходные данныеСкопировать2 50 13 5Выходные данныеСкопироватьYES1 4\n\nВходные данныеСкопировать1 485 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 50 13 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES1 4\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int d = inf.readInt(1, 30);\n    inf.readSpace();\n    int sumTime = inf.readInt(0, 240);\n    inf.readEoln();\n\n    for (int i = 0; i < d; i++) {\n        int minTime = inf.readInt(0, 8);\n        inf.readSpace();\n        int maxTime = inf.readInt(0, 8);\n        inf.readEoln();\n        ensuref(minTime <= maxTime, \"At day %d, minTime=%d should be <= maxTime=%d\", i+1, minTime, maxTime);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int d = inf.readInt(1, 30);\n    inf.readSpace();\n    int sumTime = inf.readInt(0, 240);\n    inf.readEoln();\n\n    for (int i = 0; i < d; i++) {\n        int minTime = inf.readInt(0, 8);\n        inf.readSpace();\n        int maxTime = inf.readInt(0, 8);\n        inf.readEoln();\n        ensuref(minTime <= maxTime, \"At day %d, minTime=%d should be <= maxTime=%d\", i+1, minTime, maxTime);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int d = inf.readInt(1, 30);\n    inf.readSpace();\n    int sumTime = inf.readInt(0, 240);\n    inf.readEoln();\n\n    for (int i = 0; i < d; i++) {\n        int minTime = inf.readInt(0, 8);\n        inf.readSpace();\n        int maxTime = inf.readInt(0, 8);\n        inf.readEoln();\n        ensuref(minTime <= maxTime, \"At day %d, minTime=%d should be <= maxTime=%d\", i+1, minTime, maxTime);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input from inf\n    int d = inf.readInt(1, 30, \"d\");\n    int sumTime = inf.readInt(0, 240, \"sumTime\");\n    vector<int> minTime(d), maxTime(d);\n    int total_min = 0, total_max = 0;\n    for (int i = 0; i < d; ++i) {\n        minTime[i] = inf.readInt(0, 8, format(\"minTime[%d]\", i+1).c_str());\n        maxTime[i] = inf.readInt(minTime[i], 8, format(\"maxTime[%d]\", i+1).c_str());\n        total_min += minTime[i];\n        total_max += maxTime[i];\n    }\n\n    // Read contestant's output from ouf\n    string s = ouf.readToken();\n    string s_upper = s;\n    transform(s_upper.begin(), s_upper.end(), s_upper.begin(), ::toupper);\n\n    if (s_upper == \"NO\") {\n        // Check if there is no possible schedule\n        if (sumTime < total_min || sumTime > total_max) {\n            quitf(_ok, \"Correctly output NO\");\n        }\n        else {\n            quitf(_wa, \"There exists a schedule but contestant output NO\");\n        }\n    }\n    else if (s_upper == \"YES\") {\n        // Check if a schedule is possible\n        if (sumTime < total_min || sumTime > total_max) {\n            quitf(_wa, \"No possible schedule but contestant output YES\");\n        }\n        // Read the schedule\n        vector<int> schedule(d);\n        long long sum_schedule = 0;\n        for (int i = 0; i < d; ++i) {\n            schedule[i] = ouf.readInt(minTime[i], maxTime[i], format(\"schedule[%d]\", i+1).c_str());\n            sum_schedule += schedule[i];\n        }\n        if (sum_schedule != sumTime) {\n            quitf(_wa, \"Sum of schedule is %lld, expected %d\", sum_schedule, sumTime);\n        }\n        else {\n            quitf(_ok, \"Answer is correct\");\n        }\n    }\n    else {\n        quitf(_wa, \"First token is neither YES nor NO\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // The testlib library uses or seeds the RNG internally (for example, from /dev/urandom).\n    // We do NOT manually set any seed here.\n    registerGen(argc, argv, 1);\n\n    // Read parameters from the command line\n    int d = opt<int>(\"d\");            // number of days\n    int sumTime = opt<int>(\"sumTime\"); // total amount of hours\n    // A mode that decides how we generate each day's [minTime_i, maxTime_i]\n    // Possible examples: \"allzero\", \"allmax\", \"tight\", \"random\"\n    string mode = opt<string>(\"mode\", \"random\");\n\n    // Print d and sumTime in the first line\n    cout << d << \" \" << sumTime << \"\\n\";\n\n    // Generate and print the pairs (minTime_i, maxTime_i)\n    // Constraints: 0 <= minTime_i <= maxTime_i <= 8\n\n    if (mode == \"allzero\") {\n        // Every day has [0,0]\n        for(int i = 0; i < d; i++){\n            cout << 0 << \" \" << 0 << \"\\n\";\n        }\n    }\n    else if (mode == \"allmax\") {\n        // Every day has [8,8]\n        for(int i = 0; i < d; i++){\n            cout << 8 << \" \" << 8 << \"\\n\";\n        }\n    }\n    else if (mode == \"tight\") {\n        // For each day, minTime_i = maxTime_i = some random value in [0..8]\n        for(int i = 0; i < d; i++){\n            int x = rnd.next(0, 9); // x in [0..8]\n            cout << x << \" \" << x << \"\\n\";\n        }\n    }\n    else {\n        // Default: \"random\" \n        // For each day, pick minTime in [0..8], then pick maxTime in [minTime..8].\n        for(int i = 0; i < d; i++){\n            int mn = rnd.next(0, 9);        // [0..8]\n            int mx = rnd.next(mn, 9);       // [mn..8]\n            cout << mn << \" \" << mx << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // The testlib library uses or seeds the RNG internally (for example, from /dev/urandom).\n    // We do NOT manually set any seed here.\n    registerGen(argc, argv, 1);\n\n    // Read parameters from the command line\n    int d = opt<int>(\"d\");            // number of days\n    int sumTime = opt<int>(\"sumTime\"); // total amount of hours\n    // A mode that decides how we generate each day's [minTime_i, maxTime_i]\n    // Possible examples: \"allzero\", \"allmax\", \"tight\", \"random\"\n    string mode = opt<string>(\"mode\", \"random\");\n\n    // Print d and sumTime in the first line\n    cout << d << \" \" << sumTime << \"\\n\";\n\n    // Generate and print the pairs (minTime_i, maxTime_i)\n    // Constraints: 0 <= minTime_i <= maxTime_i <= 8\n\n    if (mode == \"allzero\") {\n        // Every day has [0,0]\n        for(int i = 0; i < d; i++){\n            cout << 0 << \" \" << 0 << \"\\n\";\n        }\n    }\n    else if (mode == \"allmax\") {\n        // Every day has [8,8]\n        for(int i = 0; i < d; i++){\n            cout << 8 << \" \" << 8 << \"\\n\";\n        }\n    }\n    else if (mode == \"tight\") {\n        // For each day, minTime_i = maxTime_i = some random value in [0..8]\n        for(int i = 0; i < d; i++){\n            int x = rnd.next(0, 9); // x in [0..8]\n            cout << x << \" \" << x << \"\\n\";\n        }\n    }\n    else {\n        // Default: \"random\" \n        // For each day, pick minTime in [0..8], then pick maxTime in [minTime..8].\n        for(int i = 0; i < d; i++){\n            int mn = rnd.next(0, 9);        // [0..8]\n            int mx = rnd.next(mn, 9);       // [mn..8]\n            cout << mn << \" \" << mx << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -d 1 -sumTime 0 -mode allzero\n./gen -d 1 -sumTime 0 -mode allmax\n./gen -d 1 -sumTime 0 -mode tight\n./gen -d 1 -sumTime 0 -mode random\n\n./gen -d 1 -sumTime 10 -mode allzero\n./gen -d 1 -sumTime 10 -mode allmax\n./gen -d 1 -sumTime 10 -mode tight\n./gen -d 1 -sumTime 10 -mode random\n\n./gen -d 2 -sumTime 5 -mode random\n./gen -d 2 -sumTime 16 -mode random\n\n./gen -d 5 -sumTime 0 -mode random\n./gen -d 5 -sumTime 16 -mode random\n./gen -d 5 -sumTime 20 -mode tight\n./gen -d 5 -sumTime 40 -mode random\n\n./gen -d 10 -sumTime 10 -mode tight\n./gen -d 10 -sumTime 39 -mode random\n./gen -d 10 -sumTime 80 -mode random\n\n./gen -d 30 -sumTime 0 -mode allzero\n./gen -d 30 -sumTime 23 -mode random\n./gen -d 30 -sumTime 100 -mode tight\n./gen -d 30 -sumTime 120 -mode random\n./gen -d 30 -sumTime 240 -mode allmax\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:02.586689",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "4/C",
      "title": "C. Система регистрации",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест5 seconds",
      "memory_limit": "ограничение по памяти на тест64 megabytes",
      "input_spec": "Входные данныеВ первой строке входных данных задано число n (1 ≤ n ≤ 105). Следующие n строк содержат запросы к системе. Каждый запрос представляет собой непустую строку длиной не более 32 символов, состоящую только из строчных букв латинского алфавита.",
      "output_spec": "Выходные данныеВ выходных данных должно содержаться n строк — ответы системы на запросы: ОК в случае успешной регистрации, или подсказку с новым именем, если запрашиваемое уже занято.",
      "sample_tests": "ПримерыВходные данныеСкопировать4abacabaacabaabacabaacabВыходные данныеСкопироватьOKOKabacaba1OKВходные данныеСкопировать6firstfirstsecondsecondthirdthirdВыходные данныеСкопироватьOKfirst1OKsecond1OKthird1",
      "description": "C. Система регистрации\n\nограничение по времени на тест5 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест64 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных задано число n (1 ≤ n ≤ 105). Следующие n строк содержат запросы к системе. Каждый запрос представляет собой непустую строку длиной не более 32 символов, состоящую только из строчных букв латинского алфавита.\n\nВходные данные\n\nВыходные данныеВ выходных данных должно содержаться n строк — ответы системы на запросы: ОК в случае успешной регистрации, или подсказку с новым именем, если запрашиваемое уже занято.\n\nВыходные данные\n\nВходные данныеСкопировать4abacabaacabaabacabaacabВыходные данныеСкопироватьOKOKabacaba1OKВходные данныеСкопировать6firstfirstsecondsecondthirdthirdВыходные данныеСкопироватьOKfirst1OKsecond1OKthird1\n\nВходные данныеСкопировать4abacabaacabaabacabaacab\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьOKOKabacaba1OK\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6firstfirstsecondsecondthirdthird\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьOKfirst1OKsecond1OKthird1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[a-z]{1,32}\", format(\"s[%d]\", i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[a-z]{1,32}\", format(\"s[%d]\", i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[a-z]{1,32}\", format(\"s[%d]\", i + 1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> usernames;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 32);\n            string s;\n            for (int j = 0; j < len; ++j) {\n                char c = 'a' + rnd.next(26);\n                s += c;\n            }\n            usernames.push_back(s);\n        }\n    } else if (type == \"same\") {\n        string s = \"user\";\n        for (int i = 0; i < n; ++i) {\n            usernames.push_back(s);\n        }\n    } else if (type == \"short\") {\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            string s(1, c);\n            usernames.push_back(s);\n        }\n    } else if (type == \"long\") {\n        for (int i = 0; i < n; ++i) {\n            string s;\n            for (int j = 0; j < 32; ++j) {\n                char c = 'a' + rnd.next(26);\n                s += c;\n            }\n            usernames.push_back(s);\n        }\n    } else if (type == \"increase\") {\n        for (int i = 1; i <= n; ++i) {\n            usernames.push_back(\"name\" + to_string(i));\n        }\n    } else if (type == \"large_numbers\") {\n        string s = \"user\";\n        for (int i = 0; i < n; ++i) {\n            usernames.push_back(s);\n        }\n    } else if (type == \"max_append_number\") {\n        // This should create names that force the appended number to reach maximum\n        // For example, we can have n/2 repetitions of 'a' and n/2 repetitions of 'b'\n        if (n % 2 != 0) {\n            cerr << \"n must be even for max_append_number test case\";\n            exit(1);\n        }\n        int half = n / 2;\n        string s1 = \"a\";\n        string s2 = \"b\";\n        for (int i = 0; i < half; ++i) {\n            usernames.push_back(s1);\n        }\n        for (int i = 0; i < half; ++i) {\n            usernames.push_back(s2);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 32);\n            string s;\n            for (int j = 0; j < len; ++j) {\n                char c = 'a' + rnd.next(26);\n                s += c;\n            }\n            usernames.push_back(s);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", usernames[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> usernames;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 32);\n            string s;\n            for (int j = 0; j < len; ++j) {\n                char c = 'a' + rnd.next(26);\n                s += c;\n            }\n            usernames.push_back(s);\n        }\n    } else if (type == \"same\") {\n        string s = \"user\";\n        for (int i = 0; i < n; ++i) {\n            usernames.push_back(s);\n        }\n    } else if (type == \"short\") {\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            string s(1, c);\n            usernames.push_back(s);\n        }\n    } else if (type == \"long\") {\n        for (int i = 0; i < n; ++i) {\n            string s;\n            for (int j = 0; j < 32; ++j) {\n                char c = 'a' + rnd.next(26);\n                s += c;\n            }\n            usernames.push_back(s);\n        }\n    } else if (type == \"increase\") {\n        for (int i = 1; i <= n; ++i) {\n            usernames.push_back(\"name\" + to_string(i));\n        }\n    } else if (type == \"large_numbers\") {\n        string s = \"user\";\n        for (int i = 0; i < n; ++i) {\n            usernames.push_back(s);\n        }\n    } else if (type == \"max_append_number\") {\n        // This should create names that force the appended number to reach maximum\n        // For example, we can have n/2 repetitions of 'a' and n/2 repetitions of 'b'\n        if (n % 2 != 0) {\n            cerr << \"n must be even for max_append_number test case\";\n            exit(1);\n        }\n        int half = n / 2;\n        string s1 = \"a\";\n        string s2 = \"b\";\n        for (int i = 0; i < half; ++i) {\n            usernames.push_back(s1);\n        }\n        for (int i = 0; i < half; ++i) {\n            usernames.push_back(s2);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, 32);\n            string s;\n            for (int j = 0; j < len; ++j) {\n                char c = 'a' + rnd.next(26);\n                s += c;\n            }\n            usernames.push_back(s);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", usernames[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type same\n./gen -n 1 -type random\n./gen -n 1 -type long\n./gen -n 1 -type short\n./gen -n 2 -type same\n./gen -n 2 -type random\n./gen -n 10 -type same\n./gen -n 10 -type random\n./gen -n 10 -type increase\n./gen -n 10 -type large_numbers\n./gen -n 100 -type random\n./gen -n 100 -type same\n./gen -n 100 -type increase\n./gen -n 1000 -type random\n./gen -n 1000 -type same\n./gen -n 1000 -type long\n./gen -n 1000 -type short\n./gen -n 1000 -type increase\n./gen -n 10000 -type random\n./gen -n 10000 -type same\n./gen -n 10000 -type increase\n./gen -n 10000 -type large_numbers\n./gen -n 50000 -type same\n./gen -n 50000 -type random\n./gen -n 50000 -type increase\n./gen -n 100000 -type random\n./gen -n 100000 -type same\n./gen -n 100000 -type increase\n./gen -n 100000 -type large_numbers\n./gen -n 100000 -type max_append_number\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:04.388883",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "4/D",
      "title": "D. Mysterious Present",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first line contains integers n, w, h (1  ≤ n ≤ 5000, 1 ≤ w,  h  ≤ 106) — amount of envelopes Peter has, the card width and height respectively. Then there follow n lines, each of them contains two integer numbers wi and hi — width and height of the i-th envelope (1 ≤ wi,  hi ≤ 106).",
      "output_spec": "OutputIn the first line print the maximum chain size. In the second line print the numbers of the envelopes (separated by space), forming the required chain, starting with the number of the smallest envelope. Remember, please, that the card should fit into the smallest envelope. If the chain of maximum size is not unique, print any of the answers.If the card does not fit into any of the envelopes, print number 0 in the single line.",
      "sample_tests": "ExamplesInputCopy2 1 12 22 2OutputCopy11 InputCopy3 3 35 412 119 8OutputCopy31 3 2",
      "description": "D. Mysterious Present\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n, w, h (1  ≤ n ≤ 5000, 1 ≤ w,  h  ≤ 106) — amount of envelopes Peter has, the card width and height respectively. Then there follow n lines, each of them contains two integer numbers wi and hi — width and height of the i-th envelope (1 ≤ wi,  hi ≤ 106).\n\nOutputIn the first line print the maximum chain size. In the second line print the numbers of the envelopes (separated by space), forming the required chain, starting with the number of the smallest envelope. Remember, please, that the card should fit into the smallest envelope. If the chain of maximum size is not unique, print any of the answers.If the card does not fit into any of the envelopes, print number 0 in the single line.\n\nInputCopy2 1 12 22 2OutputCopy11 InputCopy3 3 35 412 119 8OutputCopy31 3 2\n\nInputCopy2 1 12 22 2\n\nOutputCopy11\n\nInputCopy3 3 35 412 119 8\n\nOutputCopy31 3 2",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(1, 1000000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(1, 1000000, \"h\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int wi = inf.readInt(1, 1000000, \"wi\");\n        inf.readSpace();\n        int hi = inf.readInt(1, 1000000, \"hi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(1, 1000000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(1, 1000000, \"h\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int wi = inf.readInt(1, 1000000, \"wi\");\n        inf.readSpace();\n        int hi = inf.readInt(1, 1000000, \"hi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(1, 1000000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(1, 1000000, \"h\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int wi = inf.readInt(1, 1000000, \"wi\");\n        inf.readSpace();\n        int hi = inf.readInt(1, 1000000, \"hi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint w, h; // Card dimensions\nvector<pair<int, int>> envelopes; // Envelopes dimensions\n\n// This function receives stream as an argument, reads an answer from it,\n// checks its correctness (i.e., that it is indeed a valid chain according to the problem),\n// and returns the chain size. If the chain is incorrect, it stops the execution\n// with _wa outcome if stream == ouf (participant) or with _fail outcome if stream == ans (jury).\nint readAndCheckAns(InStream& stream) {\n    int chainSize = stream.readInt(0, n, \"chain size\");\n    if (chainSize == 0) {\n        return 0; // No chain provided\n    }\n\n    vector<int> chain(chainSize);\n    set<int> usedIndices; // To check for duplicate envelopes\n\n    for (int i = 0; i < chainSize; ++i) {\n        int idx = stream.readInt(1, n, format(\"chain[%d]\", i + 1).c_str()) - 1; // Convert to 0-based index\n        if (usedIndices.count(idx)) {\n            stream.quitf(_wa, \"Envelope %d is used more than once in the chain\", idx + 1);\n        }\n        usedIndices.insert(idx);\n        chain[i] = idx;\n    }\n\n    // Check that the first envelope is strictly larger than the card\n    int envW = envelopes[chain[0]].first;\n    int envH = envelopes[chain[0]].second;\n\n    if (!(envW > w && envH > h)) {\n        stream.quitf(_wa, \"The first envelope in the chain is not strictly larger than the card\");\n    }\n\n    // Check that each envelope is strictly larger than the previous one\n    for (int i = 1; i < chainSize; ++i) {\n        int prevIdx = chain[i - 1];\n        int currIdx = chain[i];\n\n        int prevW = envelopes[prevIdx].first;\n        int prevH = envelopes[prevIdx].second;\n\n        int currW = envelopes[currIdx].first;\n        int currH = envelopes[currIdx].second;\n\n        if (!(currW > prevW && currH > prevH)) {\n            stream.quitf(_wa, \"Envelope %d is not strictly larger than envelope %d\", currIdx + 1, prevIdx + 1);\n        }\n    }\n\n    return chainSize;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Reading input data\n    n = inf.readInt();\n    w = inf.readInt();\n    h = inf.readInt();\n\n    envelopes.resize(n);\n    for (int i = 0; i < n; ++i) {\n        int wi = inf.readInt();\n        int hi = inf.readInt();\n        envelopes[i] = make_pair(wi, hi);\n    }\n\n    // Reading jury's answer\n    int juryChainSize = readAndCheckAns(ans);\n\n    // Reading participant's answer\n    int participantChainSize = readAndCheckAns(ouf);\n\n    if (participantChainSize > juryChainSize) {\n        // Participant found a better answer than the jury\n        quitf(_fail, \"Participant has a chain size (%d) greater than the jury's chain size (%d)\",\n              participantChainSize, juryChainSize);\n    } else if (participantChainSize < juryChainSize) {\n        // Participant's chain is shorter than the jury's\n        quitf(_wa, \"Participant's chain size (%d) is less than the jury's chain size (%d)\",\n              participantChainSize, juryChainSize);\n    } else {\n        // Participant's chain size matches the jury's\n        quitf(_ok, \"Chain size is %d\", participantChainSize);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int w = opt<int>(\"w\");\n    int h = opt<int>(\"h\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d %d\\n\", n, w, h);\n\n    vector<pair<int, int>> envelopes(n);\n\n    if (type == \"random\") {\n        // Generate random envelopes with widths and heights in [1, 1e6]\n        for(int i = 0; i < n; ++i) {\n            int wi = rnd.next(1, 1000000);\n            int hi = rnd.next(1, 1000000);\n            envelopes[i] = {wi, hi};\n        }\n    } else if (type == \"envelopes_larger_than_card\") {\n        // All envelopes larger than the card\n        for(int i = 0; i < n; ++i) {\n            int wi = rnd.next(w+1, 1000000);\n            int hi = rnd.next(h+1, 1000000);\n            envelopes[i] = {wi, hi};\n        }\n    } else if (type == \"no_envelope_fits\") {\n        // All envelopes smaller than or equal to the card\n        for(int i = 0; i < n; ++i) {\n            int wi = rnd.next(1, w);\n            int hi = rnd.next(1, h);\n            envelopes[i] = {wi, hi};\n        }\n    } else if (type == \"max_chain\") {\n        // Generate envelopes that can form a chain of length n\n        int wi = w + 1;\n        int hi = h + 1;\n        for(int i = 0; i < n; ++i) {\n            envelopes[i] = {wi, hi};\n            wi += rnd.next(1, 10);\n            hi += rnd.next(1, 10);\n        }\n        shuffle(envelopes.begin(), envelopes.end());\n    } else if (type == \"envelopes_same_size\") {\n        // Generate envelopes with same dimensions\n        int wi = w + rnd.next(1, 1000000 - w);\n        int hi = h + rnd.next(1, 1000000 - h);\n        for(int i = 0; i < n; ++i) {\n            envelopes[i] = {wi, hi};\n        }\n    } else if (type == \"duplicates\") {\n        // Generate envelopes with possible duplicates\n        for(int i = 0; i < n; ++i) {\n            int wi = rnd.next(1, 1000000);\n            int hi = rnd.next(1, 1000000);\n            envelopes[i] = {wi, hi};\n            if (i > 0 && rnd.next(0,1) == 0) {\n                envelopes[i].first = envelopes[i-1].first;\n                envelopes[i].second = envelopes[i-1].second;\n            }\n        }\n    } else if (type == \"degenerate_cases\") {\n        // Generate envelopes where only one dimension varies\n        for(int i = 0; i < n; ++i) {\n            int wi = rnd.next(w+1, 1000000);\n            int hi = h + rnd.next(0, 1); // h or h+1\n            envelopes[i] = {wi, hi};\n        }\n    } else if (type == \"large_numbers\") {\n        // Envelopes with dimensions near 1e6\n        for(int i = 0; i < n; ++i) {\n            int wi = rnd.next(999990, 1000000);\n            int hi = rnd.next(999990, 1000000);\n            envelopes[i] = {wi, hi};\n        }\n    } else if (type == \"small_numbers\") {\n        // Envelopes with dimensions near 1\n        for(int i = 0; i < n; ++i) {\n            int wi = rnd.next(1, max(w+1, 2));\n            int hi = rnd.next(1, max(h+1, 2));\n            envelopes[i] = {wi, hi};\n        }\n    } else if (type == \"only_one_envelope_fits\") {\n        // Only one envelope can hold the card\n        for(int i = 0; i < n; ++i) {\n            int wi = rnd.next(1, w);\n            int hi = rnd.next(1, h);\n            envelopes[i] = {wi, hi};\n        }\n        // Now make one envelope bigger than the card\n        envelopes[0] = {w+1, h+1};\n    } else {\n        // Default is random\n        for(int i = 0; i < n; ++i) {\n            int wi = rnd.next(1, 1000000);\n            int hi = rnd.next(1, 1000000);\n            envelopes[i] = {wi, hi};\n        }\n    }\n\n    // Output the envelopes\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", envelopes[i].first, envelopes[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int w = opt<int>(\"w\");\n    int h = opt<int>(\"h\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d %d\\n\", n, w, h);\n\n    vector<pair<int, int>> envelopes(n);\n\n    if (type == \"random\") {\n        // Generate random envelopes with widths and heights in [1, 1e6]\n        for(int i = 0; i < n; ++i) {\n            int wi = rnd.next(1, 1000000);\n            int hi = rnd.next(1, 1000000);\n            envelopes[i] = {wi, hi};\n        }\n    } else if (type == \"envelopes_larger_than_card\") {\n        // All envelopes larger than the card\n        for(int i = 0; i < n; ++i) {\n            int wi = rnd.next(w+1, 1000000);\n            int hi = rnd.next(h+1, 1000000);\n            envelopes[i] = {wi, hi};\n        }\n    } else if (type == \"no_envelope_fits\") {\n        // All envelopes smaller than or equal to the card\n        for(int i = 0; i < n; ++i) {\n            int wi = rnd.next(1, w);\n            int hi = rnd.next(1, h);\n            envelopes[i] = {wi, hi};\n        }\n    } else if (type == \"max_chain\") {\n        // Generate envelopes that can form a chain of length n\n        int wi = w + 1;\n        int hi = h + 1;\n        for(int i = 0; i < n; ++i) {\n            envelopes[i] = {wi, hi};\n            wi += rnd.next(1, 10);\n            hi += rnd.next(1, 10);\n        }\n        shuffle(envelopes.begin(), envelopes.end());\n    } else if (type == \"envelopes_same_size\") {\n        // Generate envelopes with same dimensions\n        int wi = w + rnd.next(1, 1000000 - w);\n        int hi = h + rnd.next(1, 1000000 - h);\n        for(int i = 0; i < n; ++i) {\n            envelopes[i] = {wi, hi};\n        }\n    } else if (type == \"duplicates\") {\n        // Generate envelopes with possible duplicates\n        for(int i = 0; i < n; ++i) {\n            int wi = rnd.next(1, 1000000);\n            int hi = rnd.next(1, 1000000);\n            envelopes[i] = {wi, hi};\n            if (i > 0 && rnd.next(0,1) == 0) {\n                envelopes[i].first = envelopes[i-1].first;\n                envelopes[i].second = envelopes[i-1].second;\n            }\n        }\n    } else if (type == \"degenerate_cases\") {\n        // Generate envelopes where only one dimension varies\n        for(int i = 0; i < n; ++i) {\n            int wi = rnd.next(w+1, 1000000);\n            int hi = h + rnd.next(0, 1); // h or h+1\n            envelopes[i] = {wi, hi};\n        }\n    } else if (type == \"large_numbers\") {\n        // Envelopes with dimensions near 1e6\n        for(int i = 0; i < n; ++i) {\n            int wi = rnd.next(999990, 1000000);\n            int hi = rnd.next(999990, 1000000);\n            envelopes[i] = {wi, hi};\n        }\n    } else if (type == \"small_numbers\") {\n        // Envelopes with dimensions near 1\n        for(int i = 0; i < n; ++i) {\n            int wi = rnd.next(1, max(w+1, 2));\n            int hi = rnd.next(1, max(h+1, 2));\n            envelopes[i] = {wi, hi};\n        }\n    } else if (type == \"only_one_envelope_fits\") {\n        // Only one envelope can hold the card\n        for(int i = 0; i < n; ++i) {\n            int wi = rnd.next(1, w);\n            int hi = rnd.next(1, h);\n            envelopes[i] = {wi, hi};\n        }\n        // Now make one envelope bigger than the card\n        envelopes[0] = {w+1, h+1};\n    } else {\n        // Default is random\n        for(int i = 0; i < n; ++i) {\n            int wi = rnd.next(1, 1000000);\n            int hi = rnd.next(1, 1000000);\n            envelopes[i] = {wi, hi};\n        }\n    }\n\n    // Output the envelopes\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", envelopes[i].first, envelopes[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -w 5 -h 5 -type random\n./gen -n 10 -w 5 -h 5 -type envelopes_larger_than_card\n./gen -n 10 -w 5 -h 5 -type no_envelope_fits\n./gen -n 10 -w 5 -h 5 -type max_chain\n./gen -n 15 -w 100 -h 100 -type envelopes_same_size\n./gen -n 50 -w 1 -h 1 -type small_numbers\n./gen -n 50 -w 1000000 -h 1000000 -type large_numbers\n./gen -n 100 -w 1000 -h 1000 -type duplicates\n./gen -n 200 -w 500000 -h 500000 -type degenerate_cases\n./gen -n 500 -w 1 -h 1 -type only_one_envelope_fits\n./gen -n 1000 -w 1000 -h 1000 -type random\n./gen -n 2000 -w 10000 -h 10000 -type max_chain\n./gen -n 3000 -w 999999 -h 999999 -type large_numbers\n./gen -n 4000 -w 2 -h 1 -type envelopes_larger_than_card\n./gen -n 5000 -w 1 -h 1 -type no_envelope_fits\n./gen -n 5000 -w 500 -h 500 -type duplicates\n./gen -n 5000 -w 100000 -h 100000 -type degenerate_cases\n./gen -n 5000 -w 500000 -h 500000 -type random\n./gen -n 5000 -w 999990 -h 999990 -type small_numbers\n./gen -n 5000 -w 1000000 -h 1000000 -type large_numbers\n./gen -n 5000 -w 1 -h 1 -type only_one_envelope_fits\n./gen -n 1 -w 1 -h 1 -type envelopes_same_size\n./gen -n 2 -w 100 -h 100 -type only_one_envelope_fits\n./gen -n 1000 -w 500000 -h 500000 -type random\n./gen -n 5000 -w 1000 -h 1000 -type envelopes_same_size\n./gen -n 5000 -w 250000 -h 250000 -type envelopes_larger_than_card\n./gen -n 5000 -w 750000 -h 750000 -type no_envelope_fits\n./gen -n 5000 -w 50000 -h 50000 -type max_chain\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:06.498180",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "40/A",
      "title": "A. Find Color",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first and single line contains two integers x and y — the coordinates of the hole made in the clock by the ball. Each of the numbers x and y has an absolute value that does not exceed 1000.",
      "output_spec": "OutputFind the required color.All the points between which and the origin of coordinates the distance is integral-value are painted black.",
      "sample_tests": "ExamplesInputCopy-2 1OutputCopywhiteInputCopy2 1OutputCopyblackInputCopy4 3OutputCopyblack",
      "description": "A. Find Color\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first and single line contains two integers x and y — the coordinates of the hole made in the clock by the ball. Each of the numbers x and y has an absolute value that does not exceed 1000.\n\nOutputFind the required color.All the points between which and the origin of coordinates the distance is integral-value are painted black.\n\nInputCopy-2 1OutputCopywhiteInputCopy2 1OutputCopyblackInputCopy4 3OutputCopyblack\n\nInputCopy-2 1\n\nOutputCopywhite\n\nInputCopy2 1\n\nOutputCopyblack\n\nInputCopy4 3\n\nOutputCopyblack",
      "solutions": [
        {
          "title": "Codeforces Beta Round #39 - Codeforces",
          "content": "I invite you all to take part in the next Codeforces Round!This time the problems are written by me and sdya. Some information about us: we both are second year students of The Faculty of Mechanics and Mathematics of Kharkiv National University named after V.N. Karazin, and we are twin brothers. We began studying programming in the 10th form, about 2.5 years ago. We do not have any significant achievements in programming competitions yet, but we hope we still have time to get some :)We would like to express our gratitude to Artem Rakhov who helped us to arrange this contest, and to Maria Belova who has translated the problems statements into English.We wish good luck to everyone and hope you will find the problems interesting!UPD: The contest is over, congratulate tourist, who won this round.Link to results.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/820",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 819
        },
        {
          "title": "Codeforces Beta Round #39 (Разбор задач) - Codeforces",
          "content": "Задача A. Определите цветЗдесь все понятно. Достаточно рассмотреть несколько случаев. Первый — когда расстояние от точки до начала координат — целое число, тогда ответ black. В противном случае, пусть d - это расстояние от нашей точки до начала координат. Тогда будем работать с [d]. Теперь осталось два случая: 1) если наша точка лежит в 1-ой, или 3-ей четверти; 2) точка лежит во 2-ой, либо 4-ой четверти. В случае 1) имеем, если [d] нечетно, то ответ white, иначе black; в случае 2) если [d] четно, то ответ white, иначе black. Подразумевается, что [d] — целая часть d.Задача B. ПерекрашиванияПервое, что надо заметить, так это то, что на i-ом шаге все перекрашенные клетки будут лежать в прямоугольнике с вершинами в клетках (i,i), (n-i,m-i) (если считать, что (1,1) - левая верхняя клетка, а (n,m) — правая нижняя). Тогда отсюда уже следует решение: нужно подсчитать количество клеток такого типа, что минимальное расстояние до стороны в точности равняется x. То есть для клетки (a,b) должно выполняться min(min(a, b), min(n - a + 1, m - b + 1)) = x.Задача C. Берляндская площадьИдейно эта задача не очень сложная, но было много хитрых случаев. Авторское решение предполагало следующую идею. Сначала заметим, что наше множество окружностей на плоскости может быть несвязным. Тут есть два случая, когда есть хотя бы одна точка пересечения окружностей и когда нет ни одной. Если их нет, то ответ N+M+1. Иначе, если есть хотя бы одна точка пересечения, то мы можем удалить некоторые окружности таким образом, чтобы оставшаяся фигура из окружностей была связной. Тогда для этой фигуры можно применить формулу Эйлера. Таким образом, нам здесь нужно посчитать количество точек пересечения и количество дуг-ребер. Нетрудно видеть, что каждая точка пересечения добавляет две дуги. Таким образом, мы можем найти количество частей, на которые разделилась плоскость без удаленных окружностей. Теперь достаточно заметить, что каждая удаленная окружность добавляет ровно 1 к ответу. Весь вопрос в том, чтобы посчитать, сколько точек пересечения. Это можно сделать за O(N+M), если считать для каждой окружности, точки пересечения, которые принадлежат ей. Для этого достаточно заметить, что все окружности, с которыми наша окружность пересекается будут иметь радиусы l, l+1, ..., r. Также, с некоторыми из этих окружностей наша окружность будет иметь не две точки пересечения а одну. Это необходимо учесть в решении. После этого остается лишь аккуратно реализовать эту идею. Задача D. Интересная последовательностьЗдесь нужно было погенерировать разные последовательности, которые могут получаться и внимательно смотреть на полученные значения. Основное наблюдение, это то, что каждое из чисел, которые встречаются в последовательности имеет вид 12k + 12m, при этом это число может встречаться лишь на позиции (k + m + 1). Теперь, когда известен общий вид, можно по методу математической индукции доказать, что на x-ой позиции могут встречаться все числа вида 12k + 12m, такие что, k + m + 1 = x. После этого можно было реализовать простое в написании решение за O(N3), где N — длина входного числа. Для этого перебираем все x от 1 до 600 и проверяем, существуют ли такие k и m, что k + m + 1 = x и 12k + 12m = A. Но также есть и решение со сложностью O(N2).Задача E. Таблица из чиселПервое, что должно было броситься в глаза, это то, что клеток, изначально не пустых — совсем мало. Из ограничений следует, что всегда есть пустая строка либо пустой столбец. Без ограничений общности можем считать, что у нас есть пустая строка и она последняя. Тогда выберем какой-либо столбец (к примеру, последний) и зафиксируем его одновременно с пустой строкой. Тогда по оставшейся таблице размера (n - 1) × (m - 1) клетки в последнем столбце и в последней строке заполняются однозначно. Но есть одно замечание, в последнем столбце уже стоят какие-то числа. Тогда нам надо для каждой строки, кроме последней подсчитать, сколько существует вариантов этой строки, таких, что произведение чисел в этой строке равно -1. В авторском решении, эта часть считалась при помощи динамического программирования. После этого нужно перемножить полученные ответы для каждой строки. Тогда ответ на задачу — это полученное произведение, либо 0 — если сумма n + m нечетна. Разбор задач был подготовлен мной и sdya.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/835",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4273
        },
        {
          "title": "codeforces #39 - Codeforces",
          "content": "Задача A(Определите цвет):  Сразу очевидно, что если sqrt(x^2+y^2)-целое то ответ black, иначе перебираем радиус: как только радиус становиться больше чем x^2+y^2 то Если x*y>0, то если радиус-четный, то ответ white, иначе ответ black Если x*y<0, то если радиус-нечетный, то ответ white, иначе ответ black Этой задачей я заработал себе первые 484 баллаЗадача B(Перекрашивания):  Если x>5000, то ответ 0. Решал перебором, то есть задал координаты углов куска поля, который еще будет закрашиваться. изначально x1=1; y1=1; x2=n; y2=m;  x1,y1- верхние левые, x2,y2- нижние правые. От 1 до x  увеличивал x1 и y1, уменьшал x2,y2; Потом перебирал значения i от x1 до x2 и j от y1 до y2 и смотрел, если i mod 2=j mod 2 значит        увеличивал ответ. Сдал эту задачу со второй попытки, получил по ней 822 балла.По задачам С, D, E у меня идей не было =(Взломы : Я сделал по задаче A-успешный взлом и 2 взлома по B, но в то же время сделал 6 неудачных взлома     по задаче B =), в общем по взломам я получил 0 баллов.Итог: Контест для меня прошел удачно, я выполнил свою цель: стать желтым =)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/829",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1082
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #39 - Codeforces - Code 1",
          "code": "94925 5648 96389 1799",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/820",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #39 - Codeforces - Code 2",
          "code": "Answer: 1426155172",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/820",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(-1000, 1000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-1000, 1000, \"y\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(-1000, 1000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-1000, 1000, \"y\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(-1000, 1000, \"x\");\n    inf.readSpace();\n    int y = inf.readInt(-1000, 1000, \"y\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int type = opt<int>(\"type\", 0);\n    int x = 0, y = 0;\n\n    if (type == 1) {\n        // Points on boundaries (D integer)\n        int radius = opt<int>(\"r\", rnd.next(1, 1000));\n        double angle = rnd.next(0.0, 2.0 * acos(-1.0));\n        x = int(round(radius * cos(angle)));\n        y = int(round(radius * sin(angle)));\n    } else if (type == 2) {\n        // Points within even-numbered rings, in different quadrants\n        int ring = rnd.next(1, 500) * 2; // even ring\n        double min_radius = ring + 0.1;\n        double max_radius = ring + 0.9;\n        double radius = rnd.next(min_radius, max_radius);\n        double angle = rnd.next(0.0, 2.0 * acos(-1.0));\n        x = int(round(radius * cos(angle)));\n        y = int(round(radius * sin(angle)));\n    } else if (type == 3) {\n        // Points within odd-numbered rings, in different quadrants\n        int ring = rnd.next(1, 500) * 2 - 1; // odd ring\n        double min_radius = ring + 0.1;\n        double max_radius = ring + 0.9;\n        double radius = rnd.next(min_radius, max_radius);\n        double angle = rnd.next(0.0, 2.0 * acos(-1.0));\n        x = int(round(radius * cos(angle)));\n        y = int(round(radius * sin(angle)));\n    } else if (type == 4) {\n        // Edge cases (x=0 or y=0)\n        if (rnd.next(0,1) == 0) {\n            x = 0;\n            y = rnd.next(-1000, 1000);\n        } else {\n            x = rnd.next(-1000, 1000);\n            y = 0;\n        }\n    } else if (type == 5) {\n        // Maximal coordinate values\n        if (rnd.next(0, 1) == 0) {\n            x = 1000;\n        } else {\n            x = -1000;\n        }\n        y = rnd.next(-1000, 1000);\n    } else if (type == 6) {\n        // Near boundary inside (just inside integer radius)\n        int radius = rnd.next(1, 1000);\n        double epsilon = rnd.next(0.0001, 0.01);\n        double distance = radius - epsilon;\n        double angle = rnd.next(0.0, 2.0 * acos(-1.0));\n        x = int(round(distance * cos(angle)));\n        y = int(round(distance * sin(angle)));\n    } else if (type == 7) {\n        // Near boundary outside (just outside integer radius)\n        int radius = rnd.next(1, 1000);\n        double epsilon = rnd.next(0.0001, 0.01);\n        double distance = radius + epsilon;\n        double angle = rnd.next(0.0, 2.0 * acos(-1.0));\n        x = int(round(distance * cos(angle)));\n        y = int(round(distance * sin(angle)));\n    } else if (type == 8) {\n        // Points at the origin\n        x = 0;\n        y = 0;\n    } else {\n        // Random point\n        x = rnd.next(-1000, 1000);\n        y = rnd.next(-1000, 1000);\n    }\n\n    // Ensure x and y are within allowed bounds\n    x = max(-1000, min(1000, x));\n    y = max(-1000, min(1000, y));\n\n    printf(\"%d %d\\n\", x, y);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int type = opt<int>(\"type\", 0);\n    int x = 0, y = 0;\n\n    if (type == 1) {\n        // Points on boundaries (D integer)\n        int radius = opt<int>(\"r\", rnd.next(1, 1000));\n        double angle = rnd.next(0.0, 2.0 * acos(-1.0));\n        x = int(round(radius * cos(angle)));\n        y = int(round(radius * sin(angle)));\n    } else if (type == 2) {\n        // Points within even-numbered rings, in different quadrants\n        int ring = rnd.next(1, 500) * 2; // even ring\n        double min_radius = ring + 0.1;\n        double max_radius = ring + 0.9;\n        double radius = rnd.next(min_radius, max_radius);\n        double angle = rnd.next(0.0, 2.0 * acos(-1.0));\n        x = int(round(radius * cos(angle)));\n        y = int(round(radius * sin(angle)));\n    } else if (type == 3) {\n        // Points within odd-numbered rings, in different quadrants\n        int ring = rnd.next(1, 500) * 2 - 1; // odd ring\n        double min_radius = ring + 0.1;\n        double max_radius = ring + 0.9;\n        double radius = rnd.next(min_radius, max_radius);\n        double angle = rnd.next(0.0, 2.0 * acos(-1.0));\n        x = int(round(radius * cos(angle)));\n        y = int(round(radius * sin(angle)));\n    } else if (type == 4) {\n        // Edge cases (x=0 or y=0)\n        if (rnd.next(0,1) == 0) {\n            x = 0;\n            y = rnd.next(-1000, 1000);\n        } else {\n            x = rnd.next(-1000, 1000);\n            y = 0;\n        }\n    } else if (type == 5) {\n        // Maximal coordinate values\n        if (rnd.next(0, 1) == 0) {\n            x = 1000;\n        } else {\n            x = -1000;\n        }\n        y = rnd.next(-1000, 1000);\n    } else if (type == 6) {\n        // Near boundary inside (just inside integer radius)\n        int radius = rnd.next(1, 1000);\n        double epsilon = rnd.next(0.0001, 0.01);\n        double distance = radius - epsilon;\n        double angle = rnd.next(0.0, 2.0 * acos(-1.0));\n        x = int(round(distance * cos(angle)));\n        y = int(round(distance * sin(angle)));\n    } else if (type == 7) {\n        // Near boundary outside (just outside integer radius)\n        int radius = rnd.next(1, 1000);\n        double epsilon = rnd.next(0.0001, 0.01);\n        double distance = radius + epsilon;\n        double angle = rnd.next(0.0, 2.0 * acos(-1.0));\n        x = int(round(distance * cos(angle)));\n        y = int(round(distance * sin(angle)));\n    } else if (type == 8) {\n        // Points at the origin\n        x = 0;\n        y = 0;\n    } else {\n        // Random point\n        x = rnd.next(-1000, 1000);\n        y = rnd.next(-1000, 1000);\n    }\n\n    // Ensure x and y are within allowed bounds\n    x = max(-1000, min(1000, x));\n    y = max(-1000, min(1000, y));\n\n    printf(\"%d %d\\n\", x, y);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type 1\n./gen -type 1 -r 1\n./gen -type 1 -r 2\n./gen -type 1 -r 1000\n./gen -type 2\n./gen -type 2\n./gen -type 2\n./gen -type 3\n./gen -type 3\n./gen -type 3\n./gen -type 4\n./gen -type 4\n./gen -type 5\n./gen -type 5\n./gen -type 6\n./gen -type 6\n./gen -type 7\n./gen -type 7\n./gen -type 8\n./gen -type 0\n./gen -type 0\n./gen -type 0\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:08.537999",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "40/B",
      "title": "B. Repaintings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n and m (1 ≤ n, m ≤ 5000). The second line contains integer x (1 ≤ x ≤ 109).",
      "output_spec": "OutputPrint how many squares will be painted exactly x times.",
      "sample_tests": "ExamplesInputCopy3 31OutputCopy4InputCopy3 32OutputCopy1InputCopy1 11OutputCopy1",
      "description": "B. Repaintings\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n and m (1 ≤ n, m ≤ 5000). The second line contains integer x (1 ≤ x ≤ 109).\n\nOutputPrint how many squares will be painted exactly x times.\n\nInputCopy3 31OutputCopy4InputCopy3 32OutputCopy1InputCopy1 11OutputCopy1\n\nInputCopy3 31\n\nOutputCopy4\n\nInputCopy3 32\n\nOutputCopy1\n\nInputCopy1 11\n\nOutputCopy1",
      "solutions": [
        {
          "title": "Codeforces Beta Round #39 - Codeforces",
          "content": "I invite you all to take part in the next Codeforces Round!This time the problems are written by me and sdya. Some information about us: we both are second year students of The Faculty of Mechanics and Mathematics of Kharkiv National University named after V.N. Karazin, and we are twin brothers. We began studying programming in the 10th form, about 2.5 years ago. We do not have any significant achievements in programming competitions yet, but we hope we still have time to get some :)We would like to express our gratitude to Artem Rakhov who helped us to arrange this contest, and to Maria Belova who has translated the problems statements into English.We wish good luck to everyone and hope you will find the problems interesting!UPD: The contest is over, congratulate tourist, who won this round.Link to results.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/820",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 819
        },
        {
          "title": "Codeforces Beta Round #39 (Разбор задач) - Codeforces",
          "content": "Задача A. Определите цветЗдесь все понятно. Достаточно рассмотреть несколько случаев. Первый — когда расстояние от точки до начала координат — целое число, тогда ответ black. В противном случае, пусть d - это расстояние от нашей точки до начала координат. Тогда будем работать с [d]. Теперь осталось два случая: 1) если наша точка лежит в 1-ой, или 3-ей четверти; 2) точка лежит во 2-ой, либо 4-ой четверти. В случае 1) имеем, если [d] нечетно, то ответ white, иначе black; в случае 2) если [d] четно, то ответ white, иначе black. Подразумевается, что [d] — целая часть d.Задача B. ПерекрашиванияПервое, что надо заметить, так это то, что на i-ом шаге все перекрашенные клетки будут лежать в прямоугольнике с вершинами в клетках (i,i), (n-i,m-i) (если считать, что (1,1) - левая верхняя клетка, а (n,m) — правая нижняя). Тогда отсюда уже следует решение: нужно подсчитать количество клеток такого типа, что минимальное расстояние до стороны в точности равняется x. То есть для клетки (a,b) должно выполняться min(min(a, b), min(n - a + 1, m - b + 1)) = x.Задача C. Берляндская площадьИдейно эта задача не очень сложная, но было много хитрых случаев. Авторское решение предполагало следующую идею. Сначала заметим, что наше множество окружностей на плоскости может быть несвязным. Тут есть два случая, когда есть хотя бы одна точка пересечения окружностей и когда нет ни одной. Если их нет, то ответ N+M+1. Иначе, если есть хотя бы одна точка пересечения, то мы можем удалить некоторые окружности таким образом, чтобы оставшаяся фигура из окружностей была связной. Тогда для этой фигуры можно применить формулу Эйлера. Таким образом, нам здесь нужно посчитать количество точек пересечения и количество дуг-ребер. Нетрудно видеть, что каждая точка пересечения добавляет две дуги. Таким образом, мы можем найти количество частей, на которые разделилась плоскость без удаленных окружностей. Теперь достаточно заметить, что каждая удаленная окружность добавляет ровно 1 к ответу. Весь вопрос в том, чтобы посчитать, сколько точек пересечения. Это можно сделать за O(N+M), если считать для каждой окружности, точки пересечения, которые принадлежат ей. Для этого достаточно заметить, что все окружности, с которыми наша окружность пересекается будут иметь радиусы l, l+1, ..., r. Также, с некоторыми из этих окружностей наша окружность будет иметь не две точки пересечения а одну. Это необходимо учесть в решении. После этого остается лишь аккуратно реализовать эту идею. Задача D. Интересная последовательностьЗдесь нужно было погенерировать разные последовательности, которые могут получаться и внимательно смотреть на полученные значения. Основное наблюдение, это то, что каждое из чисел, которые встречаются в последовательности имеет вид 12k + 12m, при этом это число может встречаться лишь на позиции (k + m + 1). Теперь, когда известен общий вид, можно по методу математической индукции доказать, что на x-ой позиции могут встречаться все числа вида 12k + 12m, такие что, k + m + 1 = x. После этого можно было реализовать простое в написании решение за O(N3), где N — длина входного числа. Для этого перебираем все x от 1 до 600 и проверяем, существуют ли такие k и m, что k + m + 1 = x и 12k + 12m = A. Но также есть и решение со сложностью O(N2).Задача E. Таблица из чиселПервое, что должно было броситься в глаза, это то, что клеток, изначально не пустых — совсем мало. Из ограничений следует, что всегда есть пустая строка либо пустой столбец. Без ограничений общности можем считать, что у нас есть пустая строка и она последняя. Тогда выберем какой-либо столбец (к примеру, последний) и зафиксируем его одновременно с пустой строкой. Тогда по оставшейся таблице размера (n - 1) × (m - 1) клетки в последнем столбце и в последней строке заполняются однозначно. Но есть одно замечание, в последнем столбце уже стоят какие-то числа. Тогда нам надо для каждой строки, кроме последней подсчитать, сколько существует вариантов этой строки, таких, что произведение чисел в этой строке равно -1. В авторском решении, эта часть считалась при помощи динамического программирования. После этого нужно перемножить полученные ответы для каждой строки. Тогда ответ на задачу — это полученное произведение, либо 0 — если сумма n + m нечетна. Разбор задач был подготовлен мной и sdya.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/835",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4273
        },
        {
          "title": "codeforces #39 - Codeforces",
          "content": "Задача A(Определите цвет):  Сразу очевидно, что если sqrt(x^2+y^2)-целое то ответ black, иначе перебираем радиус: как только радиус становиться больше чем x^2+y^2 то Если x*y>0, то если радиус-четный, то ответ white, иначе ответ black Если x*y<0, то если радиус-нечетный, то ответ white, иначе ответ black Этой задачей я заработал себе первые 484 баллаЗадача B(Перекрашивания):  Если x>5000, то ответ 0. Решал перебором, то есть задал координаты углов куска поля, который еще будет закрашиваться. изначально x1=1; y1=1; x2=n; y2=m;  x1,y1- верхние левые, x2,y2- нижние правые. От 1 до x  увеличивал x1 и y1, уменьшал x2,y2; Потом перебирал значения i от x1 до x2 и j от y1 до y2 и смотрел, если i mod 2=j mod 2 значит        увеличивал ответ. Сдал эту задачу со второй попытки, получил по ней 822 балла.По задачам С, D, E у меня идей не было =(Взломы : Я сделал по задаче A-успешный взлом и 2 взлома по B, но в то же время сделал 6 неудачных взлома     по задаче B =), в общем по взломам я получил 0 баллов.Итог: Контест для меня прошел удачно, я выполнил свою цель: стать желтым =)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/829",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1082
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #39 - Codeforces - Code 1",
          "code": "94925 5648 96389 1799",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/820",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #39 - Codeforces - Code 2",
          "code": "Answer: 1426155172",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/820",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n    int x = inf.readInt(1, 1000000000, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", rnd.next(1, 5000));\n    int m = opt<int>(\"m\", rnd.next(1, 5000));\n    int x = opt<int>(\"x\", rnd.next(1, 1000000000));\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"max\") {\n        n = 5000;\n        m = 5000;\n        x = 1;\n    } else if (type == \"min\") {\n        n = 1;\n        m = 1;\n        x = 1;\n    } else if (type == \"line_n\") {\n        n = 5000;\n        m = 1;\n        x = rnd.next(1, 1000000000);\n    } else if (type == \"line_m\") {\n        n = 1;\n        m = 5000;\n        x = rnd.next(1, 1000000000);\n    } else if (type == \"large_x\") {\n        x = 1000000000;\n    } else if (type == \"small_x\") {\n        x = 1;\n    } else if (type == \"edge\") {\n        n = rnd.next(1, 5);\n        m = rnd.next(1, 5);\n        x = rnd.next(1, 10);\n    }\n\n    // Ensure that n and m are within constraints\n    n = min(max(n, 1), 5000);\n    m = min(max(m, 1), 5000);\n    x = min(max(x, 1), 1000000000);\n\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%d\\n\", x);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", rnd.next(1, 5000));\n    int m = opt<int>(\"m\", rnd.next(1, 5000));\n    int x = opt<int>(\"x\", rnd.next(1, 1000000000));\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"max\") {\n        n = 5000;\n        m = 5000;\n        x = 1;\n    } else if (type == \"min\") {\n        n = 1;\n        m = 1;\n        x = 1;\n    } else if (type == \"line_n\") {\n        n = 5000;\n        m = 1;\n        x = rnd.next(1, 1000000000);\n    } else if (type == \"line_m\") {\n        n = 1;\n        m = 5000;\n        x = rnd.next(1, 1000000000);\n    } else if (type == \"large_x\") {\n        x = 1000000000;\n    } else if (type == \"small_x\") {\n        x = 1;\n    } else if (type == \"edge\") {\n        n = rnd.next(1, 5);\n        m = rnd.next(1, 5);\n        x = rnd.next(1, 10);\n    }\n\n    // Ensure that n and m are within constraints\n    n = min(max(n, 1), 5000);\n    m = min(max(m, 1), 5000);\n    x = min(max(x, 1), 1000000000);\n\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%d\\n\", x);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small grid, x = 1\n./gen -n 1 -m 1 -x 1 -type min\n\n# Small grid, x = 2\n./gen -n 1 -m 1 -x 2 -type edge\n\n# Small grid, n = 2, m = 3\n./gen -n 2 -m 3 -x 1 -type edge\n\n# Small square grid, n = m = 5\n./gen -n 5 -m 5 -x 3\n\n# Small rectangular grid, n = 4, m = 6\n./gen -n 4 -m 6 -x 2\n\n# Line grid, n = 5000, m = 1\n./gen -n 5000 -m 1 -x 1 -type line_n\n\n# Line grid, n = 1, m = 5000\n./gen -n 1 -m 5000 -x 1 -type line_m\n\n# Large grid, n = m = 5000, x = 1\n./gen -n 5000 -m 5000 -x 1 -type max\n\n# Large grid, n = m = 5000, x = 2\n./gen -n 5000 -m 5000 -x 2\n\n# Large grid, random x\n./gen -n 5000 -m 5000 -x 1000000000 -type large_x\n\n# Random grid, large n, m\n./gen -n 4000 -m 4500 -x 1\n\n# Random grid, small n, m\n./gen -n 100 -m 200 -x 3\n\n# Random grid, n and m random, x random\n./gen\n\n# Square grid, n = m = 1000, x = 1\n./gen -n 1000 -m 1000 -x 1\n\n# Rectangular grid, n = 3000, m = 2000, x = 2\n./gen -n 3000 -m 2000 -x 2\n\n# x = maximum allowed value (1e9)\n./gen -n 500 -m 500 -x 1000000000 -type large_x\n\n# n = 4999, m = 5000, x random\n./gen -n 4999 -m 5000\n\n# n = 5000, m = 1, x = 1e9\n./gen -n 5000 -m 1 -x 1000000000 -type large_x\n\n# n and m both even\n./gen -n 1000 -m 2000 -x 1\n\n# n and m both odd\n./gen -n 1999 -m 1999 -x 1\n\n# n odd, m even\n./gen -n 1999 -m 2000 -x 1\n\n# n even, m odd\n./gen -n 2000 -m 1999 -x 1\n\n# Small grid with x = 1e9\n./gen -n 2 -m 2 -x 1000000000 -type large_x\n\n# Small grid with x = 1\n./gen -n 2 -m 2 -x 1\n\n# Minimum grid size, maximum x\n./gen -n 1 -m 1 -x 1000000000 -type large_x\n\n# Random grid with random x\n./gen\n\n# Large grid with random x\n./gen -n 5000 -m 5000 -x 500000000\n\n# Small grid with large x\n./gen -n 2 -m 2 -x 1000000000 -type large_x\n\n# Small grid with x = 1\n./gen -n 2 -m 2 -x 1\n\n# Square grid, x = 2\n./gen -n 3 -m 3 -x 2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:10.515048",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "40/C",
      "title": "Problem 40/C",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readSpace();\n    int x = inf.readInt(-100000, 100000, \"x\");\n    inf.readSpace();\n    int M = inf.readInt(1, 100000, \"M\");\n    inf.readSpace();\n    int y = inf.readInt(-100000, 100000, \"y\");\n    inf.readEoln();\n\n    ensuref(x != y, \"x and y must be different (x = %d, y = %d)\", x, y);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readSpace();\n    int x = inf.readInt(-100000, 100000, \"x\");\n    inf.readSpace();\n    int M = inf.readInt(1, 100000, \"M\");\n    inf.readSpace();\n    int y = inf.readInt(-100000, 100000, \"y\");\n    inf.readEoln();\n\n    ensuref(x != y, \"x and y must be different (x = %d, y = %d)\", x, y);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 100000, \"N\");\n    inf.readSpace();\n    int x = inf.readInt(-100000, 100000, \"x\");\n    inf.readSpace();\n    int M = inf.readInt(1, 100000, \"M\");\n    inf.readSpace();\n    int y = inf.readInt(-100000, 100000, \"y\");\n    inf.readEoln();\n\n    ensuref(x != y, \"x and y must be different (x = %d, y = %d)\", x, y);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int NMAX = 100000;\nconst int COORMAX = 100000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read optional parameters or set default values\n    int N = opt<int>(\"N\", -1);\n    int M = opt<int>(\"M\", -1);\n    int x = opt<int>(\"x\", COORMAX + 1);\n    int y = opt<int>(\"y\", COORMAX + 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate test cases based on type\n    if (type == \"random\") {\n        if (N == -1) N = rnd.next(1, NMAX);\n        if (M == -1) M = rnd.next(1, NMAX);\n        if (x == COORMAX + 1) x = rnd.next(-COORMAX, COORMAX);\n        if (y == COORMAX + 1) y = rnd.next(-COORMAX, COORMAX);\n        if (x == y) {\n            y = (x < COORMAX) ? x + 1 : x - 1;\n        }\n    } else if (type == \"max_n_m\") {\n        N = NMAX;\n        M = NMAX;\n        if (x == COORMAX + 1) x = rnd.next(-COORMAX, COORMAX);\n        if (y == COORMAX + 1) y = rnd.next(-COORMAX, COORMAX);\n        if (x == y) {\n            y = (x < COORMAX) ? x + 1 : x - 1;\n        }\n    } else if (type == \"max_coords\") {\n        if (N == -1) N = rnd.next(1, NMAX);\n        if (M == -1) M = rnd.next(1, NMAX);\n        x = COORMAX;\n        y = -COORMAX;\n    } else if (type == \"same_n_m\") {\n        N = M = (N == -1) ? rnd.next(1, NMAX) : N;\n        if (x == COORMAX + 1) x = rnd.next(-COORMAX, COORMAX);\n        if (y == COORMAX + 1) y = rnd.next(-COORMAX, COORMAX);\n        if (x == y) {\n            y = (x < COORMAX) ? x + 1 : x - 1;\n        }\n    } else if (type == \"close_coords\") {\n        if (N == -1) N = rnd.next(1, NMAX);\n        if (M == -1) M = rnd.next(1, NMAX);\n        x = rnd.next(-COORMAX, COORMAX - 1);\n        y = x + 1;\n    } else if (type == \"zero_coords\") {\n        if (N == -1) N = rnd.next(1, NMAX);\n        if (M == -1) M = rnd.next(1, NMAX);\n        x = 0;\n        if (y == COORMAX + 1) y = rnd.next(-COORMAX, COORMAX);\n        if (x == y) {\n            y = (x < COORMAX) ? x + 1 : x - 1;\n        }\n    } else if (type == \"negative_coords\") {\n        if (N == -1) N = rnd.next(1, NMAX);\n        if (M == -1) M = rnd.next(1, NMAX);\n        x = rnd.next(-COORMAX, -1);\n        y = rnd.next(-COORMAX, -1);\n        if (x == y) {\n            y = (x < -1) ? x + 1 : x - 1;\n        }\n    } else if (type == \"small_N_M\") {\n        N = rnd.next(1, 10);\n        M = rnd.next(1, 10);\n        if (x == COORMAX + 1) x = rnd.next(-COORMAX, COORMAX);\n        if (y == COORMAX + 1) y = rnd.next(-COORMAX, COORMAX);\n        if (x == y) {\n            y = (x < COORMAX) ? x + 1 : x - 1;\n        }\n    } else if (type == \"one_circle\") {\n        N = M = 1;\n        if (x == COORMAX + 1) x = rnd.next(-COORMAX, COORMAX);\n        if (y == COORMAX + 1) y = rnd.next(-COORMAX, COORMAX);\n        if (x == y) {\n            y = (x < COORMAX) ? x + 1 : x - 1;\n        }\n    } else {\n        // Default to random if unknown type\n        if (N == -1) N = rnd.next(1, NMAX);\n        if (M == -1) M = rnd.next(1, NMAX);\n        if (x == COORMAX + 1) x = rnd.next(-COORMAX, COORMAX);\n        if (y == COORMAX + 1) y = rnd.next(-COORMAX, COORMAX);\n        if (x == y) {\n            y = (x < COORMAX) ? x + 1 : x - 1;\n        }\n    }\n\n    // Ensure x and y are within bounds\n    ensure(1 <= N && N <= NMAX);\n    ensure(1 <= M && M <= NMAX);\n    ensure(-COORMAX <= x && x <= COORMAX);\n    ensure(-COORMAX <= y && y <= COORMAX);\n    ensure(x != y);\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", N, x, M, y);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int NMAX = 100000;\nconst int COORMAX = 100000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read optional parameters or set default values\n    int N = opt<int>(\"N\", -1);\n    int M = opt<int>(\"M\", -1);\n    int x = opt<int>(\"x\", COORMAX + 1);\n    int y = opt<int>(\"y\", COORMAX + 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate test cases based on type\n    if (type == \"random\") {\n        if (N == -1) N = rnd.next(1, NMAX);\n        if (M == -1) M = rnd.next(1, NMAX);\n        if (x == COORMAX + 1) x = rnd.next(-COORMAX, COORMAX);\n        if (y == COORMAX + 1) y = rnd.next(-COORMAX, COORMAX);\n        if (x == y) {\n            y = (x < COORMAX) ? x + 1 : x - 1;\n        }\n    } else if (type == \"max_n_m\") {\n        N = NMAX;\n        M = NMAX;\n        if (x == COORMAX + 1) x = rnd.next(-COORMAX, COORMAX);\n        if (y == COORMAX + 1) y = rnd.next(-COORMAX, COORMAX);\n        if (x == y) {\n            y = (x < COORMAX) ? x + 1 : x - 1;\n        }\n    } else if (type == \"max_coords\") {\n        if (N == -1) N = rnd.next(1, NMAX);\n        if (M == -1) M = rnd.next(1, NMAX);\n        x = COORMAX;\n        y = -COORMAX;\n    } else if (type == \"same_n_m\") {\n        N = M = (N == -1) ? rnd.next(1, NMAX) : N;\n        if (x == COORMAX + 1) x = rnd.next(-COORMAX, COORMAX);\n        if (y == COORMAX + 1) y = rnd.next(-COORMAX, COORMAX);\n        if (x == y) {\n            y = (x < COORMAX) ? x + 1 : x - 1;\n        }\n    } else if (type == \"close_coords\") {\n        if (N == -1) N = rnd.next(1, NMAX);\n        if (M == -1) M = rnd.next(1, NMAX);\n        x = rnd.next(-COORMAX, COORMAX - 1);\n        y = x + 1;\n    } else if (type == \"zero_coords\") {\n        if (N == -1) N = rnd.next(1, NMAX);\n        if (M == -1) M = rnd.next(1, NMAX);\n        x = 0;\n        if (y == COORMAX + 1) y = rnd.next(-COORMAX, COORMAX);\n        if (x == y) {\n            y = (x < COORMAX) ? x + 1 : x - 1;\n        }\n    } else if (type == \"negative_coords\") {\n        if (N == -1) N = rnd.next(1, NMAX);\n        if (M == -1) M = rnd.next(1, NMAX);\n        x = rnd.next(-COORMAX, -1);\n        y = rnd.next(-COORMAX, -1);\n        if (x == y) {\n            y = (x < -1) ? x + 1 : x - 1;\n        }\n    } else if (type == \"small_N_M\") {\n        N = rnd.next(1, 10);\n        M = rnd.next(1, 10);\n        if (x == COORMAX + 1) x = rnd.next(-COORMAX, COORMAX);\n        if (y == COORMAX + 1) y = rnd.next(-COORMAX, COORMAX);\n        if (x == y) {\n            y = (x < COORMAX) ? x + 1 : x - 1;\n        }\n    } else if (type == \"one_circle\") {\n        N = M = 1;\n        if (x == COORMAX + 1) x = rnd.next(-COORMAX, COORMAX);\n        if (y == COORMAX + 1) y = rnd.next(-COORMAX, COORMAX);\n        if (x == y) {\n            y = (x < COORMAX) ? x + 1 : x - 1;\n        }\n    } else {\n        // Default to random if unknown type\n        if (N == -1) N = rnd.next(1, NMAX);\n        if (M == -1) M = rnd.next(1, NMAX);\n        if (x == COORMAX + 1) x = rnd.next(-COORMAX, COORMAX);\n        if (y == COORMAX + 1) y = rnd.next(-COORMAX, COORMAX);\n        if (x == y) {\n            y = (x < COORMAX) ? x + 1 : x - 1;\n        }\n    }\n\n    // Ensure x and y are within bounds\n    ensure(1 <= N && N <= NMAX);\n    ensure(1 <= M && M <= NMAX);\n    ensure(-COORMAX <= x && x <= COORMAX);\n    ensure(-COORMAX <= y && y <= COORMAX);\n    ensure(x != y);\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", N, x, M, y);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases\n./gen\n./gen\n./gen\n./gen\n./gen\n\n# Test cases with maximum N and M\n./gen -type max_n_m\n./gen -type max_n_m\n\n# Test cases with maximum coordinates\n./gen -type max_coords\n./gen -type max_coords\n\n# Test cases with same N and M\n./gen -type same_n_m\n./gen -type same_n_m\n\n# Test cases with coordinates close together\n./gen -type close_coords\n./gen -type close_coords\n\n# Test cases with zero coordinates\n./gen -type zero_coords\n./gen -type zero_coords\n\n# Test cases with negative coordinates\n./gen -type negative_coords\n./gen -type negative_coords\n\n# Test cases with small N and M\n./gen -type small_N_M\n./gen -type small_N_M\n\n# Test cases where N and M are 1\n./gen -type one_circle\n./gen -type one_circle\n\n# Specific test cases with extreme N, M, x, y values\n./gen -N 100000 -M 100000 -x -100000 -y 100000\n./gen -N 100000 -M 100000 -x 100000 -y -100000\n\n# Test cases with one maximum and one minimum N or M\n./gen -N 1 -M 100000 -x -99999 -y 100000\n./gen -N 100000 -M 1 -x -100000 -y -99999\n\n# Test cases with one circle in one set and maximum in the other\n./gen -N 1 -M 100000 -x 0 -y 1\n./gen -N 100000 -M 1 -x 1 -y 0\n\n# Test cases with N and M at maximum, x and y close together\n./gen -N 100000 -M 100000 -x 0 -y 1\n./gen -N 100000 -M 100000 -x -1 -y 0\n\n# Edge cases where N = M = 1 and x, y are adjacent\n./gen -N 1 -M 1 -x -100000 -y -99999\n./gen -N 1 -M 1 -x 99999 -y 100000\n\n# Random test cases with small N and M\n./gen -N 2 -M 2\n./gen -N 3 -M 4 -x 5 -y -5\n\n# Random test cases with negative x and y\n./gen -x -5000 -y -4000\n./gen -N 50000 -M 50000 -x -100000 -y -99999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:12.582217",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "40/D",
      "title": "D. Интересная последовательность",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записано целое число A (1 ≤ A < 10300). Гарантируется, что число не содержит лидирующих нулей.",
      "output_spec": "Выходные данныеВ первую строку выходного файлы выведите YES, если мог быть год, в который количество жителей в стране стало ровно A, иначе выведите NO. Если ответ YES, то далее необходимо вывести число k — количество годов, в которых население могло быть ровно A. В следующей строке нужно вывести через пробел ровно k чисел — a1, a2, ..., ak. Эти числа должны быть выведены в порядке возрастания. В следующей строке нужно вывести число p — сколько вариантов количества жителей могло быть в годы a1, a2, ..., ak, не считая вариант A. В следующих p строках нужно вывести по одному числу в каждой — искомое количество жителей. Эти числа тоже должны идти в порядке возрастания. Если какое-то из чисел (или оба) k или p превосходит 1000, то нужно выводить вместо него 1000 и лишь первые 1000 возможных вариантов ответа по возрастанию.Числа не должны содержать лидирующие нули.",
      "sample_tests": "ПримерыВходные данныеСкопировать2Выходные данныеСкопироватьYES110Входные данныеСкопировать3Выходные данныеСкопироватьNOВходные данныеСкопировать13Выходные данныеСкопироватьYES120Входные данныеСкопировать1729Выходные данныеСкопироватьYES141156",
      "description": "D. Интересная последовательность\n\nограничение по времени на тест3 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число A (1 ≤ A < 10300). Гарантируется, что число не содержит лидирующих нулей.\n\nВходные данные\n\nВыходные данныеВ первую строку выходного файлы выведите YES, если мог быть год, в который количество жителей в стране стало ровно A, иначе выведите NO. Если ответ YES, то далее необходимо вывести число k — количество годов, в которых население могло быть ровно A. В следующей строке нужно вывести через пробел ровно k чисел — a1, a2, ..., ak. Эти числа должны быть выведены в порядке возрастания. В следующей строке нужно вывести число p — сколько вариантов количества жителей могло быть в годы a1, a2, ..., ak, не считая вариант A. В следующих p строках нужно вывести по одному числу в каждой — искомое количество жителей. Эти числа тоже должны идти в порядке возрастания. Если какое-то из чисел (или оба) k или p превосходит 1000, то нужно выводить вместо него 1000 и лишь первые 1000 возможных вариантов ответа по возрастанию.Числа не должны содержать лидирующие нули.\n\nВыходные данные\n\nВходные данныеСкопировать2Выходные данныеСкопироватьYES110Входные данныеСкопировать3Выходные данныеСкопироватьNOВходные данныеСкопировать13Выходные данныеСкопироватьYES120Входные данныеСкопировать1729Выходные данныеСкопироватьYES141156\n\nВходные данныеСкопировать2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES110\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать13\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES120\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1729\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES141156\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #39 - Codeforces",
          "content": "Приглашаю всех принять участие в очередном раунде на Codeforces!В этот раз авторами задач будем я и sdya. Немного о нас: мы учимся на втором курсе механико-математического факультета Харьковского национального университета им. В. Н. Каразина. И для тех, кто не знает - мы братья-близнецы. Программированием начали заниматься в конце 10 класса, то есть примерно 2,5 года назад. Никаких масштабных достижений в программировании у нас пока нет, но мы надеемся, что все еще впереди :)Хочется сказать спасибо Артему Рахову, который помогал нам готовить этот контест, и Марие Беловой, которая перевела условия задач на английский язык. Желаем всем удачи в предстоящем раунде, надеемся, что задачи покажутся Вам интересными!UPD: Контест завершен, поздравляeм Геннадия Короткевича, который стал победителем этого раунда. Ссылка на результаты и на разбор задач.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/820",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 852
        },
        {
          "title": "Codeforces Beta Round #39 (Разбор задач) - Codeforces",
          "content": "Задача A. Определите цветЗдесь все понятно. Достаточно рассмотреть несколько случаев. Первый — когда расстояние от точки до начала координат — целое число, тогда ответ black. В противном случае, пусть d - это расстояние от нашей точки до начала координат. Тогда будем работать с [d]. Теперь осталось два случая: 1) если наша точка лежит в 1-ой, или 3-ей четверти; 2) точка лежит во 2-ой, либо 4-ой четверти. В случае 1) имеем, если [d] нечетно, то ответ white, иначе black; в случае 2) если [d] четно, то ответ white, иначе black. Подразумевается, что [d] — целая часть d.Задача B. ПерекрашиванияПервое, что надо заметить, так это то, что на i-ом шаге все перекрашенные клетки будут лежать в прямоугольнике с вершинами в клетках (i,i), (n-i,m-i) (если считать, что (1,1) - левая верхняя клетка, а (n,m) — правая нижняя). Тогда отсюда уже следует решение: нужно подсчитать количество клеток такого типа, что минимальное расстояние до стороны в точности равняется x. То есть для клетки (a,b) должно выполняться min(min(a, b), min(n - a + 1, m - b + 1)) = x.Задача C. Берляндская площадьИдейно эта задача не очень сложная, но было много хитрых случаев. Авторское решение предполагало следующую идею. Сначала заметим, что наше множество окружностей на плоскости может быть несвязным. Тут есть два случая, когда есть хотя бы одна точка пересечения окружностей и когда нет ни одной. Если их нет, то ответ N+M+1. Иначе, если есть хотя бы одна точка пересечения, то мы можем удалить некоторые окружности таким образом, чтобы оставшаяся фигура из окружностей была связной. Тогда для этой фигуры можно применить формулу Эйлера. Таким образом, нам здесь нужно посчитать количество точек пересечения и количество дуг-ребер. Нетрудно видеть, что каждая точка пересечения добавляет две дуги. Таким образом, мы можем найти количество частей, на которые разделилась плоскость без удаленных окружностей. Теперь достаточно заметить, что каждая удаленная окружность добавляет ровно 1 к ответу. Весь вопрос в том, чтобы посчитать, сколько точек пересечения. Это можно сделать за O(N+M), если считать для каждой окружности, точки пересечения, которые принадлежат ей. Для этого достаточно заметить, что все окружности, с которыми наша окружность пересекается будут иметь радиусы l, l+1, ..., r. Также, с некоторыми из этих окружностей наша окружность будет иметь не две точки пересечения а одну. Это необходимо учесть в решении. После этого остается лишь аккуратно реализовать эту идею. Задача D. Интересная последовательностьЗдесь нужно было погенерировать разные последовательности, которые могут получаться и внимательно смотреть на полученные значения. Основное наблюдение, это то, что каждое из чисел, которые встречаются в последовательности имеет вид 12k + 12m, при этом это число может встречаться лишь на позиции (k + m + 1). Теперь, когда известен общий вид, можно по методу математической индукции доказать, что на x-ой позиции могут встречаться все числа вида 12k + 12m, такие что, k + m + 1 = x. После этого можно было реализовать простое в написании решение за O(N3), где N — длина входного числа. Для этого перебираем все x от 1 до 600 и проверяем, существуют ли такие k и m, что k + m + 1 = x и 12k + 12m = A. Но также есть и решение со сложностью O(N2).Задача E. Таблица из чиселПервое, что должно было броситься в глаза, это то, что клеток, изначально не пустых — совсем мало. Из ограничений следует, что всегда есть пустая строка либо пустой столбец. Без ограничений общности можем считать, что у нас есть пустая строка и она последняя. Тогда выберем какой-либо столбец (к примеру, последний) и зафиксируем его одновременно с пустой строкой. Тогда по оставшейся таблице размера (n - 1) × (m - 1) клетки в последнем столбце и в последней строке заполняются однозначно. Но есть одно замечание, в последнем столбце уже стоят какие-то числа. Тогда нам надо для каждой строки, кроме последней подсчитать, сколько существует вариантов этой строки, таких, что произведение чисел в этой строке равно -1. В авторском решении, эта часть считалась при помощи динамического программирования. После этого нужно перемножить полученные ответы для каждой строки. Тогда ответ на задачу — это полученное произведение, либо 0 — если сумма n + m нечетна. Разбор задач был подготовлен мной и sdya.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/835",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4273
        },
        {
          "title": "codeforces #39 - Codeforces",
          "content": "Задача A(Определите цвет):  Сразу очевидно, что если sqrt(x^2+y^2)-целое то ответ black, иначе перебираем радиус: как только радиус становиться больше чем x^2+y^2 то Если x*y>0, то если радиус-четный, то ответ white, иначе ответ black Если x*y<0, то если радиус-нечетный, то ответ white, иначе ответ black Этой задачей я заработал себе первые 484 баллаЗадача B(Перекрашивания):  Если x>5000, то ответ 0. Решал перебором, то есть задал координаты углов куска поля, который еще будет закрашиваться. изначально x1=1; y1=1; x2=n; y2=m;  x1,y1- верхние левые, x2,y2- нижние правые. От 1 до x  увеличивал x1 и y1, уменьшал x2,y2; Потом перебирал значения i от x1 до x2 и j от y1 до y2 и смотрел, если i mod 2=j mod 2 значит        увеличивал ответ. Сдал эту задачу со второй попытки, получил по ней 822 балла.По задачам С, D, E у меня идей не было =(Взломы : Я сделал по задаче A-успешный взлом и 2 взлома по B, но в то же время сделал 6 неудачных взлома     по задаче B =), в общем по взломам я получил 0 баллов.Итог: Контест для меня прошел удачно, я выполнил свою цель: стать желтым =)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/829",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1082
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #39 - Codeforces - Code 1",
          "code": "94925 5648 96389 1799",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/820",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #39 - Codeforces - Code 2",
          "code": "Answer: 1426155172",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/820",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #39 - Codeforces - Code 3",
          "code": "97448 7948 91572 7786",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/820",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Beta Round #39 - Codeforces - Code 4",
          "code": "Ответ: 59292207",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/820",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string A = inf.readToken(\"[1-9][0-9]{0,299}\", \"A\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string A = inf.readToken(\"[1-9][0-9]{0,299}\", \"A\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string A = inf.readToken(\"[1-9][0-9]{0,299}\", \"A\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring multiply_strings(const string& num1, const string& num2) {\n    int n = num1.size(), m = num2.size();\n    vector<int> result(n + m, 0);\n    for(int i = n - 1; i >= 0; i--) {\n        for(int j = m -1; j >=0; j--) {\n            int mul = (num1[i] -'0') * (num2[j] -'0') + result[i + j + 1];\n            result[i + j +1] = mul % 10;\n            result[i + j] += mul /10;\n        }\n    }\n    string res_str;\n    for(int num : result) {\n        if(!(res_str.empty() && num == 0))\n            res_str.push_back(num + '0');\n    }\n    if(res_str.empty())\n        res_str = \"0\";\n    return res_str;\n}\n\nstring power_string(const string& base, int exponent) {\n    string result = \"1\";\n    string base_copy = base;\n    while (exponent > 0) {\n        if (exponent % 2 == 1) {\n            result = multiply_strings(result, base_copy);\n        }\n        base_copy = multiply_strings(base_copy, base_copy);\n        exponent /= 2;\n    }\n    return result;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\", 4);\n    string type = opt<string>(\"type\", \"from_d_n\");\n    int max_n = 277; // ensure A has at most 300 digits\n    string A;\n\n    if (type == \"from_d_n\") {\n        if (n < 1) n = 1;\n        if (n > max_n) n = max_n;\n        // Compute A = 12^{n-1} + 1\n        int exponent = n - 1;\n        string base = \"12\";\n        string s = power_string(base, exponent);\n        // Now s = 12^{n-1}\n        // A = s + 1\n        // Increment s by 1\n        int carry = 1;\n        for (int i = s.size() - 1; i >= 0 && carry > 0; --i) {\n            int digit = s[i] - '0' + carry;\n            s[i] = (digit % 10) + '0';\n            carry = digit / 10;\n        }\n        if (carry > 0) {\n            s = '1' + s;\n        }\n        if (s.size() > 300) {\n            // Truncate s to 300 digits\n            s = s.substr(0, 300);\n        }\n        A = s;\n    } else if (type == \"no_answer\") {\n        // Set A to a number that is likely not in the sequence\n        A = \"3\"; // e.g., 3\n    } else if (type == \"random\") {\n        int length = opt<int>(\"length\", 50);\n        if (length > 300) length = 300;\n        if (length < 1) length = 1;\n        stringstream ss;\n        ss << rnd.next(1, 9);\n        for(int i = 1; i < length; ++i) {\n            ss << rnd.next(0, 9);\n        }\n        A = ss.str();\n    }\n    printf(\"%s\\n\", A.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring multiply_strings(const string& num1, const string& num2) {\n    int n = num1.size(), m = num2.size();\n    vector<int> result(n + m, 0);\n    for(int i = n - 1; i >= 0; i--) {\n        for(int j = m -1; j >=0; j--) {\n            int mul = (num1[i] -'0') * (num2[j] -'0') + result[i + j + 1];\n            result[i + j +1] = mul % 10;\n            result[i + j] += mul /10;\n        }\n    }\n    string res_str;\n    for(int num : result) {\n        if(!(res_str.empty() && num == 0))\n            res_str.push_back(num + '0');\n    }\n    if(res_str.empty())\n        res_str = \"0\";\n    return res_str;\n}\n\nstring power_string(const string& base, int exponent) {\n    string result = \"1\";\n    string base_copy = base;\n    while (exponent > 0) {\n        if (exponent % 2 == 1) {\n            result = multiply_strings(result, base_copy);\n        }\n        base_copy = multiply_strings(base_copy, base_copy);\n        exponent /= 2;\n    }\n    return result;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\", 4);\n    string type = opt<string>(\"type\", \"from_d_n\");\n    int max_n = 277; // ensure A has at most 300 digits\n    string A;\n\n    if (type == \"from_d_n\") {\n        if (n < 1) n = 1;\n        if (n > max_n) n = max_n;\n        // Compute A = 12^{n-1} + 1\n        int exponent = n - 1;\n        string base = \"12\";\n        string s = power_string(base, exponent);\n        // Now s = 12^{n-1}\n        // A = s + 1\n        // Increment s by 1\n        int carry = 1;\n        for (int i = s.size() - 1; i >= 0 && carry > 0; --i) {\n            int digit = s[i] - '0' + carry;\n            s[i] = (digit % 10) + '0';\n            carry = digit / 10;\n        }\n        if (carry > 0) {\n            s = '1' + s;\n        }\n        if (s.size() > 300) {\n            // Truncate s to 300 digits\n            s = s.substr(0, 300);\n        }\n        A = s;\n    } else if (type == \"no_answer\") {\n        // Set A to a number that is likely not in the sequence\n        A = \"3\"; // e.g., 3\n    } else if (type == \"random\") {\n        int length = opt<int>(\"length\", 50);\n        if (length > 300) length = 300;\n        if (length < 1) length = 1;\n        stringstream ss;\n        ss << rnd.next(1, 9);\n        for(int i = 1; i < length; ++i) {\n            ss << rnd.next(0, 9);\n        }\n        A = ss.str();\n    }\n    printf(\"%s\\n\", A.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type from_d_n\n./gen -n 2 -type from_d_n\n./gen -n 3 -type from_d_n\n./gen -n 4 -type from_d_n\n./gen -n 5 -type from_d_n\n./gen -n 10 -type from_d_n\n./gen -n 20 -type from_d_n\n./gen -n 50 -type from_d_n\n./gen -n 100 -type from_d_n\n./gen -n 200 -type from_d_n\n./gen -n 277 -type from_d_n\n./gen -n 278 -type from_d_n\n\n./gen -type no_answer\n./gen -type no_answer\n./gen -type no_answer\n\n./gen -type random -length 1\n./gen -type random -length 10\n./gen -type random -length 50\n./gen -type random -length 100\n./gen -type random -length 200\n./gen -type random -length 300\n./gen -type random -length 301\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:14.664256",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "40/E",
      "title": "E. Number Table",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test216 megabytes",
      "input_spec": "InputThe first line contains integers n and m (1 ≤ n, m ≤ 1000). The second line contains the integer k (0 ≤ k < max(n, m)) — the number of cells in which the data had been preserved. The next k lines contain the data on the state of the table in the preserved cells. Each line is of the form \"a b c\", where a (1 ≤ a ≤ n) — the number of the table row, b (1 ≤ b ≤ m) — the number of the column, c — the value containing in the cell (1 or -1). They are numbered starting from 1. It is guaranteed that no two lines with same a and b values exist. The last line contains an integer p (2 ≤ p ≤ 109 + 7).",
      "output_spec": "OutputPrint the number of different tables that could conform to the preserved data modulo p.",
      "sample_tests": "ExamplesInputCopy2 20100OutputCopy2InputCopy2 211 1 -1100OutputCopy1",
      "description": "E. Number Table\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test216 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n and m (1 ≤ n, m ≤ 1000). The second line contains the integer k (0 ≤ k < max(n, m)) — the number of cells in which the data had been preserved. The next k lines contain the data on the state of the table in the preserved cells. Each line is of the form \"a b c\", where a (1 ≤ a ≤ n) — the number of the table row, b (1 ≤ b ≤ m) — the number of the column, c — the value containing in the cell (1 or -1). They are numbered starting from 1. It is guaranteed that no two lines with same a and b values exist. The last line contains an integer p (2 ≤ p ≤ 109 + 7).\n\nOutputPrint the number of different tables that could conform to the preserved data modulo p.\n\nInputCopy2 20100OutputCopy2InputCopy2 211 1 -1100OutputCopy1\n\nInputCopy2 20100\n\nOutputCopy2\n\nInputCopy2 211 1 -1100\n\nOutputCopy1",
      "solutions": [
        {
          "title": "Codeforces Beta Round #39 - Codeforces",
          "content": "I invite you all to take part in the next Codeforces Round!This time the problems are written by me and sdya. Some information about us: we both are second year students of The Faculty of Mechanics and Mathematics of Kharkiv National University named after V.N. Karazin, and we are twin brothers. We began studying programming in the 10th form, about 2.5 years ago. We do not have any significant achievements in programming competitions yet, but we hope we still have time to get some :)We would like to express our gratitude to Artem Rakhov who helped us to arrange this contest, and to Maria Belova who has translated the problems statements into English.We wish good luck to everyone and hope you will find the problems interesting!UPD: The contest is over, congratulate tourist, who won this round.Link to results.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/820",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 819
        },
        {
          "title": "Codeforces Beta Round #39 (Разбор задач) - Codeforces",
          "content": "Задача A. Определите цветЗдесь все понятно. Достаточно рассмотреть несколько случаев. Первый — когда расстояние от точки до начала координат — целое число, тогда ответ black. В противном случае, пусть d - это расстояние от нашей точки до начала координат. Тогда будем работать с [d]. Теперь осталось два случая: 1) если наша точка лежит в 1-ой, или 3-ей четверти; 2) точка лежит во 2-ой, либо 4-ой четверти. В случае 1) имеем, если [d] нечетно, то ответ white, иначе black; в случае 2) если [d] четно, то ответ white, иначе black. Подразумевается, что [d] — целая часть d.Задача B. ПерекрашиванияПервое, что надо заметить, так это то, что на i-ом шаге все перекрашенные клетки будут лежать в прямоугольнике с вершинами в клетках (i,i), (n-i,m-i) (если считать, что (1,1) - левая верхняя клетка, а (n,m) — правая нижняя). Тогда отсюда уже следует решение: нужно подсчитать количество клеток такого типа, что минимальное расстояние до стороны в точности равняется x. То есть для клетки (a,b) должно выполняться min(min(a, b), min(n - a + 1, m - b + 1)) = x.Задача C. Берляндская площадьИдейно эта задача не очень сложная, но было много хитрых случаев. Авторское решение предполагало следующую идею. Сначала заметим, что наше множество окружностей на плоскости может быть несвязным. Тут есть два случая, когда есть хотя бы одна точка пересечения окружностей и когда нет ни одной. Если их нет, то ответ N+M+1. Иначе, если есть хотя бы одна точка пересечения, то мы можем удалить некоторые окружности таким образом, чтобы оставшаяся фигура из окружностей была связной. Тогда для этой фигуры можно применить формулу Эйлера. Таким образом, нам здесь нужно посчитать количество точек пересечения и количество дуг-ребер. Нетрудно видеть, что каждая точка пересечения добавляет две дуги. Таким образом, мы можем найти количество частей, на которые разделилась плоскость без удаленных окружностей. Теперь достаточно заметить, что каждая удаленная окружность добавляет ровно 1 к ответу. Весь вопрос в том, чтобы посчитать, сколько точек пересечения. Это можно сделать за O(N+M), если считать для каждой окружности, точки пересечения, которые принадлежат ей. Для этого достаточно заметить, что все окружности, с которыми наша окружность пересекается будут иметь радиусы l, l+1, ..., r. Также, с некоторыми из этих окружностей наша окружность будет иметь не две точки пересечения а одну. Это необходимо учесть в решении. После этого остается лишь аккуратно реализовать эту идею. Задача D. Интересная последовательностьЗдесь нужно было погенерировать разные последовательности, которые могут получаться и внимательно смотреть на полученные значения. Основное наблюдение, это то, что каждое из чисел, которые встречаются в последовательности имеет вид 12k + 12m, при этом это число может встречаться лишь на позиции (k + m + 1). Теперь, когда известен общий вид, можно по методу математической индукции доказать, что на x-ой позиции могут встречаться все числа вида 12k + 12m, такие что, k + m + 1 = x. После этого можно было реализовать простое в написании решение за O(N3), где N — длина входного числа. Для этого перебираем все x от 1 до 600 и проверяем, существуют ли такие k и m, что k + m + 1 = x и 12k + 12m = A. Но также есть и решение со сложностью O(N2).Задача E. Таблица из чиселПервое, что должно было броситься в глаза, это то, что клеток, изначально не пустых — совсем мало. Из ограничений следует, что всегда есть пустая строка либо пустой столбец. Без ограничений общности можем считать, что у нас есть пустая строка и она последняя. Тогда выберем какой-либо столбец (к примеру, последний) и зафиксируем его одновременно с пустой строкой. Тогда по оставшейся таблице размера (n - 1) × (m - 1) клетки в последнем столбце и в последней строке заполняются однозначно. Но есть одно замечание, в последнем столбце уже стоят какие-то числа. Тогда нам надо для каждой строки, кроме последней подсчитать, сколько существует вариантов этой строки, таких, что произведение чисел в этой строке равно -1. В авторском решении, эта часть считалась при помощи динамического программирования. После этого нужно перемножить полученные ответы для каждой строки. Тогда ответ на задачу — это полученное произведение, либо 0 — если сумма n + m нечетна. Разбор задач был подготовлен мной и sdya.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/835",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4273
        },
        {
          "title": "codeforces #39 - Codeforces",
          "content": "Задача A(Определите цвет):  Сразу очевидно, что если sqrt(x^2+y^2)-целое то ответ black, иначе перебираем радиус: как только радиус становиться больше чем x^2+y^2 то Если x*y>0, то если радиус-четный, то ответ white, иначе ответ black Если x*y<0, то если радиус-нечетный, то ответ white, иначе ответ black Этой задачей я заработал себе первые 484 баллаЗадача B(Перекрашивания):  Если x>5000, то ответ 0. Решал перебором, то есть задал координаты углов куска поля, который еще будет закрашиваться. изначально x1=1; y1=1; x2=n; y2=m;  x1,y1- верхние левые, x2,y2- нижние правые. От 1 до x  увеличивал x1 и y1, уменьшал x2,y2; Потом перебирал значения i от x1 до x2 и j от y1 до y2 и смотрел, если i mod 2=j mod 2 значит        увеличивал ответ. Сдал эту задачу со второй попытки, получил по ней 822 балла.По задачам С, D, E у меня идей не было =(Взломы : Я сделал по задаче A-успешный взлом и 2 взлома по B, но в то же время сделал 6 неудачных взлома     по задаче B =), в общем по взломам я получил 0 баллов.Итог: Контест для меня прошел удачно, я выполнил свою цель: стать желтым =)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/829",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1082
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #39 - Codeforces - Code 1",
          "code": "94925 5648 96389 1799",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/820",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #39 - Codeforces - Code 2",
          "code": "Answer: 1426155172",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/820",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    int k = inf.readInt(0, max(n, m) - 1, \"k\");\n    inf.readEoln();\n\n    set<pair<int, int>> cells;\n    for (int i = 0; i < k; ++i) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, m, \"b\");\n        inf.readSpace();\n        int c = inf.readInt(-1, 1, \"c\");\n        inf.readEoln();\n\n        ensuref(c == -1 || c == 1, \"c must be either -1 or 1 at line %d\", i + 4);\n        pair<int, int> cell = make_pair(a, b);\n        ensuref(cells.count(cell) == 0, \"Duplicate cell at (%d,%d)\", a, b);\n        cells.insert(cell);\n    }\n\n    int p = inf.readInt(2, 1000000007, \"p\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    int k = inf.readInt(0, max(n, m) - 1, \"k\");\n    inf.readEoln();\n\n    set<pair<int, int>> cells;\n    for (int i = 0; i < k; ++i) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, m, \"b\");\n        inf.readSpace();\n        int c = inf.readInt(-1, 1, \"c\");\n        inf.readEoln();\n\n        ensuref(c == -1 || c == 1, \"c must be either -1 or 1 at line %d\", i + 4);\n        pair<int, int> cell = make_pair(a, b);\n        ensuref(cells.count(cell) == 0, \"Duplicate cell at (%d,%d)\", a, b);\n        cells.insert(cell);\n    }\n\n    int p = inf.readInt(2, 1000000007, \"p\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n\n    int k = inf.readInt(0, max(n, m) - 1, \"k\");\n    inf.readEoln();\n\n    set<pair<int, int>> cells;\n    for (int i = 0; i < k; ++i) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, m, \"b\");\n        inf.readSpace();\n        int c = inf.readInt(-1, 1, \"c\");\n        inf.readEoln();\n\n        ensuref(c == -1 || c == 1, \"c must be either -1 or 1 at line %d\", i + 4);\n        pair<int, int> cell = make_pair(a, b);\n        ensuref(cells.count(cell) == 0, \"Duplicate cell at (%d,%d)\", a, b);\n        cells.insert(cell);\n    }\n\n    int p = inf.readInt(2, 1000000007, \"p\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int p = opt<int>(\"p\", 1000000007);\n\n    // Ensure n and m are within [1, 1000]\n    n = min(max(1, n), 1000);\n    m = min(max(1, m), 1000);\n\n    int max_k = max(n, m) - 1;\n    k = min(max(0, k), max_k);\n\n    set<pair<int, int>> preserved_cells;\n    vector<tuple<int, int, int>> preserved_data;\n\n    if (type == \"random\") {\n        // Generate k random preserved cells with random values\n        while ((int)preserved_cells.size() < k) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, m);\n            if (preserved_cells.count({a, b})) continue;\n            preserved_cells.insert({a, b});\n            int c = rnd.next(0, 1) ? 1 : -1;\n            preserved_data.push_back({a, b, c});\n        }\n    } else if (type == \"zerosolution\") {\n        // Create a test case with zero solutions\n        n = max(2, n);\n        m = max(2, m);\n        k = 2;\n        // Fix cells to create conflict\n        preserved_cells.insert({1, 1});\n        preserved_cells.insert({1, 2});\n        // Assign values to cause conflict\n        preserved_data.push_back({1, 1, 1});\n        preserved_data.push_back({1, 2, 1});\n    } else if (type == \"unique_solution\") {\n        // Fix variables to force unique solution\n        int total_vars = n * m;\n        int total_eqns = n + m;\n        k = total_vars - total_eqns;\n        k = max(k, 0);\n        while ((int)preserved_cells.size() < k) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, m);\n            if (preserved_cells.count({a, b})) continue;\n            preserved_cells.insert({a, b});\n            int c = rnd.next(0, 1) ? 1 : -1;\n            preserved_data.push_back({a, b, c});\n        }\n    } else if (type == \"max_solutions\") {\n        // Minimize the number of preserved cells\n        k = 0;\n    } else if (type == \"n_equals_1\") {\n        n = 1;\n        k = min(k, max(n, m) - 1);\n        while ((int)preserved_cells.size() < k) {\n            int a = 1;\n            int b = rnd.next(1, m);\n            if (preserved_cells.count({a, b})) continue;\n            preserved_cells.insert({a, b});\n            int c = rnd.next(0, 1) ? 1 : -1;\n            preserved_data.push_back({a, b, c});\n        }\n    } else if (type == \"m_equals_1\") {\n        m = 1;\n        k = min(k, max(n, m) - 1);\n        while ((int)preserved_cells.size() < k) {\n            int a = rnd.next(1, n);\n            int b = 1;\n            if (preserved_cells.count({a, b})) continue;\n            preserved_cells.insert({a, b});\n            int c = rnd.next(0, 1) ? 1 : -1;\n            preserved_data.push_back({a, b, c});\n        }\n    } else if (type == \"max_k\") {\n        k = max_k;\n        while ((int)preserved_cells.size() < k) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, m);\n            if (preserved_cells.count({a, b})) continue;\n            preserved_cells.insert({a, b});\n            int c = rnd.next(0, 1) ? 1 : -1;\n            preserved_data.push_back({a, b, c});\n        }\n    } else {\n        // Default to random\n        while ((int)preserved_cells.size() < k) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, m);\n            if (preserved_cells.count({a, b})) continue;\n            preserved_cells.insert({a, b});\n            int c = rnd.next(0, 1) ? 1 : -1;\n            preserved_data.push_back({a, b, c});\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%d\\n\", (int)preserved_data.size());\n    for (auto data : preserved_data) {\n        int a, b, c;\n        std::tie(a, b, c) = data;\n        printf(\"%d %d %d\\n\", a, b, c);\n    }\n    printf(\"%d\\n\", p);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int p = opt<int>(\"p\", 1000000007);\n\n    // Ensure n and m are within [1, 1000]\n    n = min(max(1, n), 1000);\n    m = min(max(1, m), 1000);\n\n    int max_k = max(n, m) - 1;\n    k = min(max(0, k), max_k);\n\n    set<pair<int, int>> preserved_cells;\n    vector<tuple<int, int, int>> preserved_data;\n\n    if (type == \"random\") {\n        // Generate k random preserved cells with random values\n        while ((int)preserved_cells.size() < k) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, m);\n            if (preserved_cells.count({a, b})) continue;\n            preserved_cells.insert({a, b});\n            int c = rnd.next(0, 1) ? 1 : -1;\n            preserved_data.push_back({a, b, c});\n        }\n    } else if (type == \"zerosolution\") {\n        // Create a test case with zero solutions\n        n = max(2, n);\n        m = max(2, m);\n        k = 2;\n        // Fix cells to create conflict\n        preserved_cells.insert({1, 1});\n        preserved_cells.insert({1, 2});\n        // Assign values to cause conflict\n        preserved_data.push_back({1, 1, 1});\n        preserved_data.push_back({1, 2, 1});\n    } else if (type == \"unique_solution\") {\n        // Fix variables to force unique solution\n        int total_vars = n * m;\n        int total_eqns = n + m;\n        k = total_vars - total_eqns;\n        k = max(k, 0);\n        while ((int)preserved_cells.size() < k) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, m);\n            if (preserved_cells.count({a, b})) continue;\n            preserved_cells.insert({a, b});\n            int c = rnd.next(0, 1) ? 1 : -1;\n            preserved_data.push_back({a, b, c});\n        }\n    } else if (type == \"max_solutions\") {\n        // Minimize the number of preserved cells\n        k = 0;\n    } else if (type == \"n_equals_1\") {\n        n = 1;\n        k = min(k, max(n, m) - 1);\n        while ((int)preserved_cells.size() < k) {\n            int a = 1;\n            int b = rnd.next(1, m);\n            if (preserved_cells.count({a, b})) continue;\n            preserved_cells.insert({a, b});\n            int c = rnd.next(0, 1) ? 1 : -1;\n            preserved_data.push_back({a, b, c});\n        }\n    } else if (type == \"m_equals_1\") {\n        m = 1;\n        k = min(k, max(n, m) - 1);\n        while ((int)preserved_cells.size() < k) {\n            int a = rnd.next(1, n);\n            int b = 1;\n            if (preserved_cells.count({a, b})) continue;\n            preserved_cells.insert({a, b});\n            int c = rnd.next(0, 1) ? 1 : -1;\n            preserved_data.push_back({a, b, c});\n        }\n    } else if (type == \"max_k\") {\n        k = max_k;\n        while ((int)preserved_cells.size() < k) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, m);\n            if (preserved_cells.count({a, b})) continue;\n            preserved_cells.insert({a, b});\n            int c = rnd.next(0, 1) ? 1 : -1;\n            preserved_data.push_back({a, b, c});\n        }\n    } else {\n        // Default to random\n        while ((int)preserved_cells.size() < k) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, m);\n            if (preserved_cells.count({a, b})) continue;\n            preserved_cells.insert({a, b});\n            int c = rnd.next(0, 1) ? 1 : -1;\n            preserved_data.push_back({a, b, c});\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%d\\n\", (int)preserved_data.size());\n    for (auto data : preserved_data) {\n        int a, b, c;\n        std::tie(a, b, c) = data;\n        printf(\"%d %d %d\\n\", a, b, c);\n    }\n    printf(\"%d\\n\", p);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -k 0 -type random\n./gen -n 2 -m 2 -k 1 -type random\n./gen -n 2 -m 2 -k 2 -type zerosolution\n./gen -n 2 -m 2 -k 1 -type unique_solution\n\n./gen -n 1 -m 5 -k 0 -type n_equals_1\n./gen -n 5 -m 1 -k 0 -type m_equals_1\n\n./gen -n 1000 -m 1000 -k 0 -type max_solutions\n\n./gen -n 1000 -m 1000 -k 1999 -type max_k\n\n./gen -n 10 -m 10 -k 5 -type random\n./gen -n 10 -m 10 -k 50 -type random\n./gen -n 10 -m 10 -k 99 -type random\n\n./gen -n 100 -m 100 -k 0 -type random\n./gen -n 100 -m 100 -k 50 -type random\n./gen -n 100 -m 100 -k 199 -type random\n\n./gen -n 1000 -m 1000 -k 0 -type random\n./gen -n 1000 -m 1000 -k 500 -type random\n./gen -n 1000 -m 1000 -k 999 -type random\n\n./gen -n 500 -m 500 -k 999 -type zerosolution\n\n./gen -n 2 -m 2 -k 2 -type zerosolution\n\n./gen -n 3 -m 3 -k 6 -type unique_solution\n\n./gen -n 50 -m 50 -k 0 -type random\n./gen -n 50 -m 50 -k 49 -type max_k\n\n./gen -n 1000 -m 1 -k 0 -type m_equals_1\n./gen -n 1 -m 1000 -k 0 -type n_equals_1\n\n./gen -n 1 -m 1 -k 0 -type random\n\n./gen -n 1000 -m 500 -k 499 -type random\n\n./gen -n 999 -m 1000 -k 998 -type random\n\n./gen -n 100 -m 200 -k 99 -type zerosolution\n\n./gen -n 200 -m 100 -k 99 -type zerosolution\n\n./gen -n 1000 -m 1000 -k 0 -type unique_solution\n\n./gen -n 999 -m 999 -k 998 -type unique_solution\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:16.856370",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "400/A",
      "title": "A. Inna and Choose Options",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer t (1 ≤ t ≤ 100). This value shows the number of sets of test data in the input. Next follows the description of each of the t tests on a separate line.The description of each test is a string consisting of 12 characters, each character is either \"X\", or \"O\". The i-th character of the string shows the character that is written on the i-th card from the start.",
      "output_spec": "OutputFor each test, print the answer to the test on a single line. The first number in the line must represent the number of distinct ways to choose the pair a, b. Next, print on this line the pairs in the format axb. Print the pairs in the order of increasing first parameter (a). Separate the pairs in the line by whitespaces.",
      "sample_tests": "ExamplesInputCopy4OXXXOXOOXOOXOXOXOXOXOXOXXXXXXXXXXXXXOOOOOOOOOOOOOutputCopy3 1x12 2x6 4x34 1x12 2x6 3x4 6x26 1x12 2x6 3x4 4x3 6x2 12x10",
      "description": "A. Inna and Choose Options\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer t (1 ≤ t ≤ 100). This value shows the number of sets of test data in the input. Next follows the description of each of the t tests on a separate line.The description of each test is a string consisting of 12 characters, each character is either \"X\", or \"O\". The i-th character of the string shows the character that is written on the i-th card from the start.\n\nOutputFor each test, print the answer to the test on a single line. The first number in the line must represent the number of distinct ways to choose the pair a, b. Next, print on this line the pairs in the format axb. Print the pairs in the order of increasing first parameter (a). Separate the pairs in the line by whitespaces.\n\nInputCopy4OXXXOXOOXOOXOXOXOXOXOXOXXXXXXXXXXXXXOOOOOOOOOOOOOutputCopy3 1x12 2x6 4x34 1x12 2x6 3x4 6x26 1x12 2x6 3x4 4x3 6x2 12x10\n\nInputCopy4OXXXOXOOXOOXOXOXOXOXOXOXXXXXXXXXXXXXOOOOOOOOOOOO\n\nOutputCopy3 1x12 2x6 4x34 1x12 2x6 3x4 6x26 1x12 2x6 3x4 4x3 6x2 12x10",
      "solutions": [
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces",
          "content": "Hi! Soon Codeforces Round #234 (Div. 2) will take place, i am the author, Dmytro Berezin :)Thanks to Gerald Agapov (Gerald) for the help in round preparation, Maria Belova (Delinur) for tasks translations, Mike Mirzayanov (MikeMirzayanov) for perfect system, and Sergii Nagin (Sereja) for his agreement (to share his evening with me) to help in testing.Distribution will be announced as soon as found :) Standard :)Good luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10730",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 425
        },
        {
          "title": "Codeforces Round #234 (Div. 2) — Tutorial - Codeforces",
          "content": "400A — Inna and Choose OptionsNot difficult task. Let's iterate param a. If 12 % a != 0, continue. Calculate b = 12 / a. Let's iterate column (from 1 to b) and for each it's cell (i, j) check, if it contains X or not. Cell (i, j) — is ((i–1) * a + j) -th element of string.400B — Inna and New Matrix of CandiesIn the final version of statement we must choose all lines we haven't finish already. If it is a string where we have S...G — answer  - 1. Otherwise, the answer is the number of distinct distances, as one step kills all distances of the minimal length.400C — Inna and Huge Candy MatrixLet's note that the number of 90 clockwise make sence only by modulo 4. Horizontal — by modulo 2, and 90 counterclockwise — by modulo 4, and 1 such rotation is 3 clockwise rotations.90 clockwise: newi = j; newj = n–i + 1 don't forget to swap(n, m).Horizontal: newj = m–j + 1400D — Dima and BacteriaIf the distribution is correct, after deleting all ribs with cost more than 0 graph will transform to components of corrects size. Also, the nodes are numereted so we should turn dfs for the first node of each type and be sure that we receive exact all nodes of this type and no ohter.Now simple floyd warshall, and put in each cell of adjacent matrix of components the minimal weight between all ribs from 1 component to another.400E — Inna and Binary LogicLet's solve this for each bit separately. Fix some bit. Let's put 1 if the number contains bit and 0 otherwise. Now we receive the sequence, for example 11100111101.Now let's look on sequence of 1 without 0, for this sequence current bit will be added to the sum on the first stage (with all numbers single) on the second stage (with all neighbouring pairs) on the third stage and so on, the number of appiarence for sequence of neighbouring 1 is a formula which depends on the length of sequence only.The last is to learn how to modificate. For each bit let's save the set of sequence of 1. When the bit is deleted, one sequence is sepereted on two, or decreases its length by 1. When the bit is added, new sequence of length 1 appears, or some sequence increases its lentgh by 1 or two sequence transform to 1 biger sequence.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 400\\s*A"
          },
          "content_length": 2178
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 1",
          "code": "G....S\nG.S...\nG..S..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 2",
          "code": "G....S\nG.S...\nG..S..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 3",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 4",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 5",
          "code": "4 8\nG*S*****\n****G*S*\nG*****S*\n**G***S*",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 6",
          "code": "4 8\nG*S*****\n****G*S*\nG*****S*\n**G***S*",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 7",
          "code": "char p[1005]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 8",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 9",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 10",
          "code": "***O\n**GS\n*G*S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 11",
          "code": "***O\n**GS\n*G*S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 12",
          "code": "***O\n***O\n**GS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 13",
          "code": "***O\n***O\n**GS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 14",
          "code": "\"Should be disqualified!\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 15",
          "code": "\"Should be disqualified!\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 16",
          "code": "1 2 1\n 0 0\n  0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 17",
          "code": "1 2 1\n 0 0\n  0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) — Tutorial - Codeforces - Code 1",
          "code": "Time: 0 ms, memory: 972 KB\nVerdict: WRONG_ANSWER\nInput\n\n3 2 2\n2 1\n1 3 0\n3 2 0\n\nOutput\n\nNo\n\nAnswer\n\nYes\n0 0\n0 0\n\nChecker comment\n\nwrong answer 1st words differ - expected: 'Yes', found: 'No'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) — Tutorial - Codeforces - Code 2",
          "code": "Time: 0 ms, memory: 972 KB\nVerdict: WRONG_ANSWER\nInput\n\n3 2 2\n2 1\n1 3 0\n3 2 0\n\nOutput\n\nNo\n\nAnswer\n\nYes\n0 0\n0 0\n\nChecker comment\n\nwrong answer 1st words differ - expected: 'Yes', found: 'No'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10755",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 100, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; ++i) {\n        string s = inf.readLine(\"[XO]{12}\", \"s\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 100, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; ++i) {\n        string s = inf.readLine(\"[XO]{12}\", \"s\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 100, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; ++i) {\n        string s = inf.readLine(\"[XO]{12}\", \"s\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 100); // t=100 if not provided\n    string type = opt<string>(\"type\", \"random\"); // default is 'random'\n\n    printf(\"%d\\n\", t);\n    for(int test_case = 0; test_case < t; ++test_case) {\n\n        string s = string(12, 'X'); // default\n\n        if(type == \"all_X\") {\n            s = string(12, 'X');\n        } else if(type == \"all_O\") {\n            s = string(12, 'O');\n        } else if(type == \"one_X\") {\n            s = string(12, 'O');\n            int pos = rnd.next(12);\n            s[pos] = 'X';\n        } else if(type == \"one_O\") {\n            s = string(12, 'X');\n            int pos = rnd.next(12);\n            s[pos] = 'O';\n        } else if(type == \"alternate_XO\") {\n            s = \"\";\n            for(int i = 0; i < 12; ++i) {\n                s += (i % 2 == 0) ? 'X' : 'O';\n            }\n        } else if(type == \"random\") {\n            s = \"\";\n            for(int i = 0; i < 12; ++i) {\n                s += rnd.next(2) ? 'X' : 'O';\n            }\n        } else if(type == \"specific\") {\n            string win_ab = opt<string>(\"win_ab\");\n            int a, b;\n            sscanf(win_ab.c_str(), \"%dx%d\", &a, &b);\n\n            // Initialize s to all 'O's\n            s = string(12, 'O');\n\n            // Create indexes that belong to the first column of the (a, b) table\n            for(int i = 0; i < a; ++i) {\n                int idx = i * b; // first column\n                if(idx >= 0 && idx < 12) {\n                    s[idx] = 'X';\n                }\n            }\n        } else {\n            // default to random\n            s = \"\";\n            for(int i = 0; i < 12; ++i) {\n                s += rnd.next(2) ? 'X' : 'O';\n            }\n        }\n\n        // Output s\n        printf(\"%s\\n\", s.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\", 100); // t=100 if not provided\n    string type = opt<string>(\"type\", \"random\"); // default is 'random'\n\n    printf(\"%d\\n\", t);\n    for(int test_case = 0; test_case < t; ++test_case) {\n\n        string s = string(12, 'X'); // default\n\n        if(type == \"all_X\") {\n            s = string(12, 'X');\n        } else if(type == \"all_O\") {\n            s = string(12, 'O');\n        } else if(type == \"one_X\") {\n            s = string(12, 'O');\n            int pos = rnd.next(12);\n            s[pos] = 'X';\n        } else if(type == \"one_O\") {\n            s = string(12, 'X');\n            int pos = rnd.next(12);\n            s[pos] = 'O';\n        } else if(type == \"alternate_XO\") {\n            s = \"\";\n            for(int i = 0; i < 12; ++i) {\n                s += (i % 2 == 0) ? 'X' : 'O';\n            }\n        } else if(type == \"random\") {\n            s = \"\";\n            for(int i = 0; i < 12; ++i) {\n                s += rnd.next(2) ? 'X' : 'O';\n            }\n        } else if(type == \"specific\") {\n            string win_ab = opt<string>(\"win_ab\");\n            int a, b;\n            sscanf(win_ab.c_str(), \"%dx%d\", &a, &b);\n\n            // Initialize s to all 'O's\n            s = string(12, 'O');\n\n            // Create indexes that belong to the first column of the (a, b) table\n            for(int i = 0; i < a; ++i) {\n                int idx = i * b; // first column\n                if(idx >= 0 && idx < 12) {\n                    s[idx] = 'X';\n                }\n            }\n        } else {\n            // default to random\n            s = \"\";\n            for(int i = 0; i < 12; ++i) {\n                s += rnd.next(2) ? 'X' : 'O';\n            }\n        }\n\n        // Output s\n        printf(\"%s\\n\", s.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 10 -type all_X\n./gen -t 10 -type all_O\n./gen -t 10 -type one_X\n./gen -t 10 -type one_O\n./gen -t 10 -type alternate_XO\n./gen -t 20 -type random\n./gen -t 10 -type random\n./gen -t 10 -type specific -win_ab 1x12\n./gen -t 10 -type specific -win_ab 2x6\n./gen -t 10 -type specific -win_ab 3x4\n./gen -t 10 -type specific -win_ab 4x3\n./gen -t 10 -type specific -win_ab 6x2\n./gen -t 10 -type specific -win_ab 12x1\n./gen -t 10 -type random\n./gen -t 50 -type one_O\n./gen -t 50 -type one_X\n./gen -t 10 -type alternate_XO\n./gen -t 10 -type specific -win_ab 3x4\n./gen -t 10 -type specific -win_ab 6x2\n./gen -t 10 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:19.060555",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "400/B",
      "title": "B. Inna and New Matrix of Candies",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers n and m (1 ≤ n ≤ 1000; 2 ≤ m ≤ 1000). Next n lines each contain m characters — the game field for the \"Candy Martix 2: Reload\". Character \"*\" represents an empty cell of the field, character \"G\" represents a dwarf and character \"S\" represents a candy. The matrix doesn't contain other characters. It is guaranteed that each line contains exactly one character \"G\" and one character \"S\".",
      "output_spec": "OutputIn a single line print a single integer — either the minimum number of moves needed to achieve the aim of the game, or -1, if the aim cannot be achieved on the given game field.",
      "sample_tests": "ExamplesInputCopy3 4*G*SG**S*G*SOutputCopy2InputCopy1 3S*GOutputCopy-1",
      "description": "B. Inna and New Matrix of Candies\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains two integers n and m (1 ≤ n ≤ 1000; 2 ≤ m ≤ 1000). Next n lines each contain m characters — the game field for the \"Candy Martix 2: Reload\". Character \"*\" represents an empty cell of the field, character \"G\" represents a dwarf and character \"S\" represents a candy. The matrix doesn't contain other characters. It is guaranteed that each line contains exactly one character \"G\" and one character \"S\".\n\nOutputIn a single line print a single integer — either the minimum number of moves needed to achieve the aim of the game, or -1, if the aim cannot be achieved on the given game field.\n\nInputCopy3 4*G*SG**S*G*SOutputCopy2InputCopy1 3S*GOutputCopy-1\n\nInputCopy3 4*G*SG**S*G*S\n\nOutputCopy2\n\nInputCopy1 3S*G\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces",
          "content": "Hi! Soon Codeforces Round #234 (Div. 2) will take place, i am the author, Dmytro Berezin :)Thanks to Gerald Agapov (Gerald) for the help in round preparation, Maria Belova (Delinur) for tasks translations, Mike Mirzayanov (MikeMirzayanov) for perfect system, and Sergii Nagin (Sereja) for his agreement (to share his evening with me) to help in testing.Distribution will be announced as soon as found :) Standard :)Good luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10730",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 425
        },
        {
          "title": "Codeforces Round #234 (Div. 2) — Tutorial - Codeforces",
          "content": "400A — Inna and Choose OptionsNot difficult task. Let's iterate param a. If 12 % a != 0, continue. Calculate b = 12 / a. Let's iterate column (from 1 to b) and for each it's cell (i, j) check, if it contains X or not. Cell (i, j) — is ((i–1) * a + j) -th element of string.400B — Inna and New Matrix of CandiesIn the final version of statement we must choose all lines we haven't finish already. If it is a string where we have S...G — answer  - 1. Otherwise, the answer is the number of distinct distances, as one step kills all distances of the minimal length.400C — Inna and Huge Candy MatrixLet's note that the number of 90 clockwise make sence only by modulo 4. Horizontal — by modulo 2, and 90 counterclockwise — by modulo 4, and 1 such rotation is 3 clockwise rotations.90 clockwise: newi = j; newj = n–i + 1 don't forget to swap(n, m).Horizontal: newj = m–j + 1400D — Dima and BacteriaIf the distribution is correct, after deleting all ribs with cost more than 0 graph will transform to components of corrects size. Also, the nodes are numereted so we should turn dfs for the first node of each type and be sure that we receive exact all nodes of this type and no ohter.Now simple floyd warshall, and put in each cell of adjacent matrix of components the minimal weight between all ribs from 1 component to another.400E — Inna and Binary LogicLet's solve this for each bit separately. Fix some bit. Let's put 1 if the number contains bit and 0 otherwise. Now we receive the sequence, for example 11100111101.Now let's look on sequence of 1 without 0, for this sequence current bit will be added to the sum on the first stage (with all numbers single) on the second stage (with all neighbouring pairs) on the third stage and so on, the number of appiarence for sequence of neighbouring 1 is a formula which depends on the length of sequence only.The last is to learn how to modificate. For each bit let's save the set of sequence of 1. When the bit is deleted, one sequence is sepereted on two, or decreases its length by 1. When the bit is added, new sequence of length 1 appears, or some sequence increases its lentgh by 1 or two sequence transform to 1 biger sequence.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 400\\s*B"
          },
          "content_length": 2178
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 1",
          "code": "G....S\nG.S...\nG..S..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 2",
          "code": "G....S\nG.S...\nG..S..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 3",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 4",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 5",
          "code": "4 8\nG*S*****\n****G*S*\nG*****S*\n**G***S*",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 6",
          "code": "4 8\nG*S*****\n****G*S*\nG*****S*\n**G***S*",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 7",
          "code": "char p[1005]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 8",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 9",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 10",
          "code": "***O\n**GS\n*G*S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 11",
          "code": "***O\n**GS\n*G*S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 12",
          "code": "***O\n***O\n**GS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 13",
          "code": "***O\n***O\n**GS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 14",
          "code": "\"Should be disqualified!\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 15",
          "code": "\"Should be disqualified!\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 16",
          "code": "1 2 1\n 0 0\n  0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 17",
          "code": "1 2 1\n 0 0\n  0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) — Tutorial - Codeforces - Code 1",
          "code": "Time: 0 ms, memory: 972 KB\nVerdict: WRONG_ANSWER\nInput\n\n3 2 2\n2 1\n1 3 0\n3 2 0\n\nOutput\n\nNo\n\nAnswer\n\nYes\n0 0\n0 0\n\nChecker comment\n\nwrong answer 1st words differ - expected: 'Yes', found: 'No'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) — Tutorial - Codeforces - Code 2",
          "code": "Time: 0 ms, memory: 972 KB\nVerdict: WRONG_ANSWER\nInput\n\n3 2 2\n2 1\n1 3 0\n3 2 0\n\nOutput\n\nNo\n\nAnswer\n\nYes\n0 0\n0 0\n\nChecker comment\n\nwrong answer 1st words differ - expected: 'Yes', found: 'No'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10755",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        string line = inf.readLine();\n        inf.ensuref((int)line.length() == m, \"Line %d should have length %d\", i, m);\n        int num_G = 0, num_S = 0;\n        for (char c : line) {\n            inf.ensuref(c == '*' || c == 'G' || c == 'S', \"Invalid character '%c' in line %d\", c, i);\n            if (c == 'G') num_G++;\n            if (c == 'S') num_S++;\n        }\n        inf.ensuref(num_G == 1, \"Line %d should contain exactly one 'G'\", i);\n        inf.ensuref(num_S == 1, \"Line %d should contain exactly one 'S'\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        string line = inf.readLine();\n        inf.ensuref((int)line.length() == m, \"Line %d should have length %d\", i, m);\n        int num_G = 0, num_S = 0;\n        for (char c : line) {\n            inf.ensuref(c == '*' || c == 'G' || c == 'S', \"Invalid character '%c' in line %d\", c, i);\n            if (c == 'G') num_G++;\n            if (c == 'S') num_S++;\n        }\n        inf.ensuref(num_G == 1, \"Line %d should contain exactly one 'G'\", i);\n        inf.ensuref(num_S == 1, \"Line %d should contain exactly one 'S'\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        string line = inf.readLine();\n        inf.ensuref((int)line.length() == m, \"Line %d should have length %d\", i, m);\n        int num_G = 0, num_S = 0;\n        for (char c : line) {\n            inf.ensuref(c == '*' || c == 'G' || c == 'S', \"Invalid character '%c' in line %d\", c, i);\n            if (c == 'G') num_G++;\n            if (c == 'S') num_S++;\n        }\n        inf.ensuref(num_G == 1, \"Line %d should contain exactly one 'G'\", i);\n        inf.ensuref(num_S == 1, \"Line %d should contain exactly one 'S'\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<string> grid(n, string(m, '*'));\n    \n    if(type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            int g_col = rnd.next(0, m-1);\n            int s_col = rnd.next(0, m-1);\n            while(s_col == g_col)\n                s_col = rnd.next(0, m-1);\n            grid[i][g_col] = 'G';\n            grid[i][s_col] = 'S';\n        }\n    } else if (type == \"left_candy\") {\n        for(int i = 0; i < n; ++i) {\n            int g_col = rnd.next(1, m-1); // g_col >= 1\n            int s_col = rnd.next(0, g_col - 1); // s_col < g_col\n            grid[i][g_col] = 'G';\n            grid[i][s_col] = 'S';\n        }\n    } else if (type == \"right_candy\") {\n        for(int i = 0; i < n; ++i) {\n            int g_col = rnd.next(0, m-2); // g_col <= m-2\n            int s_col = rnd.next(g_col+1, m-1); // s_col > g_col\n            grid[i][g_col] = 'G';\n            grid[i][s_col] = 'S';\n        }\n    } else if (type == \"same_distance\") {\n        int d = opt<int>(\"d\", 1);\n        if (d >= m - 1) {\n            // Adjust d to be within bounds\n            d = m - 2;\n        }\n        for(int i = 0; i < n; ++i) {\n            int g_col = rnd.next(0, m - d - 2); // g_col + d + 1 < m\n            int s_col = g_col + d + 1;\n            grid[i][g_col] = 'G';\n            grid[i][s_col] = 'S';\n        }\n    } else if (type == \"increasing_distance\") {\n        int max_d = m - 2; // maximum possible distance\n        int start_d = opt<int>(\"start_d\", 0); // starting distance\n        for(int i = 0; i < n; ++i) {\n            int d = start_d + i;\n            if (d > max_d) d = max_d; // ensuring s_col <= m-1\n            int g_col = 0;\n            int s_col = g_col + d + 1;\n            grid[i][g_col] = 'G';\n            grid[i][s_col] = 'S';\n        }\n    } else if (type == \"decreasing_distance\") {\n        int max_d = m - 2; // maximum possible distance\n        int start_d = opt<int>(\"start_d\", n - 1);\n        for(int i = 0; i < n; ++i) {\n            int d = start_d - i;\n            if (d < 0) d = 0;\n            if (d > max_d) d = max_d;\n            int g_col = 0;\n            int s_col = g_col + d + 1;\n            grid[i][g_col] = 'G';\n            grid[i][s_col] = 'S';\n        }\n    } else if (type == \"edge_case\") {\n        for(int i = 0; i < n; ++i) {\n            int g_col = m - 1;\n            int s_col = m - 2;\n            grid[i][g_col] = 'G';\n            grid[i][s_col] = 'S';\n        }\n    } else {\n        // Default to random if type not recognized\n        for(int i = 0; i < n; ++i) {\n            int g_col = rnd.next(0, m-1);\n            int s_col = rnd.next(0, m-1);\n            while(s_col == g_col)\n                s_col = rnd.next(0, m-1);\n            grid[i][g_col] = 'G';\n            grid[i][s_col] = 'S';\n        }\n    }\n    \n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output grid\n    for(int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<string> grid(n, string(m, '*'));\n    \n    if(type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            int g_col = rnd.next(0, m-1);\n            int s_col = rnd.next(0, m-1);\n            while(s_col == g_col)\n                s_col = rnd.next(0, m-1);\n            grid[i][g_col] = 'G';\n            grid[i][s_col] = 'S';\n        }\n    } else if (type == \"left_candy\") {\n        for(int i = 0; i < n; ++i) {\n            int g_col = rnd.next(1, m-1); // g_col >= 1\n            int s_col = rnd.next(0, g_col - 1); // s_col < g_col\n            grid[i][g_col] = 'G';\n            grid[i][s_col] = 'S';\n        }\n    } else if (type == \"right_candy\") {\n        for(int i = 0; i < n; ++i) {\n            int g_col = rnd.next(0, m-2); // g_col <= m-2\n            int s_col = rnd.next(g_col+1, m-1); // s_col > g_col\n            grid[i][g_col] = 'G';\n            grid[i][s_col] = 'S';\n        }\n    } else if (type == \"same_distance\") {\n        int d = opt<int>(\"d\", 1);\n        if (d >= m - 1) {\n            // Adjust d to be within bounds\n            d = m - 2;\n        }\n        for(int i = 0; i < n; ++i) {\n            int g_col = rnd.next(0, m - d - 2); // g_col + d + 1 < m\n            int s_col = g_col + d + 1;\n            grid[i][g_col] = 'G';\n            grid[i][s_col] = 'S';\n        }\n    } else if (type == \"increasing_distance\") {\n        int max_d = m - 2; // maximum possible distance\n        int start_d = opt<int>(\"start_d\", 0); // starting distance\n        for(int i = 0; i < n; ++i) {\n            int d = start_d + i;\n            if (d > max_d) d = max_d; // ensuring s_col <= m-1\n            int g_col = 0;\n            int s_col = g_col + d + 1;\n            grid[i][g_col] = 'G';\n            grid[i][s_col] = 'S';\n        }\n    } else if (type == \"decreasing_distance\") {\n        int max_d = m - 2; // maximum possible distance\n        int start_d = opt<int>(\"start_d\", n - 1);\n        for(int i = 0; i < n; ++i) {\n            int d = start_d - i;\n            if (d < 0) d = 0;\n            if (d > max_d) d = max_d;\n            int g_col = 0;\n            int s_col = g_col + d + 1;\n            grid[i][g_col] = 'G';\n            grid[i][s_col] = 'S';\n        }\n    } else if (type == \"edge_case\") {\n        for(int i = 0; i < n; ++i) {\n            int g_col = m - 1;\n            int s_col = m - 2;\n            grid[i][g_col] = 'G';\n            grid[i][s_col] = 'S';\n        }\n    } else {\n        // Default to random if type not recognized\n        for(int i = 0; i < n; ++i) {\n            int g_col = rnd.next(0, m-1);\n            int s_col = rnd.next(0, m-1);\n            while(s_col == g_col)\n                s_col = rnd.next(0, m-1);\n            grid[i][g_col] = 'G';\n            grid[i][s_col] = 'S';\n        }\n    }\n    \n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output grid\n    for(int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 2 -type random\n\n./gen -n 5 -m 5 -type random\n./gen -n 10 -m 10 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 500 -m 500 -type random\n./gen -n 1000 -m 1000 -type random\n\n./gen -n 1 -m 2 -type left_candy\n./gen -n 10 -m 10 -type left_candy\n./gen -n 100 -m 100 -type left_candy\n./gen -n 500 -m 500 -type left_candy\n./gen -n 1000 -m 1000 -type left_candy\n\n./gen -n 1 -m 2 -type right_candy\n./gen -n 10 -m 10 -type right_candy\n./gen -n 100 -m 100 -type right_candy\n./gen -n 500 -m 500 -type right_candy\n./gen -n 1000 -m 1000 -type right_candy\n\n./gen -n 10 -m 10 -type same_distance -d 0\n./gen -n 10 -m 10 -type same_distance -d 1\n./gen -n 10 -m 20 -type same_distance -d 5\n./gen -n 100 -m 500 -type same_distance -d 200\n./gen -n 1000 -m 1000 -type same_distance -d 500\n\n./gen -n 10 -m 20 -type increasing_distance -start_d 0\n./gen -n 500 -m 1000 -type increasing_distance -start_d 0\n./gen -n 1000 -m 1000 -type increasing_distance -start_d 0\n\n./gen -n 10 -m 20 -type decreasing_distance -start_d 999\n./gen -n 500 -m 1000 -type decreasing_distance -start_d 999\n./gen -n 1000 -m 1000 -type decreasing_distance -start_d 999\n\n# Edge cases\n./gen -n 1000 -m 2 -type left_candy\n./gen -n 1000 -m 2 -type right_candy\n./gen -n 10 -m 10 -type edge_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:21.192547",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "400/C",
      "title": "C. Inna and Huge Candy Matrix",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains fix integers n, m, x, y, z, p (1 ≤ n, m ≤ 109; 0 ≤ x, y, z ≤ 109; 1 ≤ p ≤ 105).Each of the following p lines contains two integers xk, yk (1 ≤ xk ≤ n; 1 ≤ yk ≤ m) — the initial coordinates of the k-th candy. Two candies can lie on the same cell.",
      "output_spec": "OutputFor each of the p candies, print on a single line its space-separated new coordinates.",
      "sample_tests": "ExamplesInputCopy3 3 3 1 1 91 11 21 32 12 22 33 13 23 3OutputCopy1 31 21 12 32 22 13 33 23 1",
      "description": "C. Inna and Huge Candy Matrix\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains fix integers n, m, x, y, z, p (1 ≤ n, m ≤ 109; 0 ≤ x, y, z ≤ 109; 1 ≤ p ≤ 105).Each of the following p lines contains two integers xk, yk (1 ≤ xk ≤ n; 1 ≤ yk ≤ m) — the initial coordinates of the k-th candy. Two candies can lie on the same cell.\n\nOutputFor each of the p candies, print on a single line its space-separated new coordinates.\n\nInputCopy3 3 3 1 1 91 11 21 32 12 22 33 13 23 3OutputCopy1 31 21 12 32 22 13 33 23 1\n\nInputCopy3 3 3 1 1 91 11 21 32 12 22 33 13 23 3\n\nOutputCopy1 31 21 12 32 22 13 33 23 1\n\nNoteJust for clarity. Horizontal rotating is like a mirroring of the matrix. For matrix:QWER      REWQ ASDF  ->  FDSAZXCV      VCXZ",
      "solutions": [
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces",
          "content": "Hi! Soon Codeforces Round #234 (Div. 2) will take place, i am the author, Dmytro Berezin :)Thanks to Gerald Agapov (Gerald) for the help in round preparation, Maria Belova (Delinur) for tasks translations, Mike Mirzayanov (MikeMirzayanov) for perfect system, and Sergii Nagin (Sereja) for his agreement (to share his evening with me) to help in testing.Distribution will be announced as soon as found :) Standard :)Good luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10730",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 425
        },
        {
          "title": "Codeforces Round #234 (Div. 2) — Tutorial - Codeforces",
          "content": "400A — Inna and Choose OptionsNot difficult task. Let's iterate param a. If 12 % a != 0, continue. Calculate b = 12 / a. Let's iterate column (from 1 to b) and for each it's cell (i, j) check, if it contains X or not. Cell (i, j) — is ((i–1) * a + j) -th element of string.400B — Inna and New Matrix of CandiesIn the final version of statement we must choose all lines we haven't finish already. If it is a string where we have S...G — answer  - 1. Otherwise, the answer is the number of distinct distances, as one step kills all distances of the minimal length.400C — Inna and Huge Candy MatrixLet's note that the number of 90 clockwise make sence only by modulo 4. Horizontal — by modulo 2, and 90 counterclockwise — by modulo 4, and 1 such rotation is 3 clockwise rotations.90 clockwise: newi = j; newj = n–i + 1 don't forget to swap(n, m).Horizontal: newj = m–j + 1400D — Dima and BacteriaIf the distribution is correct, after deleting all ribs with cost more than 0 graph will transform to components of corrects size. Also, the nodes are numereted so we should turn dfs for the first node of each type and be sure that we receive exact all nodes of this type and no ohter.Now simple floyd warshall, and put in each cell of adjacent matrix of components the minimal weight between all ribs from 1 component to another.400E — Inna and Binary LogicLet's solve this for each bit separately. Fix some bit. Let's put 1 if the number contains bit and 0 otherwise. Now we receive the sequence, for example 11100111101.Now let's look on sequence of 1 without 0, for this sequence current bit will be added to the sum on the first stage (with all numbers single) on the second stage (with all neighbouring pairs) on the third stage and so on, the number of appiarence for sequence of neighbouring 1 is a formula which depends on the length of sequence only.The last is to learn how to modificate. For each bit let's save the set of sequence of 1. When the bit is deleted, one sequence is sepereted on two, or decreases its length by 1. When the bit is added, new sequence of length 1 appears, or some sequence increases its lentgh by 1 or two sequence transform to 1 biger sequence.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 400\\s*C"
          },
          "content_length": 2178
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 1",
          "code": "G....S\nG.S...\nG..S..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 2",
          "code": "G....S\nG.S...\nG..S..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 3",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 4",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 5",
          "code": "4 8\nG*S*****\n****G*S*\nG*****S*\n**G***S*",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 6",
          "code": "4 8\nG*S*****\n****G*S*\nG*****S*\n**G***S*",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 7",
          "code": "char p[1005]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 8",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 9",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 10",
          "code": "***O\n**GS\n*G*S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 11",
          "code": "***O\n**GS\n*G*S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 12",
          "code": "***O\n***O\n**GS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 13",
          "code": "***O\n***O\n**GS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 14",
          "code": "\"Should be disqualified!\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 15",
          "code": "\"Should be disqualified!\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 16",
          "code": "1 2 1\n 0 0\n  0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 17",
          "code": "1 2 1\n 0 0\n  0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) — Tutorial - Codeforces - Code 1",
          "code": "Time: 0 ms, memory: 972 KB\nVerdict: WRONG_ANSWER\nInput\n\n3 2 2\n2 1\n1 3 0\n3 2 0\n\nOutput\n\nNo\n\nAnswer\n\nYes\n0 0\n0 0\n\nChecker comment\n\nwrong answer 1st words differ - expected: 'Yes', found: 'No'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) — Tutorial - Codeforces - Code 2",
          "code": "Time: 0 ms, memory: 972 KB\nVerdict: WRONG_ANSWER\nInput\n\n3 2 2\n2 1\n1 3 0\n3 2 0\n\nOutput\n\nNo\n\nAnswer\n\nYes\n0 0\n0 0\n\nChecker comment\n\nwrong answer 1st words differ - expected: 'Yes', found: 'No'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10755",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\"); // n ∈ [1, 1e9]\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\"); // m ∈ [1, 1e9]\n    inf.readSpace();\n    int x = inf.readInt(0, 1000000000, \"x\"); // x ∈ [0, 1e9]\n    inf.readSpace();\n    int y = inf.readInt(0, 1000000000, \"y\"); // y ∈ [0, 1e9]\n    inf.readSpace();\n    int z = inf.readInt(0, 1000000000, \"z\"); // z ∈ [0, 1e9]\n    inf.readSpace();\n    int p = inf.readInt(1, 100000, \"p\"); // p ∈ [1, 1e5]\n    inf.readEoln();\n    for (int i = 0; i < p; i++) {\n        int xk = inf.readInt(1, n, \"xk\");\n        inf.readSpace();\n        int yk = inf.readInt(1, m, \"yk\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\"); // n ∈ [1, 1e9]\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\"); // m ∈ [1, 1e9]\n    inf.readSpace();\n    int x = inf.readInt(0, 1000000000, \"x\"); // x ∈ [0, 1e9]\n    inf.readSpace();\n    int y = inf.readInt(0, 1000000000, \"y\"); // y ∈ [0, 1e9]\n    inf.readSpace();\n    int z = inf.readInt(0, 1000000000, \"z\"); // z ∈ [0, 1e9]\n    inf.readSpace();\n    int p = inf.readInt(1, 100000, \"p\"); // p ∈ [1, 1e5]\n    inf.readEoln();\n    for (int i = 0; i < p; i++) {\n        int xk = inf.readInt(1, n, \"xk\");\n        inf.readSpace();\n        int yk = inf.readInt(1, m, \"yk\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\"); // n ∈ [1, 1e9]\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\"); // m ∈ [1, 1e9]\n    inf.readSpace();\n    int x = inf.readInt(0, 1000000000, \"x\"); // x ∈ [0, 1e9]\n    inf.readSpace();\n    int y = inf.readInt(0, 1000000000, \"y\"); // y ∈ [0, 1e9]\n    inf.readSpace();\n    int z = inf.readInt(0, 1000000000, \"z\"); // z ∈ [0, 1e9]\n    inf.readSpace();\n    int p = inf.readInt(1, 100000, \"p\"); // p ∈ [1, 1e5]\n    inf.readEoln();\n    for (int i = 0; i < p; i++) {\n        int xk = inf.readInt(1, n, \"xk\");\n        inf.readSpace();\n        int yk = inf.readInt(1, m, \"yk\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    long long x = opt<long long>(\"x\", 0); // Number of clockwise rotations\n    long long y = opt<long long>(\"y\", 0); // Number of horizontal flips\n    long long z = opt<long long>(\"z\", 0); // Number of counterclockwise rotations\n    int p = opt<int>(\"p\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> candies;\n\n    if (type == \"random\") {\n        // Generate p random candies\n        for (int i = 0; i < p; i++) {\n            int xk = rnd.next(1, n);\n            int yk = rnd.next(1, m);\n            candies.push_back({xk, yk});\n        }\n    } else if (type == \"corners\") {\n        // Place candies at the corners\n        vector<pair<int,int>> corner_cells = {{1,1}, {1,m}, {n,1}, {n,m}};\n        int cnt = min(p, 4);\n        for (int i = 0; i < cnt; i++) {\n            candies.push_back(corner_cells[i]);\n        }\n        // Add random candies if p > 4\n        for (int i = cnt; i < p; i++) {\n            int xk = rnd.next(1, n);\n            int yk = rnd.next(1, m);\n            candies.push_back({xk, yk});\n        }\n    } else if (type == \"edges\") {\n        // Place candies along the edges\n        for (int i = 0; i < p; i++) {\n            int side = rnd.next(1,4);\n            int xk, yk;\n            switch(side) {\n                case 1: // top edge\n                    xk = 1;\n                    yk = rnd.next(1, m);\n                    break;\n                case 2: // bottom edge\n                    xk = n;\n                    yk = rnd.next(1, m);\n                    break;\n                case 3: // left edge\n                    xk = rnd.next(1, n);\n                    yk = 1;\n                    break;\n                case 4: // right edge\n                    xk = rnd.next(1, n);\n                    yk = m;\n                    break;\n            }\n            candies.push_back({xk, yk});\n        }\n    } else if (type == \"same_cell\") {\n        // All candies in the same cell\n        int xk = rnd.next(1, n);\n        int yk = rnd.next(1, m);\n        for (int i = 0; i < p; i++) {\n            candies.push_back({xk, yk});\n        }\n    } else if (type == \"line_row\") {\n        // All candies in the same row\n        int xk = rnd.next(1, n);\n        for (int i = 0; i < p; i++) {\n            int yk = rnd.next(1, m);\n            candies.push_back({xk, yk});\n        }\n    } else if (type == \"line_column\") {\n        // All candies in the same column\n        int yk = rnd.next(1, m);\n        for (int i = 0; i < p; i++) {\n            int xk = rnd.next(1, n);\n            candies.push_back({xk, yk});\n        }\n    } else if (type == \"full_row\") {\n        // Fill a row with candies\n        int xk = rnd.next(1, n);\n        for (int yk = 1; yk <= m && (int)candies.size() < p; yk++) {\n            candies.push_back({xk, yk});\n        }\n        // Fill remaining candies randomly\n        while ((int)candies.size() < p) {\n            int yk = rnd.next(1, m);\n            candies.push_back({xk, yk});\n        }\n    } else if (type == \"full_column\") {\n        // Fill a column with candies\n        int yk = rnd.next(1, m);\n        for (int xk = 1; xk <= n && (int)candies.size() < p; xk++) {\n            candies.push_back({xk, yk});\n        }\n        // Fill remaining candies randomly\n        while ((int)candies.size() < p) {\n            int xk = rnd.next(1, n);\n            candies.push_back({xk, yk});\n        }\n    } else if (type == \"min_values\") {\n        // n = m = 1, all candies at (1,1)\n        for (int i = 0; i < p; i++) {\n            candies.push_back({1,1});\n        }\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < p; i++) {\n            int xk = rnd.next(1, n);\n            int yk = rnd.next(1, m);\n            candies.push_back({xk, yk});\n        }\n    }\n\n    // Output the data\n    printf(\"%d %d %lld %lld %lld %d\\n\", n, m, x, y, z, p);\n    for (int i = 0; i < p; i++) {\n        printf(\"%d %d\\n\", candies[i].first, candies[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    long long x = opt<long long>(\"x\", 0); // Number of clockwise rotations\n    long long y = opt<long long>(\"y\", 0); // Number of horizontal flips\n    long long z = opt<long long>(\"z\", 0); // Number of counterclockwise rotations\n    int p = opt<int>(\"p\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> candies;\n\n    if (type == \"random\") {\n        // Generate p random candies\n        for (int i = 0; i < p; i++) {\n            int xk = rnd.next(1, n);\n            int yk = rnd.next(1, m);\n            candies.push_back({xk, yk});\n        }\n    } else if (type == \"corners\") {\n        // Place candies at the corners\n        vector<pair<int,int>> corner_cells = {{1,1}, {1,m}, {n,1}, {n,m}};\n        int cnt = min(p, 4);\n        for (int i = 0; i < cnt; i++) {\n            candies.push_back(corner_cells[i]);\n        }\n        // Add random candies if p > 4\n        for (int i = cnt; i < p; i++) {\n            int xk = rnd.next(1, n);\n            int yk = rnd.next(1, m);\n            candies.push_back({xk, yk});\n        }\n    } else if (type == \"edges\") {\n        // Place candies along the edges\n        for (int i = 0; i < p; i++) {\n            int side = rnd.next(1,4);\n            int xk, yk;\n            switch(side) {\n                case 1: // top edge\n                    xk = 1;\n                    yk = rnd.next(1, m);\n                    break;\n                case 2: // bottom edge\n                    xk = n;\n                    yk = rnd.next(1, m);\n                    break;\n                case 3: // left edge\n                    xk = rnd.next(1, n);\n                    yk = 1;\n                    break;\n                case 4: // right edge\n                    xk = rnd.next(1, n);\n                    yk = m;\n                    break;\n            }\n            candies.push_back({xk, yk});\n        }\n    } else if (type == \"same_cell\") {\n        // All candies in the same cell\n        int xk = rnd.next(1, n);\n        int yk = rnd.next(1, m);\n        for (int i = 0; i < p; i++) {\n            candies.push_back({xk, yk});\n        }\n    } else if (type == \"line_row\") {\n        // All candies in the same row\n        int xk = rnd.next(1, n);\n        for (int i = 0; i < p; i++) {\n            int yk = rnd.next(1, m);\n            candies.push_back({xk, yk});\n        }\n    } else if (type == \"line_column\") {\n        // All candies in the same column\n        int yk = rnd.next(1, m);\n        for (int i = 0; i < p; i++) {\n            int xk = rnd.next(1, n);\n            candies.push_back({xk, yk});\n        }\n    } else if (type == \"full_row\") {\n        // Fill a row with candies\n        int xk = rnd.next(1, n);\n        for (int yk = 1; yk <= m && (int)candies.size() < p; yk++) {\n            candies.push_back({xk, yk});\n        }\n        // Fill remaining candies randomly\n        while ((int)candies.size() < p) {\n            int yk = rnd.next(1, m);\n            candies.push_back({xk, yk});\n        }\n    } else if (type == \"full_column\") {\n        // Fill a column with candies\n        int yk = rnd.next(1, m);\n        for (int xk = 1; xk <= n && (int)candies.size() < p; xk++) {\n            candies.push_back({xk, yk});\n        }\n        // Fill remaining candies randomly\n        while ((int)candies.size() < p) {\n            int xk = rnd.next(1, n);\n            candies.push_back({xk, yk});\n        }\n    } else if (type == \"min_values\") {\n        // n = m = 1, all candies at (1,1)\n        for (int i = 0; i < p; i++) {\n            candies.push_back({1,1});\n        }\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < p; i++) {\n            int xk = rnd.next(1, n);\n            int yk = rnd.next(1, m);\n            candies.push_back({xk, yk});\n        }\n    }\n\n    // Output the data\n    printf(\"%d %d %lld %lld %lld %d\\n\", n, m, x, y, z, p);\n    for (int i = 0; i < p; i++) {\n        printf(\"%d %d\\n\", candies[i].first, candies[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small grid with zero rotations\n./gen -n 10 -m 10 -x 0 -y 0 -z 0 -p 5 -type random\n\n# Small grid with some rotations\n./gen -n 10 -m 15 -x 1 -y 0 -z 2 -p 10 -type random\n\n# Large grid with maximum rotations\n./gen -n 1000000000 -m 1000000000 -x 1000000000 -y 1000000000 -z 1000000000 -p 100000 -type random\n\n# Minimum values (n = m = 1)\n./gen -n 1 -m 1 -x 0 -y 0 -z 0 -p 1 -type min_values\n\n# Maximum p with minimum grid size\n./gen -n 1 -m 1 -x 0 -y 0 -z 0 -p 100000 -type min_values\n\n# Candies along the edges\n./gen -n 1000000000 -m 1000000000 -x 123456789 -y 987654321 -z 192837465 -p 100000 -type edges\n\n# All candies in the same cell\n./gen -n 1000 -m 1000 -x 0 -y 0 -z 0 -p 100000 -type same_cell\n\n# All candies in the same row\n./gen -n 1000000000 -m 1000000000 -x 999999999 -y 888888888 -z 777777777 -p 100000 -type line_row\n\n# All candies in the same column\n./gen -n 1000000000 -m 1000000000 -x 555555555 -y 444444444 -z 333333333 -p 100000 -type line_column\n\n# Full row with candies\n./gen -n 1000000000 -m 100000 -x 0 -y 0 -z 0 -p 100000 -type full_row\n\n# Full column with candies\n./gen -n 100000 -m 1000000000 -x 0 -y 0 -z 0 -p 100000 -type full_column\n\n# Candies at the corners\n./gen -n 1000000000 -m 1000000000 -x 10 -y 20 -z 30 -p 10 -type corners\n\n# Testing zero rotations\n./gen -n 1000000000 -m 1000000000 -x 0 -y 0 -z 0 -p 100000 -type random\n\n# Testing large rotations\n./gen -n 1000000000 -m 1000000000 -x 1000000000 -y 1000000000 -z 1000000000 -p 100000 -type large_rotations\n\n# Testing n much larger than m\n./gen -n 1000000000 -m 10 -x 5 -y 5 -z 5 -p 100000 -type n_large_m_small\n\n# Testing m much larger than n\n./gen -n 10 -m 1000000000 -x 5 -y 5 -z 5 -p 100000 -type m_large_n_small\n\n# Small p with large grid\n./gen -n 1000000000 -m 1000000000 -x 500 -y 600 -z 700 -p 1 -type random\n\n# All candies at the maximum coordinates\n./gen -n 1000000000 -m 1000000000 -x 0 -y 0 -z 0 -p 100000 -type same_cell\n\n# Grid with n equals m and random rotations\n./gen -n 1000000000 -m 1000000000 -x 123456789 -y 987654321 -z 192837465 -p 100000 -type n_equal_m\n\n# Small grid with maximum p\n./gen -n 1000 -m 1000 -x 0 -y 0 -z 0 -p 100000 -type random\n\n# Random test case with random parameters\n./gen -n 999999999 -m 888888888 -x 777777777 -y 666666666 -z 555555555 -p 100000 -type random\n\n# Test case with rotations causing modulus\n./gen -n 1000000000 -m 1000000000 -x 4000000005 -y 2000000003 -z 3000000002 -p 100000 -type random\n\n# All candies in the middle row\n./gen -n 1000000000 -m 1000000000 -x 0 -y 0 -z 0 -p 100000 -type line_row\n\n# All candies in the middle column\n./gen -n 1000000000 -m 1000000000 -x 0 -y 0 -z 0 -p 100000 -type line_column\n\n# All candies along the boundary\n./gen -n 1000000000 -m 1000000000 -x 0 -y 0 -z 0 -p 100000 -type edges\n\n# Test case with maximum rotations but small grid\n./gen -n 1000 -m 1000 -x 1000000000 -y 1000000000 -z 1000000000 -p 100000 -type random\n\n# Test case with zero candies\n./gen -n 1000 -m 1000 -x 0 -y 0 -z 0 -p 0 -type random\n\n# Test case with candies at random positions\n./gen -n 1000000000 -m 1000000000 -x 123 -y 456 -z 789 -p 100000 -type random\n\n# Test case with maximum possible n, m, p\n./gen -n 1000000000 -m 1000000000 -x 0 -y 0 -z 0 -p 100000 -type random\n\n# Test case with minimal rotations and small p\n./gen -n 1000000000 -m 1000000000 -x 1 -y 1 -z 1 -p 10 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:23.536529",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "400/D",
      "title": "D. Dima and Bacteria",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m, k (1 ≤ n ≤ 105; 0 ≤ m ≤ 105; 1 ≤ k ≤ 500). The next line contains k integers c1, c2, ..., ck (1 ≤ ci ≤ n). Each of the next m lines contains three integers ui, vi, xi (1 ≤ ui, vi ≤ 105; 0 ≤ xi ≤ 104). It is guaranteed that .",
      "output_spec": "OutputIf Dima's type-distribution is correct, print string «Yes», and then k lines: in the i-th line print integers d[i][1], d[i][2], ..., d[i][k] (d[i][i] = 0). If there is no way to move energy from bacteria i to bacteria j appropriate d[i][j] must equal to -1. If the type-distribution isn't correct print «No».",
      "sample_tests": "ExamplesInputCopy4 4 21 32 3 03 4 02 4 12 1 2OutputCopyYes0 22 0InputCopy3 1 22 11 2 0OutputCopyYes0 -1-1 0InputCopy3 2 22 11 2 02 3 1OutputCopyYes0 11 0InputCopy3 0 21 2OutputCopyNo",
      "description": "D. Dima and Bacteria\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m, k (1 ≤ n ≤ 105; 0 ≤ m ≤ 105; 1 ≤ k ≤ 500). The next line contains k integers c1, c2, ..., ck (1 ≤ ci ≤ n). Each of the next m lines contains three integers ui, vi, xi (1 ≤ ui, vi ≤ 105; 0 ≤ xi ≤ 104). It is guaranteed that .\n\nOutputIf Dima's type-distribution is correct, print string «Yes», and then k lines: in the i-th line print integers d[i][1], d[i][2], ..., d[i][k] (d[i][i] = 0). If there is no way to move energy from bacteria i to bacteria j appropriate d[i][j] must equal to -1. If the type-distribution isn't correct print «No».\n\nInputCopy4 4 21 32 3 03 4 02 4 12 1 2OutputCopyYes0 22 0InputCopy3 1 22 11 2 0OutputCopyYes0 -1-1 0InputCopy3 2 22 11 2 02 3 1OutputCopyYes0 11 0InputCopy3 0 21 2OutputCopyNo\n\nInputCopy4 4 21 32 3 03 4 02 4 12 1 2\n\nOutputCopyYes0 22 0\n\nInputCopy3 1 22 11 2 0\n\nOutputCopyYes0 -1-1 0\n\nInputCopy3 2 22 11 2 02 3 1\n\nOutputCopyYes0 11 0\n\nInputCopy3 0 21 2\n\nOutputCopyNo",
      "solutions": [
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces",
          "content": "Hi! Soon Codeforces Round #234 (Div. 2) will take place, i am the author, Dmytro Berezin :)Thanks to Gerald Agapov (Gerald) for the help in round preparation, Maria Belova (Delinur) for tasks translations, Mike Mirzayanov (MikeMirzayanov) for perfect system, and Sergii Nagin (Sereja) for his agreement (to share his evening with me) to help in testing.Distribution will be announced as soon as found :) Standard :)Good luck!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10730",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 425
        },
        {
          "title": "Codeforces Round #234 (Div. 2) — Tutorial - Codeforces",
          "content": "400A — Inna and Choose OptionsNot difficult task. Let's iterate param a. If 12 % a != 0, continue. Calculate b = 12 / a. Let's iterate column (from 1 to b) and for each it's cell (i, j) check, if it contains X or not. Cell (i, j) — is ((i–1) * a + j) -th element of string.400B — Inna and New Matrix of CandiesIn the final version of statement we must choose all lines we haven't finish already. If it is a string where we have S...G — answer  - 1. Otherwise, the answer is the number of distinct distances, as one step kills all distances of the minimal length.400C — Inna and Huge Candy MatrixLet's note that the number of 90 clockwise make sence only by modulo 4. Horizontal — by modulo 2, and 90 counterclockwise — by modulo 4, and 1 such rotation is 3 clockwise rotations.90 clockwise: newi = j; newj = n–i + 1 don't forget to swap(n, m).Horizontal: newj = m–j + 1400D — Dima and BacteriaIf the distribution is correct, after deleting all ribs with cost more than 0 graph will transform to components of corrects size. Also, the nodes are numereted so we should turn dfs for the first node of each type and be sure that we receive exact all nodes of this type and no ohter.Now simple floyd warshall, and put in each cell of adjacent matrix of components the minimal weight between all ribs from 1 component to another.400E — Inna and Binary LogicLet's solve this for each bit separately. Fix some bit. Let's put 1 if the number contains bit and 0 otherwise. Now we receive the sequence, for example 11100111101.Now let's look on sequence of 1 without 0, for this sequence current bit will be added to the sum on the first stage (with all numbers single) on the second stage (with all neighbouring pairs) on the third stage and so on, the number of appiarence for sequence of neighbouring 1 is a formula which depends on the length of sequence only.The last is to learn how to modificate. For each bit let's save the set of sequence of 1. When the bit is deleted, one sequence is sepereted on two, or decreases its length by 1. When the bit is added, new sequence of length 1 appears, or some sequence increases its lentgh by 1 or two sequence transform to 1 biger sequence.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 400\\s*D"
          },
          "content_length": 2178
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 1",
          "code": "G....S\nG.S...\nG..S..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 2",
          "code": "G....S\nG.S...\nG..S..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 3",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 4",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 5",
          "code": "4 8\nG*S*****\n****G*S*\nG*****S*\n**G***S*",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 6",
          "code": "4 8\nG*S*****\n****G*S*\nG*****S*\n**G***S*",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 7",
          "code": "char p[1005]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 8",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 9",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 10",
          "code": "***O\n**GS\n*G*S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 11",
          "code": "***O\n**GS\n*G*S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 12",
          "code": "***O\n***O\n**GS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 13",
          "code": "***O\n***O\n**GS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 14",
          "code": "\"Should be disqualified!\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 15",
          "code": "\"Should be disqualified!\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 16",
          "code": "1 2 1\n 0 0\n  0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 17",
          "code": "1 2 1\n 0 0\n  0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) — Tutorial - Codeforces - Code 1",
          "code": "Time: 0 ms, memory: 972 KB\nVerdict: WRONG_ANSWER\nInput\n\n3 2 2\n2 1\n1 3 0\n3 2 0\n\nOutput\n\nNo\n\nAnswer\n\nYes\n0 0\n0 0\n\nChecker comment\n\nwrong answer 1st words differ - expected: 'Yes', found: 'No'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) — Tutorial - Codeforces - Code 2",
          "code": "Time: 0 ms, memory: 972 KB\nVerdict: WRONG_ANSWER\nInput\n\n3 2 2\n2 1\n1 3 0\n3 2 0\n\nOutput\n\nNo\n\nAnswer\n\nYes\n0 0\n0 0\n\nChecker comment\n\nwrong answer 1st words differ - expected: 'Yes', found: 'No'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10755",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000); // 1 ≤ n ≤ 1e5\n    inf.readSpace();\n    int m = inf.readInt(0, 100000); // 0 ≤ m ≤ 1e5\n    inf.readSpace();\n    int k = inf.readInt(1, 500); // 1 ≤ k ≤ 500\n    inf.readEoln();\n\n    vector<int> c(k);\n    int sum_c = 0;\n    for (int i = 0; i < k; i++) {\n        c[i] = inf.readInt(1, n); // 1 ≤ ci ≤ n\n        sum_c += c[i];\n        if (i < k - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n    ensuref(sum_c == n, \"Sum of ci must be equal to n\");\n\n    for (int i = 0; i < m; i++) {\n        int ui = inf.readInt(1, n);\n        inf.readSpace();\n        int vi = inf.readInt(1, n);\n        inf.readSpace();\n        int xi = inf.readInt(0, 10000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000); // 1 ≤ n ≤ 1e5\n    inf.readSpace();\n    int m = inf.readInt(0, 100000); // 0 ≤ m ≤ 1e5\n    inf.readSpace();\n    int k = inf.readInt(1, 500); // 1 ≤ k ≤ 500\n    inf.readEoln();\n\n    vector<int> c(k);\n    int sum_c = 0;\n    for (int i = 0; i < k; i++) {\n        c[i] = inf.readInt(1, n); // 1 ≤ ci ≤ n\n        sum_c += c[i];\n        if (i < k - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n    ensuref(sum_c == n, \"Sum of ci must be equal to n\");\n\n    for (int i = 0; i < m; i++) {\n        int ui = inf.readInt(1, n);\n        inf.readSpace();\n        int vi = inf.readInt(1, n);\n        inf.readSpace();\n        int xi = inf.readInt(0, 10000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000); // 1 ≤ n ≤ 1e5\n    inf.readSpace();\n    int m = inf.readInt(0, 100000); // 0 ≤ m ≤ 1e5\n    inf.readSpace();\n    int k = inf.readInt(1, 500); // 1 ≤ k ≤ 500\n    inf.readEoln();\n\n    vector<int> c(k);\n    int sum_c = 0;\n    for (int i = 0; i < k; i++) {\n        c[i] = inf.readInt(1, n); // 1 ≤ ci ≤ n\n        sum_c += c[i];\n        if (i < k - 1) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n    ensuref(sum_c == n, \"Sum of ci must be equal to n\");\n\n    for (int i = 0; i < m; i++) {\n        int ui = inf.readInt(1, n);\n        inf.readSpace();\n        int vi = inf.readInt(1, n);\n        inf.readSpace();\n        int xi = inf.readInt(0, 10000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n - 1);\n    int k = opt<int>(\"k\", 1);\n    string type = opt<string>(\"type\", \"random\");\n    int maxCost = opt<int>(\"maxCost\", 10000);\n\n    // Ensure constraints\n    ensure(1 <= n && n <= 100000);\n    ensure(0 <= m && m <= 100000);\n    ensure(1 <= k && k <= 500);\n    ensure(k <= n);\n\n    // Generate ci's ensuring ci ≥1 and sum ci = n\n    vector<int> ci(k, 1);\n    int total = k;\n    for (int i = 0; i < n - k; i++) {\n        ci[rnd.next(0, k - 1)]++;\n        total++;\n    }\n    // Assign bacteria indices per type\n    vector<pair<int, int>> typeRanges(k);\n    int idx = 1;\n    for (int i = 0; i < k; i++) {\n        typeRanges[i].first = idx;\n        typeRanges[i].second = idx + ci[i] - 1;\n        idx += ci[i];\n    }\n\n    vector<pair<int, pair<int, int>>> edges; // xi, {ui, vi}\n\n    if (type == \"connected_within_types\") {\n        // For each type, create a spanning tree among its bacteria with zero-cost edges\n        for (int i = 0; i < k; i++) {\n            int l = typeRanges[i].first;\n            int r = typeRanges[i].second;\n            vector<int> nodes;\n            for (int j = l; j <= r; j++) {\n                nodes.push_back(j);\n            }\n            // Create a tree among nodes\n            for (int j = 1; j < nodes.size(); j++) {\n                int u = nodes[j];\n                int v = nodes[rnd.next(0, j - 1)];\n                edges.push_back({0, {u, v}});\n            }\n        }\n        // Total required edges so far: n - k\n\n        int edgesNeeded = m - edges.size();\n        // Generate additional random edges with random costs\n        for (int i = 0; i < edgesNeeded; i++) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            int xi = rnd.next(0, maxCost);\n            edges.push_back({xi, {u, v}});\n        }\n    } else if (type == \"disconnected_within_types\") {\n        // Generate random edges with non-zero costs\n        for (int i = 0; i < m; i++) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            int xi = rnd.next(1, maxCost); // Costs are non-zero\n            edges.push_back({xi, {u, v}});\n        }\n    } else if (type == \"random\") {\n        // Generate m random edges with random costs\n        for (int i = 0; i < m; i++) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            int xi = rnd.next(0, maxCost);\n            edges.push_back({xi, {u, v}});\n        }\n    } else if (type == \"special_no\") {\n        // Generate a test case where type-distribution is incorrect\n        int edgesNeeded = m;\n\n        for (int i = 0; i < k; i++) {\n            int l = typeRanges[i].first;\n            int r = typeRanges[i].second;\n\n            vector<int> nodes;\n            for (int j = l; j <= r; j++) {\n                nodes.push_back(j);\n            }\n\n            if (nodes.size() >= 2) {\n                // Split into two groups\n                int mid = nodes.size() / 2;\n                vector<int> group1(nodes.begin(), nodes.begin() + mid);\n                vector<int> group2(nodes.begin() + mid, nodes.end());\n\n                // Connect within group1\n                for (int j = 1; j < group1.size(); j++) {\n                    int u = group1[j];\n                    int v = group1[rnd.next(0, j - 1)];\n                    edges.push_back({0, {u, v}});\n                }\n                // Connect within group2\n                for (int j = 1; j < group2.size(); j++) {\n                    int u = group2[j];\n                    int v = group2[rnd.next(0, j - 1)];\n                    edges.push_back({0, {u, v}});\n                }\n            }\n            // If only one node, nothing to connect\n        }\n\n        // Generate additional random edges if needed\n        while (edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            int xi = rnd.next(1, maxCost);\n            edges.push_back({xi, {u, v}});\n        }\n    } else {\n        // Default: Generate random edges\n        for (int i = 0; i < m; i++) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            int xi = rnd.next(0, maxCost);\n            edges.push_back({xi, {u, v}});\n        }\n    }\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, m, k);\n    // Output ci's\n    for (int i = 0; i < k; i++) {\n        printf(\"%d%c\", ci[i], (i + 1 == k) ? '\\n' : ' ');\n    }\n    // Output edges\n    for (size_t i = 0; i < edges.size(); i++) {\n        int xi = edges[i].first;\n        int ui = edges[i].second.first;\n        int vi = edges[i].second.second;\n        printf(\"%d %d %d\\n\", ui, vi, xi);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n - 1);\n    int k = opt<int>(\"k\", 1);\n    string type = opt<string>(\"type\", \"random\");\n    int maxCost = opt<int>(\"maxCost\", 10000);\n\n    // Ensure constraints\n    ensure(1 <= n && n <= 100000);\n    ensure(0 <= m && m <= 100000);\n    ensure(1 <= k && k <= 500);\n    ensure(k <= n);\n\n    // Generate ci's ensuring ci ≥1 and sum ci = n\n    vector<int> ci(k, 1);\n    int total = k;\n    for (int i = 0; i < n - k; i++) {\n        ci[rnd.next(0, k - 1)]++;\n        total++;\n    }\n    // Assign bacteria indices per type\n    vector<pair<int, int>> typeRanges(k);\n    int idx = 1;\n    for (int i = 0; i < k; i++) {\n        typeRanges[i].first = idx;\n        typeRanges[i].second = idx + ci[i] - 1;\n        idx += ci[i];\n    }\n\n    vector<pair<int, pair<int, int>>> edges; // xi, {ui, vi}\n\n    if (type == \"connected_within_types\") {\n        // For each type, create a spanning tree among its bacteria with zero-cost edges\n        for (int i = 0; i < k; i++) {\n            int l = typeRanges[i].first;\n            int r = typeRanges[i].second;\n            vector<int> nodes;\n            for (int j = l; j <= r; j++) {\n                nodes.push_back(j);\n            }\n            // Create a tree among nodes\n            for (int j = 1; j < nodes.size(); j++) {\n                int u = nodes[j];\n                int v = nodes[rnd.next(0, j - 1)];\n                edges.push_back({0, {u, v}});\n            }\n        }\n        // Total required edges so far: n - k\n\n        int edgesNeeded = m - edges.size();\n        // Generate additional random edges with random costs\n        for (int i = 0; i < edgesNeeded; i++) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            int xi = rnd.next(0, maxCost);\n            edges.push_back({xi, {u, v}});\n        }\n    } else if (type == \"disconnected_within_types\") {\n        // Generate random edges with non-zero costs\n        for (int i = 0; i < m; i++) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            int xi = rnd.next(1, maxCost); // Costs are non-zero\n            edges.push_back({xi, {u, v}});\n        }\n    } else if (type == \"random\") {\n        // Generate m random edges with random costs\n        for (int i = 0; i < m; i++) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            int xi = rnd.next(0, maxCost);\n            edges.push_back({xi, {u, v}});\n        }\n    } else if (type == \"special_no\") {\n        // Generate a test case where type-distribution is incorrect\n        int edgesNeeded = m;\n\n        for (int i = 0; i < k; i++) {\n            int l = typeRanges[i].first;\n            int r = typeRanges[i].second;\n\n            vector<int> nodes;\n            for (int j = l; j <= r; j++) {\n                nodes.push_back(j);\n            }\n\n            if (nodes.size() >= 2) {\n                // Split into two groups\n                int mid = nodes.size() / 2;\n                vector<int> group1(nodes.begin(), nodes.begin() + mid);\n                vector<int> group2(nodes.begin() + mid, nodes.end());\n\n                // Connect within group1\n                for (int j = 1; j < group1.size(); j++) {\n                    int u = group1[j];\n                    int v = group1[rnd.next(0, j - 1)];\n                    edges.push_back({0, {u, v}});\n                }\n                // Connect within group2\n                for (int j = 1; j < group2.size(); j++) {\n                    int u = group2[j];\n                    int v = group2[rnd.next(0, j - 1)];\n                    edges.push_back({0, {u, v}});\n                }\n            }\n            // If only one node, nothing to connect\n        }\n\n        // Generate additional random edges if needed\n        while (edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            int xi = rnd.next(1, maxCost);\n            edges.push_back({xi, {u, v}});\n        }\n    } else {\n        // Default: Generate random edges\n        for (int i = 0; i < m; i++) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            int xi = rnd.next(0, maxCost);\n            edges.push_back({xi, {u, v}});\n        }\n    }\n\n    // Output n m k\n    printf(\"%d %d %d\\n\", n, m, k);\n    // Output ci's\n    for (int i = 0; i < k; i++) {\n        printf(\"%d%c\", ci[i], (i + 1 == k) ? '\\n' : ' ');\n    }\n    // Output edges\n    for (size_t i = 0; i < edges.size(); i++) {\n        int xi = edges[i].first;\n        int ui = edges[i].second.first;\n        int vi = edges[i].second.second;\n        printf(\"%d %d %d\\n\", ui, vi, xi);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -m 0 -k 2 -type special_no\n./gen -n 3 -m 1 -k 2 -type random\n./gen -n 3 -m 2 -k 2 -type connected_within_types\n./gen -n 3 -m 2 -k 2 -type disconnected_within_types\n\n./gen -n 10 -m 9 -k 2 -type connected_within_types\n./gen -n 10 -m 15 -k 2 -type special_no\n./gen -n 10 -m 20 -k 2 -type random\n./gen -n 10 -m 20 -k 2 -type disconnected_within_types\n\n./gen -n 100 -m 99 -k 2 -type connected_within_types\n./gen -n 100 -m 200 -k 5 -type random\n./gen -n 100 -m 50 -k 10 -type disconnected_within_types\n\n./gen -n 1000 -m 999 -k 100 -type connected_within_types\n./gen -n 1000 -m 500 -k 100 -type disconnected_within_types\n./gen -n 1000 -m 2000 -k 100 -type random\n\n./gen -n 10000 -m 9999 -k 200 -type connected_within_types\n./gen -n 10000 -m 100000 -k 200 -type random\n./gen -n 10000 -m 5000 -k 200 -type disconnected_within_types\n\n./gen -n 100000 -m 99999 -k 500 -type connected_within_types\n./gen -n 100000 -m 100000 -k 500 -type random\n./gen -n 100000 -m 50000 -k 500 -type disconnected_within_types\n\n./gen -n 100000 -m 0 -k 400 -type special_no\n./gen -n 100000 -m 0 -k 1 -type special_no\n\n./gen -n 100000 -m 99999 -k 1 -type connected_within_types\n\n./gen -n 100000 -m 100000 -k 1 -type random\n./gen -n 100000 -m 0 -k 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:25.675524",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "400/E",
      "title": "E. Инна и бинарная логика",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка входных данных содержит два целых числа n и m (1 ≤ n, m ≤ 105) — количество элементов в массиве a1 и количество запросов Димы. Следующая строка содержит n целых чисел a1[1], a1[2], ..., a1[n] (0 ≤ ai ≤ 105) — изначальные элементы массива.В каждой из следующих m строк записана пара целых чисел — описание запросов Димы. Каждый запрос характеризуется двумя целыми числами pi, vi (1 ≤ pi ≤ n; 0 ≤ vi ≤ 105). В ответ на этот запрос Инна должна элемент a1[pi] сделать равным числу vi. Обратите внимание, изменения сохраняются от запроса к запросу.",
      "output_spec": "Выходные данныеВыведите m строк. Для каждого запроса на изменение массива выведите сумму всех чисел, которые выпишет Инна, если будет выполнять упражнение над текущим массивом, в отдельной строке.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 41 1 11 12 23 21 2Выходные данныеСкопировать64712",
      "description": "E. Инна и бинарная логика\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка входных данных содержит два целых числа n и m (1 ≤ n, m ≤ 105) — количество элементов в массиве a1 и количество запросов Димы. Следующая строка содержит n целых чисел a1[1], a1[2], ..., a1[n] (0 ≤ ai ≤ 105) — изначальные элементы массива.В каждой из следующих m строк записана пара целых чисел — описание запросов Димы. Каждый запрос характеризуется двумя целыми числами pi, vi (1 ≤ pi ≤ n; 0 ≤ vi ≤ 105). В ответ на этот запрос Инна должна элемент a1[pi] сделать равным числу vi. Обратите внимание, изменения сохраняются от запроса к запросу.\n\nВходные данные\n\nВыходные данныеВыведите m строк. Для каждого запроса на изменение массива выведите сумму всех чисел, которые выпишет Инна, если будет выполнять упражнение над текущим массивом, в отдельной строке.\n\nВыходные данные\n\nВходные данныеСкопировать3 41 1 11 12 23 21 2Выходные данныеСкопировать64712\n\nВходные данныеСкопировать3 41 1 11 12 23 21 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать64712\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces",
          "content": "Всем привет! Хотите вы, или нет, но скоро состоится Codeforces Round #234 (Div. 2) автором которого являюсь я :)Большое спасибо Геральду Агапову (Gerald) за помощь в подготовке раунда, Марии Беловой (Delinur) за перевод задач, Михаилу Мирзаянову (MikeMirzayanov) за превосходную систему, и Сереже Нагину (Sereja) за то, что любезно (поделился со мной картошкой и беконом, было очень вкусно) согласился помочь в тестировании.Разбалловку оглашу сразу, как найду. Нашел! Стандартная :)Всем удачи :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10730",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 495
        },
        {
          "title": "Codeforces Round #234 (Div. 2) — разбор - Codeforces",
          "content": "400A — Инна и право выбораНе сложная задача на перебор. Переберем параметр a. Если 12 не кратно a, пропустим. Вычислим b = 12 / a. Переберем столбец (от 1 до b) и для всех его клеточек (i, j) проверим, стоит ли там X. Клеточка (i, j) — это ((i–1) * a + j) -ый элемент строки.400B — Инна и новая матрица конфетВ остаточной постановке задачи выбираются все линии, в которых еще не победили. Если есть строка, где гномик уже правее конфеты — ответ -1. Иначе, ответ – количество разных расстояний, так как за один ход убиваются все расстояния минимальной величины.400C — Инна и гигантская матрица конфетЗаметим, что повороты по часовой можно брать по модулю 4. Горизонтальный — по модулю 2, а против часовой — по модулю 4, причем 1 такой поворот — это 3 поворота по часовой.Поворот по часовой: newi = j; newj = n–i + 1 не забываем swap(n, m).Поворот горизонтальный: newj = m–j + 1400D — Дима и бактерииЕсли расклад правильный, то после удаления всех ненулевых ребер наш граф распадется на компоненты соответствующих размеров. Проверим это. Да, заметим, что вершины пронумерованы, так что необходимо проверять, что из запустив дфс из первой вершины каждого типа, мы получим ровно все вершины нашего типа (их номера и кол-во нам известно) и никакие другие.Теперь можем запустить обычного флойда-уоршала, поставив в матрицу смежности для двух компонент наименьшее из рёбер, ведущих из одной компоненты в другую.400E — Инна и бинарная логикаБудем решать задачу побитово. Зафиксируем какой-то бит. Поставим числу 1, если бит имеется, и 0, если нет. Получили последовательность, к примеру, 11100111101.Возьмем кучку из последовательных единиц, для нее бит войдет в операциях над каждым из этих чисел на первом этапе, на втором, и на этапе с номером размера кучки.Осталось научится поддерживать модификацию. Для каждого бита будем держать сет кучек из единиц. При «выпадении» бита, одна кучка либо распадается на две, либо уменьшается на 1. При добавлении, одна кучка появляется, либо вырастает на 1, либо две соседние кучки срастаются.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 400\\s*E"
          },
          "content_length": 2025
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 1",
          "code": "G....S\nG.S...\nG..S..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 2",
          "code": "G....S\nG.S...\nG..S..",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 3",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 4",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 5",
          "code": "4 8\nG*S*****\n****G*S*\nG*****S*\n**G***S*",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 6",
          "code": "4 8\nG*S*****\n****G*S*\nG*****S*\n**G***S*",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 7",
          "code": "char p[1005]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 8",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 9",
          "code": "3 4\n**GS\n*G*S\nG**S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 10",
          "code": "***O\n**GS\n*G*S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 11",
          "code": "***O\n**GS\n*G*S",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 12",
          "code": "***O\n***O\n**GS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 13",
          "code": "***O\n***O\n**GS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 14",
          "code": "\"Should be disqualified!\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 15",
          "code": "\"Should be disqualified!\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 16",
          "code": "1 2 1\n 0 0\n  0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 17",
          "code": "1 2 1\n 0 0\n  0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 18",
          "code": "Wrong Answer on test 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 19",
          "code": "3 4\nG**S\n*G*S\n**GS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) - Codeforces - Code 20",
          "code": "3 4\nG**S\n*G*S\n**GS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10730",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) — разбор - Codeforces - Code 1",
          "code": "4 8\nG*S*****\n****G*S*\nG*****S*\n**G***S*\nОтвет: 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) — разбор - Codeforces - Code 2",
          "code": "4 8\nG*S*****\n****G*S*\nG*****S*\n**G***S*\nОтвет: 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) — разбор - Codeforces - Code 3",
          "code": "for i:=0 to 501 do\n        parent[i]:=i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) — разбор - Codeforces - Code 4",
          "code": "for i:=0 to 501 do\n        parent[i]:=i;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) — разбор - Codeforces - Code 5",
          "code": "Time: 0 ms, memory: 972 KB\nVerdict: WRONG_ANSWER\nInput\n\n3 2 2\n2 1\n1 3 0\n3 2 0\n\nOutput\n\nNo\n\nAnswer\n\nYes\n0 0\n0 0\n\nChecker comment\n\nwrong answer 1st words differ - expected: 'Yes', found: 'No'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #234 (Div. 2) — разбор - Codeforces - Code 6",
          "code": "Time: 0 ms, memory: 972 KB\nVerdict: WRONG_ANSWER\nInput\n\n3 2 2\n2 1\n1 3 0\n3 2 0\n\nOutput\n\nNo\n\nAnswer\n\nYes\n0 0\n0 0\n\nChecker comment\n\nwrong answer 1st words differ - expected: 'Yes', found: 'No'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10755",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100000, \"a\");\n    inf.readEoln();\n    \n    for (int i = 0; i < m; ++i) {\n        int pi = inf.readInt(1, n, \"pi\");\n        inf.readSpace();\n        int vi = inf.readInt(0, 100000, \"vi\");\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100000, \"a\");\n    inf.readEoln();\n    \n    for (int i = 0; i < m; ++i) {\n        int pi = inf.readInt(1, n, \"pi\");\n        inf.readSpace();\n        int vi = inf.readInt(0, 100000, \"vi\");\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100000, \"a\");\n    inf.readEoln();\n    \n    for (int i = 0; i < m; ++i) {\n        int pi = inf.readInt(1, n, \"pi\");\n        inf.readSpace();\n        int vi = inf.readInt(0, 100000, \"vi\");\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n    int val = opt<int>(\"val\", 0);\n\n    // Generate initial array a1[1..n] according to 'type'\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 100000);\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 100000;\n    } else if (type == \"min\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"same\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"sequence\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = i % 100001;\n    } else if (type == \"powers\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1 << rnd.next(0, 16);\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 100000);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Generate m queries according to 'qtype'\n    vector<pair<int,int>> queries(m);\n\n    if (qtype == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int pi = rnd.next(1, n);\n            int vi = rnd.next(0, 100000);\n            queries[i] = make_pair(pi, vi);\n        }\n    } else if (qtype == \"nochange\") {\n        for (int i = 0; i < m; ++i) {\n            int pi = rnd.next(1, n);\n            int vi = a[pi - 1]; // set to current value\n            queries[i] = make_pair(pi, vi);\n        }\n    } else if (qtype == \"samepos\") {\n        int pi = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            int vi = rnd.next(0, 100000);\n            queries[i] = make_pair(pi, vi);\n        }\n    } else if (qtype == \"inorder\") {\n        for (int i = 0; i < m; ++i) {\n            int pi = (i % n) + 1;\n            int vi = rnd.next(0, 100000);\n            queries[i] = make_pair(pi, vi);\n        }\n    } else if (qtype == \"maxval\") {\n        for (int i = 0; i < m; ++i) {\n            int pi = rnd.next(1, n);\n            int vi = 100000;\n            queries[i] = make_pair(pi, vi);\n        }\n    } else if (qtype == \"minval\") {\n        for (int i = 0; i < m; ++i) {\n            int pi = rnd.next(1, n);\n            int vi = 0;\n            queries[i] = make_pair(pi, vi);\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < m; ++i) {\n            int pi = rnd.next(1, n);\n            int vi = rnd.next(0, 100000);\n            queries[i] = make_pair(pi, vi);\n        }\n    }\n\n    // Output queries\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n    int val = opt<int>(\"val\", 0);\n\n    // Generate initial array a1[1..n] according to 'type'\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 100000);\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 100000;\n    } else if (type == \"min\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"same\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"sequence\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = i % 100001;\n    } else if (type == \"powers\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 1 << rnd.next(0, 16);\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 100000);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Generate m queries according to 'qtype'\n    vector<pair<int,int>> queries(m);\n\n    if (qtype == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int pi = rnd.next(1, n);\n            int vi = rnd.next(0, 100000);\n            queries[i] = make_pair(pi, vi);\n        }\n    } else if (qtype == \"nochange\") {\n        for (int i = 0; i < m; ++i) {\n            int pi = rnd.next(1, n);\n            int vi = a[pi - 1]; // set to current value\n            queries[i] = make_pair(pi, vi);\n        }\n    } else if (qtype == \"samepos\") {\n        int pi = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            int vi = rnd.next(0, 100000);\n            queries[i] = make_pair(pi, vi);\n        }\n    } else if (qtype == \"inorder\") {\n        for (int i = 0; i < m; ++i) {\n            int pi = (i % n) + 1;\n            int vi = rnd.next(0, 100000);\n            queries[i] = make_pair(pi, vi);\n        }\n    } else if (qtype == \"maxval\") {\n        for (int i = 0; i < m; ++i) {\n            int pi = rnd.next(1, n);\n            int vi = 100000;\n            queries[i] = make_pair(pi, vi);\n        }\n    } else if (qtype == \"minval\") {\n        for (int i = 0; i < m; ++i) {\n            int pi = rnd.next(1, n);\n            int vi = 0;\n            queries[i] = make_pair(pi, vi);\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < m; ++i) {\n            int pi = rnd.next(1, n);\n            int vi = rnd.next(0, 100000);\n            queries[i] = make_pair(pi, vi);\n        }\n    }\n\n    // Output queries\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random -qtype random\n\n./gen -n 1 -m 1 -type max -qtype random\n\n./gen -n 10 -m 5 -type random -qtype random\n\n./gen -n 100000 -m 100000 -type random -qtype random\n\n./gen -n 100000 -m 100000 -type max -qtype maxval\n\n./gen -n 100000 -m 100000 -type min -qtype minval\n\n./gen -n 100000 -m 100000 -type same -val 12345 -qtype samepos\n\n./gen -n 99999 -m 100000 -type sequence -qtype inorder\n\n./gen -n 100000 -m 100000 -type powers -qtype random\n\n./gen -n 100000 -m 100000 -type sequence -qtype random\n\n./gen -n 2 -m 100000 -type random -qtype random\n\n./gen -n 100000 -m 1 -type random -qtype random\n\n./gen -n 1 -m 100000 -type random -qtype random\n\n./gen -n 100000 -m 100000 -type random -qtype samepos\n\n./gen -n 100000 -m 100000 -type random -qtype nochange\n\n./gen -n 100000 -m 100000 -type max -qtype minval\n\n./gen -n 100000 -m 100000 -type min -qtype maxval\n\n./gen -n 100000 -m 100000 -type same -val 65536 -qtype random\n\n./gen -n 100000 -m 100000 -type same -val 0 -qtype random\n\n./gen -n 100000 -m 100000 -type same -val 100000 -qtype random\n\n./gen -n 100000 -m 100000 -type powers -qtype samepos\n\n./gen -n 100000 -m 100000 -type random -qtype maxval\n\n./gen -n 100000 -m 100000 -type random -qtype minval\n\n./gen -n 100000 -m 10 -type random -qtype random\n\n./gen -n 10 -m 100000 -type random -qtype random\n\n./gen -n 99999 -m 100000 -type sequence -qtype random\n\n./gen -n 100000 -m 100000 -type min -qtype random\n\n./gen -n 50000 -m 50000 -type sequence -qtype random\n\n./gen -n 50000 -m 50000 -type random -qtype random\n\n./gen -n 100000 -m 100000 -type same -val 1 -qtype random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:28.259041",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "401/A",
      "title": "A. Vanya and Cards",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers: n (1 ≤ n ≤ 1000) — the number of found cards and x (1 ≤ x ≤ 1000) — the maximum absolute value of the number on a card. The second line contains n space-separated integers — the numbers on found cards. It is guaranteed that the numbers do not exceed x in their absolute value.",
      "output_spec": "OutputPrint a single number — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy3 2-1 1 2OutputCopy1InputCopy2 3-2 -2OutputCopy2",
      "description": "A. Vanya and Cards\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers: n (1 ≤ n ≤ 1000) — the number of found cards and x (1 ≤ x ≤ 1000) — the maximum absolute value of the number on a card. The second line contains n space-separated integers — the numbers on found cards. It is guaranteed that the numbers do not exceed x in their absolute value.\n\nOutputPrint a single number — the answer to the problem.\n\nInputCopy3 2-1 1 2OutputCopy1InputCopy2 3-2 -2OutputCopy2\n\nInputCopy3 2-1 1 2\n\nOutputCopy1\n\nInputCopy2 3-2 -2\n\nOutputCopy2\n\nNoteIn the first sample, Vanya needs to find a single card with number -2.In the second sample, Vanya needs to find two cards with number 2. He can't find a single card with the required number as the numbers on the lost cards do not exceed 3 in their absolute value.",
      "solutions": [
        {
          "title": "Codeforces Round #235 (Div. 2) - Codeforces",
          "content": "Hello everyone!Codeforces Round #235 (Div. 2) will take place on March 10th at 19:30 MSK. This is my first Codeforces round and I hope not the last one.I'd like to thank Gerald Agapov (Gerald), Roman Rubanenko (Rubanenko), Sergey Oryshych (Oryshych) for helping me to prepare round, and Mariya Belova for translation of all problem statements into English.Scoring: 500-1000-1500-2000-2500GL & HF!Top five: UESTC_XHXJ GoodByeAhu OrzSKYDEC simonlindholm angelyue Congratulations of participant hoanglmdiv2, who solved the problem E.Unfortunately, my fault, in the round hit the problem that was previously used on another competition. Since it does not comply Codeforces, problem E will be deleted.English tutorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10786",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 712
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces",
          "content": "Problem АWe must sum all numbers, and reduced it to zero by the operations +x and -x.Solution АProblem BYou must identify the array of numbers contests that remember Sereja, as employed. If we want to find maximal answer, we must count the number of immune cells. If we want to find mininum answer, we must do the following:if i-th element is free and (i+1)-th element is free, and i<x then we using round type of \"Div1+Div2\" and answer++, i-th and (i+1)-th elements define as employed. if i-th element is free and (i+1)-th element is employed then we usign round type \"Div2\" and answer++, i-th element define as employed. Solution BProblem Cn — the number of cards containing number 0 and m — the number of cards containing number 1. We have answer, when ((n-1)<=m && m <= 2 * (n + 1)). If we have answer then we must do the following: if (m == n - 1) then we derive the ones and zeros in one, but we must start from zero. if (m == n) then we derive the ones and zeros in one. if (m > n && m <= 2 * (n + 1)) then we must start form one and we derive the ones and zeros in one, but in the end must be one. And if we in the end and we have ones, then we try to stick to one unit so that we have. For example, we have 10101 and two ones, after we have 110101 and one ones, and then we have 1101101. Solution СProblem DThis problem we can be attributed to the dynamic programming. We must using mask and dynamic.We have dynamic dp[i][x], when i — mask of reshuffle and x — remainder on dividing by m.if we want to add number a[j], we must using it: dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] := dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] + dp[i,x];In the end we must answer to divide by the factorial number of occurrences of each digit. for i:=0 to 9 do\n\n for j:=2 to b[i] do\n\n ans:=ans div int64(j);Solution DProblem EIf first participant of the contest will contain at point (x1;y1) and second participant of the contest will contain at point (x2;y2), then we need to satisfy two conditions: L*L <= (abs(x1-x2)*abs(x1-x2) + abs(y1-y2)*abs(y1-y2)) <= R*R gcd(abs(x1-x2),abs(y1-y2)) == 1 Since the hall can potentially be of size 100,000 x 100,000, even considering each possible size of R or L once will take too much time. And if we iterate value abs(x1-x2) and iterate value abs(y1-y2) then it will take much time too. But if we iterate only value abs(x1-x2) we can find confines of value abs(y1-y2). We can do so: L*L<=(abs(x1-x2)*abs(x1-x2)+abs(y1-y2)*abs(y1-y2))<=R*R L*L - abs(x1-x2)*abs(x1-x2) <= abs(y1-y2)*abs(y1-y2) <= R*R - abs(x1-x2)*abs(x1-x2) Number of options to place the square in hall n*m will be (n-abs(x1-x2)+1)*(m-abs(y1-y2)+1). The first quantity is easy to obtain, while the second requires a little more work. To calculate the second quantity, we note that, although w could have a large variety of prime divisors, it does not have very many of them. This important insight allows us to quickly find the sum: we find the prime factors of w, then we use the inclusion-exclusion principle to calculate the sum of all numbers between L and R that are divisible by at least one of the numbers.Unfortunately, my fault, in the round hit the problem that was previously used on another competition. Since it does not comply Codeforces, problem E will be deleted.Solution ESorry for my English.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3305
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #235 (Div. 2) - Codeforces - Code 1",
          "code": "int n;\ncin>>n;\nint a[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10786",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) - Codeforces - Code 2",
          "code": "int n;\ncin>>n;\nint a[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10786",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 1",
          "code": "((n-1)<=m && m <= 2 * (n + 1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 2",
          "code": "(m == n - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 3",
          "code": "(m > n && m <= 2 * (n + 1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 4",
          "code": "dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] := dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] + dp[i,x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 5",
          "code": "dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] := dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] + dp[i,x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 6",
          "code": "for i:=0 to 9 do\n\n   for j:=2 to b[i] do\n\n     ans:=ans div int64(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 7",
          "code": "for i:=0 to 9 do\n\n   for j:=2 to b[i] do\n\n     ans:=ans div int64(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 8",
          "code": "L*L <= (abs(x1-x2)*abs(x1-x2) + abs(y1-y2)*abs(y1-y2)) <= R*R",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 9",
          "code": "gcd(abs(x1-x2),abs(y1-y2)) == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 10",
          "code": "L*L<=(abs(x1-x2)*abs(x1-x2)+abs(y1-y2)*abs(y1-y2))<=R*R",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 11",
          "code": "L*L - abs(x1-x2)*abs(x1-x2) <= abs(y1-y2)*abs(y1-y2) <= R*R - abs(x1-x2)*abs(x1-x2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 12",
          "code": "(n-abs(x1-x2)+1)*(m-abs(y1-y2)+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 13",
          "code": "i goes from 0 to 2^l-1\n\tj goes from 0 to l-1\n\t\tx goes from 0 to m-1\n\t\t\tdp [i | (1 << (j-1))] [(x*10+a[j]) mod m] += dp[i][x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 14",
          "code": "i goes from 0 to 2^l-1\n\tj goes from 0 to l-1\n\t\tx goes from 0 to m-1\n\t\t\tdp [i | (1 << (j-1))] [(x*10+a[j]) mod m] += dp[i][x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 15",
          "code": "for(int i=1;i<2^l;i++)\n        for(int j=0;j<m;j++)\n        {\n            if(!dp[i][j])continue;\n            for(int k=0;k<l;k++)\n                if(!(i&(1<<k)))\n                    dp[i|(1<<k)][(j*10+f[k])%m]+=dp[i][j];\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 16",
          "code": "for(int i=1;i<2^l;i++)\n        for(int j=0;j<m;j++)\n        {\n            if(!dp[i][j])continue;\n            for(int k=0;k<l;k++)\n                if(!(i&(1<<k)))\n                    dp[i|(1<<k)][(j*10+f[k])%m]+=dp[i][j];\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 17",
          "code": "wrong answer. The number of ones should be 4, but found 5; The number of zeros should be 3, but found 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000, \"x\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -x, x, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000, \"x\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -x, x, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000, \"x\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -x, x, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    string sumType = opt<string>(\"sumType\", \"random\");\n\n    int S = 0; // Desired sum of the numbers\n\n    if (sumType == \"zero_sum\") {\n        S = 0;\n    } else if (sumType == \"max_positive\") {\n        S = n * x;\n    } else if (sumType == \"max_negative\") {\n        S = -n * x;\n    } else if (sumType == \"large_positive\") {\n        S = int(0.9 * n * x);\n    } else if (sumType == \"large_negative\") {\n        S = int(-0.9 * n * x);\n    } else if (sumType == \"near_zero\") {\n        S = rnd.next(-x, x);\n    } else if (sumType == \"custom\") {\n        S = opt<int>(\"S\");\n    } else { // sumType == \"random\"\n        S = rnd.next(-n * x, n * x);\n    }\n\n    // Generate n numbers in [-x, x] that sum up to S\n    vector<int> a(n);\n    int remaining_sum = S;\n    for (int i = 0; i < n; ++i) {\n        int remaining_numbers = n - i - 1;\n        int min_value = max(-x, remaining_sum - remaining_numbers * x);\n        int max_value = min(x, remaining_sum - remaining_numbers * (-x));\n        a[i] = rnd.next(min_value, max_value);\n        remaining_sum -= a[i];\n    }\n\n    // Output n and x\n    printf(\"%d %d\\n\", n, x);\n\n    // Output the numbers\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int x = opt<int>(\"x\");\n    string sumType = opt<string>(\"sumType\", \"random\");\n\n    int S = 0; // Desired sum of the numbers\n\n    if (sumType == \"zero_sum\") {\n        S = 0;\n    } else if (sumType == \"max_positive\") {\n        S = n * x;\n    } else if (sumType == \"max_negative\") {\n        S = -n * x;\n    } else if (sumType == \"large_positive\") {\n        S = int(0.9 * n * x);\n    } else if (sumType == \"large_negative\") {\n        S = int(-0.9 * n * x);\n    } else if (sumType == \"near_zero\") {\n        S = rnd.next(-x, x);\n    } else if (sumType == \"custom\") {\n        S = opt<int>(\"S\");\n    } else { // sumType == \"random\"\n        S = rnd.next(-n * x, n * x);\n    }\n\n    // Generate n numbers in [-x, x] that sum up to S\n    vector<int> a(n);\n    int remaining_sum = S;\n    for (int i = 0; i < n; ++i) {\n        int remaining_numbers = n - i - 1;\n        int min_value = max(-x, remaining_sum - remaining_numbers * x);\n        int max_value = min(x, remaining_sum - remaining_numbers * (-x));\n        a[i] = rnd.next(min_value, max_value);\n        remaining_sum -= a[i];\n    }\n\n    // Output n and x\n    printf(\"%d %d\\n\", n, x);\n\n    // Output the numbers\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -x 100 -sumType zero_sum\n./gen -n 10 -x 100 -sumType max_positive\n./gen -n 10 -x 100 -sumType max_negative\n./gen -n 10 -x 100 -sumType large_positive\n./gen -n 10 -x 100 -sumType large_negative\n./gen -n 10 -x 100 -sumType near_zero\n./gen -n 10 -x 100 -sumType random\n\n./gen -n 1000 -x 1000 -sumType zero_sum\n./gen -n 1000 -x 1000 -sumType max_positive\n./gen -n 1000 -x 1000 -sumType max_negative\n./gen -n 1000 -x 1000 -sumType large_positive\n./gen -n 1000 -x 1000 -sumType large_negative\n./gen -n 1000 -x 1000 -sumType near_zero\n./gen -n 1000 -x 1000 -sumType random\n\n./gen -n 1 -x 1 -sumType zero_sum\n./gen -n 1 -x 1 -sumType max_positive\n\n./gen -n 2 -x 1 -sumType near_zero\n\n# Special cases where the sum is not divisible by x\n./gen -n 10 -x 3 -sumType custom -S 10\n./gen -n 10 -x 3 -sumType custom -S -10\n\n# Cases where x is small, n is large\n./gen -n 1000 -x 1 -sumType random\n./gen -n 1000 -x 10 -sumType random\n\n# Cases where the sum is not zero but |S| ≤ x\n./gen -n 100 -x 100 -sumType custom -S 50\n./gen -n 100 -x 100 -sumType custom -S -50\n\n# Extreme cases\n./gen -n 1000 -x 1000 -sumType custom -S 999999\n./gen -n 1000 -x 1000 -sumType custom -S -999999\n\n# Edge cases\n./gen -n 1 -x 1000 -sumType random\n./gen -n 1000 -x 1 -sumType zero_sum\n\n./gen -n 500 -x 500 -sumType random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:30.600623",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "401/B",
      "title": "B. Sereja and Contests",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers: x (1 ≤ x ≤ 4000) — the round Sereja is taking part in today, and k (0 ≤ k < 4000) — the number of rounds he took part in.Next k lines contain the descriptions of the rounds that Sereja took part in before. If Sereja took part in one of two simultaneous rounds, the corresponding line looks like: \"1 num2 num1\" (where num2 is the identifier of this Div2 round, num1 is the identifier of the Div1 round). It is guaranteed that num1 - num2 = 1. If Sereja took part in a usual Div2 round, then the corresponding line looks like: \"2 num\" (where num is the identifier of this Div2 round). It is guaranteed that the identifiers of all given rounds are less than x.",
      "output_spec": "OutputPrint in a single line two integers — the minimum and the maximum number of rounds that Sereja could have missed.",
      "sample_tests": "ExamplesInputCopy3 22 12 2OutputCopy0 0InputCopy9 31 2 32 81 4 5OutputCopy2 3InputCopy10 0OutputCopy5 9",
      "description": "B. Sereja and Contests\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers: x (1 ≤ x ≤ 4000) — the round Sereja is taking part in today, and k (0 ≤ k < 4000) — the number of rounds he took part in.Next k lines contain the descriptions of the rounds that Sereja took part in before. If Sereja took part in one of two simultaneous rounds, the corresponding line looks like: \"1 num2 num1\" (where num2 is the identifier of this Div2 round, num1 is the identifier of the Div1 round). It is guaranteed that num1 - num2 = 1. If Sereja took part in a usual Div2 round, then the corresponding line looks like: \"2 num\" (where num is the identifier of this Div2 round). It is guaranteed that the identifiers of all given rounds are less than x.\n\nOutputPrint in a single line two integers — the minimum and the maximum number of rounds that Sereja could have missed.\n\nInputCopy3 22 12 2OutputCopy0 0InputCopy9 31 2 32 81 4 5OutputCopy2 3InputCopy10 0OutputCopy5 9\n\nInputCopy3 22 12 2\n\nOutputCopy0 0\n\nInputCopy9 31 2 32 81 4 5\n\nOutputCopy2 3\n\nInputCopy10 0\n\nOutputCopy5 9\n\nNoteIn the second sample we have unused identifiers of rounds 1, 6, 7. The minimum number of rounds Sereja could have missed equals to 2. In this case, the round with the identifier 1 will be a usual Div2 round and the round with identifier 6 will be synchronous with the Div1 round. The maximum number of rounds equals 3. In this case all unused identifiers belong to usual Div2 rounds.",
      "solutions": [
        {
          "title": "Codeforces Round #235 (Div. 2) - Codeforces",
          "content": "Hello everyone!Codeforces Round #235 (Div. 2) will take place on March 10th at 19:30 MSK. This is my first Codeforces round and I hope not the last one.I'd like to thank Gerald Agapov (Gerald), Roman Rubanenko (Rubanenko), Sergey Oryshych (Oryshych) for helping me to prepare round, and Mariya Belova for translation of all problem statements into English.Scoring: 500-1000-1500-2000-2500GL & HF!Top five: UESTC_XHXJ GoodByeAhu OrzSKYDEC simonlindholm angelyue Congratulations of participant hoanglmdiv2, who solved the problem E.Unfortunately, my fault, in the round hit the problem that was previously used on another competition. Since it does not comply Codeforces, problem E will be deleted.English tutorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10786",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 712
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces",
          "content": "Problem АWe must sum all numbers, and reduced it to zero by the operations +x and -x.Solution АProblem BYou must identify the array of numbers contests that remember Sereja, as employed. If we want to find maximal answer, we must count the number of immune cells. If we want to find mininum answer, we must do the following:if i-th element is free and (i+1)-th element is free, and i<x then we using round type of \"Div1+Div2\" and answer++, i-th and (i+1)-th elements define as employed. if i-th element is free and (i+1)-th element is employed then we usign round type \"Div2\" and answer++, i-th element define as employed. Solution BProblem Cn — the number of cards containing number 0 and m — the number of cards containing number 1. We have answer, when ((n-1)<=m && m <= 2 * (n + 1)). If we have answer then we must do the following: if (m == n - 1) then we derive the ones and zeros in one, but we must start from zero. if (m == n) then we derive the ones and zeros in one. if (m > n && m <= 2 * (n + 1)) then we must start form one and we derive the ones and zeros in one, but in the end must be one. And if we in the end and we have ones, then we try to stick to one unit so that we have. For example, we have 10101 and two ones, after we have 110101 and one ones, and then we have 1101101. Solution СProblem DThis problem we can be attributed to the dynamic programming. We must using mask and dynamic.We have dynamic dp[i][x], when i — mask of reshuffle and x — remainder on dividing by m.if we want to add number a[j], we must using it: dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] := dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] + dp[i,x];In the end we must answer to divide by the factorial number of occurrences of each digit. for i:=0 to 9 do\n\n for j:=2 to b[i] do\n\n ans:=ans div int64(j);Solution DProblem EIf first participant of the contest will contain at point (x1;y1) and second participant of the contest will contain at point (x2;y2), then we need to satisfy two conditions: L*L <= (abs(x1-x2)*abs(x1-x2) + abs(y1-y2)*abs(y1-y2)) <= R*R gcd(abs(x1-x2),abs(y1-y2)) == 1 Since the hall can potentially be of size 100,000 x 100,000, even considering each possible size of R or L once will take too much time. And if we iterate value abs(x1-x2) and iterate value abs(y1-y2) then it will take much time too. But if we iterate only value abs(x1-x2) we can find confines of value abs(y1-y2). We can do so: L*L<=(abs(x1-x2)*abs(x1-x2)+abs(y1-y2)*abs(y1-y2))<=R*R L*L - abs(x1-x2)*abs(x1-x2) <= abs(y1-y2)*abs(y1-y2) <= R*R - abs(x1-x2)*abs(x1-x2) Number of options to place the square in hall n*m will be (n-abs(x1-x2)+1)*(m-abs(y1-y2)+1). The first quantity is easy to obtain, while the second requires a little more work. To calculate the second quantity, we note that, although w could have a large variety of prime divisors, it does not have very many of them. This important insight allows us to quickly find the sum: we find the prime factors of w, then we use the inclusion-exclusion principle to calculate the sum of all numbers between L and R that are divisible by at least one of the numbers.Unfortunately, my fault, in the round hit the problem that was previously used on another competition. Since it does not comply Codeforces, problem E will be deleted.Solution ESorry for my English.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3305
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #235 (Div. 2) - Codeforces - Code 1",
          "code": "int n;\ncin>>n;\nint a[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10786",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) - Codeforces - Code 2",
          "code": "int n;\ncin>>n;\nint a[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10786",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 1",
          "code": "((n-1)<=m && m <= 2 * (n + 1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 2",
          "code": "(m == n - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 3",
          "code": "(m > n && m <= 2 * (n + 1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 4",
          "code": "dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] := dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] + dp[i,x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 5",
          "code": "dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] := dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] + dp[i,x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 6",
          "code": "for i:=0 to 9 do\n\n   for j:=2 to b[i] do\n\n     ans:=ans div int64(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 7",
          "code": "for i:=0 to 9 do\n\n   for j:=2 to b[i] do\n\n     ans:=ans div int64(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 8",
          "code": "L*L <= (abs(x1-x2)*abs(x1-x2) + abs(y1-y2)*abs(y1-y2)) <= R*R",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 9",
          "code": "gcd(abs(x1-x2),abs(y1-y2)) == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 10",
          "code": "L*L<=(abs(x1-x2)*abs(x1-x2)+abs(y1-y2)*abs(y1-y2))<=R*R",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 11",
          "code": "L*L - abs(x1-x2)*abs(x1-x2) <= abs(y1-y2)*abs(y1-y2) <= R*R - abs(x1-x2)*abs(x1-x2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 12",
          "code": "(n-abs(x1-x2)+1)*(m-abs(y1-y2)+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 13",
          "code": "i goes from 0 to 2^l-1\n\tj goes from 0 to l-1\n\t\tx goes from 0 to m-1\n\t\t\tdp [i | (1 << (j-1))] [(x*10+a[j]) mod m] += dp[i][x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 14",
          "code": "i goes from 0 to 2^l-1\n\tj goes from 0 to l-1\n\t\tx goes from 0 to m-1\n\t\t\tdp [i | (1 << (j-1))] [(x*10+a[j]) mod m] += dp[i][x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 15",
          "code": "for(int i=1;i<2^l;i++)\n        for(int j=0;j<m;j++)\n        {\n            if(!dp[i][j])continue;\n            for(int k=0;k<l;k++)\n                if(!(i&(1<<k)))\n                    dp[i|(1<<k)][(j*10+f[k])%m]+=dp[i][j];\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 16",
          "code": "for(int i=1;i<2^l;i++)\n        for(int j=0;j<m;j++)\n        {\n            if(!dp[i][j])continue;\n            for(int k=0;k<l;k++)\n                if(!(i&(1<<k)))\n                    dp[i|(1<<k)][(j*10+f[k])%m]+=dp[i][j];\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 17",
          "code": "wrong answer. The number of ones should be 4, but found 5; The number of zeros should be 3, but found 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(1, 4000, \"x\");\n    inf.readSpace();\n    int k = inf.readInt(0, 3999, \"k\"); // k < 4000\n    inf.readEoln();\n\n    if (x == 1) {\n        ensuref(k == 0, \"When x == 1, k must be 0, but k = %d\", k);\n    }\n\n    for (int i = 0; i < k; ++i) {\n        int t = inf.readInt(1, 2, \"t\");\n        if (t == 1) {\n            inf.readSpace();\n            int num2 = inf.readInt(1, x - 1, \"num2\");\n            inf.readSpace();\n            int num1 = inf.readInt(1, x - 1, \"num1\");\n            inf.readEoln();\n            ensuref(num1 - num2 == 1, \"In line %d, num1 - num2 must be 1, but num1 = %d, num2 = %d\", i + 1, num1, num2);\n        } else {\n            inf.readSpace();\n            int num = inf.readInt(1, x - 1, \"num\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(1, 4000, \"x\");\n    inf.readSpace();\n    int k = inf.readInt(0, 3999, \"k\"); // k < 4000\n    inf.readEoln();\n\n    if (x == 1) {\n        ensuref(k == 0, \"When x == 1, k must be 0, but k = %d\", k);\n    }\n\n    for (int i = 0; i < k; ++i) {\n        int t = inf.readInt(1, 2, \"t\");\n        if (t == 1) {\n            inf.readSpace();\n            int num2 = inf.readInt(1, x - 1, \"num2\");\n            inf.readSpace();\n            int num1 = inf.readInt(1, x - 1, \"num1\");\n            inf.readEoln();\n            ensuref(num1 - num2 == 1, \"In line %d, num1 - num2 must be 1, but num1 = %d, num2 = %d\", i + 1, num1, num2);\n        } else {\n            inf.readSpace();\n            int num = inf.readInt(1, x - 1, \"num\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int x = inf.readInt(1, 4000, \"x\");\n    inf.readSpace();\n    int k = inf.readInt(0, 3999, \"k\"); // k < 4000\n    inf.readEoln();\n\n    if (x == 1) {\n        ensuref(k == 0, \"When x == 1, k must be 0, but k = %d\", k);\n    }\n\n    for (int i = 0; i < k; ++i) {\n        int t = inf.readInt(1, 2, \"t\");\n        if (t == 1) {\n            inf.readSpace();\n            int num2 = inf.readInt(1, x - 1, \"num2\");\n            inf.readSpace();\n            int num1 = inf.readInt(1, x - 1, \"num1\");\n            inf.readEoln();\n            ensuref(num1 - num2 == 1, \"In line %d, num1 - num2 must be 1, but num1 = %d, num2 = %d\", i + 1, num1, num2);\n        } else {\n            inf.readSpace();\n            int num = inf.readInt(1, x - 1, \"num\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int x = opt<int>(\"x\", -1); // x = random between 1 and 4000 if not provided\n    int k = opt<int>(\"k\", -1); // k = random between 0 and x-1 if not provided\n    string type = opt<string>(\"type\", \"random\"); // type of test case\n\n    // Validate x, k\n    if (x == -1) x = rnd.next(1, 4000);\n    ensure(1 <= x && x <= 4000);\n\n    if (k == -1) k = rnd.next(0, x - 1);\n    ensure(0 <= k && k < x);\n\n    // Generate available identifiers from 1 to x-1\n    vector<int> available_ids(x - 1);\n    iota(available_ids.begin(), available_ids.end(), 1);\n\n    // Shuffle the available identifiers\n    shuffle(available_ids.begin(), available_ids.end());\n\n    // Select k identifiers for the rounds Sereja took part in\n    vector<int> selected_ids(available_ids.begin(), available_ids.begin() + k);\n    sort(selected_ids.begin(), selected_ids.end());\n\n    // Generate the rounds Sereja took part in\n    vector<string> rounds;\n\n    if (type == \"all_regular\") {\n        // All rounds are regular Div2 rounds\n        for (int id : selected_ids) {\n            rounds.push_back(\"2 \" + to_string(id));\n        }\n    } else if (type == \"all_simultaneous\") {\n        // All rounds are simultaneous Div1 and Div2 rounds\n        for (int id : selected_ids) {\n            if (id + 1 >= x) {\n                // Can't be simultaneous, make it regular\n                rounds.push_back(\"2 \" + to_string(id));\n            } else {\n                rounds.push_back(\"1 \" + to_string(id) + \" \" + to_string(id + 1));\n            }\n        }\n    } else if (type == \"mix\") {\n        // Mix of regular and simultaneous rounds\n        for (int id : selected_ids) {\n            if (rnd.next(2)) {\n                if (id + 1 >= x) {\n                    rounds.push_back(\"2 \" + to_string(id));\n                } else {\n                    rounds.push_back(\"1 \" + to_string(id) + \" \" + to_string(id + 1));\n                }\n            } else {\n                rounds.push_back(\"2 \" + to_string(id));\n            }\n        }\n    } else if (type == \"max_miss\") {\n        // Maximize possible missed rounds\n        // Sereja's rounds are all regular Div2 rounds\n        for (int id : selected_ids) {\n            rounds.push_back(\"2 \" + to_string(id));\n        }\n    } else if (type == \"min_miss\") {\n        // Minimize possible missed rounds\n        // Sereja's rounds are all simultaneous rounds\n        for (int id : selected_ids) {\n            if (id + 1 >= x) {\n                rounds.push_back(\"2 \" + to_string(id));\n            } else {\n                rounds.push_back(\"1 \" + to_string(id) + \" \" + to_string(id + 1));\n            }\n        }\n    } else {\n        // Default random case\n        for (int id : selected_ids) {\n            if (rnd.next(2)) {\n                if (id + 1 >= x) {\n                    rounds.push_back(\"2 \" + to_string(id));\n                } else {\n                    rounds.push_back(\"1 \" + to_string(id) + \" \" + to_string(id + 1));\n                }\n            } else {\n                rounds.push_back(\"2 \" + to_string(id));\n            }\n        }\n    }\n\n    // Output x and k\n    printf(\"%d %d\\n\", x, k);\n\n    // Output the rounds\n    for (const string& s : rounds) {\n        printf(\"%s\\n\", s.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int x = opt<int>(\"x\", -1); // x = random between 1 and 4000 if not provided\n    int k = opt<int>(\"k\", -1); // k = random between 0 and x-1 if not provided\n    string type = opt<string>(\"type\", \"random\"); // type of test case\n\n    // Validate x, k\n    if (x == -1) x = rnd.next(1, 4000);\n    ensure(1 <= x && x <= 4000);\n\n    if (k == -1) k = rnd.next(0, x - 1);\n    ensure(0 <= k && k < x);\n\n    // Generate available identifiers from 1 to x-1\n    vector<int> available_ids(x - 1);\n    iota(available_ids.begin(), available_ids.end(), 1);\n\n    // Shuffle the available identifiers\n    shuffle(available_ids.begin(), available_ids.end());\n\n    // Select k identifiers for the rounds Sereja took part in\n    vector<int> selected_ids(available_ids.begin(), available_ids.begin() + k);\n    sort(selected_ids.begin(), selected_ids.end());\n\n    // Generate the rounds Sereja took part in\n    vector<string> rounds;\n\n    if (type == \"all_regular\") {\n        // All rounds are regular Div2 rounds\n        for (int id : selected_ids) {\n            rounds.push_back(\"2 \" + to_string(id));\n        }\n    } else if (type == \"all_simultaneous\") {\n        // All rounds are simultaneous Div1 and Div2 rounds\n        for (int id : selected_ids) {\n            if (id + 1 >= x) {\n                // Can't be simultaneous, make it regular\n                rounds.push_back(\"2 \" + to_string(id));\n            } else {\n                rounds.push_back(\"1 \" + to_string(id) + \" \" + to_string(id + 1));\n            }\n        }\n    } else if (type == \"mix\") {\n        // Mix of regular and simultaneous rounds\n        for (int id : selected_ids) {\n            if (rnd.next(2)) {\n                if (id + 1 >= x) {\n                    rounds.push_back(\"2 \" + to_string(id));\n                } else {\n                    rounds.push_back(\"1 \" + to_string(id) + \" \" + to_string(id + 1));\n                }\n            } else {\n                rounds.push_back(\"2 \" + to_string(id));\n            }\n        }\n    } else if (type == \"max_miss\") {\n        // Maximize possible missed rounds\n        // Sereja's rounds are all regular Div2 rounds\n        for (int id : selected_ids) {\n            rounds.push_back(\"2 \" + to_string(id));\n        }\n    } else if (type == \"min_miss\") {\n        // Minimize possible missed rounds\n        // Sereja's rounds are all simultaneous rounds\n        for (int id : selected_ids) {\n            if (id + 1 >= x) {\n                rounds.push_back(\"2 \" + to_string(id));\n            } else {\n                rounds.push_back(\"1 \" + to_string(id) + \" \" + to_string(id + 1));\n            }\n        }\n    } else {\n        // Default random case\n        for (int id : selected_ids) {\n            if (rnd.next(2)) {\n                if (id + 1 >= x) {\n                    rounds.push_back(\"2 \" + to_string(id));\n                } else {\n                    rounds.push_back(\"1 \" + to_string(id) + \" \" + to_string(id + 1));\n                }\n            } else {\n                rounds.push_back(\"2 \" + to_string(id));\n            }\n        }\n    }\n\n    // Output x and k\n    printf(\"%d %d\\n\", x, k);\n\n    // Output the rounds\n    for (const string& s : rounds) {\n        printf(\"%s\\n\", s.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small x, k = 0\n./gen -x 1 -k 0 -type min_miss\n./gen -x 1 -k 0 -type max_miss\n\n# Small x, k = x - 1\n./gen -x 10 -k 9 -type min_miss\n./gen -x 10 -k 9 -type max_miss\n\n# Small x, random k\n./gen -x 10 -k 5 -type mix\n./gen -x 10 -k 5 -type all_regular\n./gen -x 10 -k 5 -type all_simultaneous\n\n# Edge case: x = max, k = 0\n./gen -x 4000 -k 0 -type min_miss\n./gen -x 4000 -k 0 -type max_miss\n\n# Edge case: x = max, k = x -1\n./gen -x 4000 -k 3999 -type min_miss\n./gen -x 4000 -k 3999 -type max_miss\n\n# Random large x\n./gen -x 2000 -k 1000 -type mix\n./gen -x 3000 -k 1500 -type all_regular\n./gen -x 3000 -k 1500 -type all_simultaneous\n\n# Random x and k\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Special test cases\n./gen -x 4000 -k 2000 -type edge_cases\n./gen -x 3999 -k 0 -type min_miss\n./gen -x 2 -k 1 -type all_simultaneous\n\n# Maximize missed rounds\n./gen -x 1000 -k 10 -type max_miss\n\n# Minimize missed rounds\n./gen -x 1000 -k 10 -type min_miss\n\n# Random k=0\n./gen -x 500 -k 0 -type random\n\n# Random k near x/2\n./gen -x 1000 -k 500 -type mix\n./gen -x 2000 -k 1000 -type mix\n\n# Max k\n./gen -x 3000 -k 2999 -type all_simultaneous\n\n# Min k\n./gen -x 3000 -k 0 -type all_regular\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:32.794908",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "401/C",
      "title": "C. Team",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers: n (1 ≤ n ≤ 106) — the number of cards containing number 0; m (1 ≤ m ≤ 106) — the number of cards containing number 1.",
      "output_spec": "OutputIn a single line print the required sequence of zeroes and ones without any spaces. If such sequence is impossible to obtain, print -1.",
      "sample_tests": "ExamplesInputCopy1 2OutputCopy101InputCopy4 8OutputCopy110110110101InputCopy4 10OutputCopy11011011011011InputCopy1 5OutputCopy-1",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers: n (1 ≤ n ≤ 106) — the number of cards containing number 0; m (1 ≤ m ≤ 106) — the number of cards containing number 1.\n\nOutputIn a single line print the required sequence of zeroes and ones without any spaces. If such sequence is impossible to obtain, print -1.\n\nInputCopy1 2OutputCopy101InputCopy4 8OutputCopy110110110101InputCopy4 10OutputCopy11011011011011InputCopy1 5OutputCopy-1\n\nInputCopy1 2\n\nOutputCopy101\n\nInputCopy4 8\n\nOutputCopy110110110101\n\nInputCopy4 10\n\nOutputCopy11011011011011\n\nInputCopy1 5\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #235 (Div. 2) - Codeforces",
          "content": "Hello everyone!Codeforces Round #235 (Div. 2) will take place on March 10th at 19:30 MSK. This is my first Codeforces round and I hope not the last one.I'd like to thank Gerald Agapov (Gerald), Roman Rubanenko (Rubanenko), Sergey Oryshych (Oryshych) for helping me to prepare round, and Mariya Belova for translation of all problem statements into English.Scoring: 500-1000-1500-2000-2500GL & HF!Top five: UESTC_XHXJ GoodByeAhu OrzSKYDEC simonlindholm angelyue Congratulations of participant hoanglmdiv2, who solved the problem E.Unfortunately, my fault, in the round hit the problem that was previously used on another competition. Since it does not comply Codeforces, problem E will be deleted.English tutorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10786",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 712
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces",
          "content": "Problem АWe must sum all numbers, and reduced it to zero by the operations +x and -x.Solution АProblem BYou must identify the array of numbers contests that remember Sereja, as employed. If we want to find maximal answer, we must count the number of immune cells. If we want to find mininum answer, we must do the following:if i-th element is free and (i+1)-th element is free, and i<x then we using round type of \"Div1+Div2\" and answer++, i-th and (i+1)-th elements define as employed. if i-th element is free and (i+1)-th element is employed then we usign round type \"Div2\" and answer++, i-th element define as employed. Solution BProblem Cn — the number of cards containing number 0 and m — the number of cards containing number 1. We have answer, when ((n-1)<=m && m <= 2 * (n + 1)). If we have answer then we must do the following: if (m == n - 1) then we derive the ones and zeros in one, but we must start from zero. if (m == n) then we derive the ones and zeros in one. if (m > n && m <= 2 * (n + 1)) then we must start form one and we derive the ones and zeros in one, but in the end must be one. And if we in the end and we have ones, then we try to stick to one unit so that we have. For example, we have 10101 and two ones, after we have 110101 and one ones, and then we have 1101101. Solution СProblem DThis problem we can be attributed to the dynamic programming. We must using mask and dynamic.We have dynamic dp[i][x], when i — mask of reshuffle and x — remainder on dividing by m.if we want to add number a[j], we must using it: dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] := dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] + dp[i,x];In the end we must answer to divide by the factorial number of occurrences of each digit. for i:=0 to 9 do\n\n for j:=2 to b[i] do\n\n ans:=ans div int64(j);Solution DProblem EIf first participant of the contest will contain at point (x1;y1) and second participant of the contest will contain at point (x2;y2), then we need to satisfy two conditions: L*L <= (abs(x1-x2)*abs(x1-x2) + abs(y1-y2)*abs(y1-y2)) <= R*R gcd(abs(x1-x2),abs(y1-y2)) == 1 Since the hall can potentially be of size 100,000 x 100,000, even considering each possible size of R or L once will take too much time. And if we iterate value abs(x1-x2) and iterate value abs(y1-y2) then it will take much time too. But if we iterate only value abs(x1-x2) we can find confines of value abs(y1-y2). We can do so: L*L<=(abs(x1-x2)*abs(x1-x2)+abs(y1-y2)*abs(y1-y2))<=R*R L*L - abs(x1-x2)*abs(x1-x2) <= abs(y1-y2)*abs(y1-y2) <= R*R - abs(x1-x2)*abs(x1-x2) Number of options to place the square in hall n*m will be (n-abs(x1-x2)+1)*(m-abs(y1-y2)+1). The first quantity is easy to obtain, while the second requires a little more work. To calculate the second quantity, we note that, although w could have a large variety of prime divisors, it does not have very many of them. This important insight allows us to quickly find the sum: we find the prime factors of w, then we use the inclusion-exclusion principle to calculate the sum of all numbers between L and R that are divisible by at least one of the numbers.Unfortunately, my fault, in the round hit the problem that was previously used on another competition. Since it does not comply Codeforces, problem E will be deleted.Solution ESorry for my English.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3305
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #235 (Div. 2) - Codeforces - Code 1",
          "code": "int n;\ncin>>n;\nint a[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10786",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) - Codeforces - Code 2",
          "code": "int n;\ncin>>n;\nint a[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10786",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 1",
          "code": "((n-1)<=m && m <= 2 * (n + 1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 2",
          "code": "(m == n - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 3",
          "code": "(m > n && m <= 2 * (n + 1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 4",
          "code": "dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] := dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] + dp[i,x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 5",
          "code": "dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] := dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] + dp[i,x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 6",
          "code": "for i:=0 to 9 do\n\n   for j:=2 to b[i] do\n\n     ans:=ans div int64(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 7",
          "code": "for i:=0 to 9 do\n\n   for j:=2 to b[i] do\n\n     ans:=ans div int64(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 8",
          "code": "L*L <= (abs(x1-x2)*abs(x1-x2) + abs(y1-y2)*abs(y1-y2)) <= R*R",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 9",
          "code": "gcd(abs(x1-x2),abs(y1-y2)) == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 10",
          "code": "L*L<=(abs(x1-x2)*abs(x1-x2)+abs(y1-y2)*abs(y1-y2))<=R*R",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 11",
          "code": "L*L - abs(x1-x2)*abs(x1-x2) <= abs(y1-y2)*abs(y1-y2) <= R*R - abs(x1-x2)*abs(x1-x2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 12",
          "code": "(n-abs(x1-x2)+1)*(m-abs(y1-y2)+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 13",
          "code": "i goes from 0 to 2^l-1\n\tj goes from 0 to l-1\n\t\tx goes from 0 to m-1\n\t\t\tdp [i | (1 << (j-1))] [(x*10+a[j]) mod m] += dp[i][x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 14",
          "code": "i goes from 0 to 2^l-1\n\tj goes from 0 to l-1\n\t\tx goes from 0 to m-1\n\t\t\tdp [i | (1 << (j-1))] [(x*10+a[j]) mod m] += dp[i][x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 15",
          "code": "for(int i=1;i<2^l;i++)\n        for(int j=0;j<m;j++)\n        {\n            if(!dp[i][j])continue;\n            for(int k=0;k<l;k++)\n                if(!(i&(1<<k)))\n                    dp[i|(1<<k)][(j*10+f[k])%m]+=dp[i][j];\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 16",
          "code": "for(int i=1;i<2^l;i++)\n        for(int j=0;j<m;j++)\n        {\n            if(!dp[i][j])continue;\n            for(int k=0;k<l;k++)\n                if(!(i&(1<<k)))\n                    dp[i|(1<<k)][(j*10+f[k])%m]+=dp[i][j];\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 17",
          "code": "wrong answer. The number of ones should be 4, but found 5; The number of zeros should be 3, but found 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include <bits/stdc++.h>\n#include \"testlib.h\"\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(); // Number of zeros\n    int m = inf.readInt(); // Number of ones\n\n    // Read jury's answer\n    string ansLine = ans.readToken();\n    // Read participant's answer\n    string oufLine = ouf.readToken();\n\n    if (ansLine == \"-1\") {\n        if (oufLine == \"-1\") {\n            quitf(_ok, \"Correctly reported impossible\");\n        } else {\n            // Validate participant's sequence\n            int zeros = 0, ones = 0;\n            bool valid = true;\n            int len = oufLine.length();\n            for (int i = 0; i < len; ++i) {\n                char c = oufLine[i];\n                if (c != '0' && c != '1') {\n                    valid = false;\n                    break;\n                }\n                if (c == '0') zeros++;\n                else ones++;\n                if (i > 0 && c == '0' && oufLine[i-1] == '0') {\n                    valid = false; // Two zeros adjacent\n                    break;\n                }\n                if (i >= 2 && c == '1' && oufLine[i-1] == '1' && oufLine[i-2] == '1') {\n                    valid = false; // Three ones in a row\n                    break;\n                }\n            }\n            if (zeros != n || ones != m) valid = false;\n            if (valid) {\n                // Participant found a valid sequence while jury said impossible\n                quitf(_fail, \"Participant found a valid sequence while jury said impossible\");\n            } else {\n                quitf(_wa, \"Participant's output is invalid\");\n            }\n        }\n    } else {\n        // Jury has a sequence\n        if (oufLine == \"-1\") {\n            quitf(_wa, \"Participant reports impossible but a sequence exists\");\n        } else {\n            // Validate participant's sequence\n            int zeros = 0, ones = 0;\n            bool valid = true;\n            int len = oufLine.length();\n            for (int i = 0; i < len; ++i) {\n                char c = oufLine[i];\n                if (c != '0' && c != '1') {\n                    valid = false;\n                    break;\n                }\n                if (c == '0') zeros++;\n                else ones++;\n                if (i > 0 && c == '0' && oufLine[i-1] == '0') {\n                    valid = false; // Two zeros adjacent\n                    break;\n                }\n                if (i >= 2 && c == '1' && oufLine[i-1] == '1' && oufLine[i-2] == '1') {\n                    valid = false; // Three ones in a row\n                    break;\n                }\n            }\n            if (zeros != n || ones != m) valid = false;\n            if (valid) {\n                quitf(_ok, \"Participant's sequence is valid\");\n            } else {\n                quitf(_wa, \"Participant's sequence is invalid\");\n            }\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n == -1 || m == -1) {\n        if (type == \"max_n\") {\n            n = 1000000;\n            m = rnd.next(n - 1, min(2 * (n + 1), 1000000));\n        } else if (type == \"max_m\") {\n            m = 1000000;\n            n = rnd.next(max(1, m - 1), 1000000);\n        } else if (type == \"equal\") {\n            n = rnd.next(1, 1000000);\n            m = n;\n        } else if (type == \"n_large_m_small\") {\n            n = 1000000;\n            m = rnd.next(1, min(n + 1, 1000000));\n        } else if (type == \"m_large_n_small\") {\n            m = 1000000;\n            n = rnd.next(1, min(m + 1, 1000000));\n        } else if (type == \"impossible_n_gt_m_plus1\") {\n            n = rnd.next(1, 1000000);\n            m = n - rnd.next(2, n);\n            if (m < 1) m = 1;\n        } else if (type == \"impossible_m_gt_2n_plus2\") {\n            n = rnd.next(1, 1000000);\n            m = (2 * (n +1)) + rnd.next(1, 1000000);\n            if (m > 1000000) m = 1000000;\n        } else if (type == \"random_possible\") {\n            // Generate random possible n and m\n            while (true) {\n                n = rnd.next(1, 1000000);\n                m = rnd.next(1, 1000000);\n                if (n <= m + 1 && m <= 2 * (n + 1)) {\n                    break;\n                }\n            }\n        } else if (type == \"random_impossible\") {\n            // Generate random impossible n and m\n            while (true) {\n                n = rnd.next(1, 1000000);\n                m = rnd.next(1, 1000000);\n                if (!(n <= m + 1 && m <= 2 * (n + 1))) {\n                    break;\n                }\n            }\n        } else if (type == \"random\") {\n            n = rnd.next(1, 1000000);\n            m = rnd.next(1, 1000000);\n        } else {\n            // Default random\n            n = rnd.next(1, 1000000);\n            m = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n == -1 || m == -1) {\n        if (type == \"max_n\") {\n            n = 1000000;\n            m = rnd.next(n - 1, min(2 * (n + 1), 1000000));\n        } else if (type == \"max_m\") {\n            m = 1000000;\n            n = rnd.next(max(1, m - 1), 1000000);\n        } else if (type == \"equal\") {\n            n = rnd.next(1, 1000000);\n            m = n;\n        } else if (type == \"n_large_m_small\") {\n            n = 1000000;\n            m = rnd.next(1, min(n + 1, 1000000));\n        } else if (type == \"m_large_n_small\") {\n            m = 1000000;\n            n = rnd.next(1, min(m + 1, 1000000));\n        } else if (type == \"impossible_n_gt_m_plus1\") {\n            n = rnd.next(1, 1000000);\n            m = n - rnd.next(2, n);\n            if (m < 1) m = 1;\n        } else if (type == \"impossible_m_gt_2n_plus2\") {\n            n = rnd.next(1, 1000000);\n            m = (2 * (n +1)) + rnd.next(1, 1000000);\n            if (m > 1000000) m = 1000000;\n        } else if (type == \"random_possible\") {\n            // Generate random possible n and m\n            while (true) {\n                n = rnd.next(1, 1000000);\n                m = rnd.next(1, 1000000);\n                if (n <= m + 1 && m <= 2 * (n + 1)) {\n                    break;\n                }\n            }\n        } else if (type == \"random_impossible\") {\n            // Generate random impossible n and m\n            while (true) {\n                n = rnd.next(1, 1000000);\n                m = rnd.next(1, 1000000);\n                if (!(n <= m + 1 && m <= 2 * (n + 1))) {\n                    break;\n                }\n            }\n        } else if (type == \"random\") {\n            n = rnd.next(1, 1000000);\n            m = rnd.next(1, 1000000);\n        } else {\n            // Default random\n            n = rnd.next(1, 1000000);\n            m = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal values\n./gen -n 1 -m 1\n./gen -n 1 -m 2\n./gen -n 2 -m 1\n\n# Maximal values\n./gen -type max_n\n./gen -type max_m\n\n# Equal values\n./gen -type equal\n\n# Cases where n is significantly larger than m\n./gen -type n_large_m_small\n\n# Cases where m is significantly larger than n\n./gen -type m_large_n_small\n\n# Random possible test cases (the sequence can be constructed)\n./gen -type random_possible\n./gen -type random_possible\n./gen -type random_possible\n\n# Random impossible test cases (the sequence cannot be constructed)\n./gen -type random_impossible\n./gen -type random_impossible\n./gen -type random_impossible\n\n# Specific impossible cases: n > m + 1\n./gen -type impossible_n_gt_m_plus1\n\n# Specific impossible cases: m > 2*(n + 1)\n./gen -type impossible_m_gt_2n_plus2\n\n# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Fixed test cases from the problem statement and additional ones\n./gen -n 1 -m 5\n./gen -n 2 -m 5\n./gen -n 4 -m 8\n./gen -n 4 -m 10\n\n# Cases close to impossible boundary\n./gen -n 500000 -m 1000001  # Should be impossible\n./gen -n 500000 -m 1000000  # Should be possible\n\n# Cases with large n and small m\n./gen -n 1000000 -m 1\n\n# Cases with small n and large m\n./gen -n 1 -m 1000000\n\n# Edge case where n = m + 1\n./gen -n 1000000 -m 999999\n\n# Edge case where m = 2*(n +1)\n./gen -n 333333 -m 666668\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:34.710737",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "401/D",
      "title": "D. Roman and Numbers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains two integers: n (1 ≤ n < 1018) and m (1 ≤ m ≤ 100).",
      "output_spec": "OutputIn a single line print a single integer — the number of numbers close to number n modulo m.",
      "sample_tests": "ExamplesInputCopy104 2OutputCopy3InputCopy223 4OutputCopy1InputCopy7067678 8OutputCopy47",
      "description": "D. Roman and Numbers\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers: n (1 ≤ n < 1018) and m (1 ≤ m ≤ 100).\n\nOutputIn a single line print a single integer — the number of numbers close to number n modulo m.\n\nInputCopy104 2OutputCopy3InputCopy223 4OutputCopy1InputCopy7067678 8OutputCopy47\n\nInputCopy104 2\n\nOutputCopy3\n\nInputCopy223 4\n\nOutputCopy1\n\nInputCopy7067678 8\n\nOutputCopy47\n\nNoteIn the first sample the required numbers are: 104, 140, 410.In the second sample the required number is 232.",
      "solutions": [
        {
          "title": "Codeforces Round #235 (Div. 2) - Codeforces",
          "content": "Hello everyone!Codeforces Round #235 (Div. 2) will take place on March 10th at 19:30 MSK. This is my first Codeforces round and I hope not the last one.I'd like to thank Gerald Agapov (Gerald), Roman Rubanenko (Rubanenko), Sergey Oryshych (Oryshych) for helping me to prepare round, and Mariya Belova for translation of all problem statements into English.Scoring: 500-1000-1500-2000-2500GL & HF!Top five: UESTC_XHXJ GoodByeAhu OrzSKYDEC simonlindholm angelyue Congratulations of participant hoanglmdiv2, who solved the problem E.Unfortunately, my fault, in the round hit the problem that was previously used on another competition. Since it does not comply Codeforces, problem E will be deleted.English tutorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10786",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 712
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces",
          "content": "Problem АWe must sum all numbers, and reduced it to zero by the operations +x and -x.Solution АProblem BYou must identify the array of numbers contests that remember Sereja, as employed. If we want to find maximal answer, we must count the number of immune cells. If we want to find mininum answer, we must do the following:if i-th element is free and (i+1)-th element is free, and i<x then we using round type of \"Div1+Div2\" and answer++, i-th and (i+1)-th elements define as employed. if i-th element is free and (i+1)-th element is employed then we usign round type \"Div2\" and answer++, i-th element define as employed. Solution BProblem Cn — the number of cards containing number 0 and m — the number of cards containing number 1. We have answer, when ((n-1)<=m && m <= 2 * (n + 1)). If we have answer then we must do the following: if (m == n - 1) then we derive the ones and zeros in one, but we must start from zero. if (m == n) then we derive the ones and zeros in one. if (m > n && m <= 2 * (n + 1)) then we must start form one and we derive the ones and zeros in one, but in the end must be one. And if we in the end and we have ones, then we try to stick to one unit so that we have. For example, we have 10101 and two ones, after we have 110101 and one ones, and then we have 1101101. Solution СProblem DThis problem we can be attributed to the dynamic programming. We must using mask and dynamic.We have dynamic dp[i][x], when i — mask of reshuffle and x — remainder on dividing by m.if we want to add number a[j], we must using it: dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] := dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] + dp[i,x];In the end we must answer to divide by the factorial number of occurrences of each digit. for i:=0 to 9 do\n\n for j:=2 to b[i] do\n\n ans:=ans div int64(j);Solution DProblem EIf first participant of the contest will contain at point (x1;y1) and second participant of the contest will contain at point (x2;y2), then we need to satisfy two conditions: L*L <= (abs(x1-x2)*abs(x1-x2) + abs(y1-y2)*abs(y1-y2)) <= R*R gcd(abs(x1-x2),abs(y1-y2)) == 1 Since the hall can potentially be of size 100,000 x 100,000, even considering each possible size of R or L once will take too much time. And if we iterate value abs(x1-x2) and iterate value abs(y1-y2) then it will take much time too. But if we iterate only value abs(x1-x2) we can find confines of value abs(y1-y2). We can do so: L*L<=(abs(x1-x2)*abs(x1-x2)+abs(y1-y2)*abs(y1-y2))<=R*R L*L - abs(x1-x2)*abs(x1-x2) <= abs(y1-y2)*abs(y1-y2) <= R*R - abs(x1-x2)*abs(x1-x2) Number of options to place the square in hall n*m will be (n-abs(x1-x2)+1)*(m-abs(y1-y2)+1). The first quantity is easy to obtain, while the second requires a little more work. To calculate the second quantity, we note that, although w could have a large variety of prime divisors, it does not have very many of them. This important insight allows us to quickly find the sum: we find the prime factors of w, then we use the inclusion-exclusion principle to calculate the sum of all numbers between L and R that are divisible by at least one of the numbers.Unfortunately, my fault, in the round hit the problem that was previously used on another competition. Since it does not comply Codeforces, problem E will be deleted.Solution ESorry for my English.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3305
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #235 (Div. 2) - Codeforces - Code 1",
          "code": "int n;\ncin>>n;\nint a[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10786",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) - Codeforces - Code 2",
          "code": "int n;\ncin>>n;\nint a[n];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10786",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 1",
          "code": "((n-1)<=m && m <= 2 * (n + 1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 2",
          "code": "(m == n - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 3",
          "code": "(m > n && m <= 2 * (n + 1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 4",
          "code": "dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] := dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] + dp[i,x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 5",
          "code": "dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] := dp[i or (1 shl (j-1)),(x*10+a[j]) mod m] + dp[i,x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 6",
          "code": "for i:=0 to 9 do\n\n   for j:=2 to b[i] do\n\n     ans:=ans div int64(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 7",
          "code": "for i:=0 to 9 do\n\n   for j:=2 to b[i] do\n\n     ans:=ans div int64(j);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 8",
          "code": "L*L <= (abs(x1-x2)*abs(x1-x2) + abs(y1-y2)*abs(y1-y2)) <= R*R",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 9",
          "code": "gcd(abs(x1-x2),abs(y1-y2)) == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 10",
          "code": "L*L<=(abs(x1-x2)*abs(x1-x2)+abs(y1-y2)*abs(y1-y2))<=R*R",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 11",
          "code": "L*L - abs(x1-x2)*abs(x1-x2) <= abs(y1-y2)*abs(y1-y2) <= R*R - abs(x1-x2)*abs(x1-x2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 12",
          "code": "(n-abs(x1-x2)+1)*(m-abs(y1-y2)+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 13",
          "code": "i goes from 0 to 2^l-1\n\tj goes from 0 to l-1\n\t\tx goes from 0 to m-1\n\t\t\tdp [i | (1 << (j-1))] [(x*10+a[j]) mod m] += dp[i][x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 14",
          "code": "i goes from 0 to 2^l-1\n\tj goes from 0 to l-1\n\t\tx goes from 0 to m-1\n\t\t\tdp [i | (1 << (j-1))] [(x*10+a[j]) mod m] += dp[i][x];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 15",
          "code": "for(int i=1;i<2^l;i++)\n        for(int j=0;j<m;j++)\n        {\n            if(!dp[i][j])continue;\n            for(int k=0;k<l;k++)\n                if(!(i&(1<<k)))\n                    dp[i|(1<<k)][(j*10+f[k])%m]+=dp[i][j];\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 16",
          "code": "for(int i=1;i<2^l;i++)\n        for(int j=0;j<m;j++)\n        {\n            if(!dp[i][j])continue;\n            for(int k=0;k<l;k++)\n                if(!(i&(1<<k)))\n                    dp[i|(1<<k)][(j*10+f[k])%m]+=dp[i][j];\n        }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #235 (Div. 2) — Tutorial - Codeforces - Code 17",
          "code": "wrong answer. The number of ones should be 4, but found 5; The number of zeros should be 3, but found 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10842",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 999999999999999999LL, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 999999999999999999LL, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1LL, 999999999999999999LL, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n_digits = opt<int>(\"n_digits\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n_digits is between 1 and 18\n    if (n_digits < 1 || n_digits > 18) {\n        n_digits = max(1, min(n_digits, 18));\n    }\n\n    string n_str;\n\n    if (type == \"random\") {\n        // Generate random n of length n_digits\n        n_str.push_back('1' + rnd.next(9)); // First digit from '1' to '9'\n        for (int i = 1; i < n_digits; ++i) {\n            n_str.push_back('0' + rnd.next(10)); // Next digits from '0' to '9'\n        }\n    } else if (type == \"leading_zero\") {\n        // Generate n with zeros to create permutations that could lead to leading zeros\n        int num_zeros = rnd.next(1, n_digits - 1);\n        vector<char> digits;\n        digits.push_back('1' + rnd.next(9)); // First digit not zero\n        for (int i = 1; i < n_digits - num_zeros; ++i) {\n            digits.push_back('0' + rnd.next(1, 9)); // digits from '1' to '9'\n        }\n        for (int i = 0; i < num_zeros; ++i) {\n            digits.push_back('0'); // Add zeros\n        }\n        shuffle(digits.begin(), digits.end());\n        n_str = string(digits.begin(), digits.end());\n        // Ensure n_str does not have a leading zero\n        if (n_str[0] == '0') {\n            for (int i = 1; i < n_digits; ++i) {\n                if (n_str[i] != '0') {\n                    swap(n_str[0], n_str[i]);\n                    break;\n                }\n            }\n        }\n    } else if (type == \"duplicates\") {\n        // Generate n with duplicate digits\n        vector<char> digits;\n        char digit1 = '1' + rnd.next(9); // from '1' to '9'\n        digits.push_back(digit1);\n        char digit2 = '0' + rnd.next(10); // from '0' to '9'\n        for (int i = 1; i < n_digits; ++i) {\n            digits.push_back(digit2);\n        }\n        shuffle(digits.begin(), digits.end());\n        n_str = string(digits.begin(), digits.end());\n        // Ensure n_str does not have a leading zero\n        if (n_str[0] == '0') {\n            for (int i = 1; i < n_digits; ++i) {\n                if (n_str[i] != '0') {\n                    swap(n_str[0], n_str[i]);\n                    break;\n                }\n            }\n        }\n    } else if (type == \"max_n\") {\n        // n has maximum allowed digits (18 digits)\n        n_digits = 18;\n        n_str.push_back('1' + rnd.next(9)); // First digit from '1' to '9'\n        for (int i = 1; i < n_digits; ++i) {\n            n_str.push_back('0' + rnd.next(10)); // Next digits from '0' to '9'\n        }\n    } else if (type == \"all_same_digit\") {\n        // n is the same digit repeated\n        char digit = '1' + rnd.next(9); // from '1' to '9'\n        n_str = string(n_digits, digit);\n    } else if (type == \"specific\") {\n        // Read n explicitly via parameter 'n'\n        n_str = opt<string>(\"n\");\n        if ((int)n_str.length() != n_digits) {\n            cerr << \"Error: n_digits doesn't match the length of n\" << endl;\n            return 1;\n        }\n        // Ensure n_str[0] is not '0'\n        if (n_str[0] == '0') {\n            cerr << \"Error: n should not have leading zero\" << endl;\n            return 1;\n        }\n    } else {\n        // Default to random\n        n_str.push_back('1' + rnd.next(9)); // First digit from '1' to '9'\n        for (int i = 1; i < n_digits; ++i) {\n            n_str.push_back('0' + rnd.next(10)); // Next digits from '0' to '9'\n        }\n    }\n\n    // Ensure n is less than 10^18\n    if (n_str.length() == 18 && n_str > \"999999999999999999\") {\n        n_str = \"999999999999999999\"; // Set to max allowed value\n    }\n\n    // Output n and m\n    printf(\"%s %d\\n\", n_str.c_str(), m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n_digits = opt<int>(\"n_digits\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n_digits is between 1 and 18\n    if (n_digits < 1 || n_digits > 18) {\n        n_digits = max(1, min(n_digits, 18));\n    }\n\n    string n_str;\n\n    if (type == \"random\") {\n        // Generate random n of length n_digits\n        n_str.push_back('1' + rnd.next(9)); // First digit from '1' to '9'\n        for (int i = 1; i < n_digits; ++i) {\n            n_str.push_back('0' + rnd.next(10)); // Next digits from '0' to '9'\n        }\n    } else if (type == \"leading_zero\") {\n        // Generate n with zeros to create permutations that could lead to leading zeros\n        int num_zeros = rnd.next(1, n_digits - 1);\n        vector<char> digits;\n        digits.push_back('1' + rnd.next(9)); // First digit not zero\n        for (int i = 1; i < n_digits - num_zeros; ++i) {\n            digits.push_back('0' + rnd.next(1, 9)); // digits from '1' to '9'\n        }\n        for (int i = 0; i < num_zeros; ++i) {\n            digits.push_back('0'); // Add zeros\n        }\n        shuffle(digits.begin(), digits.end());\n        n_str = string(digits.begin(), digits.end());\n        // Ensure n_str does not have a leading zero\n        if (n_str[0] == '0') {\n            for (int i = 1; i < n_digits; ++i) {\n                if (n_str[i] != '0') {\n                    swap(n_str[0], n_str[i]);\n                    break;\n                }\n            }\n        }\n    } else if (type == \"duplicates\") {\n        // Generate n with duplicate digits\n        vector<char> digits;\n        char digit1 = '1' + rnd.next(9); // from '1' to '9'\n        digits.push_back(digit1);\n        char digit2 = '0' + rnd.next(10); // from '0' to '9'\n        for (int i = 1; i < n_digits; ++i) {\n            digits.push_back(digit2);\n        }\n        shuffle(digits.begin(), digits.end());\n        n_str = string(digits.begin(), digits.end());\n        // Ensure n_str does not have a leading zero\n        if (n_str[0] == '0') {\n            for (int i = 1; i < n_digits; ++i) {\n                if (n_str[i] != '0') {\n                    swap(n_str[0], n_str[i]);\n                    break;\n                }\n            }\n        }\n    } else if (type == \"max_n\") {\n        // n has maximum allowed digits (18 digits)\n        n_digits = 18;\n        n_str.push_back('1' + rnd.next(9)); // First digit from '1' to '9'\n        for (int i = 1; i < n_digits; ++i) {\n            n_str.push_back('0' + rnd.next(10)); // Next digits from '0' to '9'\n        }\n    } else if (type == \"all_same_digit\") {\n        // n is the same digit repeated\n        char digit = '1' + rnd.next(9); // from '1' to '9'\n        n_str = string(n_digits, digit);\n    } else if (type == \"specific\") {\n        // Read n explicitly via parameter 'n'\n        n_str = opt<string>(\"n\");\n        if ((int)n_str.length() != n_digits) {\n            cerr << \"Error: n_digits doesn't match the length of n\" << endl;\n            return 1;\n        }\n        // Ensure n_str[0] is not '0'\n        if (n_str[0] == '0') {\n            cerr << \"Error: n should not have leading zero\" << endl;\n            return 1;\n        }\n    } else {\n        // Default to random\n        n_str.push_back('1' + rnd.next(9)); // First digit from '1' to '9'\n        for (int i = 1; i < n_digits; ++i) {\n            n_str.push_back('0' + rnd.next(10)); // Next digits from '0' to '9'\n        }\n    }\n\n    // Ensure n is less than 10^18\n    if (n_str.length() == 18 && n_str > \"999999999999999999\") {\n        n_str = \"999999999999999999\"; // Set to max allowed value\n    }\n\n    // Output n and m\n    printf(\"%s %d\\n\", n_str.c_str(), m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, small m\n./gen -n_digits 1 -m 1 -type random\n./gen -n_digits 1 -m 100 -type random\n./gen -n_digits 2 -m 2 -type random\n./gen -n_digits 2 -m 50 -type random\n\n# Medium n, small m\n./gen -n_digits 9 -m 1 -type random\n./gen -n_digits 9 -m 99 -type random\n\n# Large n, small m\n./gen -n_digits 18 -m 1 -type random\n./gen -n_digits 18 -m 100 -type random\n\n# Leading zero test cases\n./gen -n_digits 5 -m 7 -type leading_zero\n./gen -n_digits 10 -m 13 -type leading_zero\n\n# Duplicates test cases\n./gen -n_digits 7 -m 11 -type duplicates\n./gen -n_digits 15 -m 17 -type duplicates\n\n# Maximum n\n./gen -n_digits 18 -m 97 -type max_n\n\n# All same digit\n./gen -n_digits 6 -m 4 -type all_same_digit\n./gen -n_digits 18 -m 9 -type all_same_digit\n\n# Specific n test cases (from sample inputs)\n./gen -n_digits 3 -m 2 -type specific -n 104\n./gen -n_digits 3 -m 4 -type specific -n 223\n./gen -n_digits 7 -m 8 -type specific -n 7067678\n\n# Smallest n\n./gen -n_digits 1 -m 1 -type specific -n 1\n\n# n with zeros in the middle\n./gen -n_digits 5 -m 23 -type leading_zero\n./gen -n_digits 8 -m 47 -type leading_zero\n\n# Random test cases\n./gen -n_digits 12 -m 73 -type random\n./gen -n_digits 12 -m 31 -type random\n./gen -n_digits 14 -m 89 -type random\n\n# Edge m values\n./gen -n_digits 5 -m 1 -type random\n./gen -n_digits 5 -m 100 -type random\n\n# Test cases covering permutations with unique digits\n./gen -n_digits 9 -m 5 -type random\n\n# n with many zeros\n./gen -n_digits 10 -m 3 -type leading_zero\n\n# n with maximum duplicate digits\n./gen -n_digits 18 -m 2 -type duplicates\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:36.648220",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "402/A",
      "title": "A. Nuts",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four space-separated integers k, a, b, v (2 ≤ k ≤ 1000; 1 ≤ a, b, v ≤ 1000) — the maximum number of sections in the box, the number of nuts, the number of divisors and the capacity of each section of the box.",
      "output_spec": "OutputPrint a single integer — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy3 10 3 3OutputCopy2InputCopy3 10 1 3OutputCopy3InputCopy100 100 1 1000OutputCopy1",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains four space-separated integers k, a, b, v (2 ≤ k ≤ 1000; 1 ≤ a, b, v ≤ 1000) — the maximum number of sections in the box, the number of nuts, the number of divisors and the capacity of each section of the box.\n\nOutputPrint a single integer — the answer to the problem.\n\nInputCopy3 10 3 3OutputCopy2InputCopy3 10 1 3OutputCopy3InputCopy100 100 1 1000OutputCopy1\n\nInputCopy3 10 3 3\n\nOutputCopy2\n\nInputCopy3 10 1 3\n\nOutputCopy3\n\nInputCopy100 100 1 1000\n\nOutputCopy1\n\nNoteIn the first sample you can act like this:   Put two divisors to the first box. Now the first box has three sections and we can put three nuts into each section. Overall, the first box will have nine nuts.  Do not put any divisors into the second box. Thus, the second box has one section for the last nut. In the end we've put all the ten nuts into boxes.The second sample is different as we have exactly one divisor and we put it to the first box. The next two boxes will have one section each.",
      "solutions": [
        {
          "title": "Codeforces Round #236 - Codeforces",
          "content": "Soon (on March 16, 19:30 MSK) you are lucky to participate in Codeforces Round #236 for both divisions.Problems have been prepared by me. It’s my first round for both divisions and I hope not last. I want to thank Gerald Agapov (Gerald) for help in preparation of this round, Ilya Los (IlyaLos) and Ignatyev Alexander (aiMR) for testing of problems, Mary Belova(Delinur) for translating the problems, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems. UPD: Scoring system:Div. 2: 500 — 1000 — 1500 — 2000 — 2500Div. 1: 500 — 1000 — 1500 — 1500 — 2000 UPD:Contest finished, congratulation for winners!Div.2 : vladb iceiceice LoneFox ofpsxx adsz Div. 1: 1 sillycross 2 KADR 2 vepifanov 4 Endagorion 5 glassices 6 cgy4ever 7 rowdark 8 snuke 9 ftiasch 10 fsouza UPD:Editorial. UPD:Round Statistics from DmitriyH.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10959",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 839
        },
        {
          "title": "Editorial Codeforces Round #236 - Codeforces",
          "content": "402A - NutsLet's fix some value of boxes ans. After that we can get exactly cnt = ans + min((k - 1) * ans, B) of sections. So, if cnt * v ≥ a, then ans be an answer. After that you can use brute force to find smallest possible value of ans.402B - Trees in a RowLet's fix height of the first tree: let's call it a. Of course, a is an integer from segment [1, 1000]. After that, for the fixed height a of the first tree we can calculate heights of the others trees: a, a + k, a + 2k, and so on. After that you should find minimal number of operations ans to achive such heights. After that we can use brute force to find smallest possible ans for each a from 1 to 1000. For best height of the first tree you should print all operations.402C - Searching for Graph / 403A - Searching for GraphI will describe two solutions.First. Consider all pairs (i, j) (1 ≤ i < j ≤ n). After you should ouput the first 2n + p pairs in lexicographical order.It's clear to understand, that it is enough to prove, that 0-interesting graph is correct or  - 3 -interesting graph is correct. We will prove for  - 3 -interesting graph, that it is correct. This graph consists of triangles, which have an common edge 1 — 2. Let's fix some subset of vertexes, which does not contains vertexes 1 and 2. In such sets there are no edges. Let's fix some subset, which contains exactly one vertex (1 or 2). In such subsets there are exactly k - 1 edges, where k is the size of such subset. In other subset there are exactly 2 * (k — 2) + 1 edges, where k is the size of such subset.Second. Let's use some brute force, to build graphs with 0-interesting graphs with sizes 5, 6, 7, 8, 9 vertexes. Now, to build p-interesting graph with n vertexes, We will build 0-interesting graph, and after that we will add to it p another edges, which is not in the graph. We will build 0-interesting graphs using the following approach: Let's took k disjointed components, from graphs with number of vertexes from 5 to 9, in such way that there are exactly n vertexes in graph.402D - Upgrading Array / 403B - Upgrading ArrayI will describe two solutions.First. Dynamic programming approach. Let's calculate an DP d[i][j] — which is the best possible answer we can achieve, if current prefix has length i and we used operation of Upgrading last time in position j. It is clear to understand, that we should iterate i from n to 1, and j from n to i. There are only two transitions: First, d[i - 1][j] = max(d[i - 1][j], d[i][j]) — we will not use operation of upgrading of array in the current position. Second, d[i - 1][i - 1] = max(d[i - 1][i - 1], d[i][j] + f(tgcd[j]) * i - f(tgcd[i - 1]) * i — we are using an operation of upgrading. f(a) — is a beauty of the number. tgcd[i] — gcd of all numbers on the prefix of length i. You can use function, which works in to calculate the beauty. Also you can make your solution more faster, it you will precalculate some small primes. Also you can use map < int, int >  to store calculated values. DP base d[n][n] = curBeauty — is a current beauty of the array. Second. Greedy. Let's find position r, which can upgrade our answer. If there some values of r — we will take most right position. We will add this position to the answer and upgrade our answer. Why it's correct? Let's fix an optimal solution (sequence of position, where we used an upgrading operation) r1 > r2 > ... > rk. Also we have an solution which was built by using greedy l1 > l2 > ... > lm. It's clear, that r1 ≤ l1, because all position with  > l1 cannot upgrade anything (otherwise greedy will choose it as first position). In other hand, r1 ≥ l1, because otherwise we can upgrade in position l1 and make answer better. So, r1 = l1, and after that we can use our propositions for big indexes i.402E - Strictly Positive Matrix / 403C - Strictly Positive MatrixLet's look at the matrix a as a connectivity matrix of some graph with n vertices. Moreover, if aij > 0, then we have directed edge in the graph between nodes (i, j). Otherwise, if aij = 0 that graph does not contains directed edge between pair of nodes (i, j). Let b = ak. What does bij means? bij is the number of paths of length exactly k in our graph from vertex i to vertex j. Let pos is an integer, such that a[pos][pos] > 0. That is, we have a loop in the graph. So, if from the vertex pos achievable all other vertexes and vice versa, from all other vertices reachable vertex pos, then the answer is YES, otherwise the answer is NO. If reachability is missing, it is clear that for any k akipos = 0. If reachability there, we will be able to reach self-loop, use self-loop \"to twist\", and after that we will go to some another vertex.403D - Beautiful Pairs of NumbersFirst, we can note, that length of sequence is not greater then 50. Ok, but why? Because all numbers bi - ai are different, so 0 + 1 + ... + 50 > 1000. Let's imagine, that sequence from input is a sequence of non-intersecting segments. So, ci = bi - ai + 1 is length of segment i. Also, . After that let's calculate the following DP: d[i][j][k] — — number of sequences for which following holds: c1 < c2 < ... < ci, ci ≥ 1 , c1 + c2 + ... + ci = j and maximal number is less then k (upper bound of sequence). This DP will helps us to calculate number of ways to set length to each segment in sequence. It's simple to calculate such DP: base d[0][0][1] = 1, d[i][j][k + 1] = d[i][j][k + 1] + d[i][j][k] — we increase upper bound of sequence; d[i + 1][j + k][k + 1] = d[i + 1][j + k][k + 1] + d[i][j][k] — we are adding upper bound to the sequence. We can calculate such DP, by using only O(N2) of memory, where N = 1000. After that we should multiply d[i][j][k] on i!, because we need number of sequences ci, where order does not matter.After that we can calculate answer for n, k. Let's , where x — some upper bound of sequences. After that we should calculate next number: how many ways to set to distances between segments? It's clear, that we can increase distance between some segments, but we have only n - len such operations. It's well known, that answer number of ways equals to C(n - len + k, k). So, for each n we should sum by len following values: sum[len] * C(n - len + k, k).Note, that we need array C[n][k] (binomials) where n ≤ 2000, k ≤ 2000.403E - Two Rooted TreesFirst, for each vertex of the first and second tree we calculate two values in[s], out[s] — the entry time and exit time in dfs order from vertex with number 1. Also with each edge from both trees we will assosiate a pair (p, q), where p = min(in[u], in[v]), q = max(in[u], in[v]) (values in, out for each vertex we take from tree with another color). Now for each tree we will build two segment trees (yes, totally 4 segment trees). In first segment will store all pairs in following way: we will store a pair in node of segment tree if and only if (node of segment tree is a segment (l, r)) left element of pair lies in segment (l, r). In second segment tree we will store a pair if and only if right element of the pair lies in segment (l, r) All pairs in segment trees we will store in some order (in first segment tree — increasing order, in the second tree — decreasing order). Such trees use of memory, also you can build it in .Good. How to answer on query (l, r) — erase all edges from tree for which exactly one vertex have value in[s] in segment (l, r)? We will go down in our segment tree. Let's imagine, that now we in some node of segment tree. Because we store all pairs in the first segment tree in increasing order of the right element, so answer to the query is a some suffix of the array of pairs. After we can add they to the answer (if it not erased yet). After that we should modify our segment tree: for each node, where we work with suffixes, we should erase all pairs from such suffix. So, this solution in .My solution to E: 6052738",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10972",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 402\\s*A"
          },
          "content_length": 7846
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #236 - Codeforces - Code 1",
          "code": "int cn; cin >> cn;\n\tfor(int ci = 0; ci < cn; ci++) {\n\t\tint n,p; cin >> n >> p;\n\t\tint cnt = 0;\n\t\tfor(int k = 2; k <= n; k++) \n\t\t\tfor(int i = 1; i < k && ( cnt < (2*k + p) ) ; i++)\n\t\t\t\tcout << i << \" \" << k << \"\\n\", ++cnt;\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 2",
          "code": "int cn; cin >> cn;\n\tfor(int ci = 0; ci < cn; ci++) {\n\t\tint n,p; cin >> n >> p;\n\t\tint cnt = 0;\n\t\tfor(int k = 2; k <= n; k++) \n\t\t\tfor(int i = 1; i < k && ( cnt < (2*k + p) ) ; i++)\n\t\t\t\tcout << i << \" \" << k << \"\\n\", ++cnt;\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 3",
          "code": "V[j]/=gcd(V[j],Div[i]);\nDiv[j]/=gcd(Div[j],Div[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 4",
          "code": "V[j]/=gcd(V[j],Div[i]);\nDiv[j]/=gcd(Div[j],Div[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 5",
          "code": "for(int p : primes) {\n    if (p*p > v) break; // <- add this line\n    int cnt = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 6",
          "code": "for(int p : primes) {\n    if (p*p > v) break; // <- add this line\n    int cnt = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(2, 1000, \"k\");\n    inf.readSpace();\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readSpace();\n    int v = inf.readInt(1, 1000, \"v\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(2, 1000, \"k\");\n    inf.readSpace();\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readSpace();\n    int v = inf.readInt(1, 1000, \"v\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(2, 1000, \"k\");\n    inf.readSpace();\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readSpace();\n    int v = inf.readInt(1, 1000, \"v\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    string type = opt<string>(\"type\", \"random\");\n\n    int k = opt<int>(\"k\", -1);\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int v = opt<int>(\"v\", -1);\n\n    // Ensure constraints\n    if (k != -1) {\n        ensure(2 <= k && k <= 1000);\n    }\n    if (a != -1) {\n        ensure(1 <= a && a <= 1000);\n    }\n    if (b != -1) {\n        ensure(1 <= b && b <= 1000);\n    }\n    if (v != -1) {\n        ensure(1 <= v && v <= 1000);\n    }\n\n    // Now, generate missing values\n    if (type == \"random\") {\n        if (k == -1) k = rnd.next(2, 1000);\n        if (a == -1) a = rnd.next(1, 1000);\n        if (b == -1) b = rnd.next(1, 1000);\n        if (v == -1) v = rnd.next(1, 1000);\n    } else if (type == \"max_k\") {\n        k = 1000;\n        if (a == -1) a = rnd.next(1, 1000);\n        if (b == -1) b = rnd.next(1, 1000);\n        if (v == -1) v = rnd.next(1, 1000);\n    } else if (type == \"min_k\") {\n        k = 2;\n        if (a == -1) a = rnd.next(1, 1000);\n        if (b == -1) b = rnd.next(1, 1000);\n        if (v == -1) v = rnd.next(1, 1000);\n    } else if (type == \"max_a\") {\n        a = 1000;\n        if (k == -1) k = rnd.next(2, 1000);\n        if (b == -1) b = rnd.next(1, 1000);\n        if (v == -1) v = rnd.next(1, 1000);\n    } else if (type == \"min_a\") {\n        a = 1;\n        if (k == -1) k = rnd.next(2, 1000);\n        if (b == -1) b = rnd.next(1, 1000);\n        if (v == -1) v = rnd.next(1, 1000);\n    } else if (type == \"max_b\") {\n        b = 1000;\n        if (k == -1) k = rnd.next(2, 1000);\n        if (a == -1) a = rnd.next(1, 1000);\n        if (v == -1) v = rnd.next(1, 1000);\n    } else if (type == \"min_b\") {\n        b = 1;\n        if (k == -1) k = rnd.next(2, 1000);\n        if (a == -1) a = rnd.next(1, 1000);\n        if (v == -1) v = rnd.next(1, 1000);\n    } else if (type == \"max_v\") {\n        v = 1000;\n        if (k == -1) k = rnd.next(2, 1000);\n        if (a == -1) a = rnd.next(1, 1000);\n        if (b == -1) b = rnd.next(1, 1000);\n    } else if (type == \"min_v\") {\n        v = 1;\n        if (k == -1) k = rnd.next(2, 1000);\n        if (a == -1) a = rnd.next(1, 1000);\n        if (b == -1) b = rnd.next(1, 1000);\n    } else if (type == \"edge_case\") {\n        k = 2;\n        a = 1;\n        b = 1000;\n        v = 1;\n    } else if (type == \"impossible_case\") {\n        a = 1000;\n        v = 1;\n        b = 1;\n        k = 2;\n    } else {\n        // default to random\n        if (k == -1) k = rnd.next(2, 1000);\n        if (a == -1) a = rnd.next(1, 1000);\n        if (b == -1) b = rnd.next(1, 1000);\n        if (v == -1) v = rnd.next(1, 1000);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", k, a, b, v);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    string type = opt<string>(\"type\", \"random\");\n\n    int k = opt<int>(\"k\", -1);\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int v = opt<int>(\"v\", -1);\n\n    // Ensure constraints\n    if (k != -1) {\n        ensure(2 <= k && k <= 1000);\n    }\n    if (a != -1) {\n        ensure(1 <= a && a <= 1000);\n    }\n    if (b != -1) {\n        ensure(1 <= b && b <= 1000);\n    }\n    if (v != -1) {\n        ensure(1 <= v && v <= 1000);\n    }\n\n    // Now, generate missing values\n    if (type == \"random\") {\n        if (k == -1) k = rnd.next(2, 1000);\n        if (a == -1) a = rnd.next(1, 1000);\n        if (b == -1) b = rnd.next(1, 1000);\n        if (v == -1) v = rnd.next(1, 1000);\n    } else if (type == \"max_k\") {\n        k = 1000;\n        if (a == -1) a = rnd.next(1, 1000);\n        if (b == -1) b = rnd.next(1, 1000);\n        if (v == -1) v = rnd.next(1, 1000);\n    } else if (type == \"min_k\") {\n        k = 2;\n        if (a == -1) a = rnd.next(1, 1000);\n        if (b == -1) b = rnd.next(1, 1000);\n        if (v == -1) v = rnd.next(1, 1000);\n    } else if (type == \"max_a\") {\n        a = 1000;\n        if (k == -1) k = rnd.next(2, 1000);\n        if (b == -1) b = rnd.next(1, 1000);\n        if (v == -1) v = rnd.next(1, 1000);\n    } else if (type == \"min_a\") {\n        a = 1;\n        if (k == -1) k = rnd.next(2, 1000);\n        if (b == -1) b = rnd.next(1, 1000);\n        if (v == -1) v = rnd.next(1, 1000);\n    } else if (type == \"max_b\") {\n        b = 1000;\n        if (k == -1) k = rnd.next(2, 1000);\n        if (a == -1) a = rnd.next(1, 1000);\n        if (v == -1) v = rnd.next(1, 1000);\n    } else if (type == \"min_b\") {\n        b = 1;\n        if (k == -1) k = rnd.next(2, 1000);\n        if (a == -1) a = rnd.next(1, 1000);\n        if (v == -1) v = rnd.next(1, 1000);\n    } else if (type == \"max_v\") {\n        v = 1000;\n        if (k == -1) k = rnd.next(2, 1000);\n        if (a == -1) a = rnd.next(1, 1000);\n        if (b == -1) b = rnd.next(1, 1000);\n    } else if (type == \"min_v\") {\n        v = 1;\n        if (k == -1) k = rnd.next(2, 1000);\n        if (a == -1) a = rnd.next(1, 1000);\n        if (b == -1) b = rnd.next(1, 1000);\n    } else if (type == \"edge_case\") {\n        k = 2;\n        a = 1;\n        b = 1000;\n        v = 1;\n    } else if (type == \"impossible_case\") {\n        a = 1000;\n        v = 1;\n        b = 1;\n        k = 2;\n    } else {\n        // default to random\n        if (k == -1) k = rnd.next(2, 1000);\n        if (a == -1) a = rnd.next(1, 1000);\n        if (b == -1) b = rnd.next(1, 1000);\n        if (v == -1) v = rnd.next(1, 1000);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", k, a, b, v);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type max_k\n./gen -type min_k\n./gen -type max_a\n./gen -type min_a\n./gen -type max_b\n./gen -type min_b\n./gen -type max_v\n./gen -type min_v\n./gen -type edge_case\n./gen -type impossible_case\n./gen -type random -k 2\n./gen -type random -k 1000\n./gen -type random -a 1000\n./gen -type random -a 1\n./gen -type random -b 1000\n./gen -type random -b 1\n./gen -type random -v 1000\n./gen -type random -v 1\n./gen -type random -k 2 -a 1000 -b 1 -v 1\n./gen -type random -k 1000 -a 1 -b 1000 -v 1000\n./gen -type random -k 500 -a 500 -b 500 -v 500\n./gen -type random -k 2 -a 999 -b 1 -v 1\n./gen -type random -k 2 -a 1000 -b 1000 -v 1\n./gen -type random -k 1000 -a 1000 -b 1 -v 1000\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:38.971840",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "402/B",
      "title": "B. Trees in a Row",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers: n, k (1 ≤ n, k ≤ 1000). The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 1000) — the heights of the trees in the row.",
      "output_spec": "OutputIn the first line print a single integer p — the minimum number of minutes the gardener needs. In the next p lines print the description of his actions. If the gardener needs to increase the height of the j-th (1 ≤ j ≤ n) tree from the left by x (x ≥ 1) meters, then print in the corresponding line \"+ j x\". If the gardener needs to decrease the height of the j-th (1 ≤ j ≤ n) tree from the left by x (x ≥ 1) meters, print on the corresponding line \"- j x\".If there are multiple ways to make a row of trees beautiful in the minimum number of actions, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy4 11 2 1 5OutputCopy2+ 3 2- 4 1InputCopy4 11 2 3 4OutputCopy0",
      "description": "B. Trees in a Row\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers: n, k (1 ≤ n, k ≤ 1000). The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 1000) — the heights of the trees in the row.\n\nOutputIn the first line print a single integer p — the minimum number of minutes the gardener needs. In the next p lines print the description of his actions. If the gardener needs to increase the height of the j-th (1 ≤ j ≤ n) tree from the left by x (x ≥ 1) meters, then print in the corresponding line \"+ j x\". If the gardener needs to decrease the height of the j-th (1 ≤ j ≤ n) tree from the left by x (x ≥ 1) meters, print on the corresponding line \"- j x\".If there are multiple ways to make a row of trees beautiful in the minimum number of actions, you are allowed to print any of them.\n\nInputCopy4 11 2 1 5OutputCopy2+ 3 2- 4 1InputCopy4 11 2 3 4OutputCopy0\n\nInputCopy4 11 2 1 5\n\nOutputCopy2+ 3 2- 4 1\n\nInputCopy4 11 2 3 4\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #236 - Codeforces",
          "content": "Soon (on March 16, 19:30 MSK) you are lucky to participate in Codeforces Round #236 for both divisions.Problems have been prepared by me. It’s my first round for both divisions and I hope not last. I want to thank Gerald Agapov (Gerald) for help in preparation of this round, Ilya Los (IlyaLos) and Ignatyev Alexander (aiMR) for testing of problems, Mary Belova(Delinur) for translating the problems, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems. UPD: Scoring system:Div. 2: 500 — 1000 — 1500 — 2000 — 2500Div. 1: 500 — 1000 — 1500 — 1500 — 2000 UPD:Contest finished, congratulation for winners!Div.2 : vladb iceiceice LoneFox ofpsxx adsz Div. 1: 1 sillycross 2 KADR 2 vepifanov 4 Endagorion 5 glassices 6 cgy4ever 7 rowdark 8 snuke 9 ftiasch 10 fsouza UPD:Editorial. UPD:Round Statistics from DmitriyH.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10959",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 839
        },
        {
          "title": "Editorial Codeforces Round #236 - Codeforces",
          "content": "402A - NutsLet's fix some value of boxes ans. After that we can get exactly cnt = ans + min((k - 1) * ans, B) of sections. So, if cnt * v ≥ a, then ans be an answer. After that you can use brute force to find smallest possible value of ans.402B - Trees in a RowLet's fix height of the first tree: let's call it a. Of course, a is an integer from segment [1, 1000]. After that, for the fixed height a of the first tree we can calculate heights of the others trees: a, a + k, a + 2k, and so on. After that you should find minimal number of operations ans to achive such heights. After that we can use brute force to find smallest possible ans for each a from 1 to 1000. For best height of the first tree you should print all operations.402C - Searching for Graph / 403A - Searching for GraphI will describe two solutions.First. Consider all pairs (i, j) (1 ≤ i < j ≤ n). After you should ouput the first 2n + p pairs in lexicographical order.It's clear to understand, that it is enough to prove, that 0-interesting graph is correct or  - 3 -interesting graph is correct. We will prove for  - 3 -interesting graph, that it is correct. This graph consists of triangles, which have an common edge 1 — 2. Let's fix some subset of vertexes, which does not contains vertexes 1 and 2. In such sets there are no edges. Let's fix some subset, which contains exactly one vertex (1 or 2). In such subsets there are exactly k - 1 edges, where k is the size of such subset. In other subset there are exactly 2 * (k — 2) + 1 edges, where k is the size of such subset.Second. Let's use some brute force, to build graphs with 0-interesting graphs with sizes 5, 6, 7, 8, 9 vertexes. Now, to build p-interesting graph with n vertexes, We will build 0-interesting graph, and after that we will add to it p another edges, which is not in the graph. We will build 0-interesting graphs using the following approach: Let's took k disjointed components, from graphs with number of vertexes from 5 to 9, in such way that there are exactly n vertexes in graph.402D - Upgrading Array / 403B - Upgrading ArrayI will describe two solutions.First. Dynamic programming approach. Let's calculate an DP d[i][j] — which is the best possible answer we can achieve, if current prefix has length i and we used operation of Upgrading last time in position j. It is clear to understand, that we should iterate i from n to 1, and j from n to i. There are only two transitions: First, d[i - 1][j] = max(d[i - 1][j], d[i][j]) — we will not use operation of upgrading of array in the current position. Second, d[i - 1][i - 1] = max(d[i - 1][i - 1], d[i][j] + f(tgcd[j]) * i - f(tgcd[i - 1]) * i — we are using an operation of upgrading. f(a) — is a beauty of the number. tgcd[i] — gcd of all numbers on the prefix of length i. You can use function, which works in to calculate the beauty. Also you can make your solution more faster, it you will precalculate some small primes. Also you can use map < int, int >  to store calculated values. DP base d[n][n] = curBeauty — is a current beauty of the array. Second. Greedy. Let's find position r, which can upgrade our answer. If there some values of r — we will take most right position. We will add this position to the answer and upgrade our answer. Why it's correct? Let's fix an optimal solution (sequence of position, where we used an upgrading operation) r1 > r2 > ... > rk. Also we have an solution which was built by using greedy l1 > l2 > ... > lm. It's clear, that r1 ≤ l1, because all position with  > l1 cannot upgrade anything (otherwise greedy will choose it as first position). In other hand, r1 ≥ l1, because otherwise we can upgrade in position l1 and make answer better. So, r1 = l1, and after that we can use our propositions for big indexes i.402E - Strictly Positive Matrix / 403C - Strictly Positive MatrixLet's look at the matrix a as a connectivity matrix of some graph with n vertices. Moreover, if aij > 0, then we have directed edge in the graph between nodes (i, j). Otherwise, if aij = 0 that graph does not contains directed edge between pair of nodes (i, j). Let b = ak. What does bij means? bij is the number of paths of length exactly k in our graph from vertex i to vertex j. Let pos is an integer, such that a[pos][pos] > 0. That is, we have a loop in the graph. So, if from the vertex pos achievable all other vertexes and vice versa, from all other vertices reachable vertex pos, then the answer is YES, otherwise the answer is NO. If reachability is missing, it is clear that for any k akipos = 0. If reachability there, we will be able to reach self-loop, use self-loop \"to twist\", and after that we will go to some another vertex.403D - Beautiful Pairs of NumbersFirst, we can note, that length of sequence is not greater then 50. Ok, but why? Because all numbers bi - ai are different, so 0 + 1 + ... + 50 > 1000. Let's imagine, that sequence from input is a sequence of non-intersecting segments. So, ci = bi - ai + 1 is length of segment i. Also, . After that let's calculate the following DP: d[i][j][k] — — number of sequences for which following holds: c1 < c2 < ... < ci, ci ≥ 1 , c1 + c2 + ... + ci = j and maximal number is less then k (upper bound of sequence). This DP will helps us to calculate number of ways to set length to each segment in sequence. It's simple to calculate such DP: base d[0][0][1] = 1, d[i][j][k + 1] = d[i][j][k + 1] + d[i][j][k] — we increase upper bound of sequence; d[i + 1][j + k][k + 1] = d[i + 1][j + k][k + 1] + d[i][j][k] — we are adding upper bound to the sequence. We can calculate such DP, by using only O(N2) of memory, where N = 1000. After that we should multiply d[i][j][k] on i!, because we need number of sequences ci, where order does not matter.After that we can calculate answer for n, k. Let's , where x — some upper bound of sequences. After that we should calculate next number: how many ways to set to distances between segments? It's clear, that we can increase distance between some segments, but we have only n - len such operations. It's well known, that answer number of ways equals to C(n - len + k, k). So, for each n we should sum by len following values: sum[len] * C(n - len + k, k).Note, that we need array C[n][k] (binomials) where n ≤ 2000, k ≤ 2000.403E - Two Rooted TreesFirst, for each vertex of the first and second tree we calculate two values in[s], out[s] — the entry time and exit time in dfs order from vertex with number 1. Also with each edge from both trees we will assosiate a pair (p, q), where p = min(in[u], in[v]), q = max(in[u], in[v]) (values in, out for each vertex we take from tree with another color). Now for each tree we will build two segment trees (yes, totally 4 segment trees). In first segment will store all pairs in following way: we will store a pair in node of segment tree if and only if (node of segment tree is a segment (l, r)) left element of pair lies in segment (l, r). In second segment tree we will store a pair if and only if right element of the pair lies in segment (l, r) All pairs in segment trees we will store in some order (in first segment tree — increasing order, in the second tree — decreasing order). Such trees use of memory, also you can build it in .Good. How to answer on query (l, r) — erase all edges from tree for which exactly one vertex have value in[s] in segment (l, r)? We will go down in our segment tree. Let's imagine, that now we in some node of segment tree. Because we store all pairs in the first segment tree in increasing order of the right element, so answer to the query is a some suffix of the array of pairs. After we can add they to the answer (if it not erased yet). After that we should modify our segment tree: for each node, where we work with suffixes, we should erase all pairs from such suffix. So, this solution in .My solution to E: 6052738",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10972",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 402\\s*B"
          },
          "content_length": 7846
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #236 - Codeforces - Code 1",
          "code": "int cn; cin >> cn;\n\tfor(int ci = 0; ci < cn; ci++) {\n\t\tint n,p; cin >> n >> p;\n\t\tint cnt = 0;\n\t\tfor(int k = 2; k <= n; k++) \n\t\t\tfor(int i = 1; i < k && ( cnt < (2*k + p) ) ; i++)\n\t\t\t\tcout << i << \" \" << k << \"\\n\", ++cnt;\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 2",
          "code": "int cn; cin >> cn;\n\tfor(int ci = 0; ci < cn; ci++) {\n\t\tint n,p; cin >> n >> p;\n\t\tint cnt = 0;\n\t\tfor(int k = 2; k <= n; k++) \n\t\t\tfor(int i = 1; i < k && ( cnt < (2*k + p) ) ; i++)\n\t\t\t\tcout << i << \" \" << k << \"\\n\", ++cnt;\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 3",
          "code": "V[j]/=gcd(V[j],Div[i]);\nDiv[j]/=gcd(Div[j],Div[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 4",
          "code": "V[j]/=gcd(V[j],Div[i]);\nDiv[j]/=gcd(Div[j],Div[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 5",
          "code": "for(int p : primes) {\n    if (p*p > v) break; // <- add this line\n    int cnt = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 6",
          "code": "for(int p : primes) {\n    if (p*p > v) break; // <- add this line\n    int cnt = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    int k = inf.readInt(1, 1000, \"k\");\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        a[i] = inf.readInt(1, 1000, format(\"a[%d]\", i + 1).c_str());\n    }\n\n    int p_jury = ans.readInt(0, INT_MAX, \"p_jury\");\n\n    int p_participant = ouf.readInt(0, INT_MAX, \"p\");\n    if (p_participant > p_jury) {\n        quitf(_wa, \"Jury has better answer: p_jury = %d, participant's p = %d\", p_jury, p_participant);\n    }\n    if (p_participant < p_jury) {\n        quitf(_fail, \"Participant has better answer: p_jury = %d, participant's p = %d\", p_jury, p_participant);\n    }\n\n    for (int i = 0; i < p_participant; i++) {\n        string action = ouf.readToken();\n        if (action != \"+\" && action != \"-\") {\n            quitf(_wa, \"Invalid action at line %d: expected '+' or '-', found '%s'\", i + 2, action.c_str());\n        }\n        int j = ouf.readInt(1, n, format(\"tree index at line %d\", i + 2).c_str());\n        int x = ouf.readInt(1, INT_MAX, format(\"x at line %d\", i + 2).c_str());\n        if (action == \"+\") {\n            a[j - 1] += x;\n        } else { // action == \"-\"\n            a[j - 1] -= x;\n            if (a[j - 1] <= 0) {\n                quitf(_wa, \"After applying action at line %d, height of tree %d is not positive\", i + 2, j);\n            }\n        }\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        if (a[i + 1] - a[i] != k) {\n            quitf(_wa, \"After applying actions, ai+1 - ai != k at position %d: a[%d]=%d, a[%d]=%d\", i + 1, i + 1, a[i], i + 2, a[i + 1]);\n        }\n    }\n\n    quitf(_ok, \"p = %d\", p_participant);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a;\n\n    if (type == \"minimal_n_k\") {\n        n = 1;\n        k = 1;\n        a.resize(n);\n        a[0] = rnd.next(1, 1000);\n    } else if (type == \"maximal_n_k\") {\n        n = 1000;\n        k = 1000;\n        a.resize(n);\n        // Since a[i] = a[0] + i * k, to prevent exceeding 1000, a[0] must be 1\n        a[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i - 1] + k;\n            if (a[i] > 1000) a[i] = 1000;\n        }\n    } else {\n        a.resize(n);\n        if (type == \"random\") {\n            for (int i = 0; i < n; ++i) {\n                a[i] = rnd.next(1, 1000);\n            }\n        } else if (type == \"already_good\") {\n            int a0_max = 1000 - (n - 1) * k;\n            int a0_min = 1;\n            if (a0_max < a0_min) a0_max = a0_min;\n            a[0] = rnd.next(a0_min, a0_max);\n            for (int i = 1; i < n; ++i) {\n                a[i] = a[0] + i * k;\n            }\n        } else if (type == \"max_adjust\") {\n            // Generate desired heights\n            int desired_a0_max = 1000 - (n - 1) * k;\n            int desired_a0_min = 1;\n            if (desired_a0_max < desired_a0_min) desired_a0_max = desired_a0_min;\n            int desired_a0 = rnd.next(desired_a0_min, desired_a0_max);\n            vector<int> desired_a(n);\n            for (int i = 0; i < n; ++i) {\n                desired_a[i] = desired_a0 + i * k;\n            }\n            // Set initial heights to maximize adjustments\n            for (int i = 0; i < n; ++i) {\n                if (desired_a[i] <= 500) {\n                    a[i] = 1000;\n                } else {\n                    a[i] = 1;\n                }\n            }\n        } else if (type == \"constant_heights\") {\n            int h = rnd.next(1, 1000);\n            for (int i = 0; i < n; ++i) {\n                a[i] = h;\n            }\n        } else if (type == \"increasing_heights\") {\n            a[0] = rnd.next(1, 100);\n            for (int i = 1; i < n; ++i) {\n                int diff = rnd.next(1, 100);\n                a[i] = a[i - 1] + diff;\n                if (a[i] > 1000) a[i] = 1000;\n            }\n        } else if (type == \"decreasing_heights\") {\n            a[0] = rnd.next(900, 1000);\n            for (int i = 1; i < n; ++i) {\n                int diff = rnd.next(1, 100);\n                a[i] = a[i - 1] - diff;\n                if (a[i] < 1) a[i] = 1;\n            }\n        } else {\n            // Default to random\n            for (int i = 0; i < n; ++i) {\n                a[i] = rnd.next(1, 1000);\n            }\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a;\n\n    if (type == \"minimal_n_k\") {\n        n = 1;\n        k = 1;\n        a.resize(n);\n        a[0] = rnd.next(1, 1000);\n    } else if (type == \"maximal_n_k\") {\n        n = 1000;\n        k = 1000;\n        a.resize(n);\n        // Since a[i] = a[0] + i * k, to prevent exceeding 1000, a[0] must be 1\n        a[0] = 1;\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i - 1] + k;\n            if (a[i] > 1000) a[i] = 1000;\n        }\n    } else {\n        a.resize(n);\n        if (type == \"random\") {\n            for (int i = 0; i < n; ++i) {\n                a[i] = rnd.next(1, 1000);\n            }\n        } else if (type == \"already_good\") {\n            int a0_max = 1000 - (n - 1) * k;\n            int a0_min = 1;\n            if (a0_max < a0_min) a0_max = a0_min;\n            a[0] = rnd.next(a0_min, a0_max);\n            for (int i = 1; i < n; ++i) {\n                a[i] = a[0] + i * k;\n            }\n        } else if (type == \"max_adjust\") {\n            // Generate desired heights\n            int desired_a0_max = 1000 - (n - 1) * k;\n            int desired_a0_min = 1;\n            if (desired_a0_max < desired_a0_min) desired_a0_max = desired_a0_min;\n            int desired_a0 = rnd.next(desired_a0_min, desired_a0_max);\n            vector<int> desired_a(n);\n            for (int i = 0; i < n; ++i) {\n                desired_a[i] = desired_a0 + i * k;\n            }\n            // Set initial heights to maximize adjustments\n            for (int i = 0; i < n; ++i) {\n                if (desired_a[i] <= 500) {\n                    a[i] = 1000;\n                } else {\n                    a[i] = 1;\n                }\n            }\n        } else if (type == \"constant_heights\") {\n            int h = rnd.next(1, 1000);\n            for (int i = 0; i < n; ++i) {\n                a[i] = h;\n            }\n        } else if (type == \"increasing_heights\") {\n            a[0] = rnd.next(1, 100);\n            for (int i = 1; i < n; ++i) {\n                int diff = rnd.next(1, 100);\n                a[i] = a[i - 1] + diff;\n                if (a[i] > 1000) a[i] = 1000;\n            }\n        } else if (type == \"decreasing_heights\") {\n            a[0] = rnd.next(900, 1000);\n            for (int i = 1; i < n; ++i) {\n                int diff = rnd.next(1, 100);\n                a[i] = a[i - 1] - diff;\n                if (a[i] < 1) a[i] = 1;\n            }\n        } else {\n            // Default to random\n            for (int i = 0; i < n; ++i) {\n                a[i] = rnd.next(1, 1000);\n            }\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type minimal_n_k\n\n./gen -n 1000 -k 1000 -type maximal_n_k\n\n./gen -n 10 -k 1 -type already_good\n./gen -n 10 -k 1 -type random\n./gen -n 10 -k 1 -type max_adjust\n\n./gen -n 100 -k 10 -type already_good\n./gen -n 100 -k 10 -type random\n./gen -n 100 -k 10 -type max_adjust\n\n./gen -n 500 -k 5 -type already_good\n./gen -n 500 -k 5 -type random\n./gen -n 500 -k 5 -type max_adjust\n\n./gen -n 1000 -k 1 -type increasing_heights\n./gen -n 1000 -k 1 -type decreasing_heights\n\n./gen -n 1000 -k 1000 -type constant_heights\n\n./gen -n 999 -k 1 -type max_adjust\n\n./gen -n 1000 -k 999 -type already_good\n\n./gen -n 2 -k 1000 -type already_good\n\n./gen -n 1000 -k 1 -type random\n./gen -n 1000 -k 1 -type already_good\n./gen -n 1000 -k 1 -type max_adjust\n\n./gen -n 100 -k 50 -type constant_heights\n./gen -n 100 -k 50 -type increasing_heights\n./gen -n 100 -k 50 -type decreasing_heights\n\n./gen -n 500 -k 1 -type increasing_heights\n./gen -n 500 -k 1 -type decreasing_heights\n\n./gen -n 10 -k 100 -type random\n./gen -n 10 -k 100 -type already_good\n./gen -n 10 -k 100 -type max_adjust\n\n./gen -n 1 -k 500 -type minimal_n_k\n./gen -n 1 -k 1000 -type minimal_n_k\n\n./gen -n 1000 -k 1 -type maximal_n_k\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:41.235656",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "402/C",
      "title": "C. Searching for Graph",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer t (1 ≤ t ≤ 5) — the number of tests in the input. Next t lines each contains two space-separated integers: n, p (5 ≤ n ≤ 24; p ≥ 0; ) — the number of vertices in the graph and the interest value for the appropriate test. It is guaranteed that the required graph exists.",
      "output_spec": "OutputFor each of the t tests print 2n + p lines containing the description of the edges of a p-interesting graph: the i-th line must contain two space-separated integers ai, bi (1 ≤ ai, bi ≤ n; ai ≠ bi) — two vertices, connected by an edge in the resulting graph. Consider the graph vertices numbered with integers from 1 to n. Print the answers to the tests in the order the tests occur in the input. If there are multiple solutions, you can print any of them.",
      "sample_tests": "ExamplesInputCopy16 0OutputCopy1 21 31 41 51 62 32 42 52 63 43 53 6",
      "description": "C. Searching for Graph\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer t (1 ≤ t ≤ 5) — the number of tests in the input. Next t lines each contains two space-separated integers: n, p (5 ≤ n ≤ 24; p ≥ 0; ) — the number of vertices in the graph and the interest value for the appropriate test. It is guaranteed that the required graph exists.\n\nOutputFor each of the t tests print 2n + p lines containing the description of the edges of a p-interesting graph: the i-th line must contain two space-separated integers ai, bi (1 ≤ ai, bi ≤ n; ai ≠ bi) — two vertices, connected by an edge in the resulting graph. Consider the graph vertices numbered with integers from 1 to n. Print the answers to the tests in the order the tests occur in the input. If there are multiple solutions, you can print any of them.\n\nInputCopy16 0OutputCopy1 21 31 41 51 62 32 42 52 63 43 53 6\n\nInputCopy16 0\n\nOutputCopy1 21 31 41 51 62 32 42 52 63 43 53 6",
      "solutions": [
        {
          "title": "Codeforces Round #236 - Codeforces",
          "content": "Soon (on March 16, 19:30 MSK) you are lucky to participate in Codeforces Round #236 for both divisions.Problems have been prepared by me. It’s my first round for both divisions and I hope not last. I want to thank Gerald Agapov (Gerald) for help in preparation of this round, Ilya Los (IlyaLos) and Ignatyev Alexander (aiMR) for testing of problems, Mary Belova(Delinur) for translating the problems, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems. UPD: Scoring system:Div. 2: 500 — 1000 — 1500 — 2000 — 2500Div. 1: 500 — 1000 — 1500 — 1500 — 2000 UPD:Contest finished, congratulation for winners!Div.2 : vladb iceiceice LoneFox ofpsxx adsz Div. 1: 1 sillycross 2 KADR 2 vepifanov 4 Endagorion 5 glassices 6 cgy4ever 7 rowdark 8 snuke 9 ftiasch 10 fsouza UPD:Editorial. UPD:Round Statistics from DmitriyH.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10959",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 839
        },
        {
          "title": "Editorial Codeforces Round #236 - Codeforces",
          "content": "402A - NutsLet's fix some value of boxes ans. After that we can get exactly cnt = ans + min((k - 1) * ans, B) of sections. So, if cnt * v ≥ a, then ans be an answer. After that you can use brute force to find smallest possible value of ans.402B - Trees in a RowLet's fix height of the first tree: let's call it a. Of course, a is an integer from segment [1, 1000]. After that, for the fixed height a of the first tree we can calculate heights of the others trees: a, a + k, a + 2k, and so on. After that you should find minimal number of operations ans to achive such heights. After that we can use brute force to find smallest possible ans for each a from 1 to 1000. For best height of the first tree you should print all operations.402C - Searching for Graph / 403A - Searching for GraphI will describe two solutions.First. Consider all pairs (i, j) (1 ≤ i < j ≤ n). After you should ouput the first 2n + p pairs in lexicographical order.It's clear to understand, that it is enough to prove, that 0-interesting graph is correct or  - 3 -interesting graph is correct. We will prove for  - 3 -interesting graph, that it is correct. This graph consists of triangles, which have an common edge 1 — 2. Let's fix some subset of vertexes, which does not contains vertexes 1 and 2. In such sets there are no edges. Let's fix some subset, which contains exactly one vertex (1 or 2). In such subsets there are exactly k - 1 edges, where k is the size of such subset. In other subset there are exactly 2 * (k — 2) + 1 edges, where k is the size of such subset.Second. Let's use some brute force, to build graphs with 0-interesting graphs with sizes 5, 6, 7, 8, 9 vertexes. Now, to build p-interesting graph with n vertexes, We will build 0-interesting graph, and after that we will add to it p another edges, which is not in the graph. We will build 0-interesting graphs using the following approach: Let's took k disjointed components, from graphs with number of vertexes from 5 to 9, in such way that there are exactly n vertexes in graph.402D - Upgrading Array / 403B - Upgrading ArrayI will describe two solutions.First. Dynamic programming approach. Let's calculate an DP d[i][j] — which is the best possible answer we can achieve, if current prefix has length i and we used operation of Upgrading last time in position j. It is clear to understand, that we should iterate i from n to 1, and j from n to i. There are only two transitions: First, d[i - 1][j] = max(d[i - 1][j], d[i][j]) — we will not use operation of upgrading of array in the current position. Second, d[i - 1][i - 1] = max(d[i - 1][i - 1], d[i][j] + f(tgcd[j]) * i - f(tgcd[i - 1]) * i — we are using an operation of upgrading. f(a) — is a beauty of the number. tgcd[i] — gcd of all numbers on the prefix of length i. You can use function, which works in to calculate the beauty. Also you can make your solution more faster, it you will precalculate some small primes. Also you can use map < int, int >  to store calculated values. DP base d[n][n] = curBeauty — is a current beauty of the array. Second. Greedy. Let's find position r, which can upgrade our answer. If there some values of r — we will take most right position. We will add this position to the answer and upgrade our answer. Why it's correct? Let's fix an optimal solution (sequence of position, where we used an upgrading operation) r1 > r2 > ... > rk. Also we have an solution which was built by using greedy l1 > l2 > ... > lm. It's clear, that r1 ≤ l1, because all position with  > l1 cannot upgrade anything (otherwise greedy will choose it as first position). In other hand, r1 ≥ l1, because otherwise we can upgrade in position l1 and make answer better. So, r1 = l1, and after that we can use our propositions for big indexes i.402E - Strictly Positive Matrix / 403C - Strictly Positive MatrixLet's look at the matrix a as a connectivity matrix of some graph with n vertices. Moreover, if aij > 0, then we have directed edge in the graph between nodes (i, j). Otherwise, if aij = 0 that graph does not contains directed edge between pair of nodes (i, j). Let b = ak. What does bij means? bij is the number of paths of length exactly k in our graph from vertex i to vertex j. Let pos is an integer, such that a[pos][pos] > 0. That is, we have a loop in the graph. So, if from the vertex pos achievable all other vertexes and vice versa, from all other vertices reachable vertex pos, then the answer is YES, otherwise the answer is NO. If reachability is missing, it is clear that for any k akipos = 0. If reachability there, we will be able to reach self-loop, use self-loop \"to twist\", and after that we will go to some another vertex.403D - Beautiful Pairs of NumbersFirst, we can note, that length of sequence is not greater then 50. Ok, but why? Because all numbers bi - ai are different, so 0 + 1 + ... + 50 > 1000. Let's imagine, that sequence from input is a sequence of non-intersecting segments. So, ci = bi - ai + 1 is length of segment i. Also, . After that let's calculate the following DP: d[i][j][k] — — number of sequences for which following holds: c1 < c2 < ... < ci, ci ≥ 1 , c1 + c2 + ... + ci = j and maximal number is less then k (upper bound of sequence). This DP will helps us to calculate number of ways to set length to each segment in sequence. It's simple to calculate such DP: base d[0][0][1] = 1, d[i][j][k + 1] = d[i][j][k + 1] + d[i][j][k] — we increase upper bound of sequence; d[i + 1][j + k][k + 1] = d[i + 1][j + k][k + 1] + d[i][j][k] — we are adding upper bound to the sequence. We can calculate such DP, by using only O(N2) of memory, where N = 1000. After that we should multiply d[i][j][k] on i!, because we need number of sequences ci, where order does not matter.After that we can calculate answer for n, k. Let's , where x — some upper bound of sequences. After that we should calculate next number: how many ways to set to distances between segments? It's clear, that we can increase distance between some segments, but we have only n - len such operations. It's well known, that answer number of ways equals to C(n - len + k, k). So, for each n we should sum by len following values: sum[len] * C(n - len + k, k).Note, that we need array C[n][k] (binomials) where n ≤ 2000, k ≤ 2000.403E - Two Rooted TreesFirst, for each vertex of the first and second tree we calculate two values in[s], out[s] — the entry time and exit time in dfs order from vertex with number 1. Also with each edge from both trees we will assosiate a pair (p, q), where p = min(in[u], in[v]), q = max(in[u], in[v]) (values in, out for each vertex we take from tree with another color). Now for each tree we will build two segment trees (yes, totally 4 segment trees). In first segment will store all pairs in following way: we will store a pair in node of segment tree if and only if (node of segment tree is a segment (l, r)) left element of pair lies in segment (l, r). In second segment tree we will store a pair if and only if right element of the pair lies in segment (l, r) All pairs in segment trees we will store in some order (in first segment tree — increasing order, in the second tree — decreasing order). Such trees use of memory, also you can build it in .Good. How to answer on query (l, r) — erase all edges from tree for which exactly one vertex have value in[s] in segment (l, r)? We will go down in our segment tree. Let's imagine, that now we in some node of segment tree. Because we store all pairs in the first segment tree in increasing order of the right element, so answer to the query is a some suffix of the array of pairs. After we can add they to the answer (if it not erased yet). After that we should modify our segment tree: for each node, where we work with suffixes, we should erase all pairs from such suffix. So, this solution in .My solution to E: 6052738",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10972",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 402\\s*C"
          },
          "content_length": 7846
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #236 - Codeforces - Code 1",
          "code": "int cn; cin >> cn;\n\tfor(int ci = 0; ci < cn; ci++) {\n\t\tint n,p; cin >> n >> p;\n\t\tint cnt = 0;\n\t\tfor(int k = 2; k <= n; k++) \n\t\t\tfor(int i = 1; i < k && ( cnt < (2*k + p) ) ; i++)\n\t\t\t\tcout << i << \" \" << k << \"\\n\", ++cnt;\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 2",
          "code": "int cn; cin >> cn;\n\tfor(int ci = 0; ci < cn; ci++) {\n\t\tint n,p; cin >> n >> p;\n\t\tint cnt = 0;\n\t\tfor(int k = 2; k <= n; k++) \n\t\t\tfor(int i = 1; i < k && ( cnt < (2*k + p) ) ; i++)\n\t\t\t\tcout << i << \" \" << k << \"\\n\", ++cnt;\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 3",
          "code": "V[j]/=gcd(V[j],Div[i]);\nDiv[j]/=gcd(Div[j],Div[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 4",
          "code": "V[j]/=gcd(V[j],Div[i]);\nDiv[j]/=gcd(Div[j],Div[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 5",
          "code": "for(int p : primes) {\n    if (p*p > v) break; // <- add this line\n    int cnt = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 6",
          "code": "for(int p : primes) {\n    if (p*p > v) break; // <- add this line\n    int cnt = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 5, \"t\");\n    inf.readEoln();\n    for (int test = 0; test < t; ++test) {\n        int n = inf.readInt(5, 24, \"n\");\n        inf.readSpace();\n        int max_p = n * (n - 1) / 2 - 2 * n;\n        int p = inf.readInt(0, max_p, \"p\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 5, \"t\");\n    inf.readEoln();\n    for (int test = 0; test < t; ++test) {\n        int n = inf.readInt(5, 24, \"n\");\n        inf.readSpace();\n        int max_p = n * (n - 1) / 2 - 2 * n;\n        int p = inf.readInt(0, max_p, \"p\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 5, \"t\");\n    inf.readEoln();\n    for (int test = 0; test < t; ++test) {\n        int n = inf.readInt(5, 24, \"n\");\n        inf.readSpace();\n        int max_p = n * (n - 1) / 2 - 2 * n;\n        int p = inf.readInt(0, max_p, \"p\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int t = inf.readInt(1, 5, \"t\");\n    for (int test = 1; test <= t; test++) {\n        int n = inf.readInt(5, 24, format(\"n[%d]\", test).c_str());\n        int max_p = n * (n - 1) / 2 - 2 * n;\n        int p = inf.readInt(0, max_p, format(\"p[%d]\", test).c_str());\n        int total_edges = 2 * n + p;\n\n        set<pair<int, int>> edges;\n        for (int i = 0; i < total_edges; i++) {\n            int a = ouf.readInt(1, n, format(\"a[%d]\", i + 1).c_str());\n            int b = ouf.readInt(1, n, format(\"b[%d]\", i + 1).c_str());\n\n            if (a == b) {\n                quitf(_wa, \"Self-loop detected on vertex %d in test case %d\", a, test);\n            }\n\n            int u = min(a, b);\n            int v = max(a, b);\n\n            pair<int, int> edge(u, v);\n            if (edges.count(edge)) {\n                quitf(_wa, \"Multiple edge between %d and %d in test case %d\", u, v, test);\n            } else {\n                edges.insert(edge);\n            }\n        }\n\n        // Check for extra data after reading expected edges\n        if (test < t || !ouf.eof()) {\n            // For all but the last test case, expect ends of lines or spaces between test cases\n            ouf.skipBlanks();\n        }\n    }\n    // Ensure there's no extra output\n    ouf.skipBlanks();\n    if (!ouf.eof())\n        quitf(_wa, \"Extra data detected in output\");\n\n    quitf(_ok, \"OK\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parameters\n    int t = opt<int>(\"t\", 1); // number of test cases (default 1)\n    ensure(1 <= t && t <= 5);\n\n    string n_str = opt<string>(\"n\", \"random\"); // n can be \"random\", \"5-24\", or specific value\n    string p_mode = opt<string>(\"p_mode\", \"random\"); // p_mode can be \"min\", \"max\", \"mid\", \"random\", or a specific number\n\n    vector<pair<int, int>> test_cases;\n\n    for (int i = 0; i < t; ++i) {\n        int n;\n        if (n_str == \"random\") {\n            n = rnd.next(5, 24);\n        } else if (n_str.find('-') != string::npos) {\n            // n is a range\n            int n_min, n_max;\n            sscanf(n_str.c_str(), \"%d-%d\", &n_min, &n_max);\n            ensure(5 <= n_min && n_min <= n_max && n_max <= 24);\n            n = rnd.next(n_min, n_max);\n        } else {\n            n = atoi(n_str.c_str());\n            ensure(5 <= n && n <= 24);\n        }\n\n        // Compute maximum possible p\n        int max_p = n * (n - 1) / 2 - 2 * n;\n        max_p = max(0, max_p); // ensure non-negative\n        // p >= 0\n\n        int p = 0;\n\n        if (p_mode == \"min\") {\n            p = 0;\n        } else if (p_mode == \"max\") {\n            p = max_p;\n        } else if (p_mode == \"random\") {\n            p = rnd.next(0, max_p);\n        } else if (p_mode == \"mid\") {\n            p = max_p / 2;\n        } else {\n            p = atoi(p_mode.c_str()); // if p_mode is a number, set p to that number\n            ensure(0 <= p && p <= max_p);\n        }\n\n        test_cases.push_back({n, p});\n    }\n\n    // Output t\n    printf(\"%d\\n\", t);\n    for (const auto& [n, p] : test_cases) {\n        printf(\"%d %d\\n\", n, p);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parameters\n    int t = opt<int>(\"t\", 1); // number of test cases (default 1)\n    ensure(1 <= t && t <= 5);\n\n    string n_str = opt<string>(\"n\", \"random\"); // n can be \"random\", \"5-24\", or specific value\n    string p_mode = opt<string>(\"p_mode\", \"random\"); // p_mode can be \"min\", \"max\", \"mid\", \"random\", or a specific number\n\n    vector<pair<int, int>> test_cases;\n\n    for (int i = 0; i < t; ++i) {\n        int n;\n        if (n_str == \"random\") {\n            n = rnd.next(5, 24);\n        } else if (n_str.find('-') != string::npos) {\n            // n is a range\n            int n_min, n_max;\n            sscanf(n_str.c_str(), \"%d-%d\", &n_min, &n_max);\n            ensure(5 <= n_min && n_min <= n_max && n_max <= 24);\n            n = rnd.next(n_min, n_max);\n        } else {\n            n = atoi(n_str.c_str());\n            ensure(5 <= n && n <= 24);\n        }\n\n        // Compute maximum possible p\n        int max_p = n * (n - 1) / 2 - 2 * n;\n        max_p = max(0, max_p); // ensure non-negative\n        // p >= 0\n\n        int p = 0;\n\n        if (p_mode == \"min\") {\n            p = 0;\n        } else if (p_mode == \"max\") {\n            p = max_p;\n        } else if (p_mode == \"random\") {\n            p = rnd.next(0, max_p);\n        } else if (p_mode == \"mid\") {\n            p = max_p / 2;\n        } else {\n            p = atoi(p_mode.c_str()); // if p_mode is a number, set p to that number\n            ensure(0 <= p && p <= max_p);\n        }\n\n        test_cases.push_back({n, p});\n    }\n\n    // Output t\n    printf(\"%d\\n\", t);\n    for (const auto& [n, p] : test_cases) {\n        printf(\"%d %d\\n\", n, p);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -n 5 -p_mode min\n./gen -t 1 -n 5 -p_mode max\n./gen -t 1 -n 5 -p_mode random\n\n./gen -t 1 -n 24 -p_mode min\n./gen -t 1 -n 24 -p_mode max\n./gen -t 1 -n 24 -p_mode random\n\n./gen -t 5 -n 24 -p_mode max\n./gen -t 5 -n 24 -p_mode min\n./gen -t 5 -n 24 -p_mode random\n\n./gen -t 5 -n 5 -p_mode max\n./gen -t 5 -n 5 -p_mode min\n./gen -t 5 -n 5 -p_mode random\n\n./gen -t 5 -n 5-24 -p_mode random\n\n./gen -t 2 -n 10 -p_mode 0\n./gen -t 2 -n 10 -p_mode max\n\n./gen -t 3 -n 15 -p_mode random\n\n./gen -t 4 -n random -p_mode random\n\n./gen -t 1 -n random -p_mode mid\n\n./gen -t 5 -n 24 -p_mode mid\n\n./gen -t 5 -n 20 -p_mode mid\n\n./gen -t 5 -n 5-24 -p_mode max\n\n./gen -t 3 -n 6 -p_mode 0\n./gen -t 3 -n 6 -p_mode 3\n\n./gen -t 4 -n 7 -p_mode random\n\n./gen -t 1 -n 13 -p_mode 3\n\n./gen -t 5 -n 6 -p_mode random\n\n./gen -t 2 -n 23 -p_mode random\n\n./gen -t 1 -n 24 -p_mode 100\n\n./gen -t 5 -n random -p_mode random\n\n./gen -t 2 -n 5-10 -p_mode random\n\n./gen -t 5 -n 5 -p_mode 0\n\n./gen -t 1 -n 24 -p_mode 227\n\n./gen -t 3 -n random -p_mode mid\n\n./gen -t 2 -n 7-14 -p_mode random\n\n./gen -t 5 -n 10-20 -p_mode max\n\n./gen -t 4 -n 5-24 -p_mode min\n\n./gen -t 5 -n 5-24 -p_mode mid\n\n./gen -t 5 -n 5-24 -p_mode random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:43.496294",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "402/D",
      "title": "D. Upgrading Array",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 5000) showing how many numbers are in the array and how many bad prime numbers there are.The second line contains n space-separated integers a[1], a[2], ..., a[n] (1 ≤ a[i] ≤ 109) — array a. The third line contains m space-separated integers b1, b2, ..., bm (2 ≤ b1 < b2 < ... < bm ≤ 109) — the set of bad prime numbers.",
      "output_spec": "OutputPrint a single integer — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy5 24 20 34 10 102 5OutputCopy-2InputCopy4 52 4 8 163 5 7 11 17OutputCopy10",
      "description": "D. Upgrading Array\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 5000) showing how many numbers are in the array and how many bad prime numbers there are.The second line contains n space-separated integers a[1], a[2], ..., a[n] (1 ≤ a[i] ≤ 109) — array a. The third line contains m space-separated integers b1, b2, ..., bm (2 ≤ b1 < b2 < ... < bm ≤ 109) — the set of bad prime numbers.\n\nOutputPrint a single integer — the answer to the problem.\n\nInputCopy5 24 20 34 10 102 5OutputCopy-2InputCopy4 52 4 8 163 5 7 11 17OutputCopy10\n\nInputCopy5 24 20 34 10 102 5\n\nOutputCopy-2\n\nInputCopy4 52 4 8 163 5 7 11 17\n\nOutputCopy10\n\nNoteNote that the answer to the problem can be negative.The GCD(x1, x2, ..., xk) is the maximum positive integer that divides each xi.",
      "solutions": [
        {
          "title": "Codeforces Round #236 - Codeforces",
          "content": "Soon (on March 16, 19:30 MSK) you are lucky to participate in Codeforces Round #236 for both divisions.Problems have been prepared by me. It’s my first round for both divisions and I hope not last. I want to thank Gerald Agapov (Gerald) for help in preparation of this round, Ilya Los (IlyaLos) and Ignatyev Alexander (aiMR) for testing of problems, Mary Belova(Delinur) for translating the problems, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems. UPD: Scoring system:Div. 2: 500 — 1000 — 1500 — 2000 — 2500Div. 1: 500 — 1000 — 1500 — 1500 — 2000 UPD:Contest finished, congratulation for winners!Div.2 : vladb iceiceice LoneFox ofpsxx adsz Div. 1: 1 sillycross 2 KADR 2 vepifanov 4 Endagorion 5 glassices 6 cgy4ever 7 rowdark 8 snuke 9 ftiasch 10 fsouza UPD:Editorial. UPD:Round Statistics from DmitriyH.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10959",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 839
        },
        {
          "title": "Editorial Codeforces Round #236 - Codeforces",
          "content": "402A - NutsLet's fix some value of boxes ans. After that we can get exactly cnt = ans + min((k - 1) * ans, B) of sections. So, if cnt * v ≥ a, then ans be an answer. After that you can use brute force to find smallest possible value of ans.402B - Trees in a RowLet's fix height of the first tree: let's call it a. Of course, a is an integer from segment [1, 1000]. After that, for the fixed height a of the first tree we can calculate heights of the others trees: a, a + k, a + 2k, and so on. After that you should find minimal number of operations ans to achive such heights. After that we can use brute force to find smallest possible ans for each a from 1 to 1000. For best height of the first tree you should print all operations.402C - Searching for Graph / 403A - Searching for GraphI will describe two solutions.First. Consider all pairs (i, j) (1 ≤ i < j ≤ n). After you should ouput the first 2n + p pairs in lexicographical order.It's clear to understand, that it is enough to prove, that 0-interesting graph is correct or  - 3 -interesting graph is correct. We will prove for  - 3 -interesting graph, that it is correct. This graph consists of triangles, which have an common edge 1 — 2. Let's fix some subset of vertexes, which does not contains vertexes 1 and 2. In such sets there are no edges. Let's fix some subset, which contains exactly one vertex (1 or 2). In such subsets there are exactly k - 1 edges, where k is the size of such subset. In other subset there are exactly 2 * (k — 2) + 1 edges, where k is the size of such subset.Second. Let's use some brute force, to build graphs with 0-interesting graphs with sizes 5, 6, 7, 8, 9 vertexes. Now, to build p-interesting graph with n vertexes, We will build 0-interesting graph, and after that we will add to it p another edges, which is not in the graph. We will build 0-interesting graphs using the following approach: Let's took k disjointed components, from graphs with number of vertexes from 5 to 9, in such way that there are exactly n vertexes in graph.402D - Upgrading Array / 403B - Upgrading ArrayI will describe two solutions.First. Dynamic programming approach. Let's calculate an DP d[i][j] — which is the best possible answer we can achieve, if current prefix has length i and we used operation of Upgrading last time in position j. It is clear to understand, that we should iterate i from n to 1, and j from n to i. There are only two transitions: First, d[i - 1][j] = max(d[i - 1][j], d[i][j]) — we will not use operation of upgrading of array in the current position. Second, d[i - 1][i - 1] = max(d[i - 1][i - 1], d[i][j] + f(tgcd[j]) * i - f(tgcd[i - 1]) * i — we are using an operation of upgrading. f(a) — is a beauty of the number. tgcd[i] — gcd of all numbers on the prefix of length i. You can use function, which works in to calculate the beauty. Also you can make your solution more faster, it you will precalculate some small primes. Also you can use map < int, int >  to store calculated values. DP base d[n][n] = curBeauty — is a current beauty of the array. Second. Greedy. Let's find position r, which can upgrade our answer. If there some values of r — we will take most right position. We will add this position to the answer and upgrade our answer. Why it's correct? Let's fix an optimal solution (sequence of position, where we used an upgrading operation) r1 > r2 > ... > rk. Also we have an solution which was built by using greedy l1 > l2 > ... > lm. It's clear, that r1 ≤ l1, because all position with  > l1 cannot upgrade anything (otherwise greedy will choose it as first position). In other hand, r1 ≥ l1, because otherwise we can upgrade in position l1 and make answer better. So, r1 = l1, and after that we can use our propositions for big indexes i.402E - Strictly Positive Matrix / 403C - Strictly Positive MatrixLet's look at the matrix a as a connectivity matrix of some graph with n vertices. Moreover, if aij > 0, then we have directed edge in the graph between nodes (i, j). Otherwise, if aij = 0 that graph does not contains directed edge between pair of nodes (i, j). Let b = ak. What does bij means? bij is the number of paths of length exactly k in our graph from vertex i to vertex j. Let pos is an integer, such that a[pos][pos] > 0. That is, we have a loop in the graph. So, if from the vertex pos achievable all other vertexes and vice versa, from all other vertices reachable vertex pos, then the answer is YES, otherwise the answer is NO. If reachability is missing, it is clear that for any k akipos = 0. If reachability there, we will be able to reach self-loop, use self-loop \"to twist\", and after that we will go to some another vertex.403D - Beautiful Pairs of NumbersFirst, we can note, that length of sequence is not greater then 50. Ok, but why? Because all numbers bi - ai are different, so 0 + 1 + ... + 50 > 1000. Let's imagine, that sequence from input is a sequence of non-intersecting segments. So, ci = bi - ai + 1 is length of segment i. Also, . After that let's calculate the following DP: d[i][j][k] — — number of sequences for which following holds: c1 < c2 < ... < ci, ci ≥ 1 , c1 + c2 + ... + ci = j and maximal number is less then k (upper bound of sequence). This DP will helps us to calculate number of ways to set length to each segment in sequence. It's simple to calculate such DP: base d[0][0][1] = 1, d[i][j][k + 1] = d[i][j][k + 1] + d[i][j][k] — we increase upper bound of sequence; d[i + 1][j + k][k + 1] = d[i + 1][j + k][k + 1] + d[i][j][k] — we are adding upper bound to the sequence. We can calculate such DP, by using only O(N2) of memory, where N = 1000. After that we should multiply d[i][j][k] on i!, because we need number of sequences ci, where order does not matter.After that we can calculate answer for n, k. Let's , where x — some upper bound of sequences. After that we should calculate next number: how many ways to set to distances between segments? It's clear, that we can increase distance between some segments, but we have only n - len such operations. It's well known, that answer number of ways equals to C(n - len + k, k). So, for each n we should sum by len following values: sum[len] * C(n - len + k, k).Note, that we need array C[n][k] (binomials) where n ≤ 2000, k ≤ 2000.403E - Two Rooted TreesFirst, for each vertex of the first and second tree we calculate two values in[s], out[s] — the entry time and exit time in dfs order from vertex with number 1. Also with each edge from both trees we will assosiate a pair (p, q), where p = min(in[u], in[v]), q = max(in[u], in[v]) (values in, out for each vertex we take from tree with another color). Now for each tree we will build two segment trees (yes, totally 4 segment trees). In first segment will store all pairs in following way: we will store a pair in node of segment tree if and only if (node of segment tree is a segment (l, r)) left element of pair lies in segment (l, r). In second segment tree we will store a pair if and only if right element of the pair lies in segment (l, r) All pairs in segment trees we will store in some order (in first segment tree — increasing order, in the second tree — decreasing order). Such trees use of memory, also you can build it in .Good. How to answer on query (l, r) — erase all edges from tree for which exactly one vertex have value in[s] in segment (l, r)? We will go down in our segment tree. Let's imagine, that now we in some node of segment tree. Because we store all pairs in the first segment tree in increasing order of the right element, so answer to the query is a some suffix of the array of pairs. After we can add they to the answer (if it not erased yet). After that we should modify our segment tree: for each node, where we work with suffixes, we should erase all pairs from such suffix. So, this solution in .My solution to E: 6052738",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10972",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 402\\s*D"
          },
          "content_length": 7846
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #236 - Codeforces - Code 1",
          "code": "int cn; cin >> cn;\n\tfor(int ci = 0; ci < cn; ci++) {\n\t\tint n,p; cin >> n >> p;\n\t\tint cnt = 0;\n\t\tfor(int k = 2; k <= n; k++) \n\t\t\tfor(int i = 1; i < k && ( cnt < (2*k + p) ) ; i++)\n\t\t\t\tcout << i << \" \" << k << \"\\n\", ++cnt;\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 2",
          "code": "int cn; cin >> cn;\n\tfor(int ci = 0; ci < cn; ci++) {\n\t\tint n,p; cin >> n >> p;\n\t\tint cnt = 0;\n\t\tfor(int k = 2; k <= n; k++) \n\t\t\tfor(int i = 1; i < k && ( cnt < (2*k + p) ) ; i++)\n\t\t\t\tcout << i << \" \" << k << \"\\n\", ++cnt;\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 3",
          "code": "V[j]/=gcd(V[j],Div[i]);\nDiv[j]/=gcd(Div[j],Div[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 4",
          "code": "V[j]/=gcd(V[j],Div[i]);\nDiv[j]/=gcd(Div[j],Div[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 5",
          "code": "for(int p : primes) {\n    if (p*p > v) break; // <- add this line\n    int cnt = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 6",
          "code": "for(int p : primes) {\n    if (p*p > v) break; // <- add this line\n    int cnt = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int x) {\n    if (x < 2) return false;\n    if (x == 2) return true;\n    if (x % 2 == 0) return false;\n    int sqrtx = (int)sqrt(x) + 1;\n    for (int i = 3; i * i <= x; i += 2) {\n        if (x % i == 0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 2, 1000000000, \"b_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        ensuref(isPrime(b[i]), \"b[%d]=%d is not prime\", i+1, b[i]);\n        if (i > 0) {\n            ensuref(b[i-1] < b[i], \"b[%d]=%d is not less than b[%d]=%d\", i, b[i-1], i+1, b[i]);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int x) {\n    if (x < 2) return false;\n    if (x == 2) return true;\n    if (x % 2 == 0) return false;\n    int sqrtx = (int)sqrt(x) + 1;\n    for (int i = 3; i * i <= x; i += 2) {\n        if (x % i == 0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 2, 1000000000, \"b_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        ensuref(isPrime(b[i]), \"b[%d]=%d is not prime\", i+1, b[i]);\n        if (i > 0) {\n            ensuref(b[i-1] < b[i], \"b[%d]=%d is not less than b[%d]=%d\", i, b[i-1], i+1, b[i]);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Function to check if a number is prime\nbool isPrime(int x) {\n    if (x < 2) return false;\n    if (x == 2) return true;\n    if (x % 2 == 0) return false;\n    int sqrtx = (int)sqrt(x) + 1;\n    for (int i = 3; i * i <= x; i += 2) {\n        if (x % i == 0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 2, 1000000000, \"b_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        ensuref(isPrime(b[i]), \"b[%d]=%d is not prime\", i+1, b[i]);\n        if (i > 0) {\n            ensuref(b[i-1] < b[i], \"b[%d]=%d is not less than b[%d]=%d\", i, b[i-1], i+1, b[i]);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_PRIME = 35000;\nvector<int> primes;\n\nvoid generate_primes() {\n    vector<bool> is_prime(MAX_PRIME+1, true);\n    is_prime[0] = is_prime[1] = false;\n    for(int i = 2; i <= MAX_PRIME; ++i) {\n        if(is_prime[i]) {\n            primes.push_back(i);\n            for(int j = i+i; j <= MAX_PRIME; j+=i)\n                is_prime[j] = false;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // size of array a\n    int m = opt<int>(\"m\"); // number of bad primes\n    string type_a = opt<string>(\"type_a\", \"random\"); // type of array a\n    string type_b = opt<string>(\"type_b\", \"random\"); // type of bad primes\n    int max_a = opt<int>(\"max_a\", 1000000000); // maximum value of a[i]\n\n    // generate primes up to MAX_PRIME\n    generate_primes();\n\n    vector<int> a(n);\n    vector<int> bad_primes;\n\n    // Generate bad primes\n    if(type_b == \"none\") {\n        // No bad primes\n        m = 0;\n    } else if(type_b == \"all\") {\n        // All possible primes up to MAX_PRIME\n        m = min(m, (int)primes.size());\n        bad_primes = primes;\n        bad_primes.resize(m);\n    } else if(type_b == \"small\") {\n        // Small primes\n        m = min(m, 168); // primes up to 1000\n        for(int i = 0; i < m; ++i) {\n            bad_primes.push_back(primes[i]);\n        }\n    } else if(type_b == \"minimal_primes_in_a\") {\n        // We will determine bad primes later after a is generated\n        // For now, bad_primes is empty\n        m = 0;\n    } else if(type_b == \"random\") {\n        // Random primes\n        for(int i = 0; i < m; ++i) {\n            int idx = rnd.next(0, (int)primes.size()-1);\n            bad_primes.push_back(primes[idx]);\n        }\n        sort(bad_primes.begin(), bad_primes.end());\n        bad_primes.erase(unique(bad_primes.begin(), bad_primes.end()), bad_primes.end());\n        m = bad_primes.size(); // update m in case of duplicates\n    } else {\n        // Default: random\n        for(int i = 0; i < m; ++i) {\n            int idx = rnd.next(0, (int)primes.size()-1);\n            bad_primes.push_back(primes[idx]);\n        }\n    }\n\n    // Generate array a\n    if(type_a == \"ones\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if(type_a == \"same\") {\n        int val = rnd.next(1, max_a);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if(type_a == \"inc\") {\n        a[0] = rnd.next(1, max_a);\n        for(int i = 1; i < n; ++i)\n            a[i] = min(max_a, a[i-1] + rnd.next(1, 10));\n    } else if(type_a == \"dec\") {\n        a[0] = rnd.next(1, max_a);\n        for(int i = 1; i < n; ++i)\n            a[i] = max(1, a[i-1] - rnd.next(1, 10));\n    } else if(type_a == \"pow_bad\") {\n        if(bad_primes.empty()) {\n            // Need to have bad primes\n            for(int i = 0; i < m; ++i) {\n                int idx = rnd.next(0, (int)primes.size()-1);\n                bad_primes.push_back(primes[idx]);\n            }\n            sort(bad_primes.begin(), bad_primes.end());\n            bad_primes.erase(unique(bad_primes.begin(), bad_primes.end()), bad_primes.end());\n            m = bad_primes.size();\n        }\n        for(int i = 0; i < n; ++i) {\n            int p = bad_primes[rnd.next(0, m-1)];\n            int e = rnd.next(1, 10);\n            long long val = 1;\n            for(int j = 0; j < e; ++j) {\n                if(val * p > max_a) break;\n                val *= p;\n            }\n            a[i] = val;\n        }\n    } else if(type_a == \"pow_good\") {\n        vector<int> good_primes;\n        if(type_b == \"all\") {\n            for(int i = 0; i < n; ++i) {\n                a[i] = rnd.next(2, max_a);\n            }\n        } else {\n            set<int> bad_prime_set(bad_primes.begin(), bad_primes.end());\n            for(int p : primes) {\n                if(bad_prime_set.find(p) == bad_prime_set.end()) {\n                    good_primes.push_back(p);\n                }\n            }\n            if(good_primes.empty()) {\n                for(int i = 0; i < n; ++i) {\n                    a[i] = rnd.next(2, max_a);\n                }\n            } else {\n                for(int i = 0; i < n; ++i) {\n                    int p = good_primes[rnd.next(0, (int)good_primes.size()-1)];\n                    int e = rnd.next(1, 10);\n                    long long val = 1;\n                    for(int j = 0; j < e; ++j) {\n                        if(val * p > max_a) break;\n                        val *= p;\n                    }\n                    a[i] = val;\n                }\n            }\n        }\n    } else if(type_a == \"largeprimes\") {\n        for(int i = 0; i < n; ++i) {\n            int idx = rnd.next((int)primes.size()/2, (int)primes.size()-1);\n            a[i] = primes[idx];\n        }\n    } else if(type_a == \"random\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, max_a);\n    } else {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, max_a);\n    }\n\n    if(type_b == \"minimal_primes_in_a\") {\n        set<int> minimal_primes;\n        for(int i = 0; i < n; ++i) {\n            int x = a[i];\n            int min_p = 0;\n            for(int p : primes) {\n                if(x % p == 0) {\n                    min_p = p;\n                    break;\n                }\n                if(p * p > x)\n                    break;\n            }\n            if(min_p == 0) {\n                min_p = x; // x is prime\n            }\n            minimal_primes.insert(min_p);\n        }\n        bad_primes.assign(minimal_primes.begin(), minimal_primes.end());\n        m = bad_primes.size();\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n-1 ? '\\n' : ' ');\n    }\n    if(m > 0) {\n        sort(bad_primes.begin(), bad_primes.end());\n        for(int i = 0; i < m; ++i) {\n            printf(\"%d%c\", bad_primes[i], i == m-1 ? '\\n' : ' ');\n        }\n    } else {\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_PRIME = 35000;\nvector<int> primes;\n\nvoid generate_primes() {\n    vector<bool> is_prime(MAX_PRIME+1, true);\n    is_prime[0] = is_prime[1] = false;\n    for(int i = 2; i <= MAX_PRIME; ++i) {\n        if(is_prime[i]) {\n            primes.push_back(i);\n            for(int j = i+i; j <= MAX_PRIME; j+=i)\n                is_prime[j] = false;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // size of array a\n    int m = opt<int>(\"m\"); // number of bad primes\n    string type_a = opt<string>(\"type_a\", \"random\"); // type of array a\n    string type_b = opt<string>(\"type_b\", \"random\"); // type of bad primes\n    int max_a = opt<int>(\"max_a\", 1000000000); // maximum value of a[i]\n\n    // generate primes up to MAX_PRIME\n    generate_primes();\n\n    vector<int> a(n);\n    vector<int> bad_primes;\n\n    // Generate bad primes\n    if(type_b == \"none\") {\n        // No bad primes\n        m = 0;\n    } else if(type_b == \"all\") {\n        // All possible primes up to MAX_PRIME\n        m = min(m, (int)primes.size());\n        bad_primes = primes;\n        bad_primes.resize(m);\n    } else if(type_b == \"small\") {\n        // Small primes\n        m = min(m, 168); // primes up to 1000\n        for(int i = 0; i < m; ++i) {\n            bad_primes.push_back(primes[i]);\n        }\n    } else if(type_b == \"minimal_primes_in_a\") {\n        // We will determine bad primes later after a is generated\n        // For now, bad_primes is empty\n        m = 0;\n    } else if(type_b == \"random\") {\n        // Random primes\n        for(int i = 0; i < m; ++i) {\n            int idx = rnd.next(0, (int)primes.size()-1);\n            bad_primes.push_back(primes[idx]);\n        }\n        sort(bad_primes.begin(), bad_primes.end());\n        bad_primes.erase(unique(bad_primes.begin(), bad_primes.end()), bad_primes.end());\n        m = bad_primes.size(); // update m in case of duplicates\n    } else {\n        // Default: random\n        for(int i = 0; i < m; ++i) {\n            int idx = rnd.next(0, (int)primes.size()-1);\n            bad_primes.push_back(primes[idx]);\n        }\n    }\n\n    // Generate array a\n    if(type_a == \"ones\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if(type_a == \"same\") {\n        int val = rnd.next(1, max_a);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if(type_a == \"inc\") {\n        a[0] = rnd.next(1, max_a);\n        for(int i = 1; i < n; ++i)\n            a[i] = min(max_a, a[i-1] + rnd.next(1, 10));\n    } else if(type_a == \"dec\") {\n        a[0] = rnd.next(1, max_a);\n        for(int i = 1; i < n; ++i)\n            a[i] = max(1, a[i-1] - rnd.next(1, 10));\n    } else if(type_a == \"pow_bad\") {\n        if(bad_primes.empty()) {\n            // Need to have bad primes\n            for(int i = 0; i < m; ++i) {\n                int idx = rnd.next(0, (int)primes.size()-1);\n                bad_primes.push_back(primes[idx]);\n            }\n            sort(bad_primes.begin(), bad_primes.end());\n            bad_primes.erase(unique(bad_primes.begin(), bad_primes.end()), bad_primes.end());\n            m = bad_primes.size();\n        }\n        for(int i = 0; i < n; ++i) {\n            int p = bad_primes[rnd.next(0, m-1)];\n            int e = rnd.next(1, 10);\n            long long val = 1;\n            for(int j = 0; j < e; ++j) {\n                if(val * p > max_a) break;\n                val *= p;\n            }\n            a[i] = val;\n        }\n    } else if(type_a == \"pow_good\") {\n        vector<int> good_primes;\n        if(type_b == \"all\") {\n            for(int i = 0; i < n; ++i) {\n                a[i] = rnd.next(2, max_a);\n            }\n        } else {\n            set<int> bad_prime_set(bad_primes.begin(), bad_primes.end());\n            for(int p : primes) {\n                if(bad_prime_set.find(p) == bad_prime_set.end()) {\n                    good_primes.push_back(p);\n                }\n            }\n            if(good_primes.empty()) {\n                for(int i = 0; i < n; ++i) {\n                    a[i] = rnd.next(2, max_a);\n                }\n            } else {\n                for(int i = 0; i < n; ++i) {\n                    int p = good_primes[rnd.next(0, (int)good_primes.size()-1)];\n                    int e = rnd.next(1, 10);\n                    long long val = 1;\n                    for(int j = 0; j < e; ++j) {\n                        if(val * p > max_a) break;\n                        val *= p;\n                    }\n                    a[i] = val;\n                }\n            }\n        }\n    } else if(type_a == \"largeprimes\") {\n        for(int i = 0; i < n; ++i) {\n            int idx = rnd.next((int)primes.size()/2, (int)primes.size()-1);\n            a[i] = primes[idx];\n        }\n    } else if(type_a == \"random\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, max_a);\n    } else {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, max_a);\n    }\n\n    if(type_b == \"minimal_primes_in_a\") {\n        set<int> minimal_primes;\n        for(int i = 0; i < n; ++i) {\n            int x = a[i];\n            int min_p = 0;\n            for(int p : primes) {\n                if(x % p == 0) {\n                    min_p = p;\n                    break;\n                }\n                if(p * p > x)\n                    break;\n            }\n            if(min_p == 0) {\n                min_p = x; // x is prime\n            }\n            minimal_primes.insert(min_p);\n        }\n        bad_primes.assign(minimal_primes.begin(), minimal_primes.end());\n        m = bad_primes.size();\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n-1 ? '\\n' : ' ');\n    }\n    if(m > 0) {\n        sort(bad_primes.begin(), bad_primes.end());\n        for(int i = 0; i < m; ++i) {\n            printf(\"%d%c\", bad_primes[i], i == m-1 ? '\\n' : ' ');\n        }\n    } else {\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and m, random data\n./gen -n 1 -m 0 -type_a random -type_b none\n./gen -n 1 -m 1 -type_a random -type_b random\n./gen -n 1 -m 1 -type_a ones -type_b random\n\n# Max n and m\n./gen -n 5000 -m 5000 -type_a random -type_b random\n./gen -n 5000 -m 5000 -type_a ones -type_b all\n\n# All a[i] = 1\n./gen -n 10 -m 0 -type_a ones -type_b none\n./gen -n 1000 -m 0 -type_a ones -type_b none\n./gen -n 5000 -m 0 -type_a ones -type_b none\n\n# All a[i] are the same random number\n./gen -n 100 -m 10 -type_a same -type_b random\n./gen -n 5000 -m 5000 -type_a same -type_b minimal_primes_in_a\n\n# Increasing sequence\n./gen -n 5000 -m 1000 -type_a inc -type_b random\n\n# Decreasing sequence\n./gen -n 5000 -m 2000 -type_a dec -type_b random\n\n# All numbers are powers of bad primes\n./gen -n 5000 -m 100 -type_a pow_bad -type_b random\n\n# All numbers are powers of good primes\n./gen -n 5000 -m 100 -type_a pow_good -type_b random\n\n# Bad primes include all minimal prime factors of a[i]\n./gen -n 5000 -m 5000 -type_a random -type_b minimal_primes_in_a\n\n# Bad primes are small primes\n./gen -n 5000 -m 10 -type_a random -type_b small\n\n# Large primes in a[i]\n./gen -n 5000 -m 5000 -type_a largeprimes -type_b random\n\n# Bad primes are none\n./gen -n 5000 -m 0 -type_a random -type_b none\n\n# Bad primes are all (all primes up to MAX_PRIME)\n./gen -n 5000 -m 3844 -type_a random -type_b all\n\n# Max a[i] is small\n./gen -n 5000 -m 5000 -max_a 1000 -type_a random -type_b random\n\n# Max a[i] is maximum\n./gen -n 5000 -m 5000 -max_a 1000000000 -type_a random -type_b random\n\n# Small n, various types\n./gen -n 10 -m 10 -type_a pow_bad -type_b random\n./gen -n 10 -m 10 -type_a pow_good -type_b random\n\n# Edge cases\n./gen -n 5000 -m 5000 -type_a ones -type_b small\n\n./gen -n 5000 -m 5000 -type_a ones -type_b all\n\n./gen -n 2 -m 2 -type_a same -type_b minimal_primes_in_a\n\n# All primes are bad (bad primes include all primes up to MAX_PRIME)\n./gen -n 5000 -m 3844 -type_a random -type_b all\n\n# No bad primes\n./gen -n 5000 -m 0 -type_a random -type_b none\n\n# Maximize the beauty\n./gen -n 5000 -m 0 -type_a pow_good -type_b none\n\n# Minimize the beauty\n./gen -n 5000 -m 3844 -type_a pow_bad -type_b all\n\n# Random large numbers\n./gen -n 5000 -m 5000 -type_a random -type_b random\n\n# Testing GCD operations\n./gen -n 5000 -m 5000 -type_a same -type_b random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:45.527564",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "402/E",
      "title": "E. Строго положительная матрица",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано целое число n (2 ≤ n ≤ 2000) — количество строк и столбцов в матрице a.В следующих n строках задано описание строк матрицы a. В i-ой строке задано n целых неотрицательных чисел ai1, ai2, ..., ain (0 ≤ aij ≤ 50). Гарантируется, что .",
      "output_spec": "Выходные данныеЕсли существует целое число k ≥ 1, такое, что матрица ak является строго положительной, выведите «YES» (без кавычек). Иначе, выведите «NO» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать21 00 1Выходные данныеСкопироватьNOВходные данныеСкопировать54 5 6 1 21 2 3 4 56 4 1 2 41 1 1 1 14 4 4 4 4Выходные данныеСкопироватьYES",
      "description": "E. Строго положительная матрица\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке задано целое число n (2 ≤ n ≤ 2000) — количество строк и столбцов в матрице a.В следующих n строках задано описание строк матрицы a. В i-ой строке задано n целых неотрицательных чисел ai1, ai2, ..., ain (0 ≤ aij ≤ 50). Гарантируется, что .\n\nВходные данные\n\nВыходные данныеЕсли существует целое число k ≥ 1, такое, что матрица ak является строго положительной, выведите «YES» (без кавычек). Иначе, выведите «NO» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать21 00 1Выходные данныеСкопироватьNOВходные данныеСкопировать54 5 6 1 21 2 3 4 56 4 1 2 41 1 1 1 14 4 4 4 4Выходные данныеСкопироватьYES\n\nВходные данныеСкопировать21 00 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать54 5 6 1 21 2 3 4 56 4 1 2 41 1 1 1 14 4 4 4 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #236 - Codeforces",
          "content": "Скоро, 16 марта, 19:30 MSK, состоится очередной Codeforces Round #236 для участников из обоих дивизионов.Автором задач являюсь я. Это мой первый раунд для обоих дивизионов, и я надеюсь не последний. Большое спасибо Геральду Агапову (Gerald) за помощь в подготовке задач, Лось Илье (IlyaLos) и Александру Игнатьеву (aiMR) за тестирование, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon. UPD: Распределение баллов:Div. 2: 500 — 1000 — 1500 — 2000 — 2500Div. 1: 500 — 1000 — 1500 — 1500 — 2000 UPD:Соревнование закончено, поздравляем победителей!Div.2 : vladb iceiceice LoneFox ofpsxx adsz Div. 1: 1 sillycross 2 KADR 2 vepifanov 4 Endagorion 5 glassices 6 cgy4ever 7 rowdark 8 snuke 9 ftiasch 10 fsouza UPD:Разбор задач на русскомUPD:Статистика раунда от DmitriyH.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10959",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 848
        },
        {
          "title": "Разбор Codeforces Round #236 - Codeforces",
          "content": "402A - ОрехиДостаточно просто перебрать количество коробок, которыми мы воспользуемся. Предположим, это число равно ans. Тогда всего мы можем получить ровно cnt = ans + min((k - 1) * ans, B) отсеков. Если cnt * v ≥ a, тогда ответ равен ans.402B - Деревья в рядуДостаточно перебрать высоту первого дерева от 1 до 1000. При фиксированной высоте первого дерева высоты деревьев однозначно определены, то есть имеют вид: a, a + k, a + 2k и так далее. После этого необходимо подсчитать количество операций, чтобы получить красивый ряд из деревьев при фиксированной минимальной высоте. Обновим ответ. После этого выведем для самой оптимальной высоты все операции.402C - Ищем граф / 403A - Ищем графОпишу два решения.Первое. Рассмотрим все пары чисел (i, j) (1 ≤ i < j ≤ n). Выведем 2n + p пар в лексикографическом порядке. Во-первых, понятно что достаточно доказать, что 0-интересный граф верный. Более того, достаточно показать, что  - 3 интересный граф является верным. А как выглядит граф из первых 2n - 3 ребер. Очевидно, это граф имеет вид треугольников с общим ребром 1-2. Теперь предположим мы возьмем подмножество, которое не содержит вершины 1 и 2. Нетрудно увидеть, что в таких подграфах будет ноль ребер. Если в подмножестве ровно одна из вершин 1 или 2, то таких ребер будет k - 1, где k размер такого подграфа. Если две, то таких ребер 2 * (k — 2) + 1, где k размер подграфа.Второе. Напишем перебор, который построит нам 0-интересные графы с количеством вершин 5, 6, 7, 8, 9. Теперь заметим, чтобы построить p-интерсный граф с n вершинами, достаточно построить 0-интересный граф, и потом в него p любых ребер, которых еще нет в графе. Как построить 0-интересный граф с n вершинами? Очень просто. Мы просто возьмем k несвязных компонент из построенных нами графов с вершинами от 5 по 9 так, чтобы суммарно в них было ровно n вершин.402D - Улучшаем массив / 403B - Улучшаем массивОпять опишу два решения.Первое. Динамическое программирование. Подсчитаем динамическое программирование d[i][j] какое максимальный ответ мы можем получить, если перед нами сейчас префикс длины i и последний раз мы сокращали на gcd в позиции j. Понятно, что позиции следует перебирать в порядке убывания, как и размер префикса. Всего мы можем улучшить ответ в двух позициях в динамике из текущего состояния. А именно, d[i - 1][j] = max(d[i - 1][j], d[i][j]) — просто не будем сокращать на gcd текущий префикс. d[i - 1][i - 1] = max(d[i - 1][i - 1], d[i][j] + f(tgcd[j]) * i - f(tgcd[i - 1]) * i — выполним сокращение в текущей позиции. tgcd[i] — gcd всех чисел на префиксе длины i. Функция f(a) — возвращает красоту числа. Такую функцию просто реализовать за . Кроме того, можно ускорить работу этой функции, достаточно просто насчитать массив маленьких простых чисел. В таком решении очень важно не забыть, что каждый раз пересчитывать красоту чисел не нужно. Достаточно завести map < int, int >  — который сохранит уже посчитанные значения. База динамики d[n][n] = curBeauty — текущая красота массива.Второе. Жадность. Возьмем самую правую позицию, которая может улучшить ответ. Выберем эту позицию, и сократим в ней на gcd. Докажем, почему так делать верно. Пусть оптимальное решение (последовательность сокращений) имеет вид r1 > r2 > ... > rk. А мы построили решение l1 > l2 > ... > lm используя жадность. Понятно, то r1 ≤ l1, поскольку до этого позиции  > l1 не могли ничего улучшить, ведь иначе наша жадность взяла бы их в качестве своего первого выбора. С другой стороны, r1 ≥ l1, ведь иначе мы можем взять и сократить в позиции l1 и только улучшить ответ, а это противоречило бы оптимальности решения ri. То есть, r1 = l1, а значит, мы можем воспользоваться нашими соображениями и далее, для больших индексов i. 402E - Строго положительная матрица / 403C - Строго положительная матрицаБудем смотреть на матрицу a как на матрицу смежности некоторого графа из n вершин. Причем, если aij > 0, значит мы имеем ориентированное ребро в графе между вершинами (i, j). Иначе, мы получим, что ориентированного ребра нет. Тогда, пусть b = ak. Тогда что обозначает bij? Верно, количество путей длины ровно k в нашем графе из вершины i в вершину j. Пусть pos такое, что a[pos][pos] > 0. То есть, у нас есть петля в графе. Значит, если из вершины pos достижимы все остальные вершины и наоборот, из всех остальных вершин достижима вершина pos, то тогда ответ YES, иначе ответ NO. Понятно, что если достижимость отсутствует, то понятно что для любого k akipos = 0. Если же достижимость имеется, то мы сможем добраться до петли, покрутиться некоторое количество раз в петле, а потом отправиться в нужную вершину. 403D - Красивые пары чиселВо первых отметим, что на самом деле, длина последовательности не больше чем 50. Уже хорошо, а почему? Поскольку все числа bi - ai различны, то 0 + 1 + ... + 50 > 1000. Также представим, что мы имеем на самом деле последовательность попарно не пересекающихся отрезков, ci = bi - ai + 1 — длина отрезка. . Хорошо. Посчитаем динамическое программирование: d[i][j][k] — количество последовательностей из чисел c1 < c2 < ... < ci таких, что ci ≥ 1 и c1 + c2 + ... + ci = j и максимальное число в ней строго меньше чем k. Такая динамика поможет нам посчитать количество способов назначить длины отрезкам. Пересчитать такую динамику очень просто: база d[0][0][1] = 1, d[i][j][k + 1] = d[i][j][k + 1] + d[i][j][k] — просто увеличим верхнюю границу. d[i + 1][j + k][k + 1] = d[i + 1][j + k][k + 1] + d[i][j][k] — ставим текущую границу в последовательность, тем самым увеличиваем сумму и верхнюю границу. Такую динамику нужно написать, используя O(N2) памяти, где N = 1000. После этого, умножим каждое d[i][j][k] на i!, поскольку мы располагать последовательность ci не в порядке возрастания. Таким образом мы умеем считать количество способов назначить длины отрезков.Хорошо. Теперь как получить ответ для n, k? Пусть sum[len] = d[k][len][x], где x — некоторая верхняя граница. Очевидно, что нам дополнительно нужно еще раздать еще n - len единичек. С помощью этих единиц мы можем увеличивать расстояние между отрезками. Количество способов раздать эти единички равно числу C(n - len + k, k). Таким образом, для каждого n просуммируем по len полученные величины и сложим в ответ.Также следует обратить внимание на то, массив C[n][k] должен быть достаточно большим и аккуратно расставить размерности.403E - Два корневых дереваВо-первых для каждой вершины первого и второго дерева подсчитаем две величины in[s], out[s] — время входа и время выхода из вершины в порядке обхода dfs из вершины 1. Теперь с каждому ребру из обоих деревьев мы сопоставим пару (p, q) — где p = min(in[u], in[v]), q = max(in[u], in[v]) где величины in, out для каждой вершины мы берем из дерева другого цвета. Теперь для каждой дерева мы построим два дерева отрезков (в сумме 4 дерева отрезков, да). В первом дереве отрезков мы будем пары хранить в следующем виде: мы будем хранить пару в вершине (вершина дерева отрезков это некоторый отрезок (l, r)) дерева отрезков тогда и только тогда, когда ее левая граница лежит внутри отрека (l, r). Аналогично, во втором дереве отрезков мы будем хранить пару в вершине (вершина дерева отрезков это некоторый отрезок (l, r)) дерева отрезков тогда и только тогда, когда ее правая граница лежит внутри отрека (l, r). Все пары в дереве отрезков мы будем хранить по возрастанию правой границы (левой во втором дереве). Такие деревья отрезков требуют памяти, и построить можно за время .Хорошо. Как теперь ответить на запрос (l, r) — удалить ребра из дерева, такое что одна из вершин имеет время входа внутри (l, r) ? Будем спускаться по дереву отрезков. Предположим, мы сейчас находимся в некоторой его вершине. Поскольку в первом дереве мы храним все пары по возрастанию правой границы, то ответ на запрос, это некоторый суффикс массива его правый границы. После того, как мы обработаем эти ребра и начнем следующий этап, нам нужно модифицировать наше дерево. А именно, для каждой вершины дерева, в которой мы рассматривали суффиксы мы должны их удалить, иначе мы можем обработать их несколько раз. Таким образом, имеем решение за .Авторское решение по Е: 6052738",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10972",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 402\\s*E"
          },
          "content_length": 8082
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #236 - Codeforces - Code 1",
          "code": "for (int i = 2; ll(i)*i <= xx; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 2",
          "code": "for (int i = 2; i*i <= xx; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 3",
          "code": "int cn; cin >> cn;\n\tfor(int ci = 0; ci < cn; ci++) {\n\t\tint n,p; cin >> n >> p;\n\t\tint cnt = 0;\n\t\tfor(int k = 2; k <= n; k++) \n\t\t\tfor(int i = 1; i < k && ( cnt < (2*k + p) ) ; i++)\n\t\t\t\tcout << i << \" \" << k << \"\\n\", ++cnt;\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 4",
          "code": "int cn; cin >> cn;\n\tfor(int ci = 0; ci < cn; ci++) {\n\t\tint n,p; cin >> n >> p;\n\t\tint cnt = 0;\n\t\tfor(int k = 2; k <= n; k++) \n\t\t\tfor(int i = 1; i < k && ( cnt < (2*k + p) ) ; i++)\n\t\t\t\tcout << i << \" \" << k << \"\\n\", ++cnt;\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 5",
          "code": "for (size_t i = 0; i < n; i++)\n        SetEdge(links, i, (i + 1) % n);\n\n    for (size_t i = 0; i < n; i++)\n        SetEdge(links, i, (i + 2) % n);\n\n    for (size_t i = 0; i < p; i++)\n        SetEdge(links, i, (i + n / 2) % n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 6",
          "code": "for (size_t i = 0; i < n; i++)\n        SetEdge(links, i, (i + 1) % n);\n\n    for (size_t i = 0; i < n; i++)\n        SetEdge(links, i, (i + 2) % n);\n\n    for (size_t i = 0; i < p; i++)\n        SetEdge(links, i, (i + n / 2) % n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 7",
          "code": "V[j]/=gcd(V[j],Div[i]);\nDiv[j]/=gcd(Div[j],Div[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 8",
          "code": "V[j]/=gcd(V[j],Div[i]);\nDiv[j]/=gcd(Div[j],Div[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 9",
          "code": "for(int p : primes) {\n    if (p*p > v) break; // <- add this line\n    int cnt = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 10",
          "code": "for(int p : primes) {\n    if (p*p > v) break; // <- add this line\n    int cnt = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(n, 0, 50);\n        int sum = accumulate(row.begin(), row.end(), 0);\n        ensuref(sum > 0, \"Sum of elements in row %d must be positive, but it is %d\", i+1, sum);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(n, 0, 50);\n        int sum = accumulate(row.begin(), row.end(), 0);\n        ensuref(sum > 0, \"Sum of elements in row %d must be positive, but it is %d\", i+1, sum);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(n, 0, 50);\n        int sum = accumulate(row.begin(), row.end(), 0);\n        ensuref(sum > 0, \"Sum of elements in row %d must be positive, but it is %d\", i+1, sum);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    vector<vector<int>> a(n, vector<int>(n, 0));\n\n    if (type == \"primitive\") {\n        // Generate a strongly connected, primitive graph\n\n        // Create a cycle\n        vector<int> perm(n);\n        for (int i = 0; i < n; ++i)\n            perm[i] = i;\n        shuffle(perm.begin(), perm.end());\n\n        for (int i = 0; i < n; ++i) {\n            int u = perm[i];\n            int v = perm[(i + 1) % n];\n            a[u][v] = rnd.next(1, 50);\n        }\n\n        // Add self-loops to make the graph aperiodic\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1)) {\n                a[i][i] = rnd.next(1, 50);\n            }\n        }\n\n        // Add additional random edges\n        int extra_edges = rnd.next(n, n * n / 2);\n        for (int i = 0; i < extra_edges; ++i) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u != v && a[u][v] == 0) {\n                a[u][v] = rnd.next(1, 50);\n            }\n        }\n\n    } else if (type == \"nonprimitive\") {\n        // Generate a strongly connected, periodic graph\n\n        // Ensure n is even\n        if (n % 2 == 1 && n > 2) {\n            n -= 1;\n        }\n\n        // Create a cycle of even length\n        for (int i = 0; i < n; ++i) {\n            int u = i;\n            int v = (i + 1) % n;\n            a[u][v] = rnd.next(1, 50);\n        }\n\n        // Add reverse edges to ensure strong connectivity\n        for (int i = 0; i < n; ++i) {\n            int u = (i + 1) % n;\n            int v = i;\n            a[u][v] = rnd.next(1, 50);\n        }\n\n        // Optionally add random edges without self-loops\n        int extra_edges = rnd.next(n, n * n / 2);\n        for (int i = 0; i < extra_edges; ++i) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u != v && a[u][v] == 0 && rnd.next(0, 1) == 0) {\n                a[u][v] = rnd.next(1, 50);\n            }\n        }\n\n    } else if (type == \"random\") {\n        // Generate a random strongly connected graph\n\n        // Create forward and backward spanning trees\n        vector<int> perm(n);\n        for (int i = 0; i < n; ++i)\n            perm[i] = i;\n        shuffle(perm.begin(), perm.end());\n\n        // Forward tree\n        for (int i = 0; i < n - 1; ++i) {\n            int u = perm[i];\n            int v = perm[i + 1];\n            a[u][v] = rnd.next(1, 50);\n        }\n\n        // Backward tree\n        shuffle(perm.begin(), perm.end());\n        for (int i = 0; i < n - 1; ++i) {\n            int u = perm[i + 1];\n            int v = perm[i];\n            a[u][v] = rnd.next(1, 50);\n        }\n\n        // Add random edges\n        int extra_edges = rnd.next(n, n * n / 2);\n        for (int i = 0; i < extra_edges; ++i) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u != v && a[u][v] == 0) {\n                a[u][v] = rnd.next(1, 50);\n            }\n        }\n\n        // Add self-loops randomly\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 3) == 0) { // 25% chance\n                a[i][i] = rnd.next(1, 50);\n            }\n        }\n\n    } else if (type == \"small\") {\n        // Generate predefined small matrices\n\n        if (n == 2) {\n            a[0][1] = 1;\n            a[1][0] = 1;\n        } else if (n == 3) {\n            a[0][1] = 1;\n            a[1][2] = 1;\n            a[2][0] = 1;\n            a[0][0] = 1;\n        }\n    } else if (type == \"maxn\") {\n        // Generate test case with maximum n\n\n        n = 2000;\n        a.assign(n, vector<int>(n, 0));\n\n        // Create a cycle\n        for (int i = 0; i < n; ++i) {\n            int u = i;\n            int v = (i + 1) % n;\n            a[u][v] = rnd.next(1, 50);\n        }\n\n        // Add self-loops\n        for (int i = 0; i < n; ++i) {\n            a[i][i] = rnd.next(1, 50);\n        }\n\n        // Add random edges\n        int extra_edges = rnd.next(n, n * n / 2);\n        for (int i = 0; i < extra_edges; ++i) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (a[u][v] == 0) {\n                a[u][v] = rnd.next(1, 50);\n            }\n        }\n\n    } else {\n        // Undefined type\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the matrix a\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d%c\", a[i][j], j == n - 1 ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    vector<vector<int>> a(n, vector<int>(n, 0));\n\n    if (type == \"primitive\") {\n        // Generate a strongly connected, primitive graph\n\n        // Create a cycle\n        vector<int> perm(n);\n        for (int i = 0; i < n; ++i)\n            perm[i] = i;\n        shuffle(perm.begin(), perm.end());\n\n        for (int i = 0; i < n; ++i) {\n            int u = perm[i];\n            int v = perm[(i + 1) % n];\n            a[u][v] = rnd.next(1, 50);\n        }\n\n        // Add self-loops to make the graph aperiodic\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1)) {\n                a[i][i] = rnd.next(1, 50);\n            }\n        }\n\n        // Add additional random edges\n        int extra_edges = rnd.next(n, n * n / 2);\n        for (int i = 0; i < extra_edges; ++i) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u != v && a[u][v] == 0) {\n                a[u][v] = rnd.next(1, 50);\n            }\n        }\n\n    } else if (type == \"nonprimitive\") {\n        // Generate a strongly connected, periodic graph\n\n        // Ensure n is even\n        if (n % 2 == 1 && n > 2) {\n            n -= 1;\n        }\n\n        // Create a cycle of even length\n        for (int i = 0; i < n; ++i) {\n            int u = i;\n            int v = (i + 1) % n;\n            a[u][v] = rnd.next(1, 50);\n        }\n\n        // Add reverse edges to ensure strong connectivity\n        for (int i = 0; i < n; ++i) {\n            int u = (i + 1) % n;\n            int v = i;\n            a[u][v] = rnd.next(1, 50);\n        }\n\n        // Optionally add random edges without self-loops\n        int extra_edges = rnd.next(n, n * n / 2);\n        for (int i = 0; i < extra_edges; ++i) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u != v && a[u][v] == 0 && rnd.next(0, 1) == 0) {\n                a[u][v] = rnd.next(1, 50);\n            }\n        }\n\n    } else if (type == \"random\") {\n        // Generate a random strongly connected graph\n\n        // Create forward and backward spanning trees\n        vector<int> perm(n);\n        for (int i = 0; i < n; ++i)\n            perm[i] = i;\n        shuffle(perm.begin(), perm.end());\n\n        // Forward tree\n        for (int i = 0; i < n - 1; ++i) {\n            int u = perm[i];\n            int v = perm[i + 1];\n            a[u][v] = rnd.next(1, 50);\n        }\n\n        // Backward tree\n        shuffle(perm.begin(), perm.end());\n        for (int i = 0; i < n - 1; ++i) {\n            int u = perm[i + 1];\n            int v = perm[i];\n            a[u][v] = rnd.next(1, 50);\n        }\n\n        // Add random edges\n        int extra_edges = rnd.next(n, n * n / 2);\n        for (int i = 0; i < extra_edges; ++i) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (u != v && a[u][v] == 0) {\n                a[u][v] = rnd.next(1, 50);\n            }\n        }\n\n        // Add self-loops randomly\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 3) == 0) { // 25% chance\n                a[i][i] = rnd.next(1, 50);\n            }\n        }\n\n    } else if (type == \"small\") {\n        // Generate predefined small matrices\n\n        if (n == 2) {\n            a[0][1] = 1;\n            a[1][0] = 1;\n        } else if (n == 3) {\n            a[0][1] = 1;\n            a[1][2] = 1;\n            a[2][0] = 1;\n            a[0][0] = 1;\n        }\n    } else if (type == \"maxn\") {\n        // Generate test case with maximum n\n\n        n = 2000;\n        a.assign(n, vector<int>(n, 0));\n\n        // Create a cycle\n        for (int i = 0; i < n; ++i) {\n            int u = i;\n            int v = (i + 1) % n;\n            a[u][v] = rnd.next(1, 50);\n        }\n\n        // Add self-loops\n        for (int i = 0; i < n; ++i) {\n            a[i][i] = rnd.next(1, 50);\n        }\n\n        // Add random edges\n        int extra_edges = rnd.next(n, n * n / 2);\n        for (int i = 0; i < extra_edges; ++i) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            if (a[u][v] == 0) {\n                a[u][v] = rnd.next(1, 50);\n            }\n        }\n\n    } else {\n        // Undefined type\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the matrix a\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d%c\", a[i][j], j == n - 1 ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type small\n./gen -n 2 -type primitive\n./gen -n 2 -type nonprimitive\n\n./gen -n 3 -type small\n./gen -n 3 -type primitive\n./gen -n 3 -type nonprimitive\n\n./gen -n 5 -type primitive\n./gen -n 5 -type nonprimitive\n./gen -n 5 -type random\n\n./gen -n 10 -type primitive\n./gen -n 10 -type nonprimitive\n./gen -n 10 -type random\n\n./gen -n 50 -type primitive\n./gen -n 50 -type nonprimitive\n./gen -n 50 -type random\n\n./gen -n 100 -type primitive\n./gen -n 100 -type nonprimitive\n./gen -n 100 -type random\n\n./gen -n 500 -type primitive\n./gen -n 500 -type nonprimitive\n./gen -n 500 -type random\n\n./gen -n 1000 -type primitive\n./gen -n 1000 -type nonprimitive\n./gen -n 1000 -type random\n\n./gen -n 2000 -type maxn\n./gen -n 2000 -type primitive\n\n./gen -n 1999 -type primitive\n./gen -n 1999 -type nonprimitive\n\n# Additional test cases to cover edge conditions\n./gen -n 100 -type primitive\n./gen -n 100 -type nonprimitive\n\n# Random large test case\n./gen -n 2000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:47.760415",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "403/A",
      "title": "A. Ищем граф",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано единственное целое число t (1 ≤ t ≤ 5) — количество тестовых данных. В следующих t строках задано по два целых числа: n, p (5 ≤ n ≤ 24; p ≥ 0; ) — количество вершин в графе и параметр интересности для соответствующего теста. Гарантируется, что искомый граф существует.",
      "output_spec": "Выходные данныеДля каждого из t тестов выведите 2n + p строк, содержащих описание ребер p-интересного графа: i-я строка должна содержать два целых числа через пробел ai, bi (1 ≤ ai, bi ≤ n; ai ≠ bi) — две вершины, соединенные ребром в результирующем графе. Считайте, что вершины графа пронумерованы целыми числами от 1 до n. Ответы для тестов выводите в том порядке, в котором тесты заданы во входных данных. Если существует несколько решений, разрешается вывести любое из них.",
      "sample_tests": "ПримерыВходные данныеСкопировать16 0Выходные данныеСкопировать1 21 31 41 51 62 32 42 52 63 43 53 6",
      "description": "A. Ищем граф\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке задано единственное целое число t (1 ≤ t ≤ 5) — количество тестовых данных. В следующих t строках задано по два целых числа: n, p (5 ≤ n ≤ 24; p ≥ 0; ) — количество вершин в графе и параметр интересности для соответствующего теста. Гарантируется, что искомый граф существует.\n\nВходные данные\n\nВыходные данныеДля каждого из t тестов выведите 2n + p строк, содержащих описание ребер p-интересного графа: i-я строка должна содержать два целых числа через пробел ai, bi (1 ≤ ai, bi ≤ n; ai ≠ bi) — две вершины, соединенные ребром в результирующем графе. Считайте, что вершины графа пронумерованы целыми числами от 1 до n. Ответы для тестов выводите в том порядке, в котором тесты заданы во входных данных. Если существует несколько решений, разрешается вывести любое из них.\n\nВыходные данные\n\nВходные данныеСкопировать16 0Выходные данныеСкопировать1 21 31 41 51 62 32 42 52 63 43 53 6\n\nВходные данныеСкопировать16 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 21 31 41 51 62 32 42 52 63 43 53 6\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #236 - Codeforces",
          "content": "Скоро, 16 марта, 19:30 MSK, состоится очередной Codeforces Round #236 для участников из обоих дивизионов.Автором задач являюсь я. Это мой первый раунд для обоих дивизионов, и я надеюсь не последний. Большое спасибо Геральду Агапову (Gerald) за помощь в подготовке задач, Лось Илье (IlyaLos) и Александру Игнатьеву (aiMR) за тестирование, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon. UPD: Распределение баллов:Div. 2: 500 — 1000 — 1500 — 2000 — 2500Div. 1: 500 — 1000 — 1500 — 1500 — 2000 UPD:Соревнование закончено, поздравляем победителей!Div.2 : vladb iceiceice LoneFox ofpsxx adsz Div. 1: 1 sillycross 2 KADR 2 vepifanov 4 Endagorion 5 glassices 6 cgy4ever 7 rowdark 8 snuke 9 ftiasch 10 fsouza UPD:Разбор задач на русскомUPD:Статистика раунда от DmitriyH.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10959",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 848
        },
        {
          "title": "Разбор Codeforces Round #236 - Codeforces",
          "content": "402A - ОрехиДостаточно просто перебрать количество коробок, которыми мы воспользуемся. Предположим, это число равно ans. Тогда всего мы можем получить ровно cnt = ans + min((k - 1) * ans, B) отсеков. Если cnt * v ≥ a, тогда ответ равен ans.402B - Деревья в рядуДостаточно перебрать высоту первого дерева от 1 до 1000. При фиксированной высоте первого дерева высоты деревьев однозначно определены, то есть имеют вид: a, a + k, a + 2k и так далее. После этого необходимо подсчитать количество операций, чтобы получить красивый ряд из деревьев при фиксированной минимальной высоте. Обновим ответ. После этого выведем для самой оптимальной высоты все операции.402C - Ищем граф / 403A - Ищем графОпишу два решения.Первое. Рассмотрим все пары чисел (i, j) (1 ≤ i < j ≤ n). Выведем 2n + p пар в лексикографическом порядке. Во-первых, понятно что достаточно доказать, что 0-интересный граф верный. Более того, достаточно показать, что  - 3 интересный граф является верным. А как выглядит граф из первых 2n - 3 ребер. Очевидно, это граф имеет вид треугольников с общим ребром 1-2. Теперь предположим мы возьмем подмножество, которое не содержит вершины 1 и 2. Нетрудно увидеть, что в таких подграфах будет ноль ребер. Если в подмножестве ровно одна из вершин 1 или 2, то таких ребер будет k - 1, где k размер такого подграфа. Если две, то таких ребер 2 * (k — 2) + 1, где k размер подграфа.Второе. Напишем перебор, который построит нам 0-интересные графы с количеством вершин 5, 6, 7, 8, 9. Теперь заметим, чтобы построить p-интерсный граф с n вершинами, достаточно построить 0-интересный граф, и потом в него p любых ребер, которых еще нет в графе. Как построить 0-интересный граф с n вершинами? Очень просто. Мы просто возьмем k несвязных компонент из построенных нами графов с вершинами от 5 по 9 так, чтобы суммарно в них было ровно n вершин.402D - Улучшаем массив / 403B - Улучшаем массивОпять опишу два решения.Первое. Динамическое программирование. Подсчитаем динамическое программирование d[i][j] какое максимальный ответ мы можем получить, если перед нами сейчас префикс длины i и последний раз мы сокращали на gcd в позиции j. Понятно, что позиции следует перебирать в порядке убывания, как и размер префикса. Всего мы можем улучшить ответ в двух позициях в динамике из текущего состояния. А именно, d[i - 1][j] = max(d[i - 1][j], d[i][j]) — просто не будем сокращать на gcd текущий префикс. d[i - 1][i - 1] = max(d[i - 1][i - 1], d[i][j] + f(tgcd[j]) * i - f(tgcd[i - 1]) * i — выполним сокращение в текущей позиции. tgcd[i] — gcd всех чисел на префиксе длины i. Функция f(a) — возвращает красоту числа. Такую функцию просто реализовать за . Кроме того, можно ускорить работу этой функции, достаточно просто насчитать массив маленьких простых чисел. В таком решении очень важно не забыть, что каждый раз пересчитывать красоту чисел не нужно. Достаточно завести map < int, int >  — который сохранит уже посчитанные значения. База динамики d[n][n] = curBeauty — текущая красота массива.Второе. Жадность. Возьмем самую правую позицию, которая может улучшить ответ. Выберем эту позицию, и сократим в ней на gcd. Докажем, почему так делать верно. Пусть оптимальное решение (последовательность сокращений) имеет вид r1 > r2 > ... > rk. А мы построили решение l1 > l2 > ... > lm используя жадность. Понятно, то r1 ≤ l1, поскольку до этого позиции  > l1 не могли ничего улучшить, ведь иначе наша жадность взяла бы их в качестве своего первого выбора. С другой стороны, r1 ≥ l1, ведь иначе мы можем взять и сократить в позиции l1 и только улучшить ответ, а это противоречило бы оптимальности решения ri. То есть, r1 = l1, а значит, мы можем воспользоваться нашими соображениями и далее, для больших индексов i. 402E - Строго положительная матрица / 403C - Строго положительная матрицаБудем смотреть на матрицу a как на матрицу смежности некоторого графа из n вершин. Причем, если aij > 0, значит мы имеем ориентированное ребро в графе между вершинами (i, j). Иначе, мы получим, что ориентированного ребра нет. Тогда, пусть b = ak. Тогда что обозначает bij? Верно, количество путей длины ровно k в нашем графе из вершины i в вершину j. Пусть pos такое, что a[pos][pos] > 0. То есть, у нас есть петля в графе. Значит, если из вершины pos достижимы все остальные вершины и наоборот, из всех остальных вершин достижима вершина pos, то тогда ответ YES, иначе ответ NO. Понятно, что если достижимость отсутствует, то понятно что для любого k akipos = 0. Если же достижимость имеется, то мы сможем добраться до петли, покрутиться некоторое количество раз в петле, а потом отправиться в нужную вершину. 403D - Красивые пары чиселВо первых отметим, что на самом деле, длина последовательности не больше чем 50. Уже хорошо, а почему? Поскольку все числа bi - ai различны, то 0 + 1 + ... + 50 > 1000. Также представим, что мы имеем на самом деле последовательность попарно не пересекающихся отрезков, ci = bi - ai + 1 — длина отрезка. . Хорошо. Посчитаем динамическое программирование: d[i][j][k] — количество последовательностей из чисел c1 < c2 < ... < ci таких, что ci ≥ 1 и c1 + c2 + ... + ci = j и максимальное число в ней строго меньше чем k. Такая динамика поможет нам посчитать количество способов назначить длины отрезкам. Пересчитать такую динамику очень просто: база d[0][0][1] = 1, d[i][j][k + 1] = d[i][j][k + 1] + d[i][j][k] — просто увеличим верхнюю границу. d[i + 1][j + k][k + 1] = d[i + 1][j + k][k + 1] + d[i][j][k] — ставим текущую границу в последовательность, тем самым увеличиваем сумму и верхнюю границу. Такую динамику нужно написать, используя O(N2) памяти, где N = 1000. После этого, умножим каждое d[i][j][k] на i!, поскольку мы располагать последовательность ci не в порядке возрастания. Таким образом мы умеем считать количество способов назначить длины отрезков.Хорошо. Теперь как получить ответ для n, k? Пусть sum[len] = d[k][len][x], где x — некоторая верхняя граница. Очевидно, что нам дополнительно нужно еще раздать еще n - len единичек. С помощью этих единиц мы можем увеличивать расстояние между отрезками. Количество способов раздать эти единички равно числу C(n - len + k, k). Таким образом, для каждого n просуммируем по len полученные величины и сложим в ответ.Также следует обратить внимание на то, массив C[n][k] должен быть достаточно большим и аккуратно расставить размерности.403E - Два корневых дереваВо-первых для каждой вершины первого и второго дерева подсчитаем две величины in[s], out[s] — время входа и время выхода из вершины в порядке обхода dfs из вершины 1. Теперь с каждому ребру из обоих деревьев мы сопоставим пару (p, q) — где p = min(in[u], in[v]), q = max(in[u], in[v]) где величины in, out для каждой вершины мы берем из дерева другого цвета. Теперь для каждой дерева мы построим два дерева отрезков (в сумме 4 дерева отрезков, да). В первом дереве отрезков мы будем пары хранить в следующем виде: мы будем хранить пару в вершине (вершина дерева отрезков это некоторый отрезок (l, r)) дерева отрезков тогда и только тогда, когда ее левая граница лежит внутри отрека (l, r). Аналогично, во втором дереве отрезков мы будем хранить пару в вершине (вершина дерева отрезков это некоторый отрезок (l, r)) дерева отрезков тогда и только тогда, когда ее правая граница лежит внутри отрека (l, r). Все пары в дереве отрезков мы будем хранить по возрастанию правой границы (левой во втором дереве). Такие деревья отрезков требуют памяти, и построить можно за время .Хорошо. Как теперь ответить на запрос (l, r) — удалить ребра из дерева, такое что одна из вершин имеет время входа внутри (l, r) ? Будем спускаться по дереву отрезков. Предположим, мы сейчас находимся в некоторой его вершине. Поскольку в первом дереве мы храним все пары по возрастанию правой границы, то ответ на запрос, это некоторый суффикс массива его правый границы. После того, как мы обработаем эти ребра и начнем следующий этап, нам нужно модифицировать наше дерево. А именно, для каждой вершины дерева, в которой мы рассматривали суффиксы мы должны их удалить, иначе мы можем обработать их несколько раз. Таким образом, имеем решение за .Авторское решение по Е: 6052738",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10972",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 403\\s*A"
          },
          "content_length": 8082
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #236 - Codeforces - Code 1",
          "code": "for (int i = 2; ll(i)*i <= xx; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 2",
          "code": "for (int i = 2; i*i <= xx; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 3",
          "code": "int cn; cin >> cn;\n\tfor(int ci = 0; ci < cn; ci++) {\n\t\tint n,p; cin >> n >> p;\n\t\tint cnt = 0;\n\t\tfor(int k = 2; k <= n; k++) \n\t\t\tfor(int i = 1; i < k && ( cnt < (2*k + p) ) ; i++)\n\t\t\t\tcout << i << \" \" << k << \"\\n\", ++cnt;\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 4",
          "code": "int cn; cin >> cn;\n\tfor(int ci = 0; ci < cn; ci++) {\n\t\tint n,p; cin >> n >> p;\n\t\tint cnt = 0;\n\t\tfor(int k = 2; k <= n; k++) \n\t\t\tfor(int i = 1; i < k && ( cnt < (2*k + p) ) ; i++)\n\t\t\t\tcout << i << \" \" << k << \"\\n\", ++cnt;\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 5",
          "code": "for (size_t i = 0; i < n; i++)\n        SetEdge(links, i, (i + 1) % n);\n\n    for (size_t i = 0; i < n; i++)\n        SetEdge(links, i, (i + 2) % n);\n\n    for (size_t i = 0; i < p; i++)\n        SetEdge(links, i, (i + n / 2) % n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 6",
          "code": "for (size_t i = 0; i < n; i++)\n        SetEdge(links, i, (i + 1) % n);\n\n    for (size_t i = 0; i < n; i++)\n        SetEdge(links, i, (i + 2) % n);\n\n    for (size_t i = 0; i < p; i++)\n        SetEdge(links, i, (i + n / 2) % n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 7",
          "code": "V[j]/=gcd(V[j],Div[i]);\nDiv[j]/=gcd(Div[j],Div[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 8",
          "code": "V[j]/=gcd(V[j],Div[i]);\nDiv[j]/=gcd(Div[j],Div[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 9",
          "code": "for(int p : primes) {\n    if (p*p > v) break; // <- add this line\n    int cnt = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 10",
          "code": "for(int p : primes) {\n    if (p*p > v) break; // <- add this line\n    int cnt = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 5, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; i++) {\n        int n = inf.readInt(5, 24, \"n\");\n        inf.readSpace();\n        int p_max = n * (n - 1) / 2 - 2 * n;\n        int p = inf.readInt(0, p_max, \"p\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 5, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; i++) {\n        int n = inf.readInt(5, 24, \"n\");\n        inf.readSpace();\n        int p_max = n * (n - 1) / 2 - 2 * n;\n        int p = inf.readInt(0, p_max, \"p\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 5, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; i++) {\n        int n = inf.readInt(5, 24, \"n\");\n        inf.readSpace();\n        int p_max = n * (n - 1) / 2 - 2 * n;\n        int p = inf.readInt(0, p_max, \"p\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int t = inf.readInt(1, 5, \"t\");\n    for (int test_num = 1; test_num <= t; ++test_num) {\n        int n = inf.readInt(5, 24, \"n\");\n        int p = inf.readInt(0, 1000000, \"p\");\n        int E = 2 * n + p; // Expected number of edges\n\n        // Read edges from output file\n        // Read E edges for this test case\n        set<pair<int, int>> edge_set;\n        vector<pair<int, int>> edges;\n        for (int i = 0; i < E; ++i) {\n            int a = ouf.readInt(1, n, format(\"a_%d\", i + 1).c_str());\n            int b = ouf.readInt(1, n, format(\"b_%d\", i + 1).c_str());\n            if (a == b)\n                quitf(_wa, \"Self-loop detected on vertex %d\", a);\n            if (a > b)\n                swap(a, b); // Ensure a < b\n            pair<int, int> edge = make_pair(a - 1, b - 1);\n            if (edge_set.count(edge))\n                quitf(_wa, \"Multiple edges between %d and %d\", a, b);\n            edge_set.insert(edge);\n            edges.push_back(edge);\n        }\n        // Build adjacency lists\n        vector<uint32_t> adj(n, 0);\n        for (auto& edge : edges) {\n            int u = edge.first;\n            int v = edge.second;\n            adj[u] |= (1 << v);\n            adj[v] |= (1 << u);\n        }\n        // Prepare for subset processing\n        int N = n;\n        if (N > 24)\n            quitf(_fail, \"n is too large: %d (max 24)\", N);\n        int total_subsets = 1 << N;\n        vector<int> edges_in_subset(total_subsets, 0);\n        vector<int> popcount(total_subsets, 0);\n        for (int s = 0; s < total_subsets; ++s)\n            popcount[s] = __builtin_popcount(s);\n        // For each edge, update edges_in_subset\n        for (auto& edge : edges) {\n            int u = edge.first;\n            int v = edge.second;\n            int s = (1 << u) | (1 << v);\n            int s_bar = (~s) & (total_subsets - 1);\n            int m = s_bar;\n            do {\n                int s_prime = s | m;\n                edges_in_subset[s_prime] += 1;\n                if (m == 0)\n                    break;\n                m = (m - 1) & s_bar;\n            } while (true);\n        }\n        // Check condition for all subsets\n        for (int s = 0; s < total_subsets; ++s) {\n            int k = popcount[s];\n            int allowed_edges = 2 * k + p;\n            if (edges_in_subset[s] > allowed_edges)\n                quitf(_wa, \"Test %d: Subgraph with %d vertices has %d edges, exceeds 2k+p=%d\", test_num, k, edges_in_subset[s], allowed_edges);\n        }\n    }\n    quitf(_ok, \"All tests passed.\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // The number of vertices (required parameter)\n    int p = opt<int>(\"p\", -1); // The interest value p (optional parameter)\n    string p_type = opt<string>(\"p_type\", \"random\"); // Type of p if not specified\n\n    // Validate n\n    if (n < 5 || n > 24) {\n        fprintf(stderr, \"Invalid n: %d. n must be between 5 and 24.\\n\", n);\n        exit(1);\n    }\n\n    // Calculate maximum possible p for given n\n    int max_p = n * (n - 1) / 2 - 2 * n;\n    if (max_p < 0) max_p = 0;\n\n    // Determine p\n    if (p == -1) {\n        if (p_type == \"min_p\") {\n            p = 0;\n        } else if (p_type == \"max_p\") {\n            p = max_p;\n        } else if (p_type == \"random\") {\n            p = rnd.next(0, max_p);\n        } else {\n            fprintf(stderr, \"Unsupported p_type: %s\\n\", p_type.c_str());\n            exit(1);\n        }\n    } else {\n        if (p < 0 || p > max_p) {\n            fprintf(stderr, \"Invalid p: %d for n = %d. p must be between 0 and %d.\\n\", p, n, max_p);\n            exit(1);\n        }\n    }\n\n    // Output the test case\n    printf(\"1\\n\"); // Number of test cases is always 1 per execution\n    printf(\"%d %d\\n\", n, p);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // The number of vertices (required parameter)\n    int p = opt<int>(\"p\", -1); // The interest value p (optional parameter)\n    string p_type = opt<string>(\"p_type\", \"random\"); // Type of p if not specified\n\n    // Validate n\n    if (n < 5 || n > 24) {\n        fprintf(stderr, \"Invalid n: %d. n must be between 5 and 24.\\n\", n);\n        exit(1);\n    }\n\n    // Calculate maximum possible p for given n\n    int max_p = n * (n - 1) / 2 - 2 * n;\n    if (max_p < 0) max_p = 0;\n\n    // Determine p\n    if (p == -1) {\n        if (p_type == \"min_p\") {\n            p = 0;\n        } else if (p_type == \"max_p\") {\n            p = max_p;\n        } else if (p_type == \"random\") {\n            p = rnd.next(0, max_p);\n        } else {\n            fprintf(stderr, \"Unsupported p_type: %s\\n\", p_type.c_str());\n            exit(1);\n        }\n    } else {\n        if (p < 0 || p > max_p) {\n            fprintf(stderr, \"Invalid p: %d for n = %d. p must be between 0 and %d.\\n\", p, n, max_p);\n            exit(1);\n        }\n    }\n\n    // Output the test case\n    printf(\"1\\n\"); // Number of test cases is always 1 per execution\n    printf(\"%d %d\\n\", n, p);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n with minimum p\n./gen -n 5 -p_type min_p\n./gen -n 6 -p_type min_p\n./gen -n 7 -p_type min_p\n\n# Small n with maximum p\n./gen -n 5 -p_type max_p\n./gen -n 6 -p_type max_p\n./gen -n 7 -p_type max_p\n\n# Small n with random p\n./gen -n 5 -p_type random\n./gen -n 6 -p_type random\n./gen -n 7 -p_type random\n\n# Large n with minimum p\n./gen -n 22 -p_type min_p\n./gen -n 23 -p_type min_p\n./gen -n 24 -p_type min_p\n\n# Large n with maximum p\n./gen -n 22 -p_type max_p\n./gen -n 23 -p_type max_p\n./gen -n 24 -p_type max_p\n\n# Large n with random p\n./gen -n 22 -p_type random\n./gen -n 23 -p_type random\n./gen -n 24 -p_type random\n\n# Random n with specified p\n./gen -n 10 -p 0\n./gen -n 15 -p 10\n./gen -n 20 -p 50\n\n# Test with n at the minimum value\n./gen -n 5 -p 0\n\n# Test with n at the maximum value\n./gen -n 24 -p_type random\n\n# Edge cases where p is zero and maximum possible\n./gen -n 8 -p 0\n./gen -n 8 -p_type max_p\n\n# Additional random tests\n./gen -n 12 -p_type random\n./gen -n 17 -p_type random\n./gen -n 19 -p_type random\n\n# Test with specific values of p\n./gen -n 14 -p 5\n./gen -n 14 -p 15\n./gen -n 14 -p_type max_p\n\n# Small n, random p\n./gen -n 9 -p_type random\n./gen -n 11 -p_type random\n\n# Large n, p zero\n./gen -n 20 -p 0\n\n# Test with middle n and p\n./gen -n 15 -p_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:49.586964",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "403/B",
      "title": "B. Upgrading Array",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 5000) showing how many numbers are in the array and how many bad prime numbers there are.The second line contains n space-separated integers a[1], a[2], ..., a[n] (1 ≤ a[i] ≤ 109) — array a. The third line contains m space-separated integers b1, b2, ..., bm (2 ≤ b1 < b2 < ... < bm ≤ 109) — the set of bad prime numbers.",
      "output_spec": "OutputPrint a single integer — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy5 24 20 34 10 102 5OutputCopy-2InputCopy4 52 4 8 163 5 7 11 17OutputCopy10",
      "description": "B. Upgrading Array\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 5000) showing how many numbers are in the array and how many bad prime numbers there are.The second line contains n space-separated integers a[1], a[2], ..., a[n] (1 ≤ a[i] ≤ 109) — array a. The third line contains m space-separated integers b1, b2, ..., bm (2 ≤ b1 < b2 < ... < bm ≤ 109) — the set of bad prime numbers.\n\nOutputPrint a single integer — the answer to the problem.\n\nInputCopy5 24 20 34 10 102 5OutputCopy-2InputCopy4 52 4 8 163 5 7 11 17OutputCopy10\n\nInputCopy5 24 20 34 10 102 5\n\nOutputCopy-2\n\nInputCopy4 52 4 8 163 5 7 11 17\n\nOutputCopy10\n\nNoteNote that the answer to the problem can be negative.The GCD(x1, x2, ..., xk) is the maximum positive integer that divides each xi.",
      "solutions": [
        {
          "title": "Codeforces Round #236 - Codeforces",
          "content": "Soon (on March 16, 19:30 MSK) you are lucky to participate in Codeforces Round #236 for both divisions.Problems have been prepared by me. It’s my first round for both divisions and I hope not last. I want to thank Gerald Agapov (Gerald) for help in preparation of this round, Ilya Los (IlyaLos) and Ignatyev Alexander (aiMR) for testing of problems, Mary Belova(Delinur) for translating the problems, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems. UPD: Scoring system:Div. 2: 500 — 1000 — 1500 — 2000 — 2500Div. 1: 500 — 1000 — 1500 — 1500 — 2000 UPD:Contest finished, congratulation for winners!Div.2 : vladb iceiceice LoneFox ofpsxx adsz Div. 1: 1 sillycross 2 KADR 2 vepifanov 4 Endagorion 5 glassices 6 cgy4ever 7 rowdark 8 snuke 9 ftiasch 10 fsouza UPD:Editorial. UPD:Round Statistics from DmitriyH.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10959",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 839
        },
        {
          "title": "Editorial Codeforces Round #236 - Codeforces",
          "content": "402A - NutsLet's fix some value of boxes ans. After that we can get exactly cnt = ans + min((k - 1) * ans, B) of sections. So, if cnt * v ≥ a, then ans be an answer. After that you can use brute force to find smallest possible value of ans.402B - Trees in a RowLet's fix height of the first tree: let's call it a. Of course, a is an integer from segment [1, 1000]. After that, for the fixed height a of the first tree we can calculate heights of the others trees: a, a + k, a + 2k, and so on. After that you should find minimal number of operations ans to achive such heights. After that we can use brute force to find smallest possible ans for each a from 1 to 1000. For best height of the first tree you should print all operations.402C - Searching for Graph / 403A - Searching for GraphI will describe two solutions.First. Consider all pairs (i, j) (1 ≤ i < j ≤ n). After you should ouput the first 2n + p pairs in lexicographical order.It's clear to understand, that it is enough to prove, that 0-interesting graph is correct or  - 3 -interesting graph is correct. We will prove for  - 3 -interesting graph, that it is correct. This graph consists of triangles, which have an common edge 1 — 2. Let's fix some subset of vertexes, which does not contains vertexes 1 and 2. In such sets there are no edges. Let's fix some subset, which contains exactly one vertex (1 or 2). In such subsets there are exactly k - 1 edges, where k is the size of such subset. In other subset there are exactly 2 * (k — 2) + 1 edges, where k is the size of such subset.Second. Let's use some brute force, to build graphs with 0-interesting graphs with sizes 5, 6, 7, 8, 9 vertexes. Now, to build p-interesting graph with n vertexes, We will build 0-interesting graph, and after that we will add to it p another edges, which is not in the graph. We will build 0-interesting graphs using the following approach: Let's took k disjointed components, from graphs with number of vertexes from 5 to 9, in such way that there are exactly n vertexes in graph.402D - Upgrading Array / 403B - Upgrading ArrayI will describe two solutions.First. Dynamic programming approach. Let's calculate an DP d[i][j] — which is the best possible answer we can achieve, if current prefix has length i and we used operation of Upgrading last time in position j. It is clear to understand, that we should iterate i from n to 1, and j from n to i. There are only two transitions: First, d[i - 1][j] = max(d[i - 1][j], d[i][j]) — we will not use operation of upgrading of array in the current position. Second, d[i - 1][i - 1] = max(d[i - 1][i - 1], d[i][j] + f(tgcd[j]) * i - f(tgcd[i - 1]) * i — we are using an operation of upgrading. f(a) — is a beauty of the number. tgcd[i] — gcd of all numbers on the prefix of length i. You can use function, which works in to calculate the beauty. Also you can make your solution more faster, it you will precalculate some small primes. Also you can use map < int, int >  to store calculated values. DP base d[n][n] = curBeauty — is a current beauty of the array. Second. Greedy. Let's find position r, which can upgrade our answer. If there some values of r — we will take most right position. We will add this position to the answer and upgrade our answer. Why it's correct? Let's fix an optimal solution (sequence of position, where we used an upgrading operation) r1 > r2 > ... > rk. Also we have an solution which was built by using greedy l1 > l2 > ... > lm. It's clear, that r1 ≤ l1, because all position with  > l1 cannot upgrade anything (otherwise greedy will choose it as first position). In other hand, r1 ≥ l1, because otherwise we can upgrade in position l1 and make answer better. So, r1 = l1, and after that we can use our propositions for big indexes i.402E - Strictly Positive Matrix / 403C - Strictly Positive MatrixLet's look at the matrix a as a connectivity matrix of some graph with n vertices. Moreover, if aij > 0, then we have directed edge in the graph between nodes (i, j). Otherwise, if aij = 0 that graph does not contains directed edge between pair of nodes (i, j). Let b = ak. What does bij means? bij is the number of paths of length exactly k in our graph from vertex i to vertex j. Let pos is an integer, such that a[pos][pos] > 0. That is, we have a loop in the graph. So, if from the vertex pos achievable all other vertexes and vice versa, from all other vertices reachable vertex pos, then the answer is YES, otherwise the answer is NO. If reachability is missing, it is clear that for any k akipos = 0. If reachability there, we will be able to reach self-loop, use self-loop \"to twist\", and after that we will go to some another vertex.403D - Beautiful Pairs of NumbersFirst, we can note, that length of sequence is not greater then 50. Ok, but why? Because all numbers bi - ai are different, so 0 + 1 + ... + 50 > 1000. Let's imagine, that sequence from input is a sequence of non-intersecting segments. So, ci = bi - ai + 1 is length of segment i. Also, . After that let's calculate the following DP: d[i][j][k] — — number of sequences for which following holds: c1 < c2 < ... < ci, ci ≥ 1 , c1 + c2 + ... + ci = j and maximal number is less then k (upper bound of sequence). This DP will helps us to calculate number of ways to set length to each segment in sequence. It's simple to calculate such DP: base d[0][0][1] = 1, d[i][j][k + 1] = d[i][j][k + 1] + d[i][j][k] — we increase upper bound of sequence; d[i + 1][j + k][k + 1] = d[i + 1][j + k][k + 1] + d[i][j][k] — we are adding upper bound to the sequence. We can calculate such DP, by using only O(N2) of memory, where N = 1000. After that we should multiply d[i][j][k] on i!, because we need number of sequences ci, where order does not matter.After that we can calculate answer for n, k. Let's , where x — some upper bound of sequences. After that we should calculate next number: how many ways to set to distances between segments? It's clear, that we can increase distance between some segments, but we have only n - len such operations. It's well known, that answer number of ways equals to C(n - len + k, k). So, for each n we should sum by len following values: sum[len] * C(n - len + k, k).Note, that we need array C[n][k] (binomials) where n ≤ 2000, k ≤ 2000.403E - Two Rooted TreesFirst, for each vertex of the first and second tree we calculate two values in[s], out[s] — the entry time and exit time in dfs order from vertex with number 1. Also with each edge from both trees we will assosiate a pair (p, q), where p = min(in[u], in[v]), q = max(in[u], in[v]) (values in, out for each vertex we take from tree with another color). Now for each tree we will build two segment trees (yes, totally 4 segment trees). In first segment will store all pairs in following way: we will store a pair in node of segment tree if and only if (node of segment tree is a segment (l, r)) left element of pair lies in segment (l, r). In second segment tree we will store a pair if and only if right element of the pair lies in segment (l, r) All pairs in segment trees we will store in some order (in first segment tree — increasing order, in the second tree — decreasing order). Such trees use of memory, also you can build it in .Good. How to answer on query (l, r) — erase all edges from tree for which exactly one vertex have value in[s] in segment (l, r)? We will go down in our segment tree. Let's imagine, that now we in some node of segment tree. Because we store all pairs in the first segment tree in increasing order of the right element, so answer to the query is a some suffix of the array of pairs. After we can add they to the answer (if it not erased yet). After that we should modify our segment tree: for each node, where we work with suffixes, we should erase all pairs from such suffix. So, this solution in .My solution to E: 6052738",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10972",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 403\\s*B"
          },
          "content_length": 7846
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #236 - Codeforces - Code 1",
          "code": "int cn; cin >> cn;\n\tfor(int ci = 0; ci < cn; ci++) {\n\t\tint n,p; cin >> n >> p;\n\t\tint cnt = 0;\n\t\tfor(int k = 2; k <= n; k++) \n\t\t\tfor(int i = 1; i < k && ( cnt < (2*k + p) ) ; i++)\n\t\t\t\tcout << i << \" \" << k << \"\\n\", ++cnt;\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 2",
          "code": "int cn; cin >> cn;\n\tfor(int ci = 0; ci < cn; ci++) {\n\t\tint n,p; cin >> n >> p;\n\t\tint cnt = 0;\n\t\tfor(int k = 2; k <= n; k++) \n\t\t\tfor(int i = 1; i < k && ( cnt < (2*k + p) ) ; i++)\n\t\t\t\tcout << i << \" \" << k << \"\\n\", ++cnt;\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 3",
          "code": "V[j]/=gcd(V[j],Div[i]);\nDiv[j]/=gcd(Div[j],Div[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 4",
          "code": "V[j]/=gcd(V[j],Div[i]);\nDiv[j]/=gcd(Div[j],Div[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 5",
          "code": "for(int p : primes) {\n    if (p*p > v) break; // <- add this line\n    int cnt = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 6",
          "code": "for(int p : primes) {\n    if (p*p > v) break; // <- add this line\n    int cnt = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long powerMod(long long a, long long d, int mod) {\n    long long result = 1;\n    a = a % mod;\n    while (d > 0) {\n        if (d & 1)\n            result = (result * a) % mod;\n        a = (a * a) % mod;\n        d >>= 1;\n    }\n    return result;\n}\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if ((n % 2) == 0) return false;\n    int d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        ++s;\n    }\n    int bases[] = {2, 3};\n    for (int a : bases) {\n        if (a >= n) continue;\n        long long x = powerMod(a, d, n);\n        if (x == 1 || x == n - 1)\n            continue;\n        bool composite = true;\n        for (int r = 1; r < s; ++r) {\n            x = (x * x) % n;\n            if (x == n - 1) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite)\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(m, 2, 1000000000, \"b\");\n    inf.readEoln();\n\n    for (int i = 0; i < m - 1; ++i) {\n        ensuref(b[i] < b[i + 1], \"b[%d]=%d should be less than b[%d]=%d\", i + 1, b[i], i + 2, b[i + 1]);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        ensuref(isPrime(b[i]), \"b[%d]=%d is not a prime number\", i + 1, b[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long powerMod(long long a, long long d, int mod) {\n    long long result = 1;\n    a = a % mod;\n    while (d > 0) {\n        if (d & 1)\n            result = (result * a) % mod;\n        a = (a * a) % mod;\n        d >>= 1;\n    }\n    return result;\n}\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if ((n % 2) == 0) return false;\n    int d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        ++s;\n    }\n    int bases[] = {2, 3};\n    for (int a : bases) {\n        if (a >= n) continue;\n        long long x = powerMod(a, d, n);\n        if (x == 1 || x == n - 1)\n            continue;\n        bool composite = true;\n        for (int r = 1; r < s; ++r) {\n            x = (x * x) % n;\n            if (x == n - 1) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite)\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(m, 2, 1000000000, \"b\");\n    inf.readEoln();\n\n    for (int i = 0; i < m - 1; ++i) {\n        ensuref(b[i] < b[i + 1], \"b[%d]=%d should be less than b[%d]=%d\", i + 1, b[i], i + 2, b[i + 1]);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        ensuref(isPrime(b[i]), \"b[%d]=%d is not a prime number\", i + 1, b[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long powerMod(long long a, long long d, int mod) {\n    long long result = 1;\n    a = a % mod;\n    while (d > 0) {\n        if (d & 1)\n            result = (result * a) % mod;\n        a = (a * a) % mod;\n        d >>= 1;\n    }\n    return result;\n}\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if ((n % 2) == 0) return false;\n    int d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        ++s;\n    }\n    int bases[] = {2, 3};\n    for (int a : bases) {\n        if (a >= n) continue;\n        long long x = powerMod(a, d, n);\n        if (x == 1 || x == n - 1)\n            continue;\n        bool composite = true;\n        for (int r = 1; r < s; ++r) {\n            x = (x * x) % n;\n            if (x == n - 1) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite)\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(m, 2, 1000000000, \"b\");\n    inf.readEoln();\n\n    for (int i = 0; i < m - 1; ++i) {\n        ensuref(b[i] < b[i + 1], \"b[%d]=%d should be less than b[%d]=%d\", i + 1, b[i], i + 2, b[i + 1]);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        ensuref(isPrime(b[i]), \"b[%d]=%d is not a prime number\", i + 1, b[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Generate all primes up to max_limit\nconst int max_limit = 1000000;\nvector<int> primes;\n\nvoid generate_primes() {\n    vector<bool> is_prime(max_limit + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; i <= max_limit; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n            if (1LL * i * i <= max_limit) {\n                for (int j = i * i; j <= max_limit; j += i) {\n                    is_prime[j] = false;\n                }\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    generate_primes();\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate array a[1..n], and bad primes b[1..m].\n    vector<int> a(n);\n    vector<int> b(m);\n\n    if (type == \"random\") {\n        // Generate random a[i]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, int(1e9));\n        }\n\n        // Generate m distinct bad primes\n        set<int> bad_primes_set;\n        while (int(bad_primes_set.size()) < m) {\n            int idx = rnd.next(0, int(primes.size()) - 1);\n            bad_primes_set.insert(primes[idx]);\n        }\n        b.assign(bad_primes_set.begin(), bad_primes_set.end());\n        sort(b.begin(), b.end());\n    } else if (type == \"all_bad\") {\n        // Generate bad primes\n        set<int> bad_primes_set;\n        while (int(bad_primes_set.size()) < m) {\n            int idx = rnd.next(0, int(primes.size()) - 1);\n            bad_primes_set.insert(primes[idx]);\n        }\n        b.assign(bad_primes_set.begin(), bad_primes_set.end());\n        sort(b.begin(), b.end());\n\n        // Now generate a[i], minimum prime divisors are in b\n        vector<int> bad_primes(b.begin(), b.end());\n        for (int i = 0; i < n; ++i) {\n            int bp = bad_primes[rnd.next(0, m - 1)];\n            // Multiply by random number >=1\n            int num = bp * rnd.next(1, int(1e3));\n            if (num > int(1e9)) num = bp;\n            a[i] = num;\n        }\n    } else if (type == \"all_good\") {\n        // Generate bad primes\n        set<int> bad_primes_set;\n        while (int(bad_primes_set.size()) < m) {\n            int idx = rnd.next(0, int(primes.size()) - 1);\n            bad_primes_set.insert(primes[idx]);\n        }\n        b.assign(bad_primes_set.begin(), bad_primes_set.end());\n        sort(b.begin(), b.end());\n\n        // Now generate a[i], minimum prime divisors are not in b\n        set<int> bad_primes(b.begin(), b.end());\n        vector<int> good_primes;\n        for (int p : primes) {\n            if (!bad_primes.count(p)) {\n                good_primes.push_back(p);\n            }\n        }\n        // If good_primes is empty, adjust m\n        if (good_primes.empty()) {\n            fprintf(stderr, \"Not enough good primes, adjust m\\n\");\n            return 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            int gp = good_primes[rnd.next(0, int(good_primes.size()) - 1)];\n            int num = gp * rnd.next(1, int(1e3));\n            if (num > int(1e9)) num = gp;\n            a[i] = num;\n        }\n    } else if (type == \"ones\") {\n        // All a[i] = 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        // Generate random bad primes\n        set<int> bad_primes_set;\n        while (int(bad_primes_set.size()) < m) {\n            int idx = rnd.next(0, int(primes.size()) - 1);\n            bad_primes_set.insert(primes[idx]);\n        }\n        b.assign(bad_primes_set.begin(), bad_primes_set.end());\n        sort(b.begin(), b.end());\n    } else if (type == \"same_number\") {\n        // All a[i] equal to a random number\n        int num = rnd.next(2, int(1e9));\n        for (int i = 0; i < n; ++i) {\n            a[i] = num;\n        }\n        // Generate random bad primes\n        set<int> bad_primes_set;\n        while (int(bad_primes_set.size()) < m) {\n            int idx = rnd.next(0, int(primes.size()) - 1);\n            bad_primes_set.insert(primes[idx]);\n        }\n        b.assign(bad_primes_set.begin(), bad_primes_set.end());\n        sort(b.begin(), b.end());\n    } else if (type == \"max_elements\") {\n        // Elements are maximized a[i] = 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = int(1e9);\n        }\n        // Generate random bad primes\n        set<int> bad_primes_set;\n        while (int(bad_primes_set.size()) < m) {\n            int idx = rnd.next(0, int(primes.size()) - 1);\n            bad_primes_set.insert(primes[idx]);\n        }\n        b.assign(bad_primes_set.begin(), bad_primes_set.end());\n        sort(b.begin(), b.end());\n    } else if (type == \"min_elements\") {\n        // Elements are minimized a[i] = 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        // Generate random bad primes\n        set<int> bad_primes_set;\n        while (int(bad_primes_set.size()) < m) {\n            int idx = rnd.next(0, int(primes.size()) - 1);\n            bad_primes_set.insert(primes[idx]);\n        }\n        b.assign(bad_primes_set.begin(), bad_primes_set.end());\n        sort(b.begin(), b.end());\n    } else {\n        // Default random case\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, int(1e9));\n        }\n\n        set<int> bad_primes_set;\n        while (int(bad_primes_set.size()) < m) {\n            int idx = rnd.next(0, int(primes.size()) - 1);\n            bad_primes_set.insert(primes[idx]);\n        }\n        b.assign(bad_primes_set.begin(), bad_primes_set.end());\n        sort(b.begin(), b.end());\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], (i == m - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Generate all primes up to max_limit\nconst int max_limit = 1000000;\nvector<int> primes;\n\nvoid generate_primes() {\n    vector<bool> is_prime(max_limit + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; i <= max_limit; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n            if (1LL * i * i <= max_limit) {\n                for (int j = i * i; j <= max_limit; j += i) {\n                    is_prime[j] = false;\n                }\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    generate_primes();\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate array a[1..n], and bad primes b[1..m].\n    vector<int> a(n);\n    vector<int> b(m);\n\n    if (type == \"random\") {\n        // Generate random a[i]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, int(1e9));\n        }\n\n        // Generate m distinct bad primes\n        set<int> bad_primes_set;\n        while (int(bad_primes_set.size()) < m) {\n            int idx = rnd.next(0, int(primes.size()) - 1);\n            bad_primes_set.insert(primes[idx]);\n        }\n        b.assign(bad_primes_set.begin(), bad_primes_set.end());\n        sort(b.begin(), b.end());\n    } else if (type == \"all_bad\") {\n        // Generate bad primes\n        set<int> bad_primes_set;\n        while (int(bad_primes_set.size()) < m) {\n            int idx = rnd.next(0, int(primes.size()) - 1);\n            bad_primes_set.insert(primes[idx]);\n        }\n        b.assign(bad_primes_set.begin(), bad_primes_set.end());\n        sort(b.begin(), b.end());\n\n        // Now generate a[i], minimum prime divisors are in b\n        vector<int> bad_primes(b.begin(), b.end());\n        for (int i = 0; i < n; ++i) {\n            int bp = bad_primes[rnd.next(0, m - 1)];\n            // Multiply by random number >=1\n            int num = bp * rnd.next(1, int(1e3));\n            if (num > int(1e9)) num = bp;\n            a[i] = num;\n        }\n    } else if (type == \"all_good\") {\n        // Generate bad primes\n        set<int> bad_primes_set;\n        while (int(bad_primes_set.size()) < m) {\n            int idx = rnd.next(0, int(primes.size()) - 1);\n            bad_primes_set.insert(primes[idx]);\n        }\n        b.assign(bad_primes_set.begin(), bad_primes_set.end());\n        sort(b.begin(), b.end());\n\n        // Now generate a[i], minimum prime divisors are not in b\n        set<int> bad_primes(b.begin(), b.end());\n        vector<int> good_primes;\n        for (int p : primes) {\n            if (!bad_primes.count(p)) {\n                good_primes.push_back(p);\n            }\n        }\n        // If good_primes is empty, adjust m\n        if (good_primes.empty()) {\n            fprintf(stderr, \"Not enough good primes, adjust m\\n\");\n            return 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            int gp = good_primes[rnd.next(0, int(good_primes.size()) - 1)];\n            int num = gp * rnd.next(1, int(1e3));\n            if (num > int(1e9)) num = gp;\n            a[i] = num;\n        }\n    } else if (type == \"ones\") {\n        // All a[i] = 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        // Generate random bad primes\n        set<int> bad_primes_set;\n        while (int(bad_primes_set.size()) < m) {\n            int idx = rnd.next(0, int(primes.size()) - 1);\n            bad_primes_set.insert(primes[idx]);\n        }\n        b.assign(bad_primes_set.begin(), bad_primes_set.end());\n        sort(b.begin(), b.end());\n    } else if (type == \"same_number\") {\n        // All a[i] equal to a random number\n        int num = rnd.next(2, int(1e9));\n        for (int i = 0; i < n; ++i) {\n            a[i] = num;\n        }\n        // Generate random bad primes\n        set<int> bad_primes_set;\n        while (int(bad_primes_set.size()) < m) {\n            int idx = rnd.next(0, int(primes.size()) - 1);\n            bad_primes_set.insert(primes[idx]);\n        }\n        b.assign(bad_primes_set.begin(), bad_primes_set.end());\n        sort(b.begin(), b.end());\n    } else if (type == \"max_elements\") {\n        // Elements are maximized a[i] = 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = int(1e9);\n        }\n        // Generate random bad primes\n        set<int> bad_primes_set;\n        while (int(bad_primes_set.size()) < m) {\n            int idx = rnd.next(0, int(primes.size()) - 1);\n            bad_primes_set.insert(primes[idx]);\n        }\n        b.assign(bad_primes_set.begin(), bad_primes_set.end());\n        sort(b.begin(), b.end());\n    } else if (type == \"min_elements\") {\n        // Elements are minimized a[i] = 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        // Generate random bad primes\n        set<int> bad_primes_set;\n        while (int(bad_primes_set.size()) < m) {\n            int idx = rnd.next(0, int(primes.size()) - 1);\n            bad_primes_set.insert(primes[idx]);\n        }\n        b.assign(bad_primes_set.begin(), bad_primes_set.end());\n        sort(b.begin(), b.end());\n    } else {\n        // Default random case\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, int(1e9));\n        }\n\n        set<int> bad_primes_set;\n        while (int(bad_primes_set.size()) < m) {\n            int idx = rnd.next(0, int(primes.size()) - 1);\n            bad_primes_set.insert(primes[idx]);\n        }\n        b.assign(bad_primes_set.begin(), bad_primes_set.end());\n        sort(b.begin(), b.end());\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], (i == m - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 2 -type random             # Small random test case\n./gen -n 10 -m 5 -type random\n./gen -n 50 -m 20 -type random\n./gen -n 100 -m 50 -type random\n\n./gen -n 5000 -m 5000 -type random       # Maximum n and m\n\n./gen -n 5000 -m 5000 -type all_good     # All primes are good\n./gen -n 5000 -m 5000 -type all_bad      # All primes are bad\n\n./gen -n 5000 -m 5000 -type ones         # All elements are 1\n\n./gen -n 5000 -m 5000 -type same_number  # All elements are the same number\n\n./gen -n 5000 -m 5000 -type max_elements # All elements are 1e9\n\n./gen -n 5000 -m 1 -type random          # m is 1\n\n./gen -n 1 -m 5000 -type random          # n is 1\n\n./gen -n 1 -m 1 -type random             # n and m are 1\n\n./gen -n 5000 -m 1000 -type min_elements # All elements are 1\n\n./gen -n 2 -m 2 -type random             # Smallest nontrivial case\n\n./gen -n 4999 -m 4999 -type all_good\n\n./gen -n 4999 -m 4999 -type all_bad\n\n./gen -n 2500 -m 2500 -type random\n\n./gen -n 3000 -m 500 -type random\n\n./gen -n 5000 -m 10 -type all_good\n\n./gen -n 5000 -m 10 -type all_bad\n\n./gen -n 5000 -m 10 -type ones\n\n./gen -n 5000 -m 10 -type same_number\n\n./gen -n 5000 -m 5000 -type random\n\n./gen -n 5000 -m 1 -type random\n\n./gen -n 1 -m 5000 -type random\n\n./gen -n 5000 -m 5000 -type min_elements\n\n./gen -n 5000 -m 5000 -type max_elements\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:52.004804",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "403/C",
      "title": "C. Строго положительная матрица",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано целое число n (2 ≤ n ≤ 2000) — количество строк и столбцов в матрице a.В следующих n строках задано описание строк матрицы a. В i-ой строке задано n целых неотрицательных чисел ai1, ai2, ..., ain (0 ≤ aij ≤ 50). Гарантируется, что .",
      "output_spec": "Выходные данныеЕсли существует целое число k ≥ 1, такое, что матрица ak является строго положительной, выведите «YES» (без кавычек). Иначе, выведите «NO» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать21 00 1Выходные данныеСкопироватьNOВходные данныеСкопировать54 5 6 1 21 2 3 4 56 4 1 2 41 1 1 1 14 4 4 4 4Выходные данныеСкопироватьYES",
      "description": "C. Строго положительная матрица\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке задано целое число n (2 ≤ n ≤ 2000) — количество строк и столбцов в матрице a.В следующих n строках задано описание строк матрицы a. В i-ой строке задано n целых неотрицательных чисел ai1, ai2, ..., ain (0 ≤ aij ≤ 50). Гарантируется, что .\n\nВходные данные\n\nВыходные данныеЕсли существует целое число k ≥ 1, такое, что матрица ak является строго положительной, выведите «YES» (без кавычек). Иначе, выведите «NO» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать21 00 1Выходные данныеСкопироватьNOВходные данныеСкопировать54 5 6 1 21 2 3 4 56 4 1 2 41 1 1 1 14 4 4 4 4Выходные данныеСкопироватьYES\n\nВходные данныеСкопировать21 00 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать54 5 6 1 21 2 3 4 56 4 1 2 41 1 1 1 14 4 4 4 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #236 - Codeforces",
          "content": "Скоро, 16 марта, 19:30 MSK, состоится очередной Codeforces Round #236 для участников из обоих дивизионов.Автором задач являюсь я. Это мой первый раунд для обоих дивизионов, и я надеюсь не последний. Большое спасибо Геральду Агапову (Gerald) за помощь в подготовке задач, Лось Илье (IlyaLos) и Александру Игнатьеву (aiMR) за тестирование, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon. UPD: Распределение баллов:Div. 2: 500 — 1000 — 1500 — 2000 — 2500Div. 1: 500 — 1000 — 1500 — 1500 — 2000 UPD:Соревнование закончено, поздравляем победителей!Div.2 : vladb iceiceice LoneFox ofpsxx adsz Div. 1: 1 sillycross 2 KADR 2 vepifanov 4 Endagorion 5 glassices 6 cgy4ever 7 rowdark 8 snuke 9 ftiasch 10 fsouza UPD:Разбор задач на русскомUPD:Статистика раунда от DmitriyH.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10959",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 848
        },
        {
          "title": "Разбор Codeforces Round #236 - Codeforces",
          "content": "402A - ОрехиДостаточно просто перебрать количество коробок, которыми мы воспользуемся. Предположим, это число равно ans. Тогда всего мы можем получить ровно cnt = ans + min((k - 1) * ans, B) отсеков. Если cnt * v ≥ a, тогда ответ равен ans.402B - Деревья в рядуДостаточно перебрать высоту первого дерева от 1 до 1000. При фиксированной высоте первого дерева высоты деревьев однозначно определены, то есть имеют вид: a, a + k, a + 2k и так далее. После этого необходимо подсчитать количество операций, чтобы получить красивый ряд из деревьев при фиксированной минимальной высоте. Обновим ответ. После этого выведем для самой оптимальной высоты все операции.402C - Ищем граф / 403A - Ищем графОпишу два решения.Первое. Рассмотрим все пары чисел (i, j) (1 ≤ i < j ≤ n). Выведем 2n + p пар в лексикографическом порядке. Во-первых, понятно что достаточно доказать, что 0-интересный граф верный. Более того, достаточно показать, что  - 3 интересный граф является верным. А как выглядит граф из первых 2n - 3 ребер. Очевидно, это граф имеет вид треугольников с общим ребром 1-2. Теперь предположим мы возьмем подмножество, которое не содержит вершины 1 и 2. Нетрудно увидеть, что в таких подграфах будет ноль ребер. Если в подмножестве ровно одна из вершин 1 или 2, то таких ребер будет k - 1, где k размер такого подграфа. Если две, то таких ребер 2 * (k — 2) + 1, где k размер подграфа.Второе. Напишем перебор, который построит нам 0-интересные графы с количеством вершин 5, 6, 7, 8, 9. Теперь заметим, чтобы построить p-интерсный граф с n вершинами, достаточно построить 0-интересный граф, и потом в него p любых ребер, которых еще нет в графе. Как построить 0-интересный граф с n вершинами? Очень просто. Мы просто возьмем k несвязных компонент из построенных нами графов с вершинами от 5 по 9 так, чтобы суммарно в них было ровно n вершин.402D - Улучшаем массив / 403B - Улучшаем массивОпять опишу два решения.Первое. Динамическое программирование. Подсчитаем динамическое программирование d[i][j] какое максимальный ответ мы можем получить, если перед нами сейчас префикс длины i и последний раз мы сокращали на gcd в позиции j. Понятно, что позиции следует перебирать в порядке убывания, как и размер префикса. Всего мы можем улучшить ответ в двух позициях в динамике из текущего состояния. А именно, d[i - 1][j] = max(d[i - 1][j], d[i][j]) — просто не будем сокращать на gcd текущий префикс. d[i - 1][i - 1] = max(d[i - 1][i - 1], d[i][j] + f(tgcd[j]) * i - f(tgcd[i - 1]) * i — выполним сокращение в текущей позиции. tgcd[i] — gcd всех чисел на префиксе длины i. Функция f(a) — возвращает красоту числа. Такую функцию просто реализовать за . Кроме того, можно ускорить работу этой функции, достаточно просто насчитать массив маленьких простых чисел. В таком решении очень важно не забыть, что каждый раз пересчитывать красоту чисел не нужно. Достаточно завести map < int, int >  — который сохранит уже посчитанные значения. База динамики d[n][n] = curBeauty — текущая красота массива.Второе. Жадность. Возьмем самую правую позицию, которая может улучшить ответ. Выберем эту позицию, и сократим в ней на gcd. Докажем, почему так делать верно. Пусть оптимальное решение (последовательность сокращений) имеет вид r1 > r2 > ... > rk. А мы построили решение l1 > l2 > ... > lm используя жадность. Понятно, то r1 ≤ l1, поскольку до этого позиции  > l1 не могли ничего улучшить, ведь иначе наша жадность взяла бы их в качестве своего первого выбора. С другой стороны, r1 ≥ l1, ведь иначе мы можем взять и сократить в позиции l1 и только улучшить ответ, а это противоречило бы оптимальности решения ri. То есть, r1 = l1, а значит, мы можем воспользоваться нашими соображениями и далее, для больших индексов i. 402E - Строго положительная матрица / 403C - Строго положительная матрицаБудем смотреть на матрицу a как на матрицу смежности некоторого графа из n вершин. Причем, если aij > 0, значит мы имеем ориентированное ребро в графе между вершинами (i, j). Иначе, мы получим, что ориентированного ребра нет. Тогда, пусть b = ak. Тогда что обозначает bij? Верно, количество путей длины ровно k в нашем графе из вершины i в вершину j. Пусть pos такое, что a[pos][pos] > 0. То есть, у нас есть петля в графе. Значит, если из вершины pos достижимы все остальные вершины и наоборот, из всех остальных вершин достижима вершина pos, то тогда ответ YES, иначе ответ NO. Понятно, что если достижимость отсутствует, то понятно что для любого k akipos = 0. Если же достижимость имеется, то мы сможем добраться до петли, покрутиться некоторое количество раз в петле, а потом отправиться в нужную вершину. 403D - Красивые пары чиселВо первых отметим, что на самом деле, длина последовательности не больше чем 50. Уже хорошо, а почему? Поскольку все числа bi - ai различны, то 0 + 1 + ... + 50 > 1000. Также представим, что мы имеем на самом деле последовательность попарно не пересекающихся отрезков, ci = bi - ai + 1 — длина отрезка. . Хорошо. Посчитаем динамическое программирование: d[i][j][k] — количество последовательностей из чисел c1 < c2 < ... < ci таких, что ci ≥ 1 и c1 + c2 + ... + ci = j и максимальное число в ней строго меньше чем k. Такая динамика поможет нам посчитать количество способов назначить длины отрезкам. Пересчитать такую динамику очень просто: база d[0][0][1] = 1, d[i][j][k + 1] = d[i][j][k + 1] + d[i][j][k] — просто увеличим верхнюю границу. d[i + 1][j + k][k + 1] = d[i + 1][j + k][k + 1] + d[i][j][k] — ставим текущую границу в последовательность, тем самым увеличиваем сумму и верхнюю границу. Такую динамику нужно написать, используя O(N2) памяти, где N = 1000. После этого, умножим каждое d[i][j][k] на i!, поскольку мы располагать последовательность ci не в порядке возрастания. Таким образом мы умеем считать количество способов назначить длины отрезков.Хорошо. Теперь как получить ответ для n, k? Пусть sum[len] = d[k][len][x], где x — некоторая верхняя граница. Очевидно, что нам дополнительно нужно еще раздать еще n - len единичек. С помощью этих единиц мы можем увеличивать расстояние между отрезками. Количество способов раздать эти единички равно числу C(n - len + k, k). Таким образом, для каждого n просуммируем по len полученные величины и сложим в ответ.Также следует обратить внимание на то, массив C[n][k] должен быть достаточно большим и аккуратно расставить размерности.403E - Два корневых дереваВо-первых для каждой вершины первого и второго дерева подсчитаем две величины in[s], out[s] — время входа и время выхода из вершины в порядке обхода dfs из вершины 1. Теперь с каждому ребру из обоих деревьев мы сопоставим пару (p, q) — где p = min(in[u], in[v]), q = max(in[u], in[v]) где величины in, out для каждой вершины мы берем из дерева другого цвета. Теперь для каждой дерева мы построим два дерева отрезков (в сумме 4 дерева отрезков, да). В первом дереве отрезков мы будем пары хранить в следующем виде: мы будем хранить пару в вершине (вершина дерева отрезков это некоторый отрезок (l, r)) дерева отрезков тогда и только тогда, когда ее левая граница лежит внутри отрека (l, r). Аналогично, во втором дереве отрезков мы будем хранить пару в вершине (вершина дерева отрезков это некоторый отрезок (l, r)) дерева отрезков тогда и только тогда, когда ее правая граница лежит внутри отрека (l, r). Все пары в дереве отрезков мы будем хранить по возрастанию правой границы (левой во втором дереве). Такие деревья отрезков требуют памяти, и построить можно за время .Хорошо. Как теперь ответить на запрос (l, r) — удалить ребра из дерева, такое что одна из вершин имеет время входа внутри (l, r) ? Будем спускаться по дереву отрезков. Предположим, мы сейчас находимся в некоторой его вершине. Поскольку в первом дереве мы храним все пары по возрастанию правой границы, то ответ на запрос, это некоторый суффикс массива его правый границы. После того, как мы обработаем эти ребра и начнем следующий этап, нам нужно модифицировать наше дерево. А именно, для каждой вершины дерева, в которой мы рассматривали суффиксы мы должны их удалить, иначе мы можем обработать их несколько раз. Таким образом, имеем решение за .Авторское решение по Е: 6052738",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/10972",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 403\\s*C"
          },
          "content_length": 8082
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #236 - Codeforces - Code 1",
          "code": "for (int i = 2; ll(i)*i <= xx; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 2",
          "code": "for (int i = 2; i*i <= xx; i++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 3",
          "code": "int cn; cin >> cn;\n\tfor(int ci = 0; ci < cn; ci++) {\n\t\tint n,p; cin >> n >> p;\n\t\tint cnt = 0;\n\t\tfor(int k = 2; k <= n; k++) \n\t\t\tfor(int i = 1; i < k && ( cnt < (2*k + p) ) ; i++)\n\t\t\t\tcout << i << \" \" << k << \"\\n\", ++cnt;\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 4",
          "code": "int cn; cin >> cn;\n\tfor(int ci = 0; ci < cn; ci++) {\n\t\tint n,p; cin >> n >> p;\n\t\tint cnt = 0;\n\t\tfor(int k = 2; k <= n; k++) \n\t\t\tfor(int i = 1; i < k && ( cnt < (2*k + p) ) ; i++)\n\t\t\t\tcout << i << \" \" << k << \"\\n\", ++cnt;\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 5",
          "code": "for (size_t i = 0; i < n; i++)\n        SetEdge(links, i, (i + 1) % n);\n\n    for (size_t i = 0; i < n; i++)\n        SetEdge(links, i, (i + 2) % n);\n\n    for (size_t i = 0; i < p; i++)\n        SetEdge(links, i, (i + n / 2) % n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 6",
          "code": "for (size_t i = 0; i < n; i++)\n        SetEdge(links, i, (i + 1) % n);\n\n    for (size_t i = 0; i < n; i++)\n        SetEdge(links, i, (i + 2) % n);\n\n    for (size_t i = 0; i < p; i++)\n        SetEdge(links, i, (i + n / 2) % n);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 7",
          "code": "V[j]/=gcd(V[j],Div[i]);\nDiv[j]/=gcd(Div[j],Div[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 8",
          "code": "V[j]/=gcd(V[j],Div[i]);\nDiv[j]/=gcd(Div[j],Div[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 9",
          "code": "for(int p : primes) {\n    if (p*p > v) break; // <- add this line\n    int cnt = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 10",
          "code": "for(int p : primes) {\n    if (p*p > v) break; // <- add this line\n    int cnt = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 2000, \"n\"); // Read n\n    inf.readEoln(); // Read EOLN after n\n\n    long long sum = 0;\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(n, 0, 50, \"a_i\"); // Read n integers between 0 and 50\n        sum += accumulate(row.begin(), row.end(), 0LL);\n        inf.readEoln();\n    }\n    ensuref(sum > 0, \"Sum of all a_{i,j} must be greater than zero, but sum=%lld\", sum);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 2000, \"n\"); // Read n\n    inf.readEoln(); // Read EOLN after n\n\n    long long sum = 0;\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(n, 0, 50, \"a_i\"); // Read n integers between 0 and 50\n        sum += accumulate(row.begin(), row.end(), 0LL);\n        inf.readEoln();\n    }\n    ensuref(sum > 0, \"Sum of all a_{i,j} must be greater than zero, but sum=%lld\", sum);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 2000, \"n\"); // Read n\n    inf.readEoln(); // Read EOLN after n\n\n    long long sum = 0;\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(n, 0, 50, \"a_i\"); // Read n integers between 0 and 50\n        sum += accumulate(row.begin(), row.end(), 0LL);\n        inf.readEoln();\n    }\n    ensuref(sum > 0, \"Sum of all a_{i,j} must be greater than zero, but sum=%lld\", sum);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> a(n, vector<int>(n, 0));\n\n    if (type == \"identity\") {\n        // Identity matrix\n        for (int i = 0; i < n; ++i)\n            a[i][i] = 1;\n    } else if (type == \"diagonal\") {\n        // Diagonal matrix with positive entries\n        for (int i = 0; i < n; ++i)\n            a[i][i] = rnd.next(1, 50);\n    } else if (type == \"fully_positive\") {\n        // Matrix with all entries positive\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                a[i][j] = rnd.next(1, 50);\n    } else if (type == \"sparse\") {\n        // Sparse matrix with few non-zero entries\n        int non_zeros = rnd.next(1, n); // Random number of non-zero entries\n        for (int k = 0; k < non_zeros; ++k) {\n            int i = rnd.next(0, n - 1);\n            int j = rnd.next(0, n - 1);\n            a[i][j] = rnd.next(1, 50);\n        }\n    } else if (type == \"reducible\") {\n        // Reducible matrix (block diagonal)\n        int n1 = n / 2;\n        int n2 = n - n1;\n        for (int i = 0; i < n1; ++i)\n            for (int j = 0; j < n1; ++j)\n                a[i][j] = rnd.next(1, 50);\n        for (int i = n1; i < n; ++i)\n            for (int j = n1; j < n; ++j)\n                a[i][j] = rnd.next(1, 50);\n    } else if (type == \"strongly_connected\") {\n        // Strongly connected matrix\n        for (int i = 0; i < n; ++i) {\n            // Ensure at least one non-zero per row\n            a[i][(i + 1) % n] = rnd.next(1, 50);\n            int extra_edges = rnd.next(n / 2, n - 1);\n            set<int> columns;\n            columns.insert((i + 1) % n);\n            while (columns.size() < extra_edges) {\n                int j = rnd.next(0, n - 1);\n                columns.insert(j);\n            }\n            for (int j : columns)\n                a[i][j] = rnd.next(1, 50);\n        }\n    } else {\n        // Random matrix\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                if (rnd.next(0, 1))\n                    a[i][j] = rnd.next(1, 50);\n    }\n\n    // Ensure that sum of elements > 0\n    long long sum = 0;\n    for (int i = 0; i < n; ++i)\n        sum += accumulate(a[i].begin(), a[i].end(), 0LL);\n    if (sum == 0) {\n        a[0][0] = 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the matrix\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", a[i][j]);\n            if (j + 1 < n)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> a(n, vector<int>(n, 0));\n\n    if (type == \"identity\") {\n        // Identity matrix\n        for (int i = 0; i < n; ++i)\n            a[i][i] = 1;\n    } else if (type == \"diagonal\") {\n        // Diagonal matrix with positive entries\n        for (int i = 0; i < n; ++i)\n            a[i][i] = rnd.next(1, 50);\n    } else if (type == \"fully_positive\") {\n        // Matrix with all entries positive\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                a[i][j] = rnd.next(1, 50);\n    } else if (type == \"sparse\") {\n        // Sparse matrix with few non-zero entries\n        int non_zeros = rnd.next(1, n); // Random number of non-zero entries\n        for (int k = 0; k < non_zeros; ++k) {\n            int i = rnd.next(0, n - 1);\n            int j = rnd.next(0, n - 1);\n            a[i][j] = rnd.next(1, 50);\n        }\n    } else if (type == \"reducible\") {\n        // Reducible matrix (block diagonal)\n        int n1 = n / 2;\n        int n2 = n - n1;\n        for (int i = 0; i < n1; ++i)\n            for (int j = 0; j < n1; ++j)\n                a[i][j] = rnd.next(1, 50);\n        for (int i = n1; i < n; ++i)\n            for (int j = n1; j < n; ++j)\n                a[i][j] = rnd.next(1, 50);\n    } else if (type == \"strongly_connected\") {\n        // Strongly connected matrix\n        for (int i = 0; i < n; ++i) {\n            // Ensure at least one non-zero per row\n            a[i][(i + 1) % n] = rnd.next(1, 50);\n            int extra_edges = rnd.next(n / 2, n - 1);\n            set<int> columns;\n            columns.insert((i + 1) % n);\n            while (columns.size() < extra_edges) {\n                int j = rnd.next(0, n - 1);\n                columns.insert(j);\n            }\n            for (int j : columns)\n                a[i][j] = rnd.next(1, 50);\n        }\n    } else {\n        // Random matrix\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                if (rnd.next(0, 1))\n                    a[i][j] = rnd.next(1, 50);\n    }\n\n    // Ensure that sum of elements > 0\n    long long sum = 0;\n    for (int i = 0; i < n; ++i)\n        sum += accumulate(a[i].begin(), a[i].end(), 0LL);\n    if (sum == 0) {\n        a[0][0] = 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the matrix\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", a[i][j]);\n            if (j + 1 < n)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type identity\n./gen -n 2 -type diagonal\n./gen -n 2 -type fully_positive\n./gen -n 2 -type sparse\n./gen -n 2 -type reducible\n./gen -n 2 -type strongly_connected\n./gen -n 2 -type random\n\n./gen -n 10 -type identity\n./gen -n 10 -type diagonal\n./gen -n 10 -type fully_positive\n./gen -n 10 -type sparse\n./gen -n 10 -type reducible\n./gen -n 10 -type strongly_connected\n./gen -n 10 -type random\n\n./gen -n 100 -type identity\n./gen -n 100 -type diagonal\n./gen -n 100 -type fully_positive\n./gen -n 100 -type sparse\n./gen -n 100 -type reducible\n./gen -n 100 -type strongly_connected\n./gen -n 100 -type random\n\n./gen -n 500 -type identity\n./gen -n 500 -type diagonal\n./gen -n 500 -type fully_positive\n./gen -n 500 -type sparse\n./gen -n 500 -type reducible\n./gen -n 500 -type strongly_connected\n./gen -n 500 -type random\n\n./gen -n 2000 -type identity\n./gen -n 2000 -type diagonal\n./gen -n 2000 -type fully_positive\n./gen -n 2000 -type sparse\n./gen -n 2000 -type reducible\n./gen -n 2000 -type strongly_connected\n./gen -n 2000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:53.887506",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "403/D",
      "title": "Problem 403/D",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 200000, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; ++i) {\n        int n = inf.readInt(1, 1000, \"n\");\n        inf.readSpace();\n        int k = inf.readInt(1, n, \"k\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 200000, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; ++i) {\n        int n = inf.readInt(1, 1000, \"n\");\n        inf.readSpace();\n        int k = inf.readInt(1, n, \"k\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 200000, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; ++i) {\n        int n = inf.readInt(1, 1000, \"n\");\n        inf.readSpace();\n        int k = inf.readInt(1, n, \"k\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int t = opt<int>(\"t\");\n    int n_min = opt<int>(\"n_min\", 1);\n    int n_max = opt<int>(\"n_max\", 1000);\n    int k_min = opt<int>(\"k_min\", 1);\n    int k_max = opt<int>(\"k_max\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Limit t to 2e5\n    t = min(t, 200000);\n\n    // Generate t test cases\n    printf(\"%d\\n\", t);\n    for (int i = 0; i < t; ++i) {\n        int n, k;\n\n        if (type == \"min\") {\n            n = n_min;\n            k = k_min;\n        } else if (type == \"max\") {\n            n = n_max;\n            k = k_max;\n        } else if (type == \"random\") {\n            n = rnd.next(n_min, n_max);\n            k = rnd.next(k_min, min(n, k_max));\n        } else if (type == \"zero_answer\") {\n            // Generate test cases where it's likely to have answer zero\n            // One situation where we might get zero answer is when k is large compared to n\n            n = rnd.next(n_min, n_max);\n            k = rnd.next(max(k_min, n - rnd.next(0, n)), min(n, k_max));\n            if (k > n) k = n;\n            if (k < 1) k = 1;\n        } else if (type == \"special\") {\n            int choice = rnd.next(0, 3);\n            if (choice == 0) {\n                n = n_min;\n                k = n_min;\n            } else if (choice == 1) {\n                n = n_max;\n                k = n_max;\n            } else if (choice == 2) {\n                n = rnd.next(n_min, n_max);\n                k = n;\n            } else {\n                n = rnd.next(n_min, n_max);\n                k = rnd.next(k_min, min(n, k_max));\n            }\n        } else {\n            // Default to random\n            n = rnd.next(n_min, n_max);\n            k = rnd.next(k_min, min(n, k_max));\n        }\n\n        // Ensure constraints: 1 ≤ k ≤ n ≤ 1000\n        n = max(1, min(1000, n));\n        k = max(1, min(n, k));\n\n        printf(\"%d %d\\n\", n, k);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int t = opt<int>(\"t\");\n    int n_min = opt<int>(\"n_min\", 1);\n    int n_max = opt<int>(\"n_max\", 1000);\n    int k_min = opt<int>(\"k_min\", 1);\n    int k_max = opt<int>(\"k_max\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Limit t to 2e5\n    t = min(t, 200000);\n\n    // Generate t test cases\n    printf(\"%d\\n\", t);\n    for (int i = 0; i < t; ++i) {\n        int n, k;\n\n        if (type == \"min\") {\n            n = n_min;\n            k = k_min;\n        } else if (type == \"max\") {\n            n = n_max;\n            k = k_max;\n        } else if (type == \"random\") {\n            n = rnd.next(n_min, n_max);\n            k = rnd.next(k_min, min(n, k_max));\n        } else if (type == \"zero_answer\") {\n            // Generate test cases where it's likely to have answer zero\n            // One situation where we might get zero answer is when k is large compared to n\n            n = rnd.next(n_min, n_max);\n            k = rnd.next(max(k_min, n - rnd.next(0, n)), min(n, k_max));\n            if (k > n) k = n;\n            if (k < 1) k = 1;\n        } else if (type == \"special\") {\n            int choice = rnd.next(0, 3);\n            if (choice == 0) {\n                n = n_min;\n                k = n_min;\n            } else if (choice == 1) {\n                n = n_max;\n                k = n_max;\n            } else if (choice == 2) {\n                n = rnd.next(n_min, n_max);\n                k = n;\n            } else {\n                n = rnd.next(n_min, n_max);\n                k = rnd.next(k_min, min(n, k_max));\n            }\n        } else {\n            // Default to random\n            n = rnd.next(n_min, n_max);\n            k = rnd.next(k_min, min(n, k_max));\n        }\n\n        // Ensure constraints: 1 ≤ k ≤ n ≤ 1000\n        n = max(1, min(1000, n));\n        k = max(1, min(n, k));\n\n        printf(\"%d %d\\n\", n, k);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -n_min 1 -n_max 1 -k_min 1 -k_max 1 -type min\n./gen -t 200000 -n_min 1 -n_max 1 -k_min 1 -k_max 1 -type min\n./gen -t 200000 -n_min 1000 -n_max 1000 -k_min 1000 -k_max 1000 -type max\n./gen -t 100000 -n_min 1 -n_max 1000 -k_min 1 -k_max 1000 -type random\n./gen -t 10 -n_min 1 -n_max 1000 -k_min 1 -k_max 1 -type random\n./gen -t 10 -n_min 1 -n_max 1000 -k_min 1 -k_max 1000 -type special\n./gen -t 10 -n_min 1 -n_max 1000 -k_min 1 -k_max 500 -type special\n./gen -t 1000 -n_min 1 -n_max 1000 -k_min 1 -k_max 1000 -type zero_answer\n./gen -t 1000 -n_min 500 -n_max 500 -k_min 500 -k_max 500 -type special\n./gen -t 50000 -n_min 1 -n_max 1000 -k_min 1 -k_max 1000 -type random\n./gen -t 100000 -n_min 1 -n_max 1 -k_min 1 -k_max 1 -type min\n./gen -t 100000 -n_min 1000 -n_max 1000 -k_min 1 -k_max 1 -type special\n./gen -t 1 -n_min 1000 -n_max 1000 -k_min 1 -k_max 1 -type max\n./gen -t 1 -n_min 1 -n_max 1 -k_min 1 -k_max 1 -type min\n./gen -t 1 -n_min 1000 -n_max 1000 -k_min 1000 -k_max 1000 -type max\n./gen -t 200000 -n_min 1 -n_max 1000 -k_min 1 -k_max 1000 -type random\n./gen -t 200000 -n_min 1 -n_max 1000 -k_min 1 -k_max 1000 -type zero_answer\n./gen -t 50000 -n_min 1 -n_max 1000 -k_min 1 -k_max 1000 -type special\n./gen -t 5000 -n_min 1 -n_max 10 -k_min 1 -k_max 10 -type special\n./gen -t 1000 -n_min 2 -n_max 1000 -k_min 1 -k_max 500 -type special\n./gen -t 2000 -n_min 1 -n_max 100 -k_min 1 -k_max 100 -type zero_answer\n./gen -t 2000 -n_min 1 -n_max 1000 -k_min 1 -k_max 1000 -type max\n./gen -t 10000 -n_min 1 -n_max 1000 -k_min 1 -k_max 1000 -type random\n./gen -t 1000 -n_min 999 -n_max 999 -k_min 999 -k_max 999 -type max\n./gen -t 1000 -n_min 1000 -n_max 1000 -k_min 1 -k_max 1000 -type random\n./gen -t 1000 -n_min 1 -n_max 1000 -k_min 1 -k_max 1 -type random\n./gen -t 1 -n_min 1000 -n_max 1000 -k_min 1 -k_max 1 -type max\n./gen -t 1 -n_min 1 -n_max 1 -k_min 1 -k_max 1 -type min\n./gen -t 1 -n_min 1000 -n_max 1000 -k_min 1000 -k_max 1000 -type max\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:56.175532",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "403/E",
      "title": "E. Two Rooted Trees",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains integer n (2 ≤ n ≤ 2·105) — the number of vertices in each tree.The next line contains n - 1 positive integers a2, a3, ..., an (1 ≤ ai ≤ n; ai ≠ i) — the description of edges of the first tree. Number ai means that the first tree has an edge connecting vertex ai and vertex i.The next line contains n - 1 positive integers b2, b3, ..., bn (1 ≤ bi ≤ n; bi ≠ i) — the description of the edges of the second tree. Number bi means that the second tree has an edge connecting vertex bi and vertex i. The next line contains integer idx (1 ≤ idx < n) — the index of the blue edge that was removed on the first stage. Assume that the edges of each tree are numbered with numbers from 1 to n - 1 in the order in which they are given in the input.",
      "output_spec": "OutputFor each stage of removing edges print its description. Each description must consist of exactly two lines. If this is the stage when blue edges are deleted, then the first line of the description must contain word Blue, otherwise — word Red. In the second line print the indexes of the edges that will be deleted on this stage in the increasing order.",
      "sample_tests": "ExamplesInputCopy51 1 1 14 2 1 13OutputCopyBlue3Red1 3Blue1 2Red2",
      "description": "E. Two Rooted Trees\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (2 ≤ n ≤ 2·105) — the number of vertices in each tree.The next line contains n - 1 positive integers a2, a3, ..., an (1 ≤ ai ≤ n; ai ≠ i) — the description of edges of the first tree. Number ai means that the first tree has an edge connecting vertex ai and vertex i.The next line contains n - 1 positive integers b2, b3, ..., bn (1 ≤ bi ≤ n; bi ≠ i) — the description of the edges of the second tree. Number bi means that the second tree has an edge connecting vertex bi and vertex i. The next line contains integer idx (1 ≤ idx < n) — the index of the blue edge that was removed on the first stage. Assume that the edges of each tree are numbered with numbers from 1 to n - 1 in the order in which they are given in the input.\n\nOutputFor each stage of removing edges print its description. Each description must consist of exactly two lines. If this is the stage when blue edges are deleted, then the first line of the description must contain word Blue, otherwise — word Red. In the second line print the indexes of the edges that will be deleted on this stage in the increasing order.\n\nInputCopy51 1 1 14 2 1 13OutputCopyBlue3Red1 3Blue1 2Red2\n\nInputCopy51 1 1 14 2 1 13\n\nOutputCopyBlue3Red1 3Blue1 2Red2\n\nNoteFor simplicity let's assume that all edges of the root tree received some direction, so that all vertices are reachable from vertex 1. Then a subtree of vertex v is a set of vertices reachable from vertex v in the resulting directed graph (vertex v is also included in the set).",
      "solutions": [
        {
          "title": "Codeforces Round #236 - Codeforces",
          "content": "Soon (on March 16, 19:30 MSK) you are lucky to participate in Codeforces Round #236 for both divisions.Problems have been prepared by me. It’s my first round for both divisions and I hope not last. I want to thank Gerald Agapov (Gerald) for help in preparation of this round, Ilya Los (IlyaLos) and Ignatyev Alexander (aiMR) for testing of problems, Mary Belova(Delinur) for translating the problems, Michael Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems. UPD: Scoring system:Div. 2: 500 — 1000 — 1500 — 2000 — 2500Div. 1: 500 — 1000 — 1500 — 1500 — 2000 UPD:Contest finished, congratulation for winners!Div.2 : vladb iceiceice LoneFox ofpsxx adsz Div. 1: 1 sillycross 2 KADR 2 vepifanov 4 Endagorion 5 glassices 6 cgy4ever 7 rowdark 8 snuke 9 ftiasch 10 fsouza UPD:Editorial. UPD:Round Statistics from DmitriyH.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10959",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 839
        },
        {
          "title": "Editorial Codeforces Round #236 - Codeforces",
          "content": "402A - NutsLet's fix some value of boxes ans. After that we can get exactly cnt = ans + min((k - 1) * ans, B) of sections. So, if cnt * v ≥ a, then ans be an answer. After that you can use brute force to find smallest possible value of ans.402B - Trees in a RowLet's fix height of the first tree: let's call it a. Of course, a is an integer from segment [1, 1000]. After that, for the fixed height a of the first tree we can calculate heights of the others trees: a, a + k, a + 2k, and so on. After that you should find minimal number of operations ans to achive such heights. After that we can use brute force to find smallest possible ans for each a from 1 to 1000. For best height of the first tree you should print all operations.402C - Searching for Graph / 403A - Searching for GraphI will describe two solutions.First. Consider all pairs (i, j) (1 ≤ i < j ≤ n). After you should ouput the first 2n + p pairs in lexicographical order.It's clear to understand, that it is enough to prove, that 0-interesting graph is correct or  - 3 -interesting graph is correct. We will prove for  - 3 -interesting graph, that it is correct. This graph consists of triangles, which have an common edge 1 — 2. Let's fix some subset of vertexes, which does not contains vertexes 1 and 2. In such sets there are no edges. Let's fix some subset, which contains exactly one vertex (1 or 2). In such subsets there are exactly k - 1 edges, where k is the size of such subset. In other subset there are exactly 2 * (k — 2) + 1 edges, where k is the size of such subset.Second. Let's use some brute force, to build graphs with 0-interesting graphs with sizes 5, 6, 7, 8, 9 vertexes. Now, to build p-interesting graph with n vertexes, We will build 0-interesting graph, and after that we will add to it p another edges, which is not in the graph. We will build 0-interesting graphs using the following approach: Let's took k disjointed components, from graphs with number of vertexes from 5 to 9, in such way that there are exactly n vertexes in graph.402D - Upgrading Array / 403B - Upgrading ArrayI will describe two solutions.First. Dynamic programming approach. Let's calculate an DP d[i][j] — which is the best possible answer we can achieve, if current prefix has length i and we used operation of Upgrading last time in position j. It is clear to understand, that we should iterate i from n to 1, and j from n to i. There are only two transitions: First, d[i - 1][j] = max(d[i - 1][j], d[i][j]) — we will not use operation of upgrading of array in the current position. Second, d[i - 1][i - 1] = max(d[i - 1][i - 1], d[i][j] + f(tgcd[j]) * i - f(tgcd[i - 1]) * i — we are using an operation of upgrading. f(a) — is a beauty of the number. tgcd[i] — gcd of all numbers on the prefix of length i. You can use function, which works in to calculate the beauty. Also you can make your solution more faster, it you will precalculate some small primes. Also you can use map < int, int >  to store calculated values. DP base d[n][n] = curBeauty — is a current beauty of the array. Second. Greedy. Let's find position r, which can upgrade our answer. If there some values of r — we will take most right position. We will add this position to the answer and upgrade our answer. Why it's correct? Let's fix an optimal solution (sequence of position, where we used an upgrading operation) r1 > r2 > ... > rk. Also we have an solution which was built by using greedy l1 > l2 > ... > lm. It's clear, that r1 ≤ l1, because all position with  > l1 cannot upgrade anything (otherwise greedy will choose it as first position). In other hand, r1 ≥ l1, because otherwise we can upgrade in position l1 and make answer better. So, r1 = l1, and after that we can use our propositions for big indexes i.402E - Strictly Positive Matrix / 403C - Strictly Positive MatrixLet's look at the matrix a as a connectivity matrix of some graph with n vertices. Moreover, if aij > 0, then we have directed edge in the graph between nodes (i, j). Otherwise, if aij = 0 that graph does not contains directed edge between pair of nodes (i, j). Let b = ak. What does bij means? bij is the number of paths of length exactly k in our graph from vertex i to vertex j. Let pos is an integer, such that a[pos][pos] > 0. That is, we have a loop in the graph. So, if from the vertex pos achievable all other vertexes and vice versa, from all other vertices reachable vertex pos, then the answer is YES, otherwise the answer is NO. If reachability is missing, it is clear that for any k akipos = 0. If reachability there, we will be able to reach self-loop, use self-loop \"to twist\", and after that we will go to some another vertex.403D - Beautiful Pairs of NumbersFirst, we can note, that length of sequence is not greater then 50. Ok, but why? Because all numbers bi - ai are different, so 0 + 1 + ... + 50 > 1000. Let's imagine, that sequence from input is a sequence of non-intersecting segments. So, ci = bi - ai + 1 is length of segment i. Also, . After that let's calculate the following DP: d[i][j][k] — — number of sequences for which following holds: c1 < c2 < ... < ci, ci ≥ 1 , c1 + c2 + ... + ci = j and maximal number is less then k (upper bound of sequence). This DP will helps us to calculate number of ways to set length to each segment in sequence. It's simple to calculate such DP: base d[0][0][1] = 1, d[i][j][k + 1] = d[i][j][k + 1] + d[i][j][k] — we increase upper bound of sequence; d[i + 1][j + k][k + 1] = d[i + 1][j + k][k + 1] + d[i][j][k] — we are adding upper bound to the sequence. We can calculate such DP, by using only O(N2) of memory, where N = 1000. After that we should multiply d[i][j][k] on i!, because we need number of sequences ci, where order does not matter.After that we can calculate answer for n, k. Let's , where x — some upper bound of sequences. After that we should calculate next number: how many ways to set to distances between segments? It's clear, that we can increase distance between some segments, but we have only n - len such operations. It's well known, that answer number of ways equals to C(n - len + k, k). So, for each n we should sum by len following values: sum[len] * C(n - len + k, k).Note, that we need array C[n][k] (binomials) where n ≤ 2000, k ≤ 2000.403E - Two Rooted TreesFirst, for each vertex of the first and second tree we calculate two values in[s], out[s] — the entry time and exit time in dfs order from vertex with number 1. Also with each edge from both trees we will assosiate a pair (p, q), where p = min(in[u], in[v]), q = max(in[u], in[v]) (values in, out for each vertex we take from tree with another color). Now for each tree we will build two segment trees (yes, totally 4 segment trees). In first segment will store all pairs in following way: we will store a pair in node of segment tree if and only if (node of segment tree is a segment (l, r)) left element of pair lies in segment (l, r). In second segment tree we will store a pair if and only if right element of the pair lies in segment (l, r) All pairs in segment trees we will store in some order (in first segment tree — increasing order, in the second tree — decreasing order). Such trees use of memory, also you can build it in .Good. How to answer on query (l, r) — erase all edges from tree for which exactly one vertex have value in[s] in segment (l, r)? We will go down in our segment tree. Let's imagine, that now we in some node of segment tree. Because we store all pairs in the first segment tree in increasing order of the right element, so answer to the query is a some suffix of the array of pairs. After we can add they to the answer (if it not erased yet). After that we should modify our segment tree: for each node, where we work with suffixes, we should erase all pairs from such suffix. So, this solution in .My solution to E: 6052738",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/10972",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 403\\s*E"
          },
          "content_length": 7846
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #236 - Codeforces - Code 1",
          "code": "int cn; cin >> cn;\n\tfor(int ci = 0; ci < cn; ci++) {\n\t\tint n,p; cin >> n >> p;\n\t\tint cnt = 0;\n\t\tfor(int k = 2; k <= n; k++) \n\t\t\tfor(int i = 1; i < k && ( cnt < (2*k + p) ) ; i++)\n\t\t\t\tcout << i << \" \" << k << \"\\n\", ++cnt;\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 2",
          "code": "int cn; cin >> cn;\n\tfor(int ci = 0; ci < cn; ci++) {\n\t\tint n,p; cin >> n >> p;\n\t\tint cnt = 0;\n\t\tfor(int k = 2; k <= n; k++) \n\t\t\tfor(int i = 1; i < k && ( cnt < (2*k + p) ) ; i++)\n\t\t\t\tcout << i << \" \" << k << \"\\n\", ++cnt;\t\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 3",
          "code": "V[j]/=gcd(V[j],Div[i]);\nDiv[j]/=gcd(Div[j],Div[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 4",
          "code": "V[j]/=gcd(V[j],Div[i]);\nDiv[j]/=gcd(Div[j],Div[i]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 5",
          "code": "for(int p : primes) {\n    if (p*p > v) break; // <- add this line\n    int cnt = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #236 - Codeforces - Code 6",
          "code": "for(int p : primes) {\n    if (p*p > v) break; // <- add this line\n    int cnt = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/10959",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200005;\n\nint n;\nvector<int> a, b;\nint idx;\n\nvector<int> adj[MAXN];\nbool visited[MAXN];\n\nvoid dfs(int u, int parent) {\n    visited[u] = true;\n    for(int v : adj[u]) {\n        if(v != parent) {\n            if(visited[v]) {\n                // Found a cycle\n                ensuref(false, \"Tree contains a cycle\");\n            } else {\n                dfs(v, u);\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    // Read a2 to an\n    a = inf.readInts(n - 1, 1, n, \"a\");\n    inf.readEoln();\n\n    // Check that ai != i\n    for(int i = 0; i < n - 1; i++) {\n        int ai = a[i];\n        int node = i + 2;\n        ensuref(ai != node, \"First tree: a[%d]=%d cannot be equal to the node %d itself\", i + 2, ai, node);\n    }\n\n    // Build first tree\n    for(int i = 0; i <= n; i++) adj[i].clear();\n    for(int i = 0; i < n - 1; i++) {\n        int ai = a[i];\n        int node = i + 2;\n        adj[ai].push_back(node);\n        adj[node].push_back(ai);\n    }\n\n    memset(visited, 0, sizeof(visited));\n    dfs(1, -1);\n    for(int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"First tree is not connected\");\n    }\n\n    // Reset adj and visited for the second tree\n    for(int i = 0; i <= n; i++) adj[i].clear();\n    memset(visited, 0, sizeof(visited));\n\n    b = inf.readInts(n - 1, 1, n, \"b\");\n    inf.readEoln();\n\n    // Check that bi != i\n    for(int i = 0; i < n - 1; i++) {\n        int bi = b[i];\n        int node = i + 2;\n        ensuref(bi != node, \"Second tree: b[%d]=%d cannot be equal to the node %d itself\", i + 2, bi, node);\n    }\n\n    // Build second tree\n    for(int i = 0; i < n - 1; i++) {\n        int bi = b[i];\n        int node = i + 2;\n        adj[bi].push_back(node);\n        adj[node].push_back(bi);\n    }\n\n    memset(visited, 0, sizeof(visited));\n    dfs(1, -1);\n    for(int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Second tree is not connected\");\n    }\n\n    idx = inf.readInt(1, n - 1, \"idx\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200005;\n\nint n;\nvector<int> a, b;\nint idx;\n\nvector<int> adj[MAXN];\nbool visited[MAXN];\n\nvoid dfs(int u, int parent) {\n    visited[u] = true;\n    for(int v : adj[u]) {\n        if(v != parent) {\n            if(visited[v]) {\n                // Found a cycle\n                ensuref(false, \"Tree contains a cycle\");\n            } else {\n                dfs(v, u);\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    // Read a2 to an\n    a = inf.readInts(n - 1, 1, n, \"a\");\n    inf.readEoln();\n\n    // Check that ai != i\n    for(int i = 0; i < n - 1; i++) {\n        int ai = a[i];\n        int node = i + 2;\n        ensuref(ai != node, \"First tree: a[%d]=%d cannot be equal to the node %d itself\", i + 2, ai, node);\n    }\n\n    // Build first tree\n    for(int i = 0; i <= n; i++) adj[i].clear();\n    for(int i = 0; i < n - 1; i++) {\n        int ai = a[i];\n        int node = i + 2;\n        adj[ai].push_back(node);\n        adj[node].push_back(ai);\n    }\n\n    memset(visited, 0, sizeof(visited));\n    dfs(1, -1);\n    for(int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"First tree is not connected\");\n    }\n\n    // Reset adj and visited for the second tree\n    for(int i = 0; i <= n; i++) adj[i].clear();\n    memset(visited, 0, sizeof(visited));\n\n    b = inf.readInts(n - 1, 1, n, \"b\");\n    inf.readEoln();\n\n    // Check that bi != i\n    for(int i = 0; i < n - 1; i++) {\n        int bi = b[i];\n        int node = i + 2;\n        ensuref(bi != node, \"Second tree: b[%d]=%d cannot be equal to the node %d itself\", i + 2, bi, node);\n    }\n\n    // Build second tree\n    for(int i = 0; i < n - 1; i++) {\n        int bi = b[i];\n        int node = i + 2;\n        adj[bi].push_back(node);\n        adj[node].push_back(bi);\n    }\n\n    memset(visited, 0, sizeof(visited));\n    dfs(1, -1);\n    for(int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Second tree is not connected\");\n    }\n\n    idx = inf.readInt(1, n - 1, \"idx\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200005;\n\nint n;\nvector<int> a, b;\nint idx;\n\nvector<int> adj[MAXN];\nbool visited[MAXN];\n\nvoid dfs(int u, int parent) {\n    visited[u] = true;\n    for(int v : adj[u]) {\n        if(v != parent) {\n            if(visited[v]) {\n                // Found a cycle\n                ensuref(false, \"Tree contains a cycle\");\n            } else {\n                dfs(v, u);\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    // Read a2 to an\n    a = inf.readInts(n - 1, 1, n, \"a\");\n    inf.readEoln();\n\n    // Check that ai != i\n    for(int i = 0; i < n - 1; i++) {\n        int ai = a[i];\n        int node = i + 2;\n        ensuref(ai != node, \"First tree: a[%d]=%d cannot be equal to the node %d itself\", i + 2, ai, node);\n    }\n\n    // Build first tree\n    for(int i = 0; i <= n; i++) adj[i].clear();\n    for(int i = 0; i < n - 1; i++) {\n        int ai = a[i];\n        int node = i + 2;\n        adj[ai].push_back(node);\n        adj[node].push_back(ai);\n    }\n\n    memset(visited, 0, sizeof(visited));\n    dfs(1, -1);\n    for(int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"First tree is not connected\");\n    }\n\n    // Reset adj and visited for the second tree\n    for(int i = 0; i <= n; i++) adj[i].clear();\n    memset(visited, 0, sizeof(visited));\n\n    b = inf.readInts(n - 1, 1, n, \"b\");\n    inf.readEoln();\n\n    // Check that bi != i\n    for(int i = 0; i < n - 1; i++) {\n        int bi = b[i];\n        int node = i + 2;\n        ensuref(bi != node, \"Second tree: b[%d]=%d cannot be equal to the node %d itself\", i + 2, bi, node);\n    }\n\n    // Build second tree\n    for(int i = 0; i < n - 1; i++) {\n        int bi = b[i];\n        int node = i + 2;\n        adj[bi].push_back(node);\n        adj[node].push_back(bi);\n    }\n\n    memset(visited, 0, sizeof(visited));\n    dfs(1, -1);\n    for(int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Second tree is not connected\");\n    }\n\n    idx = inf.readInt(1, n - 1, \"idx\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_tree(vector<int>& parent, string type, int n) {\n    if (type == \"chain\") {\n        // Each node connected to the previous node (max depth)\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n        }\n    } else if (type == \"star\") {\n        // All nodes connected directly to the root (min depth)\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n        }\n    } else if (type == \"binary\") {\n        // Complete binary tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i / 2;\n        }\n    } else if (type == \"skewed\") {\n        // Skewed tree to one side\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = max(1, i - rnd.next(1, min(5, i - 1)));\n        }\n    } else {\n        // Default is random tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string t1 = opt<string>(\"t1\", \"random\");\n    string t2 = opt<string>(\"t2\", \"random\");\n    int idx = opt<int>(\"idx\", -1);\n\n    vector<int> a(n + 1); // parent of node i in the first tree\n    vector<int> b(n + 1); // parent of node i in the second tree\n\n    if (t1 == \"identical\") {\n        // Generate one tree and use it for both a and b\n        generate_tree(a, t2, n);\n        copy(a.begin(), a.end(), b.begin());\n    } else {\n        generate_tree(a, t1, n);\n        generate_tree(b, t2, n);\n    }\n\n    // Decide idx (edge index to remove)\n    // The edges are from 1 to n - 1, in the order of a[2], a[3], ..., a[n]\n\n    // If idx is not specified, choose idx randomly between 1 and n - 1\n    if (idx == -1) {\n        idx = rnd.next(1, n - 1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output edges of first tree\n    for(int i = 2; i <= n; ++i) {\n        printf(\"%d%c\", a[i], i == n ? '\\n' : ' ');\n    }\n\n    // Output edges of second tree\n    for(int i = 2; i <= n; ++i) {\n        printf(\"%d%c\", b[i], i == n ? '\\n' : ' ');\n    }\n\n    // Output idx\n    printf(\"%d\\n\", idx);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_tree(vector<int>& parent, string type, int n) {\n    if (type == \"chain\") {\n        // Each node connected to the previous node (max depth)\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n        }\n    } else if (type == \"star\") {\n        // All nodes connected directly to the root (min depth)\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n        }\n    } else if (type == \"binary\") {\n        // Complete binary tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i / 2;\n        }\n    } else if (type == \"skewed\") {\n        // Skewed tree to one side\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = max(1, i - rnd.next(1, min(5, i - 1)));\n        }\n    } else {\n        // Default is random tree\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string t1 = opt<string>(\"t1\", \"random\");\n    string t2 = opt<string>(\"t2\", \"random\");\n    int idx = opt<int>(\"idx\", -1);\n\n    vector<int> a(n + 1); // parent of node i in the first tree\n    vector<int> b(n + 1); // parent of node i in the second tree\n\n    if (t1 == \"identical\") {\n        // Generate one tree and use it for both a and b\n        generate_tree(a, t2, n);\n        copy(a.begin(), a.end(), b.begin());\n    } else {\n        generate_tree(a, t1, n);\n        generate_tree(b, t2, n);\n    }\n\n    // Decide idx (edge index to remove)\n    // The edges are from 1 to n - 1, in the order of a[2], a[3], ..., a[n]\n\n    // If idx is not specified, choose idx randomly between 1 and n - 1\n    if (idx == -1) {\n        idx = rnd.next(1, n - 1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output edges of first tree\n    for(int i = 2; i <= n; ++i) {\n        printf(\"%d%c\", a[i], i == n ? '\\n' : ' ');\n    }\n\n    // Output edges of second tree\n    for(int i = 2; i <= n; ++i) {\n        printf(\"%d%c\", b[i], i == n ? '\\n' : ' ');\n    }\n\n    // Output idx\n    printf(\"%d\\n\", idx);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -t1 chain -t2 chain -idx 1\n./gen -n 2 -t1 star -t2 star\n\n./gen -n 5 -t1 chain -t2 star\n./gen -n 5 -t1 star -t2 chain\n./gen -n 5 -t1 random -t2 random\n\n./gen -n 10 -t1 chain -t2 chain\n./gen -n 10 -t1 star -t2 star\n./gen -n 10 -t1 random -t2 random\n./gen -n 10 -t1 identical -t2 chain\n./gen -n 10 -t1 identical -t2 random\n\n./gen -n 100 -t1 chain -t2 star\n./gen -n 100 -t1 star -t2 chain\n./gen -n 100 -t1 random -t2 random\n\n./gen -n 1000 -t1 chain -t2 random\n./gen -n 1000 -t1 random -t2 chain\n./gen -n 1000 -t1 random -t2 random\n\n./gen -n 10000 -t1 chain -t2 chain\n./gen -n 10000 -t1 star -t2 star\n./gen -n 10000 -t1 random -t2 random\n\n./gen -n 100000 -t1 chain -t2 star\n./gen -n 100000 -t1 star -t2 chain\n./gen -n 100000 -t1 random -t2 random\n\n./gen -n 200000 -t1 random -t2 random\n\n# Edge cases\n./gen -n 2 -t1 chain -t2 chain -idx 1\n./gen -n 2 -t1 star -t2 star -idx 1\n\n./gen -n 10 -t1 identical -t2 random\n\n# Specific idx values\n./gen -n 1000 -t1 random -t2 random -idx 1\n./gen -n 1000 -t1 random -t2 random -idx 999\n\n# Max n value\n./gen -n 200000 -t1 chain -t2 chain -idx 1\n./gen -n 200000 -t1 star -t2 star\n\n# Skewed tree\n./gen -n 100000 -t1 skewed -t2 skewed\n\n# Binary trees\n./gen -n 100000 -t1 binary -t2 binary\n\n# Both trees the same\n./gen -n 100000 -t1 identical -t2 binary\n\n# Random trees\n./gen -n 200000 -t1 random -t2 random\n\n# Max n and random idx\n./gen -n 200000 -t1 random -t2 random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:22:58.719941",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "404/A",
      "title": "A. Valera and X",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (3 ≤ n < 300; n is odd). Each of the next n lines contains n small English letters — the description of Valera's paper.",
      "output_spec": "OutputPrint string \"YES\", if the letters on the paper form letter \"X\". Otherwise, print string \"NO\". Print the strings without quotes.",
      "sample_tests": "ExamplesInputCopy5xoooxoxoxosoxoooxoxoxoooxOutputCopyNOInputCopy3wswswswswOutputCopyYESInputCopy3xpxpxpxpeOutputCopyNO",
      "description": "A. Valera and X\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (3 ≤ n < 300; n is odd). Each of the next n lines contains n small English letters — the description of Valera's paper.\n\nOutputPrint string \"YES\", if the letters on the paper form letter \"X\". Otherwise, print string \"NO\". Print the strings without quotes.\n\nInputCopy5xoooxoxoxosoxoooxoxoxoooxOutputCopyNOInputCopy3wswswswswOutputCopyYESInputCopy3xpxpxpxpeOutputCopyNO\n\nInputCopy5xoooxoxoxosoxoooxoxoxooox\n\nOutputCopyNO\n\nInputCopy3wswswswsw\n\nOutputCopyYES\n\nInputCopy3xpxpxpxpe\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces",
          "content": "Hi to all!)Regular round Codeforces #237 for participants from 2 division will take place tomorrow March 19, 19:30 MSK. Traditional, participants from 1 division can take part out of the competition.The problems were prepared by Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Also thanks to Michael Mirzayanov (MikeMirzayanov) for very cool system Codeforces and Mary Belova (Delinur) for translating the problems into english.We wish everyone good luck, high rating and excellent mood)UPD: Score distribution will be standard 500 — 1000 — 1500 — 2000 — 2500.UPD 2: The contest is over, thanks to all participants.Congratulations to the winners: Pkqs09 juggler zstu_bobo kevinswat Salvare004 UPD3: You can find the tutorial here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11039",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 743
        },
        {
          "title": "Codeforces Round #237 (Div. 2) Editorial - Codeforces",
          "content": "404A - Valera and XIn this problem it was needed to check the constraints described in statement. You can use two sets here. You should insert diagonal elements of matrix into the first set, and the other elements into the second. Element ai, j belongs to the main diagonal if i = j and belongs to the secondary diagonal if i = n - j + 1. After you split all elements into sets you should check if the sets sizes are equal to one and the elements from this sets differ from each other.404B - MarathonLet's notice that after Valera run 4·a meters he will be in the same point from which he started. Valera will have run i·d meters before he gets i-th bottle of drink. Let's calculate the value — how many laps he will run. Then he have already run L = i·d - c·4·a meters on his last lap. It is easy to get Valera's position from this L. For example, if 2·a ≤ L ≤ 3·a then Valera will be in the point with coordinates (3·a - L, a). You can consider the other three cases in the same manner.404C - Restore GraphFirst of all let us notice that it must be only one 0 in d. Also d[start] = 0 means that start is the vertex from which Valera calculated the distance to the other vertices. Let's notice that every vertex u with d[u] = i must be adjacent only to the vertices v such that d[v] ≥ i - 1. Besides there is always must be such neighboor v0 of u, that d[v0] = i - 1. Let's build sought graph by adding one vertex to the existing graph. We will add vertex in order of increasing their distance to start. Initially, we have one vertex with number start in our graph. When we add vertex u with d[u] = i let's consider such vertices v that d[v] = i - 1. Let's choose the vertex with minimal degree among them. If this value is equal to k, then there is no solution. In other case let's add u to our graph and add the edge (u, v) to the answer. If there are no vertices with distance i - 1 to start then the answer is also  - 1. If everything fine we will get the answer which is tree, so the number of edges in it equals n - 1 ≤ 106.404D - Minesweeper 1DThis problem can be solved by using dynamic programming. Let's calculate d[i][type] — the number of correct ways to fill the prefix of length i so that the last filled cell has one of the 5 types. These types are the following: the cell contains \"0\" the cell contains \"1\" and the cell to the left of it contains bomb the cell contains \"1\" and the cell to the left of it doesn't contain bomb the cell contains \"2\" the cell contains bomb When we try to fill next cell we check two conditions. Firstly value of the filled cell in given string must be equal to either what we want to write or \"?\". Secondly new prefix must remain filled correct. For example, if we are in state (i, 1) (it means that the cell i contains \"0\") then we can fill next cell by \"0\" and go to the state (i + 1, 1) or fill next cell by \"1\" and go to the state (i + 1, 3). We cannot write \"2\" because both neighbours of the cell with \"2\" must contain bomb. Obvious, we cannot place bomb after \"0\". Note that, when we place \"1\" after \"0\" we go to the state (i + 1, 3), but when we place \"1\" after bomb we go to the state (i + 1, 2). You can consider other ways of going from one state to another in the same manner.404E - Maze 1DLet's consider the case when the last move of the robot is equal to \"R\". If the last move is equal to \"L\" then we can replace all \"L\" by \"R\" and vise versa and the answer doesn't change. Let's show that Valera doesn't need more than one obstacle. Suppose Valera placed obstacles somewhere. We will say that the number of obstacle is the number of cell containing it. Let's consider the rightmost obstacle obs1 among the obstacles with negative numbers and the leftmost obstacle obs2 among the obstacles with positive numbers. Obvious robot cannot go to the left of obs1 and to the right of obs2. So the needed number of obstacles is not greater than two. Let's show that Valera doesn't need to place obstacles to the cells with numbers greater than zero. Suppose he place obstacle to the cell with number a > 0. If robot doesn't try to go to this cell then its obstacle is out of place. If robot try to go to this cell then it will visit finish cell more than once. It is because robot needs to go to the right on its last move, but it can't do it from cell a - 1 and it has already visited all cells to the left of a. So Valera doesn't need more than one obstacle and its obstacle must have number less than zero.Let's now check if Valera can do without obstacles. If so the robot won't skip moves and will stop in some cell. Than Valera can choose this cell as finish and the answer will be one. We have to consider only one case when Valera must place one obstacle.Firstly let's notice that if Valera place obstacle to some cell, the finish cell can be restored uniquely. It means that the number of ways to choose where to place obstacles and finish cell is equal to the number of ways to choose one cell to place one obstacle. Suppose Valera placed obstacle in the cell with number b < 0 and robot completed its instructions successfully. Notice, that in that case robot skipped some moves of type \"L\", completed all moves of type \"R\" and went to the right on its last move to the unvisited cell. If we shift Valera's obstacle to the right on one cell then robot is going to skip not less moves of type \"L\" than in the previous case. It means that the finish cell can either go to the right or remains the same. But last time robot visited this cell on its last move, so it is going to visit a new finish cell on its last move either. This means that there is such cell p < 0 that if Valera place obstacle to the cells c ≥ p then robot will be able to complete its instructions successfully, but if Valera place obstacle to the cells d < p then robot will not. This cell p can be found by using binary search and simple simulation on each iteration. Time complexity is O(n log n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11095",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 404\\s*A"
          },
          "content_length": 5935
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 3",
          "code": "a and d (1 ≤ a, d ≤ 100000), given with precision till 4 decimal digits after the decimal point.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 4",
          "code": "#define SC 10000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 5",
          "code": "cout<<\"*\"<<dd<<endl;\ncout<<\"**\"<<dd*SC<<endl;\ncout<<\"***\"<<(int)(dd*SC)<<endl;\ncout<<\"****\"<<d<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 6",
          "code": "cout<<\"*\"<<dd<<endl;\ncout<<\"**\"<<dd*SC<<endl;\ncout<<\"***\"<<(int)(dd*SC)<<endl;\ncout<<\"****\"<<d<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 7",
          "code": "*2.8819\n**28819\n***28819\n****28819",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 8",
          "code": "*2.8819\n**28819\n***28819\n****28819",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 9",
          "code": "*2.8819\n**28819\n***28818\n****28818",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 10",
          "code": "*2.8819\n**28819\n***28818\n****28818",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 11",
          "code": "printf(\"%.6lf\\n\",2.8819*10000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 299, \"n\");\n    ensuref(n % 2 == 1, \"n must be odd, but n=%d\", n);\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(n) + \"}\";\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(pattern, \"line\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 299, \"n\");\n    ensuref(n % 2 == 1, \"n must be odd, but n=%d\", n);\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(n) + \"}\";\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(pattern, \"line\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 299, \"n\");\n    ensuref(n % 2 == 1, \"n must be odd, but n=%d\", n);\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(n) + \"}\";\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(pattern, \"line\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"yes\");\n\n    ensure(n >= 3 && n < 300 && n % 2 == 1);\n\n    vector<string> grid(n, string(n, 'a'));\n\n    if (type == \"yes\") {\n        /* Generate a valid 'X' pattern that should produce \"YES\" */\n        char diag = rnd.next('a', 'z');\n        char off_diag;\n        do {\n            off_diag = rnd.next('a', 'z');\n        } while (off_diag == diag);\n\n        for (int i = 0; i < n; ++i) {\n            grid[i][i] = diag;\n            grid[i][n - i - 1] = diag;\n        }\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0 ; j < n; ++j)\n                if (i != j && i != n - j - 1)\n                    grid[i][j] = off_diag;\n\n    } else if (type == \"no1\") {\n        /* Letters on the diagonals are not all the same */\n        char diag1 = rnd.next('a', 'z');\n        char diag2;\n        do {\n            diag2 = rnd.next('a', 'z');\n        } while (diag2 == diag1);\n\n        char off_diag;\n        do {\n            off_diag = rnd.next('a', 'z');\n        } while (off_diag == diag1 || off_diag == diag2);\n\n        for (int i = 0; i < n; ++i) {\n            grid[i][i] = diag1;\n            grid[i][n - i - 1] = diag2;\n        }\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0 ; j < n; ++j)\n                if (i != j && i != n - j - 1)\n                    grid[i][j] = off_diag;\n\n    } else if (type == \"no2\") {\n        /* Letters outside the diagonals are not all the same */\n        char diag = rnd.next('a', 'z');\n        char off_diag1;\n        do {\n            off_diag1 = rnd.next('a', 'z');\n        } while (off_diag1 == diag);\n\n        char off_diag2;\n        do {\n            off_diag2 = rnd.next('a', 'z');\n        } while (off_diag2 == diag || off_diag2 == off_diag1);\n\n        for (int i = 0; i < n; ++i) {\n            grid[i][i] = diag;\n            grid[i][n - i - 1] = diag;\n        }\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0 ; j < n; ++j)\n                if (i != j && i != n - j - 1)\n                    grid[i][j] = off_diag1;\n\n        /* Change one off-diagonal character */\n        int x, y;\n        do {\n            x = rnd.next(0, n - 1);\n            y = rnd.next(0, n - 1);\n        } while (x == y || x == n - y - 1);\n\n        grid[x][y] = off_diag2;\n\n    } else if (type == \"no3\") {\n        /* The letters on the diagonals are the same as the letters outside the diagonals */\n        char c = rnd.next('a', 'z');\n\n        for (int i = 0; i < n; ++i) {\n            grid[i][i] = c;\n            grid[i][n - i - 1] = c;\n        }\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0 ; j < n; ++j)\n                if (i != j && i != n - j - 1)\n                    grid[i][j] = c;\n\n    } else if (type == \"no4\") {\n        /* Edge case: minimal change to a valid 'X' to make it invalid */\n        char diag = rnd.next('a', 'z');\n        char off_diag;\n        do {\n            off_diag = rnd.next('a', 'z');\n        } while (off_diag == diag);\n\n        for (int i = 0; i < n; ++i) {\n            grid[i][i] = diag;\n            grid[i][n - i - 1] = diag;\n        }\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0 ; j < n; ++j)\n                if (i != j && i != n - j - 1)\n                    grid[i][j] = off_diag;\n\n        /* Make a central diagonal element incorrect */\n        grid[n / 2][n / 2] = off_diag;\n\n    } else if (type == \"random\") {\n        /* Generate a random grid */\n        for (int i = 0; i < n; ++i)\n            for (int j = 0 ; j < n; ++j)\n                grid[i][j] = rnd.next('a', 'z');\n\n    } else {\n        /* Unknown type */\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output the grid */\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"yes\");\n\n    ensure(n >= 3 && n < 300 && n % 2 == 1);\n\n    vector<string> grid(n, string(n, 'a'));\n\n    if (type == \"yes\") {\n        /* Generate a valid 'X' pattern that should produce \"YES\" */\n        char diag = rnd.next('a', 'z');\n        char off_diag;\n        do {\n            off_diag = rnd.next('a', 'z');\n        } while (off_diag == diag);\n\n        for (int i = 0; i < n; ++i) {\n            grid[i][i] = diag;\n            grid[i][n - i - 1] = diag;\n        }\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0 ; j < n; ++j)\n                if (i != j && i != n - j - 1)\n                    grid[i][j] = off_diag;\n\n    } else if (type == \"no1\") {\n        /* Letters on the diagonals are not all the same */\n        char diag1 = rnd.next('a', 'z');\n        char diag2;\n        do {\n            diag2 = rnd.next('a', 'z');\n        } while (diag2 == diag1);\n\n        char off_diag;\n        do {\n            off_diag = rnd.next('a', 'z');\n        } while (off_diag == diag1 || off_diag == diag2);\n\n        for (int i = 0; i < n; ++i) {\n            grid[i][i] = diag1;\n            grid[i][n - i - 1] = diag2;\n        }\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0 ; j < n; ++j)\n                if (i != j && i != n - j - 1)\n                    grid[i][j] = off_diag;\n\n    } else if (type == \"no2\") {\n        /* Letters outside the diagonals are not all the same */\n        char diag = rnd.next('a', 'z');\n        char off_diag1;\n        do {\n            off_diag1 = rnd.next('a', 'z');\n        } while (off_diag1 == diag);\n\n        char off_diag2;\n        do {\n            off_diag2 = rnd.next('a', 'z');\n        } while (off_diag2 == diag || off_diag2 == off_diag1);\n\n        for (int i = 0; i < n; ++i) {\n            grid[i][i] = diag;\n            grid[i][n - i - 1] = diag;\n        }\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0 ; j < n; ++j)\n                if (i != j && i != n - j - 1)\n                    grid[i][j] = off_diag1;\n\n        /* Change one off-diagonal character */\n        int x, y;\n        do {\n            x = rnd.next(0, n - 1);\n            y = rnd.next(0, n - 1);\n        } while (x == y || x == n - y - 1);\n\n        grid[x][y] = off_diag2;\n\n    } else if (type == \"no3\") {\n        /* The letters on the diagonals are the same as the letters outside the diagonals */\n        char c = rnd.next('a', 'z');\n\n        for (int i = 0; i < n; ++i) {\n            grid[i][i] = c;\n            grid[i][n - i - 1] = c;\n        }\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0 ; j < n; ++j)\n                if (i != j && i != n - j - 1)\n                    grid[i][j] = c;\n\n    } else if (type == \"no4\") {\n        /* Edge case: minimal change to a valid 'X' to make it invalid */\n        char diag = rnd.next('a', 'z');\n        char off_diag;\n        do {\n            off_diag = rnd.next('a', 'z');\n        } while (off_diag == diag);\n\n        for (int i = 0; i < n; ++i) {\n            grid[i][i] = diag;\n            grid[i][n - i - 1] = diag;\n        }\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0 ; j < n; ++j)\n                if (i != j && i != n - j - 1)\n                    grid[i][j] = off_diag;\n\n        /* Make a central diagonal element incorrect */\n        grid[n / 2][n / 2] = off_diag;\n\n    } else if (type == \"random\") {\n        /* Generate a random grid */\n        for (int i = 0; i < n; ++i)\n            for (int j = 0 ; j < n; ++j)\n                grid[i][j] = rnd.next('a', 'z');\n\n    } else {\n        /* Unknown type */\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n    /* Output the grid */\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type yes\n./gen -n 5 -type yes\n./gen -n 7 -type yes\n./gen -n 13 -type yes\n./gen -n 21 -type yes\n./gen -n 51 -type yes\n./gen -n 101 -type yes\n./gen -n 151 -type yes\n./gen -n 201 -type yes\n./gen -n 299 -type yes\n\n./gen -n 3 -type no1\n./gen -n 5 -type no1\n./gen -n 11 -type no1\n./gen -n 99 -type no1\n./gen -n 299 -type no1\n\n./gen -n 3 -type no2\n./gen -n 7 -type no2\n./gen -n 13 -type no2\n./gen -n 77 -type no2\n./gen -n 299 -type no2\n\n./gen -n 3 -type no3\n./gen -n 9 -type no3\n./gen -n 15 -type no3\n./gen -n 129 -type no3\n./gen -n 299 -type no3\n\n./gen -n 3 -type no4\n\n./gen -n 3 -type random\n./gen -n 5 -type random\n./gen -n 7 -type random\n./gen -n 13 -type random\n./gen -n 51 -type random\n./gen -n 101 -type random\n./gen -n 299 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:00.845496",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "404/B",
      "title": "B. Marathon",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated real numbers a and d (1 ≤ a, d ≤ 105), given with precision till 4 decimal digits after the decimal point. Number a denotes the length of the square's side that describes the stadium. Number d shows that after each d meters Valera gets an extra drink.The second line contains integer n (1 ≤ n ≤ 105) showing that Valera needs an extra drink n times.",
      "output_spec": "OutputPrint n lines, each line should contain two real numbers xi and yi, separated by a space. Numbers xi and yi in the i-th line mean that Valera is at point with coordinates (xi, yi) after he covers i·d meters. Your solution will be considered correct if the absolute or relative error doesn't exceed 10 - 4.Note, that this problem have huge amount of output data. Please, do not use cout stream for output in this problem.",
      "sample_tests": "ExamplesInputCopy2 52OutputCopy1.0000000000 2.00000000002.0000000000 0.0000000000InputCopy4.147 2.88196OutputCopy2.8819000000 0.00000000004.1470000000 1.61680000003.7953000000 4.14700000000.9134000000 4.14700000000.0000000000 2.17850000000.7034000000 0.0000000000",
      "description": "B. Marathon\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated real numbers a and d (1 ≤ a, d ≤ 105), given with precision till 4 decimal digits after the decimal point. Number a denotes the length of the square's side that describes the stadium. Number d shows that after each d meters Valera gets an extra drink.The second line contains integer n (1 ≤ n ≤ 105) showing that Valera needs an extra drink n times.\n\nOutputPrint n lines, each line should contain two real numbers xi and yi, separated by a space. Numbers xi and yi in the i-th line mean that Valera is at point with coordinates (xi, yi) after he covers i·d meters. Your solution will be considered correct if the absolute or relative error doesn't exceed 10 - 4.Note, that this problem have huge amount of output data. Please, do not use cout stream for output in this problem.\n\nInputCopy2 52OutputCopy1.0000000000 2.00000000002.0000000000 0.0000000000InputCopy4.147 2.88196OutputCopy2.8819000000 0.00000000004.1470000000 1.61680000003.7953000000 4.14700000000.9134000000 4.14700000000.0000000000 2.17850000000.7034000000 0.0000000000\n\nInputCopy2 52\n\nOutputCopy1.0000000000 2.00000000002.0000000000 0.0000000000\n\nInputCopy4.147 2.88196\n\nOutputCopy2.8819000000 0.00000000004.1470000000 1.61680000003.7953000000 4.14700000000.9134000000 4.14700000000.0000000000 2.17850000000.7034000000 0.0000000000",
      "solutions": [
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces",
          "content": "Hi to all!)Regular round Codeforces #237 for participants from 2 division will take place tomorrow March 19, 19:30 MSK. Traditional, participants from 1 division can take part out of the competition.The problems were prepared by Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Also thanks to Michael Mirzayanov (MikeMirzayanov) for very cool system Codeforces and Mary Belova (Delinur) for translating the problems into english.We wish everyone good luck, high rating and excellent mood)UPD: Score distribution will be standard 500 — 1000 — 1500 — 2000 — 2500.UPD 2: The contest is over, thanks to all participants.Congratulations to the winners: Pkqs09 juggler zstu_bobo kevinswat Salvare004 UPD3: You can find the tutorial here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11039",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 743
        },
        {
          "title": "Codeforces Round #237 (Div. 2) Editorial - Codeforces",
          "content": "404A - Valera and XIn this problem it was needed to check the constraints described in statement. You can use two sets here. You should insert diagonal elements of matrix into the first set, and the other elements into the second. Element ai, j belongs to the main diagonal if i = j and belongs to the secondary diagonal if i = n - j + 1. After you split all elements into sets you should check if the sets sizes are equal to one and the elements from this sets differ from each other.404B - MarathonLet's notice that after Valera run 4·a meters he will be in the same point from which he started. Valera will have run i·d meters before he gets i-th bottle of drink. Let's calculate the value — how many laps he will run. Then he have already run L = i·d - c·4·a meters on his last lap. It is easy to get Valera's position from this L. For example, if 2·a ≤ L ≤ 3·a then Valera will be in the point with coordinates (3·a - L, a). You can consider the other three cases in the same manner.404C - Restore GraphFirst of all let us notice that it must be only one 0 in d. Also d[start] = 0 means that start is the vertex from which Valera calculated the distance to the other vertices. Let's notice that every vertex u with d[u] = i must be adjacent only to the vertices v such that d[v] ≥ i - 1. Besides there is always must be such neighboor v0 of u, that d[v0] = i - 1. Let's build sought graph by adding one vertex to the existing graph. We will add vertex in order of increasing their distance to start. Initially, we have one vertex with number start in our graph. When we add vertex u with d[u] = i let's consider such vertices v that d[v] = i - 1. Let's choose the vertex with minimal degree among them. If this value is equal to k, then there is no solution. In other case let's add u to our graph and add the edge (u, v) to the answer. If there are no vertices with distance i - 1 to start then the answer is also  - 1. If everything fine we will get the answer which is tree, so the number of edges in it equals n - 1 ≤ 106.404D - Minesweeper 1DThis problem can be solved by using dynamic programming. Let's calculate d[i][type] — the number of correct ways to fill the prefix of length i so that the last filled cell has one of the 5 types. These types are the following: the cell contains \"0\" the cell contains \"1\" and the cell to the left of it contains bomb the cell contains \"1\" and the cell to the left of it doesn't contain bomb the cell contains \"2\" the cell contains bomb When we try to fill next cell we check two conditions. Firstly value of the filled cell in given string must be equal to either what we want to write or \"?\". Secondly new prefix must remain filled correct. For example, if we are in state (i, 1) (it means that the cell i contains \"0\") then we can fill next cell by \"0\" and go to the state (i + 1, 1) or fill next cell by \"1\" and go to the state (i + 1, 3). We cannot write \"2\" because both neighbours of the cell with \"2\" must contain bomb. Obvious, we cannot place bomb after \"0\". Note that, when we place \"1\" after \"0\" we go to the state (i + 1, 3), but when we place \"1\" after bomb we go to the state (i + 1, 2). You can consider other ways of going from one state to another in the same manner.404E - Maze 1DLet's consider the case when the last move of the robot is equal to \"R\". If the last move is equal to \"L\" then we can replace all \"L\" by \"R\" and vise versa and the answer doesn't change. Let's show that Valera doesn't need more than one obstacle. Suppose Valera placed obstacles somewhere. We will say that the number of obstacle is the number of cell containing it. Let's consider the rightmost obstacle obs1 among the obstacles with negative numbers and the leftmost obstacle obs2 among the obstacles with positive numbers. Obvious robot cannot go to the left of obs1 and to the right of obs2. So the needed number of obstacles is not greater than two. Let's show that Valera doesn't need to place obstacles to the cells with numbers greater than zero. Suppose he place obstacle to the cell with number a > 0. If robot doesn't try to go to this cell then its obstacle is out of place. If robot try to go to this cell then it will visit finish cell more than once. It is because robot needs to go to the right on its last move, but it can't do it from cell a - 1 and it has already visited all cells to the left of a. So Valera doesn't need more than one obstacle and its obstacle must have number less than zero.Let's now check if Valera can do without obstacles. If so the robot won't skip moves and will stop in some cell. Than Valera can choose this cell as finish and the answer will be one. We have to consider only one case when Valera must place one obstacle.Firstly let's notice that if Valera place obstacle to some cell, the finish cell can be restored uniquely. It means that the number of ways to choose where to place obstacles and finish cell is equal to the number of ways to choose one cell to place one obstacle. Suppose Valera placed obstacle in the cell with number b < 0 and robot completed its instructions successfully. Notice, that in that case robot skipped some moves of type \"L\", completed all moves of type \"R\" and went to the right on its last move to the unvisited cell. If we shift Valera's obstacle to the right on one cell then robot is going to skip not less moves of type \"L\" than in the previous case. It means that the finish cell can either go to the right or remains the same. But last time robot visited this cell on its last move, so it is going to visit a new finish cell on its last move either. This means that there is such cell p < 0 that if Valera place obstacle to the cells c ≥ p then robot will be able to complete its instructions successfully, but if Valera place obstacle to the cells d < p then robot will not. This cell p can be found by using binary search and simple simulation on each iteration. Time complexity is O(n log n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11095",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 404\\s*B"
          },
          "content_length": 5935
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 3",
          "code": "a and d (1 ≤ a, d ≤ 100000), given with precision till 4 decimal digits after the decimal point.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 4",
          "code": "#define SC 10000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 5",
          "code": "cout<<\"*\"<<dd<<endl;\ncout<<\"**\"<<dd*SC<<endl;\ncout<<\"***\"<<(int)(dd*SC)<<endl;\ncout<<\"****\"<<d<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 6",
          "code": "cout<<\"*\"<<dd<<endl;\ncout<<\"**\"<<dd*SC<<endl;\ncout<<\"***\"<<(int)(dd*SC)<<endl;\ncout<<\"****\"<<d<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 7",
          "code": "*2.8819\n**28819\n***28819\n****28819",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 8",
          "code": "*2.8819\n**28819\n***28819\n****28819",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 9",
          "code": "*2.8819\n**28819\n***28818\n****28818",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 10",
          "code": "*2.8819\n**28819\n***28818\n****28818",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 11",
          "code": "printf(\"%.6lf\\n\",2.8819*10000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string numPattern = \"([1-9][0-9]{0,4}|100000)(\\\\.[0-9]{1,4})?\";\n\n    string a_str = inf.readToken(numPattern, \"a\");\n    inf.readSpace();\n    string d_str = inf.readToken(numPattern, \"d\");\n    inf.readEoln();\n\n    double a = atof(a_str.c_str());\n    ensuref(a >= 1.0 && a <= 1e5, \"a is out of bounds: a=%0.10lf\", a);\n\n    double d = atof(d_str.c_str());\n    ensuref(d >= 1.0 && d <= 1e5, \"d is out of bounds: d=%0.10lf\", d);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string numPattern = \"([1-9][0-9]{0,4}|100000)(\\\\.[0-9]{1,4})?\";\n\n    string a_str = inf.readToken(numPattern, \"a\");\n    inf.readSpace();\n    string d_str = inf.readToken(numPattern, \"d\");\n    inf.readEoln();\n\n    double a = atof(a_str.c_str());\n    ensuref(a >= 1.0 && a <= 1e5, \"a is out of bounds: a=%0.10lf\", a);\n\n    double d = atof(d_str.c_str());\n    ensuref(d >= 1.0 && d <= 1e5, \"d is out of bounds: d=%0.10lf\", d);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string numPattern = \"([1-9][0-9]{0,4}|100000)(\\\\.[0-9]{1,4})?\";\n\n    string a_str = inf.readToken(numPattern, \"a\");\n    inf.readSpace();\n    string d_str = inf.readToken(numPattern, \"d\");\n    inf.readEoln();\n\n    double a = atof(a_str.c_str());\n    ensuref(a >= 1.0 && a <= 1e5, \"a is out of bounds: a=%0.10lf\", a);\n\n    double d = atof(d_str.c_str());\n    ensuref(d >= 1.0 && d <= 1e5, \"d is out of bounds: d=%0.10lf\", d);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-4;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.5f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.5f', found: '%.5f', error = '%.5f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.5f', expected '%.5f', error '%.5f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int n = opt<int>(\"n\", -1);\n    double a = opt<double>(\"a\", -1);\n    double d = opt<double>(\"d\", -1);\n\n    if (type == \"random\") {\n        if (n == -1) n = rnd.next(1, 100000);\n        if (a == -1) a = rnd.next(1.0, 100000.0);\n        if (d == -1) d = rnd.next(1.0, 100000.0);\n    } else if (type == \"max\") {\n        n = 100000;\n        a = 100000.0;\n        d = 100000.0;\n    } else if (type == \"min\") {\n        n = 1;\n        a = 1.0;\n        d = 1.0;\n    } else if (type == \"d_equals_a\") {\n        if (a == -1) a = rnd.next(1.0, 100000.0);\n        if (n == -1) n = rnd.next(1, 100000);\n        d = a;\n    } else if (type == \"d_divides_perimeter\") {\n        if (a == -1) a = rnd.next(1.0, 100000.0);\n        if (n == -1) n = rnd.next(1, 100000);\n        int laps = rnd.next(1, 1000);\n        double perim = 4.0 * a;\n        d = perim / laps;\n    } else if (type == \"precision\") {\n        if (a == -1) a = rnd.next(1.0, 100000.0);\n        if (n == -1) n = rnd.next(1, 100000);\n        d = rnd.next(0.0001, 0.001);\n    } else if (type == \"lap_end\") {\n        if (a == -1) a = rnd.next(1.0, 100000.0);\n        double perim = 4.0 * a;\n        d = perim;\n        if (n == -1) n = rnd.next(1, 100000);\n    } else {\n        if (n == -1) n = rnd.next(1, 100000);\n        if (a == -1) a = rnd.next(1.0, 100000.0);\n        if (d == -1) d = rnd.next(1.0, 100000.0);\n    }\n\n    a = max(1.0, min(a, 100000.0));\n    d = max(1.0, min(d, 100000.0));\n    n = max(1, min(n, 100000));\n\n    a = floor(a * 10000.0 + 0.5) / 10000.0;\n    d = floor(d * 10000.0 + 0.5) / 10000.0;\n\n    printf(\"%.4f %.4f\\n\", a, d);\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int n = opt<int>(\"n\", -1);\n    double a = opt<double>(\"a\", -1);\n    double d = opt<double>(\"d\", -1);\n\n    if (type == \"random\") {\n        if (n == -1) n = rnd.next(1, 100000);\n        if (a == -1) a = rnd.next(1.0, 100000.0);\n        if (d == -1) d = rnd.next(1.0, 100000.0);\n    } else if (type == \"max\") {\n        n = 100000;\n        a = 100000.0;\n        d = 100000.0;\n    } else if (type == \"min\") {\n        n = 1;\n        a = 1.0;\n        d = 1.0;\n    } else if (type == \"d_equals_a\") {\n        if (a == -1) a = rnd.next(1.0, 100000.0);\n        if (n == -1) n = rnd.next(1, 100000);\n        d = a;\n    } else if (type == \"d_divides_perimeter\") {\n        if (a == -1) a = rnd.next(1.0, 100000.0);\n        if (n == -1) n = rnd.next(1, 100000);\n        int laps = rnd.next(1, 1000);\n        double perim = 4.0 * a;\n        d = perim / laps;\n    } else if (type == \"precision\") {\n        if (a == -1) a = rnd.next(1.0, 100000.0);\n        if (n == -1) n = rnd.next(1, 100000);\n        d = rnd.next(0.0001, 0.001);\n    } else if (type == \"lap_end\") {\n        if (a == -1) a = rnd.next(1.0, 100000.0);\n        double perim = 4.0 * a;\n        d = perim;\n        if (n == -1) n = rnd.next(1, 100000);\n    } else {\n        if (n == -1) n = rnd.next(1, 100000);\n        if (a == -1) a = rnd.next(1.0, 100000.0);\n        if (d == -1) d = rnd.next(1.0, 100000.0);\n    }\n\n    a = max(1.0, min(a, 100000.0));\n    d = max(1.0, min(d, 100000.0));\n    n = max(1, min(n, 100000));\n\n    a = floor(a * 10000.0 + 0.5) / 10000.0;\n    d = floor(d * 10000.0 + 0.5) / 10000.0;\n\n    printf(\"%.4f %.4f\\n\", a, d);\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Maximum values test case\n./gen -type max\n\n# Minimum values test case\n./gen -type min\n\n# Test cases where d equals a\n./gen -type d_equals_a\n./gen -type d_equals_a\n\n# Test cases where d divides the perimeter\n./gen -type d_divides_perimeter\n./gen -type d_divides_perimeter\n\n# Test cases to check precision with small d\n./gen -type precision\n./gen -type precision\n\n# Test cases with d equals the perimeter (lap end)\n./gen -type lap_end\n./gen -type lap_end\n\n# Fixed value test cases\n./gen -n 1 -a 1.0000 -d 1.0000 -type fixed\n./gen -n 100000 -a 100000.0000 -d 100000.0000 -type fixed\n\n# Edge case test cases\n./gen -n 100000 -a 100000.0000 -d 1.0000 -type fixed\n./gen -n 1 -a 1.0000 -d 100000.0000 -type fixed\n\n# Test case with n and d at extremes\n./gen -n 99999 -a 100000.0000 -d 0.0001 -type fixed\n\n# Random test cases with specified n\n./gen -n 50000 -type random\n./gen -n 75000 -type random\n\n# Random test cases with specified a and d\n./gen -a 1000.1234 -d 2000.5678 -type random\n./gen -a 99999.9999 -d 0.0001 -type random\n\n# Additional fixed test cases\n./gen -n 99999 -a 98765.4321 -d 12345.6789 -type fixed\n./gen -n 54321 -a 12345.6789 -d 98765.4321 -type fixed\n\n# Some more d divides perimeter cases\n./gen -type d_divides_perimeter\n./gen -type d_divides_perimeter\n\n# Some more lap end cases\n./gen -type lap_end\n./gen -type lap_end\n\n# Precision edge cases\n./gen -n 100000 -a 99999.9999 -d 0.0001 -type precision\n./gen -n 1 -a 0.0001 -d 100000.0000 -type precision\n\n# Random test cases\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:02.833220",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "404/C",
      "title": "C. Restore Graph",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and k (1 ≤ k < n ≤ 105). Number n shows the number of vertices in the original graph. Number k shows that at most k edges were adjacent to each vertex in the original graph.The second line contains space-separated integers d[1], d[2], ..., d[n] (0 ≤ d[i] < n). Number d[i] shows the shortest distance from the vertex Valera chose to the vertex number i.",
      "output_spec": "OutputIf Valera made a mistake in his notes and the required graph doesn't exist, print in the first line number -1. Otherwise, in the first line print integer m (0 ≤ m ≤ 106) — the number of edges in the found graph.In each of the next m lines print two space-separated integers ai and bi (1 ≤ ai, bi ≤ n; ai ≠ bi), denoting the edge that connects vertices with numbers ai and bi. The graph shouldn't contain self-loops and multiple edges. If there are multiple possible answers, print any of them.",
      "sample_tests": "ExamplesInputCopy3 20 1 1OutputCopy31 21 33 2InputCopy4 22 0 1 3OutputCopy31 31 42 3InputCopy3 10 0 0OutputCopy-1",
      "description": "C. Restore Graph\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and k (1 ≤ k < n ≤ 105). Number n shows the number of vertices in the original graph. Number k shows that at most k edges were adjacent to each vertex in the original graph.The second line contains space-separated integers d[1], d[2], ..., d[n] (0 ≤ d[i] < n). Number d[i] shows the shortest distance from the vertex Valera chose to the vertex number i.\n\nOutputIf Valera made a mistake in his notes and the required graph doesn't exist, print in the first line number -1. Otherwise, in the first line print integer m (0 ≤ m ≤ 106) — the number of edges in the found graph.In each of the next m lines print two space-separated integers ai and bi (1 ≤ ai, bi ≤ n; ai ≠ bi), denoting the edge that connects vertices with numbers ai and bi. The graph shouldn't contain self-loops and multiple edges. If there are multiple possible answers, print any of them.\n\nInputCopy3 20 1 1OutputCopy31 21 33 2InputCopy4 22 0 1 3OutputCopy31 31 42 3InputCopy3 10 0 0OutputCopy-1\n\nInputCopy3 20 1 1\n\nOutputCopy31 21 33 2\n\nInputCopy4 22 0 1 3\n\nOutputCopy31 31 42 3\n\nInputCopy3 10 0 0\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces",
          "content": "Hi to all!)Regular round Codeforces #237 for participants from 2 division will take place tomorrow March 19, 19:30 MSK. Traditional, participants from 1 division can take part out of the competition.The problems were prepared by Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Also thanks to Michael Mirzayanov (MikeMirzayanov) for very cool system Codeforces and Mary Belova (Delinur) for translating the problems into english.We wish everyone good luck, high rating and excellent mood)UPD: Score distribution will be standard 500 — 1000 — 1500 — 2000 — 2500.UPD 2: The contest is over, thanks to all participants.Congratulations to the winners: Pkqs09 juggler zstu_bobo kevinswat Salvare004 UPD3: You can find the tutorial here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11039",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 743
        },
        {
          "title": "Codeforces Round #237 (Div. 2) Editorial - Codeforces",
          "content": "404A - Valera and XIn this problem it was needed to check the constraints described in statement. You can use two sets here. You should insert diagonal elements of matrix into the first set, and the other elements into the second. Element ai, j belongs to the main diagonal if i = j and belongs to the secondary diagonal if i = n - j + 1. After you split all elements into sets you should check if the sets sizes are equal to one and the elements from this sets differ from each other.404B - MarathonLet's notice that after Valera run 4·a meters he will be in the same point from which he started. Valera will have run i·d meters before he gets i-th bottle of drink. Let's calculate the value — how many laps he will run. Then he have already run L = i·d - c·4·a meters on his last lap. It is easy to get Valera's position from this L. For example, if 2·a ≤ L ≤ 3·a then Valera will be in the point with coordinates (3·a - L, a). You can consider the other three cases in the same manner.404C - Restore GraphFirst of all let us notice that it must be only one 0 in d. Also d[start] = 0 means that start is the vertex from which Valera calculated the distance to the other vertices. Let's notice that every vertex u with d[u] = i must be adjacent only to the vertices v such that d[v] ≥ i - 1. Besides there is always must be such neighboor v0 of u, that d[v0] = i - 1. Let's build sought graph by adding one vertex to the existing graph. We will add vertex in order of increasing their distance to start. Initially, we have one vertex with number start in our graph. When we add vertex u with d[u] = i let's consider such vertices v that d[v] = i - 1. Let's choose the vertex with minimal degree among them. If this value is equal to k, then there is no solution. In other case let's add u to our graph and add the edge (u, v) to the answer. If there are no vertices with distance i - 1 to start then the answer is also  - 1. If everything fine we will get the answer which is tree, so the number of edges in it equals n - 1 ≤ 106.404D - Minesweeper 1DThis problem can be solved by using dynamic programming. Let's calculate d[i][type] — the number of correct ways to fill the prefix of length i so that the last filled cell has one of the 5 types. These types are the following: the cell contains \"0\" the cell contains \"1\" and the cell to the left of it contains bomb the cell contains \"1\" and the cell to the left of it doesn't contain bomb the cell contains \"2\" the cell contains bomb When we try to fill next cell we check two conditions. Firstly value of the filled cell in given string must be equal to either what we want to write or \"?\". Secondly new prefix must remain filled correct. For example, if we are in state (i, 1) (it means that the cell i contains \"0\") then we can fill next cell by \"0\" and go to the state (i + 1, 1) or fill next cell by \"1\" and go to the state (i + 1, 3). We cannot write \"2\" because both neighbours of the cell with \"2\" must contain bomb. Obvious, we cannot place bomb after \"0\". Note that, when we place \"1\" after \"0\" we go to the state (i + 1, 3), but when we place \"1\" after bomb we go to the state (i + 1, 2). You can consider other ways of going from one state to another in the same manner.404E - Maze 1DLet's consider the case when the last move of the robot is equal to \"R\". If the last move is equal to \"L\" then we can replace all \"L\" by \"R\" and vise versa and the answer doesn't change. Let's show that Valera doesn't need more than one obstacle. Suppose Valera placed obstacles somewhere. We will say that the number of obstacle is the number of cell containing it. Let's consider the rightmost obstacle obs1 among the obstacles with negative numbers and the leftmost obstacle obs2 among the obstacles with positive numbers. Obvious robot cannot go to the left of obs1 and to the right of obs2. So the needed number of obstacles is not greater than two. Let's show that Valera doesn't need to place obstacles to the cells with numbers greater than zero. Suppose he place obstacle to the cell with number a > 0. If robot doesn't try to go to this cell then its obstacle is out of place. If robot try to go to this cell then it will visit finish cell more than once. It is because robot needs to go to the right on its last move, but it can't do it from cell a - 1 and it has already visited all cells to the left of a. So Valera doesn't need more than one obstacle and its obstacle must have number less than zero.Let's now check if Valera can do without obstacles. If so the robot won't skip moves and will stop in some cell. Than Valera can choose this cell as finish and the answer will be one. We have to consider only one case when Valera must place one obstacle.Firstly let's notice that if Valera place obstacle to some cell, the finish cell can be restored uniquely. It means that the number of ways to choose where to place obstacles and finish cell is equal to the number of ways to choose one cell to place one obstacle. Suppose Valera placed obstacle in the cell with number b < 0 and robot completed its instructions successfully. Notice, that in that case robot skipped some moves of type \"L\", completed all moves of type \"R\" and went to the right on its last move to the unvisited cell. If we shift Valera's obstacle to the right on one cell then robot is going to skip not less moves of type \"L\" than in the previous case. It means that the finish cell can either go to the right or remains the same. But last time robot visited this cell on its last move, so it is going to visit a new finish cell on its last move either. This means that there is such cell p < 0 that if Valera place obstacle to the cells c ≥ p then robot will be able to complete its instructions successfully, but if Valera place obstacle to the cells d < p then robot will not. This cell p can be found by using binary search and simple simulation on each iteration. Time complexity is O(n log n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11095",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 404\\s*C"
          },
          "content_length": 5935
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 3",
          "code": "a and d (1 ≤ a, d ≤ 100000), given with precision till 4 decimal digits after the decimal point.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 4",
          "code": "#define SC 10000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 5",
          "code": "cout<<\"*\"<<dd<<endl;\ncout<<\"**\"<<dd*SC<<endl;\ncout<<\"***\"<<(int)(dd*SC)<<endl;\ncout<<\"****\"<<d<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 6",
          "code": "cout<<\"*\"<<dd<<endl;\ncout<<\"**\"<<dd*SC<<endl;\ncout<<\"***\"<<(int)(dd*SC)<<endl;\ncout<<\"****\"<<d<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 7",
          "code": "*2.8819\n**28819\n***28819\n****28819",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 8",
          "code": "*2.8819\n**28819\n***28819\n****28819",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 9",
          "code": "*2.8819\n**28819\n***28818\n****28818",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 10",
          "code": "*2.8819\n**28819\n***28818\n****28818",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 11",
          "code": "printf(\"%.6lf\\n\",2.8819*10000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int d_i = inf.readInt(0, n - 1, \"d_i\");\n        if (i + 1 < n)\n            inf.readSpace();\n        else\n            inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int d_i = inf.readInt(0, n - 1, \"d_i\");\n        if (i + 1 < n)\n            inf.readSpace();\n        else\n            inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int d_i = inf.readInt(0, n - 1, \"d_i\");\n        if (i + 1 < n)\n            inf.readSpace();\n        else\n            inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\nvector<int> d;\nint m_ans, m_ouf;\nvector<vector<int>> adj;\nvector<int> degree;\nset<pair<int, int>> edges;\n\nvoid readGraph(InStream& stream, int m) {\n    adj.resize(n + 1);\n    degree.resize(n + 1, 0);\n    edges.clear();\n    for (int i = 0; i < m; i++) {\n        int u = stream.readInt(1, n, format(\"edge %d vertex u\", i + 1).c_str());\n        int v = stream.readInt(1, n, format(\"edge %d vertex v\", i + 1).c_str());\n        if (u == v)\n            stream.quitf(_wa, \"self-loop detected at vertex %d\", u);\n        if (edges.count(make_pair(u, v)))\n            stream.quitf(_wa, \"multiple edge between %d and %d\", u, v);\n        edges.insert(make_pair(u, v));\n        edges.insert(make_pair(v, u));\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n        degree[u]++;\n        degree[v]++;\n        if (degree[u] > k)\n            stream.quitf(_wa, \"degree of vertex %d exceeds k\", u);\n        if (degree[v] > k)\n            stream.quitf(_wa, \"degree of vertex %d exceeds k\", v);\n    }\n}\n\nbool checkConnected() {\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n    int cnt = 1;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                cnt++;\n                q.push(v);\n            }\n        }\n    }\n    return cnt == n;\n}\n\nbool checkDistances(int s) {\n    vector<int> dist(n + 1, -1);\n    queue<int> q;\n    q.push(s);\n    dist[s] = 0;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        if (dist[i] != d[i])\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt();\n    k = inf.readInt();\n    d.resize(n + 1);\n    for (int i = 1; i <= n; i++) {\n        d[i] = inf.readInt();\n    }\n    m_ans = ans.readInt();\n    m_ouf = ouf.readInt();\n\n    if (m_ans == -1) {\n        if (m_ouf == -1) {\n            quitf(_ok, \"Correctly outputs -1\");\n        } else {\n            // Read participant's graph and validate\n            readGraph(ouf, m_ouf);\n            // Additional checks\n            if (!checkConnected())\n                ouf.quitf(_wa, \"graph is not connected\");\n            // Try to find s such that distances match\n            set<int> s_vertices;\n            for (int i = 1; i <= n; i++) {\n                if (d[i] == 0)\n                    s_vertices.insert(i);\n            }\n            for (int s : s_vertices) {\n                if (checkDistances(s)) {\n                    quitf(_fail, \"Participant found a valid graph but jury says impossible\");\n                }\n            }\n            ouf.quitf(_wa, \"graph does not match the distances from any s with d[s]=0\");\n        }\n    } else {\n        if (m_ouf == -1) {\n            quitf(_wa, \"Participant outputs -1 while solution exists\");\n        } else {\n            // Read participant's graph and validate\n            readGraph(ouf, m_ouf);\n            // Additional checks\n            if (!checkConnected())\n                ouf.quitf(_wa, \"graph is not connected\");\n            // Try to find s such that distances match\n            set<int> s_vertices;\n            for (int i = 1; i <= n; i++) {\n                if (d[i] == 0)\n                    s_vertices.insert(i);\n            }\n            if (s_vertices.empty())\n                ouf.quitf(_wa, \"no vertex with d[i]=0\");\n            bool valid = false;\n            for (int s : s_vertices) {\n                if (checkDistances(s)) {\n                    valid = true;\n                    break;\n                }\n            }\n            if (!valid)\n                ouf.quitf(_wa, \"graph does not match the distances from any s with d[s]=0\");\n            quitf(_ok, \"Correct graph\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random_valid\");\n\n    vector<int> d(n+1);\n    vector<int> degrees(n+1);\n\n    if (type == \"random_valid\") {\n        // Build a tree starting from s\n        int s = rnd.next(1, n); // starting node\n        d[s] = 0;\n\n        vector<vector<int>> levels;\n        levels.push_back({s});\n        degrees[s] = 0; // start with zero degree\n\n        vector<bool> used(n+1, false);\n        used[s] = true;\n\n        int remaining = n - 1; // nodes to assign distances\n\n        while (remaining > 0) {\n            vector<int> prev_level = levels.back();\n            vector<int> current_level;\n            // Compute total capacity in prev_level\n            int total_cap = 0;\n            for (int u : prev_level) {\n                total_cap += k - degrees[u];\n            }\n            if (total_cap == 0) {\n                // Cannot proceed further, so we cannot generate a valid tree\n                // For 'random_valid', we need to ensure we can generate a valid test case\n                // So we will adjust k to be larger\n                fprintf(stderr, \"Cannot generate a valid tree with given k\\n\");\n                exit(1);\n            }\n\n            int num_in_level = min(remaining, total_cap);\n\n            // Assign new nodes\n            for (int i = 0; i < num_in_level; ++i) {\n                int v = -1;\n                for (int j = 1; j <= n; ++j) {\n                    if (!used[j]) {\n                        v = j;\n                        used[j] = true;\n                        break;\n                    }\n                }\n                if (v == -1) {\n                    // Should not happen\n                    break;\n                }\n                current_level.push_back(v);\n            }\n\n            // Now assign parents from prev_level based on capacities\n            int idx = 0;\n            for (int u : prev_level) {\n                while (degrees[u] < k && idx < current_level.size()) {\n                    int v = current_level[idx++];\n                    d[v] = levels.size(); // distance from s\n                    degrees[u]++;\n                    degrees[v] = 1;\n                }\n                if (idx >= current_level.size()) break;\n            }\n\n            levels.push_back(current_level);\n            remaining -= current_level.size();\n        }\n\n        // Now we have assigned distances\n\n        // Output n and k\n        printf(\"%d %d\\n\", n, k);\n        // Output distances\n        for (int i = 1; i <= n; ++i) {\n            if (i > 1) printf(\" \");\n            printf(\"%d\", d[i]);\n        }\n        printf(\"\\n\");\n    } else if (type == \"impossible_k_too_small\") {\n        // For example, k=1, and multiple nodes at distance 1 from s\n\n        if (k >= n) {\n            fprintf(stderr, \"k should be less than n for impossible_k_too_small\\n\");\n            exit(1);\n        }\n\n        int s = rnd.next(1, n);\n        for (int i = 1; i <= n; ++i) {\n            if (i == s) {\n                d[i] = 0;\n            } else {\n                d[i] = 1;\n            }\n        }\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 1; i <= n; ++i) {\n            if (i > 1) printf(\" \");\n            printf(\"%d\", d[i]);\n        }\n        printf(\"\\n\");\n    } else if (type == \"multiple_zero\") {\n        // Set multiple vertices with d[i]=0\n\n        int num_zero = rnd.next(2, min(n, 5));\n        for (int i = 1; i <= num_zero; ++i)\n            d[i] = 0;\n        for (int i = num_zero+1; i <= n; ++i)\n            d[i] = rnd.next(1, n-1);\n\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 1; i <= n; ++i) {\n            if (i > 1) printf(\" \");\n            printf(\"%d\", d[i]);\n        }\n        printf(\"\\n\");\n\n    } else if (type == \"chain\") {\n        // Build a chain from s\n\n        int s = 1; // Let's fix s as 1 for simplicity\n        d[s] = 0;\n        for (int i = 2; i <= n; ++i) {\n            d[i] = d[i-1] + 1;\n        }\n\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 1; i <= n; ++i) {\n            if (i > 1) printf(\" \");\n            printf(\"%d\", d[i]);\n        }\n        printf(\"\\n\");\n\n    } else if (type == \"star\") {\n        // Build a star centered at s\n\n        int s = rnd.next(1, n);\n        d[s] = 0;\n        for (int i = 1; i <= n; ++i) {\n            if (i != s)\n                d[i] = 1;\n        }\n\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 1; i <= n; ++i) {\n            if (i > 1) printf(\" \");\n            printf(\"%d\", d[i]);\n        }\n        printf(\"\\n\");\n\n    } else {\n        // Generate random distances that may be invalid\n\n        int s = rnd.next(1, n);\n        d[s] = 0;\n        for (int i = 1; i <= n; ++i) {\n            if (i != s)\n                d[i] = rnd.next(0, n-1);\n        }\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 1; i <= n; ++i) {\n            if (i > 1) printf(\" \");\n            printf(\"%d\", d[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random_valid\");\n\n    vector<int> d(n+1);\n    vector<int> degrees(n+1);\n\n    if (type == \"random_valid\") {\n        // Build a tree starting from s\n        int s = rnd.next(1, n); // starting node\n        d[s] = 0;\n\n        vector<vector<int>> levels;\n        levels.push_back({s});\n        degrees[s] = 0; // start with zero degree\n\n        vector<bool> used(n+1, false);\n        used[s] = true;\n\n        int remaining = n - 1; // nodes to assign distances\n\n        while (remaining > 0) {\n            vector<int> prev_level = levels.back();\n            vector<int> current_level;\n            // Compute total capacity in prev_level\n            int total_cap = 0;\n            for (int u : prev_level) {\n                total_cap += k - degrees[u];\n            }\n            if (total_cap == 0) {\n                // Cannot proceed further, so we cannot generate a valid tree\n                // For 'random_valid', we need to ensure we can generate a valid test case\n                // So we will adjust k to be larger\n                fprintf(stderr, \"Cannot generate a valid tree with given k\\n\");\n                exit(1);\n            }\n\n            int num_in_level = min(remaining, total_cap);\n\n            // Assign new nodes\n            for (int i = 0; i < num_in_level; ++i) {\n                int v = -1;\n                for (int j = 1; j <= n; ++j) {\n                    if (!used[j]) {\n                        v = j;\n                        used[j] = true;\n                        break;\n                    }\n                }\n                if (v == -1) {\n                    // Should not happen\n                    break;\n                }\n                current_level.push_back(v);\n            }\n\n            // Now assign parents from prev_level based on capacities\n            int idx = 0;\n            for (int u : prev_level) {\n                while (degrees[u] < k && idx < current_level.size()) {\n                    int v = current_level[idx++];\n                    d[v] = levels.size(); // distance from s\n                    degrees[u]++;\n                    degrees[v] = 1;\n                }\n                if (idx >= current_level.size()) break;\n            }\n\n            levels.push_back(current_level);\n            remaining -= current_level.size();\n        }\n\n        // Now we have assigned distances\n\n        // Output n and k\n        printf(\"%d %d\\n\", n, k);\n        // Output distances\n        for (int i = 1; i <= n; ++i) {\n            if (i > 1) printf(\" \");\n            printf(\"%d\", d[i]);\n        }\n        printf(\"\\n\");\n    } else if (type == \"impossible_k_too_small\") {\n        // For example, k=1, and multiple nodes at distance 1 from s\n\n        if (k >= n) {\n            fprintf(stderr, \"k should be less than n for impossible_k_too_small\\n\");\n            exit(1);\n        }\n\n        int s = rnd.next(1, n);\n        for (int i = 1; i <= n; ++i) {\n            if (i == s) {\n                d[i] = 0;\n            } else {\n                d[i] = 1;\n            }\n        }\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 1; i <= n; ++i) {\n            if (i > 1) printf(\" \");\n            printf(\"%d\", d[i]);\n        }\n        printf(\"\\n\");\n    } else if (type == \"multiple_zero\") {\n        // Set multiple vertices with d[i]=0\n\n        int num_zero = rnd.next(2, min(n, 5));\n        for (int i = 1; i <= num_zero; ++i)\n            d[i] = 0;\n        for (int i = num_zero+1; i <= n; ++i)\n            d[i] = rnd.next(1, n-1);\n\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 1; i <= n; ++i) {\n            if (i > 1) printf(\" \");\n            printf(\"%d\", d[i]);\n        }\n        printf(\"\\n\");\n\n    } else if (type == \"chain\") {\n        // Build a chain from s\n\n        int s = 1; // Let's fix s as 1 for simplicity\n        d[s] = 0;\n        for (int i = 2; i <= n; ++i) {\n            d[i] = d[i-1] + 1;\n        }\n\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 1; i <= n; ++i) {\n            if (i > 1) printf(\" \");\n            printf(\"%d\", d[i]);\n        }\n        printf(\"\\n\");\n\n    } else if (type == \"star\") {\n        // Build a star centered at s\n\n        int s = rnd.next(1, n);\n        d[s] = 0;\n        for (int i = 1; i <= n; ++i) {\n            if (i != s)\n                d[i] = 1;\n        }\n\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 1; i <= n; ++i) {\n            if (i > 1) printf(\" \");\n            printf(\"%d\", d[i]);\n        }\n        printf(\"\\n\");\n\n    } else {\n        // Generate random distances that may be invalid\n\n        int s = rnd.next(1, n);\n        d[s] = 0;\n        for (int i = 1; i <= n; ++i) {\n            if (i != s)\n                d[i] = rnd.next(0, n-1);\n        }\n        printf(\"%d %d\\n\", n, k);\n        for (int i = 1; i <= n; ++i) {\n            if (i > 1) printf(\" \");\n            printf(\"%d\", d[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -k 2 -type chain\n./gen -n 5 -k 2 -type star\n./gen -n 5 -k 1 -type impossible_k_too_small\n./gen -n 5 -k 2 -type multiple_zero\n\n./gen -n 10 -k 3 -type random_valid\n./gen -n 10 -k 1 -type impossible_k_too_small\n./gen -n 10 -k 2 -type random_invalid\n\n./gen -n 100 -k 2 -type chain\n./gen -n 100 -k 99 -type star\n./gen -n 100 -k 1 -type impossible_k_too_small\n\n./gen -n 1000 -k 3 -type random_valid\n./gen -n 1000 -k 1 -type impossible_k_too_small\n\n./gen -n 10000 -k 2 -type chain\n./gen -n 10000 -k 1 -type impossible_k_too_small\n\n./gen -n 50000 -k 5 -type random_valid\n./gen -n 50000 -k 1 -type impossible_k_too_small\n\n./gen -n 100000 -k 2 -type chain\n./gen -n 100000 -k 1 -type impossible_k_too_small\n\n./gen -n 99999 -k 2 -type random_valid\n./gen -n 100000 -k 1 -type impossible_k_too_small\n\n./gen -n 10 -k 2 -type multiple_zero\n./gen -n 10 -k 2 -type random_invalid\n\n./gen -n 50000 -k 3 -type random_valid\n./gen -n 50000 -k 2 -type random_invalid\n\n./gen -n 100000 -k 3 -type random_valid\n./gen -n 100000 -k 2 -type random_invalid\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:04.793801",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "404/D",
      "title": "D. Minesweeper 1D",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains sequence of characters without spaces s1s2... sn (1 ≤ n ≤ 106), containing only characters \"*\", \"?\" and digits \"0\", \"1\" or \"2\". If character si equals \"*\", then the i-th cell of the field contains a bomb. If character si equals \"?\", then Valera hasn't yet decided what to put in the i-th cell. Character si, that is equal to a digit, represents the digit written in the i-th square.",
      "output_spec": "OutputPrint a single integer — the number of ways Valera can fill the empty cells and get a correct field.As the answer can be rather large, print it modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy?01???OutputCopy4InputCopy?OutputCopy2InputCopy**12OutputCopy0InputCopy1OutputCopy0",
      "description": "D. Minesweeper 1D\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains sequence of characters without spaces s1s2... sn (1 ≤ n ≤ 106), containing only characters \"*\", \"?\" and digits \"0\", \"1\" or \"2\". If character si equals \"*\", then the i-th cell of the field contains a bomb. If character si equals \"?\", then Valera hasn't yet decided what to put in the i-th cell. Character si, that is equal to a digit, represents the digit written in the i-th square.\n\nOutputPrint a single integer — the number of ways Valera can fill the empty cells and get a correct field.As the answer can be rather large, print it modulo 1000000007 (109 + 7).\n\nInputCopy?01???OutputCopy4InputCopy?OutputCopy2InputCopy**12OutputCopy0InputCopy1OutputCopy0\n\nInputCopy?01???\n\nOutputCopy4\n\nOutputCopy2\n\nInputCopy**12\n\nOutputCopy0\n\nOutputCopy0\n\nNoteIn the first test sample you can get the following correct fields: 001**1, 001***, 001*2*, 001*10.",
      "solutions": [
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces",
          "content": "Hi to all!)Regular round Codeforces #237 for participants from 2 division will take place tomorrow March 19, 19:30 MSK. Traditional, participants from 1 division can take part out of the competition.The problems were prepared by Igor Kudryashov (Igor_Kudryashov) and Gerald Agapov (Gerald). Also thanks to Michael Mirzayanov (MikeMirzayanov) for very cool system Codeforces and Mary Belova (Delinur) for translating the problems into english.We wish everyone good luck, high rating and excellent mood)UPD: Score distribution will be standard 500 — 1000 — 1500 — 2000 — 2500.UPD 2: The contest is over, thanks to all participants.Congratulations to the winners: Pkqs09 juggler zstu_bobo kevinswat Salvare004 UPD3: You can find the tutorial here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11039",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 743
        },
        {
          "title": "Codeforces Round #237 (Div. 2) Editorial - Codeforces",
          "content": "404A - Valera and XIn this problem it was needed to check the constraints described in statement. You can use two sets here. You should insert diagonal elements of matrix into the first set, and the other elements into the second. Element ai, j belongs to the main diagonal if i = j and belongs to the secondary diagonal if i = n - j + 1. After you split all elements into sets you should check if the sets sizes are equal to one and the elements from this sets differ from each other.404B - MarathonLet's notice that after Valera run 4·a meters he will be in the same point from which he started. Valera will have run i·d meters before he gets i-th bottle of drink. Let's calculate the value — how many laps he will run. Then he have already run L = i·d - c·4·a meters on his last lap. It is easy to get Valera's position from this L. For example, if 2·a ≤ L ≤ 3·a then Valera will be in the point with coordinates (3·a - L, a). You can consider the other three cases in the same manner.404C - Restore GraphFirst of all let us notice that it must be only one 0 in d. Also d[start] = 0 means that start is the vertex from which Valera calculated the distance to the other vertices. Let's notice that every vertex u with d[u] = i must be adjacent only to the vertices v such that d[v] ≥ i - 1. Besides there is always must be such neighboor v0 of u, that d[v0] = i - 1. Let's build sought graph by adding one vertex to the existing graph. We will add vertex in order of increasing their distance to start. Initially, we have one vertex with number start in our graph. When we add vertex u with d[u] = i let's consider such vertices v that d[v] = i - 1. Let's choose the vertex with minimal degree among them. If this value is equal to k, then there is no solution. In other case let's add u to our graph and add the edge (u, v) to the answer. If there are no vertices with distance i - 1 to start then the answer is also  - 1. If everything fine we will get the answer which is tree, so the number of edges in it equals n - 1 ≤ 106.404D - Minesweeper 1DThis problem can be solved by using dynamic programming. Let's calculate d[i][type] — the number of correct ways to fill the prefix of length i so that the last filled cell has one of the 5 types. These types are the following: the cell contains \"0\" the cell contains \"1\" and the cell to the left of it contains bomb the cell contains \"1\" and the cell to the left of it doesn't contain bomb the cell contains \"2\" the cell contains bomb When we try to fill next cell we check two conditions. Firstly value of the filled cell in given string must be equal to either what we want to write or \"?\". Secondly new prefix must remain filled correct. For example, if we are in state (i, 1) (it means that the cell i contains \"0\") then we can fill next cell by \"0\" and go to the state (i + 1, 1) or fill next cell by \"1\" and go to the state (i + 1, 3). We cannot write \"2\" because both neighbours of the cell with \"2\" must contain bomb. Obvious, we cannot place bomb after \"0\". Note that, when we place \"1\" after \"0\" we go to the state (i + 1, 3), but when we place \"1\" after bomb we go to the state (i + 1, 2). You can consider other ways of going from one state to another in the same manner.404E - Maze 1DLet's consider the case when the last move of the robot is equal to \"R\". If the last move is equal to \"L\" then we can replace all \"L\" by \"R\" and vise versa and the answer doesn't change. Let's show that Valera doesn't need more than one obstacle. Suppose Valera placed obstacles somewhere. We will say that the number of obstacle is the number of cell containing it. Let's consider the rightmost obstacle obs1 among the obstacles with negative numbers and the leftmost obstacle obs2 among the obstacles with positive numbers. Obvious robot cannot go to the left of obs1 and to the right of obs2. So the needed number of obstacles is not greater than two. Let's show that Valera doesn't need to place obstacles to the cells with numbers greater than zero. Suppose he place obstacle to the cell with number a > 0. If robot doesn't try to go to this cell then its obstacle is out of place. If robot try to go to this cell then it will visit finish cell more than once. It is because robot needs to go to the right on its last move, but it can't do it from cell a - 1 and it has already visited all cells to the left of a. So Valera doesn't need more than one obstacle and its obstacle must have number less than zero.Let's now check if Valera can do without obstacles. If so the robot won't skip moves and will stop in some cell. Than Valera can choose this cell as finish and the answer will be one. We have to consider only one case when Valera must place one obstacle.Firstly let's notice that if Valera place obstacle to some cell, the finish cell can be restored uniquely. It means that the number of ways to choose where to place obstacles and finish cell is equal to the number of ways to choose one cell to place one obstacle. Suppose Valera placed obstacle in the cell with number b < 0 and robot completed its instructions successfully. Notice, that in that case robot skipped some moves of type \"L\", completed all moves of type \"R\" and went to the right on its last move to the unvisited cell. If we shift Valera's obstacle to the right on one cell then robot is going to skip not less moves of type \"L\" than in the previous case. It means that the finish cell can either go to the right or remains the same. But last time robot visited this cell on its last move, so it is going to visit a new finish cell on its last move either. This means that there is such cell p < 0 that if Valera place obstacle to the cells c ≥ p then robot will be able to complete its instructions successfully, but if Valera place obstacle to the cells d < p then robot will not. This cell p can be found by using binary search and simple simulation on each iteration. Time complexity is O(n log n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11095",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 404\\s*D"
          },
          "content_length": 5935
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 3",
          "code": "a and d (1 ≤ a, d ≤ 100000), given with precision till 4 decimal digits after the decimal point.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 4",
          "code": "#define SC 10000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 5",
          "code": "cout<<\"*\"<<dd<<endl;\ncout<<\"**\"<<dd*SC<<endl;\ncout<<\"***\"<<(int)(dd*SC)<<endl;\ncout<<\"****\"<<d<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 6",
          "code": "cout<<\"*\"<<dd<<endl;\ncout<<\"**\"<<dd*SC<<endl;\ncout<<\"***\"<<(int)(dd*SC)<<endl;\ncout<<\"****\"<<d<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 7",
          "code": "*2.8819\n**28819\n***28819\n****28819",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 8",
          "code": "*2.8819\n**28819\n***28819\n****28819",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 9",
          "code": "*2.8819\n**28819\n***28818\n****28818",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 10",
          "code": "*2.8819\n**28819\n***28818\n****28818",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 11",
          "code": "printf(\"%.6lf\\n\",2.8819*10000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    std::string s = inf.readLine(\"[*?012]{1,1000000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    std::string s = inf.readLine(\"[*?012]{1,1000000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    std::string s = inf.readLine(\"[*?012]{1,1000000}\", \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize the string with '?' characters\n    string s(n, '?');\n\n    if (type == \"random\") {\n        // Randomly choose among '*', '?', '0', '1', '2' for each position\n        const char choices[] = {'*', '?', '0', '1', '2'};\n        for (int i = 0; i < n; ++i) {\n            s[i] = choices[rnd.next(5)];\n        }\n    } else if (type == \"all_question_marks\") {\n        // Already initialized to '?'\n    } else if (type == \"all_bombs\") {\n        s.assign(n, '*');\n    } else if (type == \"all_zeros\") {\n        s.assign(n, '0');\n    } else if (type == \"all_numbers\") {\n        // All cells are numbers '0', '1', or '2'\n        for (int i = 0; i < n; ++i) {\n            s[i] = '0' + rnd.next(3); // '0', '1', or '2'\n        }\n    } else if (type == \"edge_ones\") {\n        // '1's at the edges, '?' elsewhere\n        if (n >= 1) s[0] = '1';\n        if (n >= 2) s[n-1] = '1';\n        for (int i = 1; i < n - 1; ++i) {\n            s[i] = '?';\n        }\n    } else if (type == \"edge_twos\") {\n        // '2's at the edges, '?' elsewhere\n        if (n >= 1) s[0] = '2';\n        if (n >= 2) s[n-1] = '2';\n        for (int i = 1; i < n - 1; ++i) {\n            s[i] = '?';\n        }\n    } else if (type == \"mixed_numbers\") {\n        // Random numbers '0', '1', '2' at each position\n        for (int i = 0; i < n; ++i) {\n            s[i] = '0' + rnd.next(3);\n        }\n    } else if (type == \"single_cell\") {\n        // n must be 1\n        const char choices[] = {'*', '?', '0', '1', '2'};\n        s[0] = choices[rnd.next(5)];\n    } else if (type == \"alternating_bombs\") {\n        // Alternating '*' and '?'\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? '*' : '?';\n        }\n    } else if (type == \"alternating_numbers\") {\n        // Alternating numbers '0', '1', '2'\n        for (int i = 0; i < n; ++i) {\n            s[i] = '0' + (i % 3);\n        }\n    } else if (type == \"no_bombs\") {\n        // All cells are '0's\n        s.assign(n, '0');\n    } else if (type == \"edge_case\") {\n        // Specific edge cases\n        s.assign(n, '?');\n        if (n >= 3) {\n            s[0] = '1';\n            s[1] = '2';\n            s[2] = '1';\n        } else if (n == 2) {\n            s[0] = '2';\n            s[1] = '2';\n        } else if (n == 1) {\n            s[0] = '2';\n        }\n    } else if (type == \"sample1\") {\n        s = \"?01???\";\n    } else if (type == \"sample2\") {\n        s = \"?\";\n    } else if (type == \"sample3\") {\n        s = \"**12\";\n    } else if (type == \"sample4\") {\n        s = \"1\";\n    }\n\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize the string with '?' characters\n    string s(n, '?');\n\n    if (type == \"random\") {\n        // Randomly choose among '*', '?', '0', '1', '2' for each position\n        const char choices[] = {'*', '?', '0', '1', '2'};\n        for (int i = 0; i < n; ++i) {\n            s[i] = choices[rnd.next(5)];\n        }\n    } else if (type == \"all_question_marks\") {\n        // Already initialized to '?'\n    } else if (type == \"all_bombs\") {\n        s.assign(n, '*');\n    } else if (type == \"all_zeros\") {\n        s.assign(n, '0');\n    } else if (type == \"all_numbers\") {\n        // All cells are numbers '0', '1', or '2'\n        for (int i = 0; i < n; ++i) {\n            s[i] = '0' + rnd.next(3); // '0', '1', or '2'\n        }\n    } else if (type == \"edge_ones\") {\n        // '1's at the edges, '?' elsewhere\n        if (n >= 1) s[0] = '1';\n        if (n >= 2) s[n-1] = '1';\n        for (int i = 1; i < n - 1; ++i) {\n            s[i] = '?';\n        }\n    } else if (type == \"edge_twos\") {\n        // '2's at the edges, '?' elsewhere\n        if (n >= 1) s[0] = '2';\n        if (n >= 2) s[n-1] = '2';\n        for (int i = 1; i < n - 1; ++i) {\n            s[i] = '?';\n        }\n    } else if (type == \"mixed_numbers\") {\n        // Random numbers '0', '1', '2' at each position\n        for (int i = 0; i < n; ++i) {\n            s[i] = '0' + rnd.next(3);\n        }\n    } else if (type == \"single_cell\") {\n        // n must be 1\n        const char choices[] = {'*', '?', '0', '1', '2'};\n        s[0] = choices[rnd.next(5)];\n    } else if (type == \"alternating_bombs\") {\n        // Alternating '*' and '?'\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? '*' : '?';\n        }\n    } else if (type == \"alternating_numbers\") {\n        // Alternating numbers '0', '1', '2'\n        for (int i = 0; i < n; ++i) {\n            s[i] = '0' + (i % 3);\n        }\n    } else if (type == \"no_bombs\") {\n        // All cells are '0's\n        s.assign(n, '0');\n    } else if (type == \"edge_case\") {\n        // Specific edge cases\n        s.assign(n, '?');\n        if (n >= 3) {\n            s[0] = '1';\n            s[1] = '2';\n            s[2] = '1';\n        } else if (n == 2) {\n            s[0] = '2';\n            s[1] = '2';\n        } else if (n == 1) {\n            s[0] = '2';\n        }\n    } else if (type == \"sample1\") {\n        s = \"?01???\";\n    } else if (type == \"sample2\") {\n        s = \"?\";\n    } else if (type == \"sample3\") {\n        s = \"**12\";\n    } else if (type == \"sample4\") {\n        s = \"1\";\n    }\n\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type single_cell\n./gen -n 1 -type edge_twos\n./gen -n 1 -type sample4\n./gen -n 2 -type edge_case\n./gen -n 2 -type edge_twos\n./gen -n 3 -type edge_case\n./gen -n 6 -type sample1\n./gen -n 1 -type sample2\n./gen -n 4 -type sample3\n./gen -n 10 -type all_question_marks\n./gen -n 10 -type all_bombs\n./gen -n 10 -type all_zeros\n./gen -n 10 -type random\n./gen -n 10 -type edge_ones\n./gen -n 10 -type edge_twos\n./gen -n 20 -type alternating_bombs\n./gen -n 20 -type alternating_numbers\n./gen -n 50 -type random\n./gen -n 50 -type edge_case\n./gen -n 100 -type random\n./gen -n 100 -type all_question_marks\n./gen -n 100 -type alternating_bombs\n./gen -n 100 -type alternating_numbers\n./gen -n 100 -type mixed_numbers\n./gen -n 500 -type random\n./gen -n 1000 -type random\n./gen -n 1000 -type edge_ones\n./gen -n 1000 -type edge_twos\n./gen -n 1000 -type mixed_numbers\n./gen -n 5000 -type random\n./gen -n 5000 -type edge_case\n./gen -n 10000 -type random\n./gen -n 10000 -type all_bombs\n./gen -n 10000 -type no_bombs\n./gen -n 100000 -type random\n./gen -n 100000 -type edge_case\n./gen -n 100000 -type all_question_marks\n./gen -n 1000000 -type random\n./gen -n 1000000 -type all_bombs\n./gen -n 1000000 -type no_bombs\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:07.022274",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "404/E",
      "title": "E. Лабиринт 1D",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записана последовательность символов без пробелов s1s2... sn (1 ≤ n ≤ 106), состоящая только из букв «L» и «R». Если символ si равен «L», то робот на i-м ходу должен попробовать переместиться на одну клетку влево. Если символ si равен «R», то робот на i-м ходу должен попробовать переместиться на одну клетку вправо.",
      "output_spec": "Выходные данныеВыведите целое число — требуемое количество способов. Гарантируется, что это число помещается в 64-битном знаковом целочисленном типе данных.",
      "sample_tests": "ПримерыВходные данныеСкопироватьRRВыходные данныеСкопировать1Входные данныеСкопироватьRRLВыходные данныеСкопировать1",
      "description": "E. Лабиринт 1D\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записана последовательность символов без пробелов s1s2... sn (1 ≤ n ≤ 106), состоящая только из букв «L» и «R». Если символ si равен «L», то робот на i-м ходу должен попробовать переместиться на одну клетку влево. Если символ si равен «R», то робот на i-м ходу должен попробовать переместиться на одну клетку вправо.\n\nВходные данные\n\nВыходные данныеВыведите целое число — требуемое количество способов. Гарантируется, что это число помещается в 64-битном знаковом целочисленном типе данных.\n\nВыходные данные\n\nВходные данныеСкопироватьRRВыходные данныеСкопировать1Входные данныеСкопироватьRRLВыходные данныеСкопировать1\n\nВходные данныеСкопироватьRR\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьRRL\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Валера не должен ставить никаких препятствий, а в качестве финишной клетки выбрать клетку с номером 2.Во втором примере Валере необходимо поставить препятствие в клетку с номером 1, а финишной клеткой назначить клетку с номером  - 1. В этом случае он пропустит первые два хода, а на третьем сразу перейдет из своей стартовой клетки в финишную. Если же Валера не поставит никаких препятствий, или поставит препятствие в другую клетку, то он посетит финишную клетку более одного раза.",
      "solutions": [
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces",
          "content": "Всем привет!)Завтра 19 марта в 19:30 MSK состоится очередной раунд Codeforces #237 для участников из 2 дивизиона. Традиционно, участники 1 дивизиона могут написать соревнование вне конкурса.Подготовкой задач занимались Игорь Кудряшов (Igor_Kudryashov) и Геральд Агапов (Gerald). Кроме того, выражаем благодарность Михаилу Мирзаянову (MikeMirzayanov) за прекрасный ресурс Codeforces и Марии Беловой (Delinur) за перевод условий задач на английский язык.Желаем всем участникам удачи, высокого рейтинга и удовольствия от решения задач)UPD: Распределение баллов будет стандартное 500 — 1000 — 1500 — 2000 — 2500.UPD2: Соревнование завершено, благодарим всех за участие.Поздравляем победителей: Pkqs09 juggler zstu_bobo kevinswat Salvare004 UPD3: Разбор задач можно найти здесь",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11039",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 772
        },
        {
          "title": "Разбор задач Codeforces Round #237 (Div. 2) - Codeforces",
          "content": "404A - Валера и XВ данной задаче нужно было проверить, выполняются ли ограничения, описанные в условии. Чтобы это сделать, можно было завести два множества. В одно множество сложить диагональные элементы матрицы, в другое — остальные. Элемент ai, j стоит на главной диагонали, если i = j, и стоит на побочной, если i = n - j + 1. После того, как мы сложили все элементы в множества, нужно проверить, что размеры обоих множеств равны единице, и элементы этих множеств различны.404B - МарафонВ этой задаче нужно было заметить, что пройдя расстояние 4·a, Валера окажется в той же точке, откуда стартовал. В момент, когда Валера получит i-ое питание, он пробежит расстояние i·d. Давайте посчитаем величину — сколько полных кругов пробежит Валера по стадиону. Тогда на своем последнем кругу Валера уже пробежал L = i·d - c·4·a метров. В зависимости от этого L можно легко определить позицию Валеры. Например, если 2·a ≤ L ≤ 3·a, то Валера будет находиться в точке с координатами (3·a - L, a). Аналогичным образом разбираются остальные 3 случая.404C - Восстановите графЗаметим, прежде всего, что в массиве d должен быть один и только один 0. При этом d[start] = 0 обозначает, что start именно та вершина, от которой Валера считал расстояние до всех остальных. Заметим, что любая вершина u, для которой d[u] = i должна быть соединена ребрами только с вершинами v, у которых d[v] ≥ i - 1. При этом хотя бы для одной вершины v0 из соседей u должно выполняться d[v0] = i - 1. Будем строить искомый граф добавляя по одной вершине в порядке увеличения их расстояния до start. Изначально в нашем графе будет одна вершина с номером start. При добавлении вершины u с d[u] = i рассмотрим все вершины v, у которых d[v] = i - 1. Выберем среди таких вершин вершину минимальной степени. Если эта степень равна k, то ответа не существует. Иначе добавим в граф вершину u и ребро (u, v). Если вершин с расстоянием до start равным i - 1 нет, то ответ также  - 1. В противном случае после добавления всех вершин, мы получим граф, удовлетворяющий условиям задачи, который при этом будет деревом, а значит количество ребер в нем n - 1 ≤ 106.404D - Сапер 1DЗадача решается методом динамического программирования. Будем считать d[i][type] — количество корректных способов заполнить префикс полоски длиной i так, что последняя заполненная клетка имеет один из пяти типов. Типы последних клеток будут следующие: в клетке записано \"0\" в клетке записано \"1\" и слева от нее стоит бомба в клетке записано \"1\" и слева от нее нет бомбы в клетке записано \"2\" в клетке находится бомба Когда мы хотим заполнить очередную клетку, мы перебираем, что туда запишем, и проверяем два условия. Во-первых в заданной строке значение заполняемой клетки должно либо совпадать с тем, что мы хотим записать, либо быть равно \"?\". Во-вторых новый префикс должен оставаться корректно заполненным. Это значит, например, что если мы находимся в состоянии (i, 1) (то есть в последней заполненной клетке записан \"0\"), то в следующую клетку мы можем либо записать \"0\" и перейти в состояние (i + 1, 1), либо записать \"1\" и перейти в состояние (i + 1, 3). Записать \"2\" мы не можем, так как у клетки с \"2\" оба соседа должны быть заполнены бомбами. Поставить бомбу после \"0\" мы не можем по очевидным причинам. Обратите внимание, что записав \"1\" после \"0\" мы переходим именно в состояние (i + 1, 3), а в состояние (i + 1, 2) мы можем перейти лишь записав \"1\" после бомбы. Аналогичным образом разбираются остальные переходы динамики.404E - Лабиринт 1DРассмотрим случай, когда последовательность ходов робота заканчивается буквой \"R\". Если она заканчивается на \"L\", то можно заменить в исходной строке все \"L\" на \"R\" и все \"R\" на \"L\" и ответ от этого не изменится. Покажем, что количество препятствий, которое потребуется Валере, не превосходит 1. Предположим Валера поставил препятствия в какие-то клетки. Будем говорить, что номер препятствия — это номер клетки в которой оно стоит. Рассмотрим среди всех препятствий с отрицательными номерами самое правое (обозначим его obs1), а среди препятствий с положительными — самое левое (обозначим его obs2). Очевидно, что робот не сможет оказаться левее препятствия obs1 и правее obs2. Поэтому требуемое количество препятствий не превосходит двух. Покажем, что Валере не нужно ставить препятствия в клетки с номерами больше нуля. Предположим он поставит препятствие в клетку с номером a > 0. Если робот ни разу не попытается сходить в эту клетку, то, очевидно, препятствие лишнее. Если в какой-то момент робот пытается пойти в клетку a, то в последующем он посетит финишную клетку более одного раза. Это так, потому что на последнем ходу роботу нужно пойти направо, но из клетки a - 1 направо пойти нельзя, а все клетки, которые левее уже были посещены. Таким образом мы получаем, что Валере потребуется не более одного препятствия, которое должно иметь номер меньше нуля.Давайте теперь проверим, может ли Валера обойтись вообще без препятствий. Если может, то робот не пропустит ни одного хода и успешно закончит выполнение инструкции в какой-то клетке. Тогда Валера может выбрать только эту клетку в качестве финишной и ответ на задачу в этом случае равен единице. Остается случай, когда Валера должен поставить одно препятствие.Заметим, во-первых, что по тому, где Валера поставил препятствие, однозначно восстанавливается финишная клетка. Это значит, что количество способов выбрать препятствия и финишную клетку, равно количеству клеток, в которые нужно поставить одно препятствие. Предположим Валера поставил препятствие в клетку с номером b < 0 и робот успешно закончил инструкцию. Заметим, что в этом случае робот пропустит какие-то ходы типа \"L\", выполнит все ходы типа \"R\" и последним своим ходом пойдет направо в какую-то не посещенную клетку. Если теперь мы подвинем наше препятствие на одну клетку вправо, то от этого робот может лишь пропустить больше ходов типа \"L\". Это значит, что финишная клетка может лишь подвинуться вправо. Но так как в прошлый раз мы ее посетили последней, то и новую финишную клетку мы посетим последней. Это в свою очередь значит, что существует какая-то клетка p < 0 такая, что если мы поместим препятствие во все клетки c ≥ p, то робот сможет успешно выполнить инструкцию, а если поместим препятствие в клетку d < p, то не сможет. Эту клетку p можно найти при помощи бинарного поиска и простого моделирования за O(n) на каждой его итерации. Таким образом получаем решение за O(n log n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11095",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 404\\s*E"
          },
          "content_length": 6406
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 3",
          "code": "a and d (1 ≤ a, d ≤ 100000), given with precision till 4 decimal digits after the decimal point.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 4",
          "code": "#define SC 10000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 5",
          "code": "cout<<\"*\"<<dd<<endl;\ncout<<\"**\"<<dd*SC<<endl;\ncout<<\"***\"<<(int)(dd*SC)<<endl;\ncout<<\"****\"<<d<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 6",
          "code": "cout<<\"*\"<<dd<<endl;\ncout<<\"**\"<<dd*SC<<endl;\ncout<<\"***\"<<(int)(dd*SC)<<endl;\ncout<<\"****\"<<d<<endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 7",
          "code": "*2.8819\n**28819\n***28819\n****28819",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 8",
          "code": "*2.8819\n**28819\n***28819\n****28819",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 9",
          "code": "*2.8819\n**28819\n***28818\n****28818",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 10",
          "code": "*2.8819\n**28819\n***28818\n****28818",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #237 (Div. 2) - Codeforces - Code 11",
          "code": "printf(\"%.6lf\\n\",2.8819*10000);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11039",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #237 (Div. 2) - Codeforces - Code 1",
          "code": "public static void main (String [] args){\n\n     Scanner in = new Scanner(System.in);\n\n         double a = in.nextDouble();\n         double x = in.nextDouble();\n         double n = in.nextDouble();\n\n            double d=x;\n         for(int i=0;i<n;i++){\n\n\n\n            if(d%(4*a)>0 && d%(4*a)<=a)\n                System.out.println((d%(4*a)) + \" \" + \"0\");\n\n                else if(d%(4*a)>a && d%(4*a)<=2*a)\n                   System.out.println(a + \" \" + (d%(4*a)-a));\n\n                else if(d%(4*a)>2*a && d%(4*a)<=3*a)\n                   System.out.println((3*a-(d%(4*a))) + \" \" + a);\n\n                else if(d%(4*a)>3*a && d%(4*a)<=4*a)\n                   System.out.println(\"0\" + \" \" + (4*a-d%(4*a)));\n\n                   d+=x;\n\n\n         }\n         }\n\n}",
          "language": "Java",
          "source": "https://codeforces.com/blog/entry/11095",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(int(s.size()) >= 1 && int(s.size()) <= 1000000, \"Length of s (%d) is not in [1,1e6]\", int(s.size()));\n    for (int i = 0; i < int(s.size()); ++i) {\n        ensuref(s[i] == 'L' || s[i] == 'R', \"Invalid character '%c' in s at position %d\", s[i], i+1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(int(s.size()) >= 1 && int(s.size()) <= 1000000, \"Length of s (%d) is not in [1,1e6]\", int(s.size()));\n    for (int i = 0; i < int(s.size()); ++i) {\n        ensuref(s[i] == 'L' || s[i] == 'R', \"Invalid character '%c' in s at position %d\", s[i], i+1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(int(s.size()) >= 1 && int(s.size()) <= 1000000, \"Length of s (%d) is not in [1,1e6]\", int(s.size()));\n    for (int i = 0; i < int(s.size()); ++i) {\n        ensuref(s[i] == 'L' || s[i] == 'R', \"Invalid character '%c' in s at position %d\", s[i], i+1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, ' ');\n\n    if (type == \"all_L\") {\n        s = string(n, 'L');\n    } else if (type == \"all_R\") {\n        s = string(n, 'R');\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; i++) {\n            s[i] = (i % 2 == 0) ? 'L' : 'R';\n        }\n    } else if (type == \"palindrome\") {\n        for (int i = 0; i < (n + 1) / 2; i++) {\n            s[i] = (rnd.next(2) == 0) ? 'L' : 'R';\n            s[n - i - 1] = s[i];\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            s[i] = (rnd.next(2) == 0) ? 'L' : 'R';\n        }\n    } else if (type == \"long_run_L\") {\n        int m = opt<int>(\"m\", 1);\n        for (int i = 0; i < n; i++) {\n            s[i] = ((i / m) % 2 == 0) ? 'L' : 'R';\n        }\n    } else if (type == \"long_run_R\") {\n        int m = opt<int>(\"m\", 1);\n        for (int i = 0; i < n; i++) {\n            s[i] = ((i / m) % 2 == 0) ? 'R' : 'L';\n        }\n    } else if (type == \"return_to_start\") {\n        int pos = 0;\n        s.clear();\n        for (int i = 0; i < n; i++) {\n            if (pos == 0 || rnd.next(2) == 0) {\n                s += 'R';\n                pos++;\n            } else {\n                s += 'L';\n                pos--;\n            }\n        }\n    } else if (type == \"max_changes\") {\n        for (int i = 0; i < n; i++) {\n            s[i] = (i % 2 == 0) ? 'L' : 'R';\n        }\n    } else if (type == \"single_L\") {\n        s = string(n, 'R');\n        int idx = rnd.next(n);\n        s[idx] = 'L';\n    } else if (type == \"single_R\") {\n        s = string(n, 'L');\n        int idx = rnd.next(n);\n        s[idx] = 'R';\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) {\n            s[i] = (rnd.next(2) == 0) ? 'L' : 'R';\n        }\n    }\n\n    // Output the sequence\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, ' ');\n\n    if (type == \"all_L\") {\n        s = string(n, 'L');\n    } else if (type == \"all_R\") {\n        s = string(n, 'R');\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; i++) {\n            s[i] = (i % 2 == 0) ? 'L' : 'R';\n        }\n    } else if (type == \"palindrome\") {\n        for (int i = 0; i < (n + 1) / 2; i++) {\n            s[i] = (rnd.next(2) == 0) ? 'L' : 'R';\n            s[n - i - 1] = s[i];\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            s[i] = (rnd.next(2) == 0) ? 'L' : 'R';\n        }\n    } else if (type == \"long_run_L\") {\n        int m = opt<int>(\"m\", 1);\n        for (int i = 0; i < n; i++) {\n            s[i] = ((i / m) % 2 == 0) ? 'L' : 'R';\n        }\n    } else if (type == \"long_run_R\") {\n        int m = opt<int>(\"m\", 1);\n        for (int i = 0; i < n; i++) {\n            s[i] = ((i / m) % 2 == 0) ? 'R' : 'L';\n        }\n    } else if (type == \"return_to_start\") {\n        int pos = 0;\n        s.clear();\n        for (int i = 0; i < n; i++) {\n            if (pos == 0 || rnd.next(2) == 0) {\n                s += 'R';\n                pos++;\n            } else {\n                s += 'L';\n                pos--;\n            }\n        }\n    } else if (type == \"max_changes\") {\n        for (int i = 0; i < n; i++) {\n            s[i] = (i % 2 == 0) ? 'L' : 'R';\n        }\n    } else if (type == \"single_L\") {\n        s = string(n, 'R');\n        int idx = rnd.next(n);\n        s[idx] = 'L';\n    } else if (type == \"single_R\") {\n        s = string(n, 'L');\n        int idx = rnd.next(n);\n        s[idx] = 'R';\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) {\n            s[i] = (rnd.next(2) == 0) ? 'L' : 'R';\n        }\n    }\n\n    // Output the sequence\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Smallest possible input\n./gen -n 1 -type all_L\n./gen -n 1 -type all_R\n./gen -n 1 -type random\n\n# Small inputs\n./gen -n 10 -type all_L\n./gen -n 10 -type all_R\n./gen -n 10 -type random\n./gen -n 10 -type alternating\n./gen -n 10 -type palindrome\n\n# Medium inputs\n./gen -n 1000 -type all_L\n./gen -n 1000 -type all_R\n./gen -n 1000 -type random\n./gen -n 1000 -type alternating\n./gen -n 1000 -type palindrome\n\n# Large inputs\n./gen -n 100000 -type all_L\n./gen -n 100000 -type all_R\n./gen -n 100000 -type random\n./gen -n 100000 -type alternating\n./gen -n 100000 -type palindrome\n\n# Largest inputs\n./gen -n 1000000 -type all_L\n./gen -n 1000000 -type all_R\n./gen -n 1000000 -type random\n./gen -n 1000000 -type alternating\n./gen -n 1000000 -type palindrome\n\n# Edge cases\n./gen -n 999999 -type random\n./gen -n 999999 -type palindrome\n\n# Return to start\n./gen -n 1000000 -type return_to_start\n\n# Maximum direction changes\n./gen -n 1000000 -type max_changes\n\n# Single 'L' or 'R' among the opposite\n./gen -n 1000000 -type single_L\n./gen -n 1000000 -type single_R\n\n# Long runs\n./gen -n 1000000 -type long_run_L -m 1\n./gen -n 1000000 -type long_run_L -m 1000\n./gen -n 1000000 -type long_run_L -m 100000\n./gen -n 1000000 -type long_run_R -m 1\n./gen -n 1000000 -type long_run_R -m 1000\n./gen -n 1000000 -type long_run_R -m 100000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:09.012575",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "405/A",
      "title": "A. Gravity Flip",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains an integer n (1 ≤ n ≤ 100), the number of the columns in the box. The next line contains n space-separated integer numbers. The i-th number ai (1 ≤ ai ≤ 100) denotes the number of cubes in the i-th column.",
      "output_spec": "OutputOutput n integer numbers separated by spaces, where the i-th number is the amount of cubes in the i-th column after the gravity switch.",
      "sample_tests": "ExamplesInputCopy43 2 1 2OutputCopy1 2 2 3 InputCopy32 3 8OutputCopy2 3 8",
      "description": "A. Gravity Flip\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains an integer n (1 ≤ n ≤ 100), the number of the columns in the box. The next line contains n space-separated integer numbers. The i-th number ai (1 ≤ ai ≤ 100) denotes the number of cubes in the i-th column.\n\nOutputOutput n integer numbers separated by spaces, where the i-th number is the amount of cubes in the i-th column after the gravity switch.\n\nInputCopy43 2 1 2OutputCopy1 2 2 3 InputCopy32 3 8OutputCopy2 3 8\n\nInputCopy43 2 1 2\n\nOutputCopy1 2 2 3\n\nInputCopy32 3 8\n\nOutputCopy2 3 8\n\nNoteThe first example case is shown on the figure. The top cube of the first column falls to the top of the last column; the top cube of the second column falls to the top of the third column; the middle cube of the first column falls to the top of the second column.In the second example case the gravity switch does not change the heights of the columns.",
      "solutions": [
        {
          "title": "Codeforces Round #238 - Codeforces",
          "content": "Hello everyone!Codeforces round #238 will start today at 19:30 in Moscow time. The round will be held in both divisions.The round was prepared by me and cfk. This is the 4th round for me and the 2nd for Krisjanis. I think the problems this time are rather unusual and maybe even surprising. We have no doubt that everyone will find a problem that suits their taste! But you have to find it. (:As always, thanks to Mikhail Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems, and Maria Belova (Delinur) for translating the statements. Big thanks to Gerald Agapov (Gerald) for helping in preparation of the contest. Me and Gerald had a chance to talk about the problems onsite during the Petrozavodsk winter camp, which I think was very productive. We wish you a very exciting round!UPD1: Score distribution:DivI: 500 1000 2000 2000 2500DivII: 500 1000 1500 2000 3000The scoring for the problems is relative, so that the cost of each problem would be a multiple of 500 and closer to the objective estimate. Don't be afraid, the problems are not really that hard. (:UPD2: Congratulations to the winners!DivI: al13n Shef scott_wu sillycross Komaki DivII: NelsonMondialu L_Ecry aaaaAaaaaAaaaaAaaaaA xorfire Hec UPD3: Excellent round statistics from DmitriyH.UPD4: The contest tutorial is published here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11153",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1309
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces",
          "content": "405A - Gravity FlipObserve that in the final configuration the heights of the columns are in non-decreasing order. Also, the number of columns of each height remains the same. This means that the answer to the problem is the sorted sequence of the given column heights.Solution complexity: O(n), since we can sort by counting.405B - Domino EffectIf the first pushed domino from the left was pushed to the left at position l, all dominoes at prefix [1;l] fall down, otherwise let l be 0. Similarly, if the first pushed domino from the right was pushed to the right at position r, all dominoes at suffix [r;n] also fall down, otherwise let r be n + 1. Now, in the segment (l;r) there will remain vertical dominoes and blocks of dominoes supported by the equal forces from both sides.When does a domino at position p in segment (l, r) remains standing vertically? One way is that it is not pushed by any other domino. This could be easily checked by looking at the pushed dominoes closest to p (from both sides). It is pushed by dominoes, only if the closest from the left was pushed to the right, and the closest from the right was pushed to the left. Suppose these dominoes are at positions x and y, x < p < y. Then, the only way that the domino is still standing is if it is positioned at the center of the block [x;y], which could be checked by .Solution complexity: O(n) / O(n2), depends on implementation.406A - Unusual ProductWritten as a formula, the problem asks to find the value of Suppose that i ≠ j. Then the sum contains summands AijAji and AjiAij. Since the sum is taken modulo 2, these summands together give 0 to the sum. It follows that the expression is always equal to the sum of the diagonal bits: Now, each query of type 1 and 2 flips the value of exactly one bit on the diagonal. Thus we can calculate the unusual product of the original matrix, and flip its value after each query of type 1 and 2.Solution complexity: O(n + q), if we don't take the reading of the input into account... :)406B - Toy SumLet's define the symmetric number of k to be s + 1 - k. Since in this case s is an even number, k ≠ s - k.Note that (k - 1) + (s + 1 - k) = s, i.e., the sum of a number and its symmetric is always s. Let's process the given members x of X. There can be two cases: If the symmetric of x does not belong to X, we add it to Y. Both give equal values to the respective sums: x - 1 = s - (s + 1 - x). The symmetric of x belongs to X. Then we pick any y that neither y and symmetric of y belong to X, and add them to Y. Both pairs give equal values to the respective sums, namely s. How to prove that in the second step we can always find such y? Let the number of symmetric pairs that were processed in the step 1 be a, then there remain other pairs. Among them, for pairs both members belong to X, and for other pairs none of the members belong to X. To be able to pick the same number of pairs for Y, as there are in X, we should have which is equivalent to , as given in the statement.Solution complexity: O(s) / O(n).406C - Graph CuttingIt can be proved that only graphs with an odd number of edges cannot be partitioned into path of length 2. We will construct a recursive function that solves the problem and also serves as a proof for this statement.The function partition(v) will operate on non-blocked edges. It will partition the component of vertex v connected by the non-blocked edges into paths of length 2. If this component has an odd number of edges, the function will partition all the edges of the component, except one edge (u, v); the function then will return vertex u, expecting that the parent function call will assign it to some path.The function works as follows: find all vertices that are adjacent to v by the non-blocked edges, call this set adjacent. Then block all the edges from this set vertices to v. For each u in adjacent, call partition(u). Suppose partition(u) returned a vertex w. That means we can pair it into the path (v, u, w). Otherwise, if partition(u) does not return anything, we add u to unpaired, since the edge (v, u) is not yet in any path. We can pair any two vertices of this set u, w into a single path (u, v, w). We pair as much of them as possible in any order. If from this set a single vertex, u, is left unpaired, the function will return u. Otherwise the function will not return anything.The function could be implemented as a single DFS: partition(v) :\n adjacent = { u | not blocked[(u,v)] }\n for(u : adjacent)\n blocked[(u,v)] = true\n\n unpaired = {}\n for(u : adjacent)\n int w = partition(u)\n if(w = 0)\n add(unpaired, u)\n else\n print(v,u,w)\n\n while(size(unpaired) >= 2)\n int u = pop(unpaired)\n int w = pop(unpaired)\n print(u,v,w)\n\n if(not empty(unpaired))\n return pop(unpaired)\n else\n return 0Solution complexity: O(n + m).406D - Hill ClimbingNote that the path of each hill climber is strictly convex in any case. Let's draw the paths from all hills to the rightmost hill. Then these paths form a tree with the \"root\" at the top of the rightmost hill. We can apply the Graham scan from the right to the left to find the edges of this tree. Each pop and insert in the stack corresponds to a single edge in the tree.Now it is easy to see that for each team of climbers, we should calculate the number of the lowest common ancestor for the corresponding two vertices in the tree. The size if the tree is n, so each query works in .Solution complexity: .406E - Hamming TriplesLet's look at the Hamming graph of all possible distinct 2n strings, where each two strings are connected by an edge with length equal to the Hamming distance between these strings. We can observe that this graph has a nice property: if we arrange the vertices cyclically as a regular 2n-gon with a side length of 1, then the Hamming distance between two strings is the length of the shortest route between these vertices on the perimeter of the polygon.For example, the figure shows the graph for n = 3. The gray edges have length 1, the orange edges have length 2 and the blue edges have length 3. That is the corresponding Hamming distance.Now, we can convert each string coded by a pair (s, f) to an integer (f + 1)·n - s. The new numbers will be 0, 1, ..., 2n - 1 and correspond to the same cyclical order on the perimeter of the polygon. The given strings are mapped to some subset of the vertices. Now we have to find the number of triangles (possibly degenerate) with maximal perimeter in this subgraph. It will be useful to keep the new converted numbers sorted.First, we can figure out what this perimeter could be. If there exists a diameter in the full graph, so that all of the points are on one side of the diameter, the perimeter is 2d, where d is the length of the longest edge:Then any triangle with two vertices at the longest edge points and the third one being any point has the maximal perimeter. Since the numbers are sorted, the longest edge in this case will be produced by two cyclically adjacent elements, which is not hard to find.If for any diameter this does not hold, then the maximal perimeter is 2n. This can be proved by taking two different points a, b and drawing two diameters with them as endpoints; since it is not the previous case, there shoud be a third point c in area where the perimeter of triangle a, b, c is 2n.The tricky part is to count the triples in this case. We do this by working with the diameter (0, n). There can be several cases: A maximum triangle has vertices 0 and n. This a simple case: with any other vertex as the third the triangle has perimeter 2n. A maximum triangle has vertex 0, but not n. Then the second vertex should be in interval [0, n), and the third in interval (n + 1, 2n - 1], and the clockwise distance between the second and the third should not exceed n (since then the perimeter of the triangle would be less than 2n). We count the number of such triples iterating two pointers (one in each of these intervals). For each pointer in the first interval, all points from n + 1 till the second pointer will make a maximal perimeter triangle. We similarly solve the case where the maximal triangle has vertex n, but not 0. The maximal triangle does not have 0 or n as its vertices. Then one vertex of the triangle should be on one side of diameter (0, n), and two should be on the opposite side. To count them, we iterate a vertex pointer on the first side, say, (0, n); let the diametrally opposite vertex on the opposite side be x. Then the second vertex can be any in [n + 1, s], and the third can be any of the [s, 2n - 1]. It is easy to calculate these numbers using partial sums on the circle. Note that s can be both the second and the third vertex (since strings can repeat). So we iterate this pointer over all one side vertices and update the answer. Similarly we solve the case where a single vertex is on the other side, and two on this side. One only needs to be careful with the formulas in each case.Solution complexity: , because of the sorting.Post ScriptumWhat were your solutions? Feel free to share any solutions or thoughts! For example, was there a solution to DivI E simpler than in this tutorial?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11186",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 405\\s*A"
          },
          "content_length": 9148
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #238 - Codeforces - Code 1",
          "code": "|   \n       |\n       |\n       |\n  |    |\n| |  | | \n1 2  3 4\n(In reversed order, from right to left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 2",
          "code": "|   \n       |\n       |\n       |\n  |    |\n| |  | | \n1 2  3 4\n(In reversed order, from right to left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 3",
          "code": "Push 1\nmake_edge(1,2) (i will not write these from now on)\nPush 2\ntry to pop the stack -> verify whether or not line segment 1 3 passes through hill 2 -> no -> no pop\nPush 3\ntry to pop the stack -> 2 4 is above 3, so we pop the stack\ntry to pop the stack -> 4 1 is above 2, so we pop the stack\n(make edge 1,4)\nPush 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 4",
          "code": "Push 1\nmake_edge(1,2) (i will not write these from now on)\nPush 2\ntry to pop the stack -> verify whether or not line segment 1 3 passes through hill 2 -> no -> no pop\nPush 3\ntry to pop the stack -> 2 4 is above 3, so we pop the stack\ntry to pop the stack -> 4 1 is above 2, so we pop the stack\n(make edge 1,4)\nPush 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 5",
          "code": "if(((1ll*stack[poz].x-stack[poz-1].x)*(1ll*v[i].h-stack[poz-1].h))<((1ll*stack[poz].h &mdash; 1ll*stack[poz-1].h)*(1ll*v[i].x-1ll*stack[poz-1].x)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 6",
          "code": "if(((1ll*stack[poz].x-stack[poz-1].x)*(1ll*v[i].h-stack[poz-1].h))<((1ll*stack[poz].h &mdash; 1ll*stack[poz-1].h)*(1ll*v[i].x-1ll*stack[poz-1].x)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 7",
          "code": "cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 8",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 9",
          "code": "ios :: sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 10",
          "code": "cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 11",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 12",
          "code": "string s; s.reserve(100005);\n\nfor (int i = 0; i < n; i++)\n{\n    cin >> s;\n\n    // do something\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 13",
          "code": "string s; s.reserve(100005);\n\nfor (int i = 0; i < n; i++)\n{\n    cin >> s;\n\n    // do something\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 14",
          "code": "#define dibs reserve",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 15",
          "code": "(X +- (2*Y))%2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 16",
          "code": "FastScanner",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 17",
          "code": "java.io.BufferedReader",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 1",
          "code": "partition(v)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 2",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 3",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 4",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 5",
          "code": "partition(v) :\n    adjacent = { u | not blocked[(u,v)] }\n    for(u : adjacent)\n        blocked[(u,v)] = true\n\n    unpaired = {}\n    for(u : adjacent)\n        int w = partition(u)\n        if(w = 0)\n            add(unpaired, u)\n        else\n            print(v,u,w)\n\n    while(size(unpaired) >= 2)\n        int u = pop(unpaired)\n        int w = pop(unpaired)\n        print(u,v,w)\n\n    if(not empty(unpaired))\n        return pop(unpaired)\n    else\n        return 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 6",
          "code": "partition(v) :\n    adjacent = { u | not blocked[(u,v)] }\n    for(u : adjacent)\n        blocked[(u,v)] = true\n\n    unpaired = {}\n    for(u : adjacent)\n        int w = partition(u)\n        if(w = 0)\n            add(unpaired, u)\n        else\n            print(v,u,w)\n\n    while(size(unpaired) >= 2)\n        int u = pop(unpaired)\n        int w = pop(unpaired)\n        print(u,v,w)\n\n    if(not empty(unpaired))\n        return pop(unpaired)\n    else\n        return 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 7",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, **u**)\n        **else**\n**            print(v,u,w)**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 8",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, **u**)\n        **else**\n**            print(v,u,w)**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 9",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 10",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 11",
          "code": "if(w = 0)\n    add(unpaired, u)\nelse\n    print(v,u,w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 12",
          "code": "if(w = 0)\n    add(unpaired, u)\nelse\n    print(v,u,w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is within the allowed constraints\n    ensure(1 <= n && n <= 100);\n\n    vector<int> a(n);\n\n    if (type == \"same\") {\n        // All ai are the same random value between 1 and 100\n        int val = rnd.next(1, 100);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"sorted_asc\") {\n        // ai are sorted in increasing order\n        a[0] = rnd.next(1, 10);\n        for (int i = 1; i < n; ++i) {\n            int inc = rnd.next(0, 10);\n            a[i] = a[i - 1] + inc;\n            if (a[i] > 100) a[i] = 100;\n        }\n    } else if (type == \"sorted_desc\") {\n        // ai are sorted in decreasing order\n        a[0] = rnd.next(90, 100);\n        for (int i = 1; i < n; ++i) {\n            int dec = rnd.next(0, 10);\n            a[i] = a[i - 1] - dec;\n            if (a[i] < 1) a[i] = 1;\n        }\n    } else if (type == \"reverse_order\") {\n        // Random integers sorted in decreasing order\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100);\n        }\n        sort(a.begin(), a.end(), greater<int>());\n    } else if (type == \"all_ones\") {\n        // All ai are 1\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"alternating_high_low\") {\n        // ai alternate between 100 and 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 100 : 1;\n        }\n    } else if (type == \"random_small_ai\") {\n        // Random integers between 1 and 10\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"random_large_ai\") {\n        // Random integers between 90 and 100\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(90, 100);\n        }\n    } else {\n        // Default case: random integers between 1 and 100\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is within the allowed constraints\n    ensure(1 <= n && n <= 100);\n\n    vector<int> a(n);\n\n    if (type == \"same\") {\n        // All ai are the same random value between 1 and 100\n        int val = rnd.next(1, 100);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"sorted_asc\") {\n        // ai are sorted in increasing order\n        a[0] = rnd.next(1, 10);\n        for (int i = 1; i < n; ++i) {\n            int inc = rnd.next(0, 10);\n            a[i] = a[i - 1] + inc;\n            if (a[i] > 100) a[i] = 100;\n        }\n    } else if (type == \"sorted_desc\") {\n        // ai are sorted in decreasing order\n        a[0] = rnd.next(90, 100);\n        for (int i = 1; i < n; ++i) {\n            int dec = rnd.next(0, 10);\n            a[i] = a[i - 1] - dec;\n            if (a[i] < 1) a[i] = 1;\n        }\n    } else if (type == \"reverse_order\") {\n        // Random integers sorted in decreasing order\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100);\n        }\n        sort(a.begin(), a.end(), greater<int>());\n    } else if (type == \"all_ones\") {\n        // All ai are 1\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"alternating_high_low\") {\n        // ai alternate between 100 and 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 100 : 1;\n        }\n    } else if (type == \"random_small_ai\") {\n        // Random integers between 1 and 10\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"random_large_ai\") {\n        // Random integers between 90 and 100\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(90, 100);\n        }\n    } else {\n        // Default case: random integers between 1 and 100\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type same\n./gen -n 1 -type all_ones\n./gen -n 1 -type random_large_ai\n\n./gen -n 2 -type random\n./gen -n 2 -type sorted_asc\n./gen -n 2 -type sorted_desc\n./gen -n 2 -type alternating_high_low\n\n./gen -n 10 -type random\n./gen -n 10 -type sorted_asc\n./gen -n 10 -type sorted_desc\n./gen -n 10 -type reverse_order\n./gen -n 10 -type same\n./gen -n 10 -type all_ones\n./gen -n 10 -type random_small_ai\n./gen -n 10 -type random_large_ai\n./gen -n 10 -type alternating_high_low\n\n./gen -n 50 -type random\n./gen -n 50 -type sorted_asc\n./gen -n 50 -type sorted_desc\n./gen -n 50 -type reverse_order\n./gen -n 50 -type same\n./gen -n 50 -type all_ones\n./gen -n 50 -type random_small_ai\n./gen -n 50 -type random_large_ai\n./gen -n 50 -type alternating_high_low\n\n./gen -n 100 -type random\n./gen -n 100 -type sorted_asc\n./gen -n 100 -type sorted_desc\n./gen -n 100 -type reverse_order\n./gen -n 100 -type same\n./gen -n 100 -type all_ones\n./gen -n 100 -type random_small_ai\n./gen -n 100 -type random_large_ai\n./gen -n 100 -type alternating_high_low\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:11.183992",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "405/B",
      "title": "B. Эффект домино",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано единственное целое число n (1 ≤ n ≤ 3000) — количество доминошек в ряду. В следующей строке записана строка s длины n. При этом, i-й символ строки si равняется:  «L», если Крис изначально толкнул i-ю доминошку влево;  «R», если Крис изначально толкнул i-ю доминошку вправо;  «.», если Крис изначально не толкнул i-ю доминошку. Гарантируется, что если si = sj = «L» и i < j, то существует такой индекс k, что i < k < j и sk = «R»; если si = sj = «R» и i < j, тогда существует такой индекс k, что i < k < j и sk = «L».",
      "output_spec": "Выходные данныеВыведите единственное целое число — количество доминошек, которые останутся в конце концов вертикальными.",
      "sample_tests": "ПримерыВходные данныеСкопировать14.L.R...LR..L..Выходные данныеСкопировать4Входные данныеСкопировать5R....Выходные данныеСкопировать0Входные данныеСкопировать1.Выходные данныеСкопировать1",
      "description": "B. Эффект домино\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано единственное целое число n (1 ≤ n ≤ 3000) — количество доминошек в ряду. В следующей строке записана строка s длины n. При этом, i-й символ строки si равняется:  «L», если Крис изначально толкнул i-ю доминошку влево;  «R», если Крис изначально толкнул i-ю доминошку вправо;  «.», если Крис изначально не толкнул i-ю доминошку. Гарантируется, что если si = sj = «L» и i < j, то существует такой индекс k, что i < k < j и sk = «R»; если si = sj = «R» и i < j, тогда существует такой индекс k, что i < k < j и sk = «L».\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — количество доминошек, которые останутся в конце концов вертикальными.\n\nВыходные данные\n\nВходные данныеСкопировать14.L.R...LR..L..Выходные данныеСкопировать4Входные данныеСкопировать5R....Выходные данныеСкопировать0Входные данныеСкопировать1.Выходные данныеСкопировать1\n\nВходные данныеСкопировать14.L.R...LR..L..\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5R....\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1.\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПервый пример показан на рисунке. Четыре доминошки, оставшиеся стоять вертикально, выделены оранжевым цветом.Во втором тестовом примере все доминошки падают, так как первая доминошка падает на все остальные.В последнем примере, единственную доминошку не толкали ни в одном направлении.",
      "solutions": [
        {
          "title": "Codeforces Round #238 - Codeforces",
          "content": "Всем привет!Сегодня в 19:30 по Московскому времени состоится раунд Codeforces #238. Контест пройдёт в обоих дивизиях.Раунд был подготовлен мной и cfk. Это мой 4-ый раунд и 2-ой раунд Кришьяниса. В этот раз, по-моему, задачи весьма необычные и, может, даже неожиданные. Мы уверены, что любой участник(ца) найдёт себе задачу по вкусу! Но нужно её найти. (:Как всегда, спасибо Михаилу Мирзаянову (MikeMirzayanov) за проект Codeforces и систему Polygon, и Марии Беловой (Delinur) за перевод условий. Большое спасибо Геральду Агапову (Gerald) за помощь в подготовке контеста. Мне и Геральду повезло обсудить задачи очно во время зимних Петрозаводских сборов, что, по-моему, оказалось очень полезно.Мы желаем вам захватывающего раунда!UPD1: Распределение баллов:DivI: 500 1000 2000 2000 2500DivII: 500 1000 1500 2000 3000Баллы выставлены относительно, чтобы стоимость каждой задачи делилась на 500, и была бы ближе к объективной оценке. Не пугайтесь, на самом деле задачи не настолько сложные. (:UPD2: Поздравляем победителей!DivI: al13n Shef scott_wu sillycross Komaki DivII: NelsonMondialu L_Ecry aaaaAaaaaAaaaaAaaaaA xorfire Hec UPD3: Замечательная статистика раунда от DmitriyH.UPD4: Разбор опубликован здесь.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/11153",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1207
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces",
          "content": "405A - Переключение гравитацииЗаметим, что в конечном расположении все высоты столбиков расположены в неубывающем порядке. Также, количество столбиков каждой высоты остаётся неизменным. Это означает, что ответом является упорядоченная последовательность данных высот столбиков.Сложность решения: O(n), так как можно упорядочить подсчётом.405B - Эффект доминоЕсли самая первая толкнутая доминошка слева была толкнута влево на позиции l, все доминошки на префиксе [1;l] падают, иначе пусть l будет 0. Аналогично, если самая последняя толкнутая доминошка была толкнута направо на позиции r, все доминошки на суффиксе [r;n] падают, иначе пусть r будет n + 1. Теперь, на отрезке (l;r) остаются вертикально стоящие доминошки, а также блоки домино, поддерживающиеся одинаковыми силами с обеих сторон.Когда доминошка на позиции p на отрезке (l, r) остаётся стоять вертикально? В одном случае, её не толкает ни одна другая доминошка. Это можно легко проверить, посмотрев на ближайшие к p толкнутые доминошки (с обеих сторон). Она была затронута другими домино, если самая близкая толкнутая доминошка слева была толкнута направо и самая близкая толкнутая доминошка справа была толкнута влево. Допустим, эти доминошки находятся на позициях x и y, x < p < y. Тогда, единственная возможность для доминошки остаться вертикально тогда, когда она находится в центре блока [x;y], что можно проверить выражением .Сложность решения: O(n) / O(n2), что зависит от реализации.406A - Необычное произведениеЕсли записать в виде формулы искомое произведение в задаче, получаем Допустим, что i ≠ j. Тогда сумма содержит слагаемые AijAji и AjiAij. Так как сумма всегда берётся по модулю 2, вместе эти слагаемые дают 0 к сумме. Из этого следует, что выражение всегда равняется сумме битов на диагонали: Теперь, каждый запрос типа 1 и 2 меняет значение ровно одного элемента на диагонали. Поэтому мы можем посчитать необычное произведение изначальной матрицы, и после каждого запроса типа 1 и 2 менять его значение на противоположное.Сложность решения: O(n + q), если не брать во внимание ввод... :)406B - Игрушечная суммаОпределим для числа k его симметричное число как s + 1 - k. Так как в задаче s чётное число, k ≠ s - k.Заметим, что (k - 1) + (s + 1 - k) = s, т.е., сумма числа и его симметричного всегда равно s. Будем обрабатывать все числа x множества X по порядку. Различаем два случая: Если симметричное x не принадлежит X, добавим его к Y. Оба числа дают одинаковые значения к соответствующим суммам: x - 1 = s - (s + 1 - x). Симметричное x принадлежит X. Тогда возьмём любое y такое, что ни y, ни симметричное y не принадлежат X, и добавим их к Y. Обе пары дают одинаковые значения к соответствующим суммам, а именно s. Как доказать, что во втором случае мы всегда сможем найти такое y? Пусть количество симметричных пар, которые были обработаны в первом случае, равно a, тогда остаются других пар. Среди них, для пар оба числа принадлежат X, а для других пар никакие из чисел не принадлежат X. Чтобы выбрать такое что количество пар для Y, как и в X, должно выполняться что равносильно , как и дано в условии.Сложность решения: O(s) / O(n).406C - Разрез графаМожно доказать, что только графы с нечётным количеством рёбер нельзя разбить на пути длины 2. Мы построим рекурсивную функцию, решающую задачу, которая и будет служить доказательством этого утверждения.Функция partition(v) будет работать на незаблокированных рёбрах. Она разбивает компоненту вершины v, связную по незаблокированным рёбрам, на пути длины 2. Если компонента имеет нечётное количество рёбер, функция разобьёт все рёбра компоненты, кроме одного ребра (u, v); тогда функция вернёт вершину u, ожидая, что предыдущий вызов функции присвоит это ребро какому-нибудь пути.Функция работает следующим образом: найдём все вершины, соседние с v по незаблокированным рёбрам, назовём это множество adjacent. Далее заблокируем все рёбра из этих вершин в v. Для каждой u в adjacent, вызовем partition(u). Допустим, что вызов partition(u) вернул вершину w. Это значит, что мы можем присвоить её в путь (v, u, w). Иначе, если partition(u) ничего не вернул, добавим u к unpaired, потому что ребро (v, u) ещё не присвоено ни одному пути. Мы можем объединить в путь любые две вершины этого множества u, w в один путь (u, v, w). Спарим как можно больше таких вершин в любом порядке. Если из этого множества осталась только одна вершина, u, то функция вернёт u. В противном случае функция ничего не возвращает.Функцию можно реализовать всего одним DFS: partition(v) :\n adjacent = { u | not blocked[(u,v)] }\n for(u : adjacent)\n blocked[(u,v)] = true\n\n unpaired = {}\n for(u : adjacent)\n int w = partition(u)\n if(w = 0)\n add(unpaired, u)\n else\n print(v,u,w)\n\n while(size(unpaired) >= 2)\n int u = pop(unpaired)\n int w = pop(unpaired)\n print(u,v,w)\n\n if(not empty(unpaired))\n return pop(unpaired)\n else\n return 0Сложность решения: O(n + m).406D - СкалолазаниеЗаметим, что каждый путь скалолаза выпуклый в любом случае. Проведём пути из всех скал до последней скалы. Тогда эти пути образуют дерево с «корнем» в вершине последней скалы. Мы можем применить алгоритм Грэхема справа налево, чтобы найти рёбра этого дерева. Каждое удаление и добавление в стеке соответствует ровно одному ребру в дереве.Теперь несложно видеть, что для каждой команды скалолазов, нам нужно найти номер наименьшего общего предка для соответствующей пары вершин в дереве. Так как размер дерева равен n, каждый запрос обрабатывается за .Сложность решения: .406E - Тройки ХеммингаДавайте рассмотрим хэммингов граф из всех различных 2n строк, где каждые две строки соединены ребром длины, равному расстоянию Хэмминга между этими строками. Мы можем заметить, что этот граф обладает годным свойством: если упорядочить все вершины циклически по правильному 2n-угольнику со стороной длины 1, расстояние Хэмминга для каждых двух строк равняется длине кратчайшего пути между этими вершинами на периметре этого многоугольника.Например, на рисунке изображён такой граф для n = 3. Серые рёбра имеют длину 1, оранжевые рёбра имеют длину 2, синие рёбра имеют длину 3. Это равняется соответствующему расстоянию Хэмминга.Теперь, мы можем преобразовать каждую строку, закодированную парой чисел (s, f), в целое число (f + 1)·n - s. Новые числа будут среди 0, 1, ..., 2n - 1 и соотноситься с тем же циклическим порядком на периметре многоугольника. Данные строки переходят в какой-то набор вершин. Теперь нам нужно найти количество треугольников (возможно, дегенерированных) с наибольшим периметром в этом подграфе. Далее будет полезно упорядочить преобразованные числа.Для начала, можно попробовать понять, каким может быть этот периметр. Если существует такой диаметр в полном графе, что все данные точки находятся по одну сторону диаметра, периметр будет равен 2d, где d является значением самого длинного ребра:Тогда любой треугольник с двумя вершинами на этом ребре и третьим в любой из остальных точек будет иметь наибольший периметр. Так как числа упорядочены, самое длинное ребро в этом случае будет образовано двумя циклически рядом стоящими элементами, что не трудно найти.Если для любого диаметра это не выполняется, тогда наибольший периметр равен 2n. Это можно доказать, взяв две различных точки a, b, и проведя два диаметра из этих точек как концов; так как это не предыдущий случай, должна быть третья точка c в месте, где периметр треугольника a, b, c равняется 2n.Самая хитрая часть и есть посчитать тройки в этом случае. Мы делаем это, работая с диаметром (0, n). Всего может быть несколько случаев: Наибольший треугольник содержит обе вершины 0 и n. Это простой случай: с любой другой вершиной как третьей такой треугольник имеет периметр 2n. Наибольший треугольник содержит вершину 0, но не n. Тогда вторая вершина должна находится на отрезке [0, n), а третья на отрезке (n + 1, 2n - 1], и расстояние по часовой стрелке между второй и третьей вершинами не должно превышать n (в противном случае периметр треугольника был бы меньше, чем 2n). Мы считаем количество таких троек, двигая два указателя (по одному на каждый из этих отрезков). Для каждого указателя в первом отрезке, все точки, начиная с n + 1 до второго указателя образуют наибольший треугольник. Аналогично мы решаем случай, когда треугольник содержит n, но не 0. Наибольший треугольник не содержит ни 0, ни n как вершины. Тогда одна вершина треугольника должна находится на одной стороне диаметра (0, n), а две остальные на другой стороне. Чтобы посчитать их, будем двигать указатель на первую вершину на одной стороне, скажем, (0, n); обозначим диаметрально противоположную вершину за x. Тогда вторая вершина может быть любой на отрезке [n + 1, s], а третья может быть любой на [s, 2n - 1]. Количество этих точек легко посчитать, используя частичные суммы на круге. Заметьте, что s может быть как второй, так и третьей вершиной одновременно (строки могут повторяться). Тогда мы двигаем этот указатель через все вершины одной стороны и обновляем ответ. Аналогично мы решаем случай, когда первая вершина на второй стороне, а обе других на противоположной. Остаётся только быть осторожными с формулами в каждом случае.Сложность решения: из-за сортировки.Post ScriptumКакими были ваши решения? Не стесняйтесь поделиться любыми решениями или мыслями! Например, было ли в DivI E решение, проще авторского?",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/11186",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 405\\s*B"
          },
          "content_length": 9269
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #238 - Codeforces - Code 1",
          "code": "|   \n       |\n       |\n       |\n  |    |\n| |  | | \n1 2  3 4\n(In reversed order, from right to left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 2",
          "code": "|   \n       |\n       |\n       |\n  |    |\n| |  | | \n1 2  3 4\n(In reversed order, from right to left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 3",
          "code": "Push 1\nmake_edge(1,2) (i will not write these from now on)\nPush 2\ntry to pop the stack -> verify whether or not line segment 1 3 passes through hill 2 -> no -> no pop\nPush 3\ntry to pop the stack -> 2 4 is above 3, so we pop the stack\ntry to pop the stack -> 4 1 is above 2, so we pop the stack\n(make edge 1,4)\nPush 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 4",
          "code": "Push 1\nmake_edge(1,2) (i will not write these from now on)\nPush 2\ntry to pop the stack -> verify whether or not line segment 1 3 passes through hill 2 -> no -> no pop\nPush 3\ntry to pop the stack -> 2 4 is above 3, so we pop the stack\ntry to pop the stack -> 4 1 is above 2, so we pop the stack\n(make edge 1,4)\nPush 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 5",
          "code": "if(((1ll*stack[poz].x-stack[poz-1].x)*(1ll*v[i].h-stack[poz-1].h))<((1ll*stack[poz].h &mdash; 1ll*stack[poz-1].h)*(1ll*v[i].x-1ll*stack[poz-1].x)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 6",
          "code": "if(((1ll*stack[poz].x-stack[poz-1].x)*(1ll*v[i].h-stack[poz-1].h))<((1ll*stack[poz].h &mdash; 1ll*stack[poz-1].h)*(1ll*v[i].x-1ll*stack[poz-1].x)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 7",
          "code": "if (tp==3){av.push_back(res);}\n\nfor (int i=0;i<av.size();i++)\n{\n cout<<av[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 8",
          "code": "if (tp==3){av.push_back(res);}\n\nfor (int i=0;i<av.size();i++)\n{\n cout<<av[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 9",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 10",
          "code": "scanf/printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 11",
          "code": "cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 12",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 13",
          "code": "ios :: sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 14",
          "code": "cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 15",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 16",
          "code": "string s; s.reserve(100005);\n\nfor (int i = 0; i < n; i++)\n{\n    cin >> s;\n\n    // do something\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 17",
          "code": "string s; s.reserve(100005);\n\nfor (int i = 0; i < n; i++)\n{\n    cin >> s;\n\n    // do something\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 18",
          "code": "#define dibs reserve",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 19",
          "code": "(tr(A^2)) mod 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 20",
          "code": "(tr(A^2)) mod 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 21",
          "code": "tr(A^2) mod 2 = (tr(A)*tr(A)) mod 2 = tr(A) mod 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 22",
          "code": "tr(A^2) mod 2 = (tr(A)*tr(A)) mod 2 = tr(A) mod 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 23",
          "code": "Вообще-то, все мои посылки работали ровно за n*n+const*q. Но меня окончательно добил тот факт, что посылка с контеста на Delhi, получившая RE на 3-м тесте, спокойно зашла в в дорешивании при закомменченом закрывании outputа. Всегда искренне полагал, что output надо закрывать, и на тебе - с закрыванием сыпется, а баз него все  ОК.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 24",
          "code": "(X +- (2*Y))%2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 25",
          "code": "FastScanner",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 26",
          "code": "java.io.BufferedReader",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 1",
          "code": "partition(v)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 2",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 3",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 4",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 5",
          "code": "partition(v) :\n    adjacent = { u | not blocked[(u,v)] }\n    for(u : adjacent)\n        blocked[(u,v)] = true\n\n    unpaired = {}\n    for(u : adjacent)\n        int w = partition(u)\n        if(w = 0)\n            add(unpaired, u)\n        else\n            print(v,u,w)\n\n    while(size(unpaired) >= 2)\n        int u = pop(unpaired)\n        int w = pop(unpaired)\n        print(u,v,w)\n\n    if(not empty(unpaired))\n        return pop(unpaired)\n    else\n        return 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 6",
          "code": "partition(v) :\n    adjacent = { u | not blocked[(u,v)] }\n    for(u : adjacent)\n        blocked[(u,v)] = true\n\n    unpaired = {}\n    for(u : adjacent)\n        int w = partition(u)\n        if(w = 0)\n            add(unpaired, u)\n        else\n            print(v,u,w)\n\n    while(size(unpaired) >= 2)\n        int u = pop(unpaired)\n        int w = pop(unpaired)\n        print(u,v,w)\n\n    if(not empty(unpaired))\n        return pop(unpaired)\n    else\n        return 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 7",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, **u**)\n        **else**\n**            print(v,u,w)**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 8",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, **u**)\n        **else**\n**            print(v,u,w)**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 9",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 10",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 11",
          "code": "if(w = 0)\n    add(unpaired, u)\nelse\n    print(v,u,w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 12",
          "code": "if(w = 0)\n    add(unpaired, u)\nelse\n    print(v,u,w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n    string s = inf.readToken();\n    inf.readEoln();\n    ensuref((int)s.length() == n, \"Length of s must be n=%d, but length is %d\", n, (int)s.length());\n    for(int i = 0; i < n; ++i) {\n        ensuref(s[i] == 'L' || s[i] == 'R' || s[i] == '.', \"Invalid character '%c' in s at position %d\", s[i], i+1);\n    }\n    \n    vector<int> cumulative_R(n+1, 0);\n    vector<int> cumulative_L(n+1, 0);\n    \n    for(int i = 0; i < n; ++i) {\n        cumulative_R[i+1] = cumulative_R[i] + (s[i] == 'R' ? 1 : 0);\n        cumulative_L[i+1] = cumulative_L[i] + (s[i] == 'L' ? 1 : 0);\n    }\n    \n    int last_L = -1;\n    for(int i = 0; i < n; ++i) {\n        if(s[i] == 'L') {\n            if(last_L != -1) {\n                int number_of_Rs_between = cumulative_R[i] - cumulative_R[last_L+1];\n                ensuref(number_of_Rs_between >= 1, \"Between positions %d and %d, there must be at least one 'R'\", last_L+2, i+1);\n            }\n            last_L = i;\n        }\n    }\n    \n    int last_R = -1;\n    for(int i = 0; i < n; ++i) {\n        if(s[i] == 'R') {\n            if(last_R != -1) {\n                int number_of_Ls_between = cumulative_L[i] - cumulative_L[last_R+1];\n                ensuref(number_of_Ls_between >=1, \"Between positions %d and %d, there must be at least one 'L'\", last_R+2, i+1);\n            }\n            last_R = i;\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n    string s = inf.readToken();\n    inf.readEoln();\n    ensuref((int)s.length() == n, \"Length of s must be n=%d, but length is %d\", n, (int)s.length());\n    for(int i = 0; i < n; ++i) {\n        ensuref(s[i] == 'L' || s[i] == 'R' || s[i] == '.', \"Invalid character '%c' in s at position %d\", s[i], i+1);\n    }\n    \n    vector<int> cumulative_R(n+1, 0);\n    vector<int> cumulative_L(n+1, 0);\n    \n    for(int i = 0; i < n; ++i) {\n        cumulative_R[i+1] = cumulative_R[i] + (s[i] == 'R' ? 1 : 0);\n        cumulative_L[i+1] = cumulative_L[i] + (s[i] == 'L' ? 1 : 0);\n    }\n    \n    int last_L = -1;\n    for(int i = 0; i < n; ++i) {\n        if(s[i] == 'L') {\n            if(last_L != -1) {\n                int number_of_Rs_between = cumulative_R[i] - cumulative_R[last_L+1];\n                ensuref(number_of_Rs_between >= 1, \"Between positions %d and %d, there must be at least one 'R'\", last_L+2, i+1);\n            }\n            last_L = i;\n        }\n    }\n    \n    int last_R = -1;\n    for(int i = 0; i < n; ++i) {\n        if(s[i] == 'R') {\n            if(last_R != -1) {\n                int number_of_Ls_between = cumulative_L[i] - cumulative_L[last_R+1];\n                ensuref(number_of_Ls_between >=1, \"Between positions %d and %d, there must be at least one 'L'\", last_R+2, i+1);\n            }\n            last_R = i;\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n    string s = inf.readToken();\n    inf.readEoln();\n    ensuref((int)s.length() == n, \"Length of s must be n=%d, but length is %d\", n, (int)s.length());\n    for(int i = 0; i < n; ++i) {\n        ensuref(s[i] == 'L' || s[i] == 'R' || s[i] == '.', \"Invalid character '%c' in s at position %d\", s[i], i+1);\n    }\n    \n    vector<int> cumulative_R(n+1, 0);\n    vector<int> cumulative_L(n+1, 0);\n    \n    for(int i = 0; i < n; ++i) {\n        cumulative_R[i+1] = cumulative_R[i] + (s[i] == 'R' ? 1 : 0);\n        cumulative_L[i+1] = cumulative_L[i] + (s[i] == 'L' ? 1 : 0);\n    }\n    \n    int last_L = -1;\n    for(int i = 0; i < n; ++i) {\n        if(s[i] == 'L') {\n            if(last_L != -1) {\n                int number_of_Rs_between = cumulative_R[i] - cumulative_R[last_L+1];\n                ensuref(number_of_Rs_between >= 1, \"Between positions %d and %d, there must be at least one 'R'\", last_L+2, i+1);\n            }\n            last_L = i;\n        }\n    }\n    \n    int last_R = -1;\n    for(int i = 0; i < n; ++i) {\n        if(s[i] == 'R') {\n            if(last_R != -1) {\n                int number_of_Ls_between = cumulative_L[i] - cumulative_L[last_R+1];\n                ensuref(number_of_Ls_between >=1, \"Between positions %d and %d, there must be at least one 'L'\", last_R+2, i+1);\n            }\n            last_R = i;\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, '.');\n\n    if (type == \"all_dots\") {\n        // All dominoes are not pushed\n        // s is already initialized with '.'\n    } else if (type == \"alternate\") {\n        // Alternate 'L's and 'R's, ensuring constraints\n        vector<int> positions(n);\n        for (int i = 0; i < n; ++i) {\n            positions[i] = i;\n        }\n        // Decide the number of pushes\n        int m = n;\n        // Assign 'L's and 'R's alternately\n        for (int i = 0; i < m; ++i) {\n            if (i % 2 == 0) {\n                s[i] = 'L';\n            } else {\n                s[i] = 'R';\n            }\n        }\n    } else if (type == \"ends_pushed\") {\n        // Push only the first and last dominoes\n        if (n >= 1) {\n            s[0] = 'R';\n            s[n - 1] = 'L';\n        }\n    } else if (type == \"random\") {\n        // Randomly assign pushes ensuring constraints\n        vector<int> positions(n);\n        for (int i = 0; i < n; ++i) {\n            positions[i] = i;\n        }\n        int m = rnd.next(1, n); // Number of pushes\n        shuffle(positions.begin(), positions.end());\n        vector<int> push_positions(positions.begin(), positions.begin() + m);\n        sort(push_positions.begin(), push_positions.end());\n\n        vector<char> pushes;\n        char lastPush = 0;\n        for (size_t i = 0; i < push_positions.size(); ++i) {\n            char push;\n            if (lastPush == 0) {\n                push = rnd.next(0, 1) ? 'L' : 'R';\n            } else {\n                // Alternate pushes to satisfy constraints\n                push = (lastPush == 'L') ? 'R' : 'L';\n            }\n            pushes.push_back(push);\n            lastPush = push;\n        }\n\n        for (size_t i = 0; i < push_positions.size(); ++i) {\n            int pos = push_positions[i];\n            s[pos] = pushes[i];\n        }\n    } else {\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, '.');\n\n    if (type == \"all_dots\") {\n        // All dominoes are not pushed\n        // s is already initialized with '.'\n    } else if (type == \"alternate\") {\n        // Alternate 'L's and 'R's, ensuring constraints\n        vector<int> positions(n);\n        for (int i = 0; i < n; ++i) {\n            positions[i] = i;\n        }\n        // Decide the number of pushes\n        int m = n;\n        // Assign 'L's and 'R's alternately\n        for (int i = 0; i < m; ++i) {\n            if (i % 2 == 0) {\n                s[i] = 'L';\n            } else {\n                s[i] = 'R';\n            }\n        }\n    } else if (type == \"ends_pushed\") {\n        // Push only the first and last dominoes\n        if (n >= 1) {\n            s[0] = 'R';\n            s[n - 1] = 'L';\n        }\n    } else if (type == \"random\") {\n        // Randomly assign pushes ensuring constraints\n        vector<int> positions(n);\n        for (int i = 0; i < n; ++i) {\n            positions[i] = i;\n        }\n        int m = rnd.next(1, n); // Number of pushes\n        shuffle(positions.begin(), positions.end());\n        vector<int> push_positions(positions.begin(), positions.begin() + m);\n        sort(push_positions.begin(), push_positions.end());\n\n        vector<char> pushes;\n        char lastPush = 0;\n        for (size_t i = 0; i < push_positions.size(); ++i) {\n            char push;\n            if (lastPush == 0) {\n                push = rnd.next(0, 1) ? 'L' : 'R';\n            } else {\n                // Alternate pushes to satisfy constraints\n                push = (lastPush == 'L') ? 'R' : 'L';\n            }\n            pushes.push_back(push);\n            lastPush = push;\n        }\n\n        for (size_t i = 0; i < push_positions.size(); ++i) {\n            int pos = push_positions[i];\n            s[pos] = pushes[i];\n        }\n    } else {\n        fprintf(stderr, \"Unknown type %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case 1: n = 1, all_dots\n./gen -n 1 -type all_dots\n\n# Test case 2: n = 1, ends_pushed\n./gen -n 1 -type ends_pushed\n\n# Test case 3: n = 1, random\n./gen -n 1 -type random\n\n# Test case 4: n = 2, alternate\n./gen -n 2 -type alternate\n\n# Test case 5: n = 2, random\n./gen -n 2 -type random\n\n# Test case 6: n = 3, alternate\n./gen -n 3 -type alternate\n\n# Test case 7: n = 3, random\n./gen -n 3 -type random\n\n# Test case 8: n = 10, all_dots\n./gen -n 10 -type all_dots\n\n# Test case 9: n = 10, alternate\n./gen -n 10 -type alternate\n\n# Test case 10: n = 10, ends_pushed\n./gen -n 10 -type ends_pushed\n\n# Test case 11: n = 10, random\n./gen -n 10 -type random\n\n# Test case 12: n = 10, random\n./gen -n 10 -type random\n\n# Test case 13: n = 10, random\n./gen -n 10 -type random\n\n# Test case 14: n = 100, alternate\n./gen -n 100 -type alternate\n\n# Test case 15: n = 100, ends_pushed\n./gen -n 100 -type ends_pushed\n\n# Test case 16: n = 100, random\n./gen -n 100 -type random\n\n# Test case 17: n = 100, random\n./gen -n 100 -type random\n\n# Test case 18: n = 500, alternate\n./gen -n 500 -type alternate\n\n# Test case 19: n = 500, random\n./gen -n 500 -type random\n\n# Test case 20: n = 500, random\n./gen -n 500 -type random\n\n# Test case 21: n = 1000, ends_pushed\n./gen -n 1000 -type ends_pushed\n\n# Test case 22: n = 1000, random\n./gen -n 1000 -type random\n\n# Test case 23: n = 1500, alternate\n./gen -n 1500 -type alternate\n\n# Test case 24: n = 1500, random\n./gen -n 1500 -type random\n\n# Test case 25: n = 3000, all_dots\n./gen -n 3000 -type all_dots\n\n# Test case 26: n = 3000, alternate\n./gen -n 3000 -type alternate\n\n# Test case 27: n = 3000, ends_pushed\n./gen -n 3000 -type ends_pushed\n\n# Test case 28: n = 3000, random\n./gen -n 3000 -type random\n\n# Test case 29: n = 3000, random\n./gen -n 3000 -type random\n\n# Test case 30: n = 3000, random\n./gen -n 3000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:13.656397",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "405/C",
      "title": "C. Unusual Product",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains an integer n (1 ≤ n ≤ 1000), the number of rows and the number of columns in the matrix A. The next n lines describe the matrix: the i-th line contains n space-separated bits and describes the i-th row of A. The j-th number of the i-th line aij (0 ≤ aij ≤ 1) is the element on the intersection of the i-th row and the j-th column of A.The next line of input contains an integer q (1 ≤ q ≤ 106), the number of queries. Each of the next q lines describes a single query, which can be one of the following:   1 i — flip the values of the i-th row;  2 i — flip the values of the i-th column;  3 — output the unusual square of A. Note: since the size of the input and output could be very large, don't use slow output techniques in your language. For example, do not use input and output streams (cin, cout) in C++.",
      "output_spec": "OutputLet the number of the 3rd type queries in the input be m. Output a single string s of length m, where the i-th symbol of s is the value of the unusual square of A for the i-th query of the 3rd type as it appears in the input.",
      "sample_tests": "ExamplesInputCopy31 1 10 1 11 0 01232 332 22 21 3331 22 11 13OutputCopy01001",
      "description": "C. Unusual Product\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains an integer n (1 ≤ n ≤ 1000), the number of rows and the number of columns in the matrix A. The next n lines describe the matrix: the i-th line contains n space-separated bits and describes the i-th row of A. The j-th number of the i-th line aij (0 ≤ aij ≤ 1) is the element on the intersection of the i-th row and the j-th column of A.The next line of input contains an integer q (1 ≤ q ≤ 106), the number of queries. Each of the next q lines describes a single query, which can be one of the following:   1 i — flip the values of the i-th row;  2 i — flip the values of the i-th column;  3 — output the unusual square of A. Note: since the size of the input and output could be very large, don't use slow output techniques in your language. For example, do not use input and output streams (cin, cout) in C++.\n\nOutputLet the number of the 3rd type queries in the input be m. Output a single string s of length m, where the i-th symbol of s is the value of the unusual square of A for the i-th query of the 3rd type as it appears in the input.\n\nInputCopy31 1 10 1 11 0 01232 332 22 21 3331 22 11 13OutputCopy01001\n\nInputCopy31 1 10 1 11 0 01232 332 22 21 3331 22 11 13\n\nOutputCopy01001",
      "solutions": [
        {
          "title": "Codeforces Round #238 - Codeforces",
          "content": "Hello everyone!Codeforces round #238 will start today at 19:30 in Moscow time. The round will be held in both divisions.The round was prepared by me and cfk. This is the 4th round for me and the 2nd for Krisjanis. I think the problems this time are rather unusual and maybe even surprising. We have no doubt that everyone will find a problem that suits their taste! But you have to find it. (:As always, thanks to Mikhail Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems, and Maria Belova (Delinur) for translating the statements. Big thanks to Gerald Agapov (Gerald) for helping in preparation of the contest. Me and Gerald had a chance to talk about the problems onsite during the Petrozavodsk winter camp, which I think was very productive. We wish you a very exciting round!UPD1: Score distribution:DivI: 500 1000 2000 2000 2500DivII: 500 1000 1500 2000 3000The scoring for the problems is relative, so that the cost of each problem would be a multiple of 500 and closer to the objective estimate. Don't be afraid, the problems are not really that hard. (:UPD2: Congratulations to the winners!DivI: al13n Shef scott_wu sillycross Komaki DivII: NelsonMondialu L_Ecry aaaaAaaaaAaaaaAaaaaA xorfire Hec UPD3: Excellent round statistics from DmitriyH.UPD4: The contest tutorial is published here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11153",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1309
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces",
          "content": "405A - Gravity FlipObserve that in the final configuration the heights of the columns are in non-decreasing order. Also, the number of columns of each height remains the same. This means that the answer to the problem is the sorted sequence of the given column heights.Solution complexity: O(n), since we can sort by counting.405B - Domino EffectIf the first pushed domino from the left was pushed to the left at position l, all dominoes at prefix [1;l] fall down, otherwise let l be 0. Similarly, if the first pushed domino from the right was pushed to the right at position r, all dominoes at suffix [r;n] also fall down, otherwise let r be n + 1. Now, in the segment (l;r) there will remain vertical dominoes and blocks of dominoes supported by the equal forces from both sides.When does a domino at position p in segment (l, r) remains standing vertically? One way is that it is not pushed by any other domino. This could be easily checked by looking at the pushed dominoes closest to p (from both sides). It is pushed by dominoes, only if the closest from the left was pushed to the right, and the closest from the right was pushed to the left. Suppose these dominoes are at positions x and y, x < p < y. Then, the only way that the domino is still standing is if it is positioned at the center of the block [x;y], which could be checked by .Solution complexity: O(n) / O(n2), depends on implementation.406A - Unusual ProductWritten as a formula, the problem asks to find the value of Suppose that i ≠ j. Then the sum contains summands AijAji and AjiAij. Since the sum is taken modulo 2, these summands together give 0 to the sum. It follows that the expression is always equal to the sum of the diagonal bits: Now, each query of type 1 and 2 flips the value of exactly one bit on the diagonal. Thus we can calculate the unusual product of the original matrix, and flip its value after each query of type 1 and 2.Solution complexity: O(n + q), if we don't take the reading of the input into account... :)406B - Toy SumLet's define the symmetric number of k to be s + 1 - k. Since in this case s is an even number, k ≠ s - k.Note that (k - 1) + (s + 1 - k) = s, i.e., the sum of a number and its symmetric is always s. Let's process the given members x of X. There can be two cases: If the symmetric of x does not belong to X, we add it to Y. Both give equal values to the respective sums: x - 1 = s - (s + 1 - x). The symmetric of x belongs to X. Then we pick any y that neither y and symmetric of y belong to X, and add them to Y. Both pairs give equal values to the respective sums, namely s. How to prove that in the second step we can always find such y? Let the number of symmetric pairs that were processed in the step 1 be a, then there remain other pairs. Among them, for pairs both members belong to X, and for other pairs none of the members belong to X. To be able to pick the same number of pairs for Y, as there are in X, we should have which is equivalent to , as given in the statement.Solution complexity: O(s) / O(n).406C - Graph CuttingIt can be proved that only graphs with an odd number of edges cannot be partitioned into path of length 2. We will construct a recursive function that solves the problem and also serves as a proof for this statement.The function partition(v) will operate on non-blocked edges. It will partition the component of vertex v connected by the non-blocked edges into paths of length 2. If this component has an odd number of edges, the function will partition all the edges of the component, except one edge (u, v); the function then will return vertex u, expecting that the parent function call will assign it to some path.The function works as follows: find all vertices that are adjacent to v by the non-blocked edges, call this set adjacent. Then block all the edges from this set vertices to v. For each u in adjacent, call partition(u). Suppose partition(u) returned a vertex w. That means we can pair it into the path (v, u, w). Otherwise, if partition(u) does not return anything, we add u to unpaired, since the edge (v, u) is not yet in any path. We can pair any two vertices of this set u, w into a single path (u, v, w). We pair as much of them as possible in any order. If from this set a single vertex, u, is left unpaired, the function will return u. Otherwise the function will not return anything.The function could be implemented as a single DFS: partition(v) :\n adjacent = { u | not blocked[(u,v)] }\n for(u : adjacent)\n blocked[(u,v)] = true\n\n unpaired = {}\n for(u : adjacent)\n int w = partition(u)\n if(w = 0)\n add(unpaired, u)\n else\n print(v,u,w)\n\n while(size(unpaired) >= 2)\n int u = pop(unpaired)\n int w = pop(unpaired)\n print(u,v,w)\n\n if(not empty(unpaired))\n return pop(unpaired)\n else\n return 0Solution complexity: O(n + m).406D - Hill ClimbingNote that the path of each hill climber is strictly convex in any case. Let's draw the paths from all hills to the rightmost hill. Then these paths form a tree with the \"root\" at the top of the rightmost hill. We can apply the Graham scan from the right to the left to find the edges of this tree. Each pop and insert in the stack corresponds to a single edge in the tree.Now it is easy to see that for each team of climbers, we should calculate the number of the lowest common ancestor for the corresponding two vertices in the tree. The size if the tree is n, so each query works in .Solution complexity: .406E - Hamming TriplesLet's look at the Hamming graph of all possible distinct 2n strings, where each two strings are connected by an edge with length equal to the Hamming distance between these strings. We can observe that this graph has a nice property: if we arrange the vertices cyclically as a regular 2n-gon with a side length of 1, then the Hamming distance between two strings is the length of the shortest route between these vertices on the perimeter of the polygon.For example, the figure shows the graph for n = 3. The gray edges have length 1, the orange edges have length 2 and the blue edges have length 3. That is the corresponding Hamming distance.Now, we can convert each string coded by a pair (s, f) to an integer (f + 1)·n - s. The new numbers will be 0, 1, ..., 2n - 1 and correspond to the same cyclical order on the perimeter of the polygon. The given strings are mapped to some subset of the vertices. Now we have to find the number of triangles (possibly degenerate) with maximal perimeter in this subgraph. It will be useful to keep the new converted numbers sorted.First, we can figure out what this perimeter could be. If there exists a diameter in the full graph, so that all of the points are on one side of the diameter, the perimeter is 2d, where d is the length of the longest edge:Then any triangle with two vertices at the longest edge points and the third one being any point has the maximal perimeter. Since the numbers are sorted, the longest edge in this case will be produced by two cyclically adjacent elements, which is not hard to find.If for any diameter this does not hold, then the maximal perimeter is 2n. This can be proved by taking two different points a, b and drawing two diameters with them as endpoints; since it is not the previous case, there shoud be a third point c in area where the perimeter of triangle a, b, c is 2n.The tricky part is to count the triples in this case. We do this by working with the diameter (0, n). There can be several cases: A maximum triangle has vertices 0 and n. This a simple case: with any other vertex as the third the triangle has perimeter 2n. A maximum triangle has vertex 0, but not n. Then the second vertex should be in interval [0, n), and the third in interval (n + 1, 2n - 1], and the clockwise distance between the second and the third should not exceed n (since then the perimeter of the triangle would be less than 2n). We count the number of such triples iterating two pointers (one in each of these intervals). For each pointer in the first interval, all points from n + 1 till the second pointer will make a maximal perimeter triangle. We similarly solve the case where the maximal triangle has vertex n, but not 0. The maximal triangle does not have 0 or n as its vertices. Then one vertex of the triangle should be on one side of diameter (0, n), and two should be on the opposite side. To count them, we iterate a vertex pointer on the first side, say, (0, n); let the diametrally opposite vertex on the opposite side be x. Then the second vertex can be any in [n + 1, s], and the third can be any of the [s, 2n - 1]. It is easy to calculate these numbers using partial sums on the circle. Note that s can be both the second and the third vertex (since strings can repeat). So we iterate this pointer over all one side vertices and update the answer. Similarly we solve the case where a single vertex is on the other side, and two on this side. One only needs to be careful with the formulas in each case.Solution complexity: , because of the sorting.Post ScriptumWhat were your solutions? Feel free to share any solutions or thoughts! For example, was there a solution to DivI E simpler than in this tutorial?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11186",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 405 和字母"
          },
          "content_length": 9148
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #238 - Codeforces - Code 1",
          "code": "|   \n       |\n       |\n       |\n  |    |\n| |  | | \n1 2  3 4\n(In reversed order, from right to left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 2",
          "code": "|   \n       |\n       |\n       |\n  |    |\n| |  | | \n1 2  3 4\n(In reversed order, from right to left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 3",
          "code": "Push 1\nmake_edge(1,2) (i will not write these from now on)\nPush 2\ntry to pop the stack -> verify whether or not line segment 1 3 passes through hill 2 -> no -> no pop\nPush 3\ntry to pop the stack -> 2 4 is above 3, so we pop the stack\ntry to pop the stack -> 4 1 is above 2, so we pop the stack\n(make edge 1,4)\nPush 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 4",
          "code": "Push 1\nmake_edge(1,2) (i will not write these from now on)\nPush 2\ntry to pop the stack -> verify whether or not line segment 1 3 passes through hill 2 -> no -> no pop\nPush 3\ntry to pop the stack -> 2 4 is above 3, so we pop the stack\ntry to pop the stack -> 4 1 is above 2, so we pop the stack\n(make edge 1,4)\nPush 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 5",
          "code": "if(((1ll*stack[poz].x-stack[poz-1].x)*(1ll*v[i].h-stack[poz-1].h))<((1ll*stack[poz].h &mdash; 1ll*stack[poz-1].h)*(1ll*v[i].x-1ll*stack[poz-1].x)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 6",
          "code": "if(((1ll*stack[poz].x-stack[poz-1].x)*(1ll*v[i].h-stack[poz-1].h))<((1ll*stack[poz].h &mdash; 1ll*stack[poz-1].h)*(1ll*v[i].x-1ll*stack[poz-1].x)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 7",
          "code": "cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 8",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 9",
          "code": "ios :: sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 10",
          "code": "cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 11",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 12",
          "code": "string s; s.reserve(100005);\n\nfor (int i = 0; i < n; i++)\n{\n    cin >> s;\n\n    // do something\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 13",
          "code": "string s; s.reserve(100005);\n\nfor (int i = 0; i < n; i++)\n{\n    cin >> s;\n\n    // do something\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 14",
          "code": "#define dibs reserve",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 15",
          "code": "(X +- (2*Y))%2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 16",
          "code": "FastScanner",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 17",
          "code": "java.io.BufferedReader",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 1",
          "code": "partition(v)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 2",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 3",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 4",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 5",
          "code": "partition(v) :\n    adjacent = { u | not blocked[(u,v)] }\n    for(u : adjacent)\n        blocked[(u,v)] = true\n\n    unpaired = {}\n    for(u : adjacent)\n        int w = partition(u)\n        if(w = 0)\n            add(unpaired, u)\n        else\n            print(v,u,w)\n\n    while(size(unpaired) >= 2)\n        int u = pop(unpaired)\n        int w = pop(unpaired)\n        print(u,v,w)\n\n    if(not empty(unpaired))\n        return pop(unpaired)\n    else\n        return 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 6",
          "code": "partition(v) :\n    adjacent = { u | not blocked[(u,v)] }\n    for(u : adjacent)\n        blocked[(u,v)] = true\n\n    unpaired = {}\n    for(u : adjacent)\n        int w = partition(u)\n        if(w = 0)\n            add(unpaired, u)\n        else\n            print(v,u,w)\n\n    while(size(unpaired) >= 2)\n        int u = pop(unpaired)\n        int w = pop(unpaired)\n        print(u,v,w)\n\n    if(not empty(unpaired))\n        return pop(unpaired)\n    else\n        return 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 7",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, **u**)\n        **else**\n**            print(v,u,w)**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 8",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, **u**)\n        **else**\n**            print(v,u,w)**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 9",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 10",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 11",
          "code": "if(w = 0)\n    add(unpaired, u)\nelse\n    print(v,u,w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 12",
          "code": "if(w = 0)\n    add(unpaired, u)\nelse\n    print(v,u,w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(n, 0, 1);\n        inf.readEoln();\n    }\n\n    int q = inf.readInt(1, 1000000, \"q\");\n    inf.readEoln();\n\n    for (int t = 0; t < q; ++t) {\n        int queryType = inf.readInt(1, 3, \"queryType\");\n\n        if (queryType == 1 || queryType == 2) {\n            inf.readSpace();\n            int i = inf.readInt(1, n, \"i\");\n            inf.readEoln();\n        } else if (queryType == 3) {\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(n, 0, 1);\n        inf.readEoln();\n    }\n\n    int q = inf.readInt(1, 1000000, \"q\");\n    inf.readEoln();\n\n    for (int t = 0; t < q; ++t) {\n        int queryType = inf.readInt(1, 3, \"queryType\");\n\n        if (queryType == 1 || queryType == 2) {\n            inf.readSpace();\n            int i = inf.readInt(1, n, \"i\");\n            inf.readEoln();\n        } else if (queryType == 3) {\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(n, 0, 1);\n        inf.readEoln();\n    }\n\n    int q = inf.readInt(1, 1000000, \"q\");\n    inf.readEoln();\n\n    for (int t = 0; t < q; ++t) {\n        int queryType = inf.readInt(1, 3, \"queryType\");\n\n        if (queryType == 1 || queryType == 2) {\n            inf.readSpace();\n            int i = inf.readInt(1, n, \"i\");\n            inf.readEoln();\n        } else if (queryType == 3) {\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> A(n, vector<int>(n));\n\n    if (type == \"all_zero\") {\n        // Initialize A to all zeros\n        for (int i = 0; i < n; ++i)\n            fill(A[i].begin(), A[i].end(), 0);\n    } else if (type == \"all_one\") {\n        // Initialize A to all ones\n        for (int i = 0; i < n; ++i)\n            fill(A[i].begin(), A[i].end(), 1);\n    } else if (type == \"random\") {\n        // Randomly initialize A\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                A[i][j] = rnd.next(2); // Random 0 or 1\n    } else if (type == \"diagonal\") {\n        // Initialize A with ones on the diagonal\n        for (int i = 0; i < n; ++i)\n            A[i][i] = 1;\n    } else if (type == \"checkerboard\") {\n        // Initialize A in checkerboard pattern\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                A[i][j] = (i + j) % 2;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                A[i][j] = rnd.next(2); // Random 0 or 1\n    }\n\n    // Output the initial matrix\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d%c\", A[i][j], j == n - 1 ? '\\n' : ' ');\n        }\n    }\n\n    // Now generate q queries\n    printf(\"%d\\n\", q);\n\n    if (type == \"only_type3\") {\n        // Only type 3 queries\n        for (int i = 0; i < q; ++i) {\n            printf(\"3\\n\");\n        }\n    } else if (type == \"only_flip_rows\") {\n        // Only flip rows\n        for (int i = 0; i < q; ++i) {\n            int row = rnd.next(1, n);\n            printf(\"1 %d\\n\", row);\n        }\n    } else if (type == \"only_flip_columns\") {\n        // Only flip columns\n        for (int i = 0; i < q; ++i) {\n            int col = rnd.next(1, n);\n            printf(\"2 %d\\n\", col);\n        }\n    } else if (type == \"alternate\") {\n        // Alternate between flipping and computing unusual square\n        for (int i = 0; i < q;) {\n            if (i < q) {\n                // Flip a random row or column\n                int t = rnd.next(1, 3);\n                if (t == 1) {\n                    int row = rnd.next(1, n);\n                    printf(\"1 %d\\n\", row);\n                } else {\n                    int col = rnd.next(1, n);\n                    printf(\"2 %d\\n\", col);\n                }\n                ++i;\n            }\n            if (i < q) {\n                printf(\"3\\n\");\n                ++i;\n            }\n        }\n    } else if (type == \"flip_same_row\") {\n        int row = rnd.next(1, n);\n        for (int i = 0; i < q;) {\n            if (i < q) {\n                printf(\"1 %d\\n\", row);\n                ++i;\n            }\n            if (i < q) {\n                printf(\"3\\n\");\n                ++i;\n            }\n        }\n    } else if (type == \"flip_same_column\") {\n        int col = rnd.next(1, n);\n        for (int i = 0; i < q;) {\n            if (i < q) {\n                printf(\"2 %d\\n\", col);\n                ++i;\n            }\n            if (i < q) {\n                printf(\"3\\n\");\n                ++i;\n            }\n        }\n    } else if (type == \"flip_all_rows\") {\n        for (int i = 1; i <= n && q > 0; ++i, --q) {\n            printf(\"1 %d\\n\", i);\n        }\n        for (int i = 0; i < q; ++i) {\n            printf(\"3\\n\");\n        }\n    } else if (type == \"flip_all_columns\") {\n        for (int i = 1; i <= n && q > 0; ++i, --q) {\n            printf(\"2 %d\\n\", i);\n        }\n        for (int i = 0; i < q; ++i) {\n            printf(\"3\\n\");\n        }\n    } else if (type == \"random\") {\n        if (k == -1) {\n            k = rnd.next(0, q);\n        }\n        vector<int> query_types(q);\n        for (int i = 0; i < k; ++i) {\n            query_types[i] = 3;\n        }\n        for (int i = k; i < q; ++i) {\n            query_types[i] = rnd.next(1, 2); // 1 or 2\n        }\n        shuffle(query_types.begin(), query_types.end());\n        for (int i = 0; i < q; ++i) {\n            int t = query_types[i];\n            if (t == 3) {\n                printf(\"3\\n\");\n            } else if (t == 1) {\n                int row = rnd.next(1, n);\n                printf(\"1 %d\\n\", row);\n            } else if (t == 2) {\n                int col = rnd.next(1, n);\n                printf(\"2 %d\\n\", col);\n            }\n        }\n    } else {\n        // Default to random queries\n        for (int i = 0; i < q; ++i) {\n            int t = rnd.next(1, 4); // 1,2,3\n            if (t == 3) {\n                printf(\"3\\n\");\n            } else if (t == 1) {\n                int row = rnd.next(1, n);\n                printf(\"1 %d\\n\", row);\n            } else if (t == 2) {\n                int col = rnd.next(1, n);\n                printf(\"2 %d\\n\", col);\n            }\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> A(n, vector<int>(n));\n\n    if (type == \"all_zero\") {\n        // Initialize A to all zeros\n        for (int i = 0; i < n; ++i)\n            fill(A[i].begin(), A[i].end(), 0);\n    } else if (type == \"all_one\") {\n        // Initialize A to all ones\n        for (int i = 0; i < n; ++i)\n            fill(A[i].begin(), A[i].end(), 1);\n    } else if (type == \"random\") {\n        // Randomly initialize A\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                A[i][j] = rnd.next(2); // Random 0 or 1\n    } else if (type == \"diagonal\") {\n        // Initialize A with ones on the diagonal\n        for (int i = 0; i < n; ++i)\n            A[i][i] = 1;\n    } else if (type == \"checkerboard\") {\n        // Initialize A in checkerboard pattern\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                A[i][j] = (i + j) % 2;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                A[i][j] = rnd.next(2); // Random 0 or 1\n    }\n\n    // Output the initial matrix\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d%c\", A[i][j], j == n - 1 ? '\\n' : ' ');\n        }\n    }\n\n    // Now generate q queries\n    printf(\"%d\\n\", q);\n\n    if (type == \"only_type3\") {\n        // Only type 3 queries\n        for (int i = 0; i < q; ++i) {\n            printf(\"3\\n\");\n        }\n    } else if (type == \"only_flip_rows\") {\n        // Only flip rows\n        for (int i = 0; i < q; ++i) {\n            int row = rnd.next(1, n);\n            printf(\"1 %d\\n\", row);\n        }\n    } else if (type == \"only_flip_columns\") {\n        // Only flip columns\n        for (int i = 0; i < q; ++i) {\n            int col = rnd.next(1, n);\n            printf(\"2 %d\\n\", col);\n        }\n    } else if (type == \"alternate\") {\n        // Alternate between flipping and computing unusual square\n        for (int i = 0; i < q;) {\n            if (i < q) {\n                // Flip a random row or column\n                int t = rnd.next(1, 3);\n                if (t == 1) {\n                    int row = rnd.next(1, n);\n                    printf(\"1 %d\\n\", row);\n                } else {\n                    int col = rnd.next(1, n);\n                    printf(\"2 %d\\n\", col);\n                }\n                ++i;\n            }\n            if (i < q) {\n                printf(\"3\\n\");\n                ++i;\n            }\n        }\n    } else if (type == \"flip_same_row\") {\n        int row = rnd.next(1, n);\n        for (int i = 0; i < q;) {\n            if (i < q) {\n                printf(\"1 %d\\n\", row);\n                ++i;\n            }\n            if (i < q) {\n                printf(\"3\\n\");\n                ++i;\n            }\n        }\n    } else if (type == \"flip_same_column\") {\n        int col = rnd.next(1, n);\n        for (int i = 0; i < q;) {\n            if (i < q) {\n                printf(\"2 %d\\n\", col);\n                ++i;\n            }\n            if (i < q) {\n                printf(\"3\\n\");\n                ++i;\n            }\n        }\n    } else if (type == \"flip_all_rows\") {\n        for (int i = 1; i <= n && q > 0; ++i, --q) {\n            printf(\"1 %d\\n\", i);\n        }\n        for (int i = 0; i < q; ++i) {\n            printf(\"3\\n\");\n        }\n    } else if (type == \"flip_all_columns\") {\n        for (int i = 1; i <= n && q > 0; ++i, --q) {\n            printf(\"2 %d\\n\", i);\n        }\n        for (int i = 0; i < q; ++i) {\n            printf(\"3\\n\");\n        }\n    } else if (type == \"random\") {\n        if (k == -1) {\n            k = rnd.next(0, q);\n        }\n        vector<int> query_types(q);\n        for (int i = 0; i < k; ++i) {\n            query_types[i] = 3;\n        }\n        for (int i = k; i < q; ++i) {\n            query_types[i] = rnd.next(1, 2); // 1 or 2\n        }\n        shuffle(query_types.begin(), query_types.end());\n        for (int i = 0; i < q; ++i) {\n            int t = query_types[i];\n            if (t == 3) {\n                printf(\"3\\n\");\n            } else if (t == 1) {\n                int row = rnd.next(1, n);\n                printf(\"1 %d\\n\", row);\n            } else if (t == 2) {\n                int col = rnd.next(1, n);\n                printf(\"2 %d\\n\", col);\n            }\n        }\n    } else {\n        // Default to random queries\n        for (int i = 0; i < q; ++i) {\n            int t = rnd.next(1, 4); // 1,2,3\n            if (t == 3) {\n                printf(\"3\\n\");\n            } else if (t == 1) {\n                int row = rnd.next(1, n);\n                printf(\"1 %d\\n\", row);\n            } else if (t == 2) {\n                int col = rnd.next(1, n);\n                printf(\"2 %d\\n\", col);\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -type all_zero\n./gen -n 1 -q 1 -type all_one\n\n./gen -n 1 -q 10 -type only_type3\n./gen -n 1 -q 10 -type only_flip_rows\n\n./gen -n 2 -q 10 -type random\n./gen -n 2 -q 10 -type alternate\n\n./gen -n 10 -q 100 -type random\n./gen -n 10 -q 100 -type flip_same_row\n\n./gen -n 1000 -q 1000000 -type random\n./gen -n 1000 -q 1000000 -type alternate\n\n./gen -n 1000 -q 1000000 -type only_type3\n\n./gen -n 1000 -q 1000000 -type only_flip_rows\n./gen -n 1000 -q 1000000 -type only_flip_columns\n\n./gen -n 1000 -q 1000000 -type flip_all_rows\n./gen -n 1000 -q 1000000 -type flip_all_columns\n\n./gen -n 1000 -q 1000000 -type flip_same_row\n./gen -n 1000 -q 1000000 -type flip_same_column\n\n./gen -n 1000 -q 1000000 -type checkerboard\n\n./gen -n 1000 -q 1000000 -type diagonal\n\n./gen -n 1000 -q 1000000 -type all_one\n\n./gen -n 1000 -q 1000000 -type all_zero\n\n./gen -n 999 -q 999999 -type random\n\n./gen -n 1000 -q 1000000 -type random -k 500000\n\n./gen -n 1000 -q 1000000 -type random -k 0\n\n./gen -n 1000 -q 1000000 -type random -k 1000000\n\n./gen -n 1000 -q 1000000 -type random -k 1\n\n./gen -n 1000 -q 1000000 -type random -k 999999\n\n./gen -n 2 -q 1000000 -type only_type3\n\n./gen -n 500 -q 500000 -type random\n\n./gen -n 500 -q 500000 -type alternate\n\n./gen -n 500 -q 500000 -type flip_same_row\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:15.307918",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "405/D",
      "title": "D. Toy Sum",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains a single integer n (1 ≤ n ≤ 5·105), the number of blocks in the set X. The next line contains n distinct space-separated integers x1, x2, ..., xn (1 ≤ xi ≤ 106), the numbers of the blocks in X.Note: since the size of the input and output could be very large, don't use slow output techniques in your language. For example, do not use input and output streams (cin, cout) in C++.",
      "output_spec": "OutputIn the first line of output print a single integer m (1 ≤ m ≤ 106 - n), the number of blocks in the set Y. In the next line output m distinct space-separated integers y1, y2, ..., ym (1 ≤ yi ≤ 106), such that the required equality holds. The sets X and Y should not intersect, i.e. xi ≠ yj for all i, j (1 ≤ i ≤ n; 1 ≤ j ≤ m). It is guaranteed that at least one solution always exists. If there are multiple solutions, output any of them.",
      "sample_tests": "ExamplesInputCopy31 4 5OutputCopy2999993 1000000InputCopy11OutputCopy11000000",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains a single integer n (1 ≤ n ≤ 5·105), the number of blocks in the set X. The next line contains n distinct space-separated integers x1, x2, ..., xn (1 ≤ xi ≤ 106), the numbers of the blocks in X.Note: since the size of the input and output could be very large, don't use slow output techniques in your language. For example, do not use input and output streams (cin, cout) in C++.\n\nOutputIn the first line of output print a single integer m (1 ≤ m ≤ 106 - n), the number of blocks in the set Y. In the next line output m distinct space-separated integers y1, y2, ..., ym (1 ≤ yi ≤ 106), such that the required equality holds. The sets X and Y should not intersect, i.e. xi ≠ yj for all i, j (1 ≤ i ≤ n; 1 ≤ j ≤ m). It is guaranteed that at least one solution always exists. If there are multiple solutions, output any of them.\n\nInputCopy31 4 5OutputCopy2999993 1000000InputCopy11OutputCopy11000000\n\nInputCopy31 4 5\n\nOutputCopy2999993 1000000\n\nInputCopy11\n\nOutputCopy11000000",
      "solutions": [
        {
          "title": "Codeforces Round #238 - Codeforces",
          "content": "Hello everyone!Codeforces round #238 will start today at 19:30 in Moscow time. The round will be held in both divisions.The round was prepared by me and cfk. This is the 4th round for me and the 2nd for Krisjanis. I think the problems this time are rather unusual and maybe even surprising. We have no doubt that everyone will find a problem that suits their taste! But you have to find it. (:As always, thanks to Mikhail Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems, and Maria Belova (Delinur) for translating the statements. Big thanks to Gerald Agapov (Gerald) for helping in preparation of the contest. Me and Gerald had a chance to talk about the problems onsite during the Petrozavodsk winter camp, which I think was very productive. We wish you a very exciting round!UPD1: Score distribution:DivI: 500 1000 2000 2000 2500DivII: 500 1000 1500 2000 3000The scoring for the problems is relative, so that the cost of each problem would be a multiple of 500 and closer to the objective estimate. Don't be afraid, the problems are not really that hard. (:UPD2: Congratulations to the winners!DivI: al13n Shef scott_wu sillycross Komaki DivII: NelsonMondialu L_Ecry aaaaAaaaaAaaaaAaaaaA xorfire Hec UPD3: Excellent round statistics from DmitriyH.UPD4: The contest tutorial is published here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11153",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1309
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces",
          "content": "405A - Gravity FlipObserve that in the final configuration the heights of the columns are in non-decreasing order. Also, the number of columns of each height remains the same. This means that the answer to the problem is the sorted sequence of the given column heights.Solution complexity: O(n), since we can sort by counting.405B - Domino EffectIf the first pushed domino from the left was pushed to the left at position l, all dominoes at prefix [1;l] fall down, otherwise let l be 0. Similarly, if the first pushed domino from the right was pushed to the right at position r, all dominoes at suffix [r;n] also fall down, otherwise let r be n + 1. Now, in the segment (l;r) there will remain vertical dominoes and blocks of dominoes supported by the equal forces from both sides.When does a domino at position p in segment (l, r) remains standing vertically? One way is that it is not pushed by any other domino. This could be easily checked by looking at the pushed dominoes closest to p (from both sides). It is pushed by dominoes, only if the closest from the left was pushed to the right, and the closest from the right was pushed to the left. Suppose these dominoes are at positions x and y, x < p < y. Then, the only way that the domino is still standing is if it is positioned at the center of the block [x;y], which could be checked by .Solution complexity: O(n) / O(n2), depends on implementation.406A - Unusual ProductWritten as a formula, the problem asks to find the value of Suppose that i ≠ j. Then the sum contains summands AijAji and AjiAij. Since the sum is taken modulo 2, these summands together give 0 to the sum. It follows that the expression is always equal to the sum of the diagonal bits: Now, each query of type 1 and 2 flips the value of exactly one bit on the diagonal. Thus we can calculate the unusual product of the original matrix, and flip its value after each query of type 1 and 2.Solution complexity: O(n + q), if we don't take the reading of the input into account... :)406B - Toy SumLet's define the symmetric number of k to be s + 1 - k. Since in this case s is an even number, k ≠ s - k.Note that (k - 1) + (s + 1 - k) = s, i.e., the sum of a number and its symmetric is always s. Let's process the given members x of X. There can be two cases: If the symmetric of x does not belong to X, we add it to Y. Both give equal values to the respective sums: x - 1 = s - (s + 1 - x). The symmetric of x belongs to X. Then we pick any y that neither y and symmetric of y belong to X, and add them to Y. Both pairs give equal values to the respective sums, namely s. How to prove that in the second step we can always find such y? Let the number of symmetric pairs that were processed in the step 1 be a, then there remain other pairs. Among them, for pairs both members belong to X, and for other pairs none of the members belong to X. To be able to pick the same number of pairs for Y, as there are in X, we should have which is equivalent to , as given in the statement.Solution complexity: O(s) / O(n).406C - Graph CuttingIt can be proved that only graphs with an odd number of edges cannot be partitioned into path of length 2. We will construct a recursive function that solves the problem and also serves as a proof for this statement.The function partition(v) will operate on non-blocked edges. It will partition the component of vertex v connected by the non-blocked edges into paths of length 2. If this component has an odd number of edges, the function will partition all the edges of the component, except one edge (u, v); the function then will return vertex u, expecting that the parent function call will assign it to some path.The function works as follows: find all vertices that are adjacent to v by the non-blocked edges, call this set adjacent. Then block all the edges from this set vertices to v. For each u in adjacent, call partition(u). Suppose partition(u) returned a vertex w. That means we can pair it into the path (v, u, w). Otherwise, if partition(u) does not return anything, we add u to unpaired, since the edge (v, u) is not yet in any path. We can pair any two vertices of this set u, w into a single path (u, v, w). We pair as much of them as possible in any order. If from this set a single vertex, u, is left unpaired, the function will return u. Otherwise the function will not return anything.The function could be implemented as a single DFS: partition(v) :\n adjacent = { u | not blocked[(u,v)] }\n for(u : adjacent)\n blocked[(u,v)] = true\n\n unpaired = {}\n for(u : adjacent)\n int w = partition(u)\n if(w = 0)\n add(unpaired, u)\n else\n print(v,u,w)\n\n while(size(unpaired) >= 2)\n int u = pop(unpaired)\n int w = pop(unpaired)\n print(u,v,w)\n\n if(not empty(unpaired))\n return pop(unpaired)\n else\n return 0Solution complexity: O(n + m).406D - Hill ClimbingNote that the path of each hill climber is strictly convex in any case. Let's draw the paths from all hills to the rightmost hill. Then these paths form a tree with the \"root\" at the top of the rightmost hill. We can apply the Graham scan from the right to the left to find the edges of this tree. Each pop and insert in the stack corresponds to a single edge in the tree.Now it is easy to see that for each team of climbers, we should calculate the number of the lowest common ancestor for the corresponding two vertices in the tree. The size if the tree is n, so each query works in .Solution complexity: .406E - Hamming TriplesLet's look at the Hamming graph of all possible distinct 2n strings, where each two strings are connected by an edge with length equal to the Hamming distance between these strings. We can observe that this graph has a nice property: if we arrange the vertices cyclically as a regular 2n-gon with a side length of 1, then the Hamming distance between two strings is the length of the shortest route between these vertices on the perimeter of the polygon.For example, the figure shows the graph for n = 3. The gray edges have length 1, the orange edges have length 2 and the blue edges have length 3. That is the corresponding Hamming distance.Now, we can convert each string coded by a pair (s, f) to an integer (f + 1)·n - s. The new numbers will be 0, 1, ..., 2n - 1 and correspond to the same cyclical order on the perimeter of the polygon. The given strings are mapped to some subset of the vertices. Now we have to find the number of triangles (possibly degenerate) with maximal perimeter in this subgraph. It will be useful to keep the new converted numbers sorted.First, we can figure out what this perimeter could be. If there exists a diameter in the full graph, so that all of the points are on one side of the diameter, the perimeter is 2d, where d is the length of the longest edge:Then any triangle with two vertices at the longest edge points and the third one being any point has the maximal perimeter. Since the numbers are sorted, the longest edge in this case will be produced by two cyclically adjacent elements, which is not hard to find.If for any diameter this does not hold, then the maximal perimeter is 2n. This can be proved by taking two different points a, b and drawing two diameters with them as endpoints; since it is not the previous case, there shoud be a third point c in area where the perimeter of triangle a, b, c is 2n.The tricky part is to count the triples in this case. We do this by working with the diameter (0, n). There can be several cases: A maximum triangle has vertices 0 and n. This a simple case: with any other vertex as the third the triangle has perimeter 2n. A maximum triangle has vertex 0, but not n. Then the second vertex should be in interval [0, n), and the third in interval (n + 1, 2n - 1], and the clockwise distance between the second and the third should not exceed n (since then the perimeter of the triangle would be less than 2n). We count the number of such triples iterating two pointers (one in each of these intervals). For each pointer in the first interval, all points from n + 1 till the second pointer will make a maximal perimeter triangle. We similarly solve the case where the maximal triangle has vertex n, but not 0. The maximal triangle does not have 0 or n as its vertices. Then one vertex of the triangle should be on one side of diameter (0, n), and two should be on the opposite side. To count them, we iterate a vertex pointer on the first side, say, (0, n); let the diametrally opposite vertex on the opposite side be x. Then the second vertex can be any in [n + 1, s], and the third can be any of the [s, 2n - 1]. It is easy to calculate these numbers using partial sums on the circle. Note that s can be both the second and the third vertex (since strings can repeat). So we iterate this pointer over all one side vertices and update the answer. Similarly we solve the case where a single vertex is on the other side, and two on this side. One only needs to be careful with the formulas in each case.Solution complexity: , because of the sorting.Post ScriptumWhat were your solutions? Feel free to share any solutions or thoughts! For example, was there a solution to DivI E simpler than in this tutorial?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11186",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 405 和字母"
          },
          "content_length": 9148
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #238 - Codeforces - Code 1",
          "code": "|   \n       |\n       |\n       |\n  |    |\n| |  | | \n1 2  3 4\n(In reversed order, from right to left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 2",
          "code": "|   \n       |\n       |\n       |\n  |    |\n| |  | | \n1 2  3 4\n(In reversed order, from right to left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 3",
          "code": "Push 1\nmake_edge(1,2) (i will not write these from now on)\nPush 2\ntry to pop the stack -> verify whether or not line segment 1 3 passes through hill 2 -> no -> no pop\nPush 3\ntry to pop the stack -> 2 4 is above 3, so we pop the stack\ntry to pop the stack -> 4 1 is above 2, so we pop the stack\n(make edge 1,4)\nPush 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 4",
          "code": "Push 1\nmake_edge(1,2) (i will not write these from now on)\nPush 2\ntry to pop the stack -> verify whether or not line segment 1 3 passes through hill 2 -> no -> no pop\nPush 3\ntry to pop the stack -> 2 4 is above 3, so we pop the stack\ntry to pop the stack -> 4 1 is above 2, so we pop the stack\n(make edge 1,4)\nPush 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 5",
          "code": "if(((1ll*stack[poz].x-stack[poz-1].x)*(1ll*v[i].h-stack[poz-1].h))<((1ll*stack[poz].h &mdash; 1ll*stack[poz-1].h)*(1ll*v[i].x-1ll*stack[poz-1].x)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 6",
          "code": "if(((1ll*stack[poz].x-stack[poz-1].x)*(1ll*v[i].h-stack[poz-1].h))<((1ll*stack[poz].h &mdash; 1ll*stack[poz-1].h)*(1ll*v[i].x-1ll*stack[poz-1].x)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 7",
          "code": "cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 8",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 9",
          "code": "ios :: sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 10",
          "code": "cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 11",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 12",
          "code": "string s; s.reserve(100005);\n\nfor (int i = 0; i < n; i++)\n{\n    cin >> s;\n\n    // do something\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 13",
          "code": "string s; s.reserve(100005);\n\nfor (int i = 0; i < n; i++)\n{\n    cin >> s;\n\n    // do something\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 14",
          "code": "#define dibs reserve",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 15",
          "code": "(X +- (2*Y))%2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 16",
          "code": "FastScanner",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 17",
          "code": "java.io.BufferedReader",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 1",
          "code": "partition(v)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 2",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 3",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 4",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 5",
          "code": "partition(v) :\n    adjacent = { u | not blocked[(u,v)] }\n    for(u : adjacent)\n        blocked[(u,v)] = true\n\n    unpaired = {}\n    for(u : adjacent)\n        int w = partition(u)\n        if(w = 0)\n            add(unpaired, u)\n        else\n            print(v,u,w)\n\n    while(size(unpaired) >= 2)\n        int u = pop(unpaired)\n        int w = pop(unpaired)\n        print(u,v,w)\n\n    if(not empty(unpaired))\n        return pop(unpaired)\n    else\n        return 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 6",
          "code": "partition(v) :\n    adjacent = { u | not blocked[(u,v)] }\n    for(u : adjacent)\n        blocked[(u,v)] = true\n\n    unpaired = {}\n    for(u : adjacent)\n        int w = partition(u)\n        if(w = 0)\n            add(unpaired, u)\n        else\n            print(v,u,w)\n\n    while(size(unpaired) >= 2)\n        int u = pop(unpaired)\n        int w = pop(unpaired)\n        print(u,v,w)\n\n    if(not empty(unpaired))\n        return pop(unpaired)\n    else\n        return 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 7",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, **u**)\n        **else**\n**            print(v,u,w)**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 8",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, **u**)\n        **else**\n**            print(v,u,w)**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 9",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 10",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 11",
          "code": "if(w = 0)\n    add(unpaired, u)\nelse\n    print(v,u,w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 12",
          "code": "if(w = 0)\n    add(unpaired, u)\nelse\n    print(v,u,w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n\n    // Read xi\n    vector<int> xi = inf.readInts(n, 1, 1000000, \"xi\");\n    inf.readEoln();\n\n    // Check that xi are distinct\n    sort(xi.begin(), xi.end());\n    for (int i = 1; i < n; ++i) {\n        ensuref(xi[i] != xi[i - 1], \"xi numbers must be distinct, found duplicate xi[%d]=%d\", i + 1, xi[i]);\n    }\n\n    // Read EOF\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n\n    // Read xi\n    vector<int> xi = inf.readInts(n, 1, 1000000, \"xi\");\n    inf.readEoln();\n\n    // Check that xi are distinct\n    sort(xi.begin(), xi.end());\n    for (int i = 1; i < n; ++i) {\n        ensuref(xi[i] != xi[i - 1], \"xi numbers must be distinct, found duplicate xi[%d]=%d\", i + 1, xi[i]);\n    }\n\n    // Read EOF\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n\n    // Read xi\n    vector<int> xi = inf.readInts(n, 1, 1000000, \"xi\");\n    inf.readEoln();\n\n    // Check that xi are distinct\n    sort(xi.begin(), xi.end());\n    for (int i = 1; i < n; ++i) {\n        ensuref(xi[i] != xi[i - 1], \"xi numbers must be distinct, found duplicate xi[%d]=%d\", i + 1, xi[i]);\n    }\n\n    // Read EOF\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    const int s = 1000000;  // Total number of blocks\n\n    // Read input from the input file\n    int n = inf.readInt(1, 500000, \"n\");\n    vector<int> X = inf.readInts(n, 1, s, \"X\");\n    set<int> xSet(X.begin(), X.end());\n\n    // Read contestant's output\n    int m = ouf.readInt(1, s - n, \"m\");\n    vector<int> Y = ouf.readInts(m, 1, s, \"Y\");\n\n    // Check for duplicates and intersection with X\n    set<int> ySet;\n    for (int i = 0; i < m; ++i) {\n        int y = Y[i];\n        if (xSet.count(y))\n            quitf(_wa, \"Y[%d]=%d is in X\", i + 1, y);\n        if (ySet.count(y))\n            quitf(_wa, \"Y[%d]=%d is repeated\", i + 1, y);\n        ySet.insert(y);\n    }\n\n    // Calculate the sums\n    long long left = 0;\n    for (int x : X)\n        left += x - 1;\n\n    long long right = 0;\n    for (int y : Y)\n        right += s - y;\n\n    // Verify the equality\n    if (left != right)\n        quitf(_wa, \"Sum mismatch: left=%lld, right=%lld\", left, right);\n\n    quitf(_ok, \"Solution is correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int s = 1000000;\n\n    if (n < 1 || n > 500000) {\n        fprintf(stderr, \"n must be between 1 and 500000\\n\");\n        return 1;\n    }\n\n    vector<int> xi;\n\n    if (type == \"random\") {\n        // Generate n random distinct integers between 1 and s\n        vector<int> perm(s);\n        for (int i = 1; i <= s; ++i)\n            perm[i - 1] = i;\n        shuffle(perm.begin(), perm.end());\n        xi.insert(xi.end(), perm.begin(), perm.begin() + n);\n    } else if (type == \"consecutive_start\") {\n        // xi = 1 to n\n        for (int i = 1; i <= n; ++i)\n            xi.push_back(i);\n    } else if (type == \"consecutive_end\") {\n        // xi = s - n + 1 to s\n        for (int i = s - n + 1; i <= s; ++i)\n            xi.push_back(i);\n    } else if (type == \"middle\") {\n        int start = s / 2 - n / 2;\n        for (int i = 1; i <= n; ++i)\n            xi.push_back(start + i);\n    } else if (type == \"small_numbers\") {\n        // xi from 1 to min(s, 1000)\n        int max_val = min(1000, s);\n        if (n > max_val) {\n            fprintf(stderr, \"Not enough small numbers to generate n distinct xi\\n\");\n            return 1;\n        }\n        vector<int> nums(max_val);\n        for (int i = 1; i <= max_val; ++i)\n            nums[i - 1] = i;\n        shuffle(nums.begin(), nums.end());\n        xi.insert(xi.end(), nums.begin(), nums.begin() + n);\n    } else if (type == \"large_numbers\") {\n        // xi from max(1, s - 1000 + 1) to s\n        int min_val = max(1, s - 1000 + 1);\n        int max_val = s;\n        if (n > max_val - min_val + 1) {\n            fprintf(stderr, \"Not enough large numbers to generate n distinct xi\\n\");\n            return 1;\n        }\n        vector<int> nums;\n        for (int i = min_val; i <= max_val; ++i)\n            nums.push_back(i);\n        shuffle(nums.begin(), nums.end());\n        xi.insert(xi.end(), nums.begin(), nums.begin() + n);\n    } else if (type == \"alternating\") {\n        if (n > s) {\n            fprintf(stderr, \"n cannot be greater than s\\n\");\n            return 1;\n        }\n        xi.reserve(n);\n        int low = 1;\n        int high = s;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                xi.push_back(low++);\n            else\n                xi.push_back(high--);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output xi\n    for (int i = 0; i < xi.size(); ++i) {\n        printf(\"%d\", xi[i]);\n        if (i + 1 < xi.size())\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int s = 1000000;\n\n    if (n < 1 || n > 500000) {\n        fprintf(stderr, \"n must be between 1 and 500000\\n\");\n        return 1;\n    }\n\n    vector<int> xi;\n\n    if (type == \"random\") {\n        // Generate n random distinct integers between 1 and s\n        vector<int> perm(s);\n        for (int i = 1; i <= s; ++i)\n            perm[i - 1] = i;\n        shuffle(perm.begin(), perm.end());\n        xi.insert(xi.end(), perm.begin(), perm.begin() + n);\n    } else if (type == \"consecutive_start\") {\n        // xi = 1 to n\n        for (int i = 1; i <= n; ++i)\n            xi.push_back(i);\n    } else if (type == \"consecutive_end\") {\n        // xi = s - n + 1 to s\n        for (int i = s - n + 1; i <= s; ++i)\n            xi.push_back(i);\n    } else if (type == \"middle\") {\n        int start = s / 2 - n / 2;\n        for (int i = 1; i <= n; ++i)\n            xi.push_back(start + i);\n    } else if (type == \"small_numbers\") {\n        // xi from 1 to min(s, 1000)\n        int max_val = min(1000, s);\n        if (n > max_val) {\n            fprintf(stderr, \"Not enough small numbers to generate n distinct xi\\n\");\n            return 1;\n        }\n        vector<int> nums(max_val);\n        for (int i = 1; i <= max_val; ++i)\n            nums[i - 1] = i;\n        shuffle(nums.begin(), nums.end());\n        xi.insert(xi.end(), nums.begin(), nums.begin() + n);\n    } else if (type == \"large_numbers\") {\n        // xi from max(1, s - 1000 + 1) to s\n        int min_val = max(1, s - 1000 + 1);\n        int max_val = s;\n        if (n > max_val - min_val + 1) {\n            fprintf(stderr, \"Not enough large numbers to generate n distinct xi\\n\");\n            return 1;\n        }\n        vector<int> nums;\n        for (int i = min_val; i <= max_val; ++i)\n            nums.push_back(i);\n        shuffle(nums.begin(), nums.end());\n        xi.insert(xi.end(), nums.begin(), nums.begin() + n);\n    } else if (type == \"alternating\") {\n        if (n > s) {\n            fprintf(stderr, \"n cannot be greater than s\\n\");\n            return 1;\n        }\n        xi.reserve(n);\n        int low = 1;\n        int high = s;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                xi.push_back(low++);\n            else\n                xi.push_back(high--);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output xi\n    for (int i = 0; i < xi.size(); ++i) {\n        printf(\"%d\", xi[i]);\n        if (i + 1 < xi.size())\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type consecutive_start\n./gen -n 1 -type small_numbers\n./gen -n 1 -type large_numbers\n./gen -n 1 -type alternating\n./gen -n 2 -type alternating\n./gen -n 5 -type consecutive_end\n./gen -n 5 -type small_numbers\n./gen -n 5 -type large_numbers\n./gen -n 5 -type random\n./gen -n 5 -type alternating\n./gen -n 10 -type random\n./gen -n 100 -type middle\n./gen -n 100 -type small_numbers\n./gen -n 100 -type large_numbers\n./gen -n 1000 -type small_numbers\n./gen -n 1000 -type large_numbers\n./gen -n 1000 -type alternating\n./gen -n 10000 -type random\n./gen -n 10000 -type middle\n./gen -n 100000 -type middle\n./gen -n 500000 -type random\n./gen -n 500000 -type consecutive_start\n./gen -n 500000 -type consecutive_end\n./gen -n 500000 -type alternating\n./gen -n 499999 -type alternating\n./gen -n 100000 -type random\n./gen -n 100000 -type middle\n./gen -n 500000 -type middle\n./gen -n 100000 -type random\n./gen -n 500000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:17.300270",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "405/E",
      "title": "E. Graph Cutting",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two space-separated integers n and m (1 ≤ n, m ≤ 105), the number of vertices and the number of edges in the graph. The next m lines contain the description of the graph's edges. The i-th line contains two space-separated integers ai and bi (1 ≤ ai, bi ≤ n; ai ≠ bi), the numbers of the vertices connected by the i-th edge. It is guaranteed that the given graph is simple (without self-loops and multi-edges) and connected.Note: since the size of the input and output could be very large, don't use slow output techniques in your language. For example, do not use input and output streams (cin, cout) in C++.",
      "output_spec": "OutputIf it is possible to cut the given graph into edge-distinct paths of length 2, output  lines. In the i-th line print three space-separated integers xi, yi and zi, the description of the i-th path. The graph should contain this path, i.e., the graph should contain edges (xi, yi) and (yi, zi). Each edge should appear in exactly one path of length 2. If there are multiple solutions, output any of them.If it is impossible to cut the given graph, print \"No solution\" (without quotes).",
      "sample_tests": "ExamplesInputCopy8 121 22 33 44 11 32 43 53 65 66 76 87 8OutputCopy1 2 41 3 21 4 35 3 65 6 86 7 8InputCopy3 31 22 33 1OutputCopyNo solutionInputCopy3 21 22 3OutputCopy1 2 3",
      "description": "E. Graph Cutting\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains two space-separated integers n and m (1 ≤ n, m ≤ 105), the number of vertices and the number of edges in the graph. The next m lines contain the description of the graph's edges. The i-th line contains two space-separated integers ai and bi (1 ≤ ai, bi ≤ n; ai ≠ bi), the numbers of the vertices connected by the i-th edge. It is guaranteed that the given graph is simple (without self-loops and multi-edges) and connected.Note: since the size of the input and output could be very large, don't use slow output techniques in your language. For example, do not use input and output streams (cin, cout) in C++.\n\nOutputIf it is possible to cut the given graph into edge-distinct paths of length 2, output  lines. In the i-th line print three space-separated integers xi, yi and zi, the description of the i-th path. The graph should contain this path, i.e., the graph should contain edges (xi, yi) and (yi, zi). Each edge should appear in exactly one path of length 2. If there are multiple solutions, output any of them.If it is impossible to cut the given graph, print \"No solution\" (without quotes).\n\nInputCopy8 121 22 33 44 11 32 43 53 65 66 76 87 8OutputCopy1 2 41 3 21 4 35 3 65 6 86 7 8InputCopy3 31 22 33 1OutputCopyNo solutionInputCopy3 21 22 3OutputCopy1 2 3\n\nInputCopy8 121 22 33 44 11 32 43 53 65 66 76 87 8\n\nOutputCopy1 2 41 3 21 4 35 3 65 6 86 7 8\n\nInputCopy3 31 22 33 1\n\nOutputCopyNo solution\n\nInputCopy3 21 22 3\n\nOutputCopy1 2 3",
      "solutions": [
        {
          "title": "Codeforces Round #238 - Codeforces",
          "content": "Hello everyone!Codeforces round #238 will start today at 19:30 in Moscow time. The round will be held in both divisions.The round was prepared by me and cfk. This is the 4th round for me and the 2nd for Krisjanis. I think the problems this time are rather unusual and maybe even surprising. We have no doubt that everyone will find a problem that suits their taste! But you have to find it. (:As always, thanks to Mikhail Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems, and Maria Belova (Delinur) for translating the statements. Big thanks to Gerald Agapov (Gerald) for helping in preparation of the contest. Me and Gerald had a chance to talk about the problems onsite during the Petrozavodsk winter camp, which I think was very productive. We wish you a very exciting round!UPD1: Score distribution:DivI: 500 1000 2000 2000 2500DivII: 500 1000 1500 2000 3000The scoring for the problems is relative, so that the cost of each problem would be a multiple of 500 and closer to the objective estimate. Don't be afraid, the problems are not really that hard. (:UPD2: Congratulations to the winners!DivI: al13n Shef scott_wu sillycross Komaki DivII: NelsonMondialu L_Ecry aaaaAaaaaAaaaaAaaaaA xorfire Hec UPD3: Excellent round statistics from DmitriyH.UPD4: The contest tutorial is published here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11153",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1309
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces",
          "content": "405A - Gravity FlipObserve that in the final configuration the heights of the columns are in non-decreasing order. Also, the number of columns of each height remains the same. This means that the answer to the problem is the sorted sequence of the given column heights.Solution complexity: O(n), since we can sort by counting.405B - Domino EffectIf the first pushed domino from the left was pushed to the left at position l, all dominoes at prefix [1;l] fall down, otherwise let l be 0. Similarly, if the first pushed domino from the right was pushed to the right at position r, all dominoes at suffix [r;n] also fall down, otherwise let r be n + 1. Now, in the segment (l;r) there will remain vertical dominoes and blocks of dominoes supported by the equal forces from both sides.When does a domino at position p in segment (l, r) remains standing vertically? One way is that it is not pushed by any other domino. This could be easily checked by looking at the pushed dominoes closest to p (from both sides). It is pushed by dominoes, only if the closest from the left was pushed to the right, and the closest from the right was pushed to the left. Suppose these dominoes are at positions x and y, x < p < y. Then, the only way that the domino is still standing is if it is positioned at the center of the block [x;y], which could be checked by .Solution complexity: O(n) / O(n2), depends on implementation.406A - Unusual ProductWritten as a formula, the problem asks to find the value of Suppose that i ≠ j. Then the sum contains summands AijAji and AjiAij. Since the sum is taken modulo 2, these summands together give 0 to the sum. It follows that the expression is always equal to the sum of the diagonal bits: Now, each query of type 1 and 2 flips the value of exactly one bit on the diagonal. Thus we can calculate the unusual product of the original matrix, and flip its value after each query of type 1 and 2.Solution complexity: O(n + q), if we don't take the reading of the input into account... :)406B - Toy SumLet's define the symmetric number of k to be s + 1 - k. Since in this case s is an even number, k ≠ s - k.Note that (k - 1) + (s + 1 - k) = s, i.e., the sum of a number and its symmetric is always s. Let's process the given members x of X. There can be two cases: If the symmetric of x does not belong to X, we add it to Y. Both give equal values to the respective sums: x - 1 = s - (s + 1 - x). The symmetric of x belongs to X. Then we pick any y that neither y and symmetric of y belong to X, and add them to Y. Both pairs give equal values to the respective sums, namely s. How to prove that in the second step we can always find such y? Let the number of symmetric pairs that were processed in the step 1 be a, then there remain other pairs. Among them, for pairs both members belong to X, and for other pairs none of the members belong to X. To be able to pick the same number of pairs for Y, as there are in X, we should have which is equivalent to , as given in the statement.Solution complexity: O(s) / O(n).406C - Graph CuttingIt can be proved that only graphs with an odd number of edges cannot be partitioned into path of length 2. We will construct a recursive function that solves the problem and also serves as a proof for this statement.The function partition(v) will operate on non-blocked edges. It will partition the component of vertex v connected by the non-blocked edges into paths of length 2. If this component has an odd number of edges, the function will partition all the edges of the component, except one edge (u, v); the function then will return vertex u, expecting that the parent function call will assign it to some path.The function works as follows: find all vertices that are adjacent to v by the non-blocked edges, call this set adjacent. Then block all the edges from this set vertices to v. For each u in adjacent, call partition(u). Suppose partition(u) returned a vertex w. That means we can pair it into the path (v, u, w). Otherwise, if partition(u) does not return anything, we add u to unpaired, since the edge (v, u) is not yet in any path. We can pair any two vertices of this set u, w into a single path (u, v, w). We pair as much of them as possible in any order. If from this set a single vertex, u, is left unpaired, the function will return u. Otherwise the function will not return anything.The function could be implemented as a single DFS: partition(v) :\n adjacent = { u | not blocked[(u,v)] }\n for(u : adjacent)\n blocked[(u,v)] = true\n\n unpaired = {}\n for(u : adjacent)\n int w = partition(u)\n if(w = 0)\n add(unpaired, u)\n else\n print(v,u,w)\n\n while(size(unpaired) >= 2)\n int u = pop(unpaired)\n int w = pop(unpaired)\n print(u,v,w)\n\n if(not empty(unpaired))\n return pop(unpaired)\n else\n return 0Solution complexity: O(n + m).406D - Hill ClimbingNote that the path of each hill climber is strictly convex in any case. Let's draw the paths from all hills to the rightmost hill. Then these paths form a tree with the \"root\" at the top of the rightmost hill. We can apply the Graham scan from the right to the left to find the edges of this tree. Each pop and insert in the stack corresponds to a single edge in the tree.Now it is easy to see that for each team of climbers, we should calculate the number of the lowest common ancestor for the corresponding two vertices in the tree. The size if the tree is n, so each query works in .Solution complexity: .406E - Hamming TriplesLet's look at the Hamming graph of all possible distinct 2n strings, where each two strings are connected by an edge with length equal to the Hamming distance between these strings. We can observe that this graph has a nice property: if we arrange the vertices cyclically as a regular 2n-gon with a side length of 1, then the Hamming distance between two strings is the length of the shortest route between these vertices on the perimeter of the polygon.For example, the figure shows the graph for n = 3. The gray edges have length 1, the orange edges have length 2 and the blue edges have length 3. That is the corresponding Hamming distance.Now, we can convert each string coded by a pair (s, f) to an integer (f + 1)·n - s. The new numbers will be 0, 1, ..., 2n - 1 and correspond to the same cyclical order on the perimeter of the polygon. The given strings are mapped to some subset of the vertices. Now we have to find the number of triangles (possibly degenerate) with maximal perimeter in this subgraph. It will be useful to keep the new converted numbers sorted.First, we can figure out what this perimeter could be. If there exists a diameter in the full graph, so that all of the points are on one side of the diameter, the perimeter is 2d, where d is the length of the longest edge:Then any triangle with two vertices at the longest edge points and the third one being any point has the maximal perimeter. Since the numbers are sorted, the longest edge in this case will be produced by two cyclically adjacent elements, which is not hard to find.If for any diameter this does not hold, then the maximal perimeter is 2n. This can be proved by taking two different points a, b and drawing two diameters with them as endpoints; since it is not the previous case, there shoud be a third point c in area where the perimeter of triangle a, b, c is 2n.The tricky part is to count the triples in this case. We do this by working with the diameter (0, n). There can be several cases: A maximum triangle has vertices 0 and n. This a simple case: with any other vertex as the third the triangle has perimeter 2n. A maximum triangle has vertex 0, but not n. Then the second vertex should be in interval [0, n), and the third in interval (n + 1, 2n - 1], and the clockwise distance between the second and the third should not exceed n (since then the perimeter of the triangle would be less than 2n). We count the number of such triples iterating two pointers (one in each of these intervals). For each pointer in the first interval, all points from n + 1 till the second pointer will make a maximal perimeter triangle. We similarly solve the case where the maximal triangle has vertex n, but not 0. The maximal triangle does not have 0 or n as its vertices. Then one vertex of the triangle should be on one side of diameter (0, n), and two should be on the opposite side. To count them, we iterate a vertex pointer on the first side, say, (0, n); let the diametrally opposite vertex on the opposite side be x. Then the second vertex can be any in [n + 1, s], and the third can be any of the [s, 2n - 1]. It is easy to calculate these numbers using partial sums on the circle. Note that s can be both the second and the third vertex (since strings can repeat). So we iterate this pointer over all one side vertices and update the answer. Similarly we solve the case where a single vertex is on the other side, and two on this side. One only needs to be careful with the formulas in each case.Solution complexity: , because of the sorting.Post ScriptumWhat were your solutions? Feel free to share any solutions or thoughts! For example, was there a solution to DivI E simpler than in this tutorial?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11186",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 405 和字母"
          },
          "content_length": 9148
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #238 - Codeforces - Code 1",
          "code": "|   \n       |\n       |\n       |\n  |    |\n| |  | | \n1 2  3 4\n(In reversed order, from right to left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 2",
          "code": "|   \n       |\n       |\n       |\n  |    |\n| |  | | \n1 2  3 4\n(In reversed order, from right to left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 3",
          "code": "Push 1\nmake_edge(1,2) (i will not write these from now on)\nPush 2\ntry to pop the stack -> verify whether or not line segment 1 3 passes through hill 2 -> no -> no pop\nPush 3\ntry to pop the stack -> 2 4 is above 3, so we pop the stack\ntry to pop the stack -> 4 1 is above 2, so we pop the stack\n(make edge 1,4)\nPush 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 4",
          "code": "Push 1\nmake_edge(1,2) (i will not write these from now on)\nPush 2\ntry to pop the stack -> verify whether or not line segment 1 3 passes through hill 2 -> no -> no pop\nPush 3\ntry to pop the stack -> 2 4 is above 3, so we pop the stack\ntry to pop the stack -> 4 1 is above 2, so we pop the stack\n(make edge 1,4)\nPush 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 5",
          "code": "if(((1ll*stack[poz].x-stack[poz-1].x)*(1ll*v[i].h-stack[poz-1].h))<((1ll*stack[poz].h &mdash; 1ll*stack[poz-1].h)*(1ll*v[i].x-1ll*stack[poz-1].x)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 6",
          "code": "if(((1ll*stack[poz].x-stack[poz-1].x)*(1ll*v[i].h-stack[poz-1].h))<((1ll*stack[poz].h &mdash; 1ll*stack[poz-1].h)*(1ll*v[i].x-1ll*stack[poz-1].x)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 7",
          "code": "cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 8",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 9",
          "code": "ios :: sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 10",
          "code": "cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 11",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 12",
          "code": "string s; s.reserve(100005);\n\nfor (int i = 0; i < n; i++)\n{\n    cin >> s;\n\n    // do something\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 13",
          "code": "string s; s.reserve(100005);\n\nfor (int i = 0; i < n; i++)\n{\n    cin >> s;\n\n    // do something\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 14",
          "code": "#define dibs reserve",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 15",
          "code": "(X +- (2*Y))%2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 16",
          "code": "FastScanner",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 17",
          "code": "java.io.BufferedReader",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 1",
          "code": "partition(v)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 2",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 3",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 4",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 5",
          "code": "partition(v) :\n    adjacent = { u | not blocked[(u,v)] }\n    for(u : adjacent)\n        blocked[(u,v)] = true\n\n    unpaired = {}\n    for(u : adjacent)\n        int w = partition(u)\n        if(w = 0)\n            add(unpaired, u)\n        else\n            print(v,u,w)\n\n    while(size(unpaired) >= 2)\n        int u = pop(unpaired)\n        int w = pop(unpaired)\n        print(u,v,w)\n\n    if(not empty(unpaired))\n        return pop(unpaired)\n    else\n        return 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 6",
          "code": "partition(v) :\n    adjacent = { u | not blocked[(u,v)] }\n    for(u : adjacent)\n        blocked[(u,v)] = true\n\n    unpaired = {}\n    for(u : adjacent)\n        int w = partition(u)\n        if(w = 0)\n            add(unpaired, u)\n        else\n            print(v,u,w)\n\n    while(size(unpaired) >= 2)\n        int u = pop(unpaired)\n        int w = pop(unpaired)\n        print(u,v,w)\n\n    if(not empty(unpaired))\n        return pop(unpaired)\n    else\n        return 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 7",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, **u**)\n        **else**\n**            print(v,u,w)**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 8",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, **u**)\n        **else**\n**            print(v,u,w)**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 9",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 10",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 11",
          "code": "if(w = 0)\n    add(unpaired, u)\nelse\n    print(v,u,w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 12",
          "code": "if(w = 0)\n    add(unpaired, u)\nelse\n    print(v,u,w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++) parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) parent[x] = y;\n    };\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Self-loops are not allowed. Edge %d: ai = bi = %d\", i + 1, ai);\n\n        pair<int, int> edge = make_pair(min(ai, bi), max(ai, bi));\n\n        ensuref(edges.count(edge) == 0, \"Multiple edges are not allowed. Edge %d: between %d and %d\",\n            i + 1, ai, bi);\n\n        edges.insert(edge);\n\n        unite(ai, bi);\n    }\n\n    int root = find(1);\n    for (int i = 2; i <= n; i++) {\n        ensuref(find(i) == root, \"The graph is not connected. Node %d is not connected to node 1\", i);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++) parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) parent[x] = y;\n    };\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Self-loops are not allowed. Edge %d: ai = bi = %d\", i + 1, ai);\n\n        pair<int, int> edge = make_pair(min(ai, bi), max(ai, bi));\n\n        ensuref(edges.count(edge) == 0, \"Multiple edges are not allowed. Edge %d: between %d and %d\",\n            i + 1, ai, bi);\n\n        edges.insert(edge);\n\n        unite(ai, bi);\n    }\n\n    int root = find(1);\n    for (int i = 2; i <= n; i++) {\n        ensuref(find(i) == root, \"The graph is not connected. Node %d is not connected to node 1\", i);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++) parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) parent[x] = y;\n    };\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Self-loops are not allowed. Edge %d: ai = bi = %d\", i + 1, ai);\n\n        pair<int, int> edge = make_pair(min(ai, bi), max(ai, bi));\n\n        ensuref(edges.count(edge) == 0, \"Multiple edges are not allowed. Edge %d: between %d and %d\",\n            i + 1, ai, bi);\n\n        edges.insert(edge);\n\n        unite(ai, bi);\n    }\n\n    int root = find(1);\n    for (int i = 2; i <= n; i++) {\n        ensuref(find(i) == root, \"The graph is not connected. Node %d is not connected to node 1\", i);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   Checker for the problem:\n   \"Cut a connected undirected simple graph into edge-disjoint paths of length 2,\n   or determine that it is impossible.\"\n\n   Since there may be multiple valid ways to partition the edges, this checker\n   reads the jury's answer as well as the participant's answer. It verifies:\n     1) Whether the jury's answer is valid or is \"No solution\".\n     2) Whether the participant's answer is valid or is \"No solution\".\n     3) If the jury claims \"No solution\" but the participant provides a valid solution,\n        we conclude the jury was wrong => _fail.\n     4) If the jury provides a valid solution but the participant says \"No solution\",\n        participant is wrong => _wa.\n     5) Otherwise, if the participant gives an answer that conflicts with the jury's,\n        we judge accordingly (_fail if the jury is incorrect, _wa if the participant is incorrect).\n     6) If both solutions match (both \"No solution\" or both valid partitions), we conclude _ok.\n*/\n\nstatic const string NO_SOLUTION_TOKEN = \"No solution\";\n\n// We'll store an ID for each edge (u,v) with u < v in a map so that we can mark usage.\nint n, m;\n\n// We'll store adjacency in a map: (min(u,v), max(u,v)) -> edgeID\n// Then we'll have a vector<bool> to mark whether an edge is used or not in the solutions.\nunordered_map<long long, int> edgeID;  // key = (long long)u<<32 | v, ensuring u < v\n// Utility to encode an unordered pair (u, v) with u < v\ninline long long encodeEdge(int a, int b) {\n    if (a > b) std::swap(a,b);\n    // store in a 64-bit to avoid collisions: hi= a, lo = b\n    // since n up to 1e5, it fits in 32 bits each\n    return ( (long long)a << 32 ) ^ (long long)b;\n}\n\n// Data structure to store the result from reading a solution\nstruct SolutionResult {\n    bool isNoSolution;\n    bool valid; // if we parsed a solution (not \"No solution\"), is it valid overall?\n};\n\n// Reads either \"No solution\" (exact match in case-sensitive manner is not required by problem statement,\n// but the statement specifically says print \"No solution\" -- the safe approach is exact compare or token-based parse).\n// Or reads exactly m/2 lines of triples (x y z), with each triple forming edges (x,y) and (y,z).\n//\n// If the solution is \"No solution\", we skip reading further tokens and check that no extra tokens are present afterwards.\n// If the solution is not \"No solution\", we attempt to read exactly m/2 lines of 3 integers each (unless m is odd, which\n// should be invalid because you can't pair up edges).\n// We'll fill in a local usage array for the edges. If any conflict or invalid usage is found, we quitf with either _fail\n// (isOfficial) or _wa (not isOfficial).\nSolutionResult readSolution(InStream &stream, bool isOfficial,\n                            const vector<bool> &initialUsed, // for safety copy\n                            const unordered_map<long long,int> &edgeIDMap) {\n\n    SolutionResult res;\n    res.isNoSolution = false;\n    res.valid = false;\n\n    // We'll do a peek: if next token is \"No\", we check if the following is \"solution\", else read normally.\n    // A simpler approach is to read a line, trim it, and compare. However, testlib also\n    // supports reading a token or line. We'll attempt that.\n\n    // Try reading one token. If it is exactly \"No\" or \"No solution\", we proceed.\n    // But the statement's sample exactly says \"No solution\". We'll handle that exact spelled phrase.\n    // If the token is \"No\" we next check if next token is \"solution\" to form \"No solution\".\n    // Or we can read a line. For simplicity, read a line:\n    stream.seekEof(); // check if there's no tokens at all?\n    // If no tokens at all, that might be an invalid situation if the official solution or participant solution\n    // is empty. We'll allow \"No solution\" can appear as a single line or not. Let's be more direct:\n\n    // We'll read up to 3 integers or check if the first token is \"No\" or \"No solution\".\n    // We'll do a safe approach: readString() and see if it matches \"No\".\n\n    // But we also need to handle that the participant might produce extra blank lines, etc.\n    // We'll do a guard: if there's no tokens, we interpret that as \"No solution\"? Actually that doesn't match\n    // the required output. We'll produce WA or FAIL in that scenario.\n\n    // We'll attempt to read a token. If the stream is at EOF, that is invalid => no tokens at all -> WA/fail\n    if (!stream.seekEof()) {\n        // We haven't reached EOF, let's read a token\n        string firstToken = stream.readToken();\n\n        // Check if it matches \"No\" , then the next token might be \"solution\". If yes, we interpret as \"No solution\".\n        // Alternatively, it might be \"No solution\" in one token or \"NoSolution\" or \"No.\" This is ambiguous.\n        // The statement specifically says to print \"No solution\" (with space). We'll handle exactly that scenario.\n        if (firstToken == \"No\") {\n            // we expect another token \"solution\"\n            if (stream.eof()) {\n                // ended abruptly\n                stream.quitf(isOfficial ? _fail : _wa, \n                             \"Output ends with 'No' but not followed by 'solution'\");\n            }\n            string secondToken = stream.readToken();\n            if (secondToken != \"solution\")\n                stream.quitf(isOfficial ? _fail : _wa,\n                             \"Expected \\\"No solution\\\", found \\\"No %s\\\"\", secondToken.c_str());\n            // Now we check if there's any extraneous tokens\n            if (!stream.seekEof()) {\n                // There's more stuff\n                stream.quitf(isOfficial ? _fail : _wa,\n                             \"Extraneous data after \\\"No solution\\\"\");\n            }\n            // If we reach here, it's exactly \"No solution\" with no extra tokens\n            res.isNoSolution = true;\n            res.valid = true; // \"No solution\" can be considered a 'valid' expression of impossibility\n            return res;\n        }\n        else if (firstToken == \"No solution\") {\n            // check extraneous tokens\n            if (!stream.seekEof()) {\n                // There's more stuff\n                stream.quitf(isOfficial ? _fail : _wa,\n                             \"Extraneous data after \\\"No solution\\\"\");\n            }\n            res.isNoSolution = true;\n            res.valid = true;\n            return res;\n        }\n        // If not \"No\" or \"No solution\", then we interpret it as the first integer of a triple\n        // We'll push it back or treat it as read. We have the first integer in 'firstToken'.\n        // Let's parse it as an integer.\n        // If parse fails, we quit.\n        int x;\n        // We can try to parse:\n        try {\n            x = stoi(firstToken);\n        }\n        catch (...) {\n            // not an integer => WA/fail\n            stream.quitf(isOfficial ? _fail : _wa,\n                         \"Expected either \\\"No solution\\\" or an integer, got \\\"%s\\\"\",\n                         firstToken.c_str());\n        }\n\n        // If m is odd, a valid partition is impossible. So if the solution is not \"No solution\", it must fail:\n        if (m % 2 == 1) {\n            stream.quitf(isOfficial ? _fail : _wa,\n                         \"A valid partition is impossible when m is odd, but an attempt to give a solution was found\");\n        }\n\n        // We proceed to read exactly m/2 lines of triples (the first integer is x, we must read y, z).\n        vector<bool> used = initialUsed; // local copy to mark usage\n\n        // We'll interpret that the first integer x is part of triple #1. Then read y,z for that triple.\n        int y = stream.readInt(1, n, \"y in triple\");\n        int z = stream.readInt(1, n, \"z in triple\");\n        // check edges\n        auto e1 = encodeEdge(x,y);\n        auto e2 = encodeEdge(y,z);\n\n        if (edgeIDMap.find(e1) == edgeIDMap.end())\n            stream.quitf(isOfficial ? _fail : _wa,\n                         \"Edge (%d, %d) does not exist in the graph\", x, y);\n        if (edgeIDMap.find(e2) == edgeIDMap.end())\n            stream.quitf(isOfficial ? _fail : _wa,\n                         \"Edge (%d, %d) does not exist in the graph\", y, z);\n\n        int id1 = edgeIDMap.at(e1);\n        int id2 = edgeIDMap.at(e2);\n        if (used[id1])\n            stream.quitf(isOfficial ? _fail : _wa,\n                         \"Edge (%d, %d) is used more than once\", x, y);\n        if (used[id2])\n            stream.quitf(isOfficial ? _fail : _wa,\n                         \"Edge (%d, %d) is used more than once\", y, z);\n        used[id1] = used[id2] = true;\n\n        // We'll read the remaining (m/2 - 1) lines\n        for (int i = 1; i < m/2; i++) {\n            int xx = stream.readInt(1, n, \"x in triple\");\n            int yy = stream.readInt(1, n, \"y in triple\");\n            int zz = stream.readInt(1, n, \"z in triple\");\n\n            auto ee1 = encodeEdge(xx, yy);\n            auto ee2 = encodeEdge(yy, zz);\n\n            if (edgeIDMap.find(ee1) == edgeIDMap.end())\n                stream.quitf(isOfficial ? _fail : _wa,\n                             \"Edge (%d, %d) does not exist in the graph\", xx, yy);\n            if (edgeIDMap.find(ee2) == edgeIDMap.end())\n                stream.quitf(isOfficial ? _fail : _wa,\n                             \"Edge (%d, %d) does not exist in the graph\", yy, zz);\n\n            int i1 = edgeIDMap.at(ee1);\n            int i2 = edgeIDMap.at(ee2);\n            if (used[i1])\n                stream.quitf(isOfficial ? _fail : _wa,\n                             \"Edge (%d, %d) is used more than once\", xx, yy);\n            if (used[i2])\n                stream.quitf(isOfficial ? _fail : _wa,\n                             \"Edge (%d, %d) is used more than once\", yy, zz);\n            used[i1] = used[i2] = true;\n        }\n\n        // Now we must check that there's no extra tokens after these m/2 lines\n        if (!stream.seekEof())\n            stream.quitf(isOfficial ? _fail : _wa,\n                         \"Extraneous data after reading exactly m/2 triples\");\n\n        // Finally, check that all edges are used\n        for (bool u : used) {\n            if (!u) {\n                stream.quitf(isOfficial ? _fail : _wa,\n                             \"Not all edges are used in the claimed partition\");\n            }\n        }\n\n        // If we get here, it's a valid partition\n        res.isNoSolution = false;\n        res.valid = true;\n        return res;\n    }\n    else {\n        // The solution file has no tokens at all => interpret that as \"No solution\"? The statement does not say\n        // we can output an empty file for \"No solution.\" We'll produce WA/fail.\n        stream.quitf(isOfficial ? _fail : _wa,\n                     \"No output found, expected either \\\"No solution\\\" or a valid partition\");\n        // unreachable\n        return res;\n    }\n}\n\nint main(int argc, char* argv[]){\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(); \n    m = inf.readInt();\n\n    // We'll read the edges and build the edgeID map\n    // We assume 1 <= u, v <= n, u != v, graph is simple and connected (not enforced here, but it's given).\n    edgeID.reserve(m*2ULL);\n    vector<bool> usedJury(m, false);\n    vector<bool> usedPart(m, false);\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt();\n        int b = inf.readInt();\n        if (a == b)\n            inf.quitf(_fail, \"Self-loop in the input, which must not happen (problem states simple graph)\");\n        long long code = encodeEdge(a, b);\n        if (edgeID.find(code) != edgeID.end())\n            inf.quitf(_fail, \"Multi-edge in the input, which must not happen (problem states simple graph)\");\n        edgeID[code] = i; \n    }\n\n    // Read the jury's solution from ans\n    SolutionResult juryRes = readSolution(ans, /*isOfficial=*/true, usedJury, edgeID);\n\n    // Read the participant's solution from ouf\n    SolutionResult partRes = readSolution(ouf, /*isOfficial=*/false, usedPart, edgeID);\n\n    // Now decide outcome:\n    if (!juryRes.valid) {\n        // Jury's solution was invalid => we've already quitf(_fail) inside readSolution.\n        // So we never get here actually, but just in case:\n        quitf(_fail, \"Invalid jury's answer\");\n    }\n\n    if (juryRes.isNoSolution) {\n        // Jury claims no solution\n        if (partRes.isNoSolution) {\n            // Both say no solution => OK\n            quitf(_ok, \"Both claim no solution\");\n        } else {\n            // Participant found a valid partition => jury is wrong => _fail\n            if (partRes.valid) {\n                quitf(_fail, \"Jury said no solution but participant provided a valid solution\");\n            } else {\n                // participant's solution is invalid => we judge that participant is also wrong\n                quitf(_wa, \"Jury said no solution, participant's solution is invalid anyway\");\n            }\n        }\n    } else {\n        // Jury found a valid solution\n        if (partRes.isNoSolution) {\n            // Participant says no solution => participant is wrong => WA\n            quitf(_wa, \"Jury found a valid solution, but participant claims no solution\");\n        } else {\n            // Both solutions are valid => OK\n            quitf(_ok, \"Participant's solution is valid\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    if (type == \"tree\") {\n        // Generate a tree with n nodes\n        int m = n - 1;\n        vector<pair<int,int>> edges;\n        for (int i = 2; i <= n; ++i) {\n            int u = rnd.next(1, i - 1);\n            edges.push_back(make_pair(u, i));\n        }\n        shuffle(edges.begin(), edges.end());\n        printf(\"%d %d\\n\", n, m);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if (type == \"cycle\") {\n        // Generate a cycle graph\n        int m = n;\n        vector<pair<int,int>> edges;\n        for (int i = 1; i <= n; ++i) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back(make_pair(u, v));\n        }\n        shuffle(edges.begin(), edges.end());\n        printf(\"%d %d\\n\", n, m);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if (type == \"star\") {\n        // Generate a star-shaped graph\n        int m = n - 1;\n        vector<pair<int,int>> edges;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back(make_pair(1, i));\n        }\n        shuffle(edges.begin(), edges.end());\n        printf(\"%d %d\\n\", n, m);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if (type == \"random\") {\n        // Generate a random connected graph with n nodes and m edges\n        int m = opt<int>(\"m\");\n        if (m < n - 1 || m > (long long)n * (n - 1) / 2) {\n            fprintf(stderr, \"Invalid number of edges m: %d\\n\", m);\n            exit(1);\n        }\n        vector<pair<int,int>> edges;\n        // Generate a random tree first to ensure connectivity\n        for (int i = 2; i <= n; ++i) {\n            int u = rnd.next(1, i - 1);\n            edges.push_back(make_pair(u, i));\n        }\n        set<pair<int,int>> edge_set;\n        for (auto e : edges) {\n            int u = e.first;\n            int v = e.second;\n            if (u > v) swap(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n        // Add extra edges\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count(make_pair(u, v))) continue;\n            edge_set.insert(make_pair(u, v));\n            edges.push_back(make_pair(u, v));\n        }\n        shuffle(edges.begin(), edges.end());\n        printf(\"%d %d\\n\", n, m);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else {\n        // Error: unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    if (type == \"tree\") {\n        // Generate a tree with n nodes\n        int m = n - 1;\n        vector<pair<int,int>> edges;\n        for (int i = 2; i <= n; ++i) {\n            int u = rnd.next(1, i - 1);\n            edges.push_back(make_pair(u, i));\n        }\n        shuffle(edges.begin(), edges.end());\n        printf(\"%d %d\\n\", n, m);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if (type == \"cycle\") {\n        // Generate a cycle graph\n        int m = n;\n        vector<pair<int,int>> edges;\n        for (int i = 1; i <= n; ++i) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back(make_pair(u, v));\n        }\n        shuffle(edges.begin(), edges.end());\n        printf(\"%d %d\\n\", n, m);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if (type == \"star\") {\n        // Generate a star-shaped graph\n        int m = n - 1;\n        vector<pair<int,int>> edges;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back(make_pair(1, i));\n        }\n        shuffle(edges.begin(), edges.end());\n        printf(\"%d %d\\n\", n, m);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if (type == \"random\") {\n        // Generate a random connected graph with n nodes and m edges\n        int m = opt<int>(\"m\");\n        if (m < n - 1 || m > (long long)n * (n - 1) / 2) {\n            fprintf(stderr, \"Invalid number of edges m: %d\\n\", m);\n            exit(1);\n        }\n        vector<pair<int,int>> edges;\n        // Generate a random tree first to ensure connectivity\n        for (int i = 2; i <= n; ++i) {\n            int u = rnd.next(1, i - 1);\n            edges.push_back(make_pair(u, i));\n        }\n        set<pair<int,int>> edge_set;\n        for (auto e : edges) {\n            int u = e.first;\n            int v = e.second;\n            if (u > v) swap(u, v);\n            edge_set.insert(make_pair(u, v));\n        }\n        // Add extra edges\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count(make_pair(u, v))) continue;\n            edge_set.insert(make_pair(u, v));\n            edges.push_back(make_pair(u, v));\n        }\n        shuffle(edges.begin(), edges.end());\n        printf(\"%d %d\\n\", n, m);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else {\n        // Error: unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small tree with odd n (n = 3, m = 2)\n./gen -n 3 -type tree\n# Small tree with even n (n = 4, m = 3)\n./gen -n 4 -type tree\n\n# Small cycle with odd n (n = 3, m = 3)\n./gen -n 3 -type cycle\n# Small cycle with even n (n = 4, m = 4)\n./gen -n 4 -type cycle\n\n# Small star graph (n = 5, m = 4)\n./gen -n 5 -type star\n\n# Random graph with n = 10, m = 15\n./gen -n 10 -type random -m 15\n# Random graph with n = 10, m = 20 (maximum edges for n=10)\n./gen -n 10 -type random -m 45\n\n# Tree with n = 1000 (large tree)\n./gen -n 1000 -type tree\n# Cycle with n = 1000 (large cycle)\n./gen -n 1000 -type cycle\n# Star graph with n = 1000\n./gen -n 1000 -type star\n\n# Random graph with n = 1000, m = 5000\n./gen -n 1000 -type random -m 5000\n# Random graph with n = 1000, m = 10000 (dense graph)\n./gen -n 1000 -type random -m 10000\n\n# Tree with n = 100000 (maximum n)\n./gen -n 100000 -type tree\n# Cycle with n = 100000\n./gen -n 100000 -type cycle\n# Star graph with n = 100000\n./gen -n 100000 -type star\n\n# Random graph with n = 100000, m = 150000\n./gen -n 100000 -type random -m 150000\n# Random graph with n = 100000, m = 200000 (maximum m)\n./gen -n 100000 -type random -m 200000\n\n# Tree with even n (n = 6) to test cases where m is odd (no solution expected)\n./gen -n 6 -type tree\n# Cycle with odd n (n = 5) to test cases where m is odd (no solution expected)\n./gen -n 5 -type cycle\n\n# Random graph with n = 50000, m = 99999 (m is odd, no solution expected)\n./gen -n 50000 -type random -m 99999\n\n# Random graph with minimal edges (n = 1000, m = n - 1)\n./gen -n 1000 -type random -m 999\n\n# Random graph with maximal edges for given n (n = 500, m = n*(n-1)/2)\n./gen -n 500 -type random -m 124750\n\n# Star graph with n = 7 (small odd n, m even)\n./gen -n 7 -type star\n# Star graph with n = 8 (small even n, m odd)\n./gen -n 8 -type star\n\n# Random graph with n = 10000, m = 15000 (sparse graph)\n./gen -n 10000 -type random -m 15000\n# Random graph with n = 10000, m = 49995000 (dense graph is invalid due to m > 1e5)\n# Adjust m to the maximum allowed (1e5)\n./gen -n 10000 -type random -m 100000\n\n# Tree with n = 99999 (large n, m is even)\n./gen -n 99999 -type tree\n# Tree with n = 100000 (n even, m odd, expect \"No solution\")\n./gen -n 100000 -type tree\n\n# Cycle with n = 99998 (n even, m even)\n./gen -n 99998 -type cycle\n# Cycle with n = 99999 (n odd, m odd, expect \"No solution\")\n./gen -n 99999 -type cycle\n\n# Star graph with n = 99999 (n odd, m even)\n./gen -n 99999 -type star\n# Star graph with n = 100000 (n even, m odd, expect \"No solution\")\n./gen -n 100000 -type star\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:19.306210",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "406/A",
      "title": "A. Unusual Product",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains an integer n (1 ≤ n ≤ 1000), the number of rows and the number of columns in the matrix A. The next n lines describe the matrix: the i-th line contains n space-separated bits and describes the i-th row of A. The j-th number of the i-th line aij (0 ≤ aij ≤ 1) is the element on the intersection of the i-th row and the j-th column of A.The next line of input contains an integer q (1 ≤ q ≤ 106), the number of queries. Each of the next q lines describes a single query, which can be one of the following:   1 i — flip the values of the i-th row;  2 i — flip the values of the i-th column;  3 — output the unusual square of A. Note: since the size of the input and output could be very large, don't use slow output techniques in your language. For example, do not use input and output streams (cin, cout) in C++.",
      "output_spec": "OutputLet the number of the 3rd type queries in the input be m. Output a single string s of length m, where the i-th symbol of s is the value of the unusual square of A for the i-th query of the 3rd type as it appears in the input.",
      "sample_tests": "ExamplesInputCopy31 1 10 1 11 0 01232 332 22 21 3331 22 11 13OutputCopy01001",
      "description": "A. Unusual Product\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains an integer n (1 ≤ n ≤ 1000), the number of rows and the number of columns in the matrix A. The next n lines describe the matrix: the i-th line contains n space-separated bits and describes the i-th row of A. The j-th number of the i-th line aij (0 ≤ aij ≤ 1) is the element on the intersection of the i-th row and the j-th column of A.The next line of input contains an integer q (1 ≤ q ≤ 106), the number of queries. Each of the next q lines describes a single query, which can be one of the following:   1 i — flip the values of the i-th row;  2 i — flip the values of the i-th column;  3 — output the unusual square of A. Note: since the size of the input and output could be very large, don't use slow output techniques in your language. For example, do not use input and output streams (cin, cout) in C++.\n\nOutputLet the number of the 3rd type queries in the input be m. Output a single string s of length m, where the i-th symbol of s is the value of the unusual square of A for the i-th query of the 3rd type as it appears in the input.\n\nInputCopy31 1 10 1 11 0 01232 332 22 21 3331 22 11 13OutputCopy01001\n\nInputCopy31 1 10 1 11 0 01232 332 22 21 3331 22 11 13\n\nOutputCopy01001",
      "solutions": [
        {
          "title": "Codeforces Round #238 - Codeforces",
          "content": "Hello everyone!Codeforces round #238 will start today at 19:30 in Moscow time. The round will be held in both divisions.The round was prepared by me and cfk. This is the 4th round for me and the 2nd for Krisjanis. I think the problems this time are rather unusual and maybe even surprising. We have no doubt that everyone will find a problem that suits their taste! But you have to find it. (:As always, thanks to Mikhail Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems, and Maria Belova (Delinur) for translating the statements. Big thanks to Gerald Agapov (Gerald) for helping in preparation of the contest. Me and Gerald had a chance to talk about the problems onsite during the Petrozavodsk winter camp, which I think was very productive. We wish you a very exciting round!UPD1: Score distribution:DivI: 500 1000 2000 2000 2500DivII: 500 1000 1500 2000 3000The scoring for the problems is relative, so that the cost of each problem would be a multiple of 500 and closer to the objective estimate. Don't be afraid, the problems are not really that hard. (:UPD2: Congratulations to the winners!DivI: al13n Shef scott_wu sillycross Komaki DivII: NelsonMondialu L_Ecry aaaaAaaaaAaaaaAaaaaA xorfire Hec UPD3: Excellent round statistics from DmitriyH.UPD4: The contest tutorial is published here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11153",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1309
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces",
          "content": "405A - Gravity FlipObserve that in the final configuration the heights of the columns are in non-decreasing order. Also, the number of columns of each height remains the same. This means that the answer to the problem is the sorted sequence of the given column heights.Solution complexity: O(n), since we can sort by counting.405B - Domino EffectIf the first pushed domino from the left was pushed to the left at position l, all dominoes at prefix [1;l] fall down, otherwise let l be 0. Similarly, if the first pushed domino from the right was pushed to the right at position r, all dominoes at suffix [r;n] also fall down, otherwise let r be n + 1. Now, in the segment (l;r) there will remain vertical dominoes and blocks of dominoes supported by the equal forces from both sides.When does a domino at position p in segment (l, r) remains standing vertically? One way is that it is not pushed by any other domino. This could be easily checked by looking at the pushed dominoes closest to p (from both sides). It is pushed by dominoes, only if the closest from the left was pushed to the right, and the closest from the right was pushed to the left. Suppose these dominoes are at positions x and y, x < p < y. Then, the only way that the domino is still standing is if it is positioned at the center of the block [x;y], which could be checked by .Solution complexity: O(n) / O(n2), depends on implementation.406A - Unusual ProductWritten as a formula, the problem asks to find the value of Suppose that i ≠ j. Then the sum contains summands AijAji and AjiAij. Since the sum is taken modulo 2, these summands together give 0 to the sum. It follows that the expression is always equal to the sum of the diagonal bits: Now, each query of type 1 and 2 flips the value of exactly one bit on the diagonal. Thus we can calculate the unusual product of the original matrix, and flip its value after each query of type 1 and 2.Solution complexity: O(n + q), if we don't take the reading of the input into account... :)406B - Toy SumLet's define the symmetric number of k to be s + 1 - k. Since in this case s is an even number, k ≠ s - k.Note that (k - 1) + (s + 1 - k) = s, i.e., the sum of a number and its symmetric is always s. Let's process the given members x of X. There can be two cases: If the symmetric of x does not belong to X, we add it to Y. Both give equal values to the respective sums: x - 1 = s - (s + 1 - x). The symmetric of x belongs to X. Then we pick any y that neither y and symmetric of y belong to X, and add them to Y. Both pairs give equal values to the respective sums, namely s. How to prove that in the second step we can always find such y? Let the number of symmetric pairs that were processed in the step 1 be a, then there remain other pairs. Among them, for pairs both members belong to X, and for other pairs none of the members belong to X. To be able to pick the same number of pairs for Y, as there are in X, we should have which is equivalent to , as given in the statement.Solution complexity: O(s) / O(n).406C - Graph CuttingIt can be proved that only graphs with an odd number of edges cannot be partitioned into path of length 2. We will construct a recursive function that solves the problem and also serves as a proof for this statement.The function partition(v) will operate on non-blocked edges. It will partition the component of vertex v connected by the non-blocked edges into paths of length 2. If this component has an odd number of edges, the function will partition all the edges of the component, except one edge (u, v); the function then will return vertex u, expecting that the parent function call will assign it to some path.The function works as follows: find all vertices that are adjacent to v by the non-blocked edges, call this set adjacent. Then block all the edges from this set vertices to v. For each u in adjacent, call partition(u). Suppose partition(u) returned a vertex w. That means we can pair it into the path (v, u, w). Otherwise, if partition(u) does not return anything, we add u to unpaired, since the edge (v, u) is not yet in any path. We can pair any two vertices of this set u, w into a single path (u, v, w). We pair as much of them as possible in any order. If from this set a single vertex, u, is left unpaired, the function will return u. Otherwise the function will not return anything.The function could be implemented as a single DFS: partition(v) :\n adjacent = { u | not blocked[(u,v)] }\n for(u : adjacent)\n blocked[(u,v)] = true\n\n unpaired = {}\n for(u : adjacent)\n int w = partition(u)\n if(w = 0)\n add(unpaired, u)\n else\n print(v,u,w)\n\n while(size(unpaired) >= 2)\n int u = pop(unpaired)\n int w = pop(unpaired)\n print(u,v,w)\n\n if(not empty(unpaired))\n return pop(unpaired)\n else\n return 0Solution complexity: O(n + m).406D - Hill ClimbingNote that the path of each hill climber is strictly convex in any case. Let's draw the paths from all hills to the rightmost hill. Then these paths form a tree with the \"root\" at the top of the rightmost hill. We can apply the Graham scan from the right to the left to find the edges of this tree. Each pop and insert in the stack corresponds to a single edge in the tree.Now it is easy to see that for each team of climbers, we should calculate the number of the lowest common ancestor for the corresponding two vertices in the tree. The size if the tree is n, so each query works in .Solution complexity: .406E - Hamming TriplesLet's look at the Hamming graph of all possible distinct 2n strings, where each two strings are connected by an edge with length equal to the Hamming distance between these strings. We can observe that this graph has a nice property: if we arrange the vertices cyclically as a regular 2n-gon with a side length of 1, then the Hamming distance between two strings is the length of the shortest route between these vertices on the perimeter of the polygon.For example, the figure shows the graph for n = 3. The gray edges have length 1, the orange edges have length 2 and the blue edges have length 3. That is the corresponding Hamming distance.Now, we can convert each string coded by a pair (s, f) to an integer (f + 1)·n - s. The new numbers will be 0, 1, ..., 2n - 1 and correspond to the same cyclical order on the perimeter of the polygon. The given strings are mapped to some subset of the vertices. Now we have to find the number of triangles (possibly degenerate) with maximal perimeter in this subgraph. It will be useful to keep the new converted numbers sorted.First, we can figure out what this perimeter could be. If there exists a diameter in the full graph, so that all of the points are on one side of the diameter, the perimeter is 2d, where d is the length of the longest edge:Then any triangle with two vertices at the longest edge points and the third one being any point has the maximal perimeter. Since the numbers are sorted, the longest edge in this case will be produced by two cyclically adjacent elements, which is not hard to find.If for any diameter this does not hold, then the maximal perimeter is 2n. This can be proved by taking two different points a, b and drawing two diameters with them as endpoints; since it is not the previous case, there shoud be a third point c in area where the perimeter of triangle a, b, c is 2n.The tricky part is to count the triples in this case. We do this by working with the diameter (0, n). There can be several cases: A maximum triangle has vertices 0 and n. This a simple case: with any other vertex as the third the triangle has perimeter 2n. A maximum triangle has vertex 0, but not n. Then the second vertex should be in interval [0, n), and the third in interval (n + 1, 2n - 1], and the clockwise distance between the second and the third should not exceed n (since then the perimeter of the triangle would be less than 2n). We count the number of such triples iterating two pointers (one in each of these intervals). For each pointer in the first interval, all points from n + 1 till the second pointer will make a maximal perimeter triangle. We similarly solve the case where the maximal triangle has vertex n, but not 0. The maximal triangle does not have 0 or n as its vertices. Then one vertex of the triangle should be on one side of diameter (0, n), and two should be on the opposite side. To count them, we iterate a vertex pointer on the first side, say, (0, n); let the diametrally opposite vertex on the opposite side be x. Then the second vertex can be any in [n + 1, s], and the third can be any of the [s, 2n - 1]. It is easy to calculate these numbers using partial sums on the circle. Note that s can be both the second and the third vertex (since strings can repeat). So we iterate this pointer over all one side vertices and update the answer. Similarly we solve the case where a single vertex is on the other side, and two on this side. One only needs to be careful with the formulas in each case.Solution complexity: , because of the sorting.Post ScriptumWhat were your solutions? Feel free to share any solutions or thoughts! For example, was there a solution to DivI E simpler than in this tutorial?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11186",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 406\\s*A"
          },
          "content_length": 9148
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #238 - Codeforces - Code 1",
          "code": "|   \n       |\n       |\n       |\n  |    |\n| |  | | \n1 2  3 4\n(In reversed order, from right to left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 2",
          "code": "|   \n       |\n       |\n       |\n  |    |\n| |  | | \n1 2  3 4\n(In reversed order, from right to left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 3",
          "code": "Push 1\nmake_edge(1,2) (i will not write these from now on)\nPush 2\ntry to pop the stack -> verify whether or not line segment 1 3 passes through hill 2 -> no -> no pop\nPush 3\ntry to pop the stack -> 2 4 is above 3, so we pop the stack\ntry to pop the stack -> 4 1 is above 2, so we pop the stack\n(make edge 1,4)\nPush 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 4",
          "code": "Push 1\nmake_edge(1,2) (i will not write these from now on)\nPush 2\ntry to pop the stack -> verify whether or not line segment 1 3 passes through hill 2 -> no -> no pop\nPush 3\ntry to pop the stack -> 2 4 is above 3, so we pop the stack\ntry to pop the stack -> 4 1 is above 2, so we pop the stack\n(make edge 1,4)\nPush 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 5",
          "code": "if(((1ll*stack[poz].x-stack[poz-1].x)*(1ll*v[i].h-stack[poz-1].h))<((1ll*stack[poz].h &mdash; 1ll*stack[poz-1].h)*(1ll*v[i].x-1ll*stack[poz-1].x)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 6",
          "code": "if(((1ll*stack[poz].x-stack[poz-1].x)*(1ll*v[i].h-stack[poz-1].h))<((1ll*stack[poz].h &mdash; 1ll*stack[poz-1].h)*(1ll*v[i].x-1ll*stack[poz-1].x)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 7",
          "code": "cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 8",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 9",
          "code": "ios :: sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 10",
          "code": "cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 11",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 12",
          "code": "string s; s.reserve(100005);\n\nfor (int i = 0; i < n; i++)\n{\n    cin >> s;\n\n    // do something\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 13",
          "code": "string s; s.reserve(100005);\n\nfor (int i = 0; i < n; i++)\n{\n    cin >> s;\n\n    // do something\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 14",
          "code": "#define dibs reserve",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 15",
          "code": "(X +- (2*Y))%2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 16",
          "code": "FastScanner",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 17",
          "code": "java.io.BufferedReader",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 1",
          "code": "partition(v)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 2",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 3",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 4",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 5",
          "code": "partition(v) :\n    adjacent = { u | not blocked[(u,v)] }\n    for(u : adjacent)\n        blocked[(u,v)] = true\n\n    unpaired = {}\n    for(u : adjacent)\n        int w = partition(u)\n        if(w = 0)\n            add(unpaired, u)\n        else\n            print(v,u,w)\n\n    while(size(unpaired) >= 2)\n        int u = pop(unpaired)\n        int w = pop(unpaired)\n        print(u,v,w)\n\n    if(not empty(unpaired))\n        return pop(unpaired)\n    else\n        return 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 6",
          "code": "partition(v) :\n    adjacent = { u | not blocked[(u,v)] }\n    for(u : adjacent)\n        blocked[(u,v)] = true\n\n    unpaired = {}\n    for(u : adjacent)\n        int w = partition(u)\n        if(w = 0)\n            add(unpaired, u)\n        else\n            print(v,u,w)\n\n    while(size(unpaired) >= 2)\n        int u = pop(unpaired)\n        int w = pop(unpaired)\n        print(u,v,w)\n\n    if(not empty(unpaired))\n        return pop(unpaired)\n    else\n        return 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 7",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, **u**)\n        **else**\n**            print(v,u,w)**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 8",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, **u**)\n        **else**\n**            print(v,u,w)**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 9",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 10",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 11",
          "code": "if(w = 0)\n    add(unpaired, u)\nelse\n    print(v,u,w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 12",
          "code": "if(w = 0)\n    add(unpaired, u)\nelse\n    print(v,u,w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        inf.readInts(n, 0, 1);\n        inf.readEoln();\n    }\n\n    int q = inf.readInt(1, 1000000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int queryType = inf.readInt(1, 3, \"queryType\");\n        if (queryType == 1 || queryType == 2) {\n            inf.readSpace();\n            int idx = inf.readInt(1, n, \"index\");\n            inf.readEoln();\n        } else if (queryType == 3) {\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        inf.readInts(n, 0, 1);\n        inf.readEoln();\n    }\n\n    int q = inf.readInt(1, 1000000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int queryType = inf.readInt(1, 3, \"queryType\");\n        if (queryType == 1 || queryType == 2) {\n            inf.readSpace();\n            int idx = inf.readInt(1, n, \"index\");\n            inf.readEoln();\n        } else if (queryType == 3) {\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        inf.readInts(n, 0, 1);\n        inf.readEoln();\n    }\n\n    int q = inf.readInt(1, 1000000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int queryType = inf.readInt(1, 3, \"queryType\");\n        if (queryType == 1 || queryType == 2) {\n            inf.readSpace();\n            int idx = inf.readInt(1, n, \"index\");\n            inf.readEoln();\n        } else if (queryType == 3) {\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string matType = opt<string>(\"matType\", \"random\");\n    string queryType = opt<string>(\"queryType\", \"random\");\n    \n    // Ensure n and q are within constraints\n    assert(1 <= n && n <= 1000);\n    assert(1 <= q && q <= 1000000);\n    \n    // Generate initial matrix according to matType\n    vector<vector<int>> A(n, vector<int>(n));\n    \n    if (matType == \"zeros\") {\n        for (int i = 0; i < n; ++i)\n            fill(A[i].begin(), A[i].end(), 0);\n    } else if (matType == \"ones\") {\n        for (int i = 0; i < n; ++i)\n            fill(A[i].begin(), A[i].end(), 1);\n    } else if (matType == \"alternating\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                A[i][j] = (i + j) % 2;\n    } else if (matType == \"random\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                A[i][j] = rnd.next(0, 1);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                A[i][j] = rnd.next(0, 1);\n    }\n    \n    // Output the initial matrix\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", A[i][j]);\n            if (j + 1 < n) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    \n    // Generate queries according to queryType\n    vector<string> queries;\n    if (queryType == \"only1\") {\n        // Flip rows only\n        for (int i = 0; i < q; ++i) {\n            int row = rnd.next(1, n);\n            queries.push_back(\"1 \" + to_string(row));\n        }\n    } else if (queryType == \"only2\") {\n        // Flip columns only\n        for (int i = 0; i < q; ++i) {\n            int col = rnd.next(1, n);\n            queries.push_back(\"2 \" + to_string(col));\n        }\n    } else if (queryType == \"only3\") {\n        // Only query unusual square\n        for (int i = 0; i < q; ++i) {\n            queries.push_back(\"3\");\n        }\n    } else if (queryType == \"flipRows\") {\n        // Flip the same row multiple times\n        int row = rnd.next(1, n);\n        for (int i = 0; i < q; ++i) {\n            queries.push_back(\"1 \" + to_string(row));\n        }\n    } else if (queryType == \"flipColumns\") {\n        // Flip the same column multiple times\n        int col = rnd.next(1, n);\n        for (int i = 0; i < q; ++i) {\n            queries.push_back(\"2 \" + to_string(col));\n        }\n    } else if (queryType == \"alternate\") {\n        // Alternate between flipping a row and a column\n        for (int i = 0; i < q; ++i) {\n            if (i % 2 == 0) {\n                int row = rnd.next(1, n);\n                queries.push_back(\"1 \" + to_string(row));\n            } else {\n                int col = rnd.next(1, n);\n                queries.push_back(\"2 \" + to_string(col));\n            }\n        }\n    } else if (queryType == \"no3\") {\n        // Only flips, no '3' queries\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 2);\n            int idx = rnd.next(1, n);\n            queries.push_back(to_string(type) + \" \" + to_string(idx));\n        }\n    } else if (queryType == \"all3\") {\n        // Only '3' queries\n        for (int i = 0; i < q; ++i) {\n            queries.push_back(\"3\");\n        }\n    } else if (queryType == \"random\") {\n        // Random queries\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 3);\n            if (type == 3) {\n                queries.push_back(\"3\");\n            } else {\n                int idx = rnd.next(1, n);\n                queries.push_back(to_string(type) + \" \" + to_string(idx));\n            }\n        }\n    } else if (queryType == \"edge\") {\n        // Edge cases, e.g., flip the first row, then the first column, then query\n        for (int i = 0; i < q; ++i) {\n            if (i % 3 == 0) {\n                queries.push_back(\"1 1\");\n            } else if (i % 3 == 1) {\n                queries.push_back(\"2 1\");\n            } else {\n                queries.push_back(\"3\");\n            }\n        }\n    } else {\n        // default to random queries\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 3);\n            if (type == 3) {\n                queries.push_back(\"3\");\n            } else {\n                int idx = rnd.next(1, n);\n                queries.push_back(to_string(type) + \" \" + to_string(idx));\n            }\n        }\n    }\n    \n    // Output the queries\n    printf(\"%d\\n\", q);\n    for (const string& query : queries) {\n        printf(\"%s\\n\", query.c_str());\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string matType = opt<string>(\"matType\", \"random\");\n    string queryType = opt<string>(\"queryType\", \"random\");\n    \n    // Ensure n and q are within constraints\n    assert(1 <= n && n <= 1000);\n    assert(1 <= q && q <= 1000000);\n    \n    // Generate initial matrix according to matType\n    vector<vector<int>> A(n, vector<int>(n));\n    \n    if (matType == \"zeros\") {\n        for (int i = 0; i < n; ++i)\n            fill(A[i].begin(), A[i].end(), 0);\n    } else if (matType == \"ones\") {\n        for (int i = 0; i < n; ++i)\n            fill(A[i].begin(), A[i].end(), 1);\n    } else if (matType == \"alternating\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                A[i][j] = (i + j) % 2;\n    } else if (matType == \"random\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                A[i][j] = rnd.next(0, 1);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                A[i][j] = rnd.next(0, 1);\n    }\n    \n    // Output the initial matrix\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            printf(\"%d\", A[i][j]);\n            if (j + 1 < n) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    \n    // Generate queries according to queryType\n    vector<string> queries;\n    if (queryType == \"only1\") {\n        // Flip rows only\n        for (int i = 0; i < q; ++i) {\n            int row = rnd.next(1, n);\n            queries.push_back(\"1 \" + to_string(row));\n        }\n    } else if (queryType == \"only2\") {\n        // Flip columns only\n        for (int i = 0; i < q; ++i) {\n            int col = rnd.next(1, n);\n            queries.push_back(\"2 \" + to_string(col));\n        }\n    } else if (queryType == \"only3\") {\n        // Only query unusual square\n        for (int i = 0; i < q; ++i) {\n            queries.push_back(\"3\");\n        }\n    } else if (queryType == \"flipRows\") {\n        // Flip the same row multiple times\n        int row = rnd.next(1, n);\n        for (int i = 0; i < q; ++i) {\n            queries.push_back(\"1 \" + to_string(row));\n        }\n    } else if (queryType == \"flipColumns\") {\n        // Flip the same column multiple times\n        int col = rnd.next(1, n);\n        for (int i = 0; i < q; ++i) {\n            queries.push_back(\"2 \" + to_string(col));\n        }\n    } else if (queryType == \"alternate\") {\n        // Alternate between flipping a row and a column\n        for (int i = 0; i < q; ++i) {\n            if (i % 2 == 0) {\n                int row = rnd.next(1, n);\n                queries.push_back(\"1 \" + to_string(row));\n            } else {\n                int col = rnd.next(1, n);\n                queries.push_back(\"2 \" + to_string(col));\n            }\n        }\n    } else if (queryType == \"no3\") {\n        // Only flips, no '3' queries\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 2);\n            int idx = rnd.next(1, n);\n            queries.push_back(to_string(type) + \" \" + to_string(idx));\n        }\n    } else if (queryType == \"all3\") {\n        // Only '3' queries\n        for (int i = 0; i < q; ++i) {\n            queries.push_back(\"3\");\n        }\n    } else if (queryType == \"random\") {\n        // Random queries\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 3);\n            if (type == 3) {\n                queries.push_back(\"3\");\n            } else {\n                int idx = rnd.next(1, n);\n                queries.push_back(to_string(type) + \" \" + to_string(idx));\n            }\n        }\n    } else if (queryType == \"edge\") {\n        // Edge cases, e.g., flip the first row, then the first column, then query\n        for (int i = 0; i < q; ++i) {\n            if (i % 3 == 0) {\n                queries.push_back(\"1 1\");\n            } else if (i % 3 == 1) {\n                queries.push_back(\"2 1\");\n            } else {\n                queries.push_back(\"3\");\n            }\n        }\n    } else {\n        // default to random queries\n        for (int i = 0; i < q; ++i) {\n            int type = rnd.next(1, 3);\n            if (type == 3) {\n                queries.push_back(\"3\");\n            } else {\n                int idx = rnd.next(1, n);\n                queries.push_back(to_string(type) + \" \" + to_string(idx));\n            }\n        }\n    }\n    \n    // Output the queries\n    printf(\"%d\\n\", q);\n    for (const string& query : queries) {\n        printf(\"%s\\n\", query.c_str());\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -matType zeros -queryType only3\n./gen -n 2 -q 2 -matType ones -queryType only1\n./gen -n 3 -q 3 -matType alternating -queryType only2\n\n./gen -n 1 -q 1000000 -matType zeros -queryType flipRows\n./gen -n 1 -q 1000000 -matType ones -queryType flipColumns\n\n./gen -n 2 -q 1000000 -matType ones -queryType alternate\n./gen -n 2 -q 5 -matType ones -queryType only1\n./gen -n 2 -q 5 -matType zeros -queryType only2\n./gen -n 2 -q 5 -matType alternating -queryType only3\n\n./gen -n 50 -q 100 -matType random -queryType random\n\n./gen -n 500 -q 500000 -matType alternating -queryType flipRows\n./gen -n 500 -q 500000 -matType alternating -queryType flipColumns\n./gen -n 500 -q 500000 -matType alternating -queryType alternate\n\n./gen -n 1000 -q 1 -matType ones -queryType only3\n./gen -n 1000 -q 1 -matType zeros -queryType only3\n\n./gen -n 1000 -q 10 -matType random -queryType random\n./gen -n 1000 -q 10 -matType random -queryType only3\n\n./gen -n 1000 -q 100000 -matType ones -queryType flipRows\n./gen -n 1000 -q 100000 -matType ones -queryType flipColumns\n./gen -n 1000 -q 1000000 -matType random -queryType only1\n./gen -n 1000 -q 1000000 -matType random -queryType only2\n./gen -n 1000 -q 1000000 -matType random -queryType only3\n\n./gen -n 1000 -q 1000000 -matType random -queryType random\n./gen -n 1000 -q 1000000 -matType random -queryType all3\n./gen -n 1000 -q 1000000 -matType ones -queryType no3\n\n./gen -n 1000 -q 1000000 -matType ones -queryType edge\n./gen -n 1000 -q 1000000 -matType zeros -queryType edge\n\n./gen -n 1000 -q 1000000 -matType random -queryType alternate\n./gen -n 1000 -q 1000000 -matType alternating -queryType alternate\n\n./gen -n 1000 -q 1000000 -matType ones -queryType flipRows\n./gen -n 1000 -q 1000000 -matType zeros -queryType flipColumns\n\n./gen -n 1000 -q 1000000 -matType ones -queryType all3\n./gen -n 1000 -q 1000000 -matType zeros -queryType random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:21.384702",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "406/B",
      "title": "B. Toy Sum",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains a single integer n (1 ≤ n ≤ 5·105), the number of blocks in the set X. The next line contains n distinct space-separated integers x1, x2, ..., xn (1 ≤ xi ≤ 106), the numbers of the blocks in X.Note: since the size of the input and output could be very large, don't use slow output techniques in your language. For example, do not use input and output streams (cin, cout) in C++.",
      "output_spec": "OutputIn the first line of output print a single integer m (1 ≤ m ≤ 106 - n), the number of blocks in the set Y. In the next line output m distinct space-separated integers y1, y2, ..., ym (1 ≤ yi ≤ 106), such that the required equality holds. The sets X and Y should not intersect, i.e. xi ≠ yj for all i, j (1 ≤ i ≤ n; 1 ≤ j ≤ m). It is guaranteed that at least one solution always exists. If there are multiple solutions, output any of them.",
      "sample_tests": "ExamplesInputCopy31 4 5OutputCopy2999993 1000000InputCopy11OutputCopy11000000",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains a single integer n (1 ≤ n ≤ 5·105), the number of blocks in the set X. The next line contains n distinct space-separated integers x1, x2, ..., xn (1 ≤ xi ≤ 106), the numbers of the blocks in X.Note: since the size of the input and output could be very large, don't use slow output techniques in your language. For example, do not use input and output streams (cin, cout) in C++.\n\nOutputIn the first line of output print a single integer m (1 ≤ m ≤ 106 - n), the number of blocks in the set Y. In the next line output m distinct space-separated integers y1, y2, ..., ym (1 ≤ yi ≤ 106), such that the required equality holds. The sets X and Y should not intersect, i.e. xi ≠ yj for all i, j (1 ≤ i ≤ n; 1 ≤ j ≤ m). It is guaranteed that at least one solution always exists. If there are multiple solutions, output any of them.\n\nInputCopy31 4 5OutputCopy2999993 1000000InputCopy11OutputCopy11000000\n\nInputCopy31 4 5\n\nOutputCopy2999993 1000000\n\nInputCopy11\n\nOutputCopy11000000",
      "solutions": [
        {
          "title": "Codeforces Round #238 - Codeforces",
          "content": "Hello everyone!Codeforces round #238 will start today at 19:30 in Moscow time. The round will be held in both divisions.The round was prepared by me and cfk. This is the 4th round for me and the 2nd for Krisjanis. I think the problems this time are rather unusual and maybe even surprising. We have no doubt that everyone will find a problem that suits their taste! But you have to find it. (:As always, thanks to Mikhail Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems, and Maria Belova (Delinur) for translating the statements. Big thanks to Gerald Agapov (Gerald) for helping in preparation of the contest. Me and Gerald had a chance to talk about the problems onsite during the Petrozavodsk winter camp, which I think was very productive. We wish you a very exciting round!UPD1: Score distribution:DivI: 500 1000 2000 2000 2500DivII: 500 1000 1500 2000 3000The scoring for the problems is relative, so that the cost of each problem would be a multiple of 500 and closer to the objective estimate. Don't be afraid, the problems are not really that hard. (:UPD2: Congratulations to the winners!DivI: al13n Shef scott_wu sillycross Komaki DivII: NelsonMondialu L_Ecry aaaaAaaaaAaaaaAaaaaA xorfire Hec UPD3: Excellent round statistics from DmitriyH.UPD4: The contest tutorial is published here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11153",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1309
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces",
          "content": "405A - Gravity FlipObserve that in the final configuration the heights of the columns are in non-decreasing order. Also, the number of columns of each height remains the same. This means that the answer to the problem is the sorted sequence of the given column heights.Solution complexity: O(n), since we can sort by counting.405B - Domino EffectIf the first pushed domino from the left was pushed to the left at position l, all dominoes at prefix [1;l] fall down, otherwise let l be 0. Similarly, if the first pushed domino from the right was pushed to the right at position r, all dominoes at suffix [r;n] also fall down, otherwise let r be n + 1. Now, in the segment (l;r) there will remain vertical dominoes and blocks of dominoes supported by the equal forces from both sides.When does a domino at position p in segment (l, r) remains standing vertically? One way is that it is not pushed by any other domino. This could be easily checked by looking at the pushed dominoes closest to p (from both sides). It is pushed by dominoes, only if the closest from the left was pushed to the right, and the closest from the right was pushed to the left. Suppose these dominoes are at positions x and y, x < p < y. Then, the only way that the domino is still standing is if it is positioned at the center of the block [x;y], which could be checked by .Solution complexity: O(n) / O(n2), depends on implementation.406A - Unusual ProductWritten as a formula, the problem asks to find the value of Suppose that i ≠ j. Then the sum contains summands AijAji and AjiAij. Since the sum is taken modulo 2, these summands together give 0 to the sum. It follows that the expression is always equal to the sum of the diagonal bits: Now, each query of type 1 and 2 flips the value of exactly one bit on the diagonal. Thus we can calculate the unusual product of the original matrix, and flip its value after each query of type 1 and 2.Solution complexity: O(n + q), if we don't take the reading of the input into account... :)406B - Toy SumLet's define the symmetric number of k to be s + 1 - k. Since in this case s is an even number, k ≠ s - k.Note that (k - 1) + (s + 1 - k) = s, i.e., the sum of a number and its symmetric is always s. Let's process the given members x of X. There can be two cases: If the symmetric of x does not belong to X, we add it to Y. Both give equal values to the respective sums: x - 1 = s - (s + 1 - x). The symmetric of x belongs to X. Then we pick any y that neither y and symmetric of y belong to X, and add them to Y. Both pairs give equal values to the respective sums, namely s. How to prove that in the second step we can always find such y? Let the number of symmetric pairs that were processed in the step 1 be a, then there remain other pairs. Among them, for pairs both members belong to X, and for other pairs none of the members belong to X. To be able to pick the same number of pairs for Y, as there are in X, we should have which is equivalent to , as given in the statement.Solution complexity: O(s) / O(n).406C - Graph CuttingIt can be proved that only graphs with an odd number of edges cannot be partitioned into path of length 2. We will construct a recursive function that solves the problem and also serves as a proof for this statement.The function partition(v) will operate on non-blocked edges. It will partition the component of vertex v connected by the non-blocked edges into paths of length 2. If this component has an odd number of edges, the function will partition all the edges of the component, except one edge (u, v); the function then will return vertex u, expecting that the parent function call will assign it to some path.The function works as follows: find all vertices that are adjacent to v by the non-blocked edges, call this set adjacent. Then block all the edges from this set vertices to v. For each u in adjacent, call partition(u). Suppose partition(u) returned a vertex w. That means we can pair it into the path (v, u, w). Otherwise, if partition(u) does not return anything, we add u to unpaired, since the edge (v, u) is not yet in any path. We can pair any two vertices of this set u, w into a single path (u, v, w). We pair as much of them as possible in any order. If from this set a single vertex, u, is left unpaired, the function will return u. Otherwise the function will not return anything.The function could be implemented as a single DFS: partition(v) :\n adjacent = { u | not blocked[(u,v)] }\n for(u : adjacent)\n blocked[(u,v)] = true\n\n unpaired = {}\n for(u : adjacent)\n int w = partition(u)\n if(w = 0)\n add(unpaired, u)\n else\n print(v,u,w)\n\n while(size(unpaired) >= 2)\n int u = pop(unpaired)\n int w = pop(unpaired)\n print(u,v,w)\n\n if(not empty(unpaired))\n return pop(unpaired)\n else\n return 0Solution complexity: O(n + m).406D - Hill ClimbingNote that the path of each hill climber is strictly convex in any case. Let's draw the paths from all hills to the rightmost hill. Then these paths form a tree with the \"root\" at the top of the rightmost hill. We can apply the Graham scan from the right to the left to find the edges of this tree. Each pop and insert in the stack corresponds to a single edge in the tree.Now it is easy to see that for each team of climbers, we should calculate the number of the lowest common ancestor for the corresponding two vertices in the tree. The size if the tree is n, so each query works in .Solution complexity: .406E - Hamming TriplesLet's look at the Hamming graph of all possible distinct 2n strings, where each two strings are connected by an edge with length equal to the Hamming distance between these strings. We can observe that this graph has a nice property: if we arrange the vertices cyclically as a regular 2n-gon with a side length of 1, then the Hamming distance between two strings is the length of the shortest route between these vertices on the perimeter of the polygon.For example, the figure shows the graph for n = 3. The gray edges have length 1, the orange edges have length 2 and the blue edges have length 3. That is the corresponding Hamming distance.Now, we can convert each string coded by a pair (s, f) to an integer (f + 1)·n - s. The new numbers will be 0, 1, ..., 2n - 1 and correspond to the same cyclical order on the perimeter of the polygon. The given strings are mapped to some subset of the vertices. Now we have to find the number of triangles (possibly degenerate) with maximal perimeter in this subgraph. It will be useful to keep the new converted numbers sorted.First, we can figure out what this perimeter could be. If there exists a diameter in the full graph, so that all of the points are on one side of the diameter, the perimeter is 2d, where d is the length of the longest edge:Then any triangle with two vertices at the longest edge points and the third one being any point has the maximal perimeter. Since the numbers are sorted, the longest edge in this case will be produced by two cyclically adjacent elements, which is not hard to find.If for any diameter this does not hold, then the maximal perimeter is 2n. This can be proved by taking two different points a, b and drawing two diameters with them as endpoints; since it is not the previous case, there shoud be a third point c in area where the perimeter of triangle a, b, c is 2n.The tricky part is to count the triples in this case. We do this by working with the diameter (0, n). There can be several cases: A maximum triangle has vertices 0 and n. This a simple case: with any other vertex as the third the triangle has perimeter 2n. A maximum triangle has vertex 0, but not n. Then the second vertex should be in interval [0, n), and the third in interval (n + 1, 2n - 1], and the clockwise distance between the second and the third should not exceed n (since then the perimeter of the triangle would be less than 2n). We count the number of such triples iterating two pointers (one in each of these intervals). For each pointer in the first interval, all points from n + 1 till the second pointer will make a maximal perimeter triangle. We similarly solve the case where the maximal triangle has vertex n, but not 0. The maximal triangle does not have 0 or n as its vertices. Then one vertex of the triangle should be on one side of diameter (0, n), and two should be on the opposite side. To count them, we iterate a vertex pointer on the first side, say, (0, n); let the diametrally opposite vertex on the opposite side be x. Then the second vertex can be any in [n + 1, s], and the third can be any of the [s, 2n - 1]. It is easy to calculate these numbers using partial sums on the circle. Note that s can be both the second and the third vertex (since strings can repeat). So we iterate this pointer over all one side vertices and update the answer. Similarly we solve the case where a single vertex is on the other side, and two on this side. One only needs to be careful with the formulas in each case.Solution complexity: , because of the sorting.Post ScriptumWhat were your solutions? Feel free to share any solutions or thoughts! For example, was there a solution to DivI E simpler than in this tutorial?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11186",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 406\\s*B"
          },
          "content_length": 9148
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #238 - Codeforces - Code 1",
          "code": "|   \n       |\n       |\n       |\n  |    |\n| |  | | \n1 2  3 4\n(In reversed order, from right to left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 2",
          "code": "|   \n       |\n       |\n       |\n  |    |\n| |  | | \n1 2  3 4\n(In reversed order, from right to left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 3",
          "code": "Push 1\nmake_edge(1,2) (i will not write these from now on)\nPush 2\ntry to pop the stack -> verify whether or not line segment 1 3 passes through hill 2 -> no -> no pop\nPush 3\ntry to pop the stack -> 2 4 is above 3, so we pop the stack\ntry to pop the stack -> 4 1 is above 2, so we pop the stack\n(make edge 1,4)\nPush 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 4",
          "code": "Push 1\nmake_edge(1,2) (i will not write these from now on)\nPush 2\ntry to pop the stack -> verify whether or not line segment 1 3 passes through hill 2 -> no -> no pop\nPush 3\ntry to pop the stack -> 2 4 is above 3, so we pop the stack\ntry to pop the stack -> 4 1 is above 2, so we pop the stack\n(make edge 1,4)\nPush 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 5",
          "code": "if(((1ll*stack[poz].x-stack[poz-1].x)*(1ll*v[i].h-stack[poz-1].h))<((1ll*stack[poz].h &mdash; 1ll*stack[poz-1].h)*(1ll*v[i].x-1ll*stack[poz-1].x)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 6",
          "code": "if(((1ll*stack[poz].x-stack[poz-1].x)*(1ll*v[i].h-stack[poz-1].h))<((1ll*stack[poz].h &mdash; 1ll*stack[poz-1].h)*(1ll*v[i].x-1ll*stack[poz-1].x)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 7",
          "code": "cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 8",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 9",
          "code": "ios :: sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 10",
          "code": "cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 11",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 12",
          "code": "string s; s.reserve(100005);\n\nfor (int i = 0; i < n; i++)\n{\n    cin >> s;\n\n    // do something\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 13",
          "code": "string s; s.reserve(100005);\n\nfor (int i = 0; i < n; i++)\n{\n    cin >> s;\n\n    // do something\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 14",
          "code": "#define dibs reserve",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 15",
          "code": "(X +- (2*Y))%2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 16",
          "code": "FastScanner",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 17",
          "code": "java.io.BufferedReader",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 1",
          "code": "partition(v)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 2",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 3",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 4",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 5",
          "code": "partition(v) :\n    adjacent = { u | not blocked[(u,v)] }\n    for(u : adjacent)\n        blocked[(u,v)] = true\n\n    unpaired = {}\n    for(u : adjacent)\n        int w = partition(u)\n        if(w = 0)\n            add(unpaired, u)\n        else\n            print(v,u,w)\n\n    while(size(unpaired) >= 2)\n        int u = pop(unpaired)\n        int w = pop(unpaired)\n        print(u,v,w)\n\n    if(not empty(unpaired))\n        return pop(unpaired)\n    else\n        return 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 6",
          "code": "partition(v) :\n    adjacent = { u | not blocked[(u,v)] }\n    for(u : adjacent)\n        blocked[(u,v)] = true\n\n    unpaired = {}\n    for(u : adjacent)\n        int w = partition(u)\n        if(w = 0)\n            add(unpaired, u)\n        else\n            print(v,u,w)\n\n    while(size(unpaired) >= 2)\n        int u = pop(unpaired)\n        int w = pop(unpaired)\n        print(u,v,w)\n\n    if(not empty(unpaired))\n        return pop(unpaired)\n    else\n        return 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 7",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, **u**)\n        **else**\n**            print(v,u,w)**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 8",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, **u**)\n        **else**\n**            print(v,u,w)**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 9",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 10",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 11",
          "code": "if(w = 0)\n    add(unpaired, u)\nelse\n    print(v,u,w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 12",
          "code": "if(w = 0)\n    add(unpaired, u)\nelse\n    print(v,u,w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    vector<int> x = inf.readInts(n, 1, 1000000, \"x_i\");\n    inf.readEoln();\n\n    // Verify that x_i are distinct\n    set<int> x_set(x.begin(), x.end());\n    ensuref(x_set.size() == x.size(), \"x_i are not distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    vector<int> x = inf.readInts(n, 1, 1000000, \"x_i\");\n    inf.readEoln();\n\n    // Verify that x_i are distinct\n    set<int> x_set(x.begin(), x.end());\n    ensuref(x_set.size() == x.size(), \"x_i are not distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readEoln();\n    vector<int> x = inf.readInts(n, 1, 1000000, \"x_i\");\n    inf.readEoln();\n\n    // Verify that x_i are distinct\n    set<int> x_set(x.begin(), x.end());\n    ensuref(x_set.size() == x.size(), \"x_i are not distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    using int64 = long long;\n    const int s = 1'000'000; // Total number of blocks\n\n    // Read n and X from the input file\n    int n = inf.readInt(1, 500'000, \"n\");\n    unordered_set<int> X;\n    int64 sum_xi = 0;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(1, s, format(\"x[%d]\", i + 1).c_str());\n        if (X.count(xi))\n            quitf(_fail, \"Duplicate block number %d in X\", xi);\n        X.insert(xi);\n        sum_xi += xi - 1;\n    }\n\n    // Read m and Y from the contestant's output\n    int m = ouf.readInt(1, s - n, \"m\");\n    unordered_set<int> Y;\n    int64 sum_yi = 0;\n    for (int i = 0; i < m; ++i) {\n        int yi = ouf.readInt(1, s, format(\"y[%d]\", i + 1).c_str());\n        if (X.count(yi))\n            quitf(_wa, \"Block number %d is in both X and Y\", yi);\n        if (Y.count(yi))\n            quitf(_wa, \"Block number %d appears multiple times in Y\", yi);\n        Y.insert(yi);\n        sum_yi += s - yi;\n    }\n\n    // Verify that the sums are equal\n    if (sum_xi != sum_yi)\n        quitf(_wa, \"The sums are not equal: sum_xi = %lld, sum_yi = %lld\", sum_xi, sum_yi);\n\n    // If all checks pass, the answer is correct\n    quitf(_ok, \"Correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int s = 1000000;\n    set<int> x;\n\n    if (type == \"small_x\") {\n        // x_i from 1 to n\n        for (int i = 1; x.size() < n && i <= s; ++i) {\n            x.insert(i);\n        }\n    } else if (type == \"large_x\") {\n        // x_i from s - n + 1 to s\n        for (int i = s; x.size() < n && i >= 1; --i) {\n            x.insert(i);\n        }\n    } else if (type == \"consecutive\") {\n        // Generate x_i consecutive starting from random point\n        if (n > s) n = s;\n        int start = rnd.next(1, s - n + 1);\n        for (int i = 0; i < n; ++i) {\n            x.insert(start + i);\n        }\n    } else if (type == \"arithmetic\") {\n        // Generate x_i in arithmetic progression with random common difference\n        int max_d = max(1, (s - n) / n);\n        int d = rnd.next(1, max_d);\n        int start = rnd.next(1, s - (n - 1) * d);\n        for (int i = 0; i < n; ++i) {\n            x.insert(start + i * d);\n        }\n    } else if (type == \"all_same_remainder\") {\n        // Generate x_i with same modulo k\n        int k = rnd.next(2, min(1000, s/2));\n        int rem = rnd.next(0, k - 1);\n        vector<int> candidates;\n        for (int i = rem + 1; i <= s && candidates.size() < n; i += k) {\n            candidates.push_back(i);\n        }\n        if (candidates.size() < n) {\n            // Can't generate enough numbers, fall back to random\n            while (x.size() < n) {\n                x.insert(rnd.next(1, s));\n            }\n        } else {\n            shuffle(candidates.begin(), candidates.end());\n            for (int i = 0; i < n; ++i) {\n                x.insert(candidates[i]);\n            }\n        }\n    } else if (type == \"max_sum\") {\n        // x_i from s, s-1, s-2,...\n        for (int i = 0; i < n; ++i) {\n            x.insert(s - i);\n        }\n    } else if (type == \"min_sum\") {\n        // x_i from 1,2,3,...\n        for (int i = 0; i < n; ++i) {\n            x.insert(i + 1);\n        }\n    } else if (type == \"random\") {\n        // Random x_i throughout [1, s]\n        while (x.size() < n) {\n            x.insert(rnd.next(1, s));\n        }\n    } else {\n        // Default to random\n        while (x.size() < n) {\n            x.insert(rnd.next(1, s));\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output x_i\n    vector<int> xi(x.begin(), x.end());\n    shuffle(xi.begin(), xi.end());\n    for (size_t i = 0; i < xi.size(); ++i) {\n        printf(\"%d%c\", xi[i], \" \\n\"[i+1 == xi.size()]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int s = 1000000;\n    set<int> x;\n\n    if (type == \"small_x\") {\n        // x_i from 1 to n\n        for (int i = 1; x.size() < n && i <= s; ++i) {\n            x.insert(i);\n        }\n    } else if (type == \"large_x\") {\n        // x_i from s - n + 1 to s\n        for (int i = s; x.size() < n && i >= 1; --i) {\n            x.insert(i);\n        }\n    } else if (type == \"consecutive\") {\n        // Generate x_i consecutive starting from random point\n        if (n > s) n = s;\n        int start = rnd.next(1, s - n + 1);\n        for (int i = 0; i < n; ++i) {\n            x.insert(start + i);\n        }\n    } else if (type == \"arithmetic\") {\n        // Generate x_i in arithmetic progression with random common difference\n        int max_d = max(1, (s - n) / n);\n        int d = rnd.next(1, max_d);\n        int start = rnd.next(1, s - (n - 1) * d);\n        for (int i = 0; i < n; ++i) {\n            x.insert(start + i * d);\n        }\n    } else if (type == \"all_same_remainder\") {\n        // Generate x_i with same modulo k\n        int k = rnd.next(2, min(1000, s/2));\n        int rem = rnd.next(0, k - 1);\n        vector<int> candidates;\n        for (int i = rem + 1; i <= s && candidates.size() < n; i += k) {\n            candidates.push_back(i);\n        }\n        if (candidates.size() < n) {\n            // Can't generate enough numbers, fall back to random\n            while (x.size() < n) {\n                x.insert(rnd.next(1, s));\n            }\n        } else {\n            shuffle(candidates.begin(), candidates.end());\n            for (int i = 0; i < n; ++i) {\n                x.insert(candidates[i]);\n            }\n        }\n    } else if (type == \"max_sum\") {\n        // x_i from s, s-1, s-2,...\n        for (int i = 0; i < n; ++i) {\n            x.insert(s - i);\n        }\n    } else if (type == \"min_sum\") {\n        // x_i from 1,2,3,...\n        for (int i = 0; i < n; ++i) {\n            x.insert(i + 1);\n        }\n    } else if (type == \"random\") {\n        // Random x_i throughout [1, s]\n        while (x.size() < n) {\n            x.insert(rnd.next(1, s));\n        }\n    } else {\n        // Default to random\n        while (x.size() < n) {\n            x.insert(rnd.next(1, s));\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output x_i\n    vector<int> xi(x.begin(), x.end());\n    shuffle(xi.begin(), xi.end());\n    for (size_t i = 0; i < xi.size(); ++i) {\n        printf(\"%d%c\", xi[i], \" \\n\"[i+1 == xi.size()]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min_sum\n./gen -n 1 -type max_sum\n./gen -n 1 -type small_x\n./gen -n 1 -type large_x\n./gen -n 1 -type random\n\n./gen -n 2 -type small_x\n./gen -n 2 -type large_x\n./gen -n 2 -type consecutive\n./gen -n 2 -type arithmetic\n./gen -n 2 -type random\n\n./gen -n 1000 -type min_sum\n./gen -n 1000 -type max_sum\n./gen -n 1000 -type small_x\n./gen -n 1000 -type large_x\n./gen -n 1000 -type consecutive\n./gen -n 1000 -type arithmetic\n./gen -n 1000 -type all_same_remainder\n./gen -n 1000 -type random\n\n./gen -n 500000 -type min_sum\n./gen -n 500000 -type max_sum\n./gen -n 500000 -type small_x\n./gen -n 500000 -type large_x\n./gen -n 500000 -type consecutive\n./gen -n 500000 -type arithmetic\n./gen -n 500000 -type all_same_remainder\n./gen -n 500000 -type random\n\n./gen -n 499999 -type random\n./gen -n 123456 -type small_x\n./gen -n 400000 -type large_x\n./gen -n 300000 -type random\n\n./gen -n 5 -type max_sum\n./gen -n 5 -type min_sum\n\n./gen -n 50000 -type all_same_remainder\n./gen -n 200000 -type arithmetic\n\n./gen -n 5 -type random\n./gen -n 100000 -type random\n./gen -n 499999 -type random\n./gen -n 500000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:23.118536",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "406/C",
      "title": "C. Graph Cutting",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two space-separated integers n and m (1 ≤ n, m ≤ 105), the number of vertices and the number of edges in the graph. The next m lines contain the description of the graph's edges. The i-th line contains two space-separated integers ai and bi (1 ≤ ai, bi ≤ n; ai ≠ bi), the numbers of the vertices connected by the i-th edge. It is guaranteed that the given graph is simple (without self-loops and multi-edges) and connected.Note: since the size of the input and output could be very large, don't use slow output techniques in your language. For example, do not use input and output streams (cin, cout) in C++.",
      "output_spec": "OutputIf it is possible to cut the given graph into edge-distinct paths of length 2, output  lines. In the i-th line print three space-separated integers xi, yi and zi, the description of the i-th path. The graph should contain this path, i.e., the graph should contain edges (xi, yi) and (yi, zi). Each edge should appear in exactly one path of length 2. If there are multiple solutions, output any of them.If it is impossible to cut the given graph, print \"No solution\" (without quotes).",
      "sample_tests": "ExamplesInputCopy8 121 22 33 44 11 32 43 53 65 66 76 87 8OutputCopy1 2 41 3 21 4 35 3 65 6 86 7 8InputCopy3 31 22 33 1OutputCopyNo solutionInputCopy3 21 22 3OutputCopy1 2 3",
      "description": "C. Graph Cutting\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains two space-separated integers n and m (1 ≤ n, m ≤ 105), the number of vertices and the number of edges in the graph. The next m lines contain the description of the graph's edges. The i-th line contains two space-separated integers ai and bi (1 ≤ ai, bi ≤ n; ai ≠ bi), the numbers of the vertices connected by the i-th edge. It is guaranteed that the given graph is simple (without self-loops and multi-edges) and connected.Note: since the size of the input and output could be very large, don't use slow output techniques in your language. For example, do not use input and output streams (cin, cout) in C++.\n\nOutputIf it is possible to cut the given graph into edge-distinct paths of length 2, output  lines. In the i-th line print three space-separated integers xi, yi and zi, the description of the i-th path. The graph should contain this path, i.e., the graph should contain edges (xi, yi) and (yi, zi). Each edge should appear in exactly one path of length 2. If there are multiple solutions, output any of them.If it is impossible to cut the given graph, print \"No solution\" (without quotes).\n\nInputCopy8 121 22 33 44 11 32 43 53 65 66 76 87 8OutputCopy1 2 41 3 21 4 35 3 65 6 86 7 8InputCopy3 31 22 33 1OutputCopyNo solutionInputCopy3 21 22 3OutputCopy1 2 3\n\nInputCopy8 121 22 33 44 11 32 43 53 65 66 76 87 8\n\nOutputCopy1 2 41 3 21 4 35 3 65 6 86 7 8\n\nInputCopy3 31 22 33 1\n\nOutputCopyNo solution\n\nInputCopy3 21 22 3\n\nOutputCopy1 2 3",
      "solutions": [
        {
          "title": "Codeforces Round #238 - Codeforces",
          "content": "Hello everyone!Codeforces round #238 will start today at 19:30 in Moscow time. The round will be held in both divisions.The round was prepared by me and cfk. This is the 4th round for me and the 2nd for Krisjanis. I think the problems this time are rather unusual and maybe even surprising. We have no doubt that everyone will find a problem that suits their taste! But you have to find it. (:As always, thanks to Mikhail Mirzayanov (MikeMirzayanov) for Codeforces and Polygon systems, and Maria Belova (Delinur) for translating the statements. Big thanks to Gerald Agapov (Gerald) for helping in preparation of the contest. Me and Gerald had a chance to talk about the problems onsite during the Petrozavodsk winter camp, which I think was very productive. We wish you a very exciting round!UPD1: Score distribution:DivI: 500 1000 2000 2000 2500DivII: 500 1000 1500 2000 3000The scoring for the problems is relative, so that the cost of each problem would be a multiple of 500 and closer to the objective estimate. Don't be afraid, the problems are not really that hard. (:UPD2: Congratulations to the winners!DivI: al13n Shef scott_wu sillycross Komaki DivII: NelsonMondialu L_Ecry aaaaAaaaaAaaaaAaaaaA xorfire Hec UPD3: Excellent round statistics from DmitriyH.UPD4: The contest tutorial is published here.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/11153",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1309
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces",
          "content": "405A - Gravity FlipObserve that in the final configuration the heights of the columns are in non-decreasing order. Also, the number of columns of each height remains the same. This means that the answer to the problem is the sorted sequence of the given column heights.Solution complexity: O(n), since we can sort by counting.405B - Domino EffectIf the first pushed domino from the left was pushed to the left at position l, all dominoes at prefix [1;l] fall down, otherwise let l be 0. Similarly, if the first pushed domino from the right was pushed to the right at position r, all dominoes at suffix [r;n] also fall down, otherwise let r be n + 1. Now, in the segment (l;r) there will remain vertical dominoes and blocks of dominoes supported by the equal forces from both sides.When does a domino at position p in segment (l, r) remains standing vertically? One way is that it is not pushed by any other domino. This could be easily checked by looking at the pushed dominoes closest to p (from both sides). It is pushed by dominoes, only if the closest from the left was pushed to the right, and the closest from the right was pushed to the left. Suppose these dominoes are at positions x and y, x < p < y. Then, the only way that the domino is still standing is if it is positioned at the center of the block [x;y], which could be checked by .Solution complexity: O(n) / O(n2), depends on implementation.406A - Unusual ProductWritten as a formula, the problem asks to find the value of Suppose that i ≠ j. Then the sum contains summands AijAji and AjiAij. Since the sum is taken modulo 2, these summands together give 0 to the sum. It follows that the expression is always equal to the sum of the diagonal bits: Now, each query of type 1 and 2 flips the value of exactly one bit on the diagonal. Thus we can calculate the unusual product of the original matrix, and flip its value after each query of type 1 and 2.Solution complexity: O(n + q), if we don't take the reading of the input into account... :)406B - Toy SumLet's define the symmetric number of k to be s + 1 - k. Since in this case s is an even number, k ≠ s - k.Note that (k - 1) + (s + 1 - k) = s, i.e., the sum of a number and its symmetric is always s. Let's process the given members x of X. There can be two cases: If the symmetric of x does not belong to X, we add it to Y. Both give equal values to the respective sums: x - 1 = s - (s + 1 - x). The symmetric of x belongs to X. Then we pick any y that neither y and symmetric of y belong to X, and add them to Y. Both pairs give equal values to the respective sums, namely s. How to prove that in the second step we can always find such y? Let the number of symmetric pairs that were processed in the step 1 be a, then there remain other pairs. Among them, for pairs both members belong to X, and for other pairs none of the members belong to X. To be able to pick the same number of pairs for Y, as there are in X, we should have which is equivalent to , as given in the statement.Solution complexity: O(s) / O(n).406C - Graph CuttingIt can be proved that only graphs with an odd number of edges cannot be partitioned into path of length 2. We will construct a recursive function that solves the problem and also serves as a proof for this statement.The function partition(v) will operate on non-blocked edges. It will partition the component of vertex v connected by the non-blocked edges into paths of length 2. If this component has an odd number of edges, the function will partition all the edges of the component, except one edge (u, v); the function then will return vertex u, expecting that the parent function call will assign it to some path.The function works as follows: find all vertices that are adjacent to v by the non-blocked edges, call this set adjacent. Then block all the edges from this set vertices to v. For each u in adjacent, call partition(u). Suppose partition(u) returned a vertex w. That means we can pair it into the path (v, u, w). Otherwise, if partition(u) does not return anything, we add u to unpaired, since the edge (v, u) is not yet in any path. We can pair any two vertices of this set u, w into a single path (u, v, w). We pair as much of them as possible in any order. If from this set a single vertex, u, is left unpaired, the function will return u. Otherwise the function will not return anything.The function could be implemented as a single DFS: partition(v) :\n adjacent = { u | not blocked[(u,v)] }\n for(u : adjacent)\n blocked[(u,v)] = true\n\n unpaired = {}\n for(u : adjacent)\n int w = partition(u)\n if(w = 0)\n add(unpaired, u)\n else\n print(v,u,w)\n\n while(size(unpaired) >= 2)\n int u = pop(unpaired)\n int w = pop(unpaired)\n print(u,v,w)\n\n if(not empty(unpaired))\n return pop(unpaired)\n else\n return 0Solution complexity: O(n + m).406D - Hill ClimbingNote that the path of each hill climber is strictly convex in any case. Let's draw the paths from all hills to the rightmost hill. Then these paths form a tree with the \"root\" at the top of the rightmost hill. We can apply the Graham scan from the right to the left to find the edges of this tree. Each pop and insert in the stack corresponds to a single edge in the tree.Now it is easy to see that for each team of climbers, we should calculate the number of the lowest common ancestor for the corresponding two vertices in the tree. The size if the tree is n, so each query works in .Solution complexity: .406E - Hamming TriplesLet's look at the Hamming graph of all possible distinct 2n strings, where each two strings are connected by an edge with length equal to the Hamming distance between these strings. We can observe that this graph has a nice property: if we arrange the vertices cyclically as a regular 2n-gon with a side length of 1, then the Hamming distance between two strings is the length of the shortest route between these vertices on the perimeter of the polygon.For example, the figure shows the graph for n = 3. The gray edges have length 1, the orange edges have length 2 and the blue edges have length 3. That is the corresponding Hamming distance.Now, we can convert each string coded by a pair (s, f) to an integer (f + 1)·n - s. The new numbers will be 0, 1, ..., 2n - 1 and correspond to the same cyclical order on the perimeter of the polygon. The given strings are mapped to some subset of the vertices. Now we have to find the number of triangles (possibly degenerate) with maximal perimeter in this subgraph. It will be useful to keep the new converted numbers sorted.First, we can figure out what this perimeter could be. If there exists a diameter in the full graph, so that all of the points are on one side of the diameter, the perimeter is 2d, where d is the length of the longest edge:Then any triangle with two vertices at the longest edge points and the third one being any point has the maximal perimeter. Since the numbers are sorted, the longest edge in this case will be produced by two cyclically adjacent elements, which is not hard to find.If for any diameter this does not hold, then the maximal perimeter is 2n. This can be proved by taking two different points a, b and drawing two diameters with them as endpoints; since it is not the previous case, there shoud be a third point c in area where the perimeter of triangle a, b, c is 2n.The tricky part is to count the triples in this case. We do this by working with the diameter (0, n). There can be several cases: A maximum triangle has vertices 0 and n. This a simple case: with any other vertex as the third the triangle has perimeter 2n. A maximum triangle has vertex 0, but not n. Then the second vertex should be in interval [0, n), and the third in interval (n + 1, 2n - 1], and the clockwise distance between the second and the third should not exceed n (since then the perimeter of the triangle would be less than 2n). We count the number of such triples iterating two pointers (one in each of these intervals). For each pointer in the first interval, all points from n + 1 till the second pointer will make a maximal perimeter triangle. We similarly solve the case where the maximal triangle has vertex n, but not 0. The maximal triangle does not have 0 or n as its vertices. Then one vertex of the triangle should be on one side of diameter (0, n), and two should be on the opposite side. To count them, we iterate a vertex pointer on the first side, say, (0, n); let the diametrally opposite vertex on the opposite side be x. Then the second vertex can be any in [n + 1, s], and the third can be any of the [s, 2n - 1]. It is easy to calculate these numbers using partial sums on the circle. Note that s can be both the second and the third vertex (since strings can repeat). So we iterate this pointer over all one side vertices and update the answer. Similarly we solve the case where a single vertex is on the other side, and two on this side. One only needs to be careful with the formulas in each case.Solution complexity: , because of the sorting.Post ScriptumWhat were your solutions? Feel free to share any solutions or thoughts! For example, was there a solution to DivI E simpler than in this tutorial?",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/11186",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 406\\s*C"
          },
          "content_length": 9148
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #238 - Codeforces - Code 1",
          "code": "|   \n       |\n       |\n       |\n  |    |\n| |  | | \n1 2  3 4\n(In reversed order, from right to left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 2",
          "code": "|   \n       |\n       |\n       |\n  |    |\n| |  | | \n1 2  3 4\n(In reversed order, from right to left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 3",
          "code": "Push 1\nmake_edge(1,2) (i will not write these from now on)\nPush 2\ntry to pop the stack -> verify whether or not line segment 1 3 passes through hill 2 -> no -> no pop\nPush 3\ntry to pop the stack -> 2 4 is above 3, so we pop the stack\ntry to pop the stack -> 4 1 is above 2, so we pop the stack\n(make edge 1,4)\nPush 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 4",
          "code": "Push 1\nmake_edge(1,2) (i will not write these from now on)\nPush 2\ntry to pop the stack -> verify whether or not line segment 1 3 passes through hill 2 -> no -> no pop\nPush 3\ntry to pop the stack -> 2 4 is above 3, so we pop the stack\ntry to pop the stack -> 4 1 is above 2, so we pop the stack\n(make edge 1,4)\nPush 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 5",
          "code": "if(((1ll*stack[poz].x-stack[poz-1].x)*(1ll*v[i].h-stack[poz-1].h))<((1ll*stack[poz].h &mdash; 1ll*stack[poz-1].h)*(1ll*v[i].x-1ll*stack[poz-1].x)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 6",
          "code": "if(((1ll*stack[poz].x-stack[poz-1].x)*(1ll*v[i].h-stack[poz-1].h))<((1ll*stack[poz].h &mdash; 1ll*stack[poz-1].h)*(1ll*v[i].x-1ll*stack[poz-1].x)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 7",
          "code": "cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 8",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 9",
          "code": "ios :: sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 10",
          "code": "cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 11",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 12",
          "code": "string s; s.reserve(100005);\n\nfor (int i = 0; i < n; i++)\n{\n    cin >> s;\n\n    // do something\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 13",
          "code": "string s; s.reserve(100005);\n\nfor (int i = 0; i < n; i++)\n{\n    cin >> s;\n\n    // do something\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 14",
          "code": "#define dibs reserve",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 15",
          "code": "(X +- (2*Y))%2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 16",
          "code": "FastScanner",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 17",
          "code": "java.io.BufferedReader",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 1",
          "code": "partition(v)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 2",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 3",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 4",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 5",
          "code": "partition(v) :\n    adjacent = { u | not blocked[(u,v)] }\n    for(u : adjacent)\n        blocked[(u,v)] = true\n\n    unpaired = {}\n    for(u : adjacent)\n        int w = partition(u)\n        if(w = 0)\n            add(unpaired, u)\n        else\n            print(v,u,w)\n\n    while(size(unpaired) >= 2)\n        int u = pop(unpaired)\n        int w = pop(unpaired)\n        print(u,v,w)\n\n    if(not empty(unpaired))\n        return pop(unpaired)\n    else\n        return 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 6",
          "code": "partition(v) :\n    adjacent = { u | not blocked[(u,v)] }\n    for(u : adjacent)\n        blocked[(u,v)] = true\n\n    unpaired = {}\n    for(u : adjacent)\n        int w = partition(u)\n        if(w = 0)\n            add(unpaired, u)\n        else\n            print(v,u,w)\n\n    while(size(unpaired) >= 2)\n        int u = pop(unpaired)\n        int w = pop(unpaired)\n        print(u,v,w)\n\n    if(not empty(unpaired))\n        return pop(unpaired)\n    else\n        return 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 7",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, **u**)\n        **else**\n**            print(v,u,w)**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 8",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, **u**)\n        **else**\n**            print(v,u,w)**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 9",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 10",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 11",
          "code": "if(w = 0)\n    add(unpaired, u)\nelse\n    print(v,u,w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #238 Tutorial - Codeforces - Code 12",
          "code": "if(w = 0)\n    add(unpaired, u)\nelse\n    print(v,u,w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loops are not allowed: edge from %d to %d\", a, b);\n\n        pair<int, int> edge = make_pair(min(a, b), max(a, b));\n        ensuref(edges.find(edge) == edges.end(), \"Multi-edge detected between %d and %d\", a, b);\n        edges.insert(edge);\n    }\n\n    // Check that the graph is connected\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++) parent[i] = i;\n\n    function<int(int)> find = [&](int u) {\n        if (parent[u] != u) parent[u] = find(parent[u]);\n        return parent[u];\n    };\n\n    for (const auto& edge : edges) {\n        int u = edge.first;\n        int v = edge.second;\n        int pu = find(u);\n        int pv = find(v);\n        if (pu != pv) {\n            parent[pu] = pv;\n        }\n    }\n\n    int comp = find(1);\n    for (int i = 2; i <= n; i++) {\n        ensuref(find(i) == comp, \"The graph is not connected.\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loops are not allowed: edge from %d to %d\", a, b);\n\n        pair<int, int> edge = make_pair(min(a, b), max(a, b));\n        ensuref(edges.find(edge) == edges.end(), \"Multi-edge detected between %d and %d\", a, b);\n        edges.insert(edge);\n    }\n\n    // Check that the graph is connected\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++) parent[i] = i;\n\n    function<int(int)> find = [&](int u) {\n        if (parent[u] != u) parent[u] = find(parent[u]);\n        return parent[u];\n    };\n\n    for (const auto& edge : edges) {\n        int u = edge.first;\n        int v = edge.second;\n        int pu = find(u);\n        int pv = find(v);\n        if (pu != pv) {\n            parent[pu] = pv;\n        }\n    }\n\n    int comp = find(1);\n    for (int i = 2; i <= n; i++) {\n        ensuref(find(i) == comp, \"The graph is not connected.\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loops are not allowed: edge from %d to %d\", a, b);\n\n        pair<int, int> edge = make_pair(min(a, b), max(a, b));\n        ensuref(edges.find(edge) == edges.end(), \"Multi-edge detected between %d and %d\", a, b);\n        edges.insert(edge);\n    }\n\n    // Check that the graph is connected\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++) parent[i] = i;\n\n    function<int(int)> find = [&](int u) {\n        if (parent[u] != u) parent[u] = find(parent[u]);\n        return parent[u];\n    };\n\n    for (const auto& edge : edges) {\n        int u = edge.first;\n        int v = edge.second;\n        int pu = find(u);\n        int pv = find(v);\n        if (pu != pv) {\n            parent[pu] = pv;\n        }\n    }\n\n    int comp = find(1);\n    for (int i = 2; i <= n; i++) {\n        ensuref(find(i) == comp, \"The graph is not connected.\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(); // number of vertices\n    int m = inf.readInt(); // number of edges\n\n    map<pair<int, int>, bool> edge_exists; // map to store edges\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt();\n        int v = inf.readInt();\n        edge_exists[make_pair(u, v)] = true;\n        edge_exists[make_pair(v, u)] = true;\n    }\n\n    // Read jury's answer\n    string jury_line = ans.readLine();\n    while (!jury_line.empty() && isspace(jury_line.back())) jury_line.pop_back();\n    while (!jury_line.empty() && isspace(jury_line.front())) jury_line.erase(jury_line.begin());\n\n    // Read participant's answer\n    string participant_line = ouf.readLine();\n    while (!participant_line.empty() && isspace(participant_line.back())) participant_line.pop_back();\n    while (!participant_line.empty() && isspace(participant_line.front())) participant_line.erase(participant_line.begin());\n\n    if (jury_line == \"No solution\") {\n        if (participant_line == \"No solution\") {\n            quitf(_ok, \"Correctly found no solution\");\n        } else {\n            quitf(_wa, \"Participant found solution whereas jury found no solution\");\n        }\n    } else {\n        if (participant_line == \"No solution\") {\n            quitf(_wa, \"Participant found no solution whereas jury found a solution\");\n        } else {\n            // Both outputs are solutions\n            vector<string> participant_lines;\n            participant_lines.push_back(participant_line);\n            while (!ouf.eof()) {\n                string line = ouf.readLine();\n                participant_lines.push_back(line);\n            }\n\n            if (participant_lines.size() * 2 != m) {\n                quitf(_wa, \"Incorrect number of paths, expected %d paths, got %d paths\", m / 2, participant_lines.size());\n            }\n\n            set<pair<int, int>> used_edges;\n\n            for (size_t i = 0; i < participant_lines.size(); ++i) {\n                string line = participant_lines[i];\n                std::stringstream ss(line);\n                int xi, yi, zi;\n                if (!(ss >> xi >> yi >> zi)) {\n                    quitf(_wa, \"Cannot parse three integers in line %d\", int(i + 1));\n                }\n                if (xi < 1 || xi > n || yi < 1 || yi > n || zi < 1 || zi > n) {\n                    quitf(_wa, \"Value out of bounds in line %d: xi=%d yi=%d zi=%d\", int(i + 1), xi, yi, zi);\n                }\n                string extra;\n                if (ss >> extra) {\n                    quitf(_wa, \"Extra tokens in line %d\", int(i + 1));\n                }\n                if (!edge_exists.count(make_pair(xi, yi))) {\n                    quitf(_wa, \"Edge (%d, %d) does not exist in the graph, line %d\", xi, yi, int(i + 1));\n                }\n                if (!edge_exists.count(make_pair(yi, zi))) {\n                    quitf(_wa, \"Edge (%d, %d) does not exist in the graph, line %d\", yi, zi, int(i + 1));\n                }\n                pair<int, int> e1 = make_pair(min(xi, yi), max(xi, yi));\n                pair<int, int> e2 = make_pair(min(yi, zi), max(yi, zi));\n                if (used_edges.count(e1)) {\n                    quitf(_wa, \"Edge (%d, %d) used more than once, line %d\", xi, yi, int(i + 1));\n                }\n                if (used_edges.count(e2)) {\n                    quitf(_wa, \"Edge (%d, %d) used more than once, line %d\", yi, zi, int(i + 1));\n                }\n                used_edges.insert(e1);\n                used_edges.insert(e2);\n            }\n\n            if (used_edges.size() != m) {\n                quitf(_wa, \"Not all edges are used, total used edges: %d, total edges: %d\", int(used_edges.size()), m);\n            }\n\n            quitf(_ok, \"Solution is correct\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if(type == \"tree\") {\n        // m must be n-1\n        m = n - 1;\n        printf(\"%d %d\\n\", n, m);\n        vector<pair<int, int>> edges;\n\n        // Generate a tree\n        for(int i = 2; i <= n; i++) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back({u, v});\n        }\n        shuffle(edges.begin(), edges.end());\n        for(auto &e: edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if(type == \"star\") {\n        // m = n - 1\n        m = n - 1;\n        printf(\"%d %d\\n\", n, m);\n        for(int i = 2; i <= n; i++) {\n            printf(\"1 %d\\n\", i);\n        }\n    } else if(type == \"cycle\") {\n        // m = n\n        m = n;\n        printf(\"%d %d\\n\", n, m);\n        vector<pair<int, int>> edges;\n        for(int i = 1; i <= n; i++) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back({u, v});\n        }\n        shuffle(edges.begin(), edges.end());\n        for(auto &e: edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if(type == \"complete\") {\n        // m = n*(n-1)/2\n        long long total_possible_edges = 1LL * n * (n - 1) / 2;\n        m = (m == -1 || m > total_possible_edges) ? total_possible_edges : m;\n        if(m > 100000) m = 100000;\n        printf(\"%d %d\\n\", n, m);\n        set<pair<int, int>> edge_set;\n        for(int i = 1; i <= n && (int)edge_set.size() < m; i++) {\n            for(int j = i + 1; j <= n && (int)edge_set.size() < m; j++) {\n                edge_set.insert({i, j});\n            }\n        }\n        vector<pair<int, int>> edges(edge_set.begin(), edge_set.end());\n        shuffle(edges.begin(), edges.end());\n        edges.resize(m);\n        for(auto &e: edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if(type == \"line\") {\n        // m = n - 1\n        m = n - 1;\n        printf(\"%d %d\\n\", n, m);\n        for(int i = 1; i < n; i++) {\n            printf(\"%d %d\\n\", i, i + 1);\n        }\n    } else if(type == \"random\") {\n        // m up to n*(n-1)/2\n        int max_edges = n * (n - 1) / 2;\n        if(m == -1) m = max_edges;\n        assert(m <= max_edges);\n        printf(\"%d %d\\n\", n, m);\n        vector<int> parent(n + 1);\n        for(int i = 1; i <= n; i++) parent[i] = i;\n\n        function<int(int)> find = [&](int x) {\n            return parent[x] == x ? x : parent[x] = find(parent[x]);\n        };\n\n        vector<pair<int, int>> edges;\n\n        // First, make sure graph is connected\n        for(int i = 2; i <= n; i++) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            parent[find(u)] = find(v);\n            edges.push_back({u, v});\n        }\n\n        set<pair<int, int>> edge_set(edges.begin(), edges.end());\n\n        // Add additional edges randomly\n        while((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if(u == v) continue;\n            if(u > v) swap(u, v);\n            if(edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n        shuffle(edges.begin(), edges.end());\n        for(auto &e: edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if(type == \"odd_m\") {\n        // Generate graph with m odd\n        if(m == -1) m = n - 1;\n        if(m % 2 == 0) m++;\n        int max_edges = n * (n - 1) / 2;\n        if (m > max_edges) m = max_edges;\n        printf(\"%d %d\\n\", n, m);\n        vector<int> parent(n + 1);\n        for(int i = 1; i <= n; i++) parent[i] = i;\n\n        function<int(int)> find = [&](int x) {\n            return parent[x] == x ? x : parent[x] = find(parent[x]);\n        };\n\n        vector<pair<int, int>> edges;\n\n        // First, make sure graph is connected\n        for(int i = 2; i <= n; i++) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            parent[find(u)] = find(v);\n            edges.push_back({u, v});\n        }\n\n        set<pair<int, int>> edge_set(edges.begin(), edges.end());\n\n        // Add additional edges randomly\n        while((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if(u == v) continue;\n            if(u > v) swap(u, v);\n            if(edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n        shuffle(edges.begin(), edges.end());\n        for(auto &e: edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else {\n        // Other types can be added here\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if(type == \"tree\") {\n        // m must be n-1\n        m = n - 1;\n        printf(\"%d %d\\n\", n, m);\n        vector<pair<int, int>> edges;\n\n        // Generate a tree\n        for(int i = 2; i <= n; i++) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back({u, v});\n        }\n        shuffle(edges.begin(), edges.end());\n        for(auto &e: edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if(type == \"star\") {\n        // m = n - 1\n        m = n - 1;\n        printf(\"%d %d\\n\", n, m);\n        for(int i = 2; i <= n; i++) {\n            printf(\"1 %d\\n\", i);\n        }\n    } else if(type == \"cycle\") {\n        // m = n\n        m = n;\n        printf(\"%d %d\\n\", n, m);\n        vector<pair<int, int>> edges;\n        for(int i = 1; i <= n; i++) {\n            int u = i;\n            int v = i % n + 1;\n            edges.push_back({u, v});\n        }\n        shuffle(edges.begin(), edges.end());\n        for(auto &e: edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if(type == \"complete\") {\n        // m = n*(n-1)/2\n        long long total_possible_edges = 1LL * n * (n - 1) / 2;\n        m = (m == -1 || m > total_possible_edges) ? total_possible_edges : m;\n        if(m > 100000) m = 100000;\n        printf(\"%d %d\\n\", n, m);\n        set<pair<int, int>> edge_set;\n        for(int i = 1; i <= n && (int)edge_set.size() < m; i++) {\n            for(int j = i + 1; j <= n && (int)edge_set.size() < m; j++) {\n                edge_set.insert({i, j});\n            }\n        }\n        vector<pair<int, int>> edges(edge_set.begin(), edge_set.end());\n        shuffle(edges.begin(), edges.end());\n        edges.resize(m);\n        for(auto &e: edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if(type == \"line\") {\n        // m = n - 1\n        m = n - 1;\n        printf(\"%d %d\\n\", n, m);\n        for(int i = 1; i < n; i++) {\n            printf(\"%d %d\\n\", i, i + 1);\n        }\n    } else if(type == \"random\") {\n        // m up to n*(n-1)/2\n        int max_edges = n * (n - 1) / 2;\n        if(m == -1) m = max_edges;\n        assert(m <= max_edges);\n        printf(\"%d %d\\n\", n, m);\n        vector<int> parent(n + 1);\n        for(int i = 1; i <= n; i++) parent[i] = i;\n\n        function<int(int)> find = [&](int x) {\n            return parent[x] == x ? x : parent[x] = find(parent[x]);\n        };\n\n        vector<pair<int, int>> edges;\n\n        // First, make sure graph is connected\n        for(int i = 2; i <= n; i++) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            parent[find(u)] = find(v);\n            edges.push_back({u, v});\n        }\n\n        set<pair<int, int>> edge_set(edges.begin(), edges.end());\n\n        // Add additional edges randomly\n        while((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if(u == v) continue;\n            if(u > v) swap(u, v);\n            if(edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n        shuffle(edges.begin(), edges.end());\n        for(auto &e: edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else if(type == \"odd_m\") {\n        // Generate graph with m odd\n        if(m == -1) m = n - 1;\n        if(m % 2 == 0) m++;\n        int max_edges = n * (n - 1) / 2;\n        if (m > max_edges) m = max_edges;\n        printf(\"%d %d\\n\", n, m);\n        vector<int> parent(n + 1);\n        for(int i = 1; i <= n; i++) parent[i] = i;\n\n        function<int(int)> find = [&](int x) {\n            return parent[x] == x ? x : parent[x] = find(parent[x]);\n        };\n\n        vector<pair<int, int>> edges;\n\n        // First, make sure graph is connected\n        for(int i = 2; i <= n; i++) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            parent[find(u)] = find(v);\n            edges.push_back({u, v});\n        }\n\n        set<pair<int, int>> edge_set(edges.begin(), edges.end());\n\n        // Add additional edges randomly\n        while((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if(u == v) continue;\n            if(u > v) swap(u, v);\n            if(edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n        shuffle(edges.begin(), edges.end());\n        for(auto &e: edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    } else {\n        // Other types can be added here\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n\n./gen -n 3 -m 3 -type random\n./gen -n 3 -m 2 -type random\n./gen -n 3 -type tree\n./gen -n 3 -type star\n./gen -n 3 -type cycle\n./gen -n 3 -type line\n\n# Medium n\n./gen -n 50 -m 49 -type tree\n./gen -n 50 -m 50 -type cycle\n./gen -n 50 -m 100 -type random\n./gen -n 50 -m 49 -type star\n./gen -n 50 -type complete\n\n# Large n\n./gen -n 100000 -m 99999 -type tree\n./gen -n 100000 -m 100000 -type random\n\n# Odd m\n./gen -n 1000 -m 999 -type odd_m\n./gen -n 99999 -m 99999 -type odd_m\n\n# Edge cases\n./gen -n 2 -type star\n./gen -n 2 -type cycle\n./gen -n 2 -type line\n\n# Maximum m\n./gen -n 1000 -type complete\n./gen -n 1000 -m 100000 -type random\n\n# Special configurations\n./gen -n 5000 -m 5000 -type cycle\n./gen -n 5000 -type star\n./gen -n 5000 -type line\n./gen -n 5000 -m 10000 -type random\n\n# Random graphs with various m\n./gen -n 10000 -m 20000 -type random\n./gen -n 10000 -m 50000 -type random\n./gen -n 10000 -m 99999 -type random\n\n# Graph with m = n*(n-1)/2\n./gen -n 447 -type complete\n\n# Graph with m = 1e5\n./gen -n 10000 -m 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:25.420547",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "406/D",
      "title": "D. Скалолазание",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится единственное целое число n (1 ≤ n ≤ 105) — количество скал. Следующие n строк описывают скалы: i-я из них содержит два целых числа через пробел xi, yi (1 ≤ xi ≤ 107; 1 ≤ yi ≤ 1011) — позиция и высота i-й скалы. Скалы даны в порядке увеличения xi, то есть, xi < xj для i < j.В следующей строке записано единственное целое число m (1 ≤ m ≤ 105) — количество команд. Следующие m строк описывают команды: i-я строка содержит два целых числа через пробел ai, bi (1 ≤ ai, bi ≤ n) — номера скал, где расположены участники i-й команды. Числа ai и bi могут быть равны.",
      "output_spec": "Выходные данныеВ единственной строке выведите m целых чисел через пробел, где i-е число — номер скалы, на которой встретятся скалолазы из i-й команды.",
      "sample_tests": "ПримерыВходные данныеСкопировать61 42 13 24 36 47 433 15 62 3Выходные данныеСкопировать5 6 3",
      "description": "D. Скалолазание\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке содержится единственное целое число n (1 ≤ n ≤ 105) — количество скал. Следующие n строк описывают скалы: i-я из них содержит два целых числа через пробел xi, yi (1 ≤ xi ≤ 107; 1 ≤ yi ≤ 1011) — позиция и высота i-й скалы. Скалы даны в порядке увеличения xi, то есть, xi < xj для i < j.В следующей строке записано единственное целое число m (1 ≤ m ≤ 105) — количество команд. Следующие m строк описывают команды: i-я строка содержит два целых числа через пробел ai, bi (1 ≤ ai, bi ≤ n) — номера скал, где расположены участники i-й команды. Числа ai и bi могут быть равны.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите m целых чисел через пробел, где i-е число — номер скалы, на которой встретятся скалолазы из i-й команды.\n\nВыходные данные\n\nВходные данныеСкопировать61 42 13 24 36 47 433 15 62 3Выходные данныеСкопировать5 6 3\n\nВходные данныеСкопировать61 42 13 24 36 47 433 15 62 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5 6 3\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #238 - Codeforces",
          "content": "Всем привет!Сегодня в 19:30 по Московскому времени состоится раунд Codeforces #238. Контест пройдёт в обоих дивизиях.Раунд был подготовлен мной и cfk. Это мой 4-ый раунд и 2-ой раунд Кришьяниса. В этот раз, по-моему, задачи весьма необычные и, может, даже неожиданные. Мы уверены, что любой участник(ца) найдёт себе задачу по вкусу! Но нужно её найти. (:Как всегда, спасибо Михаилу Мирзаянову (MikeMirzayanov) за проект Codeforces и систему Polygon, и Марии Беловой (Delinur) за перевод условий. Большое спасибо Геральду Агапову (Gerald) за помощь в подготовке контеста. Мне и Геральду повезло обсудить задачи очно во время зимних Петрозаводских сборов, что, по-моему, оказалось очень полезно.Мы желаем вам захватывающего раунда!UPD1: Распределение баллов:DivI: 500 1000 2000 2000 2500DivII: 500 1000 1500 2000 3000Баллы выставлены относительно, чтобы стоимость каждой задачи делилась на 500, и была бы ближе к объективной оценке. Не пугайтесь, на самом деле задачи не настолько сложные. (:UPD2: Поздравляем победителей!DivI: al13n Shef scott_wu sillycross Komaki DivII: NelsonMondialu L_Ecry aaaaAaaaaAaaaaAaaaaA xorfire Hec UPD3: Замечательная статистика раунда от DmitriyH.UPD4: Разбор опубликован здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11153",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1207
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces",
          "content": "405A - Переключение гравитацииЗаметим, что в конечном расположении все высоты столбиков расположены в неубывающем порядке. Также, количество столбиков каждой высоты остаётся неизменным. Это означает, что ответом является упорядоченная последовательность данных высот столбиков.Сложность решения: O(n), так как можно упорядочить подсчётом.405B - Эффект доминоЕсли самая первая толкнутая доминошка слева была толкнута влево на позиции l, все доминошки на префиксе [1;l] падают, иначе пусть l будет 0. Аналогично, если самая последняя толкнутая доминошка была толкнута направо на позиции r, все доминошки на суффиксе [r;n] падают, иначе пусть r будет n + 1. Теперь, на отрезке (l;r) остаются вертикально стоящие доминошки, а также блоки домино, поддерживающиеся одинаковыми силами с обеих сторон.Когда доминошка на позиции p на отрезке (l, r) остаётся стоять вертикально? В одном случае, её не толкает ни одна другая доминошка. Это можно легко проверить, посмотрев на ближайшие к p толкнутые доминошки (с обеих сторон). Она была затронута другими домино, если самая близкая толкнутая доминошка слева была толкнута направо и самая близкая толкнутая доминошка справа была толкнута влево. Допустим, эти доминошки находятся на позициях x и y, x < p < y. Тогда, единственная возможность для доминошки остаться вертикально тогда, когда она находится в центре блока [x;y], что можно проверить выражением .Сложность решения: O(n) / O(n2), что зависит от реализации.406A - Необычное произведениеЕсли записать в виде формулы искомое произведение в задаче, получаем Допустим, что i ≠ j. Тогда сумма содержит слагаемые AijAji и AjiAij. Так как сумма всегда берётся по модулю 2, вместе эти слагаемые дают 0 к сумме. Из этого следует, что выражение всегда равняется сумме битов на диагонали: Теперь, каждый запрос типа 1 и 2 меняет значение ровно одного элемента на диагонали. Поэтому мы можем посчитать необычное произведение изначальной матрицы, и после каждого запроса типа 1 и 2 менять его значение на противоположное.Сложность решения: O(n + q), если не брать во внимание ввод... :)406B - Игрушечная суммаОпределим для числа k его симметричное число как s + 1 - k. Так как в задаче s чётное число, k ≠ s - k.Заметим, что (k - 1) + (s + 1 - k) = s, т.е., сумма числа и его симметричного всегда равно s. Будем обрабатывать все числа x множества X по порядку. Различаем два случая: Если симметричное x не принадлежит X, добавим его к Y. Оба числа дают одинаковые значения к соответствующим суммам: x - 1 = s - (s + 1 - x). Симметричное x принадлежит X. Тогда возьмём любое y такое, что ни y, ни симметричное y не принадлежат X, и добавим их к Y. Обе пары дают одинаковые значения к соответствующим суммам, а именно s. Как доказать, что во втором случае мы всегда сможем найти такое y? Пусть количество симметричных пар, которые были обработаны в первом случае, равно a, тогда остаются других пар. Среди них, для пар оба числа принадлежат X, а для других пар никакие из чисел не принадлежат X. Чтобы выбрать такое что количество пар для Y, как и в X, должно выполняться что равносильно , как и дано в условии.Сложность решения: O(s) / O(n).406C - Разрез графаМожно доказать, что только графы с нечётным количеством рёбер нельзя разбить на пути длины 2. Мы построим рекурсивную функцию, решающую задачу, которая и будет служить доказательством этого утверждения.Функция partition(v) будет работать на незаблокированных рёбрах. Она разбивает компоненту вершины v, связную по незаблокированным рёбрам, на пути длины 2. Если компонента имеет нечётное количество рёбер, функция разобьёт все рёбра компоненты, кроме одного ребра (u, v); тогда функция вернёт вершину u, ожидая, что предыдущий вызов функции присвоит это ребро какому-нибудь пути.Функция работает следующим образом: найдём все вершины, соседние с v по незаблокированным рёбрам, назовём это множество adjacent. Далее заблокируем все рёбра из этих вершин в v. Для каждой u в adjacent, вызовем partition(u). Допустим, что вызов partition(u) вернул вершину w. Это значит, что мы можем присвоить её в путь (v, u, w). Иначе, если partition(u) ничего не вернул, добавим u к unpaired, потому что ребро (v, u) ещё не присвоено ни одному пути. Мы можем объединить в путь любые две вершины этого множества u, w в один путь (u, v, w). Спарим как можно больше таких вершин в любом порядке. Если из этого множества осталась только одна вершина, u, то функция вернёт u. В противном случае функция ничего не возвращает.Функцию можно реализовать всего одним DFS: partition(v) :\n adjacent = { u | not blocked[(u,v)] }\n for(u : adjacent)\n blocked[(u,v)] = true\n\n unpaired = {}\n for(u : adjacent)\n int w = partition(u)\n if(w = 0)\n add(unpaired, u)\n else\n print(v,u,w)\n\n while(size(unpaired) >= 2)\n int u = pop(unpaired)\n int w = pop(unpaired)\n print(u,v,w)\n\n if(not empty(unpaired))\n return pop(unpaired)\n else\n return 0Сложность решения: O(n + m).406D - СкалолазаниеЗаметим, что каждый путь скалолаза выпуклый в любом случае. Проведём пути из всех скал до последней скалы. Тогда эти пути образуют дерево с «корнем» в вершине последней скалы. Мы можем применить алгоритм Грэхема справа налево, чтобы найти рёбра этого дерева. Каждое удаление и добавление в стеке соответствует ровно одному ребру в дереве.Теперь несложно видеть, что для каждой команды скалолазов, нам нужно найти номер наименьшего общего предка для соответствующей пары вершин в дереве. Так как размер дерева равен n, каждый запрос обрабатывается за .Сложность решения: .406E - Тройки ХеммингаДавайте рассмотрим хэммингов граф из всех различных 2n строк, где каждые две строки соединены ребром длины, равному расстоянию Хэмминга между этими строками. Мы можем заметить, что этот граф обладает годным свойством: если упорядочить все вершины циклически по правильному 2n-угольнику со стороной длины 1, расстояние Хэмминга для каждых двух строк равняется длине кратчайшего пути между этими вершинами на периметре этого многоугольника.Например, на рисунке изображён такой граф для n = 3. Серые рёбра имеют длину 1, оранжевые рёбра имеют длину 2, синие рёбра имеют длину 3. Это равняется соответствующему расстоянию Хэмминга.Теперь, мы можем преобразовать каждую строку, закодированную парой чисел (s, f), в целое число (f + 1)·n - s. Новые числа будут среди 0, 1, ..., 2n - 1 и соотноситься с тем же циклическим порядком на периметре многоугольника. Данные строки переходят в какой-то набор вершин. Теперь нам нужно найти количество треугольников (возможно, дегенерированных) с наибольшим периметром в этом подграфе. Далее будет полезно упорядочить преобразованные числа.Для начала, можно попробовать понять, каким может быть этот периметр. Если существует такой диаметр в полном графе, что все данные точки находятся по одну сторону диаметра, периметр будет равен 2d, где d является значением самого длинного ребра:Тогда любой треугольник с двумя вершинами на этом ребре и третьим в любой из остальных точек будет иметь наибольший периметр. Так как числа упорядочены, самое длинное ребро в этом случае будет образовано двумя циклически рядом стоящими элементами, что не трудно найти.Если для любого диаметра это не выполняется, тогда наибольший периметр равен 2n. Это можно доказать, взяв две различных точки a, b, и проведя два диаметра из этих точек как концов; так как это не предыдущий случай, должна быть третья точка c в месте, где периметр треугольника a, b, c равняется 2n.Самая хитрая часть и есть посчитать тройки в этом случае. Мы делаем это, работая с диаметром (0, n). Всего может быть несколько случаев: Наибольший треугольник содержит обе вершины 0 и n. Это простой случай: с любой другой вершиной как третьей такой треугольник имеет периметр 2n. Наибольший треугольник содержит вершину 0, но не n. Тогда вторая вершина должна находится на отрезке [0, n), а третья на отрезке (n + 1, 2n - 1], и расстояние по часовой стрелке между второй и третьей вершинами не должно превышать n (в противном случае периметр треугольника был бы меньше, чем 2n). Мы считаем количество таких троек, двигая два указателя (по одному на каждый из этих отрезков). Для каждого указателя в первом отрезке, все точки, начиная с n + 1 до второго указателя образуют наибольший треугольник. Аналогично мы решаем случай, когда треугольник содержит n, но не 0. Наибольший треугольник не содержит ни 0, ни n как вершины. Тогда одна вершина треугольника должна находится на одной стороне диаметра (0, n), а две остальные на другой стороне. Чтобы посчитать их, будем двигать указатель на первую вершину на одной стороне, скажем, (0, n); обозначим диаметрально противоположную вершину за x. Тогда вторая вершина может быть любой на отрезке [n + 1, s], а третья может быть любой на [s, 2n - 1]. Количество этих точек легко посчитать, используя частичные суммы на круге. Заметьте, что s может быть как второй, так и третьей вершиной одновременно (строки могут повторяться). Тогда мы двигаем этот указатель через все вершины одной стороны и обновляем ответ. Аналогично мы решаем случай, когда первая вершина на второй стороне, а обе других на противоположной. Остаётся только быть осторожными с формулами в каждом случае.Сложность решения: из-за сортировки.Post ScriptumКакими были ваши решения? Не стесняйтесь поделиться любыми решениями или мыслями! Например, было ли в DivI E решение, проще авторского?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11186",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 406\\s*D"
          },
          "content_length": 9269
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #238 - Codeforces - Code 1",
          "code": "|   \n       |\n       |\n       |\n  |    |\n| |  | | \n1 2  3 4\n(In reversed order, from right to left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 2",
          "code": "|   \n       |\n       |\n       |\n  |    |\n| |  | | \n1 2  3 4\n(In reversed order, from right to left)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 3",
          "code": "Push 1\nmake_edge(1,2) (i will not write these from now on)\nPush 2\ntry to pop the stack -> verify whether or not line segment 1 3 passes through hill 2 -> no -> no pop\nPush 3\ntry to pop the stack -> 2 4 is above 3, so we pop the stack\ntry to pop the stack -> 4 1 is above 2, so we pop the stack\n(make edge 1,4)\nPush 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 4",
          "code": "Push 1\nmake_edge(1,2) (i will not write these from now on)\nPush 2\ntry to pop the stack -> verify whether or not line segment 1 3 passes through hill 2 -> no -> no pop\nPush 3\ntry to pop the stack -> 2 4 is above 3, so we pop the stack\ntry to pop the stack -> 4 1 is above 2, so we pop the stack\n(make edge 1,4)\nPush 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 5",
          "code": "if(((1ll*stack[poz].x-stack[poz-1].x)*(1ll*v[i].h-stack[poz-1].h))<((1ll*stack[poz].h &mdash; 1ll*stack[poz-1].h)*(1ll*v[i].x-1ll*stack[poz-1].x)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 6",
          "code": "if(((1ll*stack[poz].x-stack[poz-1].x)*(1ll*v[i].h-stack[poz-1].h))<((1ll*stack[poz].h &mdash; 1ll*stack[poz-1].h)*(1ll*v[i].x-1ll*stack[poz-1].x)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 7",
          "code": "if (tp==3){av.push_back(res);}\n\nfor (int i=0;i<av.size();i++)\n{\n cout<<av[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 8",
          "code": "if (tp==3){av.push_back(res);}\n\nfor (int i=0;i<av.size();i++)\n{\n cout<<av[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 9",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 10",
          "code": "scanf/printf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 11",
          "code": "cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 12",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 13",
          "code": "ios :: sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 14",
          "code": "cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 15",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 16",
          "code": "string s; s.reserve(100005);\n\nfor (int i = 0; i < n; i++)\n{\n    cin >> s;\n\n    // do something\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 17",
          "code": "string s; s.reserve(100005);\n\nfor (int i = 0; i < n; i++)\n{\n    cin >> s;\n\n    // do something\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 18",
          "code": "#define dibs reserve",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 19",
          "code": "(tr(A^2)) mod 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 20",
          "code": "(tr(A^2)) mod 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 21",
          "code": "tr(A^2) mod 2 = (tr(A)*tr(A)) mod 2 = tr(A) mod 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 22",
          "code": "tr(A^2) mod 2 = (tr(A)*tr(A)) mod 2 = tr(A) mod 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 23",
          "code": "Вообще-то, все мои посылки работали ровно за n*n+const*q. Но меня окончательно добил тот факт, что посылка с контеста на Delhi, получившая RE на 3-м тесте, спокойно зашла в в дорешивании при закомменченом закрывании outputа. Всегда искренне полагал, что output надо закрывать, и на тебе - с закрыванием сыпется, а баз него все  ОК.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 24",
          "code": "(X +- (2*Y))%2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 25",
          "code": "FastScanner",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #238 - Codeforces - Code 26",
          "code": "java.io.BufferedReader",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11153",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 1",
          "code": "partition(v)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 2",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 3",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 4",
          "code": "partition(u)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 5",
          "code": "partition(v) :\n    adjacent = { u | not blocked[(u,v)] }\n    for(u : adjacent)\n        blocked[(u,v)] = true\n\n    unpaired = {}\n    for(u : adjacent)\n        int w = partition(u)\n        if(w = 0)\n            add(unpaired, u)\n        else\n            print(v,u,w)\n\n    while(size(unpaired) >= 2)\n        int u = pop(unpaired)\n        int w = pop(unpaired)\n        print(u,v,w)\n\n    if(not empty(unpaired))\n        return pop(unpaired)\n    else\n        return 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 6",
          "code": "partition(v) :\n    adjacent = { u | not blocked[(u,v)] }\n    for(u : adjacent)\n        blocked[(u,v)] = true\n\n    unpaired = {}\n    for(u : adjacent)\n        int w = partition(u)\n        if(w = 0)\n            add(unpaired, u)\n        else\n            print(v,u,w)\n\n    while(size(unpaired) >= 2)\n        int u = pop(unpaired)\n        int w = pop(unpaired)\n        print(u,v,w)\n\n    if(not empty(unpaired))\n        return pop(unpaired)\n    else\n        return 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 7",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, **u**)\n        **else**\n**            print(v,u,w)**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 8",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, **u**)\n        **else**\n**            print(v,u,w)**",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 9",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 10",
          "code": "for(u : adjacent)\n        int w = partition(u)\n        if(w not 0)\n            add(unpaired, w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 11",
          "code": "if(w = 0)\n    add(unpaired, u)\nelse\n    print(v,u,w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #238 - Codeforces - Code 12",
          "code": "if(w = 0)\n    add(unpaired, u)\nelse\n    print(v,u,w)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11186",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int prev_xi = -1;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(1, 10000000, \"xi\");\n        inf.readSpace();\n        long long yi = inf.readLong(1LL, 100000000000LL, \"yi\");\n        inf.readEoln();\n\n        if (i > 0) {\n            ensuref(prev_xi < xi, \"xi[%d]=%d is not less than xi[%d]=%d\", i + 1, xi, i, prev_xi);\n        }\n        prev_xi = xi;\n    }\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int prev_xi = -1;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(1, 10000000, \"xi\");\n        inf.readSpace();\n        long long yi = inf.readLong(1LL, 100000000000LL, \"yi\");\n        inf.readEoln();\n\n        if (i > 0) {\n            ensuref(prev_xi < xi, \"xi[%d]=%d is not less than xi[%d]=%d\", i + 1, xi, i, prev_xi);\n        }\n        prev_xi = xi;\n    }\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int prev_xi = -1;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(1, 10000000, \"xi\");\n        inf.readSpace();\n        long long yi = inf.readLong(1LL, 100000000000LL, \"yi\");\n        inf.readEoln();\n\n        if (i > 0) {\n            ensuref(prev_xi < xi, \"xi[%d]=%d is not less than xi[%d]=%d\", i + 1, xi, i, prev_xi);\n        }\n        prev_xi = xi;\n    }\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    string teams_type = opt<string>(\"teams_type\", \"random\");\n    \n    vector<int> xi(n);\n    vector<long long> yi(n);\n\n    if (type == \"random\") {\n        // Generate positions xi\n        set<int> xi_set;\n        while ((int)xi_set.size() < n) {\n            xi_set.insert(rnd.next(1, 10000000));\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n        sort(xi.begin(), xi.end());\n        // Generate heights yi\n        for (int i = 0; i < n; ++i) {\n            yi[i] = rnd.next(1LL, 100000000000LL);\n        }\n    } else if (type == \"same_heights\") {\n        // Generate positions xi\n        set<int> xi_set;\n        while ((int)xi_set.size() < n) {\n            xi_set.insert(rnd.next(1, 10000000));\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n        sort(xi.begin(), xi.end());\n        // All heights equal\n        long long h = rnd.next(1LL, 100000000000LL);\n        for (int i = 0; i < n; ++i) {\n            yi[i] = h;\n        }\n    } else if (type == \"increasing_heights\") {\n        // Generate positions xi\n        set<int> xi_set;\n        while ((int)xi_set.size() < n) {\n            xi_set.insert(rnd.next(1, 10000000));\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n        sort(xi.begin(), xi.end());\n        // Heights increase\n        long long minHeight = 1LL;\n        long long maxHeight = 100000000000LL;\n        for (int i = 0; i < n; ++i) {\n            yi[i] = minHeight + (maxHeight - minHeight) * i / (n - 1);\n        }\n    } else if (type == \"decreasing_heights\") {\n        // Generate positions xi\n        set<int> xi_set;\n        while ((int)xi_set.size() < n) {\n            xi_set.insert(rnd.next(1, 10000000));\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n        sort(xi.begin(), xi.end());\n        // Heights decrease\n        long long minHeight = 1LL;\n        long long maxHeight = 100000000000LL;\n        for (int i = 0; i < n; ++i) {\n            yi[i] = maxHeight - (maxHeight - minHeight) * i / (n - 1);\n        }\n    } else if (type == \"zigzag_heights\") {\n        // Generate positions xi\n        set<int> xi_set;\n        while ((int)xi_set.size() < n) {\n            xi_set.insert(rnd.next(1, 10000000));\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n        sort(xi.begin(), xi.end());\n        // Heights oscillate between min and max\n        long long minHeight = 1LL;\n        long long maxHeight = 100000000000LL;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                yi[i] = maxHeight;\n            } else {\n                yi[i] = minHeight;\n            }\n        }\n    } else if (type == \"max_heights\") {\n        // Generate positions xi\n        set<int> xi_set;\n        while ((int)xi_set.size() < n) {\n            xi_set.insert(rnd.next(1, 10000000));\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n        sort(xi.begin(), xi.end());\n        // All heights max\n        long long h = 100000000000LL;\n        for (int i = 0; i < n; ++i) {\n            yi[i] = h;\n        }\n    } else if (type == \"min_heights\") {\n        // Generate positions xi\n        set<int> xi_set;\n        while ((int)xi_set.size() < n) {\n            xi_set.insert(rnd.next(1, 10000000));\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n        sort(xi.begin(), xi.end());\n        // All heights min\n        long long h = 1LL;\n        for (int i = 0; i < n; ++i) {\n            yi[i] = h;\n        }\n    } else {\n        // Default to random if unknown type\n        // Generate positions xi\n        set<int> xi_set;\n        while ((int)xi_set.size() < n) {\n            xi_set.insert(rnd.next(1, 10000000));\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n        sort(xi.begin(), xi.end());\n        // Generate heights yi\n        for (int i = 0; i < n; ++i) {\n            yi[i] = rnd.next(1LL, 100000000000LL);\n        }\n    }\n\n    // Output the hills\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %lld\\n\", xi[i], yi[i]);\n    }\n    \n    // Generate teams\n    vector<pair<int, int>> teams(m);\n\n    if (teams_type == \"same_hill\") {\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            teams[i] = make_pair(a, a);\n        }\n    } else if (teams_type == \"far_apart\") {\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n / 2);\n            int b = rnd.next(n / 2 + 1, n);\n            teams[i] = make_pair(a, b);\n        }\n    } else if (teams_type == \"adjacent\") {\n        // Teams on adjacent hills\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n - 1);\n            teams[i] = make_pair(a, a + 1);\n        }\n    } else if (teams_type == \"extreme\") {\n        // Climbers start at the leftmost and rightmost hills\n        for (int i = 0; i < m; ++i) {\n            teams[i] = make_pair(1, n);\n        }\n    } else {\n        // Random teams\n        for (int i = 0; i < m; ++i) {\n            int ai = rnd.next(1, n);\n            int bi = rnd.next(1, n);\n            teams[i] = make_pair(ai, bi);\n        }\n    }\n\n    // Output the teams\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", teams[i].first, teams[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    string teams_type = opt<string>(\"teams_type\", \"random\");\n    \n    vector<int> xi(n);\n    vector<long long> yi(n);\n\n    if (type == \"random\") {\n        // Generate positions xi\n        set<int> xi_set;\n        while ((int)xi_set.size() < n) {\n            xi_set.insert(rnd.next(1, 10000000));\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n        sort(xi.begin(), xi.end());\n        // Generate heights yi\n        for (int i = 0; i < n; ++i) {\n            yi[i] = rnd.next(1LL, 100000000000LL);\n        }\n    } else if (type == \"same_heights\") {\n        // Generate positions xi\n        set<int> xi_set;\n        while ((int)xi_set.size() < n) {\n            xi_set.insert(rnd.next(1, 10000000));\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n        sort(xi.begin(), xi.end());\n        // All heights equal\n        long long h = rnd.next(1LL, 100000000000LL);\n        for (int i = 0; i < n; ++i) {\n            yi[i] = h;\n        }\n    } else if (type == \"increasing_heights\") {\n        // Generate positions xi\n        set<int> xi_set;\n        while ((int)xi_set.size() < n) {\n            xi_set.insert(rnd.next(1, 10000000));\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n        sort(xi.begin(), xi.end());\n        // Heights increase\n        long long minHeight = 1LL;\n        long long maxHeight = 100000000000LL;\n        for (int i = 0; i < n; ++i) {\n            yi[i] = minHeight + (maxHeight - minHeight) * i / (n - 1);\n        }\n    } else if (type == \"decreasing_heights\") {\n        // Generate positions xi\n        set<int> xi_set;\n        while ((int)xi_set.size() < n) {\n            xi_set.insert(rnd.next(1, 10000000));\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n        sort(xi.begin(), xi.end());\n        // Heights decrease\n        long long minHeight = 1LL;\n        long long maxHeight = 100000000000LL;\n        for (int i = 0; i < n; ++i) {\n            yi[i] = maxHeight - (maxHeight - minHeight) * i / (n - 1);\n        }\n    } else if (type == \"zigzag_heights\") {\n        // Generate positions xi\n        set<int> xi_set;\n        while ((int)xi_set.size() < n) {\n            xi_set.insert(rnd.next(1, 10000000));\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n        sort(xi.begin(), xi.end());\n        // Heights oscillate between min and max\n        long long minHeight = 1LL;\n        long long maxHeight = 100000000000LL;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                yi[i] = maxHeight;\n            } else {\n                yi[i] = minHeight;\n            }\n        }\n    } else if (type == \"max_heights\") {\n        // Generate positions xi\n        set<int> xi_set;\n        while ((int)xi_set.size() < n) {\n            xi_set.insert(rnd.next(1, 10000000));\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n        sort(xi.begin(), xi.end());\n        // All heights max\n        long long h = 100000000000LL;\n        for (int i = 0; i < n; ++i) {\n            yi[i] = h;\n        }\n    } else if (type == \"min_heights\") {\n        // Generate positions xi\n        set<int> xi_set;\n        while ((int)xi_set.size() < n) {\n            xi_set.insert(rnd.next(1, 10000000));\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n        sort(xi.begin(), xi.end());\n        // All heights min\n        long long h = 1LL;\n        for (int i = 0; i < n; ++i) {\n            yi[i] = h;\n        }\n    } else {\n        // Default to random if unknown type\n        // Generate positions xi\n        set<int> xi_set;\n        while ((int)xi_set.size() < n) {\n            xi_set.insert(rnd.next(1, 10000000));\n        }\n        xi.assign(xi_set.begin(), xi_set.end());\n        sort(xi.begin(), xi.end());\n        // Generate heights yi\n        for (int i = 0; i < n; ++i) {\n            yi[i] = rnd.next(1LL, 100000000000LL);\n        }\n    }\n\n    // Output the hills\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %lld\\n\", xi[i], yi[i]);\n    }\n    \n    // Generate teams\n    vector<pair<int, int>> teams(m);\n\n    if (teams_type == \"same_hill\") {\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            teams[i] = make_pair(a, a);\n        }\n    } else if (teams_type == \"far_apart\") {\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n / 2);\n            int b = rnd.next(n / 2 + 1, n);\n            teams[i] = make_pair(a, b);\n        }\n    } else if (teams_type == \"adjacent\") {\n        // Teams on adjacent hills\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n - 1);\n            teams[i] = make_pair(a, a + 1);\n        }\n    } else if (teams_type == \"extreme\") {\n        // Climbers start at the leftmost and rightmost hills\n        for (int i = 0; i < m; ++i) {\n            teams[i] = make_pair(1, n);\n        }\n    } else {\n        // Random teams\n        for (int i = 0; i < m; ++i) {\n            int ai = rnd.next(1, n);\n            int bi = rnd.next(1, n);\n            teams[i] = make_pair(ai, bi);\n        }\n    }\n\n    // Output the teams\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", teams[i].first, teams[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and m with random hills and random teams\n./gen -n 1 -m 1 -type random -teams_type random\n./gen -n 2 -m 1 -type random -teams_type random\n./gen -n 10 -m 5 -type random -teams_type random\n\n# Hills with same heights\n./gen -n 10 -m 5 -type same_heights -teams_type random\n./gen -n 100 -m 50 -type same_heights -teams_type random\n./gen -n 1000 -m 500 -type same_heights -teams_type random\n\n# Hills with increasing heights\n./gen -n 10 -m 5 -type increasing_heights -teams_type random\n./gen -n 100 -m 50 -type increasing_heights -teams_type random\n./gen -n 1000 -m 500 -type increasing_heights -teams_type random\n\n# Hills with decreasing heights\n./gen -n 10 -m 5 -type decreasing_heights -teams_type random\n./gen -n 100 -m 50 -type decreasing_heights -teams_type random\n./gen -n 1000 -m 500 -type decreasing_heights -teams_type random\n\n# Hills with zigzag heights\n./gen -n 10 -m 5 -type zigzag_heights -teams_type random\n./gen -n 100 -m 50 -type zigzag_heights -teams_type random\n./gen -n 1000 -m 500 -type zigzag_heights -teams_type random\n\n# Hills with maximum heights\n./gen -n 1000 -m 500 -type max_heights -teams_type random\n# Hills with minimum heights\n./gen -n 1000 -m 500 -type min_heights -teams_type random\n\n# Large n and m with random hills and random teams\n./gen -n 100000 -m 100000 -type random -teams_type random\n\n# Large n and m with same heights\n./gen -n 100000 -m 100000 -type same_heights -teams_type random\n\n# Large n and m with increasing heights\n./gen -n 100000 -m 100000 -type increasing_heights -teams_type random\n\n# Large n and m with decreasing heights\n./gen -n 100000 -m 100000 -type decreasing_heights -teams_type random\n\n# Large n and m with zigzag heights\n./gen -n 100000 -m 100000 -type zigzag_heights -teams_type random\n\n# Teams start on the same hill\n./gen -n 10000 -m 5000 -type random -teams_type same_hill\n\n# Teams with climbers far apart\n./gen -n 10000 -m 5000 -type random -teams_type far_apart\n\n# Teams with climbers on adjacent hills\n./gen -n 10000 -m 5000 -type random -teams_type adjacent\n\n# Teams with climbers on leftmost and rightmost hills\n./gen -n 10000 -m 5000 -type random -teams_type extreme\n\n# Mixed types for variety\n./gen -n 100000 -m 100000 -type random -teams_type same_hill\n./gen -n 100000 -m 100000 -type max_heights -teams_type extreme\n./gen -n 100000 -m 100000 -type min_heights -teams_type far_apart\n\n# Edge case with minimal heights and climbers on the same hill\n./gen -n 2 -m 1 -type min_heights -teams_type same_hill\n\n# Edge case with maximum heights and climbers on extreme ends\n./gen -n 2 -m 1 -type max_heights -teams_type extreme\n\n# Random hills and random teams for medium n and m\n./gen -n 50000 -m 50000 -type random -teams_type random\n\n# Random hills and teams for maximum n and m\n./gen -n 100000 -m 100000 -type random -teams_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:27.315290",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "406/E",
      "title": "Problem 406/E",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1, 1000000000LL, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int si = inf.readInt(0, 1, \"s_i\");\n        inf.readSpace();\n        long long fi = inf.readLong(1, n, \"f_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1, 1000000000LL, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int si = inf.readInt(0, 1, \"s_i\");\n        inf.readSpace();\n        long long fi = inf.readLong(1, n, \"f_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long n = inf.readLong(1, 1000000000LL, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int si = inf.readInt(0, 1, \"s_i\");\n        inf.readSpace();\n        long long fi = inf.readLong(1, n, \"f_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(n >= 1 && n <= 1000000000LL);\n    ensure(m >= 3 && m <= 100000);\n\n    if (type == \"random\") {\n        printf(\"%lld %d\\n\", n, m);\n        for(int i = 0; i < m; ++i) {\n            int si = rnd.next(2); // 0 or 1\n            long long fi = rnd.next(1LL, n);\n            printf(\"%d %lld\\n\", si, fi);\n        }\n    }\n    else if (type == \"max_hamming\") {\n        printf(\"%lld %d\\n\", n, m);\n        int s1 = 0;\n        long long f1 = n;\n        int s2 = 1;\n        long long f2 = n;\n        int s3 = 0;\n        long long f3 = 1;\n        int num_each = m / 3;\n        int rem = m % 3;\n        for(int i = 0; i < num_each; ++i) {\n            printf(\"%d %lld\\n\", s1, f1);\n        }\n        for(int i = 0; i < num_each; ++i) {\n            printf(\"%d %lld\\n\", s2, f2);\n        }\n        for(int i = 0; i < num_each; ++i) {\n            printf(\"%d %lld\\n\", s3, f3);\n        }\n        for(int i = 0; i < rem; ++i) {\n            printf(\"%d %lld\\n\", s1, f1);\n        }\n    }\n    else if (type == \"min_hamming\") {\n        printf(\"%lld %d\\n\", n, m);\n        int si = rnd.next(2); // 0 or 1\n        long long fi = rnd.next(1LL, n);\n        for(int i = 0; i < m; ++i) {\n            printf(\"%d %lld\\n\", si, fi);\n        }\n    }\n    else if (type == \"duplicates\") {\n        printf(\"%lld %d\\n\", n, m);\n        int num_unique = rnd.next(1, min(1000, m));\n        vector<pair<int, long long>> strings;\n        for(int i = 0; i < num_unique; ++i) {\n            int si = rnd.next(2);\n            long long fi = rnd.next(1LL, n);\n            strings.push_back({si, fi});\n        }\n        for(int i = 0; i < m; ++i) {\n            auto s = strings[rnd.next(0, num_unique - 1)];\n            printf(\"%d %lld\\n\", s.first, s.second);\n        }\n    }\n    else if (type == \"two_groups\") {\n        printf(\"%lld %d\\n\", n, m);\n        int half = m / 2;\n        int rem = m % 2;\n        int s1 = 0;\n        long long f1 = n / 2;\n        int s2 = 1;\n        long long f2 = n / 2;\n        for(int i = 0; i < half; ++i) {\n            printf(\"%d %lld\\n\", s1, f1);\n        }\n        for(int i = 0; i < half; ++i) {\n            printf(\"%d %lld\\n\", s2, f2);\n        }\n        if (rem) {\n            printf(\"%d %lld\\n\", s1, f1);\n        }\n    }\n    else if (type == \"only_zero\") {\n        printf(\"%lld %d\\n\", n, m);\n        for(int i = 0; i < m; ++i) {\n            int si = 0;\n            long long fi = rnd.next(1LL, n);\n            printf(\"%d %lld\\n\", si, fi);\n        }\n    }\n    else if (type == \"only_one\") {\n        printf(\"%lld %d\\n\", n, m);\n        for(int i = 0; i < m; ++i) {\n            int si = 1;\n            long long fi = rnd.next(1LL, n);\n            printf(\"%d %lld\\n\", si, fi);\n        }\n    }\n    else if (type == \"max_fi\") {\n        printf(\"%lld %d\\n\", n, m);\n        for(int i = 0; i < m; ++i) {\n            int si = rnd.next(2);\n            long long fi = n;\n            printf(\"%d %lld\\n\", si, fi);\n        }\n    }\n    else if (type == \"min_fi\") {\n        printf(\"%lld %d\\n\", n, m);\n        for(int i = 0; i < m; ++i) {\n            int si = rnd.next(2);\n            long long fi = 1;\n            printf(\"%d %lld\\n\", si, fi);\n        }\n    }\n    else if (type == \"big_n_small_m\") {\n        n = 1000000000LL;\n        m = 3;\n        printf(\"%lld %d\\n\", n, m);\n        for(int i = 0; i < m; ++i) {\n            int si = rnd.next(2);\n            long long fi = rnd.next(1LL, n);\n            printf(\"%d %lld\\n\", si, fi);\n        }\n    }\n    else if (type == \"small_n_big_m\") {\n        n = 1;\n        printf(\"%lld %d\\n\", n, m);\n        for(int i = 0; i < m; ++i) {\n            int si = rnd.next(2);\n            long long fi = 1;\n            printf(\"%d %lld\\n\", si, fi);\n        }\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long n = opt<long long>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(n >= 1 && n <= 1000000000LL);\n    ensure(m >= 3 && m <= 100000);\n\n    if (type == \"random\") {\n        printf(\"%lld %d\\n\", n, m);\n        for(int i = 0; i < m; ++i) {\n            int si = rnd.next(2); // 0 or 1\n            long long fi = rnd.next(1LL, n);\n            printf(\"%d %lld\\n\", si, fi);\n        }\n    }\n    else if (type == \"max_hamming\") {\n        printf(\"%lld %d\\n\", n, m);\n        int s1 = 0;\n        long long f1 = n;\n        int s2 = 1;\n        long long f2 = n;\n        int s3 = 0;\n        long long f3 = 1;\n        int num_each = m / 3;\n        int rem = m % 3;\n        for(int i = 0; i < num_each; ++i) {\n            printf(\"%d %lld\\n\", s1, f1);\n        }\n        for(int i = 0; i < num_each; ++i) {\n            printf(\"%d %lld\\n\", s2, f2);\n        }\n        for(int i = 0; i < num_each; ++i) {\n            printf(\"%d %lld\\n\", s3, f3);\n        }\n        for(int i = 0; i < rem; ++i) {\n            printf(\"%d %lld\\n\", s1, f1);\n        }\n    }\n    else if (type == \"min_hamming\") {\n        printf(\"%lld %d\\n\", n, m);\n        int si = rnd.next(2); // 0 or 1\n        long long fi = rnd.next(1LL, n);\n        for(int i = 0; i < m; ++i) {\n            printf(\"%d %lld\\n\", si, fi);\n        }\n    }\n    else if (type == \"duplicates\") {\n        printf(\"%lld %d\\n\", n, m);\n        int num_unique = rnd.next(1, min(1000, m));\n        vector<pair<int, long long>> strings;\n        for(int i = 0; i < num_unique; ++i) {\n            int si = rnd.next(2);\n            long long fi = rnd.next(1LL, n);\n            strings.push_back({si, fi});\n        }\n        for(int i = 0; i < m; ++i) {\n            auto s = strings[rnd.next(0, num_unique - 1)];\n            printf(\"%d %lld\\n\", s.first, s.second);\n        }\n    }\n    else if (type == \"two_groups\") {\n        printf(\"%lld %d\\n\", n, m);\n        int half = m / 2;\n        int rem = m % 2;\n        int s1 = 0;\n        long long f1 = n / 2;\n        int s2 = 1;\n        long long f2 = n / 2;\n        for(int i = 0; i < half; ++i) {\n            printf(\"%d %lld\\n\", s1, f1);\n        }\n        for(int i = 0; i < half; ++i) {\n            printf(\"%d %lld\\n\", s2, f2);\n        }\n        if (rem) {\n            printf(\"%d %lld\\n\", s1, f1);\n        }\n    }\n    else if (type == \"only_zero\") {\n        printf(\"%lld %d\\n\", n, m);\n        for(int i = 0; i < m; ++i) {\n            int si = 0;\n            long long fi = rnd.next(1LL, n);\n            printf(\"%d %lld\\n\", si, fi);\n        }\n    }\n    else if (type == \"only_one\") {\n        printf(\"%lld %d\\n\", n, m);\n        for(int i = 0; i < m; ++i) {\n            int si = 1;\n            long long fi = rnd.next(1LL, n);\n            printf(\"%d %lld\\n\", si, fi);\n        }\n    }\n    else if (type == \"max_fi\") {\n        printf(\"%lld %d\\n\", n, m);\n        for(int i = 0; i < m; ++i) {\n            int si = rnd.next(2);\n            long long fi = n;\n            printf(\"%d %lld\\n\", si, fi);\n        }\n    }\n    else if (type == \"min_fi\") {\n        printf(\"%lld %d\\n\", n, m);\n        for(int i = 0; i < m; ++i) {\n            int si = rnd.next(2);\n            long long fi = 1;\n            printf(\"%d %lld\\n\", si, fi);\n        }\n    }\n    else if (type == \"big_n_small_m\") {\n        n = 1000000000LL;\n        m = 3;\n        printf(\"%lld %d\\n\", n, m);\n        for(int i = 0; i < m; ++i) {\n            int si = rnd.next(2);\n            long long fi = rnd.next(1LL, n);\n            printf(\"%d %lld\\n\", si, fi);\n        }\n    }\n    else if (type == \"small_n_big_m\") {\n        n = 1;\n        printf(\"%lld %d\\n\", n, m);\n        for(int i = 0; i < m; ++i) {\n            int si = rnd.next(2);\n            long long fi = 1;\n            printf(\"%d %lld\\n\", si, fi);\n        }\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 3 -type random\n./gen -n 10 -m 3 -type random\n./gen -n 1000 -m 3 -type random\n\n./gen -n 1000000000 -m 3 -type big_n_small_m\n./gen -n 1 -m 100000 -type small_n_big_m\n\n./gen -n 1000000000 -m 100000 -type random\n./gen -n 1000000000 -m 100000 -type max_hamming\n./gen -n 1000000000 -m 100000 -type min_hamming\n./gen -n 1000000000 -m 100000 -type duplicates\n./gen -n 1000000000 -m 100000 -type two_groups\n\n./gen -n 1000000000 -m 100000 -type max_fi\n./gen -n 1000000000 -m 100000 -type min_fi\n\n./gen -n 1000000 -m 100000 -type only_zero\n./gen -n 1000000 -m 100000 -type only_one\n\n./gen -n 1000000000 -m 50000 -type two_groups\n\n./gen -n 1000000000 -m 100000 -type random\n\n./gen -n 1000 -m 3 -type max_hamming\n\n./gen -n 1000 -m 3 -type min_hamming\n\n./gen -n 1000000 -m 100000 -type duplicates\n\n./gen -n 1 -m 3 -type max_fi\n\n./gen -n 1000000 -m 100000 -type min_fi\n\n./gen -n 1000000000 -m 3 -type only_zero\n\n./gen -n 1000000000 -m 3 -type only_one\n\n./gen -n 1000000000 -m 3 -type duplicates\n\n./gen -n 10 -m 100 -type random\n\n./gen -n 1000000000 -m 99999 -type max_hamming\n\n./gen -n 999999999 -m 99999 -type two_groups\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:29.427428",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "407/A",
      "title": "A. Triangle",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers a, b (1 ≤ a, b ≤ 1000), separated by a single space.",
      "output_spec": "OutputIn the first line print either \"YES\" or \"NO\" (without the quotes) depending on whether the required location exists. If it does, print in the next three lines three pairs of integers — the coordinates of the triangle vertices, one pair per line. The coordinates must be integers, not exceeding 109 in their absolute value.",
      "sample_tests": "ExamplesInputCopy1 1OutputCopyNOInputCopy5 5OutputCopyYES2 15 5-2 4InputCopy5 10OutputCopyYES-10 4-2 -21 2",
      "description": "A. Triangle\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers a, b (1 ≤ a, b ≤ 1000), separated by a single space.\n\nOutputIn the first line print either \"YES\" or \"NO\" (without the quotes) depending on whether the required location exists. If it does, print in the next three lines three pairs of integers — the coordinates of the triangle vertices, one pair per line. The coordinates must be integers, not exceeding 109 in their absolute value.\n\nInputCopy1 1OutputCopyNOInputCopy5 5OutputCopyYES2 15 5-2 4InputCopy5 10OutputCopyYES-10 4-2 -21 2\n\nInputCopy1 1\n\nOutputCopyNO\n\nInputCopy5 5\n\nOutputCopyYES2 15 5-2 4\n\nInputCopy5 10\n\nOutputCopyYES-10 4-2 -21 2",
      "solutions": [
        {
          "title": "Codeforces Round #239 - Codeforces",
          "content": "Hello everyone!This Sunday, on March 30 at 11:00 MSK (March 30 at 07:00 UTC), Codeforces Round #239 for both divisions participants will take place. Note the unusual time of the round.The problems have been prepared by me. I want to thank Codeforces team: tasks coordinator Gerald Agapov (Gerald) for invaluable contribution to the preparation of tasks and Maria Belova (Delinur), who has translated the problems. Also thank to Niyaz Nigmatullin (niyaznigmatul) for testing.I wish you all good luck and have a good weekend!UPD: You can see score distribution at the problems page.UPD2: You can find editorial here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11309",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 614
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces",
          "content": "Sorry for my poor English. If you find a mistake, write me a private message, I'll fix it. Some problems have not been translated yet, now you can try to read the Russian version of editorial with Google Translate.408A - Line to CashierIn this problem you were to find waiting the time for every queue by summing up the purchases of all the people, and return the minimum.408B - GarlandIn this problem it is necessary to find the garland with the maximal length, which can be composed of elements that we have. First, if you need some color, but you don't have it, then the answer is -1 Otherwise, answer is always exists. Let's sum the answers for all the colors separately. Suppose we have a pieces of a garland of some color, and we need b pieces. Then we have to add min(a, b) to the answer: if a >  = b we will use b 1 meter pieces, in the other case if a < b we will use all a pieces.407A - TriangleIn this problem you have to locate the right triangle with cathetuses a, b on a plane with its vertices in integer points. If the required layout exists, then cathetus a always can be represented as a vector with integer coordinates A{x;y}, and a2 = x2 + y2. Iterate over all possible x (1 ≤ x ≤ a - 1), check, that y = sqrt(a2 - x2) is integer. Vector, ortogonal to vector {x;y}, is { - y;x}. Take vector B{ - y / g;x / g}, where g = gcd(x, y). The triangle can be located on the plane if and only if b % |B| = 0, where |B| — length of vector B. The candidate for the answer — triangle (0;0)(x;y)( - y / g * b / |B|;x / g * b / |B|), but don't forget about checking that the hypotenuse isn't parallel to coordinate axes.407B - Long PathIn this problem you had to simulate route of character in graph. Note that if you are in vertice i, then edges in all vertices with numbers less than i are turned to pi. It gives us opportunity to see a recurrence formula: let dpi be number of steps, needed to get from vertice 1 to vertice i, if all edges are rotated back, into pi. Then dpi + 1 = 2dpi + 2 - dppi. Answer will be dpn + 1.BONUS: Can you solve this task without statement pi ≤ i? I don't know the solution, it seems difficult.407C - Curious ArrayIn this problem you had to find how to add binomial coefficients in array offline. Let's see, how problem changes due to increasing k from small to big values.1) All queries have K = 0 Every time you add 1 on subsegment. For solve this task you can add 1 at some array b[] in b[L] 1, then substract 1 from b[R+1], and after doing all queries make array a[] as array of prefix sums of array b[].2) All queries have K = 1 Arithmetic progression 1 2 3 4 ... is added on subsegment For solve this task you can add 1 at some array c[] in c[L] 1, then substract 1 from c[R+1], and after doing all queries make array b[] as array of prefix sums of array c[]. Actually you added 1 1 ... 1 on every subsegment at each query. If you will substract (R — L + 1) from c[R+1], and make array a[] as array of prefix sums of array b[], then it will be an answer: 1 1 ... 1 became 1 2 3 ... (R-L+1).3) K is arbitrary Summaring previous results one can see that if we will do a[K+1][L] += 1 a[j][R+1] -= C(k + 1 — j + r — l, k + 1 — j) for all 1 <= j <= K + 1 and after that do a[i][j] = a[i][j-1] + a[i+1][j] (making a[i] as array of prefix sums array a[i+1]), a[0] will be the answer. What is C(k + 1 — j + r — l, k + 1 — j)? This number is need for each query affect only on segment L..R, and you can see, why is it so, in Pascal's Triangle.If this explanation is not clear for you, you can try to see other participants solutions (for example, Xellos's one).407D - Largest Submatrix 3In this task you have to find largest by area submatrix, consisting from different numbers. Let's see solutions from slow to fast.1) Solution by O(n6): Iterate through two opposite vertices submatrix-answer and check that all numbers are different.2) Solution by O(n4): Let's fix Up and Down borders submatrix-answer (O(n2)). Use two pointers method to iterate Left and Right borders: while in submatrix there are no equal numbers, increment Right, while there are equal numbers — increment Left. Every check — (O(n)), increments — (O(n)).3) Solution by O(n3logn): Let's construct function maxR(Left) (let's consider that Up <= Down are fixed): maximal value Right, so that in submatrix (Up, Down, Left, Right) there is no equals numbers. You can see that maxR(i) <= maxR(i + 1) is true for every i. How values of this function changes by shift Down to Down-1? Every value maxR(Left) can only be the same (if segment(Down, Down, Left, maxR(Left)) only added new numbers), or it can decrease. When maxR(Left) is decreasing? Only when one of the numbers from added segment have already been in the current submatrix. Shift Down to down let's see all numbers in row Down. For each number (let it be in column j) find indices i and k so i <= j, there is number, equal to a[Down][j] between rows Up and Down-1, i — maximal; k >= j, there is number, equal to a[Down][j] between rows Up and Down-1, k — minimal. When you find these indices (it is easy to find them using set, when you store all columns where number x was between Up and Down for all numbers x), you can try to update maxR[i] with j — 1, maxR[j] with k — 1. It will be enough, if you also update for all i = m..1 maxR[i] = min(maxR[i], maxR[i + 1]). Now maxR(Left) is correct, and you can check answer for these Up and Down by O(n).4) Now, solution by O(n3). It requires understanding previous solution. Previous solution, despite good asymptotics, requires to store a lot (about 160 000) sets, where you will store about 160 000 elements. Even at n = 200 it works very slow. Let's get rid of log. Set is using only for finding nearest left and right elements, which are in rows from Up to Down, and equal to current. Note that when you do Up = Up — 1, nearest element comes near (by column) to a[i][j], so we can find all numbers, for which the nearest element will be in new row Up, and update them nearest number, and do that in O(n2). This solution uses O(n2) memory and O(n3) time.BONUS: Can you solve this task faster than O(n3)? I spend a lot of time and I didn't come to any solution, but I can't show that there is not solution faster.407E - k-d-sequenceIn this problem you have to find longest subsegment, satisfying the condition.Reduce problem to d = 1.If d = 0, then answer is longest subsegment from equal numbers, this case we solve separately. If d ≠ 0, then notice that if on some subsegment there are two numbers ai, aj so that ai%d ≠ aj%d, then this segment can't be good. Divide the sequence to consequent subsegments numbers, equal by modulo d, and divide each number by d, and solve task separately with every segment, consider that d = 1. Notice that segment [L, R] is good if and only if when max(L, R) — min(L, R) — (R — L) <= k, and there are no equal numbers. It is easy to exlain: if there are no equal numbers, then max(L, R) — min(L, R) — (R — L) is exactly number of numbers is needed to add for segment to consist of all numbers from min(L, R) to max(L, R). For all L lets find such maxR[L], that on segment [L..maxR[l]] there are no equal numbers, and maxR[L] is maximal. It can be done by O(nlogn) by many ways, for example you can use map. Let's learn how we can maintain array a[R] = max(L, R) — min(L, R) — (R — L). If we have such array, then we have to find rightmost R such that a[R] <= k to get an answer. We will need two stacks and segment tree with operations \"Add number on segment\", \"Find min element on segment\", \"Find rightmost number doesn't exceed k\". Let's iterate L from right to left (n downto 1). How does function max(L, R) look like with fixed L? It's values represent a set of segments so that maximum on the segment is leftmost element of segment, and these maximums are increasing. (example: for array 6 4 8 0 7 9 function max(1, R) will be 6 6 8 8 8 9). How function changes with shift L to left? Some segments are absorbed by new element, if new element is bigger than maximum on segment. Maximums on segments are increasing, so we can keep them all in stack, and when we need to add new element we have to only pop some segments from stacks while maximum on top of stack is less then new element, and push new segment after that. If every operation with stack will be accompanied with right operation with segment tree, we can store array a[R] = max(L, R). For get array a[R] = max(L, R) — min(L, R) we need only to maintain second similar stack. For get array a[R] = max(L, R) — min(L, R) we need add -1 on all suffix when we are shitfing L. Now query \"Find fightmost number less of equal k\". First, segment tree divides segment of request to log(n) segments with length powers of two. Let's choose rightmost segment with minimum <= k, and do iterative deeping there to find element that we need.So, for every L we get query on segment L..maxR(L) on rightmost number less or equal k. It is one of candidates to an answer. We are doing O(n) operation with stack, and every requires query to segment tree, so asymptotics is O(nlogn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11333",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 407\\s*A"
          },
          "content_length": 9077
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #239 - Codeforces - Code 1",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 2",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 3",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 4",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 5",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 6",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 7",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 8",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 1",
          "code": "dp[i] = 1 + (dp[p[i]]+1) + (dp[p[i]+1]+1) + ... + (dp[i-1]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 2",
          "code": "(dp[1]+1) + (dp[2]+1) + (dp[3]+1) + ... + (dp[n]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 3",
          "code": "s[p[k]]+s[p[k]+1]+s[p[k]+2]+...+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 4",
          "code": "s[k]=2+s[p[k]]+s[p[k]+1]+s[p[k]+2]+..+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 5",
          "code": "answer=s[1]+s[2]+..+s[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 6",
          "code": "dp[i] = the number of steps needed to move from room i to room (i + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 7",
          "code": "dp[i] = 2 + sum(dp[j]) for j in [p[i], i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 8",
          "code": "sum(dp[i]) for (1 ≤ i ≤ n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(1, 1000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int a = inf.readInt();\n    int b = inf.readInt();\n\n    string jury_ans = ans.readToken();\n    string part_ans = ouf.readToken();\n\n    if (part_ans != \"YES\" && part_ans != \"NO\")\n        quitf(_wa, \"First line of output must be 'YES' or 'NO'\");\n\n    if (jury_ans == \"NO\") {\n        if (part_ans != \"NO\")\n            quitf(_wa, \"Expected 'NO', but participant outputted 'YES'\");\n        else\n            quitf(_ok, \"Correct 'NO' answer\");\n    } else {\n        if (part_ans != \"YES\")\n            quitf(_wa, \"Expected 'YES', but participant outputted 'NO'\");\n        else {\n            vector<pair<long long, long long>> pts(3);\n            for (int i = 0; i < 3; ++i) {\n                long long x = ouf.readLong(-1000000000LL, 1000000000LL, format(\"x%d\", i+1).c_str());\n                long long y = ouf.readLong(-1000000000LL, 1000000000LL, format(\"y%d\", i+1).c_str());\n                pts[i] = make_pair(x, y);\n            }\n\n            // Check that none of the sides is parallel to coordinate axes\n            for (int i = 0; i < 3; ++i) {\n                int j = (i + 1) % 3;\n                if (pts[i].first == pts[j].first)\n                    quitf(_wa, \"Side %d is parallel to y-axis\", i + 1);\n                if (pts[i].second == pts[j].second)\n                    quitf(_wa, \"Side %d is parallel to x-axis\", i + 1);\n            }\n\n            // Compute squared distances between pairs\n            vector<long long> D(3);\n            D[0] = (pts[0].first - pts[1].first) * (pts[0].first - pts[1].first) +\n                   (pts[0].second - pts[1].second) * (pts[0].second - pts[1].second);\n            D[1] = (pts[0].first - pts[2].first) * (pts[0].first - pts[2].first) +\n                   (pts[0].second - pts[2].second) * (pts[0].second - pts[2].second);\n            D[2] = (pts[1].first - pts[2].first) * (pts[1].first - pts[2].first) +\n                   (pts[1].second - pts[2].second) * (pts[1].second - pts[2].second);\n\n            sort(D.begin(), D.end());\n\n            if (D[0] + D[1] != D[2])\n                quitf(_wa, \"The triangle is not right-angled\");\n\n            long long sq_a = 1LL * a * a;\n            long long sq_b = 1LL * b * b;\n\n            if ((D[0] == sq_a && D[1] == sq_b) || (D[0] == sq_b && D[1] == sq_a))\n                quitf(_ok, \"Correct triangle with legs of lengths %d and %d\", a, b);\n            else\n                quitf(_wa, \"The legs lengths are incorrect\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    string type = opt<string>(\"type\", \"\");\n\n    if (a == -1 || b == -1) {\n        if (type == \"min\") {\n            a = 1;\n            b = 1;\n        } else if (type == \"max\") {\n            a = 1000;\n            b = 1000;\n        } else if (type == \"equal\") {\n            a = b = rnd.next(1, 1000);\n        } else if (type == \"one_small\") {\n            a = 1;\n            b = rnd.next(1, 1000);\n        } else if (type == \"one_large\") {\n            a = 1000;\n            b = rnd.next(1, 1000);\n        } else if (type == \"impossible\") {\n            // Known impossible case\n            a = 1;\n            b = 1;\n        } else if (type == \"random\") {\n            a = rnd.next(1, 1000);\n            b = rnd.next(1, 1000);\n        } else {\n            // default to random if no type matches\n            a = rnd.next(1, 1000);\n            b = rnd.next(1, 1000);\n        }\n    }\n\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    string type = opt<string>(\"type\", \"\");\n\n    if (a == -1 || b == -1) {\n        if (type == \"min\") {\n            a = 1;\n            b = 1;\n        } else if (type == \"max\") {\n            a = 1000;\n            b = 1000;\n        } else if (type == \"equal\") {\n            a = b = rnd.next(1, 1000);\n        } else if (type == \"one_small\") {\n            a = 1;\n            b = rnd.next(1, 1000);\n        } else if (type == \"one_large\") {\n            a = 1000;\n            b = rnd.next(1, 1000);\n        } else if (type == \"impossible\") {\n            // Known impossible case\n            a = 1;\n            b = 1;\n        } else if (type == \"random\") {\n            a = rnd.next(1, 1000);\n            b = rnd.next(1, 1000);\n        } else {\n            // default to random if no type matches\n            a = rnd.next(1, 1000);\n            b = rnd.next(1, 1000);\n        }\n    }\n\n    printf(\"%d %d\\n\", a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type random\n./gen -type equal\n./gen -type one_small\n./gen -type one_large\n./gen -type impossible\n\n./gen -a 1 -b 1\n./gen -a 2 -b 2\n./gen -a 3 -b 3\n\n./gen -a 1 -b 2\n./gen -a 2 -b 1\n\n./gen -a 1 -b 1000\n./gen -a 1000 -b 1\n./gen -a 1000 -b 999\n./gen -a 999 -b 1000\n\n./gen -a 500 -b 500\n./gen -a 1000 -b 1000\n./gen -a 1000 -b 500\n./gen -a 500 -b 1000\n\n./gen -a 10 -b 10\n./gen -a 15 -b 20\n./gen -a 100 -b 200\n./gen -a 30 -b 40\n\n./gen -a 999 -b 999\n./gen -a 1000 -b 2\n./gen -a 2 -b 1000\n./gen -a 512 -b 256\n./gen -a 256 -b 512\n./gen -a 50 -b 50\n./gen -a 250 -b 750\n./gen -a 750 -b 250\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:31.526125",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "407/B",
      "title": "B. Long Path",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 103) — the number of rooms. The second line contains n integers pi (1 ≤ pi ≤ i). Each pi denotes the number of the room, that someone can reach, if he will use the second portal in the i-th room.",
      "output_spec": "OutputPrint a single number — the number of portal moves the boy needs to go out of the maze. As the number can be rather large, print it modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy21 2OutputCopy4InputCopy41 1 2 3OutputCopy20InputCopy51 1 1 1 1OutputCopy62",
      "description": "B. Long Path\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 103) — the number of rooms. The second line contains n integers pi (1 ≤ pi ≤ i). Each pi denotes the number of the room, that someone can reach, if he will use the second portal in the i-th room.\n\nOutputPrint a single number — the number of portal moves the boy needs to go out of the maze. As the number can be rather large, print it modulo 1000000007 (109 + 7).\n\nInputCopy21 2OutputCopy4InputCopy41 1 2 3OutputCopy20InputCopy51 1 1 1 1OutputCopy62\n\nInputCopy21 2\n\nOutputCopy4\n\nInputCopy41 1 2 3\n\nOutputCopy20\n\nInputCopy51 1 1 1 1\n\nOutputCopy62",
      "solutions": [
        {
          "title": "Codeforces Round #239 - Codeforces",
          "content": "Hello everyone!This Sunday, on March 30 at 11:00 MSK (March 30 at 07:00 UTC), Codeforces Round #239 for both divisions participants will take place. Note the unusual time of the round.The problems have been prepared by me. I want to thank Codeforces team: tasks coordinator Gerald Agapov (Gerald) for invaluable contribution to the preparation of tasks and Maria Belova (Delinur), who has translated the problems. Also thank to Niyaz Nigmatullin (niyaznigmatul) for testing.I wish you all good luck and have a good weekend!UPD: You can see score distribution at the problems page.UPD2: You can find editorial here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11309",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 614
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces",
          "content": "Sorry for my poor English. If you find a mistake, write me a private message, I'll fix it. Some problems have not been translated yet, now you can try to read the Russian version of editorial with Google Translate.408A - Line to CashierIn this problem you were to find waiting the time for every queue by summing up the purchases of all the people, and return the minimum.408B - GarlandIn this problem it is necessary to find the garland with the maximal length, which can be composed of elements that we have. First, if you need some color, but you don't have it, then the answer is -1 Otherwise, answer is always exists. Let's sum the answers for all the colors separately. Suppose we have a pieces of a garland of some color, and we need b pieces. Then we have to add min(a, b) to the answer: if a >  = b we will use b 1 meter pieces, in the other case if a < b we will use all a pieces.407A - TriangleIn this problem you have to locate the right triangle with cathetuses a, b on a plane with its vertices in integer points. If the required layout exists, then cathetus a always can be represented as a vector with integer coordinates A{x;y}, and a2 = x2 + y2. Iterate over all possible x (1 ≤ x ≤ a - 1), check, that y = sqrt(a2 - x2) is integer. Vector, ortogonal to vector {x;y}, is { - y;x}. Take vector B{ - y / g;x / g}, where g = gcd(x, y). The triangle can be located on the plane if and only if b % |B| = 0, where |B| — length of vector B. The candidate for the answer — triangle (0;0)(x;y)( - y / g * b / |B|;x / g * b / |B|), but don't forget about checking that the hypotenuse isn't parallel to coordinate axes.407B - Long PathIn this problem you had to simulate route of character in graph. Note that if you are in vertice i, then edges in all vertices with numbers less than i are turned to pi. It gives us opportunity to see a recurrence formula: let dpi be number of steps, needed to get from vertice 1 to vertice i, if all edges are rotated back, into pi. Then dpi + 1 = 2dpi + 2 - dppi. Answer will be dpn + 1.BONUS: Can you solve this task without statement pi ≤ i? I don't know the solution, it seems difficult.407C - Curious ArrayIn this problem you had to find how to add binomial coefficients in array offline. Let's see, how problem changes due to increasing k from small to big values.1) All queries have K = 0 Every time you add 1 on subsegment. For solve this task you can add 1 at some array b[] in b[L] 1, then substract 1 from b[R+1], and after doing all queries make array a[] as array of prefix sums of array b[].2) All queries have K = 1 Arithmetic progression 1 2 3 4 ... is added on subsegment For solve this task you can add 1 at some array c[] in c[L] 1, then substract 1 from c[R+1], and after doing all queries make array b[] as array of prefix sums of array c[]. Actually you added 1 1 ... 1 on every subsegment at each query. If you will substract (R — L + 1) from c[R+1], and make array a[] as array of prefix sums of array b[], then it will be an answer: 1 1 ... 1 became 1 2 3 ... (R-L+1).3) K is arbitrary Summaring previous results one can see that if we will do a[K+1][L] += 1 a[j][R+1] -= C(k + 1 — j + r — l, k + 1 — j) for all 1 <= j <= K + 1 and after that do a[i][j] = a[i][j-1] + a[i+1][j] (making a[i] as array of prefix sums array a[i+1]), a[0] will be the answer. What is C(k + 1 — j + r — l, k + 1 — j)? This number is need for each query affect only on segment L..R, and you can see, why is it so, in Pascal's Triangle.If this explanation is not clear for you, you can try to see other participants solutions (for example, Xellos's one).407D - Largest Submatrix 3In this task you have to find largest by area submatrix, consisting from different numbers. Let's see solutions from slow to fast.1) Solution by O(n6): Iterate through two opposite vertices submatrix-answer and check that all numbers are different.2) Solution by O(n4): Let's fix Up and Down borders submatrix-answer (O(n2)). Use two pointers method to iterate Left and Right borders: while in submatrix there are no equal numbers, increment Right, while there are equal numbers — increment Left. Every check — (O(n)), increments — (O(n)).3) Solution by O(n3logn): Let's construct function maxR(Left) (let's consider that Up <= Down are fixed): maximal value Right, so that in submatrix (Up, Down, Left, Right) there is no equals numbers. You can see that maxR(i) <= maxR(i + 1) is true for every i. How values of this function changes by shift Down to Down-1? Every value maxR(Left) can only be the same (if segment(Down, Down, Left, maxR(Left)) only added new numbers), or it can decrease. When maxR(Left) is decreasing? Only when one of the numbers from added segment have already been in the current submatrix. Shift Down to down let's see all numbers in row Down. For each number (let it be in column j) find indices i and k so i <= j, there is number, equal to a[Down][j] between rows Up and Down-1, i — maximal; k >= j, there is number, equal to a[Down][j] between rows Up and Down-1, k — minimal. When you find these indices (it is easy to find them using set, when you store all columns where number x was between Up and Down for all numbers x), you can try to update maxR[i] with j — 1, maxR[j] with k — 1. It will be enough, if you also update for all i = m..1 maxR[i] = min(maxR[i], maxR[i + 1]). Now maxR(Left) is correct, and you can check answer for these Up and Down by O(n).4) Now, solution by O(n3). It requires understanding previous solution. Previous solution, despite good asymptotics, requires to store a lot (about 160 000) sets, where you will store about 160 000 elements. Even at n = 200 it works very slow. Let's get rid of log. Set is using only for finding nearest left and right elements, which are in rows from Up to Down, and equal to current. Note that when you do Up = Up — 1, nearest element comes near (by column) to a[i][j], so we can find all numbers, for which the nearest element will be in new row Up, and update them nearest number, and do that in O(n2). This solution uses O(n2) memory and O(n3) time.BONUS: Can you solve this task faster than O(n3)? I spend a lot of time and I didn't come to any solution, but I can't show that there is not solution faster.407E - k-d-sequenceIn this problem you have to find longest subsegment, satisfying the condition.Reduce problem to d = 1.If d = 0, then answer is longest subsegment from equal numbers, this case we solve separately. If d ≠ 0, then notice that if on some subsegment there are two numbers ai, aj so that ai%d ≠ aj%d, then this segment can't be good. Divide the sequence to consequent subsegments numbers, equal by modulo d, and divide each number by d, and solve task separately with every segment, consider that d = 1. Notice that segment [L, R] is good if and only if when max(L, R) — min(L, R) — (R — L) <= k, and there are no equal numbers. It is easy to exlain: if there are no equal numbers, then max(L, R) — min(L, R) — (R — L) is exactly number of numbers is needed to add for segment to consist of all numbers from min(L, R) to max(L, R). For all L lets find such maxR[L], that on segment [L..maxR[l]] there are no equal numbers, and maxR[L] is maximal. It can be done by O(nlogn) by many ways, for example you can use map. Let's learn how we can maintain array a[R] = max(L, R) — min(L, R) — (R — L). If we have such array, then we have to find rightmost R such that a[R] <= k to get an answer. We will need two stacks and segment tree with operations \"Add number on segment\", \"Find min element on segment\", \"Find rightmost number doesn't exceed k\". Let's iterate L from right to left (n downto 1). How does function max(L, R) look like with fixed L? It's values represent a set of segments so that maximum on the segment is leftmost element of segment, and these maximums are increasing. (example: for array 6 4 8 0 7 9 function max(1, R) will be 6 6 8 8 8 9). How function changes with shift L to left? Some segments are absorbed by new element, if new element is bigger than maximum on segment. Maximums on segments are increasing, so we can keep them all in stack, and when we need to add new element we have to only pop some segments from stacks while maximum on top of stack is less then new element, and push new segment after that. If every operation with stack will be accompanied with right operation with segment tree, we can store array a[R] = max(L, R). For get array a[R] = max(L, R) — min(L, R) we need only to maintain second similar stack. For get array a[R] = max(L, R) — min(L, R) we need add -1 on all suffix when we are shitfing L. Now query \"Find fightmost number less of equal k\". First, segment tree divides segment of request to log(n) segments with length powers of two. Let's choose rightmost segment with minimum <= k, and do iterative deeping there to find element that we need.So, for every L we get query on segment L..maxR(L) on rightmost number less or equal k. It is one of candidates to an answer. We are doing O(n) operation with stack, and every requires query to segment tree, so asymptotics is O(nlogn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11333",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 407\\s*B"
          },
          "content_length": 9077
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #239 - Codeforces - Code 1",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 2",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 3",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 4",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 5",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 6",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 7",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 8",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 1",
          "code": "dp[i] = 1 + (dp[p[i]]+1) + (dp[p[i]+1]+1) + ... + (dp[i-1]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 2",
          "code": "(dp[1]+1) + (dp[2]+1) + (dp[3]+1) + ... + (dp[n]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 3",
          "code": "s[p[k]]+s[p[k]+1]+s[p[k]+2]+...+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 4",
          "code": "s[k]=2+s[p[k]]+s[p[k]+1]+s[p[k]+2]+..+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 5",
          "code": "answer=s[1]+s[2]+..+s[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 6",
          "code": "dp[i] = the number of steps needed to move from room i to room (i + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 7",
          "code": "dp[i] = 2 + sum(dp[j]) for j in [p[i], i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 8",
          "code": "sum(dp[i]) for (1 ≤ i ≤ n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAX_N = 1000;\n\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        int p_i;\n        if (i < n) {\n            p_i = inf.readInt(1, i, \"p_\" + vtos(i));\n            inf.readSpace();\n        } else {\n            p_i = inf.readInt(1, i, \"p_\" + vtos(i));\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAX_N = 1000;\n\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        int p_i;\n        if (i < n) {\n            p_i = inf.readInt(1, i, \"p_\" + vtos(i));\n            inf.readSpace();\n        } else {\n            p_i = inf.readInt(1, i, \"p_\" + vtos(i));\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAX_N = 1000;\n\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        int p_i;\n        if (i < n) {\n            p_i = inf.readInt(1, i, \"p_\" + vtos(i));\n            inf.readSpace();\n        } else {\n            p_i = inf.readInt(1, i, \"p_\" + vtos(i));\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    cout << n << endl;\n\n    vector<int> pi(n + 1);\n    if (type == \"all_one\") {\n        for(int i = 1; i <= n; ++i)\n            pi[i] = 1;\n    } else if (type == \"pi_eq_i\") {\n        for(int i = 1; i <= n; ++i)\n            pi[i] = i;\n    } else if (type == \"pi_eq_i_minus_1\") {\n        pi[1] = 1;\n        for(int i = 2; i <= n; ++i)\n            pi[i] = i - 1;\n    } else if (type == \"random\") {\n        for(int i = 1; i <= n; ++i)\n            pi[i] = rnd.next(i) + 1; // Random integer in [1, i]\n    } else if (type == \"random_high\") {\n        for(int i = 1; i <= n; ++i)\n            pi[i] = rnd.wnext(i, 5) + 1; // Skewed towards i\n    } else if (type == \"random_low\") {\n        for(int i = 1; i <= n; ++i)\n            pi[i] = rnd.wnext(i, -5) + 1; // Skewed towards 1\n    } else if (type == \"harmonic\") {\n        for(int i = 1; i <= n; ++i)\n            pi[i] = max(1, i / 2);\n    } else if (type == \"zigzag\") {\n        for(int i = 1; i <= n; ++i)\n            pi[i] = (i % 2 == 0) ? 1 : i;\n    } else {\n        // Default to random\n        for(int i = 1; i <= n; ++i)\n            pi[i] = rnd.next(i) + 1;\n    }\n\n    // Output pi[1..n]\n    for(int i = 1; i <= n; ++i) {\n        cout << pi[i];\n        if (i < n) cout << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    cout << n << endl;\n\n    vector<int> pi(n + 1);\n    if (type == \"all_one\") {\n        for(int i = 1; i <= n; ++i)\n            pi[i] = 1;\n    } else if (type == \"pi_eq_i\") {\n        for(int i = 1; i <= n; ++i)\n            pi[i] = i;\n    } else if (type == \"pi_eq_i_minus_1\") {\n        pi[1] = 1;\n        for(int i = 2; i <= n; ++i)\n            pi[i] = i - 1;\n    } else if (type == \"random\") {\n        for(int i = 1; i <= n; ++i)\n            pi[i] = rnd.next(i) + 1; // Random integer in [1, i]\n    } else if (type == \"random_high\") {\n        for(int i = 1; i <= n; ++i)\n            pi[i] = rnd.wnext(i, 5) + 1; // Skewed towards i\n    } else if (type == \"random_low\") {\n        for(int i = 1; i <= n; ++i)\n            pi[i] = rnd.wnext(i, -5) + 1; // Skewed towards 1\n    } else if (type == \"harmonic\") {\n        for(int i = 1; i <= n; ++i)\n            pi[i] = max(1, i / 2);\n    } else if (type == \"zigzag\") {\n        for(int i = 1; i <= n; ++i)\n            pi[i] = (i % 2 == 0) ? 1 : i;\n    } else {\n        // Default to random\n        for(int i = 1; i <= n; ++i)\n            pi[i] = rnd.next(i) + 1;\n    }\n\n    // Output pi[1..n]\n    for(int i = 1; i <= n; ++i) {\n        cout << pi[i];\n        if (i < n) cout << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_one\n./gen -n 1 -type pi_eq_i\n./gen -n 2 -type all_one\n./gen -n 2 -type pi_eq_i\n./gen -n 2 -type pi_eq_i_minus_1\n./gen -n 2 -type random\n\n./gen -n 5 -type all_one\n./gen -n 5 -type pi_eq_i_minus_1\n./gen -n 5 -type random_high\n./gen -n 5 -type random_low\n\n./gen -n 10 -type random\n./gen -n 10 -type random_low\n./gen -n 10 -type random_high\n./gen -n 10 -type zigzag\n\n./gen -n 50 -type random\n\n./gen -n 100 -type all_one\n./gen -n 100 -type pi_eq_i\n./gen -n 100 -type pi_eq_i_minus_1\n./gen -n 100 -type random\n./gen -n 100 -type random_low\n./gen -n 100 -type random_high\n./gen -n 100 -type harmonic\n./gen -n 100 -type zigzag\n\n./gen -n 500 -type random\n./gen -n 500 -type random_low\n\n./gen -n 1000 -type all_one\n./gen -n 1000 -type pi_eq_i\n./gen -n 1000 -type pi_eq_i_minus_1\n./gen -n 1000 -type random\n./gen -n 1000 -type random_low\n./gen -n 1000 -type random_high\n./gen -n 1000 -type harmonic\n./gen -n 1000 -type zigzag\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:33.196205",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "407/C",
      "title": "C. Занимательный массив",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке заданы целые числа n, m (1 ≤ n, m ≤ 105). Во второй строке задано n целых чисел a[1], a[2], ..., a[n] (0 ≤ ai ≤ 109) — изначальное состояние массива.В следующих m строках заданы запросы в формате li, ri, ki — прибавить всем элементам отрезка li... ri число Ckij - li + ki (1 ≤ li ≤ ri ≤ n; 0 ≤ k ≤ 100).",
      "output_spec": "Выходные данныеВыведите n целых чисел: i-е число — это значение элемента a[i] после всех запросов. Так как значения могут быть достаточно большими выводите их по модулю 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать5 10 0 0 0 01 5 0Выходные данныеСкопировать1 1 1 1 1Входные данныеСкопировать10 21 2 3 4 5 0 0 0 0 01 6 16 10 2Выходные данныеСкопировать2 4 6 8 10 7 3 6 10 15",
      "description": "C. Занимательный массив\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке заданы целые числа n, m (1 ≤ n, m ≤ 105). Во второй строке задано n целых чисел a[1], a[2], ..., a[n] (0 ≤ ai ≤ 109) — изначальное состояние массива.В следующих m строках заданы запросы в формате li, ri, ki — прибавить всем элементам отрезка li... ri число Ckij - li + ki (1 ≤ li ≤ ri ≤ n; 0 ≤ k ≤ 100).\n\nВходные данные\n\nВыходные данныеВыведите n целых чисел: i-е число — это значение элемента a[i] после всех запросов. Так как значения могут быть достаточно большими выводите их по модулю 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать5 10 0 0 0 01 5 0Выходные данныеСкопировать1 1 1 1 1Входные данныеСкопировать10 21 2 3 4 5 0 0 0 0 01 6 16 10 2Выходные данныеСкопировать2 4 6 8 10 7 3 6 10 15\n\nВходные данныеСкопировать5 10 0 0 0 01 5 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 1 1 1 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 21 2 3 4 5 0 0 0 0 01 6 16 10 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 4 6 8 10 7 3 6 10 15\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #239 - Codeforces",
          "content": "Всем привет!В это воскресенье, 30 марта, в 11:00 MSK, состоится Codeforces Round #239 для участников обоих дивизионов. Обратите внимание на необычное время проведения раунда.Автором задач являюсь я, izban. Большое спасибо команде Codeforces: координатору задач Геральду Агапову (Gerald) за неоценимый вклад в подготовку задач и Марии Беловой (Delinur), которая перевела задачи на английский язык. Также спасибо Ниязу Нигматуллину (niyaznigmatul) за прорешивание задач.Желаю всем хорошо написать раунд и с удовольствием провести выходные!UPD: Разбалловку вы можете увидеть на странице с задачами.UPD2: Разбор вы можете найти по этой ссылке. Обратите внимание на бонусы в некоторых задачах!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11309",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 688
        },
        {
          "title": "Codeforces Round #239 Разбор задач - Codeforces",
          "content": "Обратите внимание на бонусы в некоторых задачах, и если вы умеете их решать, пожалуйста, напишите об этом в комментариях.408A - Очередь на кассеВ задаче нужно было найти время ожидания для каждой очереди, просуммировав покупки по всем людям, и найти минимум.408B - ГирляндаВ задаче нужно было найти максимально длинную гирлянду, которую можно составить из тех элементов, что у нас есть. Во-первых, если какой-то цвет нужен, но его нет, то ответ — -1. Иначе, ответ всегда существует, и является целым числом. Просуммируем ответы по всем цветам по отдельности. Пусть у нас есть a кусков бумаги некоторого цвета, а нужно — b. Тогда если a >  = b, то к ответу можно прибавить b — повесить b кусков по одному метру, а если a < b, то к ответу можно прибавить a, использовав все куски, что есть в наличии. Итого, каждый цвет дает к ответу min(a, b).407A - ТреугольникВ задаче требовалось расположить прямоугольный треугольник с катетами a, b на плоскости с вершинами в целых точках. Если искомое расположение существует, то катет a всегда можно представить как вектор с целыми координатами A{x;y}, при чем a2 = x2 + y2. Переберем все возможные x (1 ≤ x ≤ a - 1), проверим, что y получается целым числом. Вектор, перпендикулярный вектору {x;y} — { - y;x}. Возьмем вектор B{ - y / g;x / g}, где g = gcd(x, y). Треугольник можно уложить на плоскость лишь тогда, когда b делится нацело на |B|, где |B| — длина вектора B. Кандидат на ответ — треугольник (0;0)(x;y)( - y / g * b / |B|;x / g * b / |B|), нужно лишь не забыть проверку на то, что гипотенуза не параллельна осям координат. Сложность решения — O(n).407B - Длинный путьВ задаче требовалось промоделировать путь персонажа по графу. Заметим, что если мы пришли в вершину i, то ребра во всех вершинах с номерами меньшими, чем i, повернуты в pi. Это дает нам возможность заметить рекуррентную формулу: пусть dpi — число шагов, необходимое, чтобы добраться из вершины 1 в вершину i, если все ребра изначально повернуты назад, в pi. тогда dpi + 1 = 2dpi + 2 - dppi. Ответом будет dpn + 1. Сложность решения — O(n).BONUS: Умеете ли вы решать задачу, если нет ограничения, что pi ≤ i? В такой формулировке задача становится более интересной, но я пока не знаю решения.407C - Занимательный массивВ задаче требовалось научиться прибавлять в оффлайне на отрезке числа сочетаний. Будем смотреть, как изменяется задача при увеличении k от малых чисел к большим.1) Все запросы имеют K = 0 Прибавляется каждый раз единица на отрезке. Для решения задачи нужно прибавить на некотором массиве b[] в ячейку b[L] единицу, вычесть из b[R + 1] единицу, а после выполнения всех операций построить массив a как массив сумм на префиксах массива b.2) Все запросы имеют K = 1 Прибавляется арифметическая прогрессия 1 2 3 4 ... Для решения задачи нужно прибавить на некотором массиве c[] в ячейку c[L] единицу, вычесть из с[R + 1] единицу. После выполнения всех операций можно построить массив b как массив сумм на префиксах массива c. В таком массиве мы на каждом отрезке прибавили единицу. Если после этого для каждого запроса вычесть из b[R + 1] число C(R — L + 1, 1) = (R — L + 1), и построить массив а как массив префиксных сумм над массивом b, несложно увидеть, что массив а будет ответом.3) Все запросы имеют произвольное k Пускай у нас есть массив a[N][K]. обобщая предыдущие случаи, можно понять, что если поступает запрос L, R, K, нужно сделать операции a[L][K + 1] += 1 a[R + 1][j] -= C(k + 1 — j + r — l, k + 1 — j) для всех 1 <= j <= K + 1после чего построить необходимые суммы на префиксах для всех значений K спускаясь от больших K к меньшим. Доказать, что нужно отнимать именно такое число сочетаний, проще всего, если посмотреть, как расположены эти числа в треугольнике Паскаля — легко увидеть, что это число является суммой всего ряда чисел перед ним. Сложность решения — O((n + m)k).407D - Наибольшая подматрица 3В задаче требовалось найти наибольшую по площади подматрицу, состоящую из различных чисел. Будем идти от медленных решений к более быстрым.1) Решение за O(n6): Перебираем две противоположные вершины прямоугольника-ответа и проверяем, что все числа внутри различны.2) Решение за O(n4): Фиксируем верхнюю и нижнюю границы прямоугольника-ответа (O(n2)). Используем метод двух указателей при переборе левой и правой границы: пока в прямоугольнике нет одинаковых чисел, двигаем правую границу, пока есть — двигаем левую границу. Проверка при сдвиге границы — O(n), сдвигов — O(n).3) Решение за O(n3logn): Введем функцию maxR(Left): наибольшее значение Right, такое, что при фиксированных Up и Down в прямоугольнике (Up, Down, Left, Right) нет одинаковых чисел. Заметим, что для всех i выполняется maxR(i) <= maxR(i + 1). Как изменяются значения этой функции при сдвиге Down вниз? Каждое значение maxR(Left) может либо остаться таким же (если отрезок(Down, Down, Left, maxR(Left)) добавил лишь новые числа), либо уменьшиться. Когда maxR(Left) уменьшается? Лишь тогда, когда одно из чисел с только что добавленного отрезка уже было в прямоугольнике. Сдвигая Down вниз рассмотрим все числа в ряду Down. Для каждого числа в столбце j найдем индексы i и k такие, что i <= j, в столбце j есть вхождение числа a[Down][j] между строками Up и Down-1, i — максимально; k >= j, в столбце k есть вхождение числа a[Down][j] между строками Up и Down-1, k — минимально. Найдя такие индексы i и k (для этого удобно использовать set, для каждого цвета храня столбцы, где он встречался на данный момент между строками Up и Down), можно обновить maxR[i] = j — 1, maxR[j] = k — 1. Этого будет достаточно. Несложно заметить, что после описанных действий, если мы прокинем по всем i = m..1 maxR[i] = min(maxR[i], maxR[i + 1]), то мы вновь будем иметь корректные значения функции maxR(Left), и можно пересчитать ответ для данных Up и Down за O(n).4) Решение за O(n3): Предыдущее решение, несмотря на хорошую асимптотику, требует хранения большого количества set'ов. Это работает очень медленно даже на небольших тестах. Избавимся от логарифма. Set используется лишь при поиске ближайших слева и справа чисел, равных данному, лежащих в строках с номерами от Up до Down. Заметим, что при сдвиге границы Up ближайший сверху элемент для данного a[i][j] отдаляется. Это наводит на мысль, что, двигая Up снизу вверх, можно заставить ближайший к a[i][j] элемент приближаться к столбцу j, и теперь, сдвигая Up вверх, мы можем, взяв число с верхнего ряда, быстро (за O(n)) определить все числа такие, что он будет для них ближайшим, и обновить для них ближайшее число. Такое решение использует O(n2) памяти и O(n3) времени.BONUS: Умеете ли вы решать эту задачу быстрее, чем за O(n3)? У меня не получилось, но никаких предпосылок того, что решения нет, я не нашел.407E - k-d-последовательностьНа контесте задачу, к сожалению, никто не решил, но в дорешивании первым оказался hza, с чем мы его и поздравляем. В задаче требовалось найти наидлиннейший подотрезок, удовлетворяющий условию.Сведем задачу к d = 1. Если d = 0, то ответ — наидлиннейший подотрезок из равных чисел, этот случай обрабатываем отдельно. Если d ≠ 0, то заметим, что если на некотором отрезке есть два числа ai, aj таких, что ai % d ≠ aj % d, то этот отрезок не может быть хорошим.Разобьем исходную подпоследовательность на отрезки подряд идущих чисел, дающих равные остатки от деления на d, поделим каждое число на d, будем решать для каждого отрезка задачу отдельно, сказав, что d = 1.Заметим, что отрезок [L, R] является хорошим тогда и только тогда, когда max(L, R) — min(L, R) — (R — L) <= k, и на отрезке с L по R нет одинаковых чисел. Объясняется это просто — если на отрезке нет повторяющихся чисел, то max(L, R) — min(L, R) — (R — L) — именно количество чисел, которые необходимо добавить, чтобы отрезок состоял из всех чисел с min(L, R) по max(L, R).Для каждого L найдем такое maxR[L], что на отрезке с L по maxR[L] нет повторяющихся чисел, а maxR[L] — максимально. Это делается за O(nlogn) любым способом, например, проходом с map'ом.Научимся для каждого фиксированного L поддерживать массив a[R] = max(L, R) — min(L, R) — (R — L). Если у нас есть такой массив, то для того, чтбы найти ответ, необходимо быстро найти такое наибольшее R, что a[R] <= k.Нам потребуются два стека и дерево отрезков с операциями \"Прибавить число на отрезке\", \"Найти минимальный элемент на отрезке\" и \"Найти самое правое число, такое, что оно не превышает k\". Будем перебирать L справа налево (от n до 1). Как выглядит функция max(L, R) при фиксированном L? Ее значения представляют собой набор отрезков, на которых максимумом является первый элемент отрезка. (пример: для массива 6 4 8 0 7 9 функция max(1, R) будет иметь вид 6 6 8 8 8 9) Как изменяется функция при сдвиге L влево? Некоторые отрезки поглощаются новым элементом, если новый элемент больше значения на отрезке. Заметив, что все значения массива не убывают, будем хранить все такие отрезки в стеке, а при добавлении нового элемента a[L] вытаскивать отрезки из стека, пока значение на вершине меньше нового, и добавим на стек новый отрезок, который покроет L и все, что мы вытащили. Если каждую операцию со стеком сопровождать запросом \"Прибавить число на отрезке\", то мы уже можем получить массив a[R] = max(L, R). Функция min(L, R) ведет себя абсолютно аналогично, и используя второй стек мы получаем a[R] = max(L, R) — min(L, R). Для того, чтобы получить член (R — L) достаточно просто каждый раз при сдвиге L влево отнимать единицу на отрезке [L, n]. Теперь запрос \"Найти самое правое число, такое, что оно не превышает k\". Сначала дерево отрезков разбивает отрезок запроса L..R на log(n) отрезков длиной степени двойки. Разобьем запрос на такие отрезки и выберем самый правый отрезок, минимум на котором <= k. Теперь будем спускаться по этому отрезку вниз в дереве отрезков — если в правом сыне min <= k, то в правого, иначе в левого. Так мы найдем искомый элемент. Итак, для каждого фиксированного L делаем запрос на отрезке L..maxR(L) о самом правом числе, не превышающем k. Это один из кандидатов на ответ. Все. Раз мы делаем запрос на отрезке, на котором нет различных чисел, то любое число на этом отрезке неотрицательно, и min работает корректно. Суммарное время работы — O(nlogn).BONUS: Задача и сама по себе не из простых, но умеет ли кто-нибудь решать ее по методу \"навороти побольше\"? Интересно, как решать хотя бы на дереве.BONUS2: Есть очень быстрое решение за O(n2). Давайте для отрезка [L; R] так же посмотрим на значение f(L, R) = max(L..R) — min(L..R) — (R — L) — K. f(L, R) можно считать для отрезка за O(1). Если f(L, R) <= 0, то отрезок — кандидат на ответ. Если f(L, R) > 0, то следующий отрезок, который стоит рассмотреть — [L; R + f(L, R)], потому что для всех r: R < r < R + f(L, R) отрезок [L; r] не будет k-d последовательностью, поскольку при добавлении одного числа в отрезок f(L, R) может либо возрасти на произвольное число, либо уменьшиться на единицу. Если так написать решение за квадрат, используя для начального R при фиксированном L значение L + curAns, то решение в среднем работает очень быстро, и получает ТЛ лишь на специальных тестов. Вполне возможно, что это решение можно оптимизациями довести до такого, что оно пройдет все тесты.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11333",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 407\\s*C"
          },
          "content_length": 11115
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #239 - Codeforces - Code 1",
          "code": "#збаник_пряник",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 2",
          "code": "DP[i]=(2+pre[i]-pre[P[i]-1])%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 3",
          "code": "DP[i]=(2+pre[i]-pre[P[i]-1])%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 4",
          "code": "DP[i]=(2+pre[i]-pre[P[i]-1] + MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 5",
          "code": "DP[i]=(2+pre[i]-pre[P[i]-1] + MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 6",
          "code": "for(dx=1;dx*dx<a*a;++dx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 7",
          "code": "for(dx=1;dx*dx<a*a;++dx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 8",
          "code": "xa = - a * yb / b;\nya = a * xb / b;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 9",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 10",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 11",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 12",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 13",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 14",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 15",
          "code": "1 1\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 16",
          "code": "============================================",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 17",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 18",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 19",
          "code": "YES\n0 0\n324 945\n960 -280",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 20",
          "code": "YES\n0 0\n324 945\n960 -280",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 21",
          "code": "999 = 324 * 324 + 945 * 945\n      104976    + 893025 = 998001\nsqrt(998001) = 999\n1000 = 960 * 960 + 280 * 280\n       921600    + 78400 = 1000000\nsqrt(1000000) = 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 22",
          "code": "999 = 324 * 324 + 945 * 945\n      104976    + 893025 = 998001\nsqrt(998001) = 999\n1000 = 960 * 960 + 280 * 280\n       921600    + 78400 = 1000000\nsqrt(1000000) = 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 23",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 24",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Разбор задач - Codeforces - Code 1",
          "code": "dp[i] = 1 + (dp[p[i]]+1) + (dp[p[i]+1]+1) + ... + (dp[i-1]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Разбор задач - Codeforces - Code 2",
          "code": "(dp[1]+1) + (dp[2]+1) + (dp[3]+1) + ... + (dp[n]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Разбор задач - Codeforces - Code 3",
          "code": "s[p[k]]+s[p[k]+1]+s[p[k]+2]+...+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Разбор задач - Codeforces - Code 4",
          "code": "s[k]=2+s[p[k]]+s[p[k]+1]+s[p[k]+2]+..+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Разбор задач - Codeforces - Code 5",
          "code": "answer=s[1]+s[2]+..+s[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Разбор задач - Codeforces - Code 6",
          "code": "dp[i] = the number of steps needed to move from room i to room (i + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Разбор задач - Codeforces - Code 7",
          "code": "dp[i] = 2 + sum(dp[j]) for j in [p[i], i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Разбор задач - Codeforces - Code 8",
          "code": "sum(dp[i]) for (1 ≤ i ≤ n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(1, n, \"r_i\");\n        ensuref(l <= r, \"l_i should be less than or equal to r_i\");\n        inf.readSpace();\n        int k = inf.readInt(0, 100, \"k_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(1, n, \"r_i\");\n        ensuref(l <= r, \"l_i should be less than or equal to r_i\");\n        inf.readSpace();\n        int k = inf.readInt(0, 100, \"k_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(1, n, \"r_i\");\n        ensuref(l <= r, \"l_i should be less than or equal to r_i\");\n        inf.readSpace();\n        int k = inf.readInt(0, 100, \"k_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string initial = opt<string>(\"initial\", \"random\");\n    string querytype = opt<string>(\"querytype\", \"random\");\n\n    vector<int> a(n);\n    // Generate initial array a[1..n]\n    if(initial == \"zeros\") {\n        // All zeros\n        fill(a.begin(), a.end(), 0);\n    } else if(initial == \"ones\") {\n        // All ones\n        fill(a.begin(), a.end(), 1);\n    } else if(initial == \"increasing\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = i+1;\n    } else if(initial == \"decreasing\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if(initial == \"max_ai\") {\n        // All maximum values\n        fill(a.begin(), a.end(), 1000000000); // 1e9\n    } else if(initial == \"random\") {\n        // Random integers from 0 to 1e9\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1000000000); // 1e9\n    }\n\n    // Print n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Print initial array\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if(i < n-1) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    // Generate queries\n    for(int i=0;i<m;++i) {\n        int li, ri, ki;\n        if(querytype == \"ki_zero\") {\n            ki = 0;\n        } else if(querytype == \"ki_max\") {\n            ki = 100;\n        } else if(querytype == \"ki_random\") {\n            ki = rnd.next(0,100);\n        } else if(querytype == \"ki_eq_range\") {\n            li = rnd.next(1, n);\n            ri = rnd.next(li, n);\n            ki = ri - li +1;\n            if(ki > 100) ki = 100;\n        } else {\n            // default random ki\n            ki = rnd.next(0, 100);\n        }\n\n        if(querytype == \"entire_array\") {\n            li = 1;\n            ri = n;\n        } else if(querytype == \"single_element\") {\n            li = ri = rnd.next(1, n);\n        } else if(querytype == \"front\") {\n            li = 1;\n            ri = rnd.next(1, n);\n        } else if(querytype == \"back\") {\n            li = rnd.next(1, n);\n            ri = n;\n        } else if(querytype == \"ki_eq_range\") {\n            // ki and li, ri already set\n        } else {\n            // default random li and ri\n            li = rnd.next(1, n);\n            ri = rnd.next(li, n);\n        }\n        printf(\"%d %d %d\\n\", li, ri, ki);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string initial = opt<string>(\"initial\", \"random\");\n    string querytype = opt<string>(\"querytype\", \"random\");\n\n    vector<int> a(n);\n    // Generate initial array a[1..n]\n    if(initial == \"zeros\") {\n        // All zeros\n        fill(a.begin(), a.end(), 0);\n    } else if(initial == \"ones\") {\n        // All ones\n        fill(a.begin(), a.end(), 1);\n    } else if(initial == \"increasing\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = i+1;\n    } else if(initial == \"decreasing\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if(initial == \"max_ai\") {\n        // All maximum values\n        fill(a.begin(), a.end(), 1000000000); // 1e9\n    } else if(initial == \"random\") {\n        // Random integers from 0 to 1e9\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1000000000); // 1e9\n    }\n\n    // Print n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Print initial array\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if(i < n-1) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    // Generate queries\n    for(int i=0;i<m;++i) {\n        int li, ri, ki;\n        if(querytype == \"ki_zero\") {\n            ki = 0;\n        } else if(querytype == \"ki_max\") {\n            ki = 100;\n        } else if(querytype == \"ki_random\") {\n            ki = rnd.next(0,100);\n        } else if(querytype == \"ki_eq_range\") {\n            li = rnd.next(1, n);\n            ri = rnd.next(li, n);\n            ki = ri - li +1;\n            if(ki > 100) ki = 100;\n        } else {\n            // default random ki\n            ki = rnd.next(0, 100);\n        }\n\n        if(querytype == \"entire_array\") {\n            li = 1;\n            ri = n;\n        } else if(querytype == \"single_element\") {\n            li = ri = rnd.next(1, n);\n        } else if(querytype == \"front\") {\n            li = 1;\n            ri = rnd.next(1, n);\n        } else if(querytype == \"back\") {\n            li = rnd.next(1, n);\n            ri = n;\n        } else if(querytype == \"ki_eq_range\") {\n            // ki and li, ri already set\n        } else {\n            // default random li and ri\n            li = rnd.next(1, n);\n            ri = rnd.next(li, n);\n        }\n        printf(\"%d %d %d\\n\", li, ri, ki);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -initial zeros -querytype ki_zero\n./gen -n 1 -m 1 -initial zeros -querytype ki_max\n./gen -n 1 -m 1 -initial zeros -querytype entire_array\n\n./gen -n 10 -m 5 -initial ones -querytype ki_zero\n./gen -n 10 -m 5 -initial ones -querytype ki_random\n./gen -n 10 -m 5 -initial increasing -querytype ki_max\n\n./gen -n 100 -m 50 -initial decreasing -querytype ki_zero\n./gen -n 100 -m 50 -initial random -querytype ki_eq_range\n\n./gen -n 1000 -m 500 -initial max_ai -querytype ki_random\n\n./gen -n 10000 -m 5000 -initial random -querytype ki_zero\n./gen -n 10000 -m 5000 -initial zeros -querytype ki_max\n\n./gen -n 100000 -m 100000 -initial random -querytype ki_random\n./gen -n 100000 -m 100000 -initial zeros -querytype entire_array\n./gen -n 100000 -m 100000 -initial increasing -querytype single_element\n./gen -n 100000 -m 100000 -initial decreasing -querytype front\n./gen -n 100000 -m 100000 -initial max_ai -querytype back\n./gen -n 100000 -m 100000 -initial ones -querytype ki_eq_range\n./gen -n 100000 -m 100000 -initial random -querytype ki_max\n./gen -n 100000 -m 100000 -initial zeros -querytype ki_zero\n\n./gen -n 100000 -m 1 -initial zeros -querytype entire_array\n./gen -n 1 -m 100000 -initial ones -querytype single_element\n\n./gen -n 50000 -m 50000 -initial zeros -querytype random\n./gen -n 50000 -m 50000 -initial random -querytype ki_zero\n./gen -n 50000 -m 50000 -initial random -querytype ki_max\n./gen -n 50000 -m 50000 -initial random -querytype ki_eq_range\n\n./gen -n 200 -m 200 -initial random -querytype random\n\n./gen -n 100000 -m 100000 -initial zeros -querytype random\n./gen -n 100000 -m 100000 -initial zeros -querytype ki_zero\n./gen -n 100000 -m 100000 -initial zeros -querytype ki_max\n./gen -n 100000 -m 100000 -initial zeros -querytype ki_eq_range\n./gen -n 100000 -m 100000 -initial random -querytype ki_eq_range\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:35.643290",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "407/D",
      "title": "D. Largest Submatrix 3",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, m (1 ≤ n, m ≤ 400) — the number of rows and columns of the matrix, correspondingly.Each of the next n lines contains m integers aij (1 ≤ aij ≤ 160000) — the elements of the matrix.",
      "output_spec": "OutputPrint a single integer — the area of the optimal inhomogenous submatrix.",
      "sample_tests": "ExamplesInputCopy3 31 3 14 5 62 6 1OutputCopy6InputCopy3 45 2 3 13 3 5 34 4 4 5OutputCopy4InputCopy2 61 2 3 4 5 68 6 7 8 9 1OutputCopy8",
      "description": "D. Largest Submatrix 3\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n, m (1 ≤ n, m ≤ 400) — the number of rows and columns of the matrix, correspondingly.Each of the next n lines contains m integers aij (1 ≤ aij ≤ 160000) — the elements of the matrix.\n\nOutputPrint a single integer — the area of the optimal inhomogenous submatrix.\n\nInputCopy3 31 3 14 5 62 6 1OutputCopy6InputCopy3 45 2 3 13 3 5 34 4 4 5OutputCopy4InputCopy2 61 2 3 4 5 68 6 7 8 9 1OutputCopy8\n\nInputCopy3 31 3 14 5 62 6 1\n\nOutputCopy6\n\nInputCopy3 45 2 3 13 3 5 34 4 4 5\n\nOutputCopy4\n\nInputCopy2 61 2 3 4 5 68 6 7 8 9 1\n\nOutputCopy8",
      "solutions": [
        {
          "title": "Codeforces Round #239 - Codeforces",
          "content": "Hello everyone!This Sunday, on March 30 at 11:00 MSK (March 30 at 07:00 UTC), Codeforces Round #239 for both divisions participants will take place. Note the unusual time of the round.The problems have been prepared by me. I want to thank Codeforces team: tasks coordinator Gerald Agapov (Gerald) for invaluable contribution to the preparation of tasks and Maria Belova (Delinur), who has translated the problems. Also thank to Niyaz Nigmatullin (niyaznigmatul) for testing.I wish you all good luck and have a good weekend!UPD: You can see score distribution at the problems page.UPD2: You can find editorial here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11309",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 614
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces",
          "content": "Sorry for my poor English. If you find a mistake, write me a private message, I'll fix it. Some problems have not been translated yet, now you can try to read the Russian version of editorial with Google Translate.408A - Line to CashierIn this problem you were to find waiting the time for every queue by summing up the purchases of all the people, and return the minimum.408B - GarlandIn this problem it is necessary to find the garland with the maximal length, which can be composed of elements that we have. First, if you need some color, but you don't have it, then the answer is -1 Otherwise, answer is always exists. Let's sum the answers for all the colors separately. Suppose we have a pieces of a garland of some color, and we need b pieces. Then we have to add min(a, b) to the answer: if a >  = b we will use b 1 meter pieces, in the other case if a < b we will use all a pieces.407A - TriangleIn this problem you have to locate the right triangle with cathetuses a, b on a plane with its vertices in integer points. If the required layout exists, then cathetus a always can be represented as a vector with integer coordinates A{x;y}, and a2 = x2 + y2. Iterate over all possible x (1 ≤ x ≤ a - 1), check, that y = sqrt(a2 - x2) is integer. Vector, ortogonal to vector {x;y}, is { - y;x}. Take vector B{ - y / g;x / g}, where g = gcd(x, y). The triangle can be located on the plane if and only if b % |B| = 0, where |B| — length of vector B. The candidate for the answer — triangle (0;0)(x;y)( - y / g * b / |B|;x / g * b / |B|), but don't forget about checking that the hypotenuse isn't parallel to coordinate axes.407B - Long PathIn this problem you had to simulate route of character in graph. Note that if you are in vertice i, then edges in all vertices with numbers less than i are turned to pi. It gives us opportunity to see a recurrence formula: let dpi be number of steps, needed to get from vertice 1 to vertice i, if all edges are rotated back, into pi. Then dpi + 1 = 2dpi + 2 - dppi. Answer will be dpn + 1.BONUS: Can you solve this task without statement pi ≤ i? I don't know the solution, it seems difficult.407C - Curious ArrayIn this problem you had to find how to add binomial coefficients in array offline. Let's see, how problem changes due to increasing k from small to big values.1) All queries have K = 0 Every time you add 1 on subsegment. For solve this task you can add 1 at some array b[] in b[L] 1, then substract 1 from b[R+1], and after doing all queries make array a[] as array of prefix sums of array b[].2) All queries have K = 1 Arithmetic progression 1 2 3 4 ... is added on subsegment For solve this task you can add 1 at some array c[] in c[L] 1, then substract 1 from c[R+1], and after doing all queries make array b[] as array of prefix sums of array c[]. Actually you added 1 1 ... 1 on every subsegment at each query. If you will substract (R — L + 1) from c[R+1], and make array a[] as array of prefix sums of array b[], then it will be an answer: 1 1 ... 1 became 1 2 3 ... (R-L+1).3) K is arbitrary Summaring previous results one can see that if we will do a[K+1][L] += 1 a[j][R+1] -= C(k + 1 — j + r — l, k + 1 — j) for all 1 <= j <= K + 1 and after that do a[i][j] = a[i][j-1] + a[i+1][j] (making a[i] as array of prefix sums array a[i+1]), a[0] will be the answer. What is C(k + 1 — j + r — l, k + 1 — j)? This number is need for each query affect only on segment L..R, and you can see, why is it so, in Pascal's Triangle.If this explanation is not clear for you, you can try to see other participants solutions (for example, Xellos's one).407D - Largest Submatrix 3In this task you have to find largest by area submatrix, consisting from different numbers. Let's see solutions from slow to fast.1) Solution by O(n6): Iterate through two opposite vertices submatrix-answer and check that all numbers are different.2) Solution by O(n4): Let's fix Up and Down borders submatrix-answer (O(n2)). Use two pointers method to iterate Left and Right borders: while in submatrix there are no equal numbers, increment Right, while there are equal numbers — increment Left. Every check — (O(n)), increments — (O(n)).3) Solution by O(n3logn): Let's construct function maxR(Left) (let's consider that Up <= Down are fixed): maximal value Right, so that in submatrix (Up, Down, Left, Right) there is no equals numbers. You can see that maxR(i) <= maxR(i + 1) is true for every i. How values of this function changes by shift Down to Down-1? Every value maxR(Left) can only be the same (if segment(Down, Down, Left, maxR(Left)) only added new numbers), or it can decrease. When maxR(Left) is decreasing? Only when one of the numbers from added segment have already been in the current submatrix. Shift Down to down let's see all numbers in row Down. For each number (let it be in column j) find indices i and k so i <= j, there is number, equal to a[Down][j] between rows Up and Down-1, i — maximal; k >= j, there is number, equal to a[Down][j] between rows Up and Down-1, k — minimal. When you find these indices (it is easy to find them using set, when you store all columns where number x was between Up and Down for all numbers x), you can try to update maxR[i] with j — 1, maxR[j] with k — 1. It will be enough, if you also update for all i = m..1 maxR[i] = min(maxR[i], maxR[i + 1]). Now maxR(Left) is correct, and you can check answer for these Up and Down by O(n).4) Now, solution by O(n3). It requires understanding previous solution. Previous solution, despite good asymptotics, requires to store a lot (about 160 000) sets, where you will store about 160 000 elements. Even at n = 200 it works very slow. Let's get rid of log. Set is using only for finding nearest left and right elements, which are in rows from Up to Down, and equal to current. Note that when you do Up = Up — 1, nearest element comes near (by column) to a[i][j], so we can find all numbers, for which the nearest element will be in new row Up, and update them nearest number, and do that in O(n2). This solution uses O(n2) memory and O(n3) time.BONUS: Can you solve this task faster than O(n3)? I spend a lot of time and I didn't come to any solution, but I can't show that there is not solution faster.407E - k-d-sequenceIn this problem you have to find longest subsegment, satisfying the condition.Reduce problem to d = 1.If d = 0, then answer is longest subsegment from equal numbers, this case we solve separately. If d ≠ 0, then notice that if on some subsegment there are two numbers ai, aj so that ai%d ≠ aj%d, then this segment can't be good. Divide the sequence to consequent subsegments numbers, equal by modulo d, and divide each number by d, and solve task separately with every segment, consider that d = 1. Notice that segment [L, R] is good if and only if when max(L, R) — min(L, R) — (R — L) <= k, and there are no equal numbers. It is easy to exlain: if there are no equal numbers, then max(L, R) — min(L, R) — (R — L) is exactly number of numbers is needed to add for segment to consist of all numbers from min(L, R) to max(L, R). For all L lets find such maxR[L], that on segment [L..maxR[l]] there are no equal numbers, and maxR[L] is maximal. It can be done by O(nlogn) by many ways, for example you can use map. Let's learn how we can maintain array a[R] = max(L, R) — min(L, R) — (R — L). If we have such array, then we have to find rightmost R such that a[R] <= k to get an answer. We will need two stacks and segment tree with operations \"Add number on segment\", \"Find min element on segment\", \"Find rightmost number doesn't exceed k\". Let's iterate L from right to left (n downto 1). How does function max(L, R) look like with fixed L? It's values represent a set of segments so that maximum on the segment is leftmost element of segment, and these maximums are increasing. (example: for array 6 4 8 0 7 9 function max(1, R) will be 6 6 8 8 8 9). How function changes with shift L to left? Some segments are absorbed by new element, if new element is bigger than maximum on segment. Maximums on segments are increasing, so we can keep them all in stack, and when we need to add new element we have to only pop some segments from stacks while maximum on top of stack is less then new element, and push new segment after that. If every operation with stack will be accompanied with right operation with segment tree, we can store array a[R] = max(L, R). For get array a[R] = max(L, R) — min(L, R) we need only to maintain second similar stack. For get array a[R] = max(L, R) — min(L, R) we need add -1 on all suffix when we are shitfing L. Now query \"Find fightmost number less of equal k\". First, segment tree divides segment of request to log(n) segments with length powers of two. Let's choose rightmost segment with minimum <= k, and do iterative deeping there to find element that we need.So, for every L we get query on segment L..maxR(L) on rightmost number less or equal k. It is one of candidates to an answer. We are doing O(n) operation with stack, and every requires query to segment tree, so asymptotics is O(nlogn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11333",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 407\\s*D"
          },
          "content_length": 9077
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #239 - Codeforces - Code 1",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 2",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 3",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 4",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 5",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 6",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 7",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 8",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 1",
          "code": "dp[i] = 1 + (dp[p[i]]+1) + (dp[p[i]+1]+1) + ... + (dp[i-1]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 2",
          "code": "(dp[1]+1) + (dp[2]+1) + (dp[3]+1) + ... + (dp[n]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 3",
          "code": "s[p[k]]+s[p[k]+1]+s[p[k]+2]+...+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 4",
          "code": "s[k]=2+s[p[k]]+s[p[k]+1]+s[p[k]+2]+..+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 5",
          "code": "answer=s[1]+s[2]+..+s[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 6",
          "code": "dp[i] = the number of steps needed to move from room i to room (i + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 7",
          "code": "dp[i] = 2 + sum(dp[j]) for j in [p[i], i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 8",
          "code": "sum(dp[i]) for (1 ≤ i ≤ n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 400, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 400, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(m, 1, 160000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 400, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 400, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(m, 1, 160000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 400, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 400, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(m, 1, 160000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_value = opt<int>(\"max_value\", 160000);\n\n    vector<vector<int>> a(n, vector<int>(m));\n\n    if (type == \"all_same\") {\n        // All elements are the same\n        int value = rnd.next(1, max_value);\n        for (int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), value);\n    } else if (type == \"all_distinct\") {\n        // All elements are distinct\n        if (n * m > 160000) {\n            cerr << \"Cannot generate all distinct elements with n*m > 160000\" << endl;\n            exit(1);\n        }\n        vector<int> values(n * m);\n        for (int i = 0; i < n * m; ++i)\n            values[i] = i + 1;  // Values from 1 to n*m\n        shuffle(values.begin(), values.end());\n        for (int i = 0, k = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = values[k++];\n    } else if (type == \"row_repeats\") {\n        // Each row is identical\n        for (int i = 0; i < n; ++i) {\n            int value = rnd.next(1, max_value);\n            fill(a[i].begin(), a[i].end(), value);\n        }\n    } else if (type == \"column_repeats\") {\n        // Each column is identical\n        vector<int> values(m);\n        for (int j = 0; j < m; ++j)\n            values[j] = rnd.next(1, max_value);\n        for (int i = 0; i < n; ++i)\n            copy(values.begin(), values.end(), a[i].begin());\n    } else if (type == \"checkerboard\") {\n        // Alternate elements differ\n        int v1 = rnd.next(1, max_value);\n        int v2 = rnd.next(1, max_value);\n        while (v2 == v1) v2 = rnd.next(1, max_value);\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = ((i + j) % 2) ? v1 : v2;\n    } else if (type == \"diagonal\") {\n        // Elements are the same along diagonals\n        map<int, int> diag_values;\n        for (int d = -n + 1; d < m; ++d) {\n            int value = rnd.next(1, max_value);\n            diag_values[d] = value;\n        }\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = diag_values[j - i];\n    } else if (type == \"max_inhom_submatrix\") {\n        // Entire matrix is inhomogeneous\n        if (n * m > 160000) {\n            cerr << \"Cannot generate all distinct elements with n*m > 160000\" << endl;\n            exit(1);\n        }\n        vector<int> values(n * m);\n        for (int i = 0; i < n * m; ++i)\n            values[i] = i + 1;  // Values from 1 to n*m\n        shuffle(values.begin(), values.end());\n        for (int i = 0, k = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = values[k++];\n    } else if (type == \"small_inhom_submatrix\") {\n        // Largest inhomogeneous submatrix is small\n        int value = rnd.next(1, max_value);\n        for (int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), value);\n        int sub_n = min(n, 5);\n        int sub_m = min(m, 5);\n        set<int> used_values;\n        used_values.insert(value);\n        for (int i = 0; i < sub_n; ++i)\n            for (int j = 0; j < sub_m; ++j) {\n                int new_value = rnd.next(1, max_value);\n                while (used_values.count(new_value))\n                    new_value = rnd.next(1, max_value);\n                used_values.insert(new_value);\n                a[i][j] = new_value;\n            }\n    } else if (type == \"random\") {\n        // Random matrix\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(1, max_value);\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j)\n            printf(\"%d%c\", a[i][j], (j == m -1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_value = opt<int>(\"max_value\", 160000);\n\n    vector<vector<int>> a(n, vector<int>(m));\n\n    if (type == \"all_same\") {\n        // All elements are the same\n        int value = rnd.next(1, max_value);\n        for (int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), value);\n    } else if (type == \"all_distinct\") {\n        // All elements are distinct\n        if (n * m > 160000) {\n            cerr << \"Cannot generate all distinct elements with n*m > 160000\" << endl;\n            exit(1);\n        }\n        vector<int> values(n * m);\n        for (int i = 0; i < n * m; ++i)\n            values[i] = i + 1;  // Values from 1 to n*m\n        shuffle(values.begin(), values.end());\n        for (int i = 0, k = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = values[k++];\n    } else if (type == \"row_repeats\") {\n        // Each row is identical\n        for (int i = 0; i < n; ++i) {\n            int value = rnd.next(1, max_value);\n            fill(a[i].begin(), a[i].end(), value);\n        }\n    } else if (type == \"column_repeats\") {\n        // Each column is identical\n        vector<int> values(m);\n        for (int j = 0; j < m; ++j)\n            values[j] = rnd.next(1, max_value);\n        for (int i = 0; i < n; ++i)\n            copy(values.begin(), values.end(), a[i].begin());\n    } else if (type == \"checkerboard\") {\n        // Alternate elements differ\n        int v1 = rnd.next(1, max_value);\n        int v2 = rnd.next(1, max_value);\n        while (v2 == v1) v2 = rnd.next(1, max_value);\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = ((i + j) % 2) ? v1 : v2;\n    } else if (type == \"diagonal\") {\n        // Elements are the same along diagonals\n        map<int, int> diag_values;\n        for (int d = -n + 1; d < m; ++d) {\n            int value = rnd.next(1, max_value);\n            diag_values[d] = value;\n        }\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = diag_values[j - i];\n    } else if (type == \"max_inhom_submatrix\") {\n        // Entire matrix is inhomogeneous\n        if (n * m > 160000) {\n            cerr << \"Cannot generate all distinct elements with n*m > 160000\" << endl;\n            exit(1);\n        }\n        vector<int> values(n * m);\n        for (int i = 0; i < n * m; ++i)\n            values[i] = i + 1;  // Values from 1 to n*m\n        shuffle(values.begin(), values.end());\n        for (int i = 0, k = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = values[k++];\n    } else if (type == \"small_inhom_submatrix\") {\n        // Largest inhomogeneous submatrix is small\n        int value = rnd.next(1, max_value);\n        for (int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), value);\n        int sub_n = min(n, 5);\n        int sub_m = min(m, 5);\n        set<int> used_values;\n        used_values.insert(value);\n        for (int i = 0; i < sub_n; ++i)\n            for (int j = 0; j < sub_m; ++j) {\n                int new_value = rnd.next(1, max_value);\n                while (used_values.count(new_value))\n                    new_value = rnd.next(1, max_value);\n                used_values.insert(new_value);\n                a[i][j] = new_value;\n            }\n    } else if (type == \"random\") {\n        // Random matrix\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(1, max_value);\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j)\n            printf(\"%d%c\", a[i][j], (j == m -1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small matrices\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 10 -type random\n./gen -n 10 -m 1 -type random\n./gen -n 10 -m 10 -type random\n\n# Matrices with all elements the same\n./gen -n 5 -m 5 -type all_same\n./gen -n 400 -m 400 -type all_same\n\n# Matrices with all elements distinct\n./gen -n 100 -m 100 -type all_distinct\n./gen -n 400 -m 400 -type all_distinct\n\n# Edge cases with n or m = 1\n./gen -n 1 -m 400 -type random\n./gen -n 400 -m 1 -type random\n\n# Random matrices of maximum size\n./gen -n 400 -m 400 -type random\n\n# Row repeats\n./gen -n 100 -m 100 -type row_repeats\n./gen -n 400 -m 400 -type row_repeats\n\n# Column repeats\n./gen -n 100 -m 100 -type column_repeats\n./gen -n 400 -m 400 -type column_repeats\n\n# Checkerboard pattern\n./gen -n 100 -m 100 -type checkerboard\n./gen -n 400 -m 400 -type checkerboard\n\n# Diagonal pattern\n./gen -n 100 -m 100 -type diagonal\n./gen -n 400 -m 400 -type diagonal\n\n# Small inhomogeneous submatrix\n./gen -n 400 -m 400 -type small_inhom_submatrix\n\n# Max inhomogeneous submatrix\n./gen -n 100 -m 100 -type max_inhom_submatrix\n./gen -n 400 -m 400 -type max_inhom_submatrix\n\n# Tests with different max_value\n./gen -n 400 -m 400 -type random -max_value 10\n./gen -n 400 -m 400 -type random -max_value 1\n./gen -n 400 -m 400 -type random -max_value 2\n\n# Random matrices with various sizes\n./gen -n 200 -m 300 -type random\n./gen -n 300 -m 200 -type random\n\n# Edge case with n*m just under 160000 for all_distinct\n./gen -n 200 -m 800 -type all_distinct   # n*m=160000\n\n# Random matrix with maximum allowed n and m\n./gen -n 400 -m 400 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:37.994084",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "407/E",
      "title": "E. k-d-sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers n, k, d (1 ≤ n ≤ 2·105; 0 ≤ k ≤ 2·105; 0 ≤ d ≤ 109). The second line contains n space-separated integers: a1, a2, ..., an ( - 109 ≤ ai ≤ 109) — the actual sequence.",
      "output_spec": "OutputPrint two space-separated integers l, r (1 ≤ l ≤ r ≤ n) show that sequence al, al + 1, ..., ar is the longest subsegment that is a good k-d sequence.If there are multiple optimal answers, print the one with the minimum value of l.",
      "sample_tests": "ExamplesInputCopy6 1 24 3 2 8 6 2OutputCopy3 5",
      "description": "E. k-d-sequence\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers n, k, d (1 ≤ n ≤ 2·105; 0 ≤ k ≤ 2·105; 0 ≤ d ≤ 109). The second line contains n space-separated integers: a1, a2, ..., an ( - 109 ≤ ai ≤ 109) — the actual sequence.\n\nOutputPrint two space-separated integers l, r (1 ≤ l ≤ r ≤ n) show that sequence al, al + 1, ..., ar is the longest subsegment that is a good k-d sequence.If there are multiple optimal answers, print the one with the minimum value of l.\n\nInputCopy6 1 24 3 2 8 6 2OutputCopy3 5\n\nInputCopy6 1 24 3 2 8 6 2\n\nOutputCopy3 5\n\nNoteIn the first test sample the answer is the subsegment consisting of numbers 2, 8, 6 — after adding number 4 and sorting it becomes sequence 2, 4, 6, 8 — the arithmetic progression with difference 2.",
      "solutions": [
        {
          "title": "Codeforces Round #239 - Codeforces",
          "content": "Hello everyone!This Sunday, on March 30 at 11:00 MSK (March 30 at 07:00 UTC), Codeforces Round #239 for both divisions participants will take place. Note the unusual time of the round.The problems have been prepared by me. I want to thank Codeforces team: tasks coordinator Gerald Agapov (Gerald) for invaluable contribution to the preparation of tasks and Maria Belova (Delinur), who has translated the problems. Also thank to Niyaz Nigmatullin (niyaznigmatul) for testing.I wish you all good luck and have a good weekend!UPD: You can see score distribution at the problems page.UPD2: You can find editorial here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11309",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 614
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces",
          "content": "Sorry for my poor English. If you find a mistake, write me a private message, I'll fix it. Some problems have not been translated yet, now you can try to read the Russian version of editorial with Google Translate.408A - Line to CashierIn this problem you were to find waiting the time for every queue by summing up the purchases of all the people, and return the minimum.408B - GarlandIn this problem it is necessary to find the garland with the maximal length, which can be composed of elements that we have. First, if you need some color, but you don't have it, then the answer is -1 Otherwise, answer is always exists. Let's sum the answers for all the colors separately. Suppose we have a pieces of a garland of some color, and we need b pieces. Then we have to add min(a, b) to the answer: if a >  = b we will use b 1 meter pieces, in the other case if a < b we will use all a pieces.407A - TriangleIn this problem you have to locate the right triangle with cathetuses a, b on a plane with its vertices in integer points. If the required layout exists, then cathetus a always can be represented as a vector with integer coordinates A{x;y}, and a2 = x2 + y2. Iterate over all possible x (1 ≤ x ≤ a - 1), check, that y = sqrt(a2 - x2) is integer. Vector, ortogonal to vector {x;y}, is { - y;x}. Take vector B{ - y / g;x / g}, where g = gcd(x, y). The triangle can be located on the plane if and only if b % |B| = 0, where |B| — length of vector B. The candidate for the answer — triangle (0;0)(x;y)( - y / g * b / |B|;x / g * b / |B|), but don't forget about checking that the hypotenuse isn't parallel to coordinate axes.407B - Long PathIn this problem you had to simulate route of character in graph. Note that if you are in vertice i, then edges in all vertices with numbers less than i are turned to pi. It gives us opportunity to see a recurrence formula: let dpi be number of steps, needed to get from vertice 1 to vertice i, if all edges are rotated back, into pi. Then dpi + 1 = 2dpi + 2 - dppi. Answer will be dpn + 1.BONUS: Can you solve this task without statement pi ≤ i? I don't know the solution, it seems difficult.407C - Curious ArrayIn this problem you had to find how to add binomial coefficients in array offline. Let's see, how problem changes due to increasing k from small to big values.1) All queries have K = 0 Every time you add 1 on subsegment. For solve this task you can add 1 at some array b[] in b[L] 1, then substract 1 from b[R+1], and after doing all queries make array a[] as array of prefix sums of array b[].2) All queries have K = 1 Arithmetic progression 1 2 3 4 ... is added on subsegment For solve this task you can add 1 at some array c[] in c[L] 1, then substract 1 from c[R+1], and after doing all queries make array b[] as array of prefix sums of array c[]. Actually you added 1 1 ... 1 on every subsegment at each query. If you will substract (R — L + 1) from c[R+1], and make array a[] as array of prefix sums of array b[], then it will be an answer: 1 1 ... 1 became 1 2 3 ... (R-L+1).3) K is arbitrary Summaring previous results one can see that if we will do a[K+1][L] += 1 a[j][R+1] -= C(k + 1 — j + r — l, k + 1 — j) for all 1 <= j <= K + 1 and after that do a[i][j] = a[i][j-1] + a[i+1][j] (making a[i] as array of prefix sums array a[i+1]), a[0] will be the answer. What is C(k + 1 — j + r — l, k + 1 — j)? This number is need for each query affect only on segment L..R, and you can see, why is it so, in Pascal's Triangle.If this explanation is not clear for you, you can try to see other participants solutions (for example, Xellos's one).407D - Largest Submatrix 3In this task you have to find largest by area submatrix, consisting from different numbers. Let's see solutions from slow to fast.1) Solution by O(n6): Iterate through two opposite vertices submatrix-answer and check that all numbers are different.2) Solution by O(n4): Let's fix Up and Down borders submatrix-answer (O(n2)). Use two pointers method to iterate Left and Right borders: while in submatrix there are no equal numbers, increment Right, while there are equal numbers — increment Left. Every check — (O(n)), increments — (O(n)).3) Solution by O(n3logn): Let's construct function maxR(Left) (let's consider that Up <= Down are fixed): maximal value Right, so that in submatrix (Up, Down, Left, Right) there is no equals numbers. You can see that maxR(i) <= maxR(i + 1) is true for every i. How values of this function changes by shift Down to Down-1? Every value maxR(Left) can only be the same (if segment(Down, Down, Left, maxR(Left)) only added new numbers), or it can decrease. When maxR(Left) is decreasing? Only when one of the numbers from added segment have already been in the current submatrix. Shift Down to down let's see all numbers in row Down. For each number (let it be in column j) find indices i and k so i <= j, there is number, equal to a[Down][j] between rows Up and Down-1, i — maximal; k >= j, there is number, equal to a[Down][j] between rows Up and Down-1, k — minimal. When you find these indices (it is easy to find them using set, when you store all columns where number x was between Up and Down for all numbers x), you can try to update maxR[i] with j — 1, maxR[j] with k — 1. It will be enough, if you also update for all i = m..1 maxR[i] = min(maxR[i], maxR[i + 1]). Now maxR(Left) is correct, and you can check answer for these Up and Down by O(n).4) Now, solution by O(n3). It requires understanding previous solution. Previous solution, despite good asymptotics, requires to store a lot (about 160 000) sets, where you will store about 160 000 elements. Even at n = 200 it works very slow. Let's get rid of log. Set is using only for finding nearest left and right elements, which are in rows from Up to Down, and equal to current. Note that when you do Up = Up — 1, nearest element comes near (by column) to a[i][j], so we can find all numbers, for which the nearest element will be in new row Up, and update them nearest number, and do that in O(n2). This solution uses O(n2) memory and O(n3) time.BONUS: Can you solve this task faster than O(n3)? I spend a lot of time and I didn't come to any solution, but I can't show that there is not solution faster.407E - k-d-sequenceIn this problem you have to find longest subsegment, satisfying the condition.Reduce problem to d = 1.If d = 0, then answer is longest subsegment from equal numbers, this case we solve separately. If d ≠ 0, then notice that if on some subsegment there are two numbers ai, aj so that ai%d ≠ aj%d, then this segment can't be good. Divide the sequence to consequent subsegments numbers, equal by modulo d, and divide each number by d, and solve task separately with every segment, consider that d = 1. Notice that segment [L, R] is good if and only if when max(L, R) — min(L, R) — (R — L) <= k, and there are no equal numbers. It is easy to exlain: if there are no equal numbers, then max(L, R) — min(L, R) — (R — L) is exactly number of numbers is needed to add for segment to consist of all numbers from min(L, R) to max(L, R). For all L lets find such maxR[L], that on segment [L..maxR[l]] there are no equal numbers, and maxR[L] is maximal. It can be done by O(nlogn) by many ways, for example you can use map. Let's learn how we can maintain array a[R] = max(L, R) — min(L, R) — (R — L). If we have such array, then we have to find rightmost R such that a[R] <= k to get an answer. We will need two stacks and segment tree with operations \"Add number on segment\", \"Find min element on segment\", \"Find rightmost number doesn't exceed k\". Let's iterate L from right to left (n downto 1). How does function max(L, R) look like with fixed L? It's values represent a set of segments so that maximum on the segment is leftmost element of segment, and these maximums are increasing. (example: for array 6 4 8 0 7 9 function max(1, R) will be 6 6 8 8 8 9). How function changes with shift L to left? Some segments are absorbed by new element, if new element is bigger than maximum on segment. Maximums on segments are increasing, so we can keep them all in stack, and when we need to add new element we have to only pop some segments from stacks while maximum on top of stack is less then new element, and push new segment after that. If every operation with stack will be accompanied with right operation with segment tree, we can store array a[R] = max(L, R). For get array a[R] = max(L, R) — min(L, R) we need only to maintain second similar stack. For get array a[R] = max(L, R) — min(L, R) we need add -1 on all suffix when we are shitfing L. Now query \"Find fightmost number less of equal k\". First, segment tree divides segment of request to log(n) segments with length powers of two. Let's choose rightmost segment with minimum <= k, and do iterative deeping there to find element that we need.So, for every L we get query on segment L..maxR(L) on rightmost number less or equal k. It is one of candidates to an answer. We are doing O(n) operation with stack, and every requires query to segment tree, so asymptotics is O(nlogn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11333",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 407\\s*E"
          },
          "content_length": 9077
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #239 - Codeforces - Code 1",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 2",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 3",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 4",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 5",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 6",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 7",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 8",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 1",
          "code": "dp[i] = 1 + (dp[p[i]]+1) + (dp[p[i]+1]+1) + ... + (dp[i-1]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 2",
          "code": "(dp[1]+1) + (dp[2]+1) + (dp[3]+1) + ... + (dp[n]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 3",
          "code": "s[p[k]]+s[p[k]+1]+s[p[k]+2]+...+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 4",
          "code": "s[k]=2+s[p[k]]+s[p[k]+1]+s[p[k]+2]+..+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 5",
          "code": "answer=s[1]+s[2]+..+s[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 6",
          "code": "dp[i] = the number of steps needed to move from room i to room (i + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 7",
          "code": "dp[i] = 2 + sum(dp[j]) for j in [p[i], i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 8",
          "code": "sum(dp[i]) for (1 ≤ i ≤ n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 200000, \"k\");\n    inf.readSpace();\n    int d = inf.readInt(0, 1000000000, \"d\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 200000, \"k\");\n    inf.readSpace();\n    int d = inf.readInt(0, 1000000000, \"d\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 200000, \"k\");\n    inf.readSpace();\n    int d = inf.readInt(0, 1000000000, \"d\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a;\n\n    if (type == \"one_element\") {\n        // n = 1\n        n = 1;\n        a.resize(n);\n        a[0] = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"two_elements\") {\n        // n = 2\n        n = 2;\n        a.resize(n);\n        a[0] = rnd.next(-1000000000, 1000000000);\n        a[1] = a[0] + d;\n        if (a[1] < -1000000000 || a[1] > 1000000000) {\n            a[1] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"equal\") {\n        // All elements are equal\n        int val = rnd.next(-1000000000, 1000000000);\n        a.resize(n, val);\n    } else if (type == \"arithmetic\") {\n        // The sequence is an arithmetic progression with common difference d\n        int start = rnd.next(-1000000000, 1000000000);\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = start + 1LL * i * d;\n            if (a[i] < -1000000000 || a[i] > 1000000000) {\n                a[i] = (a[i] % 2000000001) - 1000000000;\n            }\n        }\n    } else if (type == \"max_k_needed\") {\n        // Sequence needs exactly k insertions to become an arithmetic progression\n        int seq_len = n - k;\n        int start = rnd.next(-1000000000, 1000000000);\n        a.resize(n);\n        for(int i = 0; i < seq_len; ++i) {\n            a[i] = start + 1LL * i * d;\n        }\n        for(int i = seq_len; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"min_k_needed\") {\n        // Sequence is already an arithmetic progression, no insertions needed\n        int start = rnd.next(-1000000000, 1000000000);\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = start + 1LL * i * d;\n            if (a[i] < -1000000000 || a[i] > 1000000000) {\n                a[i] = (a[i] % 2000000001) - 1000000000;\n            }\n        }\n    } else if (type == \"d_zero\") {\n        // d = 0, sequence of same elements\n        int val = rnd.next(-1000000000, 1000000000);\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            if (rnd.next(0, n-1) < k) {\n                a[i] = rnd.next(-1000000000, 1000000000);\n            } else {\n                a[i] = val;\n            }\n        }\n    } else if (type == \"negative_numbers\") {\n        // All negative numbers\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, -1);\n        }\n    } else if (type == \"large_numbers\") {\n        // Numbers close to the limits\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1)) {\n                a[i] = rnd.next(1000000000 - 10000, 1000000000);\n            } else {\n                a[i] = rnd.next(-1000000000, -1000000000 + 10000);\n            }\n        }\n    } else if (type == \"multiple_optimal\") {\n        // Multiple optimal answers\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 0 : d;\n        }\n    } else {\n        // Random sequence\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n    }\n\n    printf(\"%d %d %d\\n\", n, k, d);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n-1) ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    int d = opt<int>(\"d\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a;\n\n    if (type == \"one_element\") {\n        // n = 1\n        n = 1;\n        a.resize(n);\n        a[0] = rnd.next(-1000000000, 1000000000);\n    } else if (type == \"two_elements\") {\n        // n = 2\n        n = 2;\n        a.resize(n);\n        a[0] = rnd.next(-1000000000, 1000000000);\n        a[1] = a[0] + d;\n        if (a[1] < -1000000000 || a[1] > 1000000000) {\n            a[1] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"equal\") {\n        // All elements are equal\n        int val = rnd.next(-1000000000, 1000000000);\n        a.resize(n, val);\n    } else if (type == \"arithmetic\") {\n        // The sequence is an arithmetic progression with common difference d\n        int start = rnd.next(-1000000000, 1000000000);\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = start + 1LL * i * d;\n            if (a[i] < -1000000000 || a[i] > 1000000000) {\n                a[i] = (a[i] % 2000000001) - 1000000000;\n            }\n        }\n    } else if (type == \"max_k_needed\") {\n        // Sequence needs exactly k insertions to become an arithmetic progression\n        int seq_len = n - k;\n        int start = rnd.next(-1000000000, 1000000000);\n        a.resize(n);\n        for(int i = 0; i < seq_len; ++i) {\n            a[i] = start + 1LL * i * d;\n        }\n        for(int i = seq_len; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"min_k_needed\") {\n        // Sequence is already an arithmetic progression, no insertions needed\n        int start = rnd.next(-1000000000, 1000000000);\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = start + 1LL * i * d;\n            if (a[i] < -1000000000 || a[i] > 1000000000) {\n                a[i] = (a[i] % 2000000001) - 1000000000;\n            }\n        }\n    } else if (type == \"d_zero\") {\n        // d = 0, sequence of same elements\n        int val = rnd.next(-1000000000, 1000000000);\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            if (rnd.next(0, n-1) < k) {\n                a[i] = rnd.next(-1000000000, 1000000000);\n            } else {\n                a[i] = val;\n            }\n        }\n    } else if (type == \"negative_numbers\") {\n        // All negative numbers\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, -1);\n        }\n    } else if (type == \"large_numbers\") {\n        // Numbers close to the limits\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1)) {\n                a[i] = rnd.next(1000000000 - 10000, 1000000000);\n            } else {\n                a[i] = rnd.next(-1000000000, -1000000000 + 10000);\n            }\n        }\n    } else if (type == \"multiple_optimal\") {\n        // Multiple optimal answers\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 0 : d;\n        }\n    } else {\n        // Random sequence\n        a.resize(n);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n    }\n\n    printf(\"%d %d %d\\n\", n, k, d);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n-1) ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -d 0 -type one_element\n./gen -n 2 -k 0 -d 0 -type two_elements\n./gen -n 10 -k 0 -d 0 -type equal\n./gen -n 10 -k 0 -d 0 -type d_zero\n./gen -n 10 -k 0 -d 1 -type arithmetic\n./gen -n 10 -k 5 -d 1 -type max_k_needed\n./gen -n 10 -k 2 -d 1 -type min_k_needed\n./gen -n 10 -k 10 -d 1 -type random\n./gen -n 100 -k 0 -d 0 -type equal\n./gen -n 100 -k 50 -d 5 -type max_k_needed\n./gen -n 100 -k 50 -d 0 -type d_zero\n./gen -n 100 -k 10 -d 5 -type min_k_needed\n./gen -n 1000 -k 500 -d 0 -type d_zero\n./gen -n 1000 -k 0 -d 1000000000 -type arithmetic\n./gen -n 1000 -k 100 -d 100 -type negative_numbers\n./gen -n 1000 -k 500 -d 0 -type large_numbers\n./gen -n 10000 -k 0 -d 0 -type equal\n./gen -n 10000 -k 5000 -d 10 -type random\n./gen -n 10000 -k 10000 -d 1 -type max_k_needed\n./gen -n 200000 -k 0 -d 0 -type equal\n./gen -n 200000 -k 0 -d 1 -type arithmetic\n./gen -n 200000 -k 200000 -d 0 -type random\n./gen -n 200000 -k 100000 -d 1 -type negative_numbers\n./gen -n 200000 -k 200000 -d 0 -type large_numbers\n./gen -n 200000 -k 0 -d 0 -type multiple_optimal\n./gen -n 200000 -k 0 -d 1 -type multiple_optimal\n./gen -n 100000 -k 50000 -d 100 -type random\n./gen -n 100000 -k 100000 -d 0 -type max_k_needed\n./gen -n 100000 -k 0 -d 0 -type min_k_needed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:40.275467",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "408/A",
      "title": "A. Line to Cashier",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 100) — the number of cashes in the shop. The second line contains n space-separated integers: k1, k2, ..., kn (1 ≤ ki ≤ 100), where ki is the number of people in the queue to the i-th cashier.The i-th of the next n lines contains ki space-separated integers: mi, 1, mi, 2, ..., mi, ki (1 ≤ mi, j ≤ 100) — the number of products the j-th person in the queue for the i-th cash has.",
      "output_spec": "OutputPrint a single integer — the minimum number of seconds Vasya needs to get to the cashier.",
      "sample_tests": "ExamplesInputCopy111OutputCopy20InputCopy41 4 3 21001 2 2 31 9 17 8OutputCopy100",
      "description": "A. Line to Cashier\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 100) — the number of cashes in the shop. The second line contains n space-separated integers: k1, k2, ..., kn (1 ≤ ki ≤ 100), where ki is the number of people in the queue to the i-th cashier.The i-th of the next n lines contains ki space-separated integers: mi, 1, mi, 2, ..., mi, ki (1 ≤ mi, j ≤ 100) — the number of products the j-th person in the queue for the i-th cash has.\n\nOutputPrint a single integer — the minimum number of seconds Vasya needs to get to the cashier.\n\nInputCopy111OutputCopy20InputCopy41 4 3 21001 2 2 31 9 17 8OutputCopy100\n\nInputCopy111\n\nOutputCopy20\n\nInputCopy41 4 3 21001 2 2 31 9 17 8\n\nOutputCopy100\n\nNoteIn the second test sample, if Vasya goes to the first queue, he gets to the cashier in 100·5 + 15 = 515 seconds. But if he chooses the second queue, he will need 1·5 + 2·5 + 2·5 + 3·5 + 4·15 = 100 seconds. He will need 1·5 + 9·5 + 1·5 + 3·15 = 100 seconds for the third one and 7·5 + 8·5 + 2·15 = 105 seconds for the fourth one. Thus, Vasya gets to the cashier quicker if he chooses the second or the third queue.",
      "solutions": [
        {
          "title": "Codeforces Round #239 - Codeforces",
          "content": "Hello everyone!This Sunday, on March 30 at 11:00 MSK (March 30 at 07:00 UTC), Codeforces Round #239 for both divisions participants will take place. Note the unusual time of the round.The problems have been prepared by me. I want to thank Codeforces team: tasks coordinator Gerald Agapov (Gerald) for invaluable contribution to the preparation of tasks and Maria Belova (Delinur), who has translated the problems. Also thank to Niyaz Nigmatullin (niyaznigmatul) for testing.I wish you all good luck and have a good weekend!UPD: You can see score distribution at the problems page.UPD2: You can find editorial here.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/11309",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 614
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces",
          "content": "Sorry for my poor English. If you find a mistake, write me a private message, I'll fix it. Some problems have not been translated yet, now you can try to read the Russian version of editorial with Google Translate.408A - Line to CashierIn this problem you were to find waiting the time for every queue by summing up the purchases of all the people, and return the minimum.408B - GarlandIn this problem it is necessary to find the garland with the maximal length, which can be composed of elements that we have. First, if you need some color, but you don't have it, then the answer is -1 Otherwise, answer is always exists. Let's sum the answers for all the colors separately. Suppose we have a pieces of a garland of some color, and we need b pieces. Then we have to add min(a, b) to the answer: if a >  = b we will use b 1 meter pieces, in the other case if a < b we will use all a pieces.407A - TriangleIn this problem you have to locate the right triangle with cathetuses a, b on a plane with its vertices in integer points. If the required layout exists, then cathetus a always can be represented as a vector with integer coordinates A{x;y}, and a2 = x2 + y2. Iterate over all possible x (1 ≤ x ≤ a - 1), check, that y = sqrt(a2 - x2) is integer. Vector, ortogonal to vector {x;y}, is { - y;x}. Take vector B{ - y / g;x / g}, where g = gcd(x, y). The triangle can be located on the plane if and only if b % |B| = 0, where |B| — length of vector B. The candidate for the answer — triangle (0;0)(x;y)( - y / g * b / |B|;x / g * b / |B|), but don't forget about checking that the hypotenuse isn't parallel to coordinate axes.407B - Long PathIn this problem you had to simulate route of character in graph. Note that if you are in vertice i, then edges in all vertices with numbers less than i are turned to pi. It gives us opportunity to see a recurrence formula: let dpi be number of steps, needed to get from vertice 1 to vertice i, if all edges are rotated back, into pi. Then dpi + 1 = 2dpi + 2 - dppi. Answer will be dpn + 1.BONUS: Can you solve this task without statement pi ≤ i? I don't know the solution, it seems difficult.407C - Curious ArrayIn this problem you had to find how to add binomial coefficients in array offline. Let's see, how problem changes due to increasing k from small to big values.1) All queries have K = 0 Every time you add 1 on subsegment. For solve this task you can add 1 at some array b[] in b[L] 1, then substract 1 from b[R+1], and after doing all queries make array a[] as array of prefix sums of array b[].2) All queries have K = 1 Arithmetic progression 1 2 3 4 ... is added on subsegment For solve this task you can add 1 at some array c[] in c[L] 1, then substract 1 from c[R+1], and after doing all queries make array b[] as array of prefix sums of array c[]. Actually you added 1 1 ... 1 on every subsegment at each query. If you will substract (R — L + 1) from c[R+1], and make array a[] as array of prefix sums of array b[], then it will be an answer: 1 1 ... 1 became 1 2 3 ... (R-L+1).3) K is arbitrary Summaring previous results one can see that if we will do a[K+1][L] += 1 a[j][R+1] -= C(k + 1 — j + r — l, k + 1 — j) for all 1 <= j <= K + 1 and after that do a[i][j] = a[i][j-1] + a[i+1][j] (making a[i] as array of prefix sums array a[i+1]), a[0] will be the answer. What is C(k + 1 — j + r — l, k + 1 — j)? This number is need for each query affect only on segment L..R, and you can see, why is it so, in Pascal's Triangle.If this explanation is not clear for you, you can try to see other participants solutions (for example, Xellos's one).407D - Largest Submatrix 3In this task you have to find largest by area submatrix, consisting from different numbers. Let's see solutions from slow to fast.1) Solution by O(n6): Iterate through two opposite vertices submatrix-answer and check that all numbers are different.2) Solution by O(n4): Let's fix Up and Down borders submatrix-answer (O(n2)). Use two pointers method to iterate Left and Right borders: while in submatrix there are no equal numbers, increment Right, while there are equal numbers — increment Left. Every check — (O(n)), increments — (O(n)).3) Solution by O(n3logn): Let's construct function maxR(Left) (let's consider that Up <= Down are fixed): maximal value Right, so that in submatrix (Up, Down, Left, Right) there is no equals numbers. You can see that maxR(i) <= maxR(i + 1) is true for every i. How values of this function changes by shift Down to Down-1? Every value maxR(Left) can only be the same (if segment(Down, Down, Left, maxR(Left)) only added new numbers), or it can decrease. When maxR(Left) is decreasing? Only when one of the numbers from added segment have already been in the current submatrix. Shift Down to down let's see all numbers in row Down. For each number (let it be in column j) find indices i and k so i <= j, there is number, equal to a[Down][j] between rows Up and Down-1, i — maximal; k >= j, there is number, equal to a[Down][j] between rows Up and Down-1, k — minimal. When you find these indices (it is easy to find them using set, when you store all columns where number x was between Up and Down for all numbers x), you can try to update maxR[i] with j — 1, maxR[j] with k — 1. It will be enough, if you also update for all i = m..1 maxR[i] = min(maxR[i], maxR[i + 1]). Now maxR(Left) is correct, and you can check answer for these Up and Down by O(n).4) Now, solution by O(n3). It requires understanding previous solution. Previous solution, despite good asymptotics, requires to store a lot (about 160 000) sets, where you will store about 160 000 elements. Even at n = 200 it works very slow. Let's get rid of log. Set is using only for finding nearest left and right elements, which are in rows from Up to Down, and equal to current. Note that when you do Up = Up — 1, nearest element comes near (by column) to a[i][j], so we can find all numbers, for which the nearest element will be in new row Up, and update them nearest number, and do that in O(n2). This solution uses O(n2) memory and O(n3) time.BONUS: Can you solve this task faster than O(n3)? I spend a lot of time and I didn't come to any solution, but I can't show that there is not solution faster.407E - k-d-sequenceIn this problem you have to find longest subsegment, satisfying the condition.Reduce problem to d = 1.If d = 0, then answer is longest subsegment from equal numbers, this case we solve separately. If d ≠ 0, then notice that if on some subsegment there are two numbers ai, aj so that ai%d ≠ aj%d, then this segment can't be good. Divide the sequence to consequent subsegments numbers, equal by modulo d, and divide each number by d, and solve task separately with every segment, consider that d = 1. Notice that segment [L, R] is good if and only if when max(L, R) — min(L, R) — (R — L) <= k, and there are no equal numbers. It is easy to exlain: if there are no equal numbers, then max(L, R) — min(L, R) — (R — L) is exactly number of numbers is needed to add for segment to consist of all numbers from min(L, R) to max(L, R). For all L lets find such maxR[L], that on segment [L..maxR[l]] there are no equal numbers, and maxR[L] is maximal. It can be done by O(nlogn) by many ways, for example you can use map. Let's learn how we can maintain array a[R] = max(L, R) — min(L, R) — (R — L). If we have such array, then we have to find rightmost R such that a[R] <= k to get an answer. We will need two stacks and segment tree with operations \"Add number on segment\", \"Find min element on segment\", \"Find rightmost number doesn't exceed k\". Let's iterate L from right to left (n downto 1). How does function max(L, R) look like with fixed L? It's values represent a set of segments so that maximum on the segment is leftmost element of segment, and these maximums are increasing. (example: for array 6 4 8 0 7 9 function max(1, R) will be 6 6 8 8 8 9). How function changes with shift L to left? Some segments are absorbed by new element, if new element is bigger than maximum on segment. Maximums on segments are increasing, so we can keep them all in stack, and when we need to add new element we have to only pop some segments from stacks while maximum on top of stack is less then new element, and push new segment after that. If every operation with stack will be accompanied with right operation with segment tree, we can store array a[R] = max(L, R). For get array a[R] = max(L, R) — min(L, R) we need only to maintain second similar stack. For get array a[R] = max(L, R) — min(L, R) we need add -1 on all suffix when we are shitfing L. Now query \"Find fightmost number less of equal k\". First, segment tree divides segment of request to log(n) segments with length powers of two. Let's choose rightmost segment with minimum <= k, and do iterative deeping there to find element that we need.So, for every L we get query on segment L..maxR(L) on rightmost number less or equal k. It is one of candidates to an answer. We are doing O(n) operation with stack, and every requires query to segment tree, so asymptotics is O(nlogn).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/11333",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 408\\s*A"
          },
          "content_length": 9077
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #239 - Codeforces - Code 1",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 2",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 3",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 4",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 5",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 6",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 7",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 8",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 1",
          "code": "dp[i] = 1 + (dp[p[i]]+1) + (dp[p[i]+1]+1) + ... + (dp[i-1]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 2",
          "code": "(dp[1]+1) + (dp[2]+1) + (dp[3]+1) + ... + (dp[n]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 3",
          "code": "s[p[k]]+s[p[k]+1]+s[p[k]+2]+...+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 4",
          "code": "s[k]=2+s[p[k]]+s[p[k]+1]+s[p[k]+2]+..+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 5",
          "code": "answer=s[1]+s[2]+..+s[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 6",
          "code": "dp[i] = the number of steps needed to move from room i to room (i + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 7",
          "code": "dp[i] = 2 + sum(dp[j]) for j in [p[i], i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 8",
          "code": "sum(dp[i]) for (1 ≤ i ≤ n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    vector<int> k = inf.readInts(n, 1, 100, \"k\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        vector<int> mi = inf.readInts(k[i], 1, 100, \"mi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    vector<int> k = inf.readInts(n, 1, 100, \"k\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        vector<int> mi = inf.readInts(k[i], 1, 100, \"mi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    vector<int> k = inf.readInts(n, 1, 100, \"k\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        vector<int> mi = inf.readInts(k[i], 1, 100, \"mi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> k;\n    vector<vector<int>> m;\n\n    if (type == \"random\") {\n        // Generate random n, ki, m_i,j\n        for (int i = 0; i < n; i++) {\n            int ki = rnd.next(1, 100);\n            k.push_back(ki);\n            vector<int> mi;\n            for (int j = 0; j < ki; j++) {\n                int mij = rnd.next(1, 100);\n                mi.push_back(mij);\n            }\n            m.push_back(mi);\n        }\n    } else if (type == \"max\") {\n        n = min(n, 100);\n        for (int i = 0; i < n; i++) {\n            int ki = 100;\n            k.push_back(ki);\n            vector<int> mi(ki, 100);\n            m.push_back(mi);\n        }\n    } else if (type == \"min\") {\n        n = max(n, 1);\n        for (int i = 0; i < n; i++) {\n            int ki = 1;\n            k.push_back(ki);\n            vector<int> mi(ki,1);\n            m.push_back(mi);\n        }\n    } else if (type == \"longest_time\") {\n        n = min(n, 100);\n        for (int i = 0; i < n; i++) {\n            int ki = 100;\n            k.push_back(ki);\n            vector<int> mi(ki, 100);\n            m.push_back(mi);\n        }\n    } else if (type == \"shortest_time\") {\n        int min_queue = rnd.next(0, n-1);\n        for (int i = 0; i < n; i++) {\n            if (i == min_queue) {\n                int ki = 1;\n                k.push_back(ki);\n                vector<int> mi(1, 1); // minimal time\n                m.push_back(mi);\n            } else {\n                int ki = rnd.next(1, 100);\n                k.push_back(ki);\n                vector<int> mi;\n                for (int j = 0; j < ki; j++) {\n                    int mij = rnd.next(50, 100);\n                    mi.push_back(mij);\n                }\n                m.push_back(mi);\n            }\n        }\n    } else if (type == \"off_by_one\") {\n        // Generate test cases to catch off by one errors\n        for (int i = 0; i < n; ++i) {\n            int ki;\n            if (i % 2 == 0) {\n                ki = 1;\n            } else {\n                ki = 100;\n            }\n            k.push_back(ki);\n            vector<int> mi;\n            for (int j = 0; j < ki; ++j) {\n                int mij;\n                if (j == 0 || j == ki -1) {\n                    // Edge cases\n                    mij = 1;\n                } else {\n                    mij = rnd.next(1, 100);\n                }\n                mi.push_back(mij);\n            }\n            m.push_back(mi);\n        }\n    } else {\n        // default random\n        for (int i = 0; i < n; i++) {\n            int ki = rnd.next(1, 100);\n            k.push_back(ki);\n            vector<int> mi;\n            for (int j = 0; j < ki; j++) {\n                int mij = rnd.next(1, 100);\n                mi.push_back(mij);\n            }\n            m.push_back(mi);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", k[i]);\n        if (i != n -1) printf(\" \");\n    }\n    printf(\"\\n\");\n    // Now output m_i,j\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < k[i]; j++) {\n            printf(\"%d\", m[i][j]);\n            if (j != k[i]-1) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> k;\n    vector<vector<int>> m;\n\n    if (type == \"random\") {\n        // Generate random n, ki, m_i,j\n        for (int i = 0; i < n; i++) {\n            int ki = rnd.next(1, 100);\n            k.push_back(ki);\n            vector<int> mi;\n            for (int j = 0; j < ki; j++) {\n                int mij = rnd.next(1, 100);\n                mi.push_back(mij);\n            }\n            m.push_back(mi);\n        }\n    } else if (type == \"max\") {\n        n = min(n, 100);\n        for (int i = 0; i < n; i++) {\n            int ki = 100;\n            k.push_back(ki);\n            vector<int> mi(ki, 100);\n            m.push_back(mi);\n        }\n    } else if (type == \"min\") {\n        n = max(n, 1);\n        for (int i = 0; i < n; i++) {\n            int ki = 1;\n            k.push_back(ki);\n            vector<int> mi(ki,1);\n            m.push_back(mi);\n        }\n    } else if (type == \"longest_time\") {\n        n = min(n, 100);\n        for (int i = 0; i < n; i++) {\n            int ki = 100;\n            k.push_back(ki);\n            vector<int> mi(ki, 100);\n            m.push_back(mi);\n        }\n    } else if (type == \"shortest_time\") {\n        int min_queue = rnd.next(0, n-1);\n        for (int i = 0; i < n; i++) {\n            if (i == min_queue) {\n                int ki = 1;\n                k.push_back(ki);\n                vector<int> mi(1, 1); // minimal time\n                m.push_back(mi);\n            } else {\n                int ki = rnd.next(1, 100);\n                k.push_back(ki);\n                vector<int> mi;\n                for (int j = 0; j < ki; j++) {\n                    int mij = rnd.next(50, 100);\n                    mi.push_back(mij);\n                }\n                m.push_back(mi);\n            }\n        }\n    } else if (type == \"off_by_one\") {\n        // Generate test cases to catch off by one errors\n        for (int i = 0; i < n; ++i) {\n            int ki;\n            if (i % 2 == 0) {\n                ki = 1;\n            } else {\n                ki = 100;\n            }\n            k.push_back(ki);\n            vector<int> mi;\n            for (int j = 0; j < ki; ++j) {\n                int mij;\n                if (j == 0 || j == ki -1) {\n                    // Edge cases\n                    mij = 1;\n                } else {\n                    mij = rnd.next(1, 100);\n                }\n                mi.push_back(mij);\n            }\n            m.push_back(mi);\n        }\n    } else {\n        // default random\n        for (int i = 0; i < n; i++) {\n            int ki = rnd.next(1, 100);\n            k.push_back(ki);\n            vector<int> mi;\n            for (int j = 0; j < ki; j++) {\n                int mij = rnd.next(1, 100);\n                mi.push_back(mij);\n            }\n            m.push_back(mi);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", k[i]);\n        if (i != n -1) printf(\" \");\n    }\n    printf(\"\\n\");\n    // Now output m_i,j\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < k[i]; j++) {\n            printf(\"%d\", m[i][j]);\n            if (j != k[i]-1) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min\n./gen -n 2 -type min\n./gen -n 5 -type min\n./gen -n 10 -type min\n./gen -n 1 -type max\n./gen -n 2 -type max\n./gen -n 5 -type max\n./gen -n 10 -type max\n./gen -n 50 -type random\n./gen -n 100 -type random\n./gen -n 75 -type random\n./gen -n 25 -type random\n./gen -n 100 -type longest_time\n./gen -n 50 -type longest_time\n./gen -n 100 -type shortest_time\n./gen -n 50 -type shortest_time\n./gen -n 25 -type shortest_time\n./gen -n 1 -type off_by_one\n./gen -n 2 -type off_by_one\n./gen -n 5 -type off_by_one\n./gen -n 10 -type off_by_one\n./gen -n 100 -type off_by_one\n./gen -n 50 -type off_by_one\n./gen -n 75 -type off_by_one\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 100 -type min\n./gen -n 100 -type max\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:42.303760",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "408/B",
      "title": "B. Garland",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a non-empty sequence of n (1 ≤ n ≤ 1000) small English letters (\"a\"...\"z\"). Each letter means that Vasya has a sheet of paper of the corresponding color.The second line contains a non-empty sequence of m (1 ≤ m ≤ 1000) small English letters that correspond to the colors of the pieces of paper in the garland that Vasya wants to make.",
      "output_spec": "OutputPrint an integer that is the maximum possible total area of the pieces of paper in the garland Vasya wants to get or -1, if it is impossible to make the garland from the sheets he's got. It is guaranteed that the answer is always an integer.",
      "sample_tests": "ExamplesInputCopyaaabbacaabbccacOutputCopy6InputCopyazOutputCopy-1",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a non-empty sequence of n (1 ≤ n ≤ 1000) small English letters (\"a\"...\"z\"). Each letter means that Vasya has a sheet of paper of the corresponding color.The second line contains a non-empty sequence of m (1 ≤ m ≤ 1000) small English letters that correspond to the colors of the pieces of paper in the garland that Vasya wants to make.\n\nOutputPrint an integer that is the maximum possible total area of the pieces of paper in the garland Vasya wants to get or -1, if it is impossible to make the garland from the sheets he's got. It is guaranteed that the answer is always an integer.\n\nInputCopyaaabbacaabbccacOutputCopy6InputCopyazOutputCopy-1\n\nInputCopyaaabbacaabbccac\n\nOutputCopy6\n\nInputCopyaz\n\nOutputCopy-1\n\nNoteIn the first test sample Vasya can make an garland of area 6: he can use both sheets of color b, three (but not four) sheets of color a and cut a single sheet of color c in three, for example, equal pieces. Vasya can use the resulting pieces to make a garland of area 6.In the second test sample Vasya cannot make a garland at all — he doesn't have a sheet of color z.",
      "solutions": [
        {
          "title": "Codeforces Round #239 - Codeforces",
          "content": "Hello everyone!This Sunday, on March 30 at 11:00 MSK (March 30 at 07:00 UTC), Codeforces Round #239 for both divisions participants will take place. Note the unusual time of the round.The problems have been prepared by me. I want to thank Codeforces team: tasks coordinator Gerald Agapov (Gerald) for invaluable contribution to the preparation of tasks and Maria Belova (Delinur), who has translated the problems. Also thank to Niyaz Nigmatullin (niyaznigmatul) for testing.I wish you all good luck and have a good weekend!UPD: You can see score distribution at the problems page.UPD2: You can find editorial here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11309",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 614
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces",
          "content": "Sorry for my poor English. If you find a mistake, write me a private message, I'll fix it. Some problems have not been translated yet, now you can try to read the Russian version of editorial with Google Translate.408A - Line to CashierIn this problem you were to find waiting the time for every queue by summing up the purchases of all the people, and return the minimum.408B - GarlandIn this problem it is necessary to find the garland with the maximal length, which can be composed of elements that we have. First, if you need some color, but you don't have it, then the answer is -1 Otherwise, answer is always exists. Let's sum the answers for all the colors separately. Suppose we have a pieces of a garland of some color, and we need b pieces. Then we have to add min(a, b) to the answer: if a >  = b we will use b 1 meter pieces, in the other case if a < b we will use all a pieces.407A - TriangleIn this problem you have to locate the right triangle with cathetuses a, b on a plane with its vertices in integer points. If the required layout exists, then cathetus a always can be represented as a vector with integer coordinates A{x;y}, and a2 = x2 + y2. Iterate over all possible x (1 ≤ x ≤ a - 1), check, that y = sqrt(a2 - x2) is integer. Vector, ortogonal to vector {x;y}, is { - y;x}. Take vector B{ - y / g;x / g}, where g = gcd(x, y). The triangle can be located on the plane if and only if b % |B| = 0, where |B| — length of vector B. The candidate for the answer — triangle (0;0)(x;y)( - y / g * b / |B|;x / g * b / |B|), but don't forget about checking that the hypotenuse isn't parallel to coordinate axes.407B - Long PathIn this problem you had to simulate route of character in graph. Note that if you are in vertice i, then edges in all vertices with numbers less than i are turned to pi. It gives us opportunity to see a recurrence formula: let dpi be number of steps, needed to get from vertice 1 to vertice i, if all edges are rotated back, into pi. Then dpi + 1 = 2dpi + 2 - dppi. Answer will be dpn + 1.BONUS: Can you solve this task without statement pi ≤ i? I don't know the solution, it seems difficult.407C - Curious ArrayIn this problem you had to find how to add binomial coefficients in array offline. Let's see, how problem changes due to increasing k from small to big values.1) All queries have K = 0 Every time you add 1 on subsegment. For solve this task you can add 1 at some array b[] in b[L] 1, then substract 1 from b[R+1], and after doing all queries make array a[] as array of prefix sums of array b[].2) All queries have K = 1 Arithmetic progression 1 2 3 4 ... is added on subsegment For solve this task you can add 1 at some array c[] in c[L] 1, then substract 1 from c[R+1], and after doing all queries make array b[] as array of prefix sums of array c[]. Actually you added 1 1 ... 1 on every subsegment at each query. If you will substract (R — L + 1) from c[R+1], and make array a[] as array of prefix sums of array b[], then it will be an answer: 1 1 ... 1 became 1 2 3 ... (R-L+1).3) K is arbitrary Summaring previous results one can see that if we will do a[K+1][L] += 1 a[j][R+1] -= C(k + 1 — j + r — l, k + 1 — j) for all 1 <= j <= K + 1 and after that do a[i][j] = a[i][j-1] + a[i+1][j] (making a[i] as array of prefix sums array a[i+1]), a[0] will be the answer. What is C(k + 1 — j + r — l, k + 1 — j)? This number is need for each query affect only on segment L..R, and you can see, why is it so, in Pascal's Triangle.If this explanation is not clear for you, you can try to see other participants solutions (for example, Xellos's one).407D - Largest Submatrix 3In this task you have to find largest by area submatrix, consisting from different numbers. Let's see solutions from slow to fast.1) Solution by O(n6): Iterate through two opposite vertices submatrix-answer and check that all numbers are different.2) Solution by O(n4): Let's fix Up and Down borders submatrix-answer (O(n2)). Use two pointers method to iterate Left and Right borders: while in submatrix there are no equal numbers, increment Right, while there are equal numbers — increment Left. Every check — (O(n)), increments — (O(n)).3) Solution by O(n3logn): Let's construct function maxR(Left) (let's consider that Up <= Down are fixed): maximal value Right, so that in submatrix (Up, Down, Left, Right) there is no equals numbers. You can see that maxR(i) <= maxR(i + 1) is true for every i. How values of this function changes by shift Down to Down-1? Every value maxR(Left) can only be the same (if segment(Down, Down, Left, maxR(Left)) only added new numbers), or it can decrease. When maxR(Left) is decreasing? Only when one of the numbers from added segment have already been in the current submatrix. Shift Down to down let's see all numbers in row Down. For each number (let it be in column j) find indices i and k so i <= j, there is number, equal to a[Down][j] between rows Up and Down-1, i — maximal; k >= j, there is number, equal to a[Down][j] between rows Up and Down-1, k — minimal. When you find these indices (it is easy to find them using set, when you store all columns where number x was between Up and Down for all numbers x), you can try to update maxR[i] with j — 1, maxR[j] with k — 1. It will be enough, if you also update for all i = m..1 maxR[i] = min(maxR[i], maxR[i + 1]). Now maxR(Left) is correct, and you can check answer for these Up and Down by O(n).4) Now, solution by O(n3). It requires understanding previous solution. Previous solution, despite good asymptotics, requires to store a lot (about 160 000) sets, where you will store about 160 000 elements. Even at n = 200 it works very slow. Let's get rid of log. Set is using only for finding nearest left and right elements, which are in rows from Up to Down, and equal to current. Note that when you do Up = Up — 1, nearest element comes near (by column) to a[i][j], so we can find all numbers, for which the nearest element will be in new row Up, and update them nearest number, and do that in O(n2). This solution uses O(n2) memory and O(n3) time.BONUS: Can you solve this task faster than O(n3)? I spend a lot of time and I didn't come to any solution, but I can't show that there is not solution faster.407E - k-d-sequenceIn this problem you have to find longest subsegment, satisfying the condition.Reduce problem to d = 1.If d = 0, then answer is longest subsegment from equal numbers, this case we solve separately. If d ≠ 0, then notice that if on some subsegment there are two numbers ai, aj so that ai%d ≠ aj%d, then this segment can't be good. Divide the sequence to consequent subsegments numbers, equal by modulo d, and divide each number by d, and solve task separately with every segment, consider that d = 1. Notice that segment [L, R] is good if and only if when max(L, R) — min(L, R) — (R — L) <= k, and there are no equal numbers. It is easy to exlain: if there are no equal numbers, then max(L, R) — min(L, R) — (R — L) is exactly number of numbers is needed to add for segment to consist of all numbers from min(L, R) to max(L, R). For all L lets find such maxR[L], that on segment [L..maxR[l]] there are no equal numbers, and maxR[L] is maximal. It can be done by O(nlogn) by many ways, for example you can use map. Let's learn how we can maintain array a[R] = max(L, R) — min(L, R) — (R — L). If we have such array, then we have to find rightmost R such that a[R] <= k to get an answer. We will need two stacks and segment tree with operations \"Add number on segment\", \"Find min element on segment\", \"Find rightmost number doesn't exceed k\". Let's iterate L from right to left (n downto 1). How does function max(L, R) look like with fixed L? It's values represent a set of segments so that maximum on the segment is leftmost element of segment, and these maximums are increasing. (example: for array 6 4 8 0 7 9 function max(1, R) will be 6 6 8 8 8 9). How function changes with shift L to left? Some segments are absorbed by new element, if new element is bigger than maximum on segment. Maximums on segments are increasing, so we can keep them all in stack, and when we need to add new element we have to only pop some segments from stacks while maximum on top of stack is less then new element, and push new segment after that. If every operation with stack will be accompanied with right operation with segment tree, we can store array a[R] = max(L, R). For get array a[R] = max(L, R) — min(L, R) we need only to maintain second similar stack. For get array a[R] = max(L, R) — min(L, R) we need add -1 on all suffix when we are shitfing L. Now query \"Find fightmost number less of equal k\". First, segment tree divides segment of request to log(n) segments with length powers of two. Let's choose rightmost segment with minimum <= k, and do iterative deeping there to find element that we need.So, for every L we get query on segment L..maxR(L) on rightmost number less or equal k. It is one of candidates to an answer. We are doing O(n) operation with stack, and every requires query to segment tree, so asymptotics is O(nlogn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11333",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 408\\s*B"
          },
          "content_length": 9077
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #239 - Codeforces - Code 1",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 2",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 3",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 4",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 5",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 6",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 7",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 8",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 1",
          "code": "dp[i] = 1 + (dp[p[i]]+1) + (dp[p[i]+1]+1) + ... + (dp[i-1]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 2",
          "code": "(dp[1]+1) + (dp[2]+1) + (dp[3]+1) + ... + (dp[n]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 3",
          "code": "s[p[k]]+s[p[k]+1]+s[p[k]+2]+...+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 4",
          "code": "s[k]=2+s[p[k]]+s[p[k]+1]+s[p[k]+2]+..+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 5",
          "code": "answer=s[1]+s[2]+..+s[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 6",
          "code": "dp[i] = the number of steps needed to move from room i to room (i + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 7",
          "code": "dp[i] = 2 + sum(dp[j]) for j in [p[i], i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 8",
          "code": "sum(dp[i]) for (1 ≤ i ≤ n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,1000}\", \"s\");\n    string t = inf.readLine(\"[a-z]{1,1000}\", \"t\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,1000}\", \"s\");\n    string t = inf.readLine(\"[a-z]{1,1000}\", \"t\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[a-z]{1,1000}\", \"s\");\n    string t = inf.readLine(\"[a-z]{1,1000}\", \"t\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\"); // number of available sheets\n    int m = opt<int>(\"m\"); // number of required pieces\n    string type = opt<string>(\"type\", \"random\"); // test case type\n    vector<char> available_sheets;\n    vector<char> required_pieces;\n\n    if (type == \"random\") {\n        // Generate random letters for available sheets\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            available_sheets.push_back(c);\n        }\n        // Ensure that required_pieces colors are selected from available_sheets\n        set<char> available_colors(available_sheets.begin(), available_sheets.end());\n        vector<char> colors(available_colors.begin(), available_colors.end());\n        for (int i = 0; i < m; ++i) {\n            if (colors.empty()) {\n                required_pieces.push_back('a' + rnd.next(26));\n            } else {\n                required_pieces.push_back(colors[rnd.next(colors.size())]);\n            }\n        }\n    }\n    else if (type == \"impossible\") {\n        // Generate available_sheets with letters not covering all required colors\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            available_sheets.push_back(c);\n        }\n        // Generate required_pieces containing at least one letter not in available_sheets\n        set<char> available_colors(available_sheets.begin(), available_sheets.end());\n        vector<char> missing_colors;\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (available_colors.find(c) == available_colors.end()) {\n                missing_colors.push_back(c);\n            }\n        }\n        if (missing_colors.empty()) {\n            // Ensure at least one missing color\n            char c = available_sheets[0];\n            available_sheets[0] = (c == 'a' ? 'b' : 'a');\n            missing_colors.push_back(c);\n        }\n        // Add at least one missing color to required_pieces\n        required_pieces.push_back(missing_colors[rnd.next(missing_colors.size())]);\n        for (int i = 1; i < m; ++i) {\n            required_pieces.push_back(available_sheets[rnd.next(available_sheets.size())]);\n        }\n    }\n    else if (type == \"max_area\") {\n        // Generate required_pieces and ensure available_sheets cover required counts\n        map<char, int> required_counts;\n        for (int i = 0; i < m; ++i) {\n            char c = 'a' + rnd.next(26);\n            required_pieces.push_back(c);\n            required_counts[c]++;\n        }\n        for (auto& p : required_counts) {\n            for (int i = 0; i < p.second; ++i) {\n                if ((int)available_sheets.size() < n) {\n                    available_sheets.push_back(p.first);\n                } else {\n                    break;\n                }\n            }\n            if ((int)available_sheets.size() >= n) break;\n        }\n        // Fill remaining available sheets with random letters\n        while ((int)available_sheets.size() < n) {\n            char c = 'a' + rnd.next(26);\n            available_sheets.push_back(c);\n        }\n    }\n    else if (type == \"minimal_area\") {\n        // Generate few available sheets and more required pieces\n        int num_colors = rnd.next(1, min(n, 26));\n        vector<char> colors;\n        for (int i = 0; i < num_colors; ++i) {\n            char c = 'a' + i;\n            colors.push_back(c);\n            available_sheets.push_back(c);\n        }\n        while ((int)available_sheets.size() < n) {\n            available_sheets.push_back(colors[rnd.next(colors.size())]);\n        }\n        for (int i = 0; i < m; ++i) {\n            required_pieces.push_back(colors[rnd.next(colors.size())]);\n        }\n    }\n    else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            available_sheets.push_back(c);\n        }\n        for (int i = 0; i < m; ++i) {\n            char c = 'a' + rnd.next(26);\n            required_pieces.push_back(c);\n        }\n    }\n\n    // Output the test case\n    for (char c : available_sheets)\n        printf(\"%c\", c);\n    printf(\"\\n\");\n    for (char c : required_pieces)\n        printf(\"%c\", c);\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\"); // number of available sheets\n    int m = opt<int>(\"m\"); // number of required pieces\n    string type = opt<string>(\"type\", \"random\"); // test case type\n    vector<char> available_sheets;\n    vector<char> required_pieces;\n\n    if (type == \"random\") {\n        // Generate random letters for available sheets\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            available_sheets.push_back(c);\n        }\n        // Ensure that required_pieces colors are selected from available_sheets\n        set<char> available_colors(available_sheets.begin(), available_sheets.end());\n        vector<char> colors(available_colors.begin(), available_colors.end());\n        for (int i = 0; i < m; ++i) {\n            if (colors.empty()) {\n                required_pieces.push_back('a' + rnd.next(26));\n            } else {\n                required_pieces.push_back(colors[rnd.next(colors.size())]);\n            }\n        }\n    }\n    else if (type == \"impossible\") {\n        // Generate available_sheets with letters not covering all required colors\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            available_sheets.push_back(c);\n        }\n        // Generate required_pieces containing at least one letter not in available_sheets\n        set<char> available_colors(available_sheets.begin(), available_sheets.end());\n        vector<char> missing_colors;\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (available_colors.find(c) == available_colors.end()) {\n                missing_colors.push_back(c);\n            }\n        }\n        if (missing_colors.empty()) {\n            // Ensure at least one missing color\n            char c = available_sheets[0];\n            available_sheets[0] = (c == 'a' ? 'b' : 'a');\n            missing_colors.push_back(c);\n        }\n        // Add at least one missing color to required_pieces\n        required_pieces.push_back(missing_colors[rnd.next(missing_colors.size())]);\n        for (int i = 1; i < m; ++i) {\n            required_pieces.push_back(available_sheets[rnd.next(available_sheets.size())]);\n        }\n    }\n    else if (type == \"max_area\") {\n        // Generate required_pieces and ensure available_sheets cover required counts\n        map<char, int> required_counts;\n        for (int i = 0; i < m; ++i) {\n            char c = 'a' + rnd.next(26);\n            required_pieces.push_back(c);\n            required_counts[c]++;\n        }\n        for (auto& p : required_counts) {\n            for (int i = 0; i < p.second; ++i) {\n                if ((int)available_sheets.size() < n) {\n                    available_sheets.push_back(p.first);\n                } else {\n                    break;\n                }\n            }\n            if ((int)available_sheets.size() >= n) break;\n        }\n        // Fill remaining available sheets with random letters\n        while ((int)available_sheets.size() < n) {\n            char c = 'a' + rnd.next(26);\n            available_sheets.push_back(c);\n        }\n    }\n    else if (type == \"minimal_area\") {\n        // Generate few available sheets and more required pieces\n        int num_colors = rnd.next(1, min(n, 26));\n        vector<char> colors;\n        for (int i = 0; i < num_colors; ++i) {\n            char c = 'a' + i;\n            colors.push_back(c);\n            available_sheets.push_back(c);\n        }\n        while ((int)available_sheets.size() < n) {\n            available_sheets.push_back(colors[rnd.next(colors.size())]);\n        }\n        for (int i = 0; i < m; ++i) {\n            required_pieces.push_back(colors[rnd.next(colors.size())]);\n        }\n    }\n    else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            available_sheets.push_back(c);\n        }\n        for (int i = 0; i < m; ++i) {\n            char c = 'a' + rnd.next(26);\n            required_pieces.push_back(c);\n        }\n    }\n\n    // Output the test case\n    for (char c : available_sheets)\n        printf(\"%c\", c);\n    printf(\"\\n\");\n    for (char c : required_pieces)\n        printf(\"%c\", c);\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases\n./gen -n 10 -m 10 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 1000 -m 1000 -type random\n\n# Impossible test cases\n./gen -n 10 -m 15 -type impossible\n./gen -n 50 -m 100 -type impossible\n./gen -n 500 -m 1000 -type impossible\n\n# Max area test cases\n./gen -n 10 -m 10 -type max_area\n./gen -n 50 -m 50 -type max_area\n./gen -n 100 -m 100 -type max_area\n./gen -n 500 -m 500 -type max_area\n\n# Minimal area test cases\n./gen -n 10 -m 100 -type minimal_area\n./gen -n 50 -m 500 -type minimal_area\n./gen -n 100 -m 1000 -type minimal_area\n\n# Edge cases\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1000 -type minimal_area\n./gen -n 1000 -m 1 -type random\n\n# Cases where available sheets exactly cover required pieces\n./gen -n 500 -m 800 -type max_area\n\n# Cases where required colors are missing in available sheets\n./gen -n 100 -m 500 -type impossible\n\n# Complete alphabet used\n./gen -n 1000 -m 1000 -type max_area\n\n# Random large test case\n./gen -n 1000 -m 1000 -type random\n\n# Additional test cases for thorough coverage\n./gen -n 999 -m 1000 -type minimal_area\n./gen -n 1000 -m 999 -type max_area\n./gen -n 1 -m 1 -type impossible\n./gen -n 1 -m 1 -type max_area\n\n# Tests with maximum letters\n./gen -n 1000 -m 1000 -type maximal_letters\n\n# Random test cases with small n and m\n./gen -n 2 -m 2 -type random\n./gen -n 5 -m 10 -type minimal_area\n./gen -n 10 -m 5 -type max_area\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:44.425140",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "408/C",
      "title": "C. Triangle",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers a, b (1 ≤ a, b ≤ 1000), separated by a single space.",
      "output_spec": "OutputIn the first line print either \"YES\" or \"NO\" (without the quotes) depending on whether the required location exists. If it does, print in the next three lines three pairs of integers — the coordinates of the triangle vertices, one pair per line. The coordinates must be integers, not exceeding 109 in their absolute value.",
      "sample_tests": "ExamplesInputCopy1 1OutputCopyNOInputCopy5 5OutputCopyYES2 15 5-2 4InputCopy5 10OutputCopyYES-10 4-2 -21 2",
      "description": "C. Triangle\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers a, b (1 ≤ a, b ≤ 1000), separated by a single space.\n\nOutputIn the first line print either \"YES\" or \"NO\" (without the quotes) depending on whether the required location exists. If it does, print in the next three lines three pairs of integers — the coordinates of the triangle vertices, one pair per line. The coordinates must be integers, not exceeding 109 in their absolute value.\n\nInputCopy1 1OutputCopyNOInputCopy5 5OutputCopyYES2 15 5-2 4InputCopy5 10OutputCopyYES-10 4-2 -21 2\n\nInputCopy1 1\n\nOutputCopyNO\n\nInputCopy5 5\n\nOutputCopyYES2 15 5-2 4\n\nInputCopy5 10\n\nOutputCopyYES-10 4-2 -21 2",
      "solutions": [
        {
          "title": "Codeforces Round #239 - Codeforces",
          "content": "Hello everyone!This Sunday, on March 30 at 11:00 MSK (March 30 at 07:00 UTC), Codeforces Round #239 for both divisions participants will take place. Note the unusual time of the round.The problems have been prepared by me. I want to thank Codeforces team: tasks coordinator Gerald Agapov (Gerald) for invaluable contribution to the preparation of tasks and Maria Belova (Delinur), who has translated the problems. Also thank to Niyaz Nigmatullin (niyaznigmatul) for testing.I wish you all good luck and have a good weekend!UPD: You can see score distribution at the problems page.UPD2: You can find editorial here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11309",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 614
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces",
          "content": "Sorry for my poor English. If you find a mistake, write me a private message, I'll fix it. Some problems have not been translated yet, now you can try to read the Russian version of editorial with Google Translate.408A - Line to CashierIn this problem you were to find waiting the time for every queue by summing up the purchases of all the people, and return the minimum.408B - GarlandIn this problem it is necessary to find the garland with the maximal length, which can be composed of elements that we have. First, if you need some color, but you don't have it, then the answer is -1 Otherwise, answer is always exists. Let's sum the answers for all the colors separately. Suppose we have a pieces of a garland of some color, and we need b pieces. Then we have to add min(a, b) to the answer: if a >  = b we will use b 1 meter pieces, in the other case if a < b we will use all a pieces.407A - TriangleIn this problem you have to locate the right triangle with cathetuses a, b on a plane with its vertices in integer points. If the required layout exists, then cathetus a always can be represented as a vector with integer coordinates A{x;y}, and a2 = x2 + y2. Iterate over all possible x (1 ≤ x ≤ a - 1), check, that y = sqrt(a2 - x2) is integer. Vector, ortogonal to vector {x;y}, is { - y;x}. Take vector B{ - y / g;x / g}, where g = gcd(x, y). The triangle can be located on the plane if and only if b % |B| = 0, where |B| — length of vector B. The candidate for the answer — triangle (0;0)(x;y)( - y / g * b / |B|;x / g * b / |B|), but don't forget about checking that the hypotenuse isn't parallel to coordinate axes.407B - Long PathIn this problem you had to simulate route of character in graph. Note that if you are in vertice i, then edges in all vertices with numbers less than i are turned to pi. It gives us opportunity to see a recurrence formula: let dpi be number of steps, needed to get from vertice 1 to vertice i, if all edges are rotated back, into pi. Then dpi + 1 = 2dpi + 2 - dppi. Answer will be dpn + 1.BONUS: Can you solve this task without statement pi ≤ i? I don't know the solution, it seems difficult.407C - Curious ArrayIn this problem you had to find how to add binomial coefficients in array offline. Let's see, how problem changes due to increasing k from small to big values.1) All queries have K = 0 Every time you add 1 on subsegment. For solve this task you can add 1 at some array b[] in b[L] 1, then substract 1 from b[R+1], and after doing all queries make array a[] as array of prefix sums of array b[].2) All queries have K = 1 Arithmetic progression 1 2 3 4 ... is added on subsegment For solve this task you can add 1 at some array c[] in c[L] 1, then substract 1 from c[R+1], and after doing all queries make array b[] as array of prefix sums of array c[]. Actually you added 1 1 ... 1 on every subsegment at each query. If you will substract (R — L + 1) from c[R+1], and make array a[] as array of prefix sums of array b[], then it will be an answer: 1 1 ... 1 became 1 2 3 ... (R-L+1).3) K is arbitrary Summaring previous results one can see that if we will do a[K+1][L] += 1 a[j][R+1] -= C(k + 1 — j + r — l, k + 1 — j) for all 1 <= j <= K + 1 and after that do a[i][j] = a[i][j-1] + a[i+1][j] (making a[i] as array of prefix sums array a[i+1]), a[0] will be the answer. What is C(k + 1 — j + r — l, k + 1 — j)? This number is need for each query affect only on segment L..R, and you can see, why is it so, in Pascal's Triangle.If this explanation is not clear for you, you can try to see other participants solutions (for example, Xellos's one).407D - Largest Submatrix 3In this task you have to find largest by area submatrix, consisting from different numbers. Let's see solutions from slow to fast.1) Solution by O(n6): Iterate through two opposite vertices submatrix-answer and check that all numbers are different.2) Solution by O(n4): Let's fix Up and Down borders submatrix-answer (O(n2)). Use two pointers method to iterate Left and Right borders: while in submatrix there are no equal numbers, increment Right, while there are equal numbers — increment Left. Every check — (O(n)), increments — (O(n)).3) Solution by O(n3logn): Let's construct function maxR(Left) (let's consider that Up <= Down are fixed): maximal value Right, so that in submatrix (Up, Down, Left, Right) there is no equals numbers. You can see that maxR(i) <= maxR(i + 1) is true for every i. How values of this function changes by shift Down to Down-1? Every value maxR(Left) can only be the same (if segment(Down, Down, Left, maxR(Left)) only added new numbers), or it can decrease. When maxR(Left) is decreasing? Only when one of the numbers from added segment have already been in the current submatrix. Shift Down to down let's see all numbers in row Down. For each number (let it be in column j) find indices i and k so i <= j, there is number, equal to a[Down][j] between rows Up and Down-1, i — maximal; k >= j, there is number, equal to a[Down][j] between rows Up and Down-1, k — minimal. When you find these indices (it is easy to find them using set, when you store all columns where number x was between Up and Down for all numbers x), you can try to update maxR[i] with j — 1, maxR[j] with k — 1. It will be enough, if you also update for all i = m..1 maxR[i] = min(maxR[i], maxR[i + 1]). Now maxR(Left) is correct, and you can check answer for these Up and Down by O(n).4) Now, solution by O(n3). It requires understanding previous solution. Previous solution, despite good asymptotics, requires to store a lot (about 160 000) sets, where you will store about 160 000 elements. Even at n = 200 it works very slow. Let's get rid of log. Set is using only for finding nearest left and right elements, which are in rows from Up to Down, and equal to current. Note that when you do Up = Up — 1, nearest element comes near (by column) to a[i][j], so we can find all numbers, for which the nearest element will be in new row Up, and update them nearest number, and do that in O(n2). This solution uses O(n2) memory and O(n3) time.BONUS: Can you solve this task faster than O(n3)? I spend a lot of time and I didn't come to any solution, but I can't show that there is not solution faster.407E - k-d-sequenceIn this problem you have to find longest subsegment, satisfying the condition.Reduce problem to d = 1.If d = 0, then answer is longest subsegment from equal numbers, this case we solve separately. If d ≠ 0, then notice that if on some subsegment there are two numbers ai, aj so that ai%d ≠ aj%d, then this segment can't be good. Divide the sequence to consequent subsegments numbers, equal by modulo d, and divide each number by d, and solve task separately with every segment, consider that d = 1. Notice that segment [L, R] is good if and only if when max(L, R) — min(L, R) — (R — L) <= k, and there are no equal numbers. It is easy to exlain: if there are no equal numbers, then max(L, R) — min(L, R) — (R — L) is exactly number of numbers is needed to add for segment to consist of all numbers from min(L, R) to max(L, R). For all L lets find such maxR[L], that on segment [L..maxR[l]] there are no equal numbers, and maxR[L] is maximal. It can be done by O(nlogn) by many ways, for example you can use map. Let's learn how we can maintain array a[R] = max(L, R) — min(L, R) — (R — L). If we have such array, then we have to find rightmost R such that a[R] <= k to get an answer. We will need two stacks and segment tree with operations \"Add number on segment\", \"Find min element on segment\", \"Find rightmost number doesn't exceed k\". Let's iterate L from right to left (n downto 1). How does function max(L, R) look like with fixed L? It's values represent a set of segments so that maximum on the segment is leftmost element of segment, and these maximums are increasing. (example: for array 6 4 8 0 7 9 function max(1, R) will be 6 6 8 8 8 9). How function changes with shift L to left? Some segments are absorbed by new element, if new element is bigger than maximum on segment. Maximums on segments are increasing, so we can keep them all in stack, and when we need to add new element we have to only pop some segments from stacks while maximum on top of stack is less then new element, and push new segment after that. If every operation with stack will be accompanied with right operation with segment tree, we can store array a[R] = max(L, R). For get array a[R] = max(L, R) — min(L, R) we need only to maintain second similar stack. For get array a[R] = max(L, R) — min(L, R) we need add -1 on all suffix when we are shitfing L. Now query \"Find fightmost number less of equal k\". First, segment tree divides segment of request to log(n) segments with length powers of two. Let's choose rightmost segment with minimum <= k, and do iterative deeping there to find element that we need.So, for every L we get query on segment L..maxR(L) on rightmost number less or equal k. It is one of candidates to an answer. We are doing O(n) operation with stack, and every requires query to segment tree, so asymptotics is O(nlogn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11333",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 408 和字母"
          },
          "content_length": 9077
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #239 - Codeforces - Code 1",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 2",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 3",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 4",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 5",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 6",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 7",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 8",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 1",
          "code": "dp[i] = 1 + (dp[p[i]]+1) + (dp[p[i]+1]+1) + ... + (dp[i-1]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 2",
          "code": "(dp[1]+1) + (dp[2]+1) + (dp[3]+1) + ... + (dp[n]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 3",
          "code": "s[p[k]]+s[p[k]+1]+s[p[k]+2]+...+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 4",
          "code": "s[k]=2+s[p[k]]+s[p[k]+1]+s[p[k]+2]+..+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 5",
          "code": "answer=s[1]+s[2]+..+s[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 6",
          "code": "dp[i] = the number of steps needed to move from room i to room (i + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 7",
          "code": "dp[i] = 2 + sum(dp[j]) for j in [p[i], i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 8",
          "code": "sum(dp[i]) for (1 ≤ i ≤ n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    inf.readLine(\"(1000|[1-9]\\\\d{0,2}) (1000|[1-9]\\\\d{0,2})\", \"line\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    inf.readLine(\"(1000|[1-9]\\\\d{0,2}) (1000|[1-9]\\\\d{0,2})\", \"line\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    inf.readLine(\"(1000|[1-9]\\\\d{0,2}) (1000|[1-9]\\\\d{0,2})\", \"line\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input\n    int a = inf.readInt(1, 1000);\n    int b = inf.readInt(1, 1000);\n\n    // Read jury's answer\n    string juryAns = ans.readToken();\n\n    // Read participant's answer\n    string partAns = ouf.readToken();\n\n    if (juryAns != \"YES\" && juryAns != \"NO\")\n        quitf(_fail, \"Jury's answer is neither YES nor NO: %s\", juryAns.c_str());\n\n    if (partAns != \"YES\" && partAns != \"NO\")\n        quitf(_wa, \"Participant's answer is neither YES nor NO: %s\", partAns.c_str());\n\n    if (juryAns == \"NO\") {\n        if (partAns == \"NO\") {\n            // Correct\n            quitf(_ok, \"Correct: both answers are NO\");\n        } else {\n            // Participant output YES when the correct answer is NO\n            quitf(_wa, \"Participant answered YES, but the correct answer is NO\");\n        }\n    } else { // juryAns == \"YES\"\n        if (partAns == \"NO\") {\n            // Participant output NO when correct answer is YES\n            quitf(_wa, \"Participant answered NO, but the correct answer is YES\");\n        } else {\n            // Now, both outputs are YES\n\n            // Read participant's triangle coordinates\n            long long x[3], y[3];\n            for (int i = 0; i < 3; i++) {\n                x[i] = ouf.readLong(-1000000000LL, 1000000000LL, format(\"x[%d]\", i+1).c_str());\n                y[i] = ouf.readLong(-1000000000LL, 1000000000LL, format(\"y[%d]\", i+1).c_str());\n            }\n\n            // Check that none of the sides is parallel to coordinate axes\n            for (int i = 0; i < 3; i++) {\n                int j = (i+1)%3;\n                if (x[i] == x[j])\n                    quitf(_wa, \"Side between points %d and %d is parallel to y-axis\", i+1, j+1);\n                if (y[i] == y[j])\n                    quitf(_wa, \"Side between points %d and %d is parallel to x-axis\", i+1, j+1);\n            }\n\n            // Now, check that the triangle is right-angled with legs of length a and b\n            // We need to find if any angle is 90 degrees\n\n            // Compute squared lengths\n            long long L[3];\n            L[0] = (x[0]-x[1])*(x[0]-x[1]) + (y[0]-y[1])*(y[0]-y[1]);\n            L[1] = (x[0]-x[2])*(x[0]-x[2]) + (y[0]-y[2])*(y[0]-y[2]);\n            L[2] = (x[1]-x[2])*(x[1]-x[2]) + (y[1]-y[2])*(y[1]-y[2]);\n\n            bool ok = false;\n            for (int i = 0; i < 3; i++) {\n                int j = (i+1)%3;\n                int k = (i+2)%3;\n\n                // Vectors from vertex i to j and k\n                long long vx1 = x[j] - x[i], vy1 = y[j] - y[i];\n                long long vx2 = x[k] - x[i], vy2 = y[k] - y[i];\n\n                // Compute dot product\n                long long dot = vx1*vx2 + vy1*vy2;\n                if (dot == 0) { // Right angle at vertex i\n                    // Lengths squared of adjacent sides\n                    long long len1 = vx1*vx1 + vy1*vy1;\n                    long long len2 = vx2*vx2 + vy2*vy2;\n                    long long len3 = (x[j] - x[k])*(x[j] - x[k]) + (y[j] - y[k])*(y[j] - y[k]);\n\n                    long long a2 = (long long)a * a;\n                    long long b2 = (long long)b * b;\n                    long long c2 = a2 + b2;\n\n                    if ((len1 == a2 && len2 == b2 && len3 == c2) ||\n                        (len1 == b2 && len2 == a2 && len3 == c2)) {\n                        ok = true;\n                        break;\n                    }\n                }\n            }\n            if (ok) {\n                quitf(_ok, \"Correct triangle\");\n            } else {\n                quitf(_wa, \"Participant's triangle is invalid\");\n            }\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int max_a = opt<int>(\"max_a\", 1000);\n    int max_b = opt<int>(\"max_b\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int a, b;\n\n    if (type == \"gcd1\") {\n        // Generate a and b such that gcd(a,b) == 1\n        do {\n            a = rnd.next(1, max_a);\n            b = rnd.next(1, max_b);\n        } while (__gcd(a, b) != 1);\n    } else if (type == \"gcd>1\") {\n        // Generate a and b such that gcd(a,b) > 1\n        int g;\n        do {\n            a = rnd.next(1, max_a);\n            b = rnd.next(1, max_b);\n            g = __gcd(a,b);\n        } while (g <= 1);\n    } else if (type == \"equal\") {\n        // Generate a == b\n        a = rnd.next(1, min(max_a, max_b));\n        b = a;\n    } else if (type == \"one\") {\n        // a == 1 or b == 1\n        bool chooseA = rnd.next(0, 1);\n        if (chooseA) {\n            a = 1;\n            b = rnd.next(1, max_b);\n        } else {\n            a = rnd.next(1, max_a);\n            b = 1;\n        }\n    } else if (type == \"max\") {\n        a = max_a;\n        b = max_b;\n    } else if (type == \"random\") {\n        a = rnd.next(1, max_a);\n        b = rnd.next(1, max_b);\n    } else {\n        // default case\n        a = rnd.next(1, max_a);\n        b = rnd.next(1, max_b);\n    }\n\n    printf(\"%d %d\\n\", a, b);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int max_a = opt<int>(\"max_a\", 1000);\n    int max_b = opt<int>(\"max_b\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int a, b;\n\n    if (type == \"gcd1\") {\n        // Generate a and b such that gcd(a,b) == 1\n        do {\n            a = rnd.next(1, max_a);\n            b = rnd.next(1, max_b);\n        } while (__gcd(a, b) != 1);\n    } else if (type == \"gcd>1\") {\n        // Generate a and b such that gcd(a,b) > 1\n        int g;\n        do {\n            a = rnd.next(1, max_a);\n            b = rnd.next(1, max_b);\n            g = __gcd(a,b);\n        } while (g <= 1);\n    } else if (type == \"equal\") {\n        // Generate a == b\n        a = rnd.next(1, min(max_a, max_b));\n        b = a;\n    } else if (type == \"one\") {\n        // a == 1 or b == 1\n        bool chooseA = rnd.next(0, 1);\n        if (chooseA) {\n            a = 1;\n            b = rnd.next(1, max_b);\n        } else {\n            a = rnd.next(1, max_a);\n            b = 1;\n        }\n    } else if (type == \"max\") {\n        a = max_a;\n        b = max_b;\n    } else if (type == \"random\") {\n        a = rnd.next(1, max_a);\n        b = rnd.next(1, max_b);\n    } else {\n        // default case\n        a = rnd.next(1, max_a);\n        b = rnd.next(1, max_b);\n    }\n\n    printf(\"%d %d\\n\", a, b);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type gcd1\n./gen -type gcd1 -max_a 10 -max_b 10\n./gen -type gcd1 -max_a 1000 -max_b 1000\n./gen -type gcd1 -max_a 999 -max_b 1000\n\n./gen -type gcd>1\n./gen -type gcd>1 -max_a 10 -max_b 10\n./gen -type gcd>1 -max_a 1000 -max_b 1000\n./gen -type gcd>1 -max_a 999 -max_b 1000\n./gen -type gcd>1\n\n./gen -type equal\n./gen -type equal -max_a 1 -max_b 1\n./gen -type equal -max_a 500 -max_b 500\n./gen -type equal -max_a 1000 -max_b 1000\n\n./gen -type one\n./gen -type one -max_a 1 -max_b 1000\n./gen -type one -max_a 1000 -max_b 1\n./gen -type one -max_a 1 -max_b 1\n\n./gen -type max\n./gen -type max -max_a 1000 -max_b 1000\n./gen -type max -max_a 1 -max_b 1\n\n./gen -type random\n./gen -type random -max_a 1 -max_b 1\n./gen -type random -max_a 500 -max_b 500\n./gen -type random -max_a 1000 -max_b 1000\n\n# Multiple runs to generate diverse random cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Some specific small cases\n./gen -type random -max_a 1 -max_b 1   # Should generate (1,1)\n./gen -type one -max_a 1 -max_b 10\n./gen -type one -max_a 10 -max_b 1\n./gen -type one\n\n# Large values\n./gen -type gcd>1 -max_a 1000 -max_b 1000\n./gen -type gcd1 -max_a 1000 -max_b 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:46.429458",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "408/D",
      "title": "D. Длинный путь",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 103) — число комнат. Во второй строке записаны n целых чисел pi (1 ≤ pi ≤ i) — номера комнат, в которые можно попасть из i-й комнаты, если пользоваться вторым порталом.",
      "output_spec": "Выходные данныеВыведите одно число — количество перемещений, за которое мальчик выберется из лабиринта. Поскольку это число может быть достаточно большим, выведите его по модулю 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать21 2Выходные данныеСкопировать4Входные данныеСкопировать41 1 2 3Выходные данныеСкопировать20Входные данныеСкопировать51 1 1 1 1Выходные данныеСкопировать62",
      "description": "D. Длинный путь\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 103) — число комнат. Во второй строке записаны n целых чисел pi (1 ≤ pi ≤ i) — номера комнат, в которые можно попасть из i-й комнаты, если пользоваться вторым порталом.\n\nВходные данные\n\nВыходные данныеВыведите одно число — количество перемещений, за которое мальчик выберется из лабиринта. Поскольку это число может быть достаточно большим, выведите его по модулю 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать21 2Выходные данныеСкопировать4Входные данныеСкопировать41 1 2 3Выходные данныеСкопировать20Входные данныеСкопировать51 1 1 1 1Выходные данныеСкопировать62\n\nВходные данныеСкопировать21 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать41 1 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать20\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать51 1 1 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать62\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #239 - Codeforces",
          "content": "Всем привет!В это воскресенье, 30 марта, в 11:00 MSK, состоится Codeforces Round #239 для участников обоих дивизионов. Обратите внимание на необычное время проведения раунда.Автором задач являюсь я, izban. Большое спасибо команде Codeforces: координатору задач Геральду Агапову (Gerald) за неоценимый вклад в подготовку задач и Марии Беловой (Delinur), которая перевела задачи на английский язык. Также спасибо Ниязу Нигматуллину (niyaznigmatul) за прорешивание задач.Желаю всем хорошо написать раунд и с удовольствием провести выходные!UPD: Разбалловку вы можете увидеть на странице с задачами.UPD2: Разбор вы можете найти по этой ссылке. Обратите внимание на бонусы в некоторых задачах!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11309",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 688
        },
        {
          "title": "Codeforces Round #239 Разбор задач - Codeforces",
          "content": "Обратите внимание на бонусы в некоторых задачах, и если вы умеете их решать, пожалуйста, напишите об этом в комментариях.408A - Очередь на кассеВ задаче нужно было найти время ожидания для каждой очереди, просуммировав покупки по всем людям, и найти минимум.408B - ГирляндаВ задаче нужно было найти максимально длинную гирлянду, которую можно составить из тех элементов, что у нас есть. Во-первых, если какой-то цвет нужен, но его нет, то ответ — -1. Иначе, ответ всегда существует, и является целым числом. Просуммируем ответы по всем цветам по отдельности. Пусть у нас есть a кусков бумаги некоторого цвета, а нужно — b. Тогда если a >  = b, то к ответу можно прибавить b — повесить b кусков по одному метру, а если a < b, то к ответу можно прибавить a, использовав все куски, что есть в наличии. Итого, каждый цвет дает к ответу min(a, b).407A - ТреугольникВ задаче требовалось расположить прямоугольный треугольник с катетами a, b на плоскости с вершинами в целых точках. Если искомое расположение существует, то катет a всегда можно представить как вектор с целыми координатами A{x;y}, при чем a2 = x2 + y2. Переберем все возможные x (1 ≤ x ≤ a - 1), проверим, что y получается целым числом. Вектор, перпендикулярный вектору {x;y} — { - y;x}. Возьмем вектор B{ - y / g;x / g}, где g = gcd(x, y). Треугольник можно уложить на плоскость лишь тогда, когда b делится нацело на |B|, где |B| — длина вектора B. Кандидат на ответ — треугольник (0;0)(x;y)( - y / g * b / |B|;x / g * b / |B|), нужно лишь не забыть проверку на то, что гипотенуза не параллельна осям координат. Сложность решения — O(n).407B - Длинный путьВ задаче требовалось промоделировать путь персонажа по графу. Заметим, что если мы пришли в вершину i, то ребра во всех вершинах с номерами меньшими, чем i, повернуты в pi. Это дает нам возможность заметить рекуррентную формулу: пусть dpi — число шагов, необходимое, чтобы добраться из вершины 1 в вершину i, если все ребра изначально повернуты назад, в pi. тогда dpi + 1 = 2dpi + 2 - dppi. Ответом будет dpn + 1. Сложность решения — O(n).BONUS: Умеете ли вы решать задачу, если нет ограничения, что pi ≤ i? В такой формулировке задача становится более интересной, но я пока не знаю решения.407C - Занимательный массивВ задаче требовалось научиться прибавлять в оффлайне на отрезке числа сочетаний. Будем смотреть, как изменяется задача при увеличении k от малых чисел к большим.1) Все запросы имеют K = 0 Прибавляется каждый раз единица на отрезке. Для решения задачи нужно прибавить на некотором массиве b[] в ячейку b[L] единицу, вычесть из b[R + 1] единицу, а после выполнения всех операций построить массив a как массив сумм на префиксах массива b.2) Все запросы имеют K = 1 Прибавляется арифметическая прогрессия 1 2 3 4 ... Для решения задачи нужно прибавить на некотором массиве c[] в ячейку c[L] единицу, вычесть из с[R + 1] единицу. После выполнения всех операций можно построить массив b как массив сумм на префиксах массива c. В таком массиве мы на каждом отрезке прибавили единицу. Если после этого для каждого запроса вычесть из b[R + 1] число C(R — L + 1, 1) = (R — L + 1), и построить массив а как массив префиксных сумм над массивом b, несложно увидеть, что массив а будет ответом.3) Все запросы имеют произвольное k Пускай у нас есть массив a[N][K]. обобщая предыдущие случаи, можно понять, что если поступает запрос L, R, K, нужно сделать операции a[L][K + 1] += 1 a[R + 1][j] -= C(k + 1 — j + r — l, k + 1 — j) для всех 1 <= j <= K + 1после чего построить необходимые суммы на префиксах для всех значений K спускаясь от больших K к меньшим. Доказать, что нужно отнимать именно такое число сочетаний, проще всего, если посмотреть, как расположены эти числа в треугольнике Паскаля — легко увидеть, что это число является суммой всего ряда чисел перед ним. Сложность решения — O((n + m)k).407D - Наибольшая подматрица 3В задаче требовалось найти наибольшую по площади подматрицу, состоящую из различных чисел. Будем идти от медленных решений к более быстрым.1) Решение за O(n6): Перебираем две противоположные вершины прямоугольника-ответа и проверяем, что все числа внутри различны.2) Решение за O(n4): Фиксируем верхнюю и нижнюю границы прямоугольника-ответа (O(n2)). Используем метод двух указателей при переборе левой и правой границы: пока в прямоугольнике нет одинаковых чисел, двигаем правую границу, пока есть — двигаем левую границу. Проверка при сдвиге границы — O(n), сдвигов — O(n).3) Решение за O(n3logn): Введем функцию maxR(Left): наибольшее значение Right, такое, что при фиксированных Up и Down в прямоугольнике (Up, Down, Left, Right) нет одинаковых чисел. Заметим, что для всех i выполняется maxR(i) <= maxR(i + 1). Как изменяются значения этой функции при сдвиге Down вниз? Каждое значение maxR(Left) может либо остаться таким же (если отрезок(Down, Down, Left, maxR(Left)) добавил лишь новые числа), либо уменьшиться. Когда maxR(Left) уменьшается? Лишь тогда, когда одно из чисел с только что добавленного отрезка уже было в прямоугольнике. Сдвигая Down вниз рассмотрим все числа в ряду Down. Для каждого числа в столбце j найдем индексы i и k такие, что i <= j, в столбце j есть вхождение числа a[Down][j] между строками Up и Down-1, i — максимально; k >= j, в столбце k есть вхождение числа a[Down][j] между строками Up и Down-1, k — минимально. Найдя такие индексы i и k (для этого удобно использовать set, для каждого цвета храня столбцы, где он встречался на данный момент между строками Up и Down), можно обновить maxR[i] = j — 1, maxR[j] = k — 1. Этого будет достаточно. Несложно заметить, что после описанных действий, если мы прокинем по всем i = m..1 maxR[i] = min(maxR[i], maxR[i + 1]), то мы вновь будем иметь корректные значения функции maxR(Left), и можно пересчитать ответ для данных Up и Down за O(n).4) Решение за O(n3): Предыдущее решение, несмотря на хорошую асимптотику, требует хранения большого количества set'ов. Это работает очень медленно даже на небольших тестах. Избавимся от логарифма. Set используется лишь при поиске ближайших слева и справа чисел, равных данному, лежащих в строках с номерами от Up до Down. Заметим, что при сдвиге границы Up ближайший сверху элемент для данного a[i][j] отдаляется. Это наводит на мысль, что, двигая Up снизу вверх, можно заставить ближайший к a[i][j] элемент приближаться к столбцу j, и теперь, сдвигая Up вверх, мы можем, взяв число с верхнего ряда, быстро (за O(n)) определить все числа такие, что он будет для них ближайшим, и обновить для них ближайшее число. Такое решение использует O(n2) памяти и O(n3) времени.BONUS: Умеете ли вы решать эту задачу быстрее, чем за O(n3)? У меня не получилось, но никаких предпосылок того, что решения нет, я не нашел.407E - k-d-последовательностьНа контесте задачу, к сожалению, никто не решил, но в дорешивании первым оказался hza, с чем мы его и поздравляем. В задаче требовалось найти наидлиннейший подотрезок, удовлетворяющий условию.Сведем задачу к d = 1. Если d = 0, то ответ — наидлиннейший подотрезок из равных чисел, этот случай обрабатываем отдельно. Если d ≠ 0, то заметим, что если на некотором отрезке есть два числа ai, aj таких, что ai % d ≠ aj % d, то этот отрезок не может быть хорошим.Разобьем исходную подпоследовательность на отрезки подряд идущих чисел, дающих равные остатки от деления на d, поделим каждое число на d, будем решать для каждого отрезка задачу отдельно, сказав, что d = 1.Заметим, что отрезок [L, R] является хорошим тогда и только тогда, когда max(L, R) — min(L, R) — (R — L) <= k, и на отрезке с L по R нет одинаковых чисел. Объясняется это просто — если на отрезке нет повторяющихся чисел, то max(L, R) — min(L, R) — (R — L) — именно количество чисел, которые необходимо добавить, чтобы отрезок состоял из всех чисел с min(L, R) по max(L, R).Для каждого L найдем такое maxR[L], что на отрезке с L по maxR[L] нет повторяющихся чисел, а maxR[L] — максимально. Это делается за O(nlogn) любым способом, например, проходом с map'ом.Научимся для каждого фиксированного L поддерживать массив a[R] = max(L, R) — min(L, R) — (R — L). Если у нас есть такой массив, то для того, чтбы найти ответ, необходимо быстро найти такое наибольшее R, что a[R] <= k.Нам потребуются два стека и дерево отрезков с операциями \"Прибавить число на отрезке\", \"Найти минимальный элемент на отрезке\" и \"Найти самое правое число, такое, что оно не превышает k\". Будем перебирать L справа налево (от n до 1). Как выглядит функция max(L, R) при фиксированном L? Ее значения представляют собой набор отрезков, на которых максимумом является первый элемент отрезка. (пример: для массива 6 4 8 0 7 9 функция max(1, R) будет иметь вид 6 6 8 8 8 9) Как изменяется функция при сдвиге L влево? Некоторые отрезки поглощаются новым элементом, если новый элемент больше значения на отрезке. Заметив, что все значения массива не убывают, будем хранить все такие отрезки в стеке, а при добавлении нового элемента a[L] вытаскивать отрезки из стека, пока значение на вершине меньше нового, и добавим на стек новый отрезок, который покроет L и все, что мы вытащили. Если каждую операцию со стеком сопровождать запросом \"Прибавить число на отрезке\", то мы уже можем получить массив a[R] = max(L, R). Функция min(L, R) ведет себя абсолютно аналогично, и используя второй стек мы получаем a[R] = max(L, R) — min(L, R). Для того, чтобы получить член (R — L) достаточно просто каждый раз при сдвиге L влево отнимать единицу на отрезке [L, n]. Теперь запрос \"Найти самое правое число, такое, что оно не превышает k\". Сначала дерево отрезков разбивает отрезок запроса L..R на log(n) отрезков длиной степени двойки. Разобьем запрос на такие отрезки и выберем самый правый отрезок, минимум на котором <= k. Теперь будем спускаться по этому отрезку вниз в дереве отрезков — если в правом сыне min <= k, то в правого, иначе в левого. Так мы найдем искомый элемент. Итак, для каждого фиксированного L делаем запрос на отрезке L..maxR(L) о самом правом числе, не превышающем k. Это один из кандидатов на ответ. Все. Раз мы делаем запрос на отрезке, на котором нет различных чисел, то любое число на этом отрезке неотрицательно, и min работает корректно. Суммарное время работы — O(nlogn).BONUS: Задача и сама по себе не из простых, но умеет ли кто-нибудь решать ее по методу \"навороти побольше\"? Интересно, как решать хотя бы на дереве.BONUS2: Есть очень быстрое решение за O(n2). Давайте для отрезка [L; R] так же посмотрим на значение f(L, R) = max(L..R) — min(L..R) — (R — L) — K. f(L, R) можно считать для отрезка за O(1). Если f(L, R) <= 0, то отрезок — кандидат на ответ. Если f(L, R) > 0, то следующий отрезок, который стоит рассмотреть — [L; R + f(L, R)], потому что для всех r: R < r < R + f(L, R) отрезок [L; r] не будет k-d последовательностью, поскольку при добавлении одного числа в отрезок f(L, R) может либо возрасти на произвольное число, либо уменьшиться на единицу. Если так написать решение за квадрат, используя для начального R при фиксированном L значение L + curAns, то решение в среднем работает очень быстро, и получает ТЛ лишь на специальных тестов. Вполне возможно, что это решение можно оптимизациями довести до такого, что оно пройдет все тесты.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11333",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 408 和字母"
          },
          "content_length": 11115
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #239 - Codeforces - Code 1",
          "code": "#збаник_пряник",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 2",
          "code": "DP[i]=(2+pre[i]-pre[P[i]-1])%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 3",
          "code": "DP[i]=(2+pre[i]-pre[P[i]-1])%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 4",
          "code": "DP[i]=(2+pre[i]-pre[P[i]-1] + MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 5",
          "code": "DP[i]=(2+pre[i]-pre[P[i]-1] + MOD)%MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 6",
          "code": "for(dx=1;dx*dx<a*a;++dx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 7",
          "code": "for(dx=1;dx*dx<a*a;++dx)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 8",
          "code": "xa = - a * yb / b;\nya = a * xb / b;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 9",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 10",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 11",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 12",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 13",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 14",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 15",
          "code": "1 1\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 16",
          "code": "============================================",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 17",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 18",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 19",
          "code": "YES\n0 0\n324 945\n960 -280",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 20",
          "code": "YES\n0 0\n324 945\n960 -280",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 21",
          "code": "999 = 324 * 324 + 945 * 945\n      104976    + 893025 = 998001\nsqrt(998001) = 999\n1000 = 960 * 960 + 280 * 280\n       921600    + 78400 = 1000000\nsqrt(1000000) = 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 22",
          "code": "999 = 324 * 324 + 945 * 945\n      104976    + 893025 = 998001\nsqrt(998001) = 999\n1000 = 960 * 960 + 280 * 280\n       921600    + 78400 = 1000000\nsqrt(1000000) = 1000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 23",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 24",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Разбор задач - Codeforces - Code 1",
          "code": "dp[i] = 1 + (dp[p[i]]+1) + (dp[p[i]+1]+1) + ... + (dp[i-1]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Разбор задач - Codeforces - Code 2",
          "code": "(dp[1]+1) + (dp[2]+1) + (dp[3]+1) + ... + (dp[n]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Разбор задач - Codeforces - Code 3",
          "code": "s[p[k]]+s[p[k]+1]+s[p[k]+2]+...+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Разбор задач - Codeforces - Code 4",
          "code": "s[k]=2+s[p[k]]+s[p[k]+1]+s[p[k]+2]+..+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Разбор задач - Codeforces - Code 5",
          "code": "answer=s[1]+s[2]+..+s[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Разбор задач - Codeforces - Code 6",
          "code": "dp[i] = the number of steps needed to move from room i to room (i + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Разбор задач - Codeforces - Code 7",
          "code": "dp[i] = 2 + sum(dp[j]) for j in [p[i], i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Разбор задач - Codeforces - Code 8",
          "code": "sum(dp[i]) for (1 ≤ i ≤ n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    for (int i = 1; i <= n; i++) {\n        if (i > 1) inf.readSpace();\n        int pi = inf.readInt(1, i, \"p_i\");\n    }\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    for (int i = 1; i <= n; i++) {\n        if (i > 1) inf.readSpace();\n        int pi = inf.readInt(1, i, \"p_i\");\n    }\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    for (int i = 1; i <= n; i++) {\n        if (i > 1) inf.readSpace();\n        int pi = inf.readInt(1, i, \"p_i\");\n    }\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> pi(n);\n\n    if (type == \"min_pi\") {\n        // pi = 1 for all i\n        for(int i = 0; i < n; ++i) {\n            pi[i] = 1;\n        }\n    } else if (type == \"max_pi\") {\n        // pi = i for all i\n        for(int i = 0; i < n; ++i) {\n            pi[i] = i + 1;\n        }\n    } else if (type == \"random\") {\n        // pi random in [1, i + 1]\n        for(int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(1, i + 1);\n        }\n    } else if (type == \"half_pi\") {\n        // pi = floor((i + 1) / 2)\n        for(int i = 0; i < n; ++i) {\n            pi[i] = (i + 1) / 2;\n        }\n    } else if (type == \"alternate\") {\n        // pi alternates between 1 and i + 1\n        for(int i = 0; i < n; ++i) {\n            if ((i & 1) == 0)\n                pi[i] = 1;\n            else\n                pi[i] = i + 1;\n        }\n    } else if (type == \"decreasing\") {\n        // pi decreasing from i + 1 to 1\n        for(int i = 0; i < n; ++i) {\n            pi[i] = n - i;\n            if (pi[i] > i + 1) pi[i] = i + 1;\n            if (pi[i] < 1) pi[i] = 1;\n        }\n    } else if (type == \"ones_and_max\") {\n        // First half pi = 1, second half pi = i + 1\n        for(int i = 0; i < n; ++i) {\n            if (i < n / 2)\n                pi[i] = 1;\n            else\n                pi[i] = i + 1;\n        }\n    } else if (type == \"random_max\") {\n        // Random pi biased towards maximum values\n        for(int i = 0; i < n; ++i) {\n            pi[i] = rnd.wnext(1, i + 1, 5); // Bias towards higher values\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output pi\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", pi[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> pi(n);\n\n    if (type == \"min_pi\") {\n        // pi = 1 for all i\n        for(int i = 0; i < n; ++i) {\n            pi[i] = 1;\n        }\n    } else if (type == \"max_pi\") {\n        // pi = i for all i\n        for(int i = 0; i < n; ++i) {\n            pi[i] = i + 1;\n        }\n    } else if (type == \"random\") {\n        // pi random in [1, i + 1]\n        for(int i = 0; i < n; ++i) {\n            pi[i] = rnd.next(1, i + 1);\n        }\n    } else if (type == \"half_pi\") {\n        // pi = floor((i + 1) / 2)\n        for(int i = 0; i < n; ++i) {\n            pi[i] = (i + 1) / 2;\n        }\n    } else if (type == \"alternate\") {\n        // pi alternates between 1 and i + 1\n        for(int i = 0; i < n; ++i) {\n            if ((i & 1) == 0)\n                pi[i] = 1;\n            else\n                pi[i] = i + 1;\n        }\n    } else if (type == \"decreasing\") {\n        // pi decreasing from i + 1 to 1\n        for(int i = 0; i < n; ++i) {\n            pi[i] = n - i;\n            if (pi[i] > i + 1) pi[i] = i + 1;\n            if (pi[i] < 1) pi[i] = 1;\n        }\n    } else if (type == \"ones_and_max\") {\n        // First half pi = 1, second half pi = i + 1\n        for(int i = 0; i < n; ++i) {\n            if (i < n / 2)\n                pi[i] = 1;\n            else\n                pi[i] = i + 1;\n        }\n    } else if (type == \"random_max\") {\n        // Random pi biased towards maximum values\n        for(int i = 0; i < n; ++i) {\n            pi[i] = rnd.wnext(1, i + 1, 5); // Bias towards higher values\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output pi\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", pi[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Smallest n\n./gen -n 1 -type min_pi\n./gen -n 1 -type max_pi\n./gen -n 1 -type random\n\n# Small n\n./gen -n 2 -type min_pi\n./gen -n 2 -type max_pi\n./gen -n 2 -type random\n\n./gen -n 3 -type min_pi\n./gen -n 3 -type max_pi\n./gen -n 3 -type random\n\n./gen -n 5 -type min_pi\n./gen -n 5 -type max_pi\n./gen -n 5 -type random\n\n# Moderate n\n./gen -n 10 -type half_pi\n./gen -n 10 -type alternate\n./gen -n 10 -type decreasing\n./gen -n 10 -type ones_and_max\n./gen -n 10 -type random_max\n\n./gen -n 50 -type min_pi\n./gen -n 50 -type max_pi\n./gen -n 50 -type random\n\n# Maximum n\n./gen -n 1000 -type min_pi\n./gen -n 1000 -type max_pi\n./gen -n 1000 -type random\n\n# Other types with maximum n\n./gen -n 1000 -type half_pi\n./gen -n 1000 -type alternate\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type ones_and_max\n./gen -n 1000 -type random_max\n\n# Random n\n./gen -n 500 -type random\n./gen -n 999 -type random\n\n# Edge cases with small n\n./gen -n 2 -type half_pi\n./gen -n 2 -type alternate\n./gen -n 2 -type decreasing\n./gen -n 2 -type ones_and_max\n./gen -n 2 -type random_max\n\n# Testing random_max with moderate n\n./gen -n 50 -type random_max\n./gen -n 100 -type random_max\n\n# Additional tests\n./gen -n 1000 -type alternate\n./gen -n 1000 -type decreasing\n./gen -n 1000 -type ones_and_max\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:48.589981",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "408/E",
      "title": "E. Curious Array",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n, m (1 ≤ n, m ≤ 105).The second line contains n integers a[1], a[2], ..., a[n] (0 ≤ ai ≤ 109) — the initial array.Next m lines contain queries in the format li, ri, ki — to all elements of the segment li... ri add number  (1 ≤ li ≤ ri ≤ n; 0 ≤ k ≤ 100).",
      "output_spec": "OutputPrint n integers: the i-th number is the value of element a[i] after all the queries. As the values can be rather large, print them modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy5 10 0 0 0 01 5 0OutputCopy1 1 1 1 1InputCopy10 21 2 3 4 5 0 0 0 0 01 6 16 10 2OutputCopy2 4 6 8 10 7 3 6 10 15",
      "description": "E. Curious Array\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n, m (1 ≤ n, m ≤ 105).The second line contains n integers a[1], a[2], ..., a[n] (0 ≤ ai ≤ 109) — the initial array.Next m lines contain queries in the format li, ri, ki — to all elements of the segment li... ri add number  (1 ≤ li ≤ ri ≤ n; 0 ≤ k ≤ 100).\n\nOutputPrint n integers: the i-th number is the value of element a[i] after all the queries. As the values can be rather large, print them modulo 1000000007 (109 + 7).\n\nInputCopy5 10 0 0 0 01 5 0OutputCopy1 1 1 1 1InputCopy10 21 2 3 4 5 0 0 0 0 01 6 16 10 2OutputCopy2 4 6 8 10 7 3 6 10 15\n\nInputCopy5 10 0 0 0 01 5 0\n\nOutputCopy1 1 1 1 1\n\nInputCopy10 21 2 3 4 5 0 0 0 0 01 6 16 10 2\n\nOutputCopy2 4 6 8 10 7 3 6 10 15",
      "solutions": [
        {
          "title": "Codeforces Round #239 - Codeforces",
          "content": "Hello everyone!This Sunday, on March 30 at 11:00 MSK (March 30 at 07:00 UTC), Codeforces Round #239 for both divisions participants will take place. Note the unusual time of the round.The problems have been prepared by me. I want to thank Codeforces team: tasks coordinator Gerald Agapov (Gerald) for invaluable contribution to the preparation of tasks and Maria Belova (Delinur), who has translated the problems. Also thank to Niyaz Nigmatullin (niyaznigmatul) for testing.I wish you all good luck and have a good weekend!UPD: You can see score distribution at the problems page.UPD2: You can find editorial here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11309",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 614
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces",
          "content": "Sorry for my poor English. If you find a mistake, write me a private message, I'll fix it. Some problems have not been translated yet, now you can try to read the Russian version of editorial with Google Translate.408A - Line to CashierIn this problem you were to find waiting the time for every queue by summing up the purchases of all the people, and return the minimum.408B - GarlandIn this problem it is necessary to find the garland with the maximal length, which can be composed of elements that we have. First, if you need some color, but you don't have it, then the answer is -1 Otherwise, answer is always exists. Let's sum the answers for all the colors separately. Suppose we have a pieces of a garland of some color, and we need b pieces. Then we have to add min(a, b) to the answer: if a >  = b we will use b 1 meter pieces, in the other case if a < b we will use all a pieces.407A - TriangleIn this problem you have to locate the right triangle with cathetuses a, b on a plane with its vertices in integer points. If the required layout exists, then cathetus a always can be represented as a vector with integer coordinates A{x;y}, and a2 = x2 + y2. Iterate over all possible x (1 ≤ x ≤ a - 1), check, that y = sqrt(a2 - x2) is integer. Vector, ortogonal to vector {x;y}, is { - y;x}. Take vector B{ - y / g;x / g}, where g = gcd(x, y). The triangle can be located on the plane if and only if b % |B| = 0, where |B| — length of vector B. The candidate for the answer — triangle (0;0)(x;y)( - y / g * b / |B|;x / g * b / |B|), but don't forget about checking that the hypotenuse isn't parallel to coordinate axes.407B - Long PathIn this problem you had to simulate route of character in graph. Note that if you are in vertice i, then edges in all vertices with numbers less than i are turned to pi. It gives us opportunity to see a recurrence formula: let dpi be number of steps, needed to get from vertice 1 to vertice i, if all edges are rotated back, into pi. Then dpi + 1 = 2dpi + 2 - dppi. Answer will be dpn + 1.BONUS: Can you solve this task without statement pi ≤ i? I don't know the solution, it seems difficult.407C - Curious ArrayIn this problem you had to find how to add binomial coefficients in array offline. Let's see, how problem changes due to increasing k from small to big values.1) All queries have K = 0 Every time you add 1 on subsegment. For solve this task you can add 1 at some array b[] in b[L] 1, then substract 1 from b[R+1], and after doing all queries make array a[] as array of prefix sums of array b[].2) All queries have K = 1 Arithmetic progression 1 2 3 4 ... is added on subsegment For solve this task you can add 1 at some array c[] in c[L] 1, then substract 1 from c[R+1], and after doing all queries make array b[] as array of prefix sums of array c[]. Actually you added 1 1 ... 1 on every subsegment at each query. If you will substract (R — L + 1) from c[R+1], and make array a[] as array of prefix sums of array b[], then it will be an answer: 1 1 ... 1 became 1 2 3 ... (R-L+1).3) K is arbitrary Summaring previous results one can see that if we will do a[K+1][L] += 1 a[j][R+1] -= C(k + 1 — j + r — l, k + 1 — j) for all 1 <= j <= K + 1 and after that do a[i][j] = a[i][j-1] + a[i+1][j] (making a[i] as array of prefix sums array a[i+1]), a[0] will be the answer. What is C(k + 1 — j + r — l, k + 1 — j)? This number is need for each query affect only on segment L..R, and you can see, why is it so, in Pascal's Triangle.If this explanation is not clear for you, you can try to see other participants solutions (for example, Xellos's one).407D - Largest Submatrix 3In this task you have to find largest by area submatrix, consisting from different numbers. Let's see solutions from slow to fast.1) Solution by O(n6): Iterate through two opposite vertices submatrix-answer and check that all numbers are different.2) Solution by O(n4): Let's fix Up and Down borders submatrix-answer (O(n2)). Use two pointers method to iterate Left and Right borders: while in submatrix there are no equal numbers, increment Right, while there are equal numbers — increment Left. Every check — (O(n)), increments — (O(n)).3) Solution by O(n3logn): Let's construct function maxR(Left) (let's consider that Up <= Down are fixed): maximal value Right, so that in submatrix (Up, Down, Left, Right) there is no equals numbers. You can see that maxR(i) <= maxR(i + 1) is true for every i. How values of this function changes by shift Down to Down-1? Every value maxR(Left) can only be the same (if segment(Down, Down, Left, maxR(Left)) only added new numbers), or it can decrease. When maxR(Left) is decreasing? Only when one of the numbers from added segment have already been in the current submatrix. Shift Down to down let's see all numbers in row Down. For each number (let it be in column j) find indices i and k so i <= j, there is number, equal to a[Down][j] between rows Up and Down-1, i — maximal; k >= j, there is number, equal to a[Down][j] between rows Up and Down-1, k — minimal. When you find these indices (it is easy to find them using set, when you store all columns where number x was between Up and Down for all numbers x), you can try to update maxR[i] with j — 1, maxR[j] with k — 1. It will be enough, if you also update for all i = m..1 maxR[i] = min(maxR[i], maxR[i + 1]). Now maxR(Left) is correct, and you can check answer for these Up and Down by O(n).4) Now, solution by O(n3). It requires understanding previous solution. Previous solution, despite good asymptotics, requires to store a lot (about 160 000) sets, where you will store about 160 000 elements. Even at n = 200 it works very slow. Let's get rid of log. Set is using only for finding nearest left and right elements, which are in rows from Up to Down, and equal to current. Note that when you do Up = Up — 1, nearest element comes near (by column) to a[i][j], so we can find all numbers, for which the nearest element will be in new row Up, and update them nearest number, and do that in O(n2). This solution uses O(n2) memory and O(n3) time.BONUS: Can you solve this task faster than O(n3)? I spend a lot of time and I didn't come to any solution, but I can't show that there is not solution faster.407E - k-d-sequenceIn this problem you have to find longest subsegment, satisfying the condition.Reduce problem to d = 1.If d = 0, then answer is longest subsegment from equal numbers, this case we solve separately. If d ≠ 0, then notice that if on some subsegment there are two numbers ai, aj so that ai%d ≠ aj%d, then this segment can't be good. Divide the sequence to consequent subsegments numbers, equal by modulo d, and divide each number by d, and solve task separately with every segment, consider that d = 1. Notice that segment [L, R] is good if and only if when max(L, R) — min(L, R) — (R — L) <= k, and there are no equal numbers. It is easy to exlain: if there are no equal numbers, then max(L, R) — min(L, R) — (R — L) is exactly number of numbers is needed to add for segment to consist of all numbers from min(L, R) to max(L, R). For all L lets find such maxR[L], that on segment [L..maxR[l]] there are no equal numbers, and maxR[L] is maximal. It can be done by O(nlogn) by many ways, for example you can use map. Let's learn how we can maintain array a[R] = max(L, R) — min(L, R) — (R — L). If we have such array, then we have to find rightmost R such that a[R] <= k to get an answer. We will need two stacks and segment tree with operations \"Add number on segment\", \"Find min element on segment\", \"Find rightmost number doesn't exceed k\". Let's iterate L from right to left (n downto 1). How does function max(L, R) look like with fixed L? It's values represent a set of segments so that maximum on the segment is leftmost element of segment, and these maximums are increasing. (example: for array 6 4 8 0 7 9 function max(1, R) will be 6 6 8 8 8 9). How function changes with shift L to left? Some segments are absorbed by new element, if new element is bigger than maximum on segment. Maximums on segments are increasing, so we can keep them all in stack, and when we need to add new element we have to only pop some segments from stacks while maximum on top of stack is less then new element, and push new segment after that. If every operation with stack will be accompanied with right operation with segment tree, we can store array a[R] = max(L, R). For get array a[R] = max(L, R) — min(L, R) we need only to maintain second similar stack. For get array a[R] = max(L, R) — min(L, R) we need add -1 on all suffix when we are shitfing L. Now query \"Find fightmost number less of equal k\". First, segment tree divides segment of request to log(n) segments with length powers of two. Let's choose rightmost segment with minimum <= k, and do iterative deeping there to find element that we need.So, for every L we get query on segment L..maxR(L) on rightmost number less or equal k. It is one of candidates to an answer. We are doing O(n) operation with stack, and every requires query to segment tree, so asymptotics is O(nlogn).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11333",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 408 和字母"
          },
          "content_length": 9077
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #239 - Codeforces - Code 1",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 2",
          "code": "YES\n0 0\n12 9\n-12 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 3",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 4",
          "code": "YES \n0 0 \n9 12\n-16 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 5",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 6",
          "code": "YES\n0 0\n75 180\n432 -180",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 7",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 - Codeforces - Code 8",
          "code": "YES\n2496 2497\n2500 2500\n2497 2496",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11309",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 1",
          "code": "dp[i] = 1 + (dp[p[i]]+1) + (dp[p[i]+1]+1) + ... + (dp[i-1]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 2",
          "code": "(dp[1]+1) + (dp[2]+1) + (dp[3]+1) + ... + (dp[n]+1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 3",
          "code": "s[p[k]]+s[p[k]+1]+s[p[k]+2]+...+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 4",
          "code": "s[k]=2+s[p[k]]+s[p[k]+1]+s[p[k]+2]+..+s[k-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 5",
          "code": "answer=s[1]+s[2]+..+s[n]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 6",
          "code": "dp[i] = the number of steps needed to move from room i to room (i + 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 7",
          "code": "dp[i] = 2 + sum(dp[j]) for j in [p[i], i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #239 Editorial - Codeforces - Code 8",
          "code": "sum(dp[i]) for (1 ≤ i ≤ n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11333",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000);\n    inf.readSpace();\n    int m = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    inf.readInts(n, 0, 1000000000);\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int li = inf.readInt(1, n);\n        inf.readSpace();\n        int ri = inf.readInt(li, n);\n        inf.readSpace();\n        int ki = inf.readInt(0, 100);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000);\n    inf.readSpace();\n    int m = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    inf.readInts(n, 0, 1000000000);\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int li = inf.readInt(1, n);\n        inf.readSpace();\n        int ri = inf.readInt(li, n);\n        inf.readSpace();\n        int ki = inf.readInt(0, 100);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000);\n    inf.readSpace();\n    int m = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    inf.readInts(n, 0, 1000000000);\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int li = inf.readInt(1, n);\n        inf.readSpace();\n        int ri = inf.readInt(li, n);\n        inf.readSpace();\n        int ki = inf.readInt(0, 100);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string initial = opt<string>(\"initial\", \"random\");\n    string queries_type = opt<string>(\"queries\", \"random\");\n\n    vector<int> a(n);\n\n    if (initial == \"min\") {\n        // All a[i] = 0\n        fill(a.begin(), a.end(), 0);\n    } else if (initial == \"max\") {\n        // All a[i] = 1e9\n        fill(a.begin(), a.end(), 1000000000);\n    } else if (initial == \"zeros\") {\n        // All a[i] = 0\n        fill(a.begin(), a.end(), 0);\n    } else if (initial == \"ones\") {\n        // All a[i] = 1\n        fill(a.begin(), a.end(), 1);\n    } else if (initial == \"alternating\") {\n        // a[i] alternates between 0 and 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 0 : 1000000000;\n        }\n    } else if (initial == \"staggered_max\") {\n        // a[i] increases up to 1e9\n        int max_val = 1000000000;\n        int step = max(1, max_val / n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i * step) % (max_val + 1);\n        }\n    } else {\n        // Random a[i] in [0, 1e9]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Generate m queries\n    vector<tuple<int, int, int>> queries(m);\n\n    if (queries_type == \"single_point\") {\n        // All queries are on single elements\n        for (int i = 0; i < m; ++i) {\n            int pos = rnd.next(1, n);\n            int k = rnd.next(0, 100);\n            queries[i] = make_tuple(pos, pos, k);\n        }\n    } else if (queries_type == \"full_range\") {\n        // Queries cover the whole array\n        for (int i = 0; i < m; ++i) {\n            int k = rnd.next(0, 100);\n            queries[i] = make_tuple(1, n, k);\n        }\n    } else if (queries_type == \"max_k\") {\n        // All k = 100\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_tuple(l, r, 100);\n        }\n    } else if (queries_type == \"min_k\") {\n        // All k = 0\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_tuple(l, r, 0);\n        }\n    } else if (queries_type == \"overlapping\") {\n        // Overlapping queries\n        int blockSize = max(1, n / m);\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = min(n, l + rnd.next(0, blockSize));\n            int k = rnd.next(0, 100);\n            queries[i] = make_tuple(l, r, k);\n        }\n    } else if (queries_type == \"edge_cases\") {\n        // Edge index queries\n        for (int i = 0; i < m; ++i) {\n            int l = (rnd.next(0, 1) == 0) ? 1 : n;\n            int r = l;\n            int k = rnd.next(0, 100);\n            queries[i] = make_tuple(l, r, k);\n        }\n    } else if (queries_type == \"increasing\") {\n        // Queries with increasing l and r\n        int last_r = 1;\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(last_r, n);\n            int r = rnd.next(l, n);\n            int k = rnd.next(0, 100);\n            queries[i] = make_tuple(l, r, k);\n            last_r = r;\n        }\n    } else {\n        // Random queries\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int k = rnd.next(0, 100);\n            queries[i] = make_tuple(l, r, k);\n        }\n    }\n\n    // Output queries\n    for (int i = 0; i < m; ++i) {\n        int l, r, k;\n        tie(l, r, k) = queries[i];\n        printf(\"%d %d %d\\n\", l, r, k);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string initial = opt<string>(\"initial\", \"random\");\n    string queries_type = opt<string>(\"queries\", \"random\");\n\n    vector<int> a(n);\n\n    if (initial == \"min\") {\n        // All a[i] = 0\n        fill(a.begin(), a.end(), 0);\n    } else if (initial == \"max\") {\n        // All a[i] = 1e9\n        fill(a.begin(), a.end(), 1000000000);\n    } else if (initial == \"zeros\") {\n        // All a[i] = 0\n        fill(a.begin(), a.end(), 0);\n    } else if (initial == \"ones\") {\n        // All a[i] = 1\n        fill(a.begin(), a.end(), 1);\n    } else if (initial == \"alternating\") {\n        // a[i] alternates between 0 and 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? 0 : 1000000000;\n        }\n    } else if (initial == \"staggered_max\") {\n        // a[i] increases up to 1e9\n        int max_val = 1000000000;\n        int step = max(1, max_val / n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i * step) % (max_val + 1);\n        }\n    } else {\n        // Random a[i] in [0, 1e9]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1000000000);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output array a\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Generate m queries\n    vector<tuple<int, int, int>> queries(m);\n\n    if (queries_type == \"single_point\") {\n        // All queries are on single elements\n        for (int i = 0; i < m; ++i) {\n            int pos = rnd.next(1, n);\n            int k = rnd.next(0, 100);\n            queries[i] = make_tuple(pos, pos, k);\n        }\n    } else if (queries_type == \"full_range\") {\n        // Queries cover the whole array\n        for (int i = 0; i < m; ++i) {\n            int k = rnd.next(0, 100);\n            queries[i] = make_tuple(1, n, k);\n        }\n    } else if (queries_type == \"max_k\") {\n        // All k = 100\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_tuple(l, r, 100);\n        }\n    } else if (queries_type == \"min_k\") {\n        // All k = 0\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_tuple(l, r, 0);\n        }\n    } else if (queries_type == \"overlapping\") {\n        // Overlapping queries\n        int blockSize = max(1, n / m);\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = min(n, l + rnd.next(0, blockSize));\n            int k = rnd.next(0, 100);\n            queries[i] = make_tuple(l, r, k);\n        }\n    } else if (queries_type == \"edge_cases\") {\n        // Edge index queries\n        for (int i = 0; i < m; ++i) {\n            int l = (rnd.next(0, 1) == 0) ? 1 : n;\n            int r = l;\n            int k = rnd.next(0, 100);\n            queries[i] = make_tuple(l, r, k);\n        }\n    } else if (queries_type == \"increasing\") {\n        // Queries with increasing l and r\n        int last_r = 1;\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(last_r, n);\n            int r = rnd.next(l, n);\n            int k = rnd.next(0, 100);\n            queries[i] = make_tuple(l, r, k);\n            last_r = r;\n        }\n    } else {\n        // Random queries\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int k = rnd.next(0, 100);\n            queries[i] = make_tuple(l, r, k);\n        }\n    }\n\n    // Output queries\n    for (int i = 0; i < m; ++i) {\n        int l, r, k;\n        tie(l, r, k) = queries[i];\n        printf(\"%d %d %d\\n\", l, r, k);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -initial zeros -queries single_point\n./gen -n 1 -m 1 -initial zeros -queries full_range\n\n./gen -n 5 -m 2 -initial zeros -queries random\n./gen -n 5 -m 2 -initial ones -queries random\n./gen -n 5 -m 2 -initial random -queries random\n\n./gen -n 10 -m 5 -initial zeros -queries random\n./gen -n 10 -m 5 -initial max -queries random\n\n./gen -n 100 -m 50 -initial random -queries overlapping\n./gen -n 100 -m 50 -initial random -queries edge_cases\n\n./gen -n 1000 -m 1000 -initial random -queries random\n./gen -n 1000 -m 1000 -initial random -queries max_k\n\n./gen -n 10000 -m 10000 -initial zeros -queries full_range\n./gen -n 10000 -m 10000 -initial zeros -queries min_k\n\n./gen -n 50000 -m 50000 -initial alternating -queries random\n./gen -n 50000 -m 50000 -initial alternating -queries overlapping\n\n./gen -n 100000 -m 100000 -initial zeros -queries random\n./gen -n 100000 -m 100000 -initial random -queries random\n\n./gen -n 100000 -m 100000 -initial max -queries single_point\n\n./gen -n 100000 -m 100000 -initial random -queries increasing\n\n./gen -n 100000 -m 1 -initial zeros -queries full_range\n\n./gen -n 50000 -m 1 -initial zeros -queries full_range\n\n./gen -n 10000 -m 100000 -initial zeros -queries full_range\n\n./gen -n 100000 -m 100000 -initial max -queries max_k\n\n./gen -n 100000 -m 1 -initial zeros -queries edge_cases\n\n./gen -n 100000 -m 0 -initial random -queries random\n\n./gen -n 1 -m 100000 -initial ones -queries single_point\n\n./gen -n 100000 -m 100000 -initial zeros -queries min_k\n\n./gen -n 1 -m 1 -initial zeros -queries full_range\n\n./gen -n 100000 -m 100000 -initial zeros -queries single_point\n\n./gen -n 100000 -m 100000 -initial zeros -queries overlapping\n\n./gen -n 100000 -m 100000 -initial zeros -queries edge_cases\n\n./gen -n 20 -m 1 -initial zeros -queries full_range\n./gen -n 20 -m 1 -initial zeros -queries single_point\n\n./gen -n 100000 -m 100000 -initial alternating -queries random\n\n./gen -n 100000 -m 100000 -initial staggered_max -queries min_k\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:50.227708",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "41/A",
      "title": "A. Translation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains word s, the second line contains word t. The words consist of lowercase Latin letters. The input data do not contain unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.",
      "output_spec": "OutputIf the word t is a word s, written reversely, print YES, otherwise print NO.",
      "sample_tests": "ExamplesInputCopycodeedocOutputCopyYESInputCopyabbabaOutputCopyNOInputCopycodecodeOutputCopyNO",
      "description": "A. Translation\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains word s, the second line contains word t. The words consist of lowercase Latin letters. The input data do not contain unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.\n\nOutputIf the word t is a word s, written reversely, print YES, otherwise print NO.\n\nInputCopycodeedocOutputCopyYESInputCopyabbabaOutputCopyNOInputCopycodecodeOutputCopyNO\n\nInputCopycodeedoc\n\nOutputCopyYES\n\nInputCopyabbaba\n\nOutputCopyNO\n\nInputCopycodecode\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Beta Round #40 (Div. 2) - Codeforces",
          "content": "Hi, everybody!Welcome to the  \"Codeforces Beta Round #40 (Div. 2)\". Let the weather cloudy (at least in Saratov), and the round began with the unavailability of the server (we apologize for a fail), but I hope the tasks will bring you pleasure.Wish you high ratings,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/843",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 280
        },
        {
          "title": "Codeforces Beta Round #40 Mini-Tutorial - Codeforces",
          "content": "I wrote this post to help my friend , Iman Movahhedi , complete this one.Round #40 was my first contest here in Codeforces and I feel I fell in love with CF just after that.A-Translation: (C# code)Many languages have built-in reverse() function for strings. we can reverse one of the strings and check if it's equal to the other one , or we can check it manually. I prefer the second. B-Martian Dollar: (C# code)Since number of days is very small (2 × 103) we can just iterate over all possibilities of buy-day and sell-day. This will take θ (n2) time which is OK.C-Email Address: (C++ code)The first letter of the input string can not be part of an \"at\" or a \"dot\" so we start from the second character. Greedily put \".\" wherever you reached \"dot\" and put \"@\" the first time you reached \"at\". This will take θ(n) time , where n is the length of input.D-Pawn:For each cell of the table store k + 1 values. Where ith value is the maximum number of peas the pawn can take while he is at that cell and this number mod k + 1 is i.This makes a O(n2 × m × k) dynamic programming which fits perfectly in the time.E-3-cycles: (C++ code)The road map with most edges is a complete bipartite graph with equal number of vertices on each side. (Prove it by yourself :D ). We can make such a graph by putting the first vertices on one side and the other on the other side.For sure , number of edges is .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1620",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1389
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[a-z]{1,100}\", \"s\");\n    string t = inf.readLine(\"[a-z]{1,100}\", \"t\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[a-z]{1,100}\", \"s\");\n    string t = inf.readLine(\"[a-z]{1,100}\", \"t\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[a-z]{1,100}\", \"s\");\n    string t = inf.readLine(\"[a-z]{1,100}\", \"t\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generateRandomString(int n) {\n    string s;\n    for(int i = 0; i < n; ++i) {\n        s += (char)('a' + rnd.next(26));\n    }\n    return s;\n}\n\nstring reverseString(string s) {\n    reverse(s.begin(), s.end());\n    return s;\n}\n\nchar getDifferentChar(char c) {\n    char new_c;\n    do {\n        new_c = 'a' + rnd.next(26);\n    } while(new_c == c);\n    return new_c;\n}\n\nstring generatePalindrome(int n) {\n    string s(n, 'a');\n    for(int i = 0; i <= (n - 1) / 2; ++i) {\n        char c = 'a' + rnd.next(26);\n        s[i] = c;\n        s[n - i - 1] = c;\n    }\n    return s;\n}\n\nstring generateNonPalindrome(int n) {\n    string s = generateRandomString(n);\n    if (s == reverseString(s)) {\n        // Modify one character to make it not a palindrome\n        int pos = rnd.next(0, n - 1);\n        s[pos] = getDifferentChar(s[pos]);\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s, t;\n\n    if (type == \"yes\") {\n        // t is the reverse of s\n        s = generateRandomString(n);\n        t = reverseString(s);\n    } else if (type == \"no\") {\n        // t is not the reverse of s\n        s = generateRandomString(n);\n        t = reverseString(s);\n        int pos = rnd.next(0, n - 1);\n        t[pos] = getDifferentChar(t[pos]);\n    } else if (type == \"palindrome\") {\n        // s is a palindrome, t = reverse(s) (which is same as s)\n        s = generatePalindrome(n);\n        t = reverseString(s);\n    } else if (type == \"same\") {\n        // s is not a palindrome, t equals s\n        s = generateNonPalindrome(n);\n        t = s;\n    } else {\n        // Random s and t\n        s = generateRandomString(n);\n        t = generateRandomString(n);\n    }\n\n    // Output s and t\n    cout << s << endl << t << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generateRandomString(int n) {\n    string s;\n    for(int i = 0; i < n; ++i) {\n        s += (char)('a' + rnd.next(26));\n    }\n    return s;\n}\n\nstring reverseString(string s) {\n    reverse(s.begin(), s.end());\n    return s;\n}\n\nchar getDifferentChar(char c) {\n    char new_c;\n    do {\n        new_c = 'a' + rnd.next(26);\n    } while(new_c == c);\n    return new_c;\n}\n\nstring generatePalindrome(int n) {\n    string s(n, 'a');\n    for(int i = 0; i <= (n - 1) / 2; ++i) {\n        char c = 'a' + rnd.next(26);\n        s[i] = c;\n        s[n - i - 1] = c;\n    }\n    return s;\n}\n\nstring generateNonPalindrome(int n) {\n    string s = generateRandomString(n);\n    if (s == reverseString(s)) {\n        // Modify one character to make it not a palindrome\n        int pos = rnd.next(0, n - 1);\n        s[pos] = getDifferentChar(s[pos]);\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s, t;\n\n    if (type == \"yes\") {\n        // t is the reverse of s\n        s = generateRandomString(n);\n        t = reverseString(s);\n    } else if (type == \"no\") {\n        // t is not the reverse of s\n        s = generateRandomString(n);\n        t = reverseString(s);\n        int pos = rnd.next(0, n - 1);\n        t[pos] = getDifferentChar(t[pos]);\n    } else if (type == \"palindrome\") {\n        // s is a palindrome, t = reverse(s) (which is same as s)\n        s = generatePalindrome(n);\n        t = reverseString(s);\n    } else if (type == \"same\") {\n        // s is not a palindrome, t equals s\n        s = generateNonPalindrome(n);\n        t = s;\n    } else {\n        // Random s and t\n        s = generateRandomString(n);\n        t = generateRandomString(n);\n    }\n\n    // Output s and t\n    cout << s << endl << t << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type yes\n./gen -n 1 -type no\n./gen -n 1 -type palindrome\n./gen -n 1 -type same\n./gen -n 1 -type random\n\n./gen -n 2 -type yes\n./gen -n 2 -type no\n./gen -n 2 -type palindrome\n./gen -n 2 -type same\n./gen -n 2 -type random\n\n./gen -n 10 -type yes\n./gen -n 10 -type no\n./gen -n 10 -type palindrome\n./gen -n 10 -type same\n./gen -n 10 -type random\n\n./gen -n 50 -type yes\n./gen -n 50 -type no\n./gen -n 50 -type palindrome\n./gen -n 50 -type same\n./gen -n 50 -type random\n\n./gen -n 99 -type yes\n./gen -n 99 -type no\n./gen -n 99 -type palindrome\n./gen -n 99 -type same\n./gen -n 99 -type random\n\n./gen -n 100 -type yes\n./gen -n 100 -type no\n./gen -n 100 -type palindrome\n./gen -n 100 -type same\n./gen -n 100 -type random\n\n./gen -n 20 -type yes\n./gen -n 30 -type no\n./gen -n 40 -type palindrome\n./gen -n 60 -type same\n./gen -n 80 -type random\n\n./gen -n 1 -type same\n./gen -n 100 -type same\n\n./gen -n 2 -type palindrome\n./gen -n 2 -type same\n\n./gen -n 99 -type random\n./gen -n 50 -type random\n./gen -n 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:52.260847",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "41/B",
      "title": "B. Martian Dollar",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and b (1 ≤ n, b ≤ 2000) — the number of days and the initial number of money in bourles. The next line contains n integers ai (1 ≤ ai ≤ 2000) — the prices of Martian dollars.",
      "output_spec": "OutputPrint the single number — which maximal sum of money in bourles can Vasya get by the end of day n.",
      "sample_tests": "ExamplesInputCopy2 43 7OutputCopy8InputCopy4 104 3 2 1OutputCopy10InputCopy4 104 2 3 1OutputCopy15",
      "description": "B. Martian Dollar\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and b (1 ≤ n, b ≤ 2000) — the number of days and the initial number of money in bourles. The next line contains n integers ai (1 ≤ ai ≤ 2000) — the prices of Martian dollars.\n\nOutputPrint the single number — which maximal sum of money in bourles can Vasya get by the end of day n.\n\nInputCopy2 43 7OutputCopy8InputCopy4 104 3 2 1OutputCopy10InputCopy4 104 2 3 1OutputCopy15\n\nInputCopy2 43 7\n\nOutputCopy8\n\nInputCopy4 104 3 2 1\n\nOutputCopy10\n\nInputCopy4 104 2 3 1\n\nOutputCopy15",
      "solutions": [
        {
          "title": "Codeforces Beta Round #40 (Div. 2) - Codeforces",
          "content": "Hi, everybody!Welcome to the  \"Codeforces Beta Round #40 (Div. 2)\". Let the weather cloudy (at least in Saratov), and the round began with the unavailability of the server (we apologize for a fail), but I hope the tasks will bring you pleasure.Wish you high ratings,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/843",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 280
        },
        {
          "title": "Codeforces Beta Round #40 Mini-Tutorial - Codeforces",
          "content": "I wrote this post to help my friend , Iman Movahhedi , complete this one.Round #40 was my first contest here in Codeforces and I feel I fell in love with CF just after that.A-Translation: (C# code)Many languages have built-in reverse() function for strings. we can reverse one of the strings and check if it's equal to the other one , or we can check it manually. I prefer the second. B-Martian Dollar: (C# code)Since number of days is very small (2 × 103) we can just iterate over all possibilities of buy-day and sell-day. This will take θ (n2) time which is OK.C-Email Address: (C++ code)The first letter of the input string can not be part of an \"at\" or a \"dot\" so we start from the second character. Greedily put \".\" wherever you reached \"dot\" and put \"@\" the first time you reached \"at\". This will take θ(n) time , where n is the length of input.D-Pawn:For each cell of the table store k + 1 values. Where ith value is the maximum number of peas the pawn can take while he is at that cell and this number mod k + 1 is i.This makes a O(n2 × m × k) dynamic programming which fits perfectly in the time.E-3-cycles: (C++ code)The road map with most edges is a complete bipartite graph with equal number of vertices on each side. (Prove it by yourself :D ). We can make such a graph by putting the first vertices on one side and the other on the other side.For sure , number of edges is .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1620",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1389
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and b\n    int n = inf.readInt(1, 2000, \"n\"); // n in [1, 2000]\n    inf.readSpace();\n    int b = inf.readInt(1, 2000, \"b\"); // b in [1, 2000]\n    inf.readEoln();\n\n    // Read n integers ai\n    inf.readInts(n, 1, 2000);\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and b\n    int n = inf.readInt(1, 2000, \"n\"); // n in [1, 2000]\n    inf.readSpace();\n    int b = inf.readInt(1, 2000, \"b\"); // b in [1, 2000]\n    inf.readEoln();\n\n    // Read n integers ai\n    inf.readInts(n, 1, 2000);\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and b\n    int n = inf.readInt(1, 2000, \"n\"); // n in [1, 2000]\n    inf.readSpace();\n    int b = inf.readInt(1, 2000, \"b\"); // b in [1, 2000]\n    inf.readEoln();\n\n    // Read n integers ai\n    inf.readInts(n, 1, 2000);\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int b = opt<int>(\"b\", rnd.next(1,2000));\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a(n);\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 2000);\n    } else if (type == \"constant\") {\n        int val = rnd.next(1,2000);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"increasing\") {\n        int start = rnd.next(1,2000 - n + 1);\n        for(int i = 0; i < n; ++i)\n            a[i] = start + i;\n    } else if (type == \"decreasing\") {\n        int start = rnd.next(n,2000);\n        for(int i = 0; i < n; ++i)\n            a[i] = start - i;\n    } else if (type == \"peak\") {\n        int mid = n / 2;\n        int start = rnd.next(1,2000 - mid);\n        for(int i = 0; i < mid; ++i)\n            a[i] = start + i;\n        for(int i = mid; i < n; ++i)\n            a[i] = a[mid-1] - (i - mid + 1);\n    } else if (type == \"valley\") {\n        int mid = n / 2;\n        int start = rnd.next(mid,2000);\n        for(int i = 0; i < mid; ++i)\n            a[i] = start - i;\n        for(int i = mid; i < n; ++i)\n            a[i] = a[mid-1] + (i - mid + 1);\n    } else if (type == \"zigzag\") {\n        for(int i = 0; i < n; ++i)\n            if (i % 2 == 0)\n                a[i] = rnd.next(1,1000);\n            else\n                a[i] = rnd.next(1001,2000);\n    } else if (type == \"randomsmall\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1,10);\n    } else if (type == \"randomlarge\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1990,2000);\n    } else if (type == \"maxprofit\") {\n        int start = rnd.next(1,2000 - n + 1);\n        for(int i = 0; i < n; ++i)\n            a[i] = start + i;\n    } else if (type == \"minprofit\") {\n        int start = rnd.next(n,2000);\n        for(int i = 0; i < n; ++i)\n            a[i] = start - i;\n    } else if (type == \"constantmax\") {\n        int val = 2000;\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"constantmin\") {\n        int val = 1;\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"onepeak\") {\n        int peak_day = rnd.next(1,n-2);\n        for(int i = 0; i < peak_day; ++i)\n            a[i] = rnd.next(1,1000);\n        a[peak_day] = rnd.next(1001,2000);\n        for(int i = peak_day+1; i < n; ++i)\n            a[i] = rnd.next(1,1000);\n    } else if (type == \"onevalley\") {\n        int valley_day = rnd.next(1,n-2);\n        for(int i = 0; i < valley_day; ++i)\n            a[i] = rnd.next(1001,2000);\n        a[valley_day] = rnd.next(1,1000);\n        for(int i = valley_day+1; i < n; ++i)\n            a[i] = rnd.next(1001,2000);\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 2000);\n    }\n    // Output n and b\n    printf(\"%d %d\\n\", n, b);\n    // Output a_i\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n -1) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int b = opt<int>(\"b\", rnd.next(1,2000));\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a(n);\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 2000);\n    } else if (type == \"constant\") {\n        int val = rnd.next(1,2000);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"increasing\") {\n        int start = rnd.next(1,2000 - n + 1);\n        for(int i = 0; i < n; ++i)\n            a[i] = start + i;\n    } else if (type == \"decreasing\") {\n        int start = rnd.next(n,2000);\n        for(int i = 0; i < n; ++i)\n            a[i] = start - i;\n    } else if (type == \"peak\") {\n        int mid = n / 2;\n        int start = rnd.next(1,2000 - mid);\n        for(int i = 0; i < mid; ++i)\n            a[i] = start + i;\n        for(int i = mid; i < n; ++i)\n            a[i] = a[mid-1] - (i - mid + 1);\n    } else if (type == \"valley\") {\n        int mid = n / 2;\n        int start = rnd.next(mid,2000);\n        for(int i = 0; i < mid; ++i)\n            a[i] = start - i;\n        for(int i = mid; i < n; ++i)\n            a[i] = a[mid-1] + (i - mid + 1);\n    } else if (type == \"zigzag\") {\n        for(int i = 0; i < n; ++i)\n            if (i % 2 == 0)\n                a[i] = rnd.next(1,1000);\n            else\n                a[i] = rnd.next(1001,2000);\n    } else if (type == \"randomsmall\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1,10);\n    } else if (type == \"randomlarge\") {\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1990,2000);\n    } else if (type == \"maxprofit\") {\n        int start = rnd.next(1,2000 - n + 1);\n        for(int i = 0; i < n; ++i)\n            a[i] = start + i;\n    } else if (type == \"minprofit\") {\n        int start = rnd.next(n,2000);\n        for(int i = 0; i < n; ++i)\n            a[i] = start - i;\n    } else if (type == \"constantmax\") {\n        int val = 2000;\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"constantmin\") {\n        int val = 1;\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"onepeak\") {\n        int peak_day = rnd.next(1,n-2);\n        for(int i = 0; i < peak_day; ++i)\n            a[i] = rnd.next(1,1000);\n        a[peak_day] = rnd.next(1001,2000);\n        for(int i = peak_day+1; i < n; ++i)\n            a[i] = rnd.next(1,1000);\n    } else if (type == \"onevalley\") {\n        int valley_day = rnd.next(1,n-2);\n        for(int i = 0; i < valley_day; ++i)\n            a[i] = rnd.next(1001,2000);\n        a[valley_day] = rnd.next(1,1000);\n        for(int i = valley_day+1; i < n; ++i)\n            a[i] = rnd.next(1001,2000);\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 2000);\n    }\n    // Output n and b\n    printf(\"%d %d\\n\", n, b);\n    // Output a_i\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i < n -1) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -b 1 -type random\n./gen -n 1 -b 2000 -type random\n./gen -n 2 -b 2000 -type increasing\n./gen -n 2 -b 2000 -type decreasing\n./gen -n 100 -b 1000 -type random\n./gen -n 100 -b 1000 -type constant\n./gen -n 100 -b 1000 -type increasing\n./gen -n 100 -b 1000 -type decreasing\n./gen -n 100 -b 1000 -type peak\n./gen -n 100 -b 1000 -type valley\n./gen -n 100 -b 1000 -type zigzag\n./gen -n 100 -b 1000 -type randomsmall\n./gen -n 100 -b 1000 -type randomlarge\n./gen -n 100 -b 1000 -type maxprofit\n./gen -n 100 -b 1000 -type minprofit\n./gen -n 1000 -b 2000 -type random\n./gen -n 1000 -b 2000 -type increasing\n./gen -n 1000 -b 2000 -type decreasing\n./gen -n 1000 -b 2000 -type peak\n./gen -n 1000 -b 2000 -type valley\n./gen -n 1000 -b 2000 -type onepeak\n./gen -n 1000 -b 2000 -type onevalley\n./gen -n 2000 -b 2000 -type random\n./gen -n 2000 -b 2000 -type constantmax\n./gen -n 2000 -b 1 -type constantmin\n./gen -n 2000 -b 2000 -type zigzag\n./gen -n 2000 -b 2000 -type randomsmall\n./gen -n 2000 -b 2000 -type randomlarge\n./gen -n 2000 -b 2000 -type maxprofit\n./gen -n 2000 -b 2000 -type minprofit\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:54.876482",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "41/C",
      "title": "C. Email address",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains the email address description. It is guaranteed that that is a proper email address with all the dots replaced by dot an the at signs replaced by at. The line is not empty and its length does not exceed 100 symbols.",
      "output_spec": "OutputPrint the shortest email address, from which the given line could be made by the described above replacements. If there are several solutions to that problem, print the lexicographically minimal one (the lexicographical comparison of the lines are implemented with an operator < in modern programming languages).In the ASCII table the symbols go in this order: . @ ab...z",
      "sample_tests": "ExamplesInputCopyvasyaatgmaildotcomOutputCopyvasya@gmail.comInputCopydotdotdotatdotdotatOutputCopydot..@..atInputCopyaattOutputCopya@t",
      "description": "C. Email address\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains the email address description. It is guaranteed that that is a proper email address with all the dots replaced by dot an the at signs replaced by at. The line is not empty and its length does not exceed 100 symbols.\n\nOutputPrint the shortest email address, from which the given line could be made by the described above replacements. If there are several solutions to that problem, print the lexicographically minimal one (the lexicographical comparison of the lines are implemented with an operator < in modern programming languages).In the ASCII table the symbols go in this order: . @ ab...z\n\nInputCopyvasyaatgmaildotcomOutputCopyvasya@gmail.comInputCopydotdotdotatdotdotatOutputCopydot..@..atInputCopyaattOutputCopya@t\n\nInputCopyvasyaatgmaildotcom\n\nOutputCopyvasya@gmail.com\n\nInputCopydotdotdotatdotdotat\n\nOutputCopydot..@..at\n\nInputCopyaatt\n\nOutputCopya@t",
      "solutions": [
        {
          "title": "Codeforces Beta Round #40 (Div. 2) - Codeforces",
          "content": "Hi, everybody!Welcome to the  \"Codeforces Beta Round #40 (Div. 2)\". Let the weather cloudy (at least in Saratov), and the round began with the unavailability of the server (we apologize for a fail), but I hope the tasks will bring you pleasure.Wish you high ratings,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/843",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 280
        },
        {
          "title": "Codeforces Beta Round #40 Mini-Tutorial - Codeforces",
          "content": "I wrote this post to help my friend , Iman Movahhedi , complete this one.Round #40 was my first contest here in Codeforces and I feel I fell in love with CF just after that.A-Translation: (C# code)Many languages have built-in reverse() function for strings. we can reverse one of the strings and check if it's equal to the other one , or we can check it manually. I prefer the second. B-Martian Dollar: (C# code)Since number of days is very small (2 × 103) we can just iterate over all possibilities of buy-day and sell-day. This will take θ (n2) time which is OK.C-Email Address: (C++ code)The first letter of the input string can not be part of an \"at\" or a \"dot\" so we start from the second character. Greedily put \".\" wherever you reached \"dot\" and put \"@\" the first time you reached \"at\". This will take θ(n) time , where n is the length of input.D-Pawn:For each cell of the table store k + 1 values. Where ith value is the maximum number of peas the pawn can take while he is at that cell and this number mod k + 1 is i.This makes a O(n2 × m × k) dynamic programming which fits perfectly in the time.E-3-cycles: (C++ code)The road map with most edges is a complete bipartite graph with equal number of vertices on each side. (Prove it by yourself :D ). We can make such a graph by putting the first vertices on one side and the other on the other side.For sure , number of edges is .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1620",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1389
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 100, \"Length of s must be between 1 and 100\");\n    for (char c : s) {\n        ensuref('a' <= c && c <= 'z', \"All characters must be lowercase letters\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 100, \"Length of s must be between 1 and 100\");\n    for (char c : s) {\n        ensuref('a' <= c && c <= 'z', \"All characters must be lowercase letters\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 100, \"Length of s must be between 1 and 100\");\n    for (char c : s) {\n        ensuref('a' <= c && c <= 'z', \"All characters must be lowercase letters\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a part of the email (local or domain)\nstring generate_part(int length, int num_dots) {\n    // The part should be of length 'length', contain 'num_dots' dots,\n    // not starting or ending with '.'\n    if (length == 1) {\n        // Cannot contain dots\n        num_dots = 0;\n        char c = 'a' + rnd.next(0,25);\n        return string(1, c);\n    }\n\n    vector<int> dot_positions;\n    if (num_dots > 0) {\n        int max_dots = length - 2;\n        num_dots = min(num_dots, max_dots);\n\n        vector<int> positions(length - 2);\n        for (int i = 1; i <= length - 2; ++i) {\n            positions[i - 1] = i;\n        }\n        shuffle(positions.begin(), positions.end());\n        dot_positions.assign(positions.begin(), positions.begin() + num_dots);\n        sort(dot_positions.begin(), dot_positions.end());\n    }\n\n    string s(length, 'a');\n    int dot_idx = 0;\n    for (int i = 0; i < length; ++i) {\n        if (dot_idx < dot_positions.size() && dot_positions[dot_idx] == i) {\n            s[i] = '.';\n            dot_idx++;\n        } else {\n            s[i] = 'a' + rnd.next(0, 25); // Random letter 'a' to 'z'\n        }\n    }\n    return s;\n}\n\n// Function to transform email address by replacing '@' with 'at' and '.' with 'dot'\nstring transform_email(const string& email) {\n    string transformed;\n    for (char c : email) {\n        if (c == '@') {\n            transformed += \"at\";\n        } else if (c == '.') {\n            transformed += \"dot\";\n        } else {\n            transformed += c;\n        }\n    }\n    return transformed;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\", 100);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        int L = len;\n        L = min(L, 99);\n        L = max(L, 3);\n        while (L >= 3) {\n            int max_num_dot = (100 - L - 1) / 2;\n            if (max_num_dot >= 0)\n                break;\n            --L;\n        }\n        if (L < 3) {\n            L = 3;\n        }\n        int max_num_dot = (100 - L - 1) / 2;\n        int num_dot = rnd.next(0, max_num_dot);\n\n        int length_local = rnd.next(1, L - 2);\n        int length_domain = L - length_local - 1;\n\n        int max_dot_local = max(0, length_local - 1);\n        int max_dot_domain = max(0, length_domain - 1);\n\n        int min_num_dot_local = max(0, num_dot - max_dot_domain);\n        int max_num_dot_local = min(max_dot_local, num_dot);\n\n        if (min_num_dot_local > max_num_dot_local)\n            min_num_dot_local = max_num_dot_local;\n\n        int num_dot_local = rnd.next(min_num_dot_local, max_num_dot_local);\n        int num_dot_domain = num_dot - num_dot_local;\n\n        string local_part = generate_part(length_local, num_dot_local);\n        string domain_part = generate_part(length_domain, num_dot_domain);\n\n        string email = local_part + '@' + domain_part;\n\n        string transformed_email = transform_email(email);\n\n        // Output the transformed email\n        printf(\"%s\\n\", transformed_email.c_str());\n    } else if (type == \"overlap\") {\n        // Generate email addresses with overlapping 'at' and 'dot'\n        // For simplicity, we will use fixed patterns that can cause overlapping\n        string email = \"datat@dotdat.com\";\n        string transformed_email = transform_email(email);\n\n        // Ensure the transformed email length does not exceed 100\n        if (transformed_email.length() <= 100) {\n            printf(\"%s\\n\", transformed_email.c_str());\n        } else {\n            // Fallback to a smaller overlapping email\n            email = \"at@dot.com\";\n            transformed_email = transform_email(email);\n            printf(\"%s\\n\", transformed_email.c_str());\n        }\n    } else if (type == \"max_length\") {\n        // Generate an email address with the maximum possible length\n        int L = 99;\n        int num_dot = (100 - L - 1) / 2;\n\n        int length_local = L / 2;\n        int length_domain = L - length_local - 1;\n\n        int num_dot_local = (length_local - 1);\n        int num_dot_domain = num_dot - num_dot_local;\n\n        string local_part(length_local, 'a');\n        for (int i = 1; i < length_local - 1; ++i) {\n            local_part[i] = '.';\n        }\n        string domain_part(length_domain, 'b');\n        for (int i = 1; i < length_domain - 1 && num_dot_domain > 0; ++i, --num_dot_domain) {\n            domain_part[i] = '.';\n        }\n\n        string email = local_part + '@' + domain_part;\n        string transformed_email = transform_email(email);\n\n        printf(\"%s\\n\", transformed_email.c_str());\n    } else {\n        // Default to a simple email address\n        string email = \"user@domain.com\";\n        string transformed_email = transform_email(email);\n        printf(\"%s\\n\", transformed_email.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a part of the email (local or domain)\nstring generate_part(int length, int num_dots) {\n    // The part should be of length 'length', contain 'num_dots' dots,\n    // not starting or ending with '.'\n    if (length == 1) {\n        // Cannot contain dots\n        num_dots = 0;\n        char c = 'a' + rnd.next(0,25);\n        return string(1, c);\n    }\n\n    vector<int> dot_positions;\n    if (num_dots > 0) {\n        int max_dots = length - 2;\n        num_dots = min(num_dots, max_dots);\n\n        vector<int> positions(length - 2);\n        for (int i = 1; i <= length - 2; ++i) {\n            positions[i - 1] = i;\n        }\n        shuffle(positions.begin(), positions.end());\n        dot_positions.assign(positions.begin(), positions.begin() + num_dots);\n        sort(dot_positions.begin(), dot_positions.end());\n    }\n\n    string s(length, 'a');\n    int dot_idx = 0;\n    for (int i = 0; i < length; ++i) {\n        if (dot_idx < dot_positions.size() && dot_positions[dot_idx] == i) {\n            s[i] = '.';\n            dot_idx++;\n        } else {\n            s[i] = 'a' + rnd.next(0, 25); // Random letter 'a' to 'z'\n        }\n    }\n    return s;\n}\n\n// Function to transform email address by replacing '@' with 'at' and '.' with 'dot'\nstring transform_email(const string& email) {\n    string transformed;\n    for (char c : email) {\n        if (c == '@') {\n            transformed += \"at\";\n        } else if (c == '.') {\n            transformed += \"dot\";\n        } else {\n            transformed += c;\n        }\n    }\n    return transformed;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\", 100);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        int L = len;\n        L = min(L, 99);\n        L = max(L, 3);\n        while (L >= 3) {\n            int max_num_dot = (100 - L - 1) / 2;\n            if (max_num_dot >= 0)\n                break;\n            --L;\n        }\n        if (L < 3) {\n            L = 3;\n        }\n        int max_num_dot = (100 - L - 1) / 2;\n        int num_dot = rnd.next(0, max_num_dot);\n\n        int length_local = rnd.next(1, L - 2);\n        int length_domain = L - length_local - 1;\n\n        int max_dot_local = max(0, length_local - 1);\n        int max_dot_domain = max(0, length_domain - 1);\n\n        int min_num_dot_local = max(0, num_dot - max_dot_domain);\n        int max_num_dot_local = min(max_dot_local, num_dot);\n\n        if (min_num_dot_local > max_num_dot_local)\n            min_num_dot_local = max_num_dot_local;\n\n        int num_dot_local = rnd.next(min_num_dot_local, max_num_dot_local);\n        int num_dot_domain = num_dot - num_dot_local;\n\n        string local_part = generate_part(length_local, num_dot_local);\n        string domain_part = generate_part(length_domain, num_dot_domain);\n\n        string email = local_part + '@' + domain_part;\n\n        string transformed_email = transform_email(email);\n\n        // Output the transformed email\n        printf(\"%s\\n\", transformed_email.c_str());\n    } else if (type == \"overlap\") {\n        // Generate email addresses with overlapping 'at' and 'dot'\n        // For simplicity, we will use fixed patterns that can cause overlapping\n        string email = \"datat@dotdat.com\";\n        string transformed_email = transform_email(email);\n\n        // Ensure the transformed email length does not exceed 100\n        if (transformed_email.length() <= 100) {\n            printf(\"%s\\n\", transformed_email.c_str());\n        } else {\n            // Fallback to a smaller overlapping email\n            email = \"at@dot.com\";\n            transformed_email = transform_email(email);\n            printf(\"%s\\n\", transformed_email.c_str());\n        }\n    } else if (type == \"max_length\") {\n        // Generate an email address with the maximum possible length\n        int L = 99;\n        int num_dot = (100 - L - 1) / 2;\n\n        int length_local = L / 2;\n        int length_domain = L - length_local - 1;\n\n        int num_dot_local = (length_local - 1);\n        int num_dot_domain = num_dot - num_dot_local;\n\n        string local_part(length_local, 'a');\n        for (int i = 1; i < length_local - 1; ++i) {\n            local_part[i] = '.';\n        }\n        string domain_part(length_domain, 'b');\n        for (int i = 1; i < length_domain - 1 && num_dot_domain > 0; ++i, --num_dot_domain) {\n            domain_part[i] = '.';\n        }\n\n        string email = local_part + '@' + domain_part;\n        string transformed_email = transform_email(email);\n\n        printf(\"%s\\n\", transformed_email.c_str());\n    } else {\n        // Default to a simple email address\n        string email = \"user@domain.com\";\n        string transformed_email = transform_email(email);\n        printf(\"%s\\n\", transformed_email.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -len 10 -type random\n./gen -len 20 -type random\n./gen -len 30 -type random\n./gen -len 40 -type random\n./gen -len 50 -type random\n./gen -len 60 -type random\n./gen -len 70 -type random\n./gen -len 80 -type random\n./gen -len 90 -type random\n./gen -len 100 -type random\n\n./gen -len 10 -type overlap\n./gen -len 20 -type overlap\n./gen -len 30 -type overlap\n./gen -len 40 -type overlap\n./gen -len 50 -type overlap\n\n./gen -len 100 -type max_length\n\n./gen -len 3 -type random\n./gen -len 4 -type random\n./gen -len 5 -type random\n./gen -len 6 -type random\n./gen -len 7 -type random\n./gen -len 8 -type random\n./gen -len 9 -type random\n\n./gen -len 100 -type default\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:57.207659",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "41/D",
      "title": "D. Пешка",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записаны три целых числа n, m, k (2 ≤ n, m ≤ 100, 0 ≤ k ≤ 10) — количество рядов и столбцов в шахматной доске, количество братьев пешки. Далее следует n строк по m цифр от 0 до 9 без пробелов — описание шахматной доски. Каждая клетка описывается одной цифрой — количество горошин в ней. Первая строка соответствует верхнему ряду, а последняя — нижнему.",
      "output_spec": "Выходные данныеЕсли невозможно добраться до верхнего ряда, собрав при этом число делящееся на k + 1 количество горошин, выведите -1. Иначе, первая строка должна содержать одно число — какое наибольшее число горошин она сможет собрать, при условии, что это число должно делиться на k + 1. Вторая строка должна содержать одно число — номер столбца клетки на нижнем ряду, откуда пешка должна начать свое путешествие. Столбцы нумеруются слева направо натуральными числами начиная с 1. Третья строка должна содержать строку из n - 1 символов — описание ходов пешки. Если пешка должна пойти вверх и влево, выведите L, если вверх и вправо, выведите R. Если решений несколько, выведите любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 3 1123456789Выходные данныеСкопировать162RLВходные данныеСкопировать3 3 0123456789Выходные данныеСкопировать173LRВходные данныеСкопировать2 2 109875Выходные данныеСкопировать-1",
      "description": "ограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны три целых числа n, m, k (2 ≤ n, m ≤ 100, 0 ≤ k ≤ 10) — количество рядов и столбцов в шахматной доске, количество братьев пешки. Далее следует n строк по m цифр от 0 до 9 без пробелов — описание шахматной доски. Каждая клетка описывается одной цифрой — количество горошин в ней. Первая строка соответствует верхнему ряду, а последняя — нижнему.\n\nВходные данные\n\nВыходные данныеЕсли невозможно добраться до верхнего ряда, собрав при этом число делящееся на k + 1 количество горошин, выведите -1. Иначе, первая строка должна содержать одно число — какое наибольшее число горошин она сможет собрать, при условии, что это число должно делиться на k + 1. Вторая строка должна содержать одно число — номер столбца клетки на нижнем ряду, откуда пешка должна начать свое путешествие. Столбцы нумеруются слева направо натуральными числами начиная с 1. Третья строка должна содержать строку из n - 1 символов — описание ходов пешки. Если пешка должна пойти вверх и влево, выведите L, если вверх и вправо, выведите R. Если решений несколько, выведите любое.\n\nВыходные данные\n\nВходные данныеСкопировать3 3 1123456789Выходные данныеСкопировать162RLВходные данныеСкопировать3 3 0123456789Выходные данныеСкопировать173LRВходные данныеСкопировать2 2 109875Выходные данныеСкопировать-1\n\nВходные данныеСкопировать3 3 1123456789\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать162RL\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 3 0123456789\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать173LR\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 2 109875\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #40 (Div. 2) - Codeforces",
          "content": "Всем привет!Добро пожаловать на раунд \"Codeforces Beta Round #40 (Div. 2)\". Пусть за окном хмуро и пасмурно (во всяком случае в Саратове), а раунд начался с недоступности сервера (просим прощения за fail), но надеюсь решение задач принесет вам удовольствие.Высокого вам рейтинга,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/843",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 293
        },
        {
          "title": "Codeforces Beta Round #40 Mini-Tutorial - Codeforces",
          "content": "I wrote this post to help my friend , Iman Movahhedi , complete this one.Round #40 was my first contest here in Codeforces and I feel I fell in love with CF just after that.A-Translation: (C# code)Many languages have built-in reverse() function for strings. we can reverse one of the strings and check if it's equal to the other one , or we can check it manually. I prefer the second. B-Martian Dollar: (C# code)Since number of days is very small (2 × 103) we can just iterate over all possibilities of buy-day and sell-day. This will take θ (n2) time which is OK.C-Email Address: (C++ code)The first letter of the input string can not be part of an \"at\" or a \"dot\" so we start from the second character. Greedily put \".\" wherever you reached \"dot\" and put \"@\" the first time you reached \"at\". This will take θ(n) time , where n is the length of input.D-Pawn:For each cell of the table store k + 1 values. Where ith value is the maximum number of peas the pawn can take while he is at that cell and this number mod k + 1 is i.This makes a O(n2 × m × k) dynamic programming which fits perfectly in the time.E-3-cycles: (C++ code)The road map with most edges is a complete bipartite graph with equal number of vertices on each side. (Prove it by yourself :D ). We can make such a graph by putting the first vertices on one side and the other on the other side.For sure , number of edges is .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1620",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1389
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #40 (Div. 2) - Codeforces - Code 1",
          "code": "4 100\n2 100 2 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/843",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #40 (Div. 2) - Codeforces - Code 2",
          "code": "5 10\n10 5 7 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/843",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #40 (Div. 2) - Codeforces - Code 3",
          "code": "4 100\n2 100 2 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/843",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 10, \"k\");\n    inf.readEoln();\n\n    string regex = \"[0-9]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; i++) {\n        inf.readLine(regex);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 10, \"k\");\n    inf.readEoln();\n\n    string regex = \"[0-9]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; i++) {\n        inf.readLine(regex);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 10, \"k\");\n    inf.readEoln();\n\n    string regex = \"[0-9]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; i++) {\n        inf.readLine(regex);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, k;\nvector<vector<int>> board;\n\nint readAns(InStream& stream) {\n    int collectedPeas = 0;\n    int firstLine = stream.readInt(-1, n * m * 9, \"total peas collected or -1\");\n    if (firstLine == -1) {\n        return -1;\n    }\n    int totalCollected = firstLine;\n    int startCol = stream.readInt(1, m, \"starting column\");\n    string path = stream.readToken(); // Read n - 1 letters\n    if ((int)path.length() != n - 1) {\n        stream.quitf(_wa, \"Path length is not n - 1, got %d\", (int)path.length());\n    }\n    for (int i = 0; i < n -1; ++i) {\n        if (path[i] != 'L' && path[i] != 'R') {\n            stream.quitf(_wa, \"Invalid character in path at position %d: %c\", i+1, path[i]);\n        }\n    }\n    collectedPeas = 0;\n    int current_row = n - 1;\n    int current_col = startCol -1;\n\n    // Collect peas from starting position\n    collectedPeas += board[current_row][current_col];\n\n    for (int i = 0; i < n - 1; ++i) {\n        char move = path[i];\n        if (move == 'L') {\n            current_row -= 1;\n            current_col -= 1;\n        } else if (move == 'R') {\n            current_row -=1;\n            current_col +=1;\n        }\n        if (current_row < 0 || current_row >= n || current_col < 0 || current_col >= m) {\n            stream.quitf(_wa, \"Pawn moves out of the board at move %d\", i + 1);\n        }\n        collectedPeas += board[current_row][current_col];\n    }\n    if (current_row != 0) {\n        stream.quitf(_wa, \"Pawn does not reach the uppermost row\");\n    }\n    if (collectedPeas != totalCollected) {\n        stream.quitf(_wa, \"Collected peas (%d) does not match reported total (%d)\", collectedPeas, totalCollected);\n    }\n    if (collectedPeas % (k+1) != 0) {\n        stream.quitf(_wa, \"Total collected peas (%d) is not divisible by k + 1 (%d)\", collectedPeas, k + 1);\n    }\n    return collectedPeas;\n}\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n    n = inf.readInt(2, 100, \"n\");\n    m = inf.readInt(2, 100, \"m\");\n    k = inf.readInt(0, 10, \"k\");\n    inf.readEoln();\n\n    board.resize(n, vector<int>(m));\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine();\n        if ((int)line.length() != m) {\n            quitf(_fail, \"Invalid length of board row %d: expected %d, got %d\", i + 1, m, (int)line.length());\n        }\n        for (int j = 0; j < m; ++j) {\n            if (!isdigit(line[j])) {\n                quitf(_fail, \"Invalid character in board at row %d, column %d\", i + 1, j +1);\n            }\n            board[i][j] = line[j] - '0';\n        }\n    }\n\n    int jury_collectedPeas = readAns(ans);\n    int participant_collectedPeas = readAns(ouf);\n\n    if (jury_collectedPeas == -1) {\n        if (participant_collectedPeas == -1) {\n            quitf(_ok, \"Both outputs are -1 (impossible)\");\n        } else {\n            quitf(_fail, \"Participant found a solution while jury says impossible\");\n        }\n    } else {\n        if (participant_collectedPeas == -1) {\n            quitf(_wa, \"Participant reports impossible, but solution exists\");\n        } else {\n            if (participant_collectedPeas > jury_collectedPeas) {\n                quitf(_fail, \"Participant's collected peas (%d) is greater than jury's (%d)\", participant_collectedPeas, jury_collectedPeas);\n            } else if (participant_collectedPeas == jury_collectedPeas) {\n                quitf(_ok, \"Correct answer: %d\", participant_collectedPeas);\n            } else {\n                quitf(_wa, \"Participant's collected peas (%d) is less than jury's (%d)\", participant_collectedPeas, jury_collectedPeas);\n            }\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    assert(2 <= n && n <= 100); // n between 2 and 100\n    assert(2 <= m && m <= 100); // m between 2 and 100\n    assert(0 <= k && k <= 10); // k between 0 and 10\n\n    vector<vector<int>> board(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Fill each cell with random number between 0 and 9\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                board[i][j] = rnd.next(10);\n            }\n        }\n    } else if (type == \"max_peas\") {\n        // Maximize peas along a path from bottom to top\n        // We can create a path with high numbers and fill the rest with low numbers\n\n        // First, choose a starting column\n        int start_col = rnd.next(m);\n\n        // Create a path from bottom to top\n        int col = start_col;\n        for (int i = n - 1; i >= 0; --i) {\n            // Set the cell on the path to 9 (maximum peas)\n            board[i][col] = 9;\n\n            // For other cells, set to random low numbers\n            for (int j = 0; j < m; ++j) {\n                if (j != col) {\n                    board[i][j] = rnd.next(3); // random number between 0 and 2\n                }\n            }\n\n            // Decide whether to move left or right\n            if (i > 0) {\n                if (col > 0 && col < m - 1) {\n                    // Can move left or right\n                    if (rnd.next(2)) {\n                        col -= 1;\n                    } else {\n                        col += 1;\n                    }\n                } else if (col == 0) {\n                    // Can only go right\n                    col += 1;\n                } else if (col == m - 1) {\n                    // Can only go left\n                    col -= 1;\n                }\n            }\n        }\n    } else if (type == \"min_peas\") {\n        // Fill the board with zeros\n        for (int i = 0; i < n; ++i){\n            for (int j = 0; j < m; ++j){\n                board[i][j] = 0;\n            }\n        }\n        // It's impossible to collect any peas\n    } else if (type == \"one_path\") {\n        // Create a board where only one path is possible\n        // So in each row, we will have only one column with peas, the rest are zeros\n\n        int start_col = rnd.next(1, m - 2); // Start from somewhere not at the edges\n        int col = start_col;\n\n        for (int i = n - 1; i >= 0; --i) {\n            // Set the cell on the path to a random number between 1 and 9\n            board[i][col] = rnd.next(1, 10);\n\n            // Other cells set to zero\n            for (int j = 0; j < m; ++j) {\n                if (j != col) {\n                    board[i][j] = 0;\n                }\n            }\n\n            // Decide the next column\n            if (i > 0) {\n                if (col > 0 && col < m - 1) {\n                    // Decide randomly to go left or right\n                    if (rnd.next(2)) {\n                        col -= 1;\n                    } else {\n                        col += 1;\n                    }\n                } else if (col == 0) {\n                    col += 1;\n                } else if (col == m - 1) {\n                    col -= 1;\n                }\n            }\n        }\n    } else if (type == \"no_solution\") {\n        // Create a board where it's impossible to collect peas divisible by k+1\n\n        // For simplicity, fill the board with ones except the bottom row which has zeros\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < m; ++j) {\n                if (i == n - 1) {\n                    // Bottom row\n                    board[i][j] = 0;\n                } else {\n                    board[i][j] = 1;\n                }\n            }\n        }\n    } else {\n        // Default is random\n        for (int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                board[i][j] = rnd.next(10);\n            }\n        }\n    }\n\n    // Output the board\n\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", board[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    assert(2 <= n && n <= 100); // n between 2 and 100\n    assert(2 <= m && m <= 100); // m between 2 and 100\n    assert(0 <= k && k <= 10); // k between 0 and 10\n\n    vector<vector<int>> board(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Fill each cell with random number between 0 and 9\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                board[i][j] = rnd.next(10);\n            }\n        }\n    } else if (type == \"max_peas\") {\n        // Maximize peas along a path from bottom to top\n        // We can create a path with high numbers and fill the rest with low numbers\n\n        // First, choose a starting column\n        int start_col = rnd.next(m);\n\n        // Create a path from bottom to top\n        int col = start_col;\n        for (int i = n - 1; i >= 0; --i) {\n            // Set the cell on the path to 9 (maximum peas)\n            board[i][col] = 9;\n\n            // For other cells, set to random low numbers\n            for (int j = 0; j < m; ++j) {\n                if (j != col) {\n                    board[i][j] = rnd.next(3); // random number between 0 and 2\n                }\n            }\n\n            // Decide whether to move left or right\n            if (i > 0) {\n                if (col > 0 && col < m - 1) {\n                    // Can move left or right\n                    if (rnd.next(2)) {\n                        col -= 1;\n                    } else {\n                        col += 1;\n                    }\n                } else if (col == 0) {\n                    // Can only go right\n                    col += 1;\n                } else if (col == m - 1) {\n                    // Can only go left\n                    col -= 1;\n                }\n            }\n        }\n    } else if (type == \"min_peas\") {\n        // Fill the board with zeros\n        for (int i = 0; i < n; ++i){\n            for (int j = 0; j < m; ++j){\n                board[i][j] = 0;\n            }\n        }\n        // It's impossible to collect any peas\n    } else if (type == \"one_path\") {\n        // Create a board where only one path is possible\n        // So in each row, we will have only one column with peas, the rest are zeros\n\n        int start_col = rnd.next(1, m - 2); // Start from somewhere not at the edges\n        int col = start_col;\n\n        for (int i = n - 1; i >= 0; --i) {\n            // Set the cell on the path to a random number between 1 and 9\n            board[i][col] = rnd.next(1, 10);\n\n            // Other cells set to zero\n            for (int j = 0; j < m; ++j) {\n                if (j != col) {\n                    board[i][j] = 0;\n                }\n            }\n\n            // Decide the next column\n            if (i > 0) {\n                if (col > 0 && col < m - 1) {\n                    // Decide randomly to go left or right\n                    if (rnd.next(2)) {\n                        col -= 1;\n                    } else {\n                        col += 1;\n                    }\n                } else if (col == 0) {\n                    col += 1;\n                } else if (col == m - 1) {\n                    col -= 1;\n                }\n            }\n        }\n    } else if (type == \"no_solution\") {\n        // Create a board where it's impossible to collect peas divisible by k+1\n\n        // For simplicity, fill the board with ones except the bottom row which has zeros\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < m; ++j) {\n                if (i == n - 1) {\n                    // Bottom row\n                    board[i][j] = 0;\n                } else {\n                    board[i][j] = 1;\n                }\n            }\n        }\n    } else {\n        // Default is random\n        for (int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                board[i][j] = rnd.next(10);\n            }\n        }\n    }\n\n    // Output the board\n\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", board[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -k 0 -type random\n./gen -n 2 -m 2 -k 0 -type no_solution\n./gen -n 2 -m 2 -k 1 -type min_peas\n./gen -n 2 -m 2 -k 1 -type max_peas\n./gen -n 3 -m 3 -k 1 -type one_path\n\n./gen -n 10 -m 10 -k 2 -type random\n./gen -n 10 -m 10 -k 2 -type max_peas\n./gen -n 10 -m 10 -k 2 -type min_peas\n./gen -n 10 -m 10 -k 2 -type one_path\n./gen -n 10 -m 10 -k 3 -type no_solution\n\n./gen -n 50 -m 50 -k 5 -type random\n./gen -n 50 -m 50 -k 5 -type max_peas\n./gen -n 50 -m 50 -k 5 -type min_peas\n./gen -n 50 -m 50 -k 5 -type one_path\n./gen -n 50 -m 50 -k 6 -type no_solution\n\n./gen -n 100 -m 100 -k 10 -type random\n./gen -n 100 -m 100 -k 10 -type max_peas\n./gen -n 100 -m 100 -k 10 -type min_peas\n./gen -n 100 -m 100 -k 10 -type one_path\n./gen -n 100 -m 100 -k 9 -type no_solution\n\n./gen -n 2 -m 100 -k 0 -type random\n./gen -n 100 -m 2 -k 0 -type random\n./gen -n 2 -m 2 -k 10 -type random\n./gen -n 100 -m 2 -k 10 -type max_peas\n\n./gen -n 10 -m 10 -k 0 -type random\n./gen -n 50 -m 50 -k 0 -type random\n./gen -n 100 -m 100 -k 0 -type max_peas\n\n./gen -n 10 -m 10 -k 10 -type random\n./gen -n 50 -m 50 -k 10 -type random\n./gen -n 100 -m 100 -k 10 -type max_peas\n\n./gen -n 25 -m 75 -k 4 -type random\n./gen -n 75 -m 25 -k 5 -type max_peas\n./gen -n 99 -m 99 -k 1 -type min_peas\n./gen -n 100 -m 99 -k 2 -type no_solution\n./gen -n 98 -m 100 -k 3 -type one_path\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:23:59.364766",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "41/E",
      "title": "E. 3-циклы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 100) — количество городов в Берляндии.",
      "output_spec": "Выходные данныеВ первой строке должно быть записано число m — наибольшее возможное число дорог в Берляндии. Далее выведите m строк по два числа в каждой — номера городов, которые соединяет очередная дорога. Города нумеруются целыми числами от 1 до n. Если решений несколько, выведите любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать3Выходные данныеСкопировать21 22 3Входные данныеСкопировать4Выходные данныеСкопировать41 22 33 44 1",
      "description": "ограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 100) — количество городов в Берляндии.\n\nВходные данные\n\nВыходные данныеВ первой строке должно быть записано число m — наибольшее возможное число дорог в Берляндии. Далее выведите m строк по два числа в каждой — номера городов, которые соединяет очередная дорога. Города нумеруются целыми числами от 1 до n. Если решений несколько, выведите любое.\n\nВыходные данные\n\nВходные данныеСкопировать3Выходные данныеСкопировать21 22 3Входные данныеСкопировать4Выходные данныеСкопировать41 22 33 44 1\n\nВходные данныеСкопировать3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать21 22 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать41 22 33 44 1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #40 (Div. 2) - Codeforces",
          "content": "Всем привет!Добро пожаловать на раунд \"Codeforces Beta Round #40 (Div. 2)\". Пусть за окном хмуро и пасмурно (во всяком случае в Саратове), а раунд начался с недоступности сервера (просим прощения за fail), но надеюсь решение задач принесет вам удовольствие.Высокого вам рейтинга,MikeMirzayanov",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/843",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 293
        },
        {
          "title": "Codeforces Beta Round #40 Mini-Tutorial - Codeforces",
          "content": "I wrote this post to help my friend , Iman Movahhedi , complete this one.Round #40 was my first contest here in Codeforces and I feel I fell in love with CF just after that.A-Translation: (C# code)Many languages have built-in reverse() function for strings. we can reverse one of the strings and check if it's equal to the other one , or we can check it manually. I prefer the second. B-Martian Dollar: (C# code)Since number of days is very small (2 × 103) we can just iterate over all possibilities of buy-day and sell-day. This will take θ (n2) time which is OK.C-Email Address: (C++ code)The first letter of the input string can not be part of an \"at\" or a \"dot\" so we start from the second character. Greedily put \".\" wherever you reached \"dot\" and put \"@\" the first time you reached \"at\". This will take θ(n) time , where n is the length of input.D-Pawn:For each cell of the table store k + 1 values. Where ith value is the maximum number of peas the pawn can take while he is at that cell and this number mod k + 1 is i.This makes a O(n2 × m × k) dynamic programming which fits perfectly in the time.E-3-cycles: (C++ code)The road map with most edges is a complete bipartite graph with equal number of vertices on each side. (Prove it by yourself :D ). We can make such a graph by putting the first vertices on one side and the other on the other side.For sure , number of edges is .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1620",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1389
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #40 (Div. 2) - Codeforces - Code 1",
          "code": "4 100\n2 100 2 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/843",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #40 (Div. 2) - Codeforces - Code 2",
          "code": "5 10\n10 5 7 1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/843",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #40 (Div. 2) - Codeforces - Code 3",
          "code": "4 100\n2 100 2 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/843",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid die_quitf(InStream& stream, TResult verdict, const char* msg) {\n    if (&stream == &ouf)\n        quitf(verdict, \"%s\", msg);\n    else\n        quitf(_fail, \"%s\", msg);\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input n\n    int n = inf.readInt(1, 100, \"n\");\n    // Compute maximal m according to Turán's theorem\n    int max_m = (n * n) / 4;\n\n    // Read contestant's m\n    int m = ouf.readInt(0, n * (n - 1) / 2, \"m\");\n\n    // Check if m equals maximal m\n    if (m != max_m)\n        quitf(_wa, \"m is not maximal, expected %d but found %d\", max_m, m);\n\n    set<pair<int, int>> edges;\n    vector<vector<bool>> adj(n + 1, vector<bool>(n + 1, false));\n    for (int i = 0; i < m; i++) {\n        int u = ouf.readInt(1, n, \"u\");\n        int v = ouf.readInt(1, n, \"v\");\n        if (u == v)\n            quitf(_wa, \"Self-loop detected at node %d\", u);\n        if (edges.count({min(u, v), max(u, v)}))\n            quitf(_wa, \"Multiple edges between nodes %d and %d\", u, v);\n        edges.insert({min(u, v), max(u, v)});\n        adj[u][v] = adj[v][u] = true;\n    }\n\n    // Check for triangles\n    for (int u = 1; u <= n; u++) {\n        for (int v = u + 1; v <= n; v++) {\n            if (adj[u][v]) {\n                for (int w = v + 1; w <= n; w++) {\n                    if (adj[u][w] && adj[v][w])\n                        quitf(_wa, \"Triangle detected among nodes %d, %d, %d\", u, v, w);\n                }\n            }\n        }\n    }\n\n    quitf(_ok, \"The graph is a maximal triangle-free graph with %d edges\", m);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters.\n    // We let the user either set \"n\" OR a \"type\" to decide how n is generated.\n    // If the user explicitly gives n > 0, we use that directly.\n    // Otherwise, we choose n based on \"type\".\n    // If neither is set, we default to n=10.\n    int n = opt<int>(\"n\", -1);\n    string t = opt<string>(\"type\", \"manual\");\n\n    // Precompute some primes up to 100.\n    static vector<int> primes = {\n        2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\n        31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\n        73, 79, 83, 89, 97\n    };\n\n    if (n < 1) {\n        if (t == \"min1\") {\n            // Minimal n\n            n = 1;\n        } else if (t == \"small\") {\n            // Random n in [2..10]\n            n = rnd.next(2, 10);\n        } else if (t == \"medium\") {\n            // Random n in [11..50]\n            n = rnd.next(11, 50);\n        } else if (t == \"large\") {\n            // Random n in [51..99]\n            n = rnd.next(51, 99);\n        } else if (t == \"max\") {\n            // Maximum valid n\n            n = 100;\n        } else if (t == \"prime\") {\n            // Choose a random prime in [2..97]\n            n = primes[rnd.next(int(primes.size()))];\n        } else if (t == \"random\") {\n            // Completely random n in [1..100]\n            n = rnd.next(1, 100);\n        } else {\n            // Default\n            n = 10;\n        }\n    }\n\n    // Ensure n is within the valid bounds of the problem [1..100].\n    // (Just a protective check; ideally the user or logic above ensures this.)\n    n = max(1, min(n, 100));\n\n    // Output the single integer n.\n    cout << n << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters.\n    // We let the user either set \"n\" OR a \"type\" to decide how n is generated.\n    // If the user explicitly gives n > 0, we use that directly.\n    // Otherwise, we choose n based on \"type\".\n    // If neither is set, we default to n=10.\n    int n = opt<int>(\"n\", -1);\n    string t = opt<string>(\"type\", \"manual\");\n\n    // Precompute some primes up to 100.\n    static vector<int> primes = {\n        2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\n        31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\n        73, 79, 83, 89, 97\n    };\n\n    if (n < 1) {\n        if (t == \"min1\") {\n            // Minimal n\n            n = 1;\n        } else if (t == \"small\") {\n            // Random n in [2..10]\n            n = rnd.next(2, 10);\n        } else if (t == \"medium\") {\n            // Random n in [11..50]\n            n = rnd.next(11, 50);\n        } else if (t == \"large\") {\n            // Random n in [51..99]\n            n = rnd.next(51, 99);\n        } else if (t == \"max\") {\n            // Maximum valid n\n            n = 100;\n        } else if (t == \"prime\") {\n            // Choose a random prime in [2..97]\n            n = primes[rnd.next(int(primes.size()))];\n        } else if (t == \"random\") {\n            // Completely random n in [1..100]\n            n = rnd.next(1, 100);\n        } else {\n            // Default\n            n = 10;\n        }\n    }\n\n    // Ensure n is within the valid bounds of the problem [1..100].\n    // (Just a protective check; ideally the user or logic above ensures this.)\n    n = max(1, min(n, 100));\n\n    // Output the single integer n.\n    cout << n << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 10\n./gen -n 11\n./gen -n 12\n./gen -n 49\n./gen -type min1\n./gen -type small\n./gen -type small\n./gen -type medium\n./gen -type medium\n./gen -type large\n./gen -type large\n./gen -type prime\n./gen -type prime\n./gen -type max\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:01.496592",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "411/B",
      "title": "B. Многоядерный процессор",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны три целых числа n, m, k (1 ≤ n, m, k ≤ 100). Далее идут n строк, описывающих инструкции. В i-й строке содержится m целых чисел: xi1, xi2, ..., xim (0 ≤ xij ≤ k), где xij обозначает инструкцию, которую должно выполнить i-е ядро на j-м такте. Если xij равно 0, то соответствующая инструкция «ничего не делать». Если же xij число от 1 до k, то соответствующая инструкция «записать информацию в ячейку кеш-памяти с номером xij».Считается, что ядра пронумерованы от 1 до n, такты работы пронумерованы от 1 до m, а ячейки памяти пронумерованы от 1 до k.",
      "output_spec": "Выходные данныеВыведите n строк. В i-й строке выведите целое число ti, равное 0, если i-е ядро не будет заблокировано, либо равное номеру такта, в течение которого ядро будет заблокировано.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 3 51 0 01 0 22 3 13 2 0Выходные данныеСкопировать1130Входные данныеСкопировать3 2 21 21 22 2Выходные данныеСкопировать110Входные данныеСкопировать1 1 10Выходные данныеСкопировать0",
      "description": "B. Многоядерный процессор\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны три целых числа n, m, k (1 ≤ n, m, k ≤ 100). Далее идут n строк, описывающих инструкции. В i-й строке содержится m целых чисел: xi1, xi2, ..., xim (0 ≤ xij ≤ k), где xij обозначает инструкцию, которую должно выполнить i-е ядро на j-м такте. Если xij равно 0, то соответствующая инструкция «ничего не делать». Если же xij число от 1 до k, то соответствующая инструкция «записать информацию в ячейку кеш-памяти с номером xij».Считается, что ядра пронумерованы от 1 до n, такты работы пронумерованы от 1 до m, а ячейки памяти пронумерованы от 1 до k.\n\nВходные данные\n\nВыходные данныеВыведите n строк. В i-й строке выведите целое число ti, равное 0, если i-е ядро не будет заблокировано, либо равное номеру такта, в течение которого ядро будет заблокировано.\n\nВыходные данные\n\nВходные данныеСкопировать4 3 51 0 01 0 22 3 13 2 0Выходные данныеСкопировать1130Входные данныеСкопировать3 2 21 21 22 2Выходные данныеСкопировать110Входные данныеСкопировать1 1 10Выходные данныеСкопировать0\n\nВходные данныеСкопировать4 3 51 0 01 0 22 3 13 2 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1130\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 2 21 21 22 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать110\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 1 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Coder-Strike 2014: Квалификационный раунд - Codeforces",
          "content": "Добрый день!Напоминаю, что Квалификационный раунд Coder-Strike 2014 стартует очень скоро. Раунд будет проводиться по правилам ACM ICPC и будет нерейтинговым для всех участников. Для прохождения в следующий этап соревнования Coder-Strike 2014 достаточно будет решить хотя бы одну задачу.Обратите внимание, что официальными участниками чемпионата являются школьники Москвы и Московской области. Если вы являетесь таковым, обязательно зарегистрируйтесь по ссылке для официальных участников (большая кнопка снизу :]), а также зарегистрируйтесь на участие в контесте на странице. Обязательно требуются обе регистрации. Зарегистрироваться →Только для школьников Москвы и Московской области Не забудьте почитать об отличных призах чемпионата здесь! Там же можно ознакомиться с регламентом соревнования.Все неофициальные участники, как обычно, могут решать задачи вне конкурса. Если вы не являетесь официальным участником, пожалуйста, не регистрируйтесь по ссылке выше. Совсем скоро мы откроем для вас специальную регистрацию.UPD 1: Список официальных участников, которые зарегистрировались, находится по ссылке. Все участники, которые зарегистрировались, но не являются школьниками Москвы или Московской области не будут допущены к официальному участию в следующем раунде.UPD 2: Регистрация для неофициальных участников открыта.UPD 3: Напоминаю, что регистрация открыта до конца соревнования, не до его начала, как обычно.UPD 4: Соревнование завершилось, надеюсь задачи вам понравились. Для тех, кому интересно, как решаются задачи, опубликован разбор задач.Желаю всем удачи!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/11646",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1568
        },
        {
          "title": "Coder-Strike 2014: Квалификационный раунд (разбор задач) - Codeforces",
          "content": "411A - Проверка пароляВ первой задаче нужно было аккуратно реализовать написанное в условии. Например, так: string s;\ncin >> s;\nbool upper = false, lower = false, digit = false;\nfor(int i= 0; i < s.size(); ++i){\n if(isupper(s[i]))\n upper = true;\n if(islower(s[i]))\n lower = true;\n if(isdigit(s[i]))\n digit = true;\n}\nputs((upper && lower && digit && s.size() >= 5) ? \"Correct\" : \"Too weak\");411B - Многоядерный процессорВ этой задаче важно было внимательно прочитать условие и разобрать несколько принципиальных случаев. Далее нужно было аккуратно реализовать в коде разбор случаев. Авторское решение делало это следующим образом: Будем хранить массивы blockedCell[] (значение в ячейке i равно 1, если соответствующая клетка заблокирована, и 0 иначе), blockedCore[] (значение в ячейке i равно 0, если соответствующее ядро еще не заблокировано, и номеру такта, когда ядро заблокируется, иначе). Будем итерироваться по тактам начиная с первого. Рассмотрим некоторый такт k. Проходом по процессорам пересчитаем, какие ячейки заблокируются на такте k. Выставим в соответствующих ячейках массива blockedCell[] единицы. Далее, для каждого ядра i, если выполняется условие ([blockedCore[i] равно 0] И [blockedCell[x[i][k]] равно 1]), тогда ядро i заблокируется на такте k. Запишем blockedCore[i] = k. 411C - КикерДля того, чтобы решить эту задачу нужно было воспользоваться логикой (математической логикой) :]. Логика подсказывает, что: Если для какого-то расположения первой команды, не существует расположения второй команды, при котором она может гарантировать себе хотя бы ничью, тогда гарантированно выигрывает первая команда. Если для любого расположения первой команды, существует расположение второй команды, при котором она может гарантировать себе победу, тогда гарантированно побеждает вторая команда. Иначе, никто не может победить гарантированно, нужно вывести Draw. Сделав описанные рассуждения, нужно реализовать их в коде. Делается это перебором всех возможных вариантов расположения игроков.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/11673",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 411\\s*B"
          },
          "content_length": 2000
        }
      ],
      "code_examples": [
        {
          "title": "Coder-Strike 2014: Квалификационный раунд (разбор задач) - Codeforces - Code 1",
          "code": "string s;\ncin >> s;\nbool upper = false, lower = false, digit = false;\nfor(int i= 0; i < s.size(); ++i){\n    if(isupper(s[i]))\n        upper = true;\n    if(islower(s[i]))\n        lower = true;\n    if(isdigit(s[i]))\n        digit = true;\n}\nputs((upper && lower && digit && s.size() >= 5) ? \"Correct\" : \"Too weak\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11673",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> xi = inf.readInts(m, 0, k, \"x_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> xi = inf.readInts(m, 0, k, \"x_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> xi = inf.readInts(m, 0, k, \"x_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    vector<vector<int>> instructions(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Generate random instructions\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < m; j++) {\n                int val = rnd.next(0, k); // 0 ≤ xij ≤ k\n                instructions[i][j] = val;\n            }\n        }\n    }\n    else if (type == \"conflict_at_once\") {\n        // All cores try to write to the same cell at cycle 1\n        int cell = rnd.next(1, k);\n        for(int i = 0; i < n; i++) {\n            instructions[i][0] = cell;\n            for(int j = 1; j < m; j++) {\n                instructions[i][j] = 0;\n            }\n        }\n    }\n    else if (type == \"conflict_later\") {\n        // All cores try to write to the same cell at cycle c (>1)\n        int cell = rnd.next(1, k);\n        int c = rnd.next(2, m); // conflict at cycle c\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < m; j++) {\n                if(j+1 == c) {\n                    instructions[i][j] = cell;\n                }\n                else {\n                    instructions[i][j] = 0;\n                }\n            }\n        }\n    }\n    else if (type == \"sequential_conflict\") {\n        // One core locks a cell, other cores attempt to write to that cell later\n        int cell = rnd.next(1, k);\n        // First core writes to cell at cycle 1\n        instructions[0][0] = cell;\n        for(int j = 1; j < m; j++) {\n            instructions[0][j] = 0;\n        }\n        // Other cores attempt to write to cell at subsequent cycles\n        for(int i = 1; i < n; i++) {\n            for(int j = 0; j < m; j++) {\n                if(j == i) { // Each core attempts at its own cycle\n                    instructions[i][j] = cell;\n                }\n                else {\n                    instructions[i][j] = 0;\n                }\n            }\n        }\n    }\n    else if (type == \"no_lock\") {\n        // None of the cores get locked\n        // All cores do nothing\n        for(int i = 0; i < n; i++) {\n            fill(instructions[i].begin(), instructions[i].end(), 0);\n        }\n    }\n    else if (type == \"max_lock\") {\n        // All cores get locked as quickly as possible\n        // All cores attempt to write to the same cell every cycle\n        int cell = rnd.next(1, k);\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < m; j++) {\n                instructions[i][j] = cell;\n            }\n        }\n    }\n    else if (type == \"write_to_locked_cell\") {\n        // Cores attempt to write to a cell that is already locked\n        int cell1 = rnd.next(1, k);\n        int cell2 = cell1 % k + 1; // Ensure different cell\n        // First core locks cell1 at cycle 1\n        instructions[0][0] = cell1;\n        for(int j = 1; j < m; j++) {\n            instructions[0][j] = 0;\n        }\n        // Other cores attempt to write to cell1 at cycle 2\n        for(int i = 1; i < n; i++) {\n            instructions[i][0] = 0;\n            instructions[i][1] = cell1; // Attempt to write to locked cell\n            for(int j = 2; j < m; j++) {\n                instructions[i][j] = 0;\n            }\n        }\n    }\n    else if (type == \"check_zero_cycle\") {\n        // Cores that never get locked should output 0\n        // All cores do nothing\n        for(int i = 0; i < n; i++) {\n            fill(instructions[i].begin(), instructions[i].end(), 0);\n        }\n    }\n    else if (type == \"off_by_one\") {\n        // To catch off-by-one errors\n        // Cores attempt to write to the same cell at the last cycle\n        int cell = rnd.next(1, k);\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < m - 1; j++) {\n                instructions[i][j] = 0;\n            }\n            instructions[i][m - 1] = cell; // Attempt at last cycle\n        }\n    }\n    else {\n        // Default behavior (random)\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < m; j++) {\n                instructions[i][j] = rnd.next(0, k);\n            }\n        }\n    }\n\n    // Output the instructions\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n            printf(\"%d\", instructions[i][j]);\n            if(j + 1 < m)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    vector<vector<int>> instructions(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Generate random instructions\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < m; j++) {\n                int val = rnd.next(0, k); // 0 ≤ xij ≤ k\n                instructions[i][j] = val;\n            }\n        }\n    }\n    else if (type == \"conflict_at_once\") {\n        // All cores try to write to the same cell at cycle 1\n        int cell = rnd.next(1, k);\n        for(int i = 0; i < n; i++) {\n            instructions[i][0] = cell;\n            for(int j = 1; j < m; j++) {\n                instructions[i][j] = 0;\n            }\n        }\n    }\n    else if (type == \"conflict_later\") {\n        // All cores try to write to the same cell at cycle c (>1)\n        int cell = rnd.next(1, k);\n        int c = rnd.next(2, m); // conflict at cycle c\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < m; j++) {\n                if(j+1 == c) {\n                    instructions[i][j] = cell;\n                }\n                else {\n                    instructions[i][j] = 0;\n                }\n            }\n        }\n    }\n    else if (type == \"sequential_conflict\") {\n        // One core locks a cell, other cores attempt to write to that cell later\n        int cell = rnd.next(1, k);\n        // First core writes to cell at cycle 1\n        instructions[0][0] = cell;\n        for(int j = 1; j < m; j++) {\n            instructions[0][j] = 0;\n        }\n        // Other cores attempt to write to cell at subsequent cycles\n        for(int i = 1; i < n; i++) {\n            for(int j = 0; j < m; j++) {\n                if(j == i) { // Each core attempts at its own cycle\n                    instructions[i][j] = cell;\n                }\n                else {\n                    instructions[i][j] = 0;\n                }\n            }\n        }\n    }\n    else if (type == \"no_lock\") {\n        // None of the cores get locked\n        // All cores do nothing\n        for(int i = 0; i < n; i++) {\n            fill(instructions[i].begin(), instructions[i].end(), 0);\n        }\n    }\n    else if (type == \"max_lock\") {\n        // All cores get locked as quickly as possible\n        // All cores attempt to write to the same cell every cycle\n        int cell = rnd.next(1, k);\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < m; j++) {\n                instructions[i][j] = cell;\n            }\n        }\n    }\n    else if (type == \"write_to_locked_cell\") {\n        // Cores attempt to write to a cell that is already locked\n        int cell1 = rnd.next(1, k);\n        int cell2 = cell1 % k + 1; // Ensure different cell\n        // First core locks cell1 at cycle 1\n        instructions[0][0] = cell1;\n        for(int j = 1; j < m; j++) {\n            instructions[0][j] = 0;\n        }\n        // Other cores attempt to write to cell1 at cycle 2\n        for(int i = 1; i < n; i++) {\n            instructions[i][0] = 0;\n            instructions[i][1] = cell1; // Attempt to write to locked cell\n            for(int j = 2; j < m; j++) {\n                instructions[i][j] = 0;\n            }\n        }\n    }\n    else if (type == \"check_zero_cycle\") {\n        // Cores that never get locked should output 0\n        // All cores do nothing\n        for(int i = 0; i < n; i++) {\n            fill(instructions[i].begin(), instructions[i].end(), 0);\n        }\n    }\n    else if (type == \"off_by_one\") {\n        // To catch off-by-one errors\n        // Cores attempt to write to the same cell at the last cycle\n        int cell = rnd.next(1, k);\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < m - 1; j++) {\n                instructions[i][j] = 0;\n            }\n            instructions[i][m - 1] = cell; // Attempt at last cycle\n        }\n    }\n    else {\n        // Default behavior (random)\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < m; j++) {\n                instructions[i][j] = rnd.next(0, k);\n            }\n        }\n    }\n\n    // Output the instructions\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n            printf(\"%d\", instructions[i][j]);\n            if(j + 1 < m)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -k 1 -type random\n./gen -n 100 -m 100 -k 100 -type random\n./gen -n 50 -m 50 -k 50 -type conflict_at_once\n./gen -n 50 -m 50 -k 50 -type conflict_later\n./gen -n 100 -m 1 -k 1 -type conflict_at_once\n./gen -n 1 -m 100 -k 1 -type sequential_conflict\n./gen -n 100 -m 100 -k 100 -type no_lock\n./gen -n 100 -m 100 -k 1 -type max_lock\n./gen -n 100 -m 100 -k 2 -type write_to_locked_cell\n./gen -n 100 -m 100 -k 100 -type check_zero_cycle\n./gen -n 100 -m 100 -k 100 -type off_by_one\n./gen -n 99 -m 99 -k 99 -type random\n./gen -n 1 -m 1 -k 100 -type random\n./gen -n 100 -m 1 -k 100 -type random\n./gen -n 10 -m 100 -k 10 -type conflict_later\n./gen -n 100 -m 10 -k 100 -type sequential_conflict\n./gen -n 10 -m 10 -k 100 -type write_to_locked_cell\n./gen -n 2 -m 2 -k 2 -type random\n./gen -n 3 -m 3 -k 3 -type conflict_at_once\n./gen -n 4 -m 4 -k 4 -type conflict_later\n./gen -n 5 -m 5 -k 5 -type sequential_conflict\n./gen -n 6 -m 6 -k 6 -type max_lock\n./gen -n 7 -m 7 -k 7 -type write_to_locked_cell\n./gen -n 8 -m 8 -k 8 -type check_zero_cycle\n./gen -n 9 -m 9 -k 9 -type off_by_one\n./gen -n 100 -m 100 -k 100 -type conflict_at_once\n./gen -n 100 -m 100 -k 100 -type conflict_later\n./gen -n 100 -m 100 -k 100 -type sequential_conflict\n./gen -n 100 -m 50 -k 100 -type max_lock\n./gen -n 100 -m 1 -k 100 -type write_to_locked_cell\n./gen -n 100 -m 50 -k 1 -type off_by_one\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:03.324322",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "411/C",
      "title": "C. Кикер",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВо входных данных в четырех строках задано описание игроков. В i-й строке через пробел записаны два целых числа ai и bi (1 ≤ ai, bi ≤ 100) — навык защиты и нападения i-го игрока соответственно.",
      "output_spec": "Выходные данныеЕсли гарантированно может победить первая команда, то выведите фразу «Team 1» (без кавычек), если гарантированно может победить вторая команда — выведите фразу «Team 2» (без кавычек). Если ни одна команда не может гарантированно одержать победу, выведите фразу «Draw» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать1 100100 199 9999 99Выходные данныеСкопироватьTeam 1Входные данныеСкопировать1 12 23 32 2Выходные данныеСкопироватьTeam 2Входные данныеСкопировать3 32 21 12 2Выходные данныеСкопироватьDraw",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВо входных данных в четырех строках задано описание игроков. В i-й строке через пробел записаны два целых числа ai и bi (1 ≤ ai, bi ≤ 100) — навык защиты и нападения i-го игрока соответственно.\n\nВходные данные\n\nВыходные данныеЕсли гарантированно может победить первая команда, то выведите фразу «Team 1» (без кавычек), если гарантированно может победить вторая команда — выведите фразу «Team 2» (без кавычек). Если ни одна команда не может гарантированно одержать победу, выведите фразу «Draw» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать1 100100 199 9999 99Выходные данныеСкопироватьTeam 1Входные данныеСкопировать1 12 23 32 2Выходные данныеСкопироватьTeam 2Входные данныеСкопировать3 32 21 12 2Выходные данныеСкопироватьDraw\n\nВходные данныеСкопировать1 100100 199 9999 99\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьTeam 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 12 23 32 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьTeam 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 32 21 12 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьDraw\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим первый тестовый пример. Если первый игрок будет играть в нападении, а второй в защите, тогда, вне зависимости от расположения игроков второй команды, первая команда может гарантированно одержать победу.Во втором тестовом примере имеет значение порядок выбора игроков. Так как сначала игроки первой команды определяют, как им играть, игроки второй команды могут, зная их расположение, встать так, чтобы гарантированно победить.",
      "solutions": [
        {
          "title": "Coder-Strike 2014: Квалификационный раунд - Codeforces",
          "content": "Добрый день!Напоминаю, что Квалификационный раунд Coder-Strike 2014 стартует очень скоро. Раунд будет проводиться по правилам ACM ICPC и будет нерейтинговым для всех участников. Для прохождения в следующий этап соревнования Coder-Strike 2014 достаточно будет решить хотя бы одну задачу.Обратите внимание, что официальными участниками чемпионата являются школьники Москвы и Московской области. Если вы являетесь таковым, обязательно зарегистрируйтесь по ссылке для официальных участников (большая кнопка снизу :]), а также зарегистрируйтесь на участие в контесте на странице. Обязательно требуются обе регистрации. Зарегистрироваться →Только для школьников Москвы и Московской области Не забудьте почитать об отличных призах чемпионата здесь! Там же можно ознакомиться с регламентом соревнования.Все неофициальные участники, как обычно, могут решать задачи вне конкурса. Если вы не являетесь официальным участником, пожалуйста, не регистрируйтесь по ссылке выше. Совсем скоро мы откроем для вас специальную регистрацию.UPD 1: Список официальных участников, которые зарегистрировались, находится по ссылке. Все участники, которые зарегистрировались, но не являются школьниками Москвы или Московской области не будут допущены к официальному участию в следующем раунде.UPD 2: Регистрация для неофициальных участников открыта.UPD 3: Напоминаю, что регистрация открыта до конца соревнования, не до его начала, как обычно.UPD 4: Соревнование завершилось, надеюсь задачи вам понравились. Для тех, кому интересно, как решаются задачи, опубликован разбор задач.Желаю всем удачи!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11646",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1568
        },
        {
          "title": "Coder-Strike 2014: Квалификационный раунд (разбор задач) - Codeforces",
          "content": "411A - Проверка пароляВ первой задаче нужно было аккуратно реализовать написанное в условии. Например, так: string s;\ncin >> s;\nbool upper = false, lower = false, digit = false;\nfor(int i= 0; i < s.size(); ++i){\n if(isupper(s[i]))\n upper = true;\n if(islower(s[i]))\n lower = true;\n if(isdigit(s[i]))\n digit = true;\n}\nputs((upper && lower && digit && s.size() >= 5) ? \"Correct\" : \"Too weak\");411B - Многоядерный процессорВ этой задаче важно было внимательно прочитать условие и разобрать несколько принципиальных случаев. Далее нужно было аккуратно реализовать в коде разбор случаев. Авторское решение делало это следующим образом: Будем хранить массивы blockedCell[] (значение в ячейке i равно 1, если соответствующая клетка заблокирована, и 0 иначе), blockedCore[] (значение в ячейке i равно 0, если соответствующее ядро еще не заблокировано, и номеру такта, когда ядро заблокируется, иначе). Будем итерироваться по тактам начиная с первого. Рассмотрим некоторый такт k. Проходом по процессорам пересчитаем, какие ячейки заблокируются на такте k. Выставим в соответствующих ячейках массива blockedCell[] единицы. Далее, для каждого ядра i, если выполняется условие ([blockedCore[i] равно 0] И [blockedCell[x[i][k]] равно 1]), тогда ядро i заблокируется на такте k. Запишем blockedCore[i] = k. 411C - КикерДля того, чтобы решить эту задачу нужно было воспользоваться логикой (математической логикой) :]. Логика подсказывает, что: Если для какого-то расположения первой команды, не существует расположения второй команды, при котором она может гарантировать себе хотя бы ничью, тогда гарантированно выигрывает первая команда. Если для любого расположения первой команды, существует расположение второй команды, при котором она может гарантировать себе победу, тогда гарантированно побеждает вторая команда. Иначе, никто не может победить гарантированно, нужно вывести Draw. Сделав описанные рассуждения, нужно реализовать их в коде. Делается это перебором всех возможных вариантов расположения игроков.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11673",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 411\\s*C"
          },
          "content_length": 2000
        }
      ],
      "code_examples": [
        {
          "title": "Coder-Strike 2014: Квалификационный раунд (разбор задач) - Codeforces - Code 1",
          "code": "string s;\ncin >> s;\nbool upper = false, lower = false, digit = false;\nfor(int i= 0; i < s.size(); ++i){\n    if(isupper(s[i]))\n        upper = true;\n    if(islower(s[i]))\n        lower = true;\n    if(isdigit(s[i]))\n        digit = true;\n}\nputs((upper && lower && digit && s.size() >= 5) ? \"Correct\" : \"Too weak\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11673",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    for(int i = 0; i < 4; i++) {\n        int ai = inf.readInt(1, 100, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 100, \"bi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    for(int i = 0; i < 4; i++) {\n        int ai = inf.readInt(1, 100, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 100, \"bi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    \n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    for(int i = 0; i < 4; i++) {\n        int ai = inf.readInt(1, 100, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, 100, \"bi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    \n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(4), b(4);\n\n    if (type == \"random\") {\n        for(int i = 0; i < 4; ++i) {\n            a[i] = rnd.next(1, 100);\n            b[i] = rnd.next(1, 100);\n        }\n    } else if (type == \"max\") {\n        for(int i = 0; i < 4; ++i) {\n            a[i] = 100;\n            b[i] = 100;\n        }\n    } else if (type == \"min\") {\n        for(int i = 0; i < 4; ++i) {\n            a[i] = 1;\n            b[i] = 1;\n        }\n    } else if (type == \"equal\") {\n        int val = opt<int>(\"val\", rnd.next(1, 100));\n        for(int i = 0; i < 4; ++i) {\n            a[i] = val;\n            b[i] = val;\n        }\n    } else if (type == \"team1_win\") {\n        /* Generate skills such that Team 1 can guarantee a win */\n        for(int i = 0; i < 2; ++i) {\n            a[i] = rnd.next(70, 100);\n            b[i] = rnd.next(70, 100);\n        }\n        for(int i = 2; i < 4; ++i) {\n            a[i] = rnd.next(1, 50);\n            b[i] = rnd.next(1, 50);\n        }\n    } else if (type == \"team2_win\") {\n        /* Generate skills such that Team 2 can guarantee a win */\n        for(int i = 0; i < 2; ++i) {\n            a[i] = rnd.next(1, 50);\n            b[i] = rnd.next(1, 50);\n        }\n        for(int i = 2; i < 4; ++i) {\n            a[i] = rnd.next(70, 100);\n            b[i] = rnd.next(70, 100);\n        }\n    } else if (type == \"draw\") {\n        /* Generate skills such that neither team can guarantee a win */\n        for(int i = 0; i < 4; ++i) {\n            a[i] = rnd.next(40, 60);\n            b[i] = rnd.next(40, 60);\n        }\n    } else if (type == \"special_case\") {\n        a[0] = opt<int>(\"a1\");\n        b[0] = opt<int>(\"b1\");\n        a[1] = opt<int>(\"a2\");\n        b[1] = opt<int>(\"b2\");\n        a[2] = opt<int>(\"a3\");\n        b[2] = opt<int>(\"b3\");\n        a[3] = opt<int>(\"a4\");\n        b[3] = opt<int>(\"b4\");\n    }\n\n    /* Output the skills */\n    for(int i = 0; i < 4; ++i) {\n        printf(\"%d %d\\n\", a[i], b[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(4), b(4);\n\n    if (type == \"random\") {\n        for(int i = 0; i < 4; ++i) {\n            a[i] = rnd.next(1, 100);\n            b[i] = rnd.next(1, 100);\n        }\n    } else if (type == \"max\") {\n        for(int i = 0; i < 4; ++i) {\n            a[i] = 100;\n            b[i] = 100;\n        }\n    } else if (type == \"min\") {\n        for(int i = 0; i < 4; ++i) {\n            a[i] = 1;\n            b[i] = 1;\n        }\n    } else if (type == \"equal\") {\n        int val = opt<int>(\"val\", rnd.next(1, 100));\n        for(int i = 0; i < 4; ++i) {\n            a[i] = val;\n            b[i] = val;\n        }\n    } else if (type == \"team1_win\") {\n        /* Generate skills such that Team 1 can guarantee a win */\n        for(int i = 0; i < 2; ++i) {\n            a[i] = rnd.next(70, 100);\n            b[i] = rnd.next(70, 100);\n        }\n        for(int i = 2; i < 4; ++i) {\n            a[i] = rnd.next(1, 50);\n            b[i] = rnd.next(1, 50);\n        }\n    } else if (type == \"team2_win\") {\n        /* Generate skills such that Team 2 can guarantee a win */\n        for(int i = 0; i < 2; ++i) {\n            a[i] = rnd.next(1, 50);\n            b[i] = rnd.next(1, 50);\n        }\n        for(int i = 2; i < 4; ++i) {\n            a[i] = rnd.next(70, 100);\n            b[i] = rnd.next(70, 100);\n        }\n    } else if (type == \"draw\") {\n        /* Generate skills such that neither team can guarantee a win */\n        for(int i = 0; i < 4; ++i) {\n            a[i] = rnd.next(40, 60);\n            b[i] = rnd.next(40, 60);\n        }\n    } else if (type == \"special_case\") {\n        a[0] = opt<int>(\"a1\");\n        b[0] = opt<int>(\"b1\");\n        a[1] = opt<int>(\"a2\");\n        b[1] = opt<int>(\"b2\");\n        a[2] = opt<int>(\"a3\");\n        b[2] = opt<int>(\"b3\");\n        a[3] = opt<int>(\"a4\");\n        b[3] = opt<int>(\"b4\");\n    }\n\n    /* Output the skills */\n    for(int i = 0; i < 4; ++i) {\n        printf(\"%d %d\\n\", a[i], b[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type team1_win\n./gen -type team1_win\n./gen -type team1_win\n./gen -type team2_win\n./gen -type team2_win\n./gen -type team2_win\n./gen -type draw\n./gen -type draw\n./gen -type draw\n./gen -type min\n./gen -type max\n./gen -type equal -val 1\n./gen -type equal -val 50\n./gen -type equal -val 100\n./gen -type special_case -a1 100 -b1 1 -a2 1 -b2 100 -a3 1 -b3 100 -a4 100 -b4 1\n./gen -type special_case -a1 1 -b1 100 -a2 100 -b2 1 -a3 100 -b3 1 -a4 1 -b4 100\n./gen -type special_case -a1 50 -b1 50 -a2 51 -b2 49 -a3 49 -b3 51 -a4 50 -b4 50\n./gen -type special_case -a1 60 -b1 60 -a2 60 -b2 60 -a3 60 -b3 60 -a4 60 -b4 60\n./gen -type special_case -a1 100 -b1 100 -a2 100 -b2 100 -a3 1 -b3 1 -a4 1 -b4 1\n./gen -type special_case -a1 1 -b1 1 -a2 1 -b2 1 -a3 100 -b3 100 -a4 100 -b4 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:05.539070",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "412/A",
      "title": "A. Poster",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers, n and k (1 ≤ k ≤ n ≤ 100) — the number of characters in the slogan and the initial position of the ladder, correspondingly. The next line contains the slogan as n characters written without spaces. Each character of the slogan is either a large English letter, or digit, or one of the characters: '.', '!', ',', '?'.",
      "output_spec": "OutputIn t lines, print the actions the programmers need to make. In the i-th line print:  \"LEFT\" (without the quotes), if the i-th action was \"move the ladder to the left\";  \"RIGHT\" (without the quotes), if the i-th action was \"move the ladder to the right\";  \"PRINT x\" (without the quotes), if the i-th action was to \"go up the ladder, paint character x, go down the ladder\". The painting time (variable t) must be minimum possible. If there are multiple optimal painting plans, you can print any of them.",
      "sample_tests": "ExamplesInputCopy2 2R1OutputCopyPRINT 1LEFTPRINT RInputCopy2 1R1OutputCopyPRINT RRIGHTPRINT 1InputCopy6 4GO?GO!OutputCopyRIGHTRIGHTPRINT !LEFTPRINT OLEFTPRINT GLEFTPRINT ?LEFTPRINT OLEFTPRINT G",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers, n and k (1 ≤ k ≤ n ≤ 100) — the number of characters in the slogan and the initial position of the ladder, correspondingly. The next line contains the slogan as n characters written without spaces. Each character of the slogan is either a large English letter, or digit, or one of the characters: '.', '!', ',', '?'.\n\nOutputIn t lines, print the actions the programmers need to make. In the i-th line print:  \"LEFT\" (without the quotes), if the i-th action was \"move the ladder to the left\";  \"RIGHT\" (without the quotes), if the i-th action was \"move the ladder to the right\";  \"PRINT x\" (without the quotes), if the i-th action was to \"go up the ladder, paint character x, go down the ladder\". The painting time (variable t) must be minimum possible. If there are multiple optimal painting plans, you can print any of them.\n\nInputCopy2 2R1OutputCopyPRINT 1LEFTPRINT RInputCopy2 1R1OutputCopyPRINT RRIGHTPRINT 1InputCopy6 4GO?GO!OutputCopyRIGHTRIGHTPRINT !LEFTPRINT OLEFTPRINT GLEFTPRINT ?LEFTPRINT OLEFTPRINT G\n\nInputCopy2 2R1\n\nOutputCopyPRINT 1LEFTPRINT R\n\nInputCopy2 1R1\n\nOutputCopyPRINT RRIGHTPRINT 1\n\nInputCopy6 4GO?GO!\n\nOutputCopyRIGHTRIGHTPRINT !LEFTPRINT OLEFTPRINT GLEFTPRINT ?LEFTPRINT OLEFTPRINT G\n\nNoteNote that the ladder cannot be shifted by less than one meter. The ladder can only stand in front of some square of the poster. For example, you cannot shift a ladder by half a meter and position it between two squares. Then go up and paint the first character and the second character.",
      "solutions": [
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces",
          "content": "Good Day!Coder-Strike 2014: Round 1 will start very soon. If you want to participate, please register for the contest on page. The round was prepared by me, HolkinPV and Igor_Kudryashov. And we tried our best to make it really awesome.The round will be usual rated round for the second division participants. The first division participants can take part too, but for them the round will be unrated.If you have any additional questions, please, ask at comments. Hope you enjoy the problems! Good luck!UPD 1. Score distribution will be standard: 500-1000-1500-2000-2500. UPD 2. The competition was delayed by 10 minutes. :]UPD 3. Because of unusual room assignment Div.1 and Div.2 participants will be in the same rooms this round.UPD 4. The contest has ended, hope you like the problems. Rating for Div.2 participants will be updated a bit later.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11746",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 846
        },
        {
          "title": "Editorial of Coder-Strike 2014 Round 1 - Codeforces",
          "content": "412A - PosterOne of the optimal solutions is the following. If k - 1 ≤ n - k then firstly let's move ladder to the left by k - 1 positions. After that we will do the following pair of operations n - 1 times: paint i-th symbol of the slogan and move the ladder to the right. In the end we will paint the last symbol of the slogan. If k - 1 > n - k then we will move the ladder to the right by n - k positions. After that we will also paint symbol and move the ladder to the left. Our last action will be to paint the first symbol of the slogan. Total number of sought operations is min(k - 1, n - k) + 2·n - 1.412B - Network ConfigurationIn this task you should sort array in descending order and print k-th element. Due to the weak constraints you could also solve the problem in the following manner. Let's brute ans — the value of answer and calculate how many computers already have Internet's speed not less than ans. If there are not less than k such computers then the answer is acceptable. Let's find the maximum among acceptable answers and it will be the sought value.412C - PatternLet's find the answer symbol-by-symbol. Let's consider i-th symbol. If there are two different symbols differ from '?' on i-th positions in the given strings then we must place '?' on i-th position in the answer. If there are '?' on i-th positions in all string then we can write any symbol. Obviously, it is better to write not '?' but any letter, 'x' for example. Lastly we should consider the case when there are only '?' and one the same letter on i-th positions. In this case we should find this letter and put it to the answer.412D - Giving AwardsLet's build sought permutation by adding employee one-by-one. Let's we already define the order of the first k employees: a1, a2, ..., ak. Let's place k + 1-th after ak-th. If ak-th employee owe money to k + 1-th then we will swap their positions (and will get permutation a1, a2, ..., ak - 1, k + 1, ak). If ak - 1-th employee also owe money to k + 1-th then we will also swap their positions and so on. If all first k employees owe money to k + 1-th then k + 1-th employee will be placed first in permutation. This algorithm has time complexity O(m), where m is the number of the debt relationships.412E - E-mail AddressesLet's consider position i such, that si = '@'. We are going to calculate the number of such substrings that are correct addresses and the symbol '@' in them is si. Let's go to the left from i until we find '@' or '.' — the symbols that aren't allowed to be to the left of '@'. Let's calculate cnt how many letters on the segment we went through. This letters can be the first symbols of the correct addresses. Let's now move to the right of i while considered symbol is letter or digit. If we stopped and the string is over or the following symbol is '@' or '_' then there aren't correct addresses. If the following symbol is '.' then let's go to the right of it while the considered symbols are letters. The correct address can finish in every such position, so we should add cnt to the answer. In the described solution \"move\" means \"brute by cycle for\". We can do this because we will go through each symbol not more than 2 times. Total time complexity is O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11756",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 412\\s*A"
          },
          "content_length": 3232
        }
      ],
      "code_examples": [
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 1",
          "code": "employe than 1 owes is 2\nemploye than 2 owes is 3\nemploye than 3 owes is 1 ( but we visit that so we step back)\nprint 3\nprint 2\nprint 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 2",
          "code": "employe than 1 owes is 2\nemploye than 2 owes is 3\nemploye than 3 owes is 1 ( but we visit that so we step back)\nprint 3\nprint 2\nprint 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 3",
          "code": "ab@@c.com\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 4",
          "code": "ab@@c.com\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 5",
          "code": "@a_1a@_.a\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 6",
          "code": "@a_1a@_.a\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 7",
          "code": "YellowNextYear",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    string pattern = \"[A-Z0-9.!?,]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"slogan\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    string pattern = \"[A-Z0-9.!?,]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"slogan\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    string pattern = \"[A-Z0-9.!?,]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"slogan\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n and k from the input file\n    int n = inf.readInt(1, 100, \"n\");\n    int k = inf.readInt(1, n, \"k\");\n    string slogan = inf.readToken();\n    if ((int)slogan.length() != n) {\n        quitf(_fail, \"The length of the slogan does not match n\");\n    }\n\n    // Initialize the ladder position\n    int ladder_pos = k;\n\n    // Initialize painted positions\n    vector<bool> painted(n + 1, false);  // positions are from 1 to n\n\n    // Keep track of the actions taken\n    int actions = 0;\n    map<int, char> painted_chars;\n\n    // Read participant's output\n    while (!ouf.eof()) {\n        string line = ouf.readString();\n\n        // Skip empty lines\n        if (line.empty()) continue;\n\n        actions++;\n\n        // Parse the action\n        if (line == \"LEFT\") {\n            if (ladder_pos == 1)\n                quitf(_wa, \"Attempted to move ladder left from position 1\");\n            ladder_pos--;\n        }\n        else if (line == \"RIGHT\") {\n            if (ladder_pos == n)\n                quitf(_wa, \"Attempted to move ladder right from position %d\", n);\n            ladder_pos++;\n        }\n        else if (line.substr(0, 5) == \"PRINT\") {\n            if (line.length() < 7 || line[5] != ' ')\n                quitf(_wa, \"Invalid PRINT command format\");\n\n            char ch = line[6];\n            // Check if the position has already been painted\n            if (painted[ladder_pos])\n                quitf(_wa, \"Position %d has already been painted\", ladder_pos);\n\n            // Check if the character matches the slogan at this position\n            if (slogan[ladder_pos - 1] != ch)\n                quitf(_wa, \"Incorrect character painted at position %d: expected '%c', found '%c'\",\n                      ladder_pos, slogan[ladder_pos - 1], ch);\n\n            painted[ladder_pos] = true;\n            painted_chars[ladder_pos] = ch;\n        }\n        else {\n            quitf(_wa, \"Invalid action: '%s'\", line.c_str());\n        }\n    }\n\n    // Check if all positions have been painted\n    for (int i = 1; i <= n; i++) {\n        if (!painted[i]) {\n            quitf(_wa, \"Position %d has not been painted\", i);\n        }\n    }\n\n    // The plan is valid\n    quitf(_ok, \"Valid painting plan with %d actions\", actions);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    ensure(1 <= n && n <= 100);\n    ensure(1 <= k && k <= n);\n    \n    vector<char> allowed_chars;\n    if (type == \"letters\" || type == \"same\") {\n        for (char c = 'A'; c <= 'Z'; c++)\n            allowed_chars.push_back(c);\n    } else if (type == \"digits\") {\n        for (char c = '0'; c <= '9'; c++)\n            allowed_chars.push_back(c);\n    } else if (type == \"punctuation\") {\n        allowed_chars = {'.', '!', ',', '?'};\n    } else if (type == \"random\") {\n        for (char c = 'A'; c <= 'Z'; c++)\n            allowed_chars.push_back(c);\n        for (char c = '0'; c <= '9'; c++)\n            allowed_chars.push_back(c);\n        allowed_chars.push_back('.');\n        allowed_chars.push_back('!');\n        allowed_chars.push_back(',');\n        allowed_chars.push_back('?');\n    }\n    if (allowed_chars.empty()) {\n        cerr << \"No allowed characters for type \" << type << endl;\n        return 1;\n    }\n    string slogan;\n    if (type == \"same\") {\n        char c = allowed_chars[rnd.next(allowed_chars.size())];\n        slogan = string(n, c);\n    } else {\n        for (int i = 0; i < n; ++i) {\n            char c = allowed_chars[rnd.next(allowed_chars.size())];\n            slogan += c;\n        }\n    }\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%s\\n\", slogan.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    ensure(1 <= n && n <= 100);\n    ensure(1 <= k && k <= n);\n    \n    vector<char> allowed_chars;\n    if (type == \"letters\" || type == \"same\") {\n        for (char c = 'A'; c <= 'Z'; c++)\n            allowed_chars.push_back(c);\n    } else if (type == \"digits\") {\n        for (char c = '0'; c <= '9'; c++)\n            allowed_chars.push_back(c);\n    } else if (type == \"punctuation\") {\n        allowed_chars = {'.', '!', ',', '?'};\n    } else if (type == \"random\") {\n        for (char c = 'A'; c <= 'Z'; c++)\n            allowed_chars.push_back(c);\n        for (char c = '0'; c <= '9'; c++)\n            allowed_chars.push_back(c);\n        allowed_chars.push_back('.');\n        allowed_chars.push_back('!');\n        allowed_chars.push_back(',');\n        allowed_chars.push_back('?');\n    }\n    if (allowed_chars.empty()) {\n        cerr << \"No allowed characters for type \" << type << endl;\n        return 1;\n    }\n    string slogan;\n    if (type == \"same\") {\n        char c = allowed_chars[rnd.next(allowed_chars.size())];\n        slogan = string(n, c);\n    } else {\n        for (int i = 0; i < n; ++i) {\n            char c = allowed_chars[rnd.next(allowed_chars.size())];\n            slogan += c;\n        }\n    }\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%s\\n\", slogan.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type random\n./gen -n 1 -k 1 -type same\n./gen -n 1 -k 1 -type letters\n./gen -n 1 -k 1 -type digits\n./gen -n 1 -k 1 -type punctuation\n\n./gen -n 2 -k 1 -type random\n./gen -n 2 -k 2 -type random\n\n./gen -n 5 -k 3 -type random\n\n./gen -n 10 -k 1 -type random\n./gen -n 10 -k 10 -type random\n./gen -n 10 -k 5 -type random\n\n./gen -n 20 -k 1 -type same\n./gen -n 20 -k 20 -type same\n./gen -n 20 -k 10 -type same\n\n./gen -n 50 -k 25 -type letters\n./gen -n 50 -k 25 -type digits\n./gen -n 50 -k 25 -type punctuation\n\n./gen -n 100 -k 1 -type random\n./gen -n 100 -k 100 -type random\n./gen -n 100 -k 50 -type random\n\n./gen -n 100 -k 1 -type letters\n./gen -n 100 -k 100 -type digits\n./gen -n 100 -k 50 -type punctuation\n\n./gen -n 100 -k 1 -type same\n./gen -n 100 -k 100 -type same\n./gen -n 100 -k 50 -type same\n\n./gen -n 99 -k 99 -type random\n./gen -n 99 -k 1 -type random\n./gen -n 99 -k 50 -type random\n\n./gen -n 100 -k 51 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:07.603368",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "412/B",
      "title": "B. Network Configuration",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and k (1 ≤ k ≤ n ≤ 100) — the number of computers and the number of participants, respectively. In the second line you have a space-separated sequence consisting of n integers: a1, a2, ..., an (16 ≤ ai ≤ 32768); number ai denotes the maximum data transfer speed on the i-th computer.",
      "output_spec": "OutputPrint a single integer — the maximum Internet speed value. It is guaranteed that the answer to the problem is always an integer.",
      "sample_tests": "ExamplesInputCopy3 240 20 30OutputCopy30InputCopy6 4100 20 40 20 50 50OutputCopy40",
      "description": "B. Network Configuration\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and k (1 ≤ k ≤ n ≤ 100) — the number of computers and the number of participants, respectively. In the second line you have a space-separated sequence consisting of n integers: a1, a2, ..., an (16 ≤ ai ≤ 32768); number ai denotes the maximum data transfer speed on the i-th computer.\n\nOutputPrint a single integer — the maximum Internet speed value. It is guaranteed that the answer to the problem is always an integer.\n\nInputCopy3 240 20 30OutputCopy30InputCopy6 4100 20 40 20 50 50OutputCopy40\n\nInputCopy3 240 20 30\n\nOutputCopy30\n\nInputCopy6 4100 20 40 20 50 50\n\nOutputCopy40\n\nNoteIn the first test case the organizers can cut the first computer's speed to 30 kilobits. Then two computers (the first and the third one) will have the same speed of 30 kilobits. They should be used as the participants' computers. This answer is optimal.",
      "solutions": [
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces",
          "content": "Good Day!Coder-Strike 2014: Round 1 will start very soon. If you want to participate, please register for the contest on page. The round was prepared by me, HolkinPV and Igor_Kudryashov. And we tried our best to make it really awesome.The round will be usual rated round for the second division participants. The first division participants can take part too, but for them the round will be unrated.If you have any additional questions, please, ask at comments. Hope you enjoy the problems! Good luck!UPD 1. Score distribution will be standard: 500-1000-1500-2000-2500. UPD 2. The competition was delayed by 10 minutes. :]UPD 3. Because of unusual room assignment Div.1 and Div.2 participants will be in the same rooms this round.UPD 4. The contest has ended, hope you like the problems. Rating for Div.2 participants will be updated a bit later.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/11746",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 846
        },
        {
          "title": "Editorial of Coder-Strike 2014 Round 1 - Codeforces",
          "content": "412A - PosterOne of the optimal solutions is the following. If k - 1 ≤ n - k then firstly let's move ladder to the left by k - 1 positions. After that we will do the following pair of operations n - 1 times: paint i-th symbol of the slogan and move the ladder to the right. In the end we will paint the last symbol of the slogan. If k - 1 > n - k then we will move the ladder to the right by n - k positions. After that we will also paint symbol and move the ladder to the left. Our last action will be to paint the first symbol of the slogan. Total number of sought operations is min(k - 1, n - k) + 2·n - 1.412B - Network ConfigurationIn this task you should sort array in descending order and print k-th element. Due to the weak constraints you could also solve the problem in the following manner. Let's brute ans — the value of answer and calculate how many computers already have Internet's speed not less than ans. If there are not less than k such computers then the answer is acceptable. Let's find the maximum among acceptable answers and it will be the sought value.412C - PatternLet's find the answer symbol-by-symbol. Let's consider i-th symbol. If there are two different symbols differ from '?' on i-th positions in the given strings then we must place '?' on i-th position in the answer. If there are '?' on i-th positions in all string then we can write any symbol. Obviously, it is better to write not '?' but any letter, 'x' for example. Lastly we should consider the case when there are only '?' and one the same letter on i-th positions. In this case we should find this letter and put it to the answer.412D - Giving AwardsLet's build sought permutation by adding employee one-by-one. Let's we already define the order of the first k employees: a1, a2, ..., ak. Let's place k + 1-th after ak-th. If ak-th employee owe money to k + 1-th then we will swap their positions (and will get permutation a1, a2, ..., ak - 1, k + 1, ak). If ak - 1-th employee also owe money to k + 1-th then we will also swap their positions and so on. If all first k employees owe money to k + 1-th then k + 1-th employee will be placed first in permutation. This algorithm has time complexity O(m), where m is the number of the debt relationships.412E - E-mail AddressesLet's consider position i such, that si = '@'. We are going to calculate the number of such substrings that are correct addresses and the symbol '@' in them is si. Let's go to the left from i until we find '@' or '.' — the symbols that aren't allowed to be to the left of '@'. Let's calculate cnt how many letters on the segment we went through. This letters can be the first symbols of the correct addresses. Let's now move to the right of i while considered symbol is letter or digit. If we stopped and the string is over or the following symbol is '@' or '_' then there aren't correct addresses. If the following symbol is '.' then let's go to the right of it while the considered symbols are letters. The correct address can finish in every such position, so we should add cnt to the answer. In the described solution \"move\" means \"brute by cycle for\". We can do this because we will go through each symbol not more than 2 times. Total time complexity is O(n).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/11756",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 412\\s*B"
          },
          "content_length": 3232
        }
      ],
      "code_examples": [
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 1",
          "code": "employe than 1 owes is 2\nemploye than 2 owes is 3\nemploye than 3 owes is 1 ( but we visit that so we step back)\nprint 3\nprint 2\nprint 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "Qingyu"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 2",
          "code": "employe than 1 owes is 2\nemploye than 2 owes is 3\nemploye than 3 owes is 1 ( but we visit that so we step back)\nprint 3\nprint 2\nprint 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "Qingyu"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 3",
          "code": "ab@@c.com\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "Qingyu"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 4",
          "code": "ab@@c.com\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "Qingyu"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 5",
          "code": "@a_1a@_.a\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "Qingyu"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 6",
          "code": "@a_1a@_.a\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "Qingyu"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 7",
          "code": "YellowNextYear",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 16, 32768, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 16, 32768, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 16, 32768, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"equal\");\n    \n    vector<int> ai(n);\n    \n    if (type == \"equal\") {\n        int speed = rnd.next(16, 32768);\n        for (int i = 0; i < n; ++i)\n            ai[i] = speed;\n    } else if (type == \"ascending\") {\n        int delta = max(1, (32768 - 16) / max(1, n - 1));\n        for (int i = 0; i < n; ++i)\n            ai[i] = 16 + delta * i;\n    } else if (type == \"descending\") {\n        int delta = max(1, (32768 - 16) / max(1, n - 1));\n        for (int i = 0; i < n; ++i)\n            ai[i] = 32768 - delta * i;\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(16, 32768);\n    } else if (type == \"maxspeedk\") {\n        int speed = rnd.next(17, 32768);\n        for (int i = 0; i < k; ++i)\n            ai[i] = speed;\n        for (int i = k; i < n; ++i) {\n            ai[i] = rnd.next(16, speed - 1);\n        }\n        shuffle(ai.begin(), ai.end());\n    } else if (type == \"maxspeedkplus\") {\n        if (k < n) {\n            int speed = rnd.next(17, 32768);\n            int minCount = k + 1;\n            int count = rnd.next(minCount, n);\n            for (int i = 0; i < count; ++i)\n                ai[i] = speed;\n            for (int i = count; i < n; ++i)\n                ai[i] = rnd.next(16, speed - 1);\n            shuffle(ai.begin(), ai.end());\n        } else {\n            // k == n, all speeds equal\n            int speed = rnd.next(16, 32768);\n            for (int i = 0; i < n; ++i)\n                ai[i] = speed;\n        }\n    } else if (type == \"maxspeedkminus\") {\n        if (k > 1) {\n            int speed = rnd.next(17, 32768);\n            int maxCount = k - 1;\n            int count = rnd.next(1, maxCount);\n            for (int i = 0; i < count; ++i)\n                ai[i] = speed;\n            for (int i = count; i < n; ++i)\n                ai[i] = rnd.next(16, speed - 1);\n            shuffle(ai.begin(), ai.end());\n        } else {\n            // k == 1, cannot have less than one computer\n            // Generate random data\n            for (int i = 0; i < n; ++i)\n                ai[i] = rnd.next(16, 32768);\n        }\n    } else if (type == \"unique\") {\n        set<int> speeds;\n        while ((int)speeds.size() < n) {\n            int val = rnd.next(16, 32768);\n            speeds.insert(val);\n        }\n        ai.assign(speeds.begin(), speeds.end());\n        shuffle(ai.begin(), ai.end());\n    } else if (type == \"smallai\") {\n        int speed = 16;\n        for (int i = 0; i < n; ++i)\n            ai[i] = speed;\n    } else if (type == \"largeai\") {\n        int speed = 32768;\n        for (int i = 0; i < n; ++i)\n            ai[i] = speed;\n    } else if (type == \"gcd\") {\n        int c = rnd.next(2, 1000);\n        for (int i = 0; i < n; ++i) {\n            int mult = rnd.next(1, 32768 / c);\n            ai[i] = c * mult;\n            if (ai[i] < 16) ai[i] = 16;\n            if (ai[i] > 32768) ai[i] = 32768;\n        }\n    }\n    \n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output the ai\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", ai[i], \" \\n\"[i == n - 1]);\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"equal\");\n    \n    vector<int> ai(n);\n    \n    if (type == \"equal\") {\n        int speed = rnd.next(16, 32768);\n        for (int i = 0; i < n; ++i)\n            ai[i] = speed;\n    } else if (type == \"ascending\") {\n        int delta = max(1, (32768 - 16) / max(1, n - 1));\n        for (int i = 0; i < n; ++i)\n            ai[i] = 16 + delta * i;\n    } else if (type == \"descending\") {\n        int delta = max(1, (32768 - 16) / max(1, n - 1));\n        for (int i = 0; i < n; ++i)\n            ai[i] = 32768 - delta * i;\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(16, 32768);\n    } else if (type == \"maxspeedk\") {\n        int speed = rnd.next(17, 32768);\n        for (int i = 0; i < k; ++i)\n            ai[i] = speed;\n        for (int i = k; i < n; ++i) {\n            ai[i] = rnd.next(16, speed - 1);\n        }\n        shuffle(ai.begin(), ai.end());\n    } else if (type == \"maxspeedkplus\") {\n        if (k < n) {\n            int speed = rnd.next(17, 32768);\n            int minCount = k + 1;\n            int count = rnd.next(minCount, n);\n            for (int i = 0; i < count; ++i)\n                ai[i] = speed;\n            for (int i = count; i < n; ++i)\n                ai[i] = rnd.next(16, speed - 1);\n            shuffle(ai.begin(), ai.end());\n        } else {\n            // k == n, all speeds equal\n            int speed = rnd.next(16, 32768);\n            for (int i = 0; i < n; ++i)\n                ai[i] = speed;\n        }\n    } else if (type == \"maxspeedkminus\") {\n        if (k > 1) {\n            int speed = rnd.next(17, 32768);\n            int maxCount = k - 1;\n            int count = rnd.next(1, maxCount);\n            for (int i = 0; i < count; ++i)\n                ai[i] = speed;\n            for (int i = count; i < n; ++i)\n                ai[i] = rnd.next(16, speed - 1);\n            shuffle(ai.begin(), ai.end());\n        } else {\n            // k == 1, cannot have less than one computer\n            // Generate random data\n            for (int i = 0; i < n; ++i)\n                ai[i] = rnd.next(16, 32768);\n        }\n    } else if (type == \"unique\") {\n        set<int> speeds;\n        while ((int)speeds.size() < n) {\n            int val = rnd.next(16, 32768);\n            speeds.insert(val);\n        }\n        ai.assign(speeds.begin(), speeds.end());\n        shuffle(ai.begin(), ai.end());\n    } else if (type == \"smallai\") {\n        int speed = 16;\n        for (int i = 0; i < n; ++i)\n            ai[i] = speed;\n    } else if (type == \"largeai\") {\n        int speed = 32768;\n        for (int i = 0; i < n; ++i)\n            ai[i] = speed;\n    } else if (type == \"gcd\") {\n        int c = rnd.next(2, 1000);\n        for (int i = 0; i < n; ++i) {\n            int mult = rnd.next(1, 32768 / c);\n            ai[i] = c * mult;\n            if (ai[i] < 16) ai[i] = 16;\n            if (ai[i] > 32768) ai[i] = 32768;\n        }\n    }\n    \n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output the ai\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", ai[i], \" \\n\"[i == n - 1]);\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type equal\n./gen -n 1 -k 1 -type maxspeedk\n./gen -n 1 -k 1 -type maxspeedkminus\n\n./gen -n 5 -k 1 -type random\n./gen -n 5 -k 5 -type equal\n./gen -n 5 -k 3 -type maxspeedk\n./gen -n 5 -k 3 -type maxspeedkplus\n./gen -n 5 -k 3 -type maxspeedkminus\n\n./gen -n 10 -k 1 -type smallai\n./gen -n 10 -k 10 -type largeai\n./gen -n 10 -k 5 -type ascending\n./gen -n 10 -k 5 -type descending\n./gen -n 10 -k 5 -type unique\n./gen -n 10 -k 5 -type gcd\n\n./gen -n 20 -k 15 -type random\n./gen -n 20 -k 10 -type maxspeedk\n./gen -n 20 -k 15 -type maxspeedkplus\n./gen -n 20 -k 5 -type maxspeedkminus\n\n./gen -n 50 -k 1 -type random\n./gen -n 50 -k 50 -type equal\n./gen -n 50 -k 25 -type ascending\n./gen -n 50 -k 25 -type descending\n./gen -n 50 -k 25 -type unique\n./gen -n 50 -k 25 -type gcd\n\n./gen -n 100 -k 1 -type random\n./gen -n 100 -k 100 -type equal\n./gen -n 100 -k 50 -type ascending\n./gen -n 100 -k 50 -type descending\n./gen -n 100 -k 75 -type maxspeedk\n./gen -n 100 -k 75 -type maxspeedkplus\n./gen -n 100 -k 75 -type maxspeedkminus\n./gen -n 100 -k 10 -type smallai\n./gen -n 100 -k 90 -type largeai\n./gen -n 100 -k 50 -type unique\n./gen -n 100 -k 50 -type gcd\n\n./gen -n 100 -k 1 -type maxspeedkminus\n./gen -n 100 -k 100 -type maxspeedkminus\n./gen -n 100 -k 100 -type maxspeedkplus\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:09.956653",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "412/C",
      "title": "C. Pattern",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 105) — the number of patterns. Next n lines contain the patterns.It is guaranteed that the patterns can only consist of small English letters and symbols '?'. All patterns are non-empty and have the same length. The total length of all the patterns does not exceed 105 characters.",
      "output_spec": "OutputIn a single line print the answer to the problem — the pattern with the minimal number of signs '?', which intersects with each of the given ones. If there are several answers, print any of them.",
      "sample_tests": "ExamplesInputCopy2?ab??bOutputCopyxabInputCopy2abOutputCopy?InputCopy1?a?bOutputCopycacb",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 105) — the number of patterns. Next n lines contain the patterns.It is guaranteed that the patterns can only consist of small English letters and symbols '?'. All patterns are non-empty and have the same length. The total length of all the patterns does not exceed 105 characters.\n\nOutputIn a single line print the answer to the problem — the pattern with the minimal number of signs '?', which intersects with each of the given ones. If there are several answers, print any of them.\n\nInputCopy2?ab??bOutputCopyxabInputCopy2abOutputCopy?InputCopy1?a?bOutputCopycacb\n\nInputCopy2?ab??b\n\nOutputCopyxab\n\nInputCopy2ab\n\nOutputCopy?\n\nInputCopy1?a?b\n\nOutputCopycacb\n\nNoteConsider the first example. Pattern xab intersects with each of the given patterns. Pattern ??? also intersects with each of the given patterns, but it contains more question signs, hence it is not an optimal answer. Clearly, xab is the optimal answer, because it doesn't contain any question sign. There are a lot of other optimal answers, for example: aab, bab, cab, dab and so on.",
      "solutions": [
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces",
          "content": "Good Day!Coder-Strike 2014: Round 1 will start very soon. If you want to participate, please register for the contest on page. The round was prepared by me, HolkinPV and Igor_Kudryashov. And we tried our best to make it really awesome.The round will be usual rated round for the second division participants. The first division participants can take part too, but for them the round will be unrated.If you have any additional questions, please, ask at comments. Hope you enjoy the problems! Good luck!UPD 1. Score distribution will be standard: 500-1000-1500-2000-2500. UPD 2. The competition was delayed by 10 minutes. :]UPD 3. Because of unusual room assignment Div.1 and Div.2 participants will be in the same rooms this round.UPD 4. The contest has ended, hope you like the problems. Rating for Div.2 participants will be updated a bit later.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11746",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 846
        },
        {
          "title": "Editorial of Coder-Strike 2014 Round 1 - Codeforces",
          "content": "412A - PosterOne of the optimal solutions is the following. If k - 1 ≤ n - k then firstly let's move ladder to the left by k - 1 positions. After that we will do the following pair of operations n - 1 times: paint i-th symbol of the slogan and move the ladder to the right. In the end we will paint the last symbol of the slogan. If k - 1 > n - k then we will move the ladder to the right by n - k positions. After that we will also paint symbol and move the ladder to the left. Our last action will be to paint the first symbol of the slogan. Total number of sought operations is min(k - 1, n - k) + 2·n - 1.412B - Network ConfigurationIn this task you should sort array in descending order and print k-th element. Due to the weak constraints you could also solve the problem in the following manner. Let's brute ans — the value of answer and calculate how many computers already have Internet's speed not less than ans. If there are not less than k such computers then the answer is acceptable. Let's find the maximum among acceptable answers and it will be the sought value.412C - PatternLet's find the answer symbol-by-symbol. Let's consider i-th symbol. If there are two different symbols differ from '?' on i-th positions in the given strings then we must place '?' on i-th position in the answer. If there are '?' on i-th positions in all string then we can write any symbol. Obviously, it is better to write not '?' but any letter, 'x' for example. Lastly we should consider the case when there are only '?' and one the same letter on i-th positions. In this case we should find this letter and put it to the answer.412D - Giving AwardsLet's build sought permutation by adding employee one-by-one. Let's we already define the order of the first k employees: a1, a2, ..., ak. Let's place k + 1-th after ak-th. If ak-th employee owe money to k + 1-th then we will swap their positions (and will get permutation a1, a2, ..., ak - 1, k + 1, ak). If ak - 1-th employee also owe money to k + 1-th then we will also swap their positions and so on. If all first k employees owe money to k + 1-th then k + 1-th employee will be placed first in permutation. This algorithm has time complexity O(m), where m is the number of the debt relationships.412E - E-mail AddressesLet's consider position i such, that si = '@'. We are going to calculate the number of such substrings that are correct addresses and the symbol '@' in them is si. Let's go to the left from i until we find '@' or '.' — the symbols that aren't allowed to be to the left of '@'. Let's calculate cnt how many letters on the segment we went through. This letters can be the first symbols of the correct addresses. Let's now move to the right of i while considered symbol is letter or digit. If we stopped and the string is over or the following symbol is '@' or '_' then there aren't correct addresses. If the following symbol is '.' then let's go to the right of it while the considered symbols are letters. The correct address can finish in every such position, so we should add cnt to the answer. In the described solution \"move\" means \"brute by cycle for\". We can do this because we will go through each symbol not more than 2 times. Total time complexity is O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11756",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 412\\s*C"
          },
          "content_length": 3232
        }
      ],
      "code_examples": [
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 1",
          "code": "employe than 1 owes is 2\nemploye than 2 owes is 3\nemploye than 3 owes is 1 ( but we visit that so we step back)\nprint 3\nprint 2\nprint 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 2",
          "code": "employe than 1 owes is 2\nemploye than 2 owes is 3\nemploye than 3 owes is 1 ( but we visit that so we step back)\nprint 3\nprint 2\nprint 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 3",
          "code": "ab@@c.com\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 4",
          "code": "ab@@c.com\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 5",
          "code": "@a_1a@_.a\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 6",
          "code": "@a_1a@_.a\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 7",
          "code": "YellowNextYear",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int totalLength = 0;\n    int patternLength = -1;\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[a-z?]+\", \"pattern\");\n\n        int len = s.length();\n\n        ensuref(len >= 1, \"Pattern must be non-empty\");\n\n        if (patternLength == -1) {\n            patternLength = len;\n        } else {\n            ensuref(len == patternLength, \"All patterns must have the same length\");\n        }\n\n        totalLength += len;\n        ensuref(totalLength <= 100000, \"Total length of patterns must not exceed 100000\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int totalLength = 0;\n    int patternLength = -1;\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[a-z?]+\", \"pattern\");\n\n        int len = s.length();\n\n        ensuref(len >= 1, \"Pattern must be non-empty\");\n\n        if (patternLength == -1) {\n            patternLength = len;\n        } else {\n            ensuref(len == patternLength, \"All patterns must have the same length\");\n        }\n\n        totalLength += len;\n        ensuref(totalLength <= 100000, \"Total length of patterns must not exceed 100000\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int totalLength = 0;\n    int patternLength = -1;\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[a-z?]+\", \"pattern\");\n\n        int len = s.length();\n\n        ensuref(len >= 1, \"Pattern must be non-empty\");\n\n        if (patternLength == -1) {\n            patternLength = len;\n        } else {\n            ensuref(len == patternLength, \"All patterns must have the same length\");\n        }\n\n        totalLength += len;\n        ensuref(totalLength <= 100000, \"Total length of patterns must not exceed 100000\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<string> patterns;\nint pattern_len;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt();\n    patterns.resize(n);\n\n    pattern_len = -1;\n    for (int i = 0; i < n; ++i) {\n        patterns[i] = inf.readToken();\n        if (pattern_len == -1)\n            pattern_len = patterns[i].size();\n        else if ((int)patterns[i].size() != pattern_len)\n            quitf(_fail, \"Inconsistent pattern lengths in input\");\n    }\n\n    string j_ans = ans.readToken();\n    if ((int)j_ans.size() != pattern_len)\n        quitf(_fail, \"Judge's answer pattern length (%d) does not match expected length (%d)\", (int)j_ans.size(), pattern_len);\n\n    int j_question_marks = count(j_ans.begin(), j_ans.end(), '?');\n\n    string p_ans = ouf.readToken();\n    if ((int)p_ans.size() != pattern_len)\n        quitf(_wa, \"Participant's pattern length (%d) does not match expected length (%d)\", (int)p_ans.size(), pattern_len);\n\n    int p_question_marks = count(p_ans.begin(), p_ans.end(), '?');\n\n    if (p_question_marks > j_question_marks)\n        quitf(_wa, \"Participant's pattern has more question marks (%d) than judge's answer (%d)\", p_question_marks, j_question_marks);\n    else if (p_question_marks < j_question_marks)\n        quitf(_fail, \"Participant's pattern has fewer question marks (%d) than judge's answer (%d)\", p_question_marks, j_question_marks);\n    else {\n        // Now check that participant's pattern intersects with all input patterns\n        for (int idx = 0; idx < n; ++idx) {\n            string& input_pattern = patterns[idx];\n            bool intersects = true;\n            for (int i = 0; i < pattern_len; ++i) {\n                char pc = p_ans[i];\n                char ic = input_pattern[i];\n\n                if (pc != '?' && ic != '?' && pc != ic) {\n                    intersects = false;\n                    break;\n                }\n            }\n            if (!intersects) {\n                quitf(_wa, \"Participant's pattern does not intersect with pattern #%d\", idx + 1);\n            }\n        }\n        // Everything is OK\n        quitf(_ok, \"Correct\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int len = opt<int>(\"len\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check constraints\n    if (n < 1 || n > 100000) {\n        fprintf(stderr, \"n must be between 1 and 1e5\\n\");\n        return 1;\n    }\n    if (len < 1 || n * len > 100000) {\n        fprintf(stderr, \"Invalid len: len must be >=1 and total length <=100000\\n\");\n        return 1;\n    }\n\n    vector<string> patterns;\n\n    if (type == \"all_same\") {\n        // Generate a random pattern, possibly with '?'\n        string pattern;\n        for (int i = 0; i < len; ++i) {\n            int c = rnd.next(27); // 0 to 26\n            if (c == 26)\n                pattern += '?';\n            else\n                pattern += 'a' + c;\n        }\n        // Output this pattern n times\n        patterns.assign(n, pattern);\n    } else if (type == \"all_different\") {\n        // Generate n patterns, ensuring at least one position differs in each\n        for (int i = 0; i < n; ++i) {\n            string pattern;\n            for (int j = 0; j < len; ++j) {\n                int c = (i + j) % 26; // Vary letters\n                pattern += 'a' + c;\n            }\n            patterns.push_back(pattern);\n        }\n    } else if (type == \"maximize_question_marks\") {\n        // Generate patterns such that at each position, there are multiple letters\n        for (int i = 0; i < n; ++i) {\n            string pattern;\n            for (int j = 0; j < len; ++j) {\n                int c = rnd.next(26);\n                pattern += 'a' + c;\n            }\n            patterns.push_back(pattern);\n        }\n    } else if (type == \"minimize_question_marks\") {\n        // Generate patterns where at each position, letters are same or '?'\n        string base_pattern;\n        for (int i = 0; i < len; ++i) {\n            int c = rnd.next(27); // 0 to 26\n            if (c == 26)\n                base_pattern += '?';\n            else\n                base_pattern += 'a' + c;\n        }\n        for (int i = 0; i < n; ++i) {\n            // Possibly vary the '?'\n            string pattern = base_pattern;\n            // Introduce '?' randomly\n            for (int j = 0; j < len; ++j) {\n                if (rnd.next(10) == 0) // 10% chance\n                    pattern[j] = '?';\n            }\n            patterns.push_back(pattern);\n        }\n    } else if (type == \"random\") {\n        // Random patterns\n        for (int i = 0; i < n; ++i) {\n            string pattern;\n            for (int j = 0; j < len; ++j) {\n                int c = rnd.next(27);\n                if (c == 26)\n                    pattern += '?';\n                else\n                    pattern += 'a' + c;\n            }\n            patterns.push_back(pattern);\n        }\n    } else if (type == \"one_question_each\") {\n        // Each pattern has one '?' at random position\n        for (int i = 0; i < n; ++i) {\n            string pattern;\n            int question_pos = rnd.next(len); // Position to put '?'\n            for (int j = 0; j < len; ++j) {\n                if (j == question_pos)\n                    pattern += '?';\n                else\n                    pattern += 'a' + rnd.next(26);\n            }\n            patterns.push_back(pattern);\n        }\n    } else if (type == \"no_question_marks\") {\n        // Patterns with no '?'\n        for (int i = 0; i < n; ++i) {\n            string pattern;\n            for (int j = 0; j < len; ++j) {\n                int c = rnd.next(26);\n                pattern += 'a' + c;\n            }\n            patterns.push_back(pattern);\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output patterns\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", patterns[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int len = opt<int>(\"len\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check constraints\n    if (n < 1 || n > 100000) {\n        fprintf(stderr, \"n must be between 1 and 1e5\\n\");\n        return 1;\n    }\n    if (len < 1 || n * len > 100000) {\n        fprintf(stderr, \"Invalid len: len must be >=1 and total length <=100000\\n\");\n        return 1;\n    }\n\n    vector<string> patterns;\n\n    if (type == \"all_same\") {\n        // Generate a random pattern, possibly with '?'\n        string pattern;\n        for (int i = 0; i < len; ++i) {\n            int c = rnd.next(27); // 0 to 26\n            if (c == 26)\n                pattern += '?';\n            else\n                pattern += 'a' + c;\n        }\n        // Output this pattern n times\n        patterns.assign(n, pattern);\n    } else if (type == \"all_different\") {\n        // Generate n patterns, ensuring at least one position differs in each\n        for (int i = 0; i < n; ++i) {\n            string pattern;\n            for (int j = 0; j < len; ++j) {\n                int c = (i + j) % 26; // Vary letters\n                pattern += 'a' + c;\n            }\n            patterns.push_back(pattern);\n        }\n    } else if (type == \"maximize_question_marks\") {\n        // Generate patterns such that at each position, there are multiple letters\n        for (int i = 0; i < n; ++i) {\n            string pattern;\n            for (int j = 0; j < len; ++j) {\n                int c = rnd.next(26);\n                pattern += 'a' + c;\n            }\n            patterns.push_back(pattern);\n        }\n    } else if (type == \"minimize_question_marks\") {\n        // Generate patterns where at each position, letters are same or '?'\n        string base_pattern;\n        for (int i = 0; i < len; ++i) {\n            int c = rnd.next(27); // 0 to 26\n            if (c == 26)\n                base_pattern += '?';\n            else\n                base_pattern += 'a' + c;\n        }\n        for (int i = 0; i < n; ++i) {\n            // Possibly vary the '?'\n            string pattern = base_pattern;\n            // Introduce '?' randomly\n            for (int j = 0; j < len; ++j) {\n                if (rnd.next(10) == 0) // 10% chance\n                    pattern[j] = '?';\n            }\n            patterns.push_back(pattern);\n        }\n    } else if (type == \"random\") {\n        // Random patterns\n        for (int i = 0; i < n; ++i) {\n            string pattern;\n            for (int j = 0; j < len; ++j) {\n                int c = rnd.next(27);\n                if (c == 26)\n                    pattern += '?';\n                else\n                    pattern += 'a' + c;\n            }\n            patterns.push_back(pattern);\n        }\n    } else if (type == \"one_question_each\") {\n        // Each pattern has one '?' at random position\n        for (int i = 0; i < n; ++i) {\n            string pattern;\n            int question_pos = rnd.next(len); // Position to put '?'\n            for (int j = 0; j < len; ++j) {\n                if (j == question_pos)\n                    pattern += '?';\n                else\n                    pattern += 'a' + rnd.next(26);\n            }\n            patterns.push_back(pattern);\n        }\n    } else if (type == \"no_question_marks\") {\n        // Patterns with no '?'\n        for (int i = 0; i < n; ++i) {\n            string pattern;\n            for (int j = 0; j < len; ++j) {\n                int c = rnd.next(26);\n                pattern += 'a' + c;\n            }\n            patterns.push_back(pattern);\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output patterns\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", patterns[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -len 1 -type all_same\n./gen -n 1 -len 1 -type all_different\n./gen -n 1 -len 1 -type maximize_question_marks\n./gen -n 1 -len 1 -type minimize_question_marks\n./gen -n 1 -len 1 -type random\n./gen -n 1 -len 1 -type one_question_each\n./gen -n 1 -len 1 -type no_question_marks\n\n./gen -n 1 -len 100000 -type all_same\n./gen -n 1 -len 100000 -type maximize_question_marks\n\n./gen -n 100000 -len 1 -type all_different\n./gen -n 100000 -len 1 -type no_question_marks\n\n./gen -n 1000 -len 100 -type minimize_question_marks\n./gen -n 1000 -len 100 -type random\n\n./gen -n 10000 -len 10 -type one_question_each\n\n./gen -n 50000 -len 2 -type maximize_question_marks\n\n./gen -n 100000 -len 1 -type all_same\n\n./gen -n 100000 -len 1 -type maximize_question_marks\n\n./gen -n 1000 -len 100 -type all_different\n\n./gen -n 50000 -len 2 -type minimize_question_marks\n\n./gen -n 10 -len 10000 -type random\n\n./gen -n 200 -len 500 -type no_question_marks\n\n./gen -n 1 -len 100000 -type no_question_marks\n\n./gen -n 100000 -len 1 -type one_question_each\n\n./gen -n 1000 -len 50 -type random\n\n./gen -n 1000 -len 50 -type minimize_question_marks\n\n./gen -n 1000 -len 50 -type maximize_question_marks\n\n./gen -n 2000 -len 50 -type one_question_each\n\n./gen -n 50000 -len 2 -type random\n\n./gen -n 25000 -len 4 -type minimize_question_marks\n\n./gen -n 25000 -len 4 -type maximize_question_marks\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:11.904696",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "412/D",
      "title": "D. Выдача премий",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны через пробел целые числа n и m  — количество сотрудников в R1 и количество отношений долга. В каждой из следующих m строк записано два целых числа через пробел ai, bi (1 ≤ ai, bi ≤ n; ai ≠ bi), эти числа обозначают, что человек с номером ai должен человеку с номером bi. Считайте, что все сотрудники пронумерованы от 1 до n.Гарантируется, что каждая пара людей p, q упоминается во входных данных не более одного раза. В частности, входные данные не будут содержать пар p, q и q, p одновременно.",
      "output_spec": "Выходные данныеВыведите -1, если описанного порядка не существует. Иначе, выведите перестановку из n различных целых чисел. Первое число должно обозначать номер человека, которого надо позвать первым в кабинет главы R1, второе — номер второго человека, и так далее.Если существует несколько правильных порядков, разрешается вывести любой.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 11 2Выходные данныеСкопировать2 1 Входные данныеСкопировать3 31 22 33 1Выходные данныеСкопировать2 1 3",
      "description": "D. Выдача премий\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны через пробел целые числа n и m  — количество сотрудников в R1 и количество отношений долга. В каждой из следующих m строк записано два целых числа через пробел ai, bi (1 ≤ ai, bi ≤ n; ai ≠ bi), эти числа обозначают, что человек с номером ai должен человеку с номером bi. Считайте, что все сотрудники пронумерованы от 1 до n.Гарантируется, что каждая пара людей p, q упоминается во входных данных не более одного раза. В частности, входные данные не будут содержать пар p, q и q, p одновременно.\n\nВходные данные\n\nВыходные данныеВыведите -1, если описанного порядка не существует. Иначе, выведите перестановку из n различных целых чисел. Первое число должно обозначать номер человека, которого надо позвать первым в кабинет главы R1, второе — номер второго человека, и так далее.Если существует несколько правильных порядков, разрешается вывести любой.\n\nВыходные данные\n\nВходные данныеСкопировать2 11 2Выходные данныеСкопировать2 1 Входные данныеСкопировать3 31 22 33 1Выходные данныеСкопировать2 1 3\n\nВходные данныеСкопировать2 11 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 31 22 33 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 1 3\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Coder-Strike 2014: Раунд 1 - Codeforces",
          "content": "Доброе время суток!Совсем скоро начнется Coder-Strike 2014: Раунд 1. Напоминаю, что его официальными участниками будут школьники Москвы и Московской области, решившие на квалификационном раунде хотя бы одну задачу. Все остальные могут поучаствовать в раунде неофициально. Как обычно, для участия в раунде нужно зарегистрироваться на него на странице.Раунд будет рейтинговым для всех официальных участников раунда, а также для неофициальных участников из второго дивизиона. Рейтинг по официальным и неофициальным участникам будет считаться отдельно.Раунд готовили я, HolkinPV и Igor_Kudryashov. Мы очень старались подготовить его как можно лучше. Если есть какие-то вопросы, не стесняйтесь, задавайте их в комментариях. Надеюсь задачи раунда вам понравятся. Удачи!UPD 1. Распределение баллов по задачам будет стандартное: 500-1000-1500-2000-2500. UPD 2. Соревнование перенесено на 10 минут. Все, кто не успели зарегистрироваться, могут попытать счастье еще 5 минут. :]UPD 3. Из-за сложностей с распределением комнат в этом раунде Div.1 и Div.2 участники будут в одних и тех же комнатах.UPD 4. Соревнование завершилось, надеюсь вам понравилось. Для официальных участников рейтинг пересчитан. Для остальных он будет пересчитан немного позже.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11746",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1238
        },
        {
          "title": "Разбор задач Coder-Strike 2014 Раунд 1 - Codeforces",
          "content": "412A - ПлакатВ данной задаче одно из оптимальных решений следующее. Если k - 1 ≤ n - k, то подвинем сначала лестницу на k - 1 позицию влево. Затем n - 1 раз проделаем пару операций: нарисуем i-ый символ названия и подвинем лестницу вправо. После этого нарисуем последний символ названия. Если же k - 1 > n - k, то подвинем сначала лестницу вправо на n - k позиций. Далее также будем рисовать символ и передвигать лестницу влево, и последним действием нарисуем первый символ названия. Суммарное количество требуемых операций равно min(k - 1, n - k) + 2·n - 1.412B - Настройка сетиВ этой задаче нужно было отсортировать массив по невозрастанию и вывести k-ый элемент. Также ограничения позволяли решать следующим образом. Переберем ans — величину ответа и посчитаем, сколько компьютеров уже имеют скорость не меньшую ans. Если их не меньше k, то такой ответ нам подходит. Среди всех подходящих ответов выберем максимум, это и будет искомой величиной.412C - Строка-шаблонБудем искать требуемый шаблон посимвольно. Рассмотрим i-ый символ. Если в заданных строках на i-ых позициях есть хотя бы два различных символа, отличных от «?», то в ответе на i-ой позиции должен стоять «?». Если на i-ой позиции во всех строках стоят «?», то мы можем записать в ответ любой символ в качестве i-го. Очевидно, лучше записать не «?», а какую-нибудь букву, например «x». Остается случай, когда на i-ых позициях стоят «?» и какая-то одна и та же буква. Тогда нужно определить, что это за буква и добавить ее в ответ.412D - Выдача премийБудем строить искомую перестановку по индукции добавляя по одному сотруднику. Пусть мы уже определили порядок первых k сотрудников: a1, a2, ..., ak. Скажем, что k + 1-ый будет идти за ak-ым. Если ak-ый сотрудник должен денег k + 1-ому, то поменяем им местами (получим перестановку a1, a2, ..., ak - 1, k + 1, ak). Если и ak - 1-ый сотрудник должен k + 1-ому, то поменяем и их местами, и так далее. Если же все из первых k сотрудников должны k + 1-ому, то он окажется в самом начале перестановки. При аккуратной реализации данный алгоритм будет работать за время O(m), где m — количество отношений долга.412E - Е-mail адресаПереберем позицию i такую, что si = «@». Посчитаем количество подстрок, являющихся корректными адресами, у которых символ «@» — это si. Будем идти влево от i до тех пор, пока не встретим «@» или «.» — символы, которые недопустимы слева от «@». Посчитаем cnt сколько букв на пройденном отрезке — с них могут начинаться корректные адреса. Теперь будем двигаться вправо от i пока будут идти цифры или буквы. Если после этого строка закончилась или следует \"@\" или \"_\", то корректные адреса уже не могут получиться. Если же далее идет «.», то пройдем вправо от нее до тех пор, пока встречаются буквы. В каждой из этих букв может закончится корректный адрес, поэтому каждый раз нужно прибавлять к ответу cnt. В описанном выше решении \"пройдемся\" означает \"перебираем циклом\". Это можно делать, т.к. в результате по каждому символу мы пройдем не более 2 раз. Итого асимптотика решения O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11756",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 412\\s*D"
          },
          "content_length": 3023
        }
      ],
      "code_examples": [
        {
          "title": "Coder-Strike 2014: Раунд 1 - Codeforces - Code 1",
          "code": "employe than 1 owes is 2\nemploye than 2 owes is 3\nemploye than 3 owes is 1 ( but we visit that so we step back)\nprint 3\nprint 2\nprint 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 1 - Codeforces - Code 2",
          "code": "employe than 1 owes is 2\nemploye than 2 owes is 3\nemploye than 3 owes is 1 ( but we visit that so we step back)\nprint 3\nprint 2\nprint 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 1 - Codeforces - Code 3",
          "code": "ab@@c.com\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 1 - Codeforces - Code 4",
          "code": "ab@@c.com\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 1 - Codeforces - Code 5",
          "code": "@a_1a@_.a\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 1 - Codeforces - Code 6",
          "code": "@a_1a@_.a\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 1 - Codeforces - Code 7",
          "code": "YellowNextYear",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 500000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        ensuref(a != b, \"ai (%d) should not be equal to bi (%d)\", a, b);\n        auto p = make_pair(a, b);\n        ensuref(edges.count(p) == 0, \"Pair (%d,%d) occurs multiple times\", a, b);\n        edges.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 500000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        ensuref(a != b, \"ai (%d) should not be equal to bi (%d)\", a, b);\n        auto p = make_pair(a, b);\n        ensuref(edges.count(p) == 0, \"Pair (%d,%d) occurs multiple times\", a, b);\n        edges.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 500000, \"m\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        ensuref(a != b, \"ai (%d) should not be equal to bi (%d)\", a, b);\n        auto p = make_pair(a, b);\n        ensuref(edges.count(p) == 0, \"Pair (%d,%d) occurs multiple times\", a, b);\n        edges.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<set<int>> debts; // debts[x] contains the set of people that x owes\n\nvoid readInput() {\n    n = inf.readInt(); // read n\n    m = inf.readInt(); // read m\n    debts.resize(n+1); // debts[1..n]\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt();\n        int b = inf.readInt();\n        debts[a].insert(b);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    readInput();\n    int ansFirstInt = ans.readInt(-1, n, \"ansFirstInt\");\n    int oufFirstInt = ouf.readInt(-1, n, \"oufFirstInt\");\n    \n    if (ansFirstInt == -1) {\n        if (oufFirstInt != -1) {\n            quitf(_wa, \"Contestant found a solution when none exists according to jury\");\n        } else {\n            // Both outputs are -1\n            quitf(_ok, \"Correct: both outputs are -1 (no solution)\");\n        }\n    } else {\n        if (oufFirstInt == -1) {\n            quitf(_wa, \"Contestant says no solution exists but jury found a solution\");\n        } else {\n            // Both outputs are solutions, check participant's permutation\n            vector<int> perm(n);\n            perm[0] = oufFirstInt;\n            for (int i = 1; i < n; ++i) {\n                perm[i] = ouf.readInt(1, n, format(\"perm[%d]\", i+1).c_str());\n            }\n            // Check for duplicates\n            vector<bool> used(n+1, false);\n            used[perm[0]] = true;\n            for (int i = 1; i < n; ++i) {\n                if (used[perm[i]]) {\n                    quitf(_wa, \"Duplicate number %d in permutation\", perm[i]);\n                }\n                used[perm[i]] = true;\n            }\n            // Check adjacent pairs\n            for (int i = 0; i < n-1; ++i) {\n                int x = perm[i];\n                int y = perm[i+1];\n                if (debts[x].count(y)) {\n                    quitf(_wa, \"Invalid adjacent pair: %d owes %d\", x, y);\n                }\n            }\n            // Everything is OK\n            quitf(_ok, \"Participant's output is correct\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int> > edges;\n\n    if (type == \"chain\") {\n        // Debts form a chain: 1->2->3->...->n\n        if (m < n - 1) {\n            // Cannot generate a chain with fewer than n - 1 edges\n            m = n - 1;\n        }\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (type == \"cycle\") {\n        // Debts form a cycle\n        if (m < n) {\n            m = n;\n        }\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        edges.push_back({n, 1});\n    } else if (type == \"star\") {\n        // Debts from node 1 to every other node\n        if (m < n - 1) {\n            m = n -1;\n        }\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"reverse_star\") {\n        // Debts from every other node to node 1\n        if (m < n - 1) {\n            m = n -1;\n        }\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i, 1});\n        }\n    } else { // \"random\"\n        set<pair<int,int> > edge_set;\n        // Generate m random edges avoiding duplicates and reverse edges\n        long long max_edges = (long long)n * (n - 1) / 2;\n        if (m > max_edges) {\n            m = max_edges;\n        }\n        while ( (int)edge_set.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (edge_set.count({b, a})) continue; // Ignore reverse edge\n            if (edge_set.count({a, b})) continue; // Already exists\n            edge_set.insert({a, b});\n        }\n        edges = vector<pair<int,int>>(edge_set.begin(), edge_set.end());\n    }\n\n    // If m is less than edges.size(), randomly select m edges\n    if ( (int)edges.size() > m ) {\n        shuffle(edges.begin(), edges.end());\n        edges.resize(m);\n    }\n\n    // Now output n and m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    // Output edges\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int> > edges;\n\n    if (type == \"chain\") {\n        // Debts form a chain: 1->2->3->...->n\n        if (m < n - 1) {\n            // Cannot generate a chain with fewer than n - 1 edges\n            m = n - 1;\n        }\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (type == \"cycle\") {\n        // Debts form a cycle\n        if (m < n) {\n            m = n;\n        }\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        edges.push_back({n, 1});\n    } else if (type == \"star\") {\n        // Debts from node 1 to every other node\n        if (m < n - 1) {\n            m = n -1;\n        }\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"reverse_star\") {\n        // Debts from every other node to node 1\n        if (m < n - 1) {\n            m = n -1;\n        }\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i, 1});\n        }\n    } else { // \"random\"\n        set<pair<int,int> > edge_set;\n        // Generate m random edges avoiding duplicates and reverse edges\n        long long max_edges = (long long)n * (n - 1) / 2;\n        if (m > max_edges) {\n            m = max_edges;\n        }\n        while ( (int)edge_set.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (edge_set.count({b, a})) continue; // Ignore reverse edge\n            if (edge_set.count({a, b})) continue; // Already exists\n            edge_set.insert({a, b});\n        }\n        edges = vector<pair<int,int>>(edge_set.begin(), edge_set.end());\n    }\n\n    // If m is less than edges.size(), randomly select m edges\n    if ( (int)edges.size() > m ) {\n        shuffle(edges.begin(), edges.end());\n        edges.resize(m);\n    }\n\n    // Now output n and m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    // Output edges\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 0 -type random\n\n./gen -n 2 -m 1 -type chain\n\n./gen -n 3 -m 3 -type cycle\n\n./gen -n 5 -m 4 -type star\n\n./gen -n 5 -m 4 -type reverse_star\n\n./gen -n 10 -m 9 -type chain\n\n./gen -n 10 -m 0 -type random\n\n./gen -n 100 -m 500 -type random\n\n./gen -n 1000 -m 5000 -type random\n\n./gen -n 1000 -m 999 -type chain\n\n./gen -n 1000 -m 1000 -type cycle\n\n./gen -n 1000 -m 1000 -type star\n\n./gen -n 1000 -m 1000 -type reverse_star\n\n./gen -n 5000 -m 10000 -type random\n\n./gen -n 5000 -m 5000 -type random\n\n./gen -n 5000 -m 1000 -type random\n\n./gen -n 100000 -m 200000 -type random\n\n./gen -n 100000 -m 99999 -type chain\n\n./gen -n 100000 -m 100000 -type cycle\n\n./gen -n 100000 -m 100000 -type star\n\n./gen -n 100000 -m 100000 -type reverse_star\n\n./gen -n 100000 -m 0 -type random\n\n./gen -n 100000 -m 1000000 -type random\n\n./gen -n 2 -m 1 -type reverse_star\n\n./gen -n 50000 -m 0 -type random\n\n./gen -n 50000 -m 49999 -type chain\n\n./gen -n 50000 -m 50000 -type cycle\n\n./gen -n 1000 -m 10000 -type random\n\n./gen -n 1000 -m 499500 -type random\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:13.842252",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "412/E",
      "title": "E. E-mail Addresses",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first and the only line contains the sequence of characters s1s2... sn (1 ≤ n ≤ 106) — the saved string. It is guaranteed that the given string contains only small English letters, digits and characters '.', '_', '@'.",
      "output_spec": "OutputPrint in a single line the number of substrings that are valid e-mail addresses.",
      "sample_tests": "ExamplesInputCopygerald.agapov1991@gmail.comOutputCopy18InputCopyx@x.x@x.x_e_@r1.comOutputCopy8InputCopya___@1.rOutputCopy1InputCopy.asd123__..@OutputCopy0",
      "description": "E. E-mail Addresses\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first and the only line contains the sequence of characters s1s2... sn (1 ≤ n ≤ 106) — the saved string. It is guaranteed that the given string contains only small English letters, digits and characters '.', '_', '@'.\n\nOutputPrint in a single line the number of substrings that are valid e-mail addresses.\n\nInputCopygerald.agapov1991@gmail.comOutputCopy18InputCopyx@x.x@x.x_e_@r1.comOutputCopy8InputCopya___@1.rOutputCopy1InputCopy.asd123__..@OutputCopy0\n\nInputCopygerald.agapov1991@gmail.com\n\nOutputCopy18\n\nInputCopyx@x.x@x.x_e_@r1.com\n\nOutputCopy8\n\nInputCopya___@1.r\n\nOutputCopy1\n\nInputCopy.asd123__..@\n\nOutputCopy0\n\nNoteIn the first test case all the substrings that are correct e-mail addresses begin from one of the letters of the word agapov and end in one of the letters of the word com.In the second test case note that the e-mail x@x.x is considered twice in the answer. Note that in this example the e-mail entries overlap inside the string.",
      "solutions": [
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces",
          "content": "Good Day!Coder-Strike 2014: Round 1 will start very soon. If you want to participate, please register for the contest on page. The round was prepared by me, HolkinPV and Igor_Kudryashov. And we tried our best to make it really awesome.The round will be usual rated round for the second division participants. The first division participants can take part too, but for them the round will be unrated.If you have any additional questions, please, ask at comments. Hope you enjoy the problems! Good luck!UPD 1. Score distribution will be standard: 500-1000-1500-2000-2500. UPD 2. The competition was delayed by 10 minutes. :]UPD 3. Because of unusual room assignment Div.1 and Div.2 participants will be in the same rooms this round.UPD 4. The contest has ended, hope you like the problems. Rating for Div.2 participants will be updated a bit later.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11746",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 846
        },
        {
          "title": "Editorial of Coder-Strike 2014 Round 1 - Codeforces",
          "content": "412A - PosterOne of the optimal solutions is the following. If k - 1 ≤ n - k then firstly let's move ladder to the left by k - 1 positions. After that we will do the following pair of operations n - 1 times: paint i-th symbol of the slogan and move the ladder to the right. In the end we will paint the last symbol of the slogan. If k - 1 > n - k then we will move the ladder to the right by n - k positions. After that we will also paint symbol and move the ladder to the left. Our last action will be to paint the first symbol of the slogan. Total number of sought operations is min(k - 1, n - k) + 2·n - 1.412B - Network ConfigurationIn this task you should sort array in descending order and print k-th element. Due to the weak constraints you could also solve the problem in the following manner. Let's brute ans — the value of answer and calculate how many computers already have Internet's speed not less than ans. If there are not less than k such computers then the answer is acceptable. Let's find the maximum among acceptable answers and it will be the sought value.412C - PatternLet's find the answer symbol-by-symbol. Let's consider i-th symbol. If there are two different symbols differ from '?' on i-th positions in the given strings then we must place '?' on i-th position in the answer. If there are '?' on i-th positions in all string then we can write any symbol. Obviously, it is better to write not '?' but any letter, 'x' for example. Lastly we should consider the case when there are only '?' and one the same letter on i-th positions. In this case we should find this letter and put it to the answer.412D - Giving AwardsLet's build sought permutation by adding employee one-by-one. Let's we already define the order of the first k employees: a1, a2, ..., ak. Let's place k + 1-th after ak-th. If ak-th employee owe money to k + 1-th then we will swap their positions (and will get permutation a1, a2, ..., ak - 1, k + 1, ak). If ak - 1-th employee also owe money to k + 1-th then we will also swap their positions and so on. If all first k employees owe money to k + 1-th then k + 1-th employee will be placed first in permutation. This algorithm has time complexity O(m), where m is the number of the debt relationships.412E - E-mail AddressesLet's consider position i such, that si = '@'. We are going to calculate the number of such substrings that are correct addresses and the symbol '@' in them is si. Let's go to the left from i until we find '@' or '.' — the symbols that aren't allowed to be to the left of '@'. Let's calculate cnt how many letters on the segment we went through. This letters can be the first symbols of the correct addresses. Let's now move to the right of i while considered symbol is letter or digit. If we stopped and the string is over or the following symbol is '@' or '_' then there aren't correct addresses. If the following symbol is '.' then let's go to the right of it while the considered symbols are letters. The correct address can finish in every such position, so we should add cnt to the answer. In the described solution \"move\" means \"brute by cycle for\". We can do this because we will go through each symbol not more than 2 times. Total time complexity is O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11756",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 412\\s*E"
          },
          "content_length": 3232
        }
      ],
      "code_examples": [
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 1",
          "code": "employe than 1 owes is 2\nemploye than 2 owes is 3\nemploye than 3 owes is 1 ( but we visit that so we step back)\nprint 3\nprint 2\nprint 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 2",
          "code": "employe than 1 owes is 2\nemploye than 2 owes is 3\nemploye than 3 owes is 1 ( but we visit that so we step back)\nprint 3\nprint 2\nprint 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 3",
          "code": "ab@@c.com\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 4",
          "code": "ab@@c.com\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 5",
          "code": "@a_1a@_.a\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 6",
          "code": "@a_1a@_.a\nAnswer : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 1 - Codeforces - Code 7",
          "code": "YellowNextYear",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11746",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 1000000, \"Length of the string must be between 1 and 1e6, but length=%d\", (int)s.length());\n    for (int i = 0; i < (int)s.length(); ++i) {\n        char c = s[i];\n        ensuref(('a' <= c && c <= 'z') || ('0' <= c && c <= '9') || c == '.' || c == '_' || c == '@', \"Invalid character '%c' at position %d\", c, i+1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 1000000, \"Length of the string must be between 1 and 1e6, but length=%d\", (int)s.length());\n    for (int i = 0; i < (int)s.length(); ++i) {\n        char c = s[i];\n        ensuref(('a' <= c && c <= 'z') || ('0' <= c && c <= '9') || c == '.' || c == '_' || c == '@', \"Invalid character '%c' at position %d\", c, i+1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 1000000, \"Length of the string must be between 1 and 1e6, but length=%d\", (int)s.length());\n    for (int i = 0; i < (int)s.length(); ++i) {\n        char c = s[i];\n        ensuref(('a' <= c && c <= 'z') || ('0' <= c && c <= '9') || c == '.' || c == '_' || c == '@', \"Invalid character '%c' at position %d\", c, i+1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"no_email\") {\n        // Generate a string of length n with no valid email addresses.\n        // For this, we can fill it with characters that cannot form valid emails.\n        // Since valid emails require '@' and '.', we can avoid those.\n        // Also, we need to avoid sequences that start with letters and contain '@' and '.'\n\n        s = \"\";\n        string chars = \"bcdefghijklmnopqrstuvwxyz0123456789_\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(int(chars.size()))];\n        }\n\n    } else if (type == \"max_email\") {\n        // Generate a string of length n that contains the maximum possible number of valid email addresses.\n        // We need to consider overlapping emails.\n        // We'll create overlapping minimal emails.\n\n        s = \"\";\n        string email = \"a@1.a\";\n        int overlap = 4; // Overlap as much as possible to maximize number of emails\n\n        while ((int)s.length() + (int)email.length() - overlap <= n) {\n            s += email.substr(overlap);\n        }\n        s = email.substr(0, overlap) + s;\n        if ((int)s.length() < n) {\n            s += string(n - s.length(), 'a');\n        } else if ((int)s.length() > n) {\n            s = s.substr(0, n);\n        }\n\n    } else if (type == \"random_email\") {\n        // Generate a random string with some valid email addresses embedded.\n\n        s = \"\";\n        string all_chars = \"abcdefghijklmnopqrstuvwxyz0123456789._@\";\n\n        int pos_in_s = 0;\n        while (pos_in_s < n) {\n            if (rnd.next(0, 1)) {\n                // Insert an email with 50% probability\n                int remaining = n - pos_in_s;\n                if (remaining >= 5) {\n                    // Generate a random valid email of length between 5 and min(20, remaining)\n                    int email_len = rnd.next(5, min(20, remaining));\n                    // Build an email\n                    string email = \"\";\n\n                    // username: starts with letter, followed by letters, numbers, '_', at least 1 character\n                    int username_len = rnd.next(1, email_len - 4); // at least one character, leaves enough for '@a.a'\n                    email += 'a' + rnd.next(26); // starting letter\n                    string username_chars = \"abcdefghijklmnopqrstuvwxyz0123456789_\";\n                    for (int j = 1; j < username_len; ++j) {\n                        email += username_chars[rnd.next(int(username_chars.size()))];\n                    }\n\n                    email += '@';\n\n                    // domain: non-empty sequence of letters or numbers\n                    int domain_len = rnd.next(1, email_len - username_len - 3);  // at least 1 character, leaves enough for '.a'\n                    string domain_chars = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n                    for (int j = 0; j < domain_len; ++j) {\n                        email += domain_chars[rnd.next(int(domain_chars.size()))];\n                    }\n\n                    email += '.';\n\n                    // tld: non-empty sequence of letters\n                    int tld_len = email_len - username_len - domain_len - 2;\n                    if (tld_len <= 0) tld_len = 1;\n                    for (int j = 0; j < tld_len; ++j) {\n                        email += 'a' + rnd.next(26);\n                    }\n\n                    s += email;\n\n                    pos_in_s += email.length();\n                } else {\n                    // Not enough space, fill with random characters\n                    while (pos_in_s < n) {\n                        s += all_chars[rnd.next(int(all_chars.size()))];\n                        pos_in_s++;\n                    }\n                    break;\n                }\n            } else {\n                // Insert random character\n                s += all_chars[rnd.next(int(all_chars.size()))];\n                pos_in_s++;\n            }\n        }\n        if ((int)s.length() > n) s = s.substr(0, n);\n\n    } else if (type == \"overlapping_email\") {\n        // Generate a string where emails overlap\n\n        string email = \"a@1.a\";\n        s = \"\";\n        int overlap = 1; // Number of characters to overlap\n        while ((int)s.length() + (int)email.length() - overlap <= n) {\n            s += email.substr(overlap);\n        }\n        s = email.substr(0, overlap) + s;\n        if ((int)s.length() > n) s = s.substr(0, n);\n\n    } else if (type == \"starts_with_email\") {\n        // Generate a string that starts with an email, possibly with some random characters after\n\n        s = \"\";\n        // Generate a valid email\n        string email = \"a@1.a\";\n        s += email;\n\n        // Fill the rest with random characters\n        int remaining = n - s.length();\n        string chars = \"abcdefghijklmnopqrstuvwxyz0123456789_@.\";\n        for (int i = 0; i < remaining; ++i) {\n            s += chars[rnd.next(int(chars.size()))];\n        }\n\n    } else if (type == \"ends_with_email\") {\n        // Generate a string that ends with an email, possibly with some random characters before\n\n        s = \"\";\n\n        // Fill the initial part with random characters\n        int initial_length = n - 5; // length of 'a@1.a' is 5\n        string chars = \"abcdefghijklmnopqrstuvwxyz0123456789_@.\";\n        for (int i = 0; i < initial_length; ++i) {\n            s += chars[rnd.next(int(chars.size()))];\n        }\n\n        // Append a valid email\n        s += \"a@1.a\";\n\n    } else if (type == \"minimal_email\") {\n        // Generate a string with minimal valid emails\n\n        s = \"\";\n        string email = \"a@1.a\";\n        while ((int)s.length() + (int)email.length() <= n) {\n            s += email;\n        }\n        int remaining = n - s.length();\n        s += string(remaining, 'a');\n\n    } else {\n        // By default, generate a random string of length n with allowed characters\n\n        s = \"\";\n        string chars = \"abcdefghijklmnopqrstuvwxyz0123456789_@.\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(int(chars.size()))];\n        }\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"no_email\") {\n        // Generate a string of length n with no valid email addresses.\n        // For this, we can fill it with characters that cannot form valid emails.\n        // Since valid emails require '@' and '.', we can avoid those.\n        // Also, we need to avoid sequences that start with letters and contain '@' and '.'\n\n        s = \"\";\n        string chars = \"bcdefghijklmnopqrstuvwxyz0123456789_\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(int(chars.size()))];\n        }\n\n    } else if (type == \"max_email\") {\n        // Generate a string of length n that contains the maximum possible number of valid email addresses.\n        // We need to consider overlapping emails.\n        // We'll create overlapping minimal emails.\n\n        s = \"\";\n        string email = \"a@1.a\";\n        int overlap = 4; // Overlap as much as possible to maximize number of emails\n\n        while ((int)s.length() + (int)email.length() - overlap <= n) {\n            s += email.substr(overlap);\n        }\n        s = email.substr(0, overlap) + s;\n        if ((int)s.length() < n) {\n            s += string(n - s.length(), 'a');\n        } else if ((int)s.length() > n) {\n            s = s.substr(0, n);\n        }\n\n    } else if (type == \"random_email\") {\n        // Generate a random string with some valid email addresses embedded.\n\n        s = \"\";\n        string all_chars = \"abcdefghijklmnopqrstuvwxyz0123456789._@\";\n\n        int pos_in_s = 0;\n        while (pos_in_s < n) {\n            if (rnd.next(0, 1)) {\n                // Insert an email with 50% probability\n                int remaining = n - pos_in_s;\n                if (remaining >= 5) {\n                    // Generate a random valid email of length between 5 and min(20, remaining)\n                    int email_len = rnd.next(5, min(20, remaining));\n                    // Build an email\n                    string email = \"\";\n\n                    // username: starts with letter, followed by letters, numbers, '_', at least 1 character\n                    int username_len = rnd.next(1, email_len - 4); // at least one character, leaves enough for '@a.a'\n                    email += 'a' + rnd.next(26); // starting letter\n                    string username_chars = \"abcdefghijklmnopqrstuvwxyz0123456789_\";\n                    for (int j = 1; j < username_len; ++j) {\n                        email += username_chars[rnd.next(int(username_chars.size()))];\n                    }\n\n                    email += '@';\n\n                    // domain: non-empty sequence of letters or numbers\n                    int domain_len = rnd.next(1, email_len - username_len - 3);  // at least 1 character, leaves enough for '.a'\n                    string domain_chars = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n                    for (int j = 0; j < domain_len; ++j) {\n                        email += domain_chars[rnd.next(int(domain_chars.size()))];\n                    }\n\n                    email += '.';\n\n                    // tld: non-empty sequence of letters\n                    int tld_len = email_len - username_len - domain_len - 2;\n                    if (tld_len <= 0) tld_len = 1;\n                    for (int j = 0; j < tld_len; ++j) {\n                        email += 'a' + rnd.next(26);\n                    }\n\n                    s += email;\n\n                    pos_in_s += email.length();\n                } else {\n                    // Not enough space, fill with random characters\n                    while (pos_in_s < n) {\n                        s += all_chars[rnd.next(int(all_chars.size()))];\n                        pos_in_s++;\n                    }\n                    break;\n                }\n            } else {\n                // Insert random character\n                s += all_chars[rnd.next(int(all_chars.size()))];\n                pos_in_s++;\n            }\n        }\n        if ((int)s.length() > n) s = s.substr(0, n);\n\n    } else if (type == \"overlapping_email\") {\n        // Generate a string where emails overlap\n\n        string email = \"a@1.a\";\n        s = \"\";\n        int overlap = 1; // Number of characters to overlap\n        while ((int)s.length() + (int)email.length() - overlap <= n) {\n            s += email.substr(overlap);\n        }\n        s = email.substr(0, overlap) + s;\n        if ((int)s.length() > n) s = s.substr(0, n);\n\n    } else if (type == \"starts_with_email\") {\n        // Generate a string that starts with an email, possibly with some random characters after\n\n        s = \"\";\n        // Generate a valid email\n        string email = \"a@1.a\";\n        s += email;\n\n        // Fill the rest with random characters\n        int remaining = n - s.length();\n        string chars = \"abcdefghijklmnopqrstuvwxyz0123456789_@.\";\n        for (int i = 0; i < remaining; ++i) {\n            s += chars[rnd.next(int(chars.size()))];\n        }\n\n    } else if (type == \"ends_with_email\") {\n        // Generate a string that ends with an email, possibly with some random characters before\n\n        s = \"\";\n\n        // Fill the initial part with random characters\n        int initial_length = n - 5; // length of 'a@1.a' is 5\n        string chars = \"abcdefghijklmnopqrstuvwxyz0123456789_@.\";\n        for (int i = 0; i < initial_length; ++i) {\n            s += chars[rnd.next(int(chars.size()))];\n        }\n\n        // Append a valid email\n        s += \"a@1.a\";\n\n    } else if (type == \"minimal_email\") {\n        // Generate a string with minimal valid emails\n\n        s = \"\";\n        string email = \"a@1.a\";\n        while ((int)s.length() + (int)email.length() <= n) {\n            s += email;\n        }\n        int remaining = n - s.length();\n        s += string(remaining, 'a');\n\n    } else {\n        // By default, generate a random string of length n with allowed characters\n\n        s = \"\";\n        string chars = \"abcdefghijklmnopqrstuvwxyz0123456789_@.\";\n        for (int i = 0; i < n; ++i) {\n            s += chars[rnd.next(int(chars.size()))];\n        }\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type minimal_email\n./gen -n 10 -type minimal_email\n./gen -n 15 -type minimal_email\n\n./gen -n 5 -type max_email\n./gen -n 10 -type max_email\n./gen -n 15 -type max_email\n\n./gen -n 20 -type overlapping_email\n./gen -n 25 -type overlapping_email\n./gen -n 30 -type overlapping_email\n\n./gen -n 1000000 -type no_email\n./gen -n 1000000 -type max_email\n./gen -n 1000000 -type overlapping_email\n\n./gen -n 1000000 -type random_email\n./gen -n 1000000 -type starts_with_email\n./gen -n 1000000 -type ends_with_email\n\n./gen -n 1 -type no_email\n./gen -n 1 -type starts_with_email\n\n./gen -n 1000000 -type minimal_email\n\n./gen -n 999999 -type random_email\n\n./gen -n 500000 -type random_email\n./gen -n 500000 -type no_email\n\n./gen -n 1000 -type starts_with_email\n./gen -n 1000 -type ends_with_email\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:16.109701",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "413/A",
      "title": "A. Восстановление данных",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны четыре целых числа n, m, min, max (1 ≤ m < n ≤ 100; 1 ≤ min < max ≤ 100). Во второй строке записаны m целых чисел через пробел ti (1 ≤ ti ≤ 100) — выписанные помощником температуры.Обратите внимание, что как выписанные, так и добавленные температуры могут быть одинаковыми.",
      "output_spec": "Выходные данныеЕсли данные непротиворечивые, выведите «Correct» (без кавычек). Иначе, выведите «Incorrect» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать2 1 1 21Выходные данныеСкопироватьCorrectВходные данныеСкопировать3 1 1 32Выходные данныеСкопироватьCorrectВходные данныеСкопировать2 1 1 32Выходные данныеСкопироватьIncorrect",
      "description": "A. Восстановление данных\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны четыре целых числа n, m, min, max (1 ≤ m < n ≤ 100; 1 ≤ min < max ≤ 100). Во второй строке записаны m целых чисел через пробел ti (1 ≤ ti ≤ 100) — выписанные помощником температуры.Обратите внимание, что как выписанные, так и добавленные температуры могут быть одинаковыми.\n\nВходные данные\n\nВыходные данныеЕсли данные непротиворечивые, выведите «Correct» (без кавычек). Иначе, выведите «Incorrect» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать2 1 1 21Выходные данныеСкопироватьCorrectВходные данныеСкопировать3 1 1 32Выходные данныеСкопироватьCorrectВходные данныеСкопировать2 1 1 32Выходные данныеСкопироватьIncorrect\n\nВходные данныеСкопировать2 1 1 21\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьCorrect\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 1 1 32\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьCorrect\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 1 1 32\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьIncorrect\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере одна из возможных изначальных конфигураций температур: [1, 2].Во втором тестовом примере одна из возможных изначальных конфигураций температур: [2, 1, 3].В третьем тестовом примере никак нельзя добавить одну температуру, чтобы получить минимум, равный 1, и максимум, равный 3.",
      "solutions": [
        {
          "title": "Coder-Strike 2014: Раунд 2 - Codeforces",
          "content": "Добрый день!Завтра утром состоится Coder-Strike 2014: Раунд 2. Как обычно, для участия в нем нужно зарегистрироваться на странице.Аналогично прошлому раунду, все желающие могут принять участие в раунде. Раунд будет рейтинговым для всех официальных участников раунда (лучшие 50 официальных участников первого раунда), а также для неофициальных участников из второго дивизиона. Рейтинг по официальным и неофициальным участникам будет считаться отдельно. Для неофициальных участников из первого дивизиона раунд будет нерейтинговым, но не расстраивайтесь, финальный раунд обязательно будет рейтинговым для первого дивизиона.Если есть какие-то вопросы, не стесняйтесь, задавайте их в комментариях.Удачи и до встречи на раунде!UPD 1. Прошу прощение за небольшое опоздание, разбалловка стандартная.UPD 2. Контест завершен, поздравляю победителей, надеюсь задачи вам понравились!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11784",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 871
        },
        {
          "title": "Разбор задач Coder-Strike 2014 Раунд 2 - Codeforces",
          "content": "413A - Восстановление данныхПосчитаем минимум и максимум в заданном массиве размера m. Если минимум уже меньше заданного min, либо если уже максимум больше заданного max, то ответ Incorrect. Посчитаем минимальное значение 0 ≤ need ≤ 2, которое будет равняться числу элементов, которые надо добавить в исходный массив, чтобы его минимум стал равен min, а максимум стал равен max. Для этого нужно попарно сравнить минимум заданном массиве со значением min и максимум в заданном массиве со значением max. Тогда ответ Correct, если n - m ≥ need. Иначе ответ Incorrect.413B - Spyke чатОбработаем все запросы и будем поддерживать следующие величины: для каждого сотрудника будем поддерживать число сообщений, которые он отправил в какой-нибудь чат и для каждого чата количество сообщений, которые были отправлены в этот чат. Тогда ответ для каждого сотрудника — это сумма числа сообщений, отправленных во все чаты, участником которых является данный сотрудник, минус число сообщений которые отправил сам сотрудник в какой-нибудь чат.413C - Своя играДля начала выберем все вопросы не аукционы и ответим на них. Затем у нас останутся только вопросы аукционы. Отсортируем их по неубыванию стоимости. Далее переберём минимальный размер суффикса, вопросы из которого нужно будет взять за их стоимость, а остальные вопросы возможно будет использовать для умножения нашего выигрыша на 2.Очевидно, что это наиболее выгодно, поскольку чем меньше стоимость вопроса, тем меньше нужно иметь очков для умножения своего баланса на 2. Так же чем больше стоимость вопроса, тем более выгодно брать его за реальную стоимость.413D - 2048Рассмотрим произвольное состояние в нашей игре. Заметим, что нам имеет смысл поддерживать максимальный по длине суффикс чисел в убывающем порядке. При этом будем хранить только младшие k - 1 степень двойки, а также запомним была ли уже достигнута k-ая степень или выше. Действительно, если убывающий порядок нарушился, то мы никогда не сможем использовать эти числа, поскольку значения могут только увеличиваться.Поэтому посчитаем следующую динамику dp[i][mask][j], где i — размер уже рассмотренного префикса элементов, а mask — маска размера k, в которой бит x возведён тогда и только тогда, когда среди последних идущих по убыванию степеней двойки присутствует 2x, j — была ли уже достигнута k-ая степень или выше (0 или 1). Возможны два типа переходов, когда пришло число 2 и когда пришло число 4. Если пришло число 0, то выполним оба перехода.413E - Лабиринт 2DБудем обрабатывать запросы по очереди. Вначале проверим, достижима ли одна клетка из другой. Для этого вначале найдем компоненты связности. Если клетки находятся в разных компонентах связности, то ответ -1. Иначе предположим, что обе клетки находятся в столбцах, в которых ровно одно препятствие. Чтобы найти длину пути между ними, необходимо предподсчитать с помощью частичных сумм длины путей между такими столбцами.Для этого пройдем по столбцам слева направо, поддерживая тип последнего столбца с одним препятствием (препятствие в нижней строке, либо препятствие в верхней строке). Если в столбце j тип препятствия изменился, то запишем в массив для частичных сумм в позицию j единицу, иначе запишем ноль. Тогда ответ на такой вид запросов будет равен сумме модуля разности столбцов клеток запроса и значения посчитанной частичной суммы между ними. Если столбец с левой клеткой запроса не содержит препятствий, то найдем ближайший справа от него столбец с одним препятствием, а для столбца с правой клеткой запроса найдем ближайший слева столбец с одним препятствием. Таким образом, мы сведем общий вид запроса к описанному выше. Нужно быть аккуратным в случае, если между клетками запроса нет столбцов с ровно одним препятствием.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11837",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 413\\s*A"
          },
          "content_length": 3710
        }
      ],
      "code_examples": [
        {
          "title": "Coder-Strike 2014: Раунд 2 - Codeforces - Code 1",
          "code": "2 1\n.X\n..\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 2 - Codeforces - Code 2",
          "code": "2 1\n.X\n..\n1 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 2 - Codeforces - Code 3",
          "code": "5 1\n.X.X.\n.....\n3 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 2 - Codeforces - Code 4",
          "code": "5 1\n.X.X.\n.....\n3 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 2 - Codeforces - Code 5",
          "code": "c[i] = a[b[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 2 - Codeforces - Code 6",
          "code": "1 <= i <= n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 2 - Codeforces - Code 7",
          "code": "1 <= i <= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 2 - Codeforces - Code 8",
          "code": "Будьте осторожны, игра затягивает, а времени на контесте не так много!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 2 - Codeforces - Code 9",
          "code": "s1 = [l; m]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 2 - Codeforces - Code 10",
          "code": "s2 = [m+1; r]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 2 - Codeforces - Code 11",
          "code": "d[i][j] = 1 + min(s1.d[i][0] + s2.d[0][j], s1.d[i][1] + s2.d[1][j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 2 - Codeforces - Code 12",
          "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<limits>\n#include<vector>\n#include<set>\n#include<utility>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long long unsigned LLU;\n\n#define fi first\n#define se second\n#define DEB(N) cout<<#N<<\"  :  \"<<N<<endl\nLL GCD(LL a,LL b)\n{\n    return __gcd(a,b);\n}\n\nLL LCM(LL a,LL b)\n{\n    return a/GCD(a,b)*b;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);cin.tie(0);\n    int n,m,k,num;cin>>n>>m>>k;\n    vector< vector<int>   > chats(m);int i;\n    for(i=0;i<m;i++)\n        chats[i].resize(20010);\n    int j;\n    for(i=0;i<n;i++)\n    {\n\n        for( j=0;j<m;j++)\n        {\n            cin>>num;\n            if(num==1)\n            {\n                chats[j][chats[j][20009]]=i;\n                chats[j][20009]++;\n            }\n        }\n    }\n    int employ[30000]={0};\n    int x1,y1;\n    for(i=0;i<k;i++)\n    {\n        cin>>x1>>y1;y1--;x1--;\n        for(j=0;j<chats[y1][20009];j++)\n        {\n                employ[chats[y1][j]]++;\n        }\n        employ[x1]--;\n    }\n\n    for(i=0;i<n;i++)cout<<employ[i]<<\" \";\n\n    cout<<endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 2 - Codeforces - Code 13",
          "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<limits>\n#include<vector>\n#include<set>\n#include<utility>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long long unsigned LLU;\n\n#define fi first\n#define se second\n#define DEB(N) cout<<#N<<\"  :  \"<<N<<endl\nLL GCD(LL a,LL b)\n{\n    return __gcd(a,b);\n}\n\nLL LCM(LL a,LL b)\n{\n    return a/GCD(a,b)*b;\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);cin.tie(0);\n    int n,m,k,num;cin>>n>>m>>k;\n    vector< vector<int>   > chats(m);int i;\n    for(i=0;i<m;i++)\n        chats[i].resize(20010);\n    int j;\n    for(i=0;i<n;i++)\n    {\n\n        for( j=0;j<m;j++)\n        {\n            cin>>num;\n            if(num==1)\n            {\n                chats[j][chats[j][20009]]=i;\n                chats[j][20009]++;\n            }\n        }\n    }\n    int employ[30000]={0};\n    int x1,y1;\n    for(i=0;i<k;i++)\n    {\n        cin>>x1>>y1;y1--;x1--;\n        for(j=0;j<chats[y1][20009];j++)\n        {\n                employ[chats[y1][j]]++;\n        }\n        employ[x1]--;\n    }\n\n    for(i=0;i<n;i++)cout<<employ[i]<<\" \";\n\n    cout<<endl;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 2 - Codeforces - Code 14",
          "code": "for(i=0;i<k;i++)\n        for(j=0;j<chats[y1][20009];j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 2 - Codeforces - Code 15",
          "code": "for(i=0;i<k;i++)\n        for(j=0;j<chats[y1][20009];j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Раунд 2 - Codeforces - Code 16",
          "code": "n*k = 4 * 10^9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n - 1, \"m\");\n    inf.readSpace();\n    int min_t = inf.readInt(1, 99, \"min\");\n    inf.readSpace();\n    int max_t = inf.readInt(min_t + 1, 100, \"max\");\n    inf.readEoln();\n\n    vector<int> t = inf.readInts(m, 1, 100, \"t\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n - 1, \"m\");\n    inf.readSpace();\n    int min_t = inf.readInt(1, 99, \"min\");\n    inf.readSpace();\n    int max_t = inf.readInt(min_t + 1, 100, \"max\");\n    inf.readEoln();\n\n    vector<int> t = inf.readInts(m, 1, 100, \"t\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n - 1, \"m\");\n    inf.readSpace();\n    int min_t = inf.readInt(1, 99, \"min\");\n    inf.readSpace();\n    int max_t = inf.readInt(min_t + 1, 100, \"max\");\n    inf.readEoln();\n\n    vector<int> t = inf.readInts(m, 1, 100, \"t\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string correctness = opt<string>(\"correctness\", \"correct\");\n\n    ensure(1 <= m && m < n && n <= 100);\n\n    int mn, mx;\n\n    if (correctness == \"correct\") {\n        // Generate min and max such that 1 <= min < max <= 100\n        mn = rnd.next(1, 99);\n        mx = rnd.next(mn + 1, 100);\n\n        // Number of missing values among min and max\n        int totalMissing = rnd.next(0, min(2, n - m));\n\n        // Determine if min and/or max are missing\n        bool missingMin = false, missingMax = false;\n        if (totalMissing == 1) {\n            if (rnd.next(2) == 0) {\n                missingMin = true;\n            } else {\n                missingMax = true;\n            }\n        } else if (totalMissing == 2) {\n            missingMin = true;\n            missingMax = true;\n        }\n\n        set<int> missingSet;\n        if (missingMin) missingSet.insert(mn);\n        if (missingMax) missingSet.insert(mx);\n\n        vector<int> t(m);\n        for (int i = 0; i < m; ++i) {\n            int val;\n            do {\n                val = rnd.next(1, 100);\n            } while (missingSet.count(val));\n            t[i] = val;\n        }\n\n        // Output\n        printf(\"%d %d %d %d\\n\", n, m, mn, mx);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", t[i]);\n        }\n        printf(\"\\n\");\n\n    } else { // correctness == \"incorrect\"\n        // Ensure n - m <= 1 for totalMissing > n - m\n        ensure(n - m <= 1);\n\n        // Generate min and max\n        mn = rnd.next(1, 99);\n        mx = rnd.next(mn + 1, 100);\n\n        // Both min and max are missing\n        set<int> missingSet = {mn, mx};\n        vector<int> t(m);\n        for (int i = 0; i < m; ++i) {\n            int val;\n            do {\n                val = rnd.next(1, 100);\n            } while (missingSet.count(val));\n            t[i] = val;\n        }\n\n        // Output\n        printf(\"%d %d %d %d\\n\", n, m, mn, mx);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", t[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string correctness = opt<string>(\"correctness\", \"correct\");\n\n    ensure(1 <= m && m < n && n <= 100);\n\n    int mn, mx;\n\n    if (correctness == \"correct\") {\n        // Generate min and max such that 1 <= min < max <= 100\n        mn = rnd.next(1, 99);\n        mx = rnd.next(mn + 1, 100);\n\n        // Number of missing values among min and max\n        int totalMissing = rnd.next(0, min(2, n - m));\n\n        // Determine if min and/or max are missing\n        bool missingMin = false, missingMax = false;\n        if (totalMissing == 1) {\n            if (rnd.next(2) == 0) {\n                missingMin = true;\n            } else {\n                missingMax = true;\n            }\n        } else if (totalMissing == 2) {\n            missingMin = true;\n            missingMax = true;\n        }\n\n        set<int> missingSet;\n        if (missingMin) missingSet.insert(mn);\n        if (missingMax) missingSet.insert(mx);\n\n        vector<int> t(m);\n        for (int i = 0; i < m; ++i) {\n            int val;\n            do {\n                val = rnd.next(1, 100);\n            } while (missingSet.count(val));\n            t[i] = val;\n        }\n\n        // Output\n        printf(\"%d %d %d %d\\n\", n, m, mn, mx);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", t[i]);\n        }\n        printf(\"\\n\");\n\n    } else { // correctness == \"incorrect\"\n        // Ensure n - m <= 1 for totalMissing > n - m\n        ensure(n - m <= 1);\n\n        // Generate min and max\n        mn = rnd.next(1, 99);\n        mx = rnd.next(mn + 1, 100);\n\n        // Both min and max are missing\n        set<int> missingSet = {mn, mx};\n        vector<int> t(m);\n        for (int i = 0; i < m; ++i) {\n            int val;\n            do {\n                val = rnd.next(1, 100);\n            } while (missingSet.count(val));\n            t[i] = val;\n        }\n\n        // Output\n        printf(\"%d %d %d %d\\n\", n, m, mn, mx);\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) printf(\" \");\n            printf(\"%d\", t[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -correctness correct\n./gen -n 2 -m 1 -correctness incorrect\n\n./gen -n 3 -m 1 -correctness correct\n./gen -n 3 -m 2 -correctness correct\n./gen -n 3 -m 2 -correctness incorrect\n\n./gen -n 5 -m 2 -correctness correct\n./gen -n 5 -m 3 -correctness correct\n./gen -n 5 -m 4 -correctness correct\n./gen -n 5 -m 4 -correctness incorrect\n\n./gen -n 10 -m 5 -correctness correct\n./gen -n 10 -m 9 -correctness correct\n./gen -n 10 -m 9 -correctness incorrect\n\n./gen -n 20 -m 10 -correctness correct\n./gen -n 20 -m 19 -correctness correct\n./gen -n 20 -m 19 -correctness incorrect\n\n./gen -n 100 -m 50 -correctness correct\n./gen -n 100 -m 99 -correctness correct\n./gen -n 100 -m 99 -correctness incorrect\n\n./gen -n 5 -m 4 -correctness correct\n./gen -n 5 -m 4 -correctness incorrect\n\n./gen -n 2 -m 1 -correctness correct\n./gen -n 2 -m 1 -correctness incorrect\n\n./gen -n 4 -m 2 -correctness correct\n./gen -n 4 -m 2 -correctness incorrect\n\n./gen -n 3 -m 1 -correctness correct\n./gen -n 3 -m 1 -correctness incorrect\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:18.113073",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "413/B",
      "title": "Problem 413/B",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 20000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 200000, \"k\");\n    inf.readEoln();\n\n    vector<vector<int>> a(n, vector<int>(m));\n\n    for (int i = 0; i < n; i++) {\n        a[i] = inf.readInts(m, 0, 1);\n        inf.readEoln();\n    }\n\n    // Check that each chat has at least 2 participants\n    for (int j = 0; j < m; j++) {\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (a[i][j] == 1) count++;\n        }\n        ensuref(count >= 2, \"Chat %d should have at least two participants\", j+1);\n    }\n\n    for (int i = 0; i < k; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, m, \"yi\");\n        inf.readEoln();\n\n        ensuref(a[xi - 1][yi - 1] == 1, \"Employee %d is not a participant of chat %d\", xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 20000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 200000, \"k\");\n    inf.readEoln();\n\n    vector<vector<int>> a(n, vector<int>(m));\n\n    for (int i = 0; i < n; i++) {\n        a[i] = inf.readInts(m, 0, 1);\n        inf.readEoln();\n    }\n\n    // Check that each chat has at least 2 participants\n    for (int j = 0; j < m; j++) {\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (a[i][j] == 1) count++;\n        }\n        ensuref(count >= 2, \"Chat %d should have at least two participants\", j+1);\n    }\n\n    for (int i = 0; i < k; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, m, \"yi\");\n        inf.readEoln();\n\n        ensuref(a[xi - 1][yi - 1] == 1, \"Employee %d is not a participant of chat %d\", xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 20000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 200000, \"k\");\n    inf.readEoln();\n\n    vector<vector<int>> a(n, vector<int>(m));\n\n    for (int i = 0; i < n; i++) {\n        a[i] = inf.readInts(m, 0, 1);\n        inf.readEoln();\n    }\n\n    // Check that each chat has at least 2 participants\n    for (int j = 0; j < m; j++) {\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (a[i][j] == 1) count++;\n        }\n        ensuref(count >= 2, \"Chat %d should have at least two participants\", j+1);\n    }\n\n    for (int i = 0; i < k; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, m, \"yi\");\n        inf.readEoln();\n\n        ensuref(a[xi - 1][yi - 1] == 1, \"Employee %d is not a participant of chat %d\", xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check that n, m, k are within constraints\n    ensuref(2 <= n && n <= 20000, \"n (%d) must be in range [2, 20000]\", n);\n    ensuref(1 <= m && m <= 10, \"m (%d) must be in range [1, 10]\", m);\n    ensuref(1 <= k && k <= 200000, \"k (%d) must be in range [1, 200000]\", k);\n\n    vector<vector<int> > a(n, vector<int>(m, 0)); // Matrix a_{ij}\n    \n    // Now, generate types accordingly\n    if (type == \"random\") {\n        // Randomly assign employees to chats\n        for (int j = 0; j < m; ++j) {\n            // For each chat, select participants\n            int num_participants = rnd.next(2, n); // At least 2 participants per chat\n\n            // Shuffle employees and pick num_participants of them\n            vector<int> perm(n);\n            for(int i = 0; i < n; ++i) perm[i] = i;\n            shuffle(perm.begin(), perm.end());\n\n            for (int i = 0; i < num_participants; ++i) {\n                int employee = perm[i];\n                a[employee][j] = 1;\n            }\n        }\n    } else if (type == \"sparse\") {\n        // Each chat has exactly 2 participants\n        // Assign each chat to two unique employees if possible\n\n        if (n < 2) {\n            fprintf(stderr, \"Not enough employees for 'sparse' type\\n\");\n            exit(1);\n        }\n\n        // Create a list of employees\n        vector<int> employees(n);\n        for(int i = 0; i < n; ++i) employees[i] = i;\n\n        shuffle(employees.begin(), employees.end());\n\n        int idx = 0;\n        for (int j = 0; j < m; ++j) {\n            a[employees[idx % n]][j] = 1;\n            a[employees[(idx + 1) % n]][j] = 1;\n            idx += 2;\n        }\n    } else if (type == \"dense\") {\n        // Each employee participates in all chats\n        // All chats have all employees\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = 1;\n    } else if (type == \"some_empty\") {\n        // Some employees are not in any chat\n        // Some chats have minimum participants\n        if (n < 2) {\n            fprintf(stderr, \"Not enough employees for 'some_empty' type\\n\");\n            exit(1);\n        }\n        // Let's assign chats to only two employees\n        vector<int> employees(n);\n        for(int i = 0; i < n; ++i) employees[i] = i;\n\n        shuffle(employees.begin(), employees.end());\n\n        for (int j = 0; j < m; ++j) {\n            a[employees[0]][j] = 1;\n            a[employees[1]][j] = 1;\n        }\n\n        // The rest of the employees are in no chats\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Ensure that each chat has at least two participants\n    for (int j = 0; j < m; ++j) {\n        int participants = 0;\n        for (int i = 0; i < n; ++i)\n            if (a[i][j] == 1)\n                ++participants;\n        if (participants < 2) {\n            fprintf(stderr, \"Chat %d has less than 2 participants\\n\", j + 1);\n            exit(1);\n        }\n    }\n\n    // Now, generate k events\n    vector<pair<int, int> > events;\n\n    // Precompute for each employee the list of chats they are in\n    vector<vector<int> > employee_chats(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (a[i][j] == 1)\n                employee_chats[i].push_back(j);\n        }\n    }\n\n    // Build a list of employees who are in at least one chat\n    vector<int> active_employees;\n    for (int i = 0; i < n; ++i)\n        if (!employee_chats[i].empty())\n            active_employees.push_back(i);\n\n    for (int z = 0; z < k; ++z) {\n        // Randomly pick an employee who is in at least one chat\n        int emp_idx = rnd.next(0, (int)active_employees.size() - 1);\n        int emp = active_employees[emp_idx];\n\n        // Randomly pick a chat they are in\n        int chat_idx = rnd.next(0, (int)employee_chats[emp].size() - 1);\n        int chat = employee_chats[emp][chat_idx];\n\n        events.emplace_back(emp, chat);\n    }\n\n    // Output the test case\n\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output matrix a (n lines of m numbers)\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", a[i][j]);\n            if (j + 1 < m)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    // Output k events\n    for (int z = 0; z < k; ++z) {\n        int xi = events[z].first + 1; // Employee IDs are 1-based\n        int yi = events[z].second + 1; // Chat IDs are 1-based\n        printf(\"%d %d\\n\", xi, yi);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check that n, m, k are within constraints\n    ensuref(2 <= n && n <= 20000, \"n (%d) must be in range [2, 20000]\", n);\n    ensuref(1 <= m && m <= 10, \"m (%d) must be in range [1, 10]\", m);\n    ensuref(1 <= k && k <= 200000, \"k (%d) must be in range [1, 200000]\", k);\n\n    vector<vector<int> > a(n, vector<int>(m, 0)); // Matrix a_{ij}\n    \n    // Now, generate types accordingly\n    if (type == \"random\") {\n        // Randomly assign employees to chats\n        for (int j = 0; j < m; ++j) {\n            // For each chat, select participants\n            int num_participants = rnd.next(2, n); // At least 2 participants per chat\n\n            // Shuffle employees and pick num_participants of them\n            vector<int> perm(n);\n            for(int i = 0; i < n; ++i) perm[i] = i;\n            shuffle(perm.begin(), perm.end());\n\n            for (int i = 0; i < num_participants; ++i) {\n                int employee = perm[i];\n                a[employee][j] = 1;\n            }\n        }\n    } else if (type == \"sparse\") {\n        // Each chat has exactly 2 participants\n        // Assign each chat to two unique employees if possible\n\n        if (n < 2) {\n            fprintf(stderr, \"Not enough employees for 'sparse' type\\n\");\n            exit(1);\n        }\n\n        // Create a list of employees\n        vector<int> employees(n);\n        for(int i = 0; i < n; ++i) employees[i] = i;\n\n        shuffle(employees.begin(), employees.end());\n\n        int idx = 0;\n        for (int j = 0; j < m; ++j) {\n            a[employees[idx % n]][j] = 1;\n            a[employees[(idx + 1) % n]][j] = 1;\n            idx += 2;\n        }\n    } else if (type == \"dense\") {\n        // Each employee participates in all chats\n        // All chats have all employees\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = 1;\n    } else if (type == \"some_empty\") {\n        // Some employees are not in any chat\n        // Some chats have minimum participants\n        if (n < 2) {\n            fprintf(stderr, \"Not enough employees for 'some_empty' type\\n\");\n            exit(1);\n        }\n        // Let's assign chats to only two employees\n        vector<int> employees(n);\n        for(int i = 0; i < n; ++i) employees[i] = i;\n\n        shuffle(employees.begin(), employees.end());\n\n        for (int j = 0; j < m; ++j) {\n            a[employees[0]][j] = 1;\n            a[employees[1]][j] = 1;\n        }\n\n        // The rest of the employees are in no chats\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Ensure that each chat has at least two participants\n    for (int j = 0; j < m; ++j) {\n        int participants = 0;\n        for (int i = 0; i < n; ++i)\n            if (a[i][j] == 1)\n                ++participants;\n        if (participants < 2) {\n            fprintf(stderr, \"Chat %d has less than 2 participants\\n\", j + 1);\n            exit(1);\n        }\n    }\n\n    // Now, generate k events\n    vector<pair<int, int> > events;\n\n    // Precompute for each employee the list of chats they are in\n    vector<vector<int> > employee_chats(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (a[i][j] == 1)\n                employee_chats[i].push_back(j);\n        }\n    }\n\n    // Build a list of employees who are in at least one chat\n    vector<int> active_employees;\n    for (int i = 0; i < n; ++i)\n        if (!employee_chats[i].empty())\n            active_employees.push_back(i);\n\n    for (int z = 0; z < k; ++z) {\n        // Randomly pick an employee who is in at least one chat\n        int emp_idx = rnd.next(0, (int)active_employees.size() - 1);\n        int emp = active_employees[emp_idx];\n\n        // Randomly pick a chat they are in\n        int chat_idx = rnd.next(0, (int)employee_chats[emp].size() - 1);\n        int chat = employee_chats[emp][chat_idx];\n\n        events.emplace_back(emp, chat);\n    }\n\n    // Output the test case\n\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output matrix a (n lines of m numbers)\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", a[i][j]);\n            if (j + 1 < m)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    // Output k events\n    for (int z = 0; z < k; ++z) {\n        int xi = events[z].first + 1; // Employee IDs are 1-based\n        int yi = events[z].second + 1; // Chat IDs are 1-based\n        printf(\"%d %d\\n\", xi, yi);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -k 1 -type random\n./gen -n 2 -m 1 -k 2 -type dense\n./gen -n 10 -m 2 -k 20 -type random\n./gen -n 100 -m 5 -k 500 -type sparse\n./gen -n 1000 -m 10 -k 10000 -type random\n./gen -n 20000 -m 10 -k 200000 -type dense\n./gen -n 20000 -m 1 -k 200000 -type random\n./gen -n 5000 -m 5 -k 50000 -type some_empty\n./gen -n 20000 -m 10 -k 200000 -type sparse\n./gen -n 2 -m 10 -k 200 -type dense\n./gen -n 15000 -m 10 -k 150000 -type random\n./gen -n 20000 -m 10 -k 200000 -type random\n./gen -n 20000 -m 2 -k 200000 -type some_empty\n./gen -n 10000 -m 10 -k 200000 -type random\n./gen -n 19999 -m 10 -k 199999 -type dense\n./gen -n 3 -m 3 -k 3 -type random\n./gen -n 2 -m 10 -k 10 -type some_empty\n./gen -n 20000 -m 1 -k 200000 -type random\n./gen -n 20000 -m 10 -k 1 -type random\n./gen -n 20000 -m 10 -k 1 -type dense\n./gen -n 20000 -m 10 -k 200000 -type random\n./gen -n 20000 -m 10 -k 200000 -type some_empty\n./gen -n 20000 -m 10 -k 200000 -type sparse\n./gen -n 20000 -m 10 -k 200000 -type dense\n./gen -n 2 -m 10 -k 1 -type sparse\n./gen -n 100 -m 10 -k 1000 -type random\n./gen -n 1000 -m 10 -k 10000 -type random\n./gen -n 1000 -m 10 -k 10000 -type some_empty\n./gen -n 1000 -m 10 -k 10000 -type sparse\n./gen -n 1000 -m 10 -k 10000 -type dense\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:20.456090",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "413/C",
      "title": "C. Jeopardy!",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 100; m ≤ min(n, 30)) — the total number of questions and the number of auction questions, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 107) — the prices of the questions. The third line contains m distinct integers bi (1 ≤ bi ≤ n) — the numbers of auction questions. Assume that the questions are numbered from 1 to n.",
      "output_spec": "OutputIn the single line, print the answer to the problem — the maximum points the R2 company can get if it plays optimally well. It is guaranteed that the answer fits into the integer 64-bit signed type.",
      "sample_tests": "ExamplesInputCopy4 11 3 7 53OutputCopy18InputCopy3 210 3 82 3OutputCopy40InputCopy2 2100 2001 2OutputCopy400",
      "description": "C. Jeopardy!\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 100; m ≤ min(n, 30)) — the total number of questions and the number of auction questions, correspondingly. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 107) — the prices of the questions. The third line contains m distinct integers bi (1 ≤ bi ≤ n) — the numbers of auction questions. Assume that the questions are numbered from 1 to n.\n\nOutputIn the single line, print the answer to the problem — the maximum points the R2 company can get if it plays optimally well. It is guaranteed that the answer fits into the integer 64-bit signed type.\n\nInputCopy4 11 3 7 53OutputCopy18InputCopy3 210 3 82 3OutputCopy40InputCopy2 2100 2001 2OutputCopy400\n\nInputCopy4 11 3 7 53\n\nOutputCopy18\n\nInputCopy3 210 3 82 3\n\nOutputCopy40\n\nInputCopy2 2100 2001 2\n\nOutputCopy400",
      "solutions": [
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces",
          "content": "Good day!Coder-Strike 2014: Round 2 will start tomorrow at Russian morning. If you want to participate, please register for the contest on the page.In much the same way as the first round, all users can take part in the competition. But this round will be usual rated round only for the second division participants. The first division participants can take part too, but for them the round will be unrated. Please, do not get upset, the next Coder-Strike round (finals) will be rated round for the first division participants.If you have any additional questions, please, ask at comments. Good luck, and see you on the contest!UPD 1. Sorry for delay, the score distribution is standard.UPD 2. The contest is over, congratulations to the winners, hope you like the problems!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11784",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 774
        },
        {
          "title": "Editorial of Coder-Strike 2014 Round 2 - Codeforces",
          "content": "413A - Data RecoveryCount min and max values in given array of length m. If the min value is less then given min or the max value is greater the given max the answer is Incorrect.Count value 0 ≤ need ≤ 2, which equals to minimal number of elements which should be added in given array so that the min value will become min and the max value will become max. Then answer is Correct if n - m ≥ need. Otherwise answer is Incorrect.413B - Spyke ChattingProcess all queries and count some values: for each employee we will count number of messages which weer sent by this employee and for each chat we will count number of messages which were sent to this chat. Then the answer for some employee equals to sum of messages sent to all chats in which he participates minus all messages sent by him to some chats.413C - Jeopardy!Firstly choose all not auction questions and answer on them. So we have only auctions. Sort them in non-decreasing order. Consider each size of suffix of auctions and answer them on their initial price and try to answer other questions by multiplying by 2.It could be explained in this way: less than the cost value, the less you need to multiply your balance by 2. Also more than the cost value more profitable to take it for initial value.413D - 2048Consider some state in your game. Note that, we should maintain the maximum suffix if values in descending order. Also, we will maintain only first k - 1 powers of two and keep in mind if have already k-th power of two or greater. In fact in violation of this order we can not use these numbers because values could only increase.So, we will count dynamic dp[i][mask][j], where i — size of considered elements, mask — mask of first k - 1 powers of two in descending order, j — do we have already the k-th power of two or greater (0 or 1). There are two possible transitions by 2 or 4. If the current element equals to 0 make both transitions.413E - Maze 2DWe will consider queries one by one. Firstly check if the one cell of the query is reachable from the second. Find all connected components. If the cells are in different connected components, the answer is -1.Otherwise assume that both cells are situated in columns with exactly one obstacle. To find the answer for such cells we should count the length of the path between these columns using array of partial sums.To count this array consider all columns from left to right and store the last type of column with exactly one obstacle (down obstacle or up obstacle). If in column j the type changes set in the cell j of the array value 1, otherwise set value 0. In this case of query the length of the path between cells equals to sum of absolute differences between column indexes and counted partial sum between these columns.If the column with the left cell has no obstacles find the nearest column with exactly one obstacle to the right. If the column with the right cell has no obstacles find the nearest column with exactly one obstacle to the left. So we get the situation considered above. Be careful if there is no columns with exactly one obstacle between given cells.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11837",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 413\\s*C"
          },
          "content_length": 3109
        }
      ],
      "code_examples": [
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces - Code 1",
          "code": "c[i] = a[b[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces - Code 2",
          "code": "1 <= i <= n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces - Code 3",
          "code": "1 <= i <= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces - Code 4",
          "code": "s1 = [l; m]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces - Code 5",
          "code": "s2 = [m+1; r]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces - Code 6",
          "code": "d[i][j] = 1 + min(s1.d[i][0] + s2.d[0][j], s1.d[i][1] + s2.d[1][j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, min(n, 30), \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 10000000, \"a\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, n, \"b\");\n    inf.readEoln();\n\n    set<int> unique_b(b.begin(), b.end());\n    ensuref((int)unique_b.size() == m, \"bi's should be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, min(n, 30), \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 10000000, \"a\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, n, \"b\");\n    inf.readEoln();\n\n    set<int> unique_b(b.begin(), b.end());\n    ensuref((int)unique_b.size() == m, \"bi's should be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, min(n, 30), \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 10000000, \"a\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, n, \"b\");\n    inf.readEoln();\n\n    set<int> unique_b(b.begin(), b.end());\n    ensuref((int)unique_b.size() == m, \"bi's should be distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure m ≤ min(n,30)\n    m = min(m, min(n, 30));\n\n    vector<int> prices(n);\n    vector<int> auctionQuestions;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            prices[i] = rnd.next(1, 10000000);\n        }\n        // Select m auction questions\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i) {\n            indices[i] = i + 1;\n        }\n        shuffle(indices.begin(), indices.end());\n        auctionQuestions = vector<int>(indices.begin(), indices.begin() + m);\n\n    } else if (type == \"min_prices\") {\n        for (int i = 0; i < n; ++i) {\n            prices[i] = 1;\n        }\n        // Select m auction questions\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i) {\n            indices[i] = i + 1;\n        }\n        shuffle(indices.begin(), indices.end());\n        auctionQuestions = vector<int>(indices.begin(), indices.begin() + m);\n\n    } else if (type == \"max_prices\") {\n        for (int i = 0; i < n; ++i) {\n            prices[i] = 10000000;\n        }\n        // Select m auction questions\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i) {\n            indices[i] = i + 1;\n        }\n        shuffle(indices.begin(), indices.end());\n        auctionQuestions = vector<int>(indices.begin(), indices.begin() + m);\n\n    } else if (type == \"minimal\") {\n        // Override n and m\n        n = 1;\n        m = 0;\n        prices = {1};\n        auctionQuestions = {};\n\n    } else if (type == \"maximal\") {\n        n = 100;\n        m = 30;\n        prices.resize(n);\n        for (int i = 0; i < n; ++i) {\n            prices[i] = 10000000;\n        }\n        // Select m auction questions\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i) {\n            indices[i] = i + 1;\n        }\n        shuffle(indices.begin(), indices.end());\n        auctionQuestions = vector<int>(indices.begin(), indices.begin() + m);\n    }\n\n    // Output n and m\n    cout << n << \" \" << m << \"\\n\";\n    // Output prices\n    for (int i = 0; i < n; ++i) {\n        cout << prices[i];\n        if (i + 1 < n) cout << \" \";\n        else cout << \"\\n\";\n    }\n    // Output auction questions\n    for (int i = 0; i < m; ++i) {\n        cout << auctionQuestions[i];\n        if (i + 1 < m) cout << \" \";\n        else cout << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure m ≤ min(n,30)\n    m = min(m, min(n, 30));\n\n    vector<int> prices(n);\n    vector<int> auctionQuestions;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            prices[i] = rnd.next(1, 10000000);\n        }\n        // Select m auction questions\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i) {\n            indices[i] = i + 1;\n        }\n        shuffle(indices.begin(), indices.end());\n        auctionQuestions = vector<int>(indices.begin(), indices.begin() + m);\n\n    } else if (type == \"min_prices\") {\n        for (int i = 0; i < n; ++i) {\n            prices[i] = 1;\n        }\n        // Select m auction questions\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i) {\n            indices[i] = i + 1;\n        }\n        shuffle(indices.begin(), indices.end());\n        auctionQuestions = vector<int>(indices.begin(), indices.begin() + m);\n\n    } else if (type == \"max_prices\") {\n        for (int i = 0; i < n; ++i) {\n            prices[i] = 10000000;\n        }\n        // Select m auction questions\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i) {\n            indices[i] = i + 1;\n        }\n        shuffle(indices.begin(), indices.end());\n        auctionQuestions = vector<int>(indices.begin(), indices.begin() + m);\n\n    } else if (type == \"minimal\") {\n        // Override n and m\n        n = 1;\n        m = 0;\n        prices = {1};\n        auctionQuestions = {};\n\n    } else if (type == \"maximal\") {\n        n = 100;\n        m = 30;\n        prices.resize(n);\n        for (int i = 0; i < n; ++i) {\n            prices[i] = 10000000;\n        }\n        // Select m auction questions\n        vector<int> indices(n);\n        for (int i = 0; i < n; ++i) {\n            indices[i] = i + 1;\n        }\n        shuffle(indices.begin(), indices.end());\n        auctionQuestions = vector<int>(indices.begin(), indices.begin() + m);\n    }\n\n    // Output n and m\n    cout << n << \" \" << m << \"\\n\";\n    // Output prices\n    for (int i = 0; i < n; ++i) {\n        cout << prices[i];\n        if (i + 1 < n) cout << \" \";\n        else cout << \"\\n\";\n    }\n    // Output auction questions\n    for (int i = 0; i < m; ++i) {\n        cout << auctionQuestions[i];\n        if (i + 1 < m) cout << \" \";\n        else cout << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 0 -type minimal\n./gen -n 1 -m 1 -type minimal\n\n./gen -n 2 -m 1 -type random\n./gen -n 2 -m 2 -type random\n\n./gen -n 10 -m 5 -type random\n./gen -n 10 -m 5 -type min_prices\n./gen -n 10 -m 5 -type max_prices\n\n./gen -n 50 -m 25 -type random\n\n./gen -n 100 -m 30 -type maximal\n\n./gen -n 100 -m 30 -type min_prices\n./gen -n 100 -m 30 -type max_prices\n./gen -n 100 -m 30 -type random\n\n./gen -n 99 -m 29 -type random\n./gen -n 99 -m 29 -type min_prices\n\n./gen -n 100 -m 0 -type random\n./gen -n 100 -m 0 -type min_prices\n\n./gen -n 100 -m 30 -type random\n\n./gen -n 50 -m 25 -type random\n./gen -n 75 -m 15 -type random\n\n./gen -n 1 -m 0 -type minimal\n./gen -n 1 -m 1 -type minimal\n\n./gen -n 100 -m 30 -type maximal\n./gen -n 99 -m 29 -type maximal\n\n./gen -n 100 -m 30 -type random\n./gen -n 1 -m 1 -type random\n\n./gen -n 100 -m 30 -type min_prices\n./gen -n 100 -m 30 -type max_prices\n\n./gen -n 50 -m 25 -type min_prices\n./gen -n 50 -m 25 -type max_prices\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:22.370269",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "413/D",
      "title": "D. 2048",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1 ≤ n ≤ 2000; 3 ≤ k ≤ 11). The next line contains sequence of n integers, each of them is either 0, or 2, or 4.",
      "output_spec": "OutputPrint a single integer — the number of ways to replace zeroes by numbers 2 or 4 to get a winning sequence. As this number can be rather large, print it modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy7 42 2 4 2 2 2 2OutputCopy1InputCopy1 30OutputCopy0InputCopy2 30 4OutputCopy1InputCopy5 42 0 0 4 4OutputCopy2",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k (1 ≤ n ≤ 2000; 3 ≤ k ≤ 11). The next line contains sequence of n integers, each of them is either 0, or 2, or 4.\n\nOutputPrint a single integer — the number of ways to replace zeroes by numbers 2 or 4 to get a winning sequence. As this number can be rather large, print it modulo 1000000007 (109 + 7).\n\nInputCopy7 42 2 4 2 2 2 2OutputCopy1InputCopy1 30OutputCopy0InputCopy2 30 4OutputCopy1InputCopy5 42 0 0 4 4OutputCopy2\n\nInputCopy7 42 2 4 2 2 2 2\n\nOutputCopy1\n\nInputCopy1 30\n\nOutputCopy0\n\nInputCopy2 30 4\n\nOutputCopy1\n\nInputCopy5 42 0 0 4 4\n\nOutputCopy2\n\nNoteConsider the first example. The beginning of the strip will look as follows: 2  →  4  →  8  →  8 2  →  8 4  →  8 4 2  →  16.To better understand the game, you can see the original game on http://gabrielecirulli.github.io/2048/. Please note that the game that is described on the strip is slightly different from the original game (when the two numbers add up in the original game, they do not keep moving). Be careful, the game is addictive, there isn't much time for the contest!",
      "solutions": [
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces",
          "content": "Good day!Coder-Strike 2014: Round 2 will start tomorrow at Russian morning. If you want to participate, please register for the contest on the page.In much the same way as the first round, all users can take part in the competition. But this round will be usual rated round only for the second division participants. The first division participants can take part too, but for them the round will be unrated. Please, do not get upset, the next Coder-Strike round (finals) will be rated round for the first division participants.If you have any additional questions, please, ask at comments. Good luck, and see you on the contest!UPD 1. Sorry for delay, the score distribution is standard.UPD 2. The contest is over, congratulations to the winners, hope you like the problems!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11784",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 774
        },
        {
          "title": "Editorial of Coder-Strike 2014 Round 2 - Codeforces",
          "content": "413A - Data RecoveryCount min and max values in given array of length m. If the min value is less then given min or the max value is greater the given max the answer is Incorrect.Count value 0 ≤ need ≤ 2, which equals to minimal number of elements which should be added in given array so that the min value will become min and the max value will become max. Then answer is Correct if n - m ≥ need. Otherwise answer is Incorrect.413B - Spyke ChattingProcess all queries and count some values: for each employee we will count number of messages which weer sent by this employee and for each chat we will count number of messages which were sent to this chat. Then the answer for some employee equals to sum of messages sent to all chats in which he participates minus all messages sent by him to some chats.413C - Jeopardy!Firstly choose all not auction questions and answer on them. So we have only auctions. Sort them in non-decreasing order. Consider each size of suffix of auctions and answer them on their initial price and try to answer other questions by multiplying by 2.It could be explained in this way: less than the cost value, the less you need to multiply your balance by 2. Also more than the cost value more profitable to take it for initial value.413D - 2048Consider some state in your game. Note that, we should maintain the maximum suffix if values in descending order. Also, we will maintain only first k - 1 powers of two and keep in mind if have already k-th power of two or greater. In fact in violation of this order we can not use these numbers because values could only increase.So, we will count dynamic dp[i][mask][j], where i — size of considered elements, mask — mask of first k - 1 powers of two in descending order, j — do we have already the k-th power of two or greater (0 or 1). There are two possible transitions by 2 or 4. If the current element equals to 0 make both transitions.413E - Maze 2DWe will consider queries one by one. Firstly check if the one cell of the query is reachable from the second. Find all connected components. If the cells are in different connected components, the answer is -1.Otherwise assume that both cells are situated in columns with exactly one obstacle. To find the answer for such cells we should count the length of the path between these columns using array of partial sums.To count this array consider all columns from left to right and store the last type of column with exactly one obstacle (down obstacle or up obstacle). If in column j the type changes set in the cell j of the array value 1, otherwise set value 0. In this case of query the length of the path between cells equals to sum of absolute differences between column indexes and counted partial sum between these columns.If the column with the left cell has no obstacles find the nearest column with exactly one obstacle to the right. If the column with the right cell has no obstacles find the nearest column with exactly one obstacle to the left. So we get the situation considered above. Be careful if there is no columns with exactly one obstacle between given cells.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11837",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 413\\s*D"
          },
          "content_length": 3109
        }
      ],
      "code_examples": [
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces - Code 1",
          "code": "c[i] = a[b[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces - Code 2",
          "code": "1 <= i <= n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces - Code 3",
          "code": "1 <= i <= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces - Code 4",
          "code": "s1 = [l; m]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces - Code 5",
          "code": "s2 = [m+1; r]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces - Code 6",
          "code": "d[i][j] = 1 + min(s1.d[i][0] + s2.d[0][j], s1.d[i][1] + s2.d[1][j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(3, 11, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 4, \"a\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ai = a[i];\n        ensuref(ai == 0 || ai == 2 || ai == 4, \"The %d-th number must be 0, 2, or 4, but it is %d\", i+1, ai);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(3, 11, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 4, \"a\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ai = a[i];\n        ensuref(ai == 0 || ai == 2 || ai == 4, \"The %d-th number must be 0, 2, or 4, but it is %d\", i+1, ai);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(3, 11, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 4, \"a\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int ai = a[i];\n        ensuref(ai == 0 || ai == 2 || ai == 4, \"The %d-th number must be 0, 2, or 4, but it is %d\", i+1, ai);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and k are within the problem constraints\n    ensure(1 <= n && n <= 2000);\n    ensure(3 <= k && k <= 11);\n\n    vector<int> seq(n);\n\n    if (type == \"all_zeros\") {\n        // All zeros\n        fill(seq.begin(), seq.end(), 0);\n    } else if (type == \"no_zeros\") {\n        // No zeros, only 2 and 4\n        for (int i = 0; i < n; ++i) {\n            seq[i] = (rnd.next(2) == 0 ? 2 : 4);\n        }\n    } else if (type == \"random\") {\n        // Random 0, 2, 4\n        for (int i = 0; i < n; ++i) {\n            int tmp = rnd.next(3);\n            if (tmp == 0)\n                seq[i] = 0;\n            else if (tmp == 1)\n                seq[i] = 2;\n            else\n                seq[i] = 4;\n        }\n    } else if (type == \"half_zeros\") {\n        // Alternating zeros and non-zeros\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                seq[i] = 0;\n            else\n                seq[i] = (rnd.next(2) == 0 ? 2 : 4);\n        }\n    } else if (type == \"maximize_ways\") {\n        // Maximize the number of ways by setting all zeros\n        fill(seq.begin(), seq.end(), 0);\n    } else if (type == \"zero_ways\") {\n        // No way to win regardless of zero replacements\n        fill(seq.begin(), seq.end(), 0);\n    } else if (type == \"one_way\") {\n        // Only one way to win\n        fill(seq.begin(), seq.end(), 0);\n        if (n > 0) {\n            seq[n - 1] = 0; // This position must be replaced appropriately\n        }\n    } else if (type == \"alternating\") {\n        // Zeros and non-zeros alternate\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                seq[i] = 0;\n            else\n                seq[i] = (rnd.next(2) == 0 ? 2 : 4);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int tmp = rnd.next(3);\n            if (tmp == 0)\n                seq[i] = 0;\n            else if (tmp == 1)\n                seq[i] = 2;\n            else\n                seq[i] = 4;\n        }\n    }\n\n    // Output the generated test case\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", seq[i]);\n        if (i != n - 1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n and k are within the problem constraints\n    ensure(1 <= n && n <= 2000);\n    ensure(3 <= k && k <= 11);\n\n    vector<int> seq(n);\n\n    if (type == \"all_zeros\") {\n        // All zeros\n        fill(seq.begin(), seq.end(), 0);\n    } else if (type == \"no_zeros\") {\n        // No zeros, only 2 and 4\n        for (int i = 0; i < n; ++i) {\n            seq[i] = (rnd.next(2) == 0 ? 2 : 4);\n        }\n    } else if (type == \"random\") {\n        // Random 0, 2, 4\n        for (int i = 0; i < n; ++i) {\n            int tmp = rnd.next(3);\n            if (tmp == 0)\n                seq[i] = 0;\n            else if (tmp == 1)\n                seq[i] = 2;\n            else\n                seq[i] = 4;\n        }\n    } else if (type == \"half_zeros\") {\n        // Alternating zeros and non-zeros\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                seq[i] = 0;\n            else\n                seq[i] = (rnd.next(2) == 0 ? 2 : 4);\n        }\n    } else if (type == \"maximize_ways\") {\n        // Maximize the number of ways by setting all zeros\n        fill(seq.begin(), seq.end(), 0);\n    } else if (type == \"zero_ways\") {\n        // No way to win regardless of zero replacements\n        fill(seq.begin(), seq.end(), 0);\n    } else if (type == \"one_way\") {\n        // Only one way to win\n        fill(seq.begin(), seq.end(), 0);\n        if (n > 0) {\n            seq[n - 1] = 0; // This position must be replaced appropriately\n        }\n    } else if (type == \"alternating\") {\n        // Zeros and non-zeros alternate\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                seq[i] = 0;\n            else\n                seq[i] = (rnd.next(2) == 0 ? 2 : 4);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int tmp = rnd.next(3);\n            if (tmp == 0)\n                seq[i] = 0;\n            else if (tmp == 1)\n                seq[i] = 2;\n            else\n                seq[i] = 4;\n        }\n    }\n\n    // Output the generated test case\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", seq[i]);\n        if (i != n - 1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 3 -type all_zeros\n./gen -n 1 -k 11 -type all_zeros\n./gen -n 2000 -k 3 -type all_zeros\n./gen -n 2000 -k 11 -type all_zeros\n\n./gen -n 1 -k 3 -type no_zeros\n./gen -n 1 -k 11 -type no_zeros\n./gen -n 2000 -k 3 -type no_zeros\n./gen -n 2000 -k 11 -type no_zeros\n\n./gen -n 1 -k 3 -type random\n./gen -n 100 -k 5 -type random\n./gen -n 500 -k 7 -type random\n./gen -n 1000 -k 9 -type random\n./gen -n 2000 -k 11 -type random\n\n./gen -n 1 -k 3 -type half_zeros\n./gen -n 100 -k 5 -type half_zeros\n./gen -n 500 -k 7 -type half_zeros\n./gen -n 1000 -k 9 -type half_zeros\n./gen -n 2000 -k 11 -type half_zeros\n\n./gen -n 1 -k 3 -type maximize_ways\n./gen -n 2000 -k 11 -type maximize_ways\n\n./gen -n 1 -k 3 -type zero_ways\n./gen -n 10 -k 11 -type zero_ways\n./gen -n 2000 -k 11 -type zero_ways\n\n./gen -n 1 -k 3 -type one_way\n./gen -n 10 -k 7 -type one_way\n./gen -n 2000 -k 11 -type one_way\n\n./gen -n 1 -k 3 -type alternating\n./gen -n 100 -k 5 -type alternating\n./gen -n 500 -k 7 -type alternating\n./gen -n 1000 -k 9 -type alternating\n./gen -n 2000 -k 11 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:24.748804",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "413/E",
      "title": "E. Maze 2D",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers, n and m (1 ≤ n ≤ 2·105; 1 ≤ m ≤ 2·105) — the width of the maze and the number of queries, correspondingly. Next two lines contain the maze. Each line contains n characters, each character equals either '.' (empty cell), or 'X' (obstacle).Each of the next m lines contains two integers vi and ui (1 ≤ vi, ui ≤ 2n) — the description of the i-th request. Numbers vi, ui mean that you need to print the value of the shortest path from the cell of the maze number vi to the cell number ui. We assume that the cells of the first line of the maze are numbered from 1 to n, from left to right, and the cells of the second line are numbered from n + 1 to 2n from left to right. It is guaranteed that both given cells are empty.",
      "output_spec": "OutputPrint m lines. In the i-th line print the answer to the i-th request — either the size of the shortest path or -1, if we can't reach the second cell from the first one.",
      "sample_tests": "ExamplesInputCopy4 7.X.....X5 11 37 71 46 14 75 7OutputCopy1405222InputCopy10 3X...X..X....X...X..X11 77 1818 10OutputCopy9-13",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers, n and m (1 ≤ n ≤ 2·105; 1 ≤ m ≤ 2·105) — the width of the maze and the number of queries, correspondingly. Next two lines contain the maze. Each line contains n characters, each character equals either '.' (empty cell), or 'X' (obstacle).Each of the next m lines contains two integers vi and ui (1 ≤ vi, ui ≤ 2n) — the description of the i-th request. Numbers vi, ui mean that you need to print the value of the shortest path from the cell of the maze number vi to the cell number ui. We assume that the cells of the first line of the maze are numbered from 1 to n, from left to right, and the cells of the second line are numbered from n + 1 to 2n from left to right. It is guaranteed that both given cells are empty.\n\nOutputPrint m lines. In the i-th line print the answer to the i-th request — either the size of the shortest path or -1, if we can't reach the second cell from the first one.\n\nInputCopy4 7.X.....X5 11 37 71 46 14 75 7OutputCopy1405222InputCopy10 3X...X..X....X...X..X11 77 1818 10OutputCopy9-13\n\nInputCopy4 7.X.....X5 11 37 71 46 14 75 7\n\nOutputCopy1405222\n\nInputCopy10 3X...X..X....X...X..X11 77 1818 10\n\nOutputCopy9-13",
      "solutions": [
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces",
          "content": "Good day!Coder-Strike 2014: Round 2 will start tomorrow at Russian morning. If you want to participate, please register for the contest on the page.In much the same way as the first round, all users can take part in the competition. But this round will be usual rated round only for the second division participants. The first division participants can take part too, but for them the round will be unrated. Please, do not get upset, the next Coder-Strike round (finals) will be rated round for the first division participants.If you have any additional questions, please, ask at comments. Good luck, and see you on the contest!UPD 1. Sorry for delay, the score distribution is standard.UPD 2. The contest is over, congratulations to the winners, hope you like the problems!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11784",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 774
        },
        {
          "title": "Editorial of Coder-Strike 2014 Round 2 - Codeforces",
          "content": "413A - Data RecoveryCount min and max values in given array of length m. If the min value is less then given min or the max value is greater the given max the answer is Incorrect.Count value 0 ≤ need ≤ 2, which equals to minimal number of elements which should be added in given array so that the min value will become min and the max value will become max. Then answer is Correct if n - m ≥ need. Otherwise answer is Incorrect.413B - Spyke ChattingProcess all queries and count some values: for each employee we will count number of messages which weer sent by this employee and for each chat we will count number of messages which were sent to this chat. Then the answer for some employee equals to sum of messages sent to all chats in which he participates minus all messages sent by him to some chats.413C - Jeopardy!Firstly choose all not auction questions and answer on them. So we have only auctions. Sort them in non-decreasing order. Consider each size of suffix of auctions and answer them on their initial price and try to answer other questions by multiplying by 2.It could be explained in this way: less than the cost value, the less you need to multiply your balance by 2. Also more than the cost value more profitable to take it for initial value.413D - 2048Consider some state in your game. Note that, we should maintain the maximum suffix if values in descending order. Also, we will maintain only first k - 1 powers of two and keep in mind if have already k-th power of two or greater. In fact in violation of this order we can not use these numbers because values could only increase.So, we will count dynamic dp[i][mask][j], where i — size of considered elements, mask — mask of first k - 1 powers of two in descending order, j — do we have already the k-th power of two or greater (0 or 1). There are two possible transitions by 2 or 4. If the current element equals to 0 make both transitions.413E - Maze 2DWe will consider queries one by one. Firstly check if the one cell of the query is reachable from the second. Find all connected components. If the cells are in different connected components, the answer is -1.Otherwise assume that both cells are situated in columns with exactly one obstacle. To find the answer for such cells we should count the length of the path between these columns using array of partial sums.To count this array consider all columns from left to right and store the last type of column with exactly one obstacle (down obstacle or up obstacle). If in column j the type changes set in the cell j of the array value 1, otherwise set value 0. In this case of query the length of the path between cells equals to sum of absolute differences between column indexes and counted partial sum between these columns.If the column with the left cell has no obstacles find the nearest column with exactly one obstacle to the right. If the column with the right cell has no obstacles find the nearest column with exactly one obstacle to the left. So we get the situation considered above. Be careful if there is no columns with exactly one obstacle between given cells.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11837",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 413\\s*E"
          },
          "content_length": 3109
        }
      ],
      "code_examples": [
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces - Code 1",
          "code": "c[i] = a[b[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces - Code 2",
          "code": "1 <= i <= n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces - Code 3",
          "code": "1 <= i <= m",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces - Code 4",
          "code": "s1 = [l; m]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces - Code 5",
          "code": "s2 = [m+1; r]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        },
        {
          "title": "Coder-Strike 2014: Round 2 - Codeforces - Code 6",
          "code": "d[i][j] = 1 + min(s1.d[i][0] + s2.d[0][j], s1.d[i][1] + s2.d[1][j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11784",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[.X]{\" + to_string(n) + \"}\";\n    string s1 = inf.readLine(pattern, \"maze_row_1\");\n    string s2 = inf.readLine(pattern, \"maze_row_2\");\n\n    vector<bool> isEmpty(2 * n + 1, false);\n    for (int i = 1; i <= n; ++i) {\n        isEmpty[i] = (s1[i - 1] == '.');\n    }\n    for (int i = n + 1; i <= 2 * n; ++i) {\n        isEmpty[i] = (s2[i - n - 1] == '.');\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int vi = inf.readInt(1, 2 * n);\n        inf.readSpace();\n        int ui = inf.readInt(1, 2 * n);\n        inf.readEoln();\n\n        ensuref(isEmpty[vi], \"Cell %d is not empty\", vi);\n        ensuref(isEmpty[ui], \"Cell %d is not empty\", ui);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[.X]{\" + to_string(n) + \"}\";\n    string s1 = inf.readLine(pattern, \"maze_row_1\");\n    string s2 = inf.readLine(pattern, \"maze_row_2\");\n\n    vector<bool> isEmpty(2 * n + 1, false);\n    for (int i = 1; i <= n; ++i) {\n        isEmpty[i] = (s1[i - 1] == '.');\n    }\n    for (int i = n + 1; i <= 2 * n; ++i) {\n        isEmpty[i] = (s2[i - n - 1] == '.');\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int vi = inf.readInt(1, 2 * n);\n        inf.readSpace();\n        int ui = inf.readInt(1, 2 * n);\n        inf.readEoln();\n\n        ensuref(isEmpty[vi], \"Cell %d is not empty\", vi);\n        ensuref(isEmpty[ui], \"Cell %d is not empty\", ui);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[.X]{\" + to_string(n) + \"}\";\n    string s1 = inf.readLine(pattern, \"maze_row_1\");\n    string s2 = inf.readLine(pattern, \"maze_row_2\");\n\n    vector<bool> isEmpty(2 * n + 1, false);\n    for (int i = 1; i <= n; ++i) {\n        isEmpty[i] = (s1[i - 1] == '.');\n    }\n    for (int i = n + 1; i <= 2 * n; ++i) {\n        isEmpty[i] = (s2[i - n - 1] == '.');\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int vi = inf.readInt(1, 2 * n);\n        inf.readSpace();\n        int ui = inf.readInt(1, 2 * n);\n        inf.readEoln();\n\n        ensuref(isEmpty[vi], \"Cell %d is not empty\", vi);\n        ensuref(isEmpty[ui], \"Cell %d is not empty\", ui);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Get parameters from command line\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string maze_type = opt<string>(\"maze_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate maze according to maze_type\n    vector<string> maze(2, string(n, '.'));\n\n    if (maze_type == \"empty\") {\n        // All cells are empty\n        // Do nothing, maze is already initialized to '.'\n    } else if (maze_type == \"full\") {\n        // All cells are obstacles\n        for (int i = 0; i < 2; ++i)\n            maze[i] = string(n, 'X');\n    } else if (maze_type == \"random\") {\n        // Random obstacles\n        for (int i = 0; i < 2; ++i)\n            for (int j = 0; j < n; ++j)\n                maze[i][j] = (rnd.next(0, 1) ? '.' : 'X');\n    } else if (maze_type == \"half-blocked\") {\n        // One row is blocked\n        maze[0] = string(n, 'X'); // First row blocked\n        maze[1] = string(n, '.'); // Second row empty\n    } else if (maze_type == \"checkerboard\") {\n        // Checkerboard pattern\n        for (int i = 0; i < 2; ++i)\n            for (int j = 0; j < n; ++j)\n                maze[i][j] = ((i + j) % 2 == 0) ? '.' : 'X';\n    }\n\n    // Generate queries according to query_type\n    vector<pair<int, int>> queries(m);\n\n    vector<int> empty_cells;\n    // Collect the indices of empty cells\n    for (int i = 0; i < 2; ++i)\n        for (int j = 0; j < n; ++j)\n            if (maze[i][j] == '.')\n                empty_cells.push_back(i * n + j + 1);\n\n    // Ensure there is at least one empty cell\n    if (empty_cells.empty()) {\n        maze[0][0] = '.';\n        empty_cells.push_back(1);\n    }\n\n    if (query_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int v = rnd.any(empty_cells);\n            int u = rnd.any(empty_cells);\n            queries[i] = make_pair(v, u);\n        }\n    } else if (query_type == \"same_cell\") {\n        for (int i = 0; i < m; ++i) {\n            int v = rnd.any(empty_cells);\n            queries[i] = make_pair(v, v);\n        }\n    } else if (query_type == \"max_distance\") {\n        int v = empty_cells.front();\n        int u = empty_cells.back();\n        for (int i = 0; i < m; ++i) {\n            queries[i] = make_pair(v, u);\n        }\n    } else if (query_type == \"unreachable\") {\n        int total_cells = 2 * n;\n        vector<vector<int>> adj(total_cells + 1);\n        for (int i = 0; i < 2; ++i)\n            for (int j = 0; j < n; ++j) {\n                if (maze[i][j] == '.') {\n                    int curr = i * n + j + 1;\n                    if (i > 0 && maze[i - 1][j] == '.') {\n                        int up = (i - 1) * n + j + 1;\n                        adj[curr].push_back(up);\n                    }\n                    if (i < 1 && maze[i + 1][j] == '.') {\n                        int down = (i + 1) * n + j + 1;\n                        adj[curr].push_back(down);\n                    }\n                    if (j > 0 && maze[i][j - 1] == '.') {\n                        int left = i * n + (j - 1) + 1;\n                        adj[curr].push_back(left);\n                    }\n                    if (j < n - 1 && maze[i][j + 1] == '.') {\n                        int right = i * n + (j + 1) + 1;\n                        adj[curr].push_back(right);\n                    }\n                }\n            }\n        vector<int> component(total_cells + 1, 0);\n        int comp_id = 0;\n        for (int cell : empty_cells) {\n            if (component[cell] == 0) {\n                ++comp_id;\n                queue<int> q;\n                q.push(cell);\n                component[cell] = comp_id;\n                while (!q.empty()) {\n                    int curr = q.front(); q.pop();\n                    for (int neighbor : adj[curr]) {\n                        if (component[neighbor] == 0) {\n                            component[neighbor] = comp_id;\n                            q.push(neighbor);\n                        }\n                    }\n                }\n            }\n        }\n        if (comp_id < 2) {\n            // Adjust the maze to create at least two components\n            int mid_col = n / 2;\n            for (int i = 0; i < 2; ++i)\n                maze[i][mid_col] = 'X';\n            // Rebuild empty_cells and adj\n            adj.clear();\n            adj.resize(total_cells + 1);\n            empty_cells.clear();\n            for (int i = 0; i < 2; ++i)\n                for (int j = 0; j < n; ++j) {\n                    if (maze[i][j] == '.') {\n                        int curr = i * n + j + 1;\n                        empty_cells.push_back(curr);\n                        if (i > 0 && maze[i - 1][j] == '.') {\n                            int up = (i - 1) * n + j + 1;\n                            adj[curr].push_back(up);\n                        }\n                        if (i < 1 && maze[i + 1][j] == '.') {\n                            int down = (i + 1) * n + j + 1;\n                            adj[curr].push_back(down);\n                        }\n                        if (j > 0 && maze[i][j - 1] == '.') {\n                            int left = i * n + (j - 1) + 1;\n                            adj[curr].push_back(left);\n                        }\n                        if (j < n - 1 && maze[i][j + 1] == '.') {\n                            int right = i * n + (j + 1) + 1;\n                            adj[curr].push_back(right);\n                        }\n                    }\n                }\n            component.assign(total_cells + 1, 0);\n            comp_id = 0;\n            for (int cell : empty_cells) {\n                if (component[cell] == 0) {\n                    ++comp_id;\n                    queue<int> q;\n                    q.push(cell);\n                    component[cell] = comp_id;\n                    while (!q.empty()) {\n                        int curr = q.front(); q.pop();\n                        for (int neighbor : adj[curr]) {\n                            if (component[neighbor] == 0) {\n                                component[neighbor] = comp_id;\n                                q.push(neighbor);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        vector<int> cells_in_comp1, cells_in_comp2;\n        for (int cell : empty_cells) {\n            if (component[cell] == 1)\n                cells_in_comp1.push_back(cell);\n            else\n                cells_in_comp2.push_back(cell);\n        }\n        if (!cells_in_comp2.empty()) {\n            for (int i = 0; i < m; ++i) {\n                int v = rnd.any(cells_in_comp1);\n                int u = rnd.any(cells_in_comp2);\n                queries[i] = make_pair(v, u);\n            }\n        } else {\n            for (int i = 0; i < m; ++i) {\n                int v = rnd.any(empty_cells);\n                int u = rnd.any(empty_cells);\n                queries[i] = make_pair(v, u);\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the maze\n    printf(\"%s\\n%s\\n\", maze[0].c_str(), maze[1].c_str());\n    // Output the queries\n    for (int i = 0; i < m; ++i)\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Get parameters from command line\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string maze_type = opt<string>(\"maze_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate maze according to maze_type\n    vector<string> maze(2, string(n, '.'));\n\n    if (maze_type == \"empty\") {\n        // All cells are empty\n        // Do nothing, maze is already initialized to '.'\n    } else if (maze_type == \"full\") {\n        // All cells are obstacles\n        for (int i = 0; i < 2; ++i)\n            maze[i] = string(n, 'X');\n    } else if (maze_type == \"random\") {\n        // Random obstacles\n        for (int i = 0; i < 2; ++i)\n            for (int j = 0; j < n; ++j)\n                maze[i][j] = (rnd.next(0, 1) ? '.' : 'X');\n    } else if (maze_type == \"half-blocked\") {\n        // One row is blocked\n        maze[0] = string(n, 'X'); // First row blocked\n        maze[1] = string(n, '.'); // Second row empty\n    } else if (maze_type == \"checkerboard\") {\n        // Checkerboard pattern\n        for (int i = 0; i < 2; ++i)\n            for (int j = 0; j < n; ++j)\n                maze[i][j] = ((i + j) % 2 == 0) ? '.' : 'X';\n    }\n\n    // Generate queries according to query_type\n    vector<pair<int, int>> queries(m);\n\n    vector<int> empty_cells;\n    // Collect the indices of empty cells\n    for (int i = 0; i < 2; ++i)\n        for (int j = 0; j < n; ++j)\n            if (maze[i][j] == '.')\n                empty_cells.push_back(i * n + j + 1);\n\n    // Ensure there is at least one empty cell\n    if (empty_cells.empty()) {\n        maze[0][0] = '.';\n        empty_cells.push_back(1);\n    }\n\n    if (query_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int v = rnd.any(empty_cells);\n            int u = rnd.any(empty_cells);\n            queries[i] = make_pair(v, u);\n        }\n    } else if (query_type == \"same_cell\") {\n        for (int i = 0; i < m; ++i) {\n            int v = rnd.any(empty_cells);\n            queries[i] = make_pair(v, v);\n        }\n    } else if (query_type == \"max_distance\") {\n        int v = empty_cells.front();\n        int u = empty_cells.back();\n        for (int i = 0; i < m; ++i) {\n            queries[i] = make_pair(v, u);\n        }\n    } else if (query_type == \"unreachable\") {\n        int total_cells = 2 * n;\n        vector<vector<int>> adj(total_cells + 1);\n        for (int i = 0; i < 2; ++i)\n            for (int j = 0; j < n; ++j) {\n                if (maze[i][j] == '.') {\n                    int curr = i * n + j + 1;\n                    if (i > 0 && maze[i - 1][j] == '.') {\n                        int up = (i - 1) * n + j + 1;\n                        adj[curr].push_back(up);\n                    }\n                    if (i < 1 && maze[i + 1][j] == '.') {\n                        int down = (i + 1) * n + j + 1;\n                        adj[curr].push_back(down);\n                    }\n                    if (j > 0 && maze[i][j - 1] == '.') {\n                        int left = i * n + (j - 1) + 1;\n                        adj[curr].push_back(left);\n                    }\n                    if (j < n - 1 && maze[i][j + 1] == '.') {\n                        int right = i * n + (j + 1) + 1;\n                        adj[curr].push_back(right);\n                    }\n                }\n            }\n        vector<int> component(total_cells + 1, 0);\n        int comp_id = 0;\n        for (int cell : empty_cells) {\n            if (component[cell] == 0) {\n                ++comp_id;\n                queue<int> q;\n                q.push(cell);\n                component[cell] = comp_id;\n                while (!q.empty()) {\n                    int curr = q.front(); q.pop();\n                    for (int neighbor : adj[curr]) {\n                        if (component[neighbor] == 0) {\n                            component[neighbor] = comp_id;\n                            q.push(neighbor);\n                        }\n                    }\n                }\n            }\n        }\n        if (comp_id < 2) {\n            // Adjust the maze to create at least two components\n            int mid_col = n / 2;\n            for (int i = 0; i < 2; ++i)\n                maze[i][mid_col] = 'X';\n            // Rebuild empty_cells and adj\n            adj.clear();\n            adj.resize(total_cells + 1);\n            empty_cells.clear();\n            for (int i = 0; i < 2; ++i)\n                for (int j = 0; j < n; ++j) {\n                    if (maze[i][j] == '.') {\n                        int curr = i * n + j + 1;\n                        empty_cells.push_back(curr);\n                        if (i > 0 && maze[i - 1][j] == '.') {\n                            int up = (i - 1) * n + j + 1;\n                            adj[curr].push_back(up);\n                        }\n                        if (i < 1 && maze[i + 1][j] == '.') {\n                            int down = (i + 1) * n + j + 1;\n                            adj[curr].push_back(down);\n                        }\n                        if (j > 0 && maze[i][j - 1] == '.') {\n                            int left = i * n + (j - 1) + 1;\n                            adj[curr].push_back(left);\n                        }\n                        if (j < n - 1 && maze[i][j + 1] == '.') {\n                            int right = i * n + (j + 1) + 1;\n                            adj[curr].push_back(right);\n                        }\n                    }\n                }\n            component.assign(total_cells + 1, 0);\n            comp_id = 0;\n            for (int cell : empty_cells) {\n                if (component[cell] == 0) {\n                    ++comp_id;\n                    queue<int> q;\n                    q.push(cell);\n                    component[cell] = comp_id;\n                    while (!q.empty()) {\n                        int curr = q.front(); q.pop();\n                        for (int neighbor : adj[curr]) {\n                            if (component[neighbor] == 0) {\n                                component[neighbor] = comp_id;\n                                q.push(neighbor);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        vector<int> cells_in_comp1, cells_in_comp2;\n        for (int cell : empty_cells) {\n            if (component[cell] == 1)\n                cells_in_comp1.push_back(cell);\n            else\n                cells_in_comp2.push_back(cell);\n        }\n        if (!cells_in_comp2.empty()) {\n            for (int i = 0; i < m; ++i) {\n                int v = rnd.any(cells_in_comp1);\n                int u = rnd.any(cells_in_comp2);\n                queries[i] = make_pair(v, u);\n            }\n        } else {\n            for (int i = 0; i < m; ++i) {\n                int v = rnd.any(empty_cells);\n                int u = rnd.any(empty_cells);\n                queries[i] = make_pair(v, u);\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the maze\n    printf(\"%s\\n%s\\n\", maze[0].c_str(), maze[1].c_str());\n    // Output the queries\n    for (int i = 0; i < m; ++i)\n        printf(\"%d %d\\n\", queries[i].first, queries[i].second);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 3 -maze_type empty -query_type random\n./gen -n 5 -m 3 -maze_type full -query_type random\n./gen -n 5 -m 3 -maze_type random -query_type random\n./gen -n 5 -m 3 -maze_type half-blocked -query_type random\n./gen -n 5 -m 3 -maze_type checkerboard -query_type random\n\n./gen -n 5 -m 3 -maze_type empty -query_type same_cell\n./gen -n 5 -m 3 -maze_type random -query_type same_cell\n\n./gen -n 5 -m 3 -maze_type empty -query_type max_distance\n./gen -n 5 -m 3 -maze_type random -query_type max_distance\n\n./gen -n 5 -m 3 -maze_type half-blocked -query_type unreachable\n./gen -n 5 -m 3 -maze_type checkerboard -query_type unreachable\n\n./gen -n 100000 -m 100000 -maze_type empty -query_type random\n./gen -n 100000 -m 100000 -maze_type random -query_type random\n./gen -n 100000 -m 100000 -maze_type half-blocked -query_type random\n\n./gen -n 100000 -m 100000 -maze_type empty -query_type same_cell\n./gen -n 100000 -m 100000 -maze_type random -query_type max_distance\n./gen -n 100000 -m 100000 -maze_type random -query_type unreachable\n\n./gen -n 100000 -m 100000 -maze_type full -query_type random\n\n./gen -n 1 -m 200000 -maze_type empty -query_type random\n./gen -n 200000 -m 1 -maze_type checkerboard -query_type random\n\n./gen -n 100000 -m 1 -maze_type full -query_type same_cell\n\n./gen -n 1000 -m 1000 -maze_type empty -query_type random\n./gen -n 1000 -m 1000 -maze_type random -query_type random\n./gen -n 1000 -m 1000 -maze_type half-blocked -query_type random\n./gen -n 1000 -m 1000 -maze_type checkerboard -query_type random\n\n./gen -n 1000 -m 1000 -maze_type random -query_type unreachable\n./gen -n 1000 -m 1000 -maze_type random -query_type same_cell\n./gen -n 1000 -m 1000 -maze_type random -query_type max_distance\n\n./gen -n 2 -m 5 -maze_type empty -query_type random\n./gen -n 2 -m 5 -maze_type full -query_type random\n./gen -n 2 -m 5 -maze_type random -query_type random\n\n./gen -n 50000 -m 100000 -maze_type half-blocked -query_type unreachable\n./gen -n 50000 -m 100000 -maze_type checkerboard -query_type unreachable\n\n./gen -n 200000 -m 200000 -maze_type empty -query_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:26.853145",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "414/A",
      "title": "A. Машмох и числа",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа через пробел: n, k (1 ≤ n ≤ 105; 0 ≤ k ≤ 108).",
      "output_spec": "Выходные данныеЕсли требуемая последовательность не существует, выведите -1. В противном случае, выведите n различных целых чисел через пробел a1, a2, ..., an (1 ≤ ai ≤ 109).",
      "sample_tests": "ПримерыВходные данныеСкопировать5 2Выходные данныеСкопировать1 2 3 4 5Входные данныеСкопировать5 3Выходные данныеСкопировать2 4 3 7 1Входные данныеСкопировать7 2Выходные данныеСкопировать-1",
      "description": "A. Машмох и числа\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа через пробел: n, k (1 ≤ n ≤ 105; 0 ≤ k ≤ 108).\n\nВходные данные\n\nВыходные данныеЕсли требуемая последовательность не существует, выведите -1. В противном случае, выведите n различных целых чисел через пробел a1, a2, ..., an (1 ≤ ai ≤ 109).\n\nВыходные данные\n\nВходные данныеСкопировать5 2Выходные данныеСкопировать1 2 3 4 5Входные данныеСкопировать5 3Выходные данныеСкопировать2 4 3 7 1Входные данныеСкопировать7 2Выходные данныеСкопировать-1\n\nВходные данныеСкопировать5 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 2 3 4 5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 4 3 7 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеgcd(x, y) — это наибольший общий делитель чисел x и y.",
      "solutions": [
        {
          "title": "Codeforces Round #240 - Codeforces",
          "content": "Всем привет!Завтра в 19:30 MSK состоится Codeforces Round #240.Это наш первый раунд на Codeforces и мы надеемся, что он вам понравится. Задачи были подготовлены авторами: Amir Keivan Mohtashami (matrix), Farbod Yadegarian (FarbodY) и Gerald Agapov (Gerald).Традиционно благодарю MikeMirzayanov за системы Polygon и Codeforces, а также Maria Belova (Delinur) за перевод задач.Желаем вам хорошего и интересного раунда.Удачи!Как обычно, распределение баллов по задачам будет анонсировано перед началом контеста!Распределение баллов:div1: 500 — 1000 — 1500 — 1500 — 2500div2: 500 — 1000 — 1500 — 2000 — 2500 (стандарт)UPD: Поздравляю победителей!Div 1: fqw sankear (Единственный, кто решил задачу E во время контеста) Egor qwerty787788 hos.lyric Div 2: jzzhu SJTU_WengJian alcot LoveEvita huyifei NiuYiqiang Статистика по раунду, подготовленная DmitriyH, находится здесь. Английский разбор можно прочитать здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11458",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 908
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces",
          "content": "Hi!415A - Mashmokh and LightsFor this problem for each light j you could just iterate over all pressed buttons and find the first button bi that bi < j. Then you could output bi and move to next light.  415B - Mashmokh and TokensFor this problem you can find the number of tokens you can save if you initally have k tokens in O(1). Then you can calculate the answer for all of numbers in O(n). Suppose by p. then p * b ≤ w * a. then . Suppose initially we have k tokens. Let then we need to find such maximum k0 that .So k0 will be equal to . so we can calculate k0 in O(1).414A - Mashmokh and NumbersIn each turn Bimokh will at least get one point so the result is at lease . So if the answer is -1. Let's denote . Then you could output x and 2x as the first two integers in the sequence then output consecutive integers and also one random integer(distinct from the others) if n is odd. Based on the following fact, Bimokh's point will equal to which is equal to k.. Also you must consider some corner cases such as when n = 1.414B - Mashmokh and ACMLets define dp[i][j] as number of good sequences of length i that ends in j.Let's denote divisors of j by x1, x2, ..., xl. Then This yields O(nk sqrt(n)) solution which is not fast enough. But one could use the fact that the following loops run in O(n log(n)) in order to achieve O(nk log(n)) which is fast enough to pass the tests. for (i = 1; i <= n; i++) //loop from 1 to n\n for (int j = i; j <= n; j += i) //iterating through all multiples of i that are at most n414C - Mashmokh and Reverse OperationBuild a complete binary tree with height n. So its i-th leaf corresponds to i-th element of the initial array. For each vertex v lets define its subarray as the subarray containing the elements that have a leaf corresponding to them in subtree rooted at v.For each non-leaf vertex v, suppose its left child's subarray contains elements [a..b] of the array and its right child contains elements [b + 1..c] of the array. We'll calculate two numbers for this vertex. number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai > bj and number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai < bj. We'll call the first calculated number, normal number and the other one reverse number. Calculating these numbers can be done using merge-sort algorithm in O(n  *  2n). We'll Initially write normal number for each vertex on it. We'll define a vertex's type as type of the number that is written on them. Let's define height of a vertex v equal to its distnace to the nearest leaf. Also let's define switching a vertex as switching the number written on it with the other type number(if normal number is written on it change it to reverse number and vise-versa).Initially sum of writed numbers is equal to number of inversions in the initial array. Now when query h is given, by switching all vertices with height at most h, the sum of writed numbers will become equal to the number of inversions in the new array. The only question is how to perform such query fast? One can notice that in a height h, always all of the vertices has the same type. So we can calculate two numbers for each height h. The sum of normal numbers of vertices with height h and the sum of their reverse numbers. Then instead of switching vertices in a height one by one each time, one can just switch the number for that height. The sum of numbers of heights after each query will be the answer for that query. since there are n height each query can be performed in O(n) so the total running time will be O(nq  +  n  * 2n). 414D - Mashmokh and Water TanksLet's suppose instead of a tank there is a pile at each vertex and instead of water the game is played on tiles. Let's denote distance of each vertex q from the root by depth(q). Also Let's label each tile with number of the vertex it was initially put on. Suppose initially there was a tile at each of vertices v and u and after some move tile u and v are in the same vertex's pile. Then one can prove that there were exactly |depth(v) - depth(u)| moves at which vertex containing the tile at vertex with less depth was closed and the vertex containing the other tile wasn't. Suppose after i-th move, there was xi tiles inside the root's pile and xj is the maximum among these numbers. Suppose tiles a1, a2, ...axj were on the root after j-th move. Then the other tiles that we put inside the tree at the beginning have no effect in the final result. Then we can suppose that only these tiles were initially put on tree.So we can assume that all tiles we place at the beginning will reach to the root together. Suppose hi of these tiles were put at a vertex with depth i and d1 is the maximum depth that there is at least a tile in that depth. So as to these tiles reach to the root together we must pay . Then we want to minimize the number of needed coins so at the beginning there must not be two consecutive depth i and i + 1 that i + 1 ≤ d and there is a tile at depth i and an empty vertex at depth i + 1. In other words if we denote the minimum depth that initially there is a tile inside it as d0 then there must be a tile at each vertex with depth more than d0 and less than or equal to d1. Let's iterate over d1. Then for each d1 we can calculate d2, the minimum depth that we can pay the needed price if we put a tile at each vertex with depth at least d2 and at most d1. Let's denote this needed price as p0. Then we can also put at depth d2 - 1. So we can calculate maximum number of tiles that we can put on the tree so that they all reach to root together for a fixed d1. So the maximum of these numbers for all possible d1 will be the answer.Since by increasing d1, d2 won't decrease one can use two-pointers to update d2 while iterating over d1. Let's denote number of the vertices with depth i as cnti. Then we can save and update the following values.Then the needed price is equal to (d1 * s) - t. So as long as (d1 * s) - t > p we must increase d2. This yields an O(n) solution.414E - Mashmokh's Designed ProblemLet's define the dfs-order of a tree as the sequence created by calling function dfs(root). We'll build another sequence from a dfs-order by replacing each vertex in dfs-order by '+1' and inserting a '-1' after the last vertex of its subtree. Note that all vertices of a particular subtree are a continuous part of dfs-order of that tree. Also note that for each vertex v if the +1 corresponding to it is the i-th element of sequence, then v's distance from root(which we'll denote by height of v) is equal to sum of elements 1..i.Suppose we can perform the following operations on such sequence: For each i, find sum of the elements 1..i. For each i find the biggest j(j < i) so that sum of elements 1..j of the sequence equals p. Using these two operations we can find LCA of two vertices v and u, so since distance of u and v equals to height(u) + height(v) - 2 * height(LCA(u, v)) we can answer the second query. Also the third query can be answered using the second operation described above.As for the first query it cuts a continuous part of sequence and insert it in another place. This operation can be done using implicit treap. Also we can use the treap as a segment tree to store the following values for each vertex v. Then using these values the operations described above can be done. All of these operation can be done in O(logn). Sum of the elements in its subtree(each vertex in the treap has a value equal to +1 or -1 since it corresponds to an element of the sequence.) Let's write the values of each vertex in the subtree of v in the order they appear in the sequence. Then lets denote sum of the first i numbers we wrote as ps[i] and call elements of ps, prefix sums of the subtree of v. Then we store the maximum number amongst the prefix sums. Also we'll store the minimum number amongst prefix sums.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11470",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 414\\s*A"
          },
          "content_length": 7826
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #240 - Codeforces - Code 1",
          "code": "// cout << a/2\nint a = 6; int b = 1; \nwhile( b <= a && 2*b < a ) ++b;\ncout << b;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 2",
          "code": "// cout << a/2\nint a = 6; int b = 1; \nwhile( b <= a && 2*b < a ) ++b;\ncout << b;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 3",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 4",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 5",
          "code": "for(int i=1;i<=n;i++)\nfor(int j=1;j*i<=n;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 6",
          "code": "for(int i=1;i<=n;i++)\nfor(int j=1;j*i<=n;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 7",
          "code": "dp[i][j] = dp[i+1][j] + dp[i+1][2*j] + ... + dp[i+1][n/j*j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 8",
          "code": "dp[n][x] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 1",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 2",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 3",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 4",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 5",
          "code": "((a*x) % b) / a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 6",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 7",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 8",
          "code": "((x * A) % B)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 9",
          "code": "number of inversion after reverse = N(N-1)/2 - number of inversion before reverse - number of pair of same element",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 10",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 11",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 12",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 13",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, 100000, \"n\");\n    k = inf.readInt(0, 100000000, \"k\");\n\n    int participant_first_int = ouf.readInt(-1, 1000000000, \"participant_first_int\");\n    if (participant_first_int == -1) {\n        // Participant outputs -1, claims no solution exists\n        int jury_first_int = ans.readInt(-1, 1000000000, \"jury_first_int\");\n        if (jury_first_int == -1) {\n            quitf(_ok, \"Participant and jury both claim no solution exists.\");\n        } else {\n            quitf(_wa, \"Participant claims no solution exists, but jury has a solution.\");\n        }\n    } else {\n        // Participant outputs a sequence\n        vector<int> seq;\n        seq.push_back(participant_first_int);\n        if (n == 1) {\n            // n == 1, no more integers to read\n        } else {\n            vector<int> rest_participant_ints = ouf.readInts(n - 1, 1, 1000000000, \"participant_sequence\");\n            seq.insert(seq.end(), rest_participant_ints.begin(), rest_participant_ints.end());\n        }\n\n        // Validate that all integers are distinct\n        set<int> s(seq.begin(), seq.end());\n        if ((int)s.size() != n) {\n            quitf(_wa, \"Integers are not distinct.\");\n        }\n\n        // Simulate the game\n        int total_points = 0;\n        int sz = n;\n        for (int i = 0; i + 1 < n; i += 2) {\n            int x = seq[i];\n            int y = seq[i + 1];\n            int g = __gcd(x, y);\n            total_points += g;\n        }\n\n        if (total_points != k) {\n            quitf(_wa, \"Total points %d do not equal k = %d.\", total_points, k);\n        } else {\n            // Participant's answer is correct\n            quitf(_ok, \"Participant's answer is correct. Total points = %d.\", total_points);\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"possible\");\n\n    int m = n / 2; // Number of pairs\n\n    // Compute minimal and maximal possible total points\n    int min_k = m * 1; // Minimal total points if gcd in each pair is 1\n    int max_gcd_per_pair = 500000000; // Maximum possible gcd per pair\n    int max_k = m * max_gcd_per_pair;\n    if (max_k > 100000000) max_k = 100000000; // Cap max_k at 1e8\n\n    if (k == -1) {\n        // k not provided, need to generate k based on type\n        if (type == \"possible\") {\n            // Generate a k such that a solution exists\n            // Pick k in [min_k, max_k]\n            if (min_k <= max_k) {\n                k = rnd.next(min_k, max_k);\n            } else {\n                // If min_k > max_k, it's impossible to have a valid k\n                // So we'll output -1 in this case\n                k = min_k; // Just set k to min_k\n            }\n        } else if (type == \"impossible\") {\n            // Generate a k such that no solution exists\n            // Pick k outside [min_k, max_k]\n            if (min_k <= max_k) {\n                if (rnd.next(2)) {\n                    // k less than min_k (if min_k > 0)\n                    if (min_k > 0) {\n                        k = rnd.next(0, min_k - 1);\n                    } else {\n                        // If min_k == 0, set k greater than max_k\n                        k = max_k + rnd.next(1, 100000000);\n                        if (k > 100000000) k = 100000000;\n                    }\n                } else {\n                    // k greater than max_k\n                    k = max_k + rnd.next(1, 100000000);\n                    if (k > 100000000) k = 100000000;\n                }\n            } else {\n                // No valid k exists, pick any k within constraints\n                k = rnd.next(0, 100000000);\n            }\n        } else if (type == \"random\") {\n            // Generate random k between 0 and 1e8\n            k = rnd.next(0, 100000000);\n        } else {\n            // Default, generate possible k\n            if (min_k <= max_k) {\n                k = rnd.next(min_k, max_k);\n            } else {\n                k = min_k;\n            }\n        }\n    }\n    // Ensure k is within 0 ≤ k ≤ 1e8\n    if (k < 0) k = 0;\n    if (k > 100000000) k = 100000000;\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"possible\");\n\n    int m = n / 2; // Number of pairs\n\n    // Compute minimal and maximal possible total points\n    int min_k = m * 1; // Minimal total points if gcd in each pair is 1\n    int max_gcd_per_pair = 500000000; // Maximum possible gcd per pair\n    int max_k = m * max_gcd_per_pair;\n    if (max_k > 100000000) max_k = 100000000; // Cap max_k at 1e8\n\n    if (k == -1) {\n        // k not provided, need to generate k based on type\n        if (type == \"possible\") {\n            // Generate a k such that a solution exists\n            // Pick k in [min_k, max_k]\n            if (min_k <= max_k) {\n                k = rnd.next(min_k, max_k);\n            } else {\n                // If min_k > max_k, it's impossible to have a valid k\n                // So we'll output -1 in this case\n                k = min_k; // Just set k to min_k\n            }\n        } else if (type == \"impossible\") {\n            // Generate a k such that no solution exists\n            // Pick k outside [min_k, max_k]\n            if (min_k <= max_k) {\n                if (rnd.next(2)) {\n                    // k less than min_k (if min_k > 0)\n                    if (min_k > 0) {\n                        k = rnd.next(0, min_k - 1);\n                    } else {\n                        // If min_k == 0, set k greater than max_k\n                        k = max_k + rnd.next(1, 100000000);\n                        if (k > 100000000) k = 100000000;\n                    }\n                } else {\n                    // k greater than max_k\n                    k = max_k + rnd.next(1, 100000000);\n                    if (k > 100000000) k = 100000000;\n                }\n            } else {\n                // No valid k exists, pick any k within constraints\n                k = rnd.next(0, 100000000);\n            }\n        } else if (type == \"random\") {\n            // Generate random k between 0 and 1e8\n            k = rnd.next(0, 100000000);\n        } else {\n            // Default, generate possible k\n            if (min_k <= max_k) {\n                k = rnd.next(min_k, max_k);\n            } else {\n                k = min_k;\n            }\n        }\n    }\n    // Ensure k is within 0 ≤ k ≤ 1e8\n    if (k < 0) k = 0;\n    if (k > 100000000) k = 100000000;\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, possible k\n./gen -n 1 -k 0\n./gen -n 2 -type possible\n./gen -n 3 -type possible\n\n# Small n, impossible k\n./gen -n 1 -k 1  # Impossible since n=1, k must be 0\n./gen -n 2 -type impossible\n./gen -n 3 -type impossible\n\n# Small n, random k\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type random\n\n# n at various sizes, possible k\n./gen -n 10 -type possible\n./gen -n 99 -type possible\n./gen -n 100 -type possible\n./gen -n 999 -type possible\n./gen -n 1000 -type possible\n./gen -n 9999 -type possible\n./gen -n 10000 -type possible\n./gen -n 99999 -type possible\n./gen -n 100000 -type possible\n\n# n at various sizes, impossible k\n./gen -n 10 -type impossible\n./gen -n 99 -type impossible\n./gen -n 100 -type impossible\n./gen -n 999 -type impossible\n./gen -n 1000 -type impossible\n./gen -n 9999 -type impossible\n./gen -n 10000 -type impossible\n./gen -n 99999 -type impossible\n./gen -n 100000 -type impossible\n\n# n at maximum size, k at minimum possible\n./gen -n 100000 -k 50000  # min_k = m = n/2\n\n# n at maximum size, k at maximum possible (max_k = 1e8)\n./gen -n 100000 -k 100000000\n\n# k = 0 cases\n./gen -n 1 -k 0\n./gen -n 2 -k 0  # Impossible, since min_k = 1\n./gen -n 2 -k 1  # Possible, min_k = 1\n\n# Random cases\n./gen -n 51234 -type random\n./gen -n 72568 -type random\n./gen -n 94876 -type random\n\n# Edge cases\n./gen -n 1 -k 0\n./gen -n 1 -k 100000000  # Impossible, since n=1, k must be 0\n\n# Max k cases\n./gen -n 100000 -k 100000000  # Possible\n./gen -n 99999 -k 100000000   # Possible\n\n# Impossible k beyond limits\n./gen -n 100000 -k 100000001  # Impossible\n./gen -n 100000 -k -1         # Impossible k\n\n# Odd n, possible and impossible k\n./gen -n 99999 -type possible\n./gen -n 99999 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:28.747626",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "414/B",
      "title": "B. Машмох и ACM",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа через пробел n, k (1 ≤ n, k ≤ 2000).",
      "output_spec": "Выходные данныеВыведите единственное целое число — количество хороших последовательностей длины k по модулю 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать3 2Выходные данныеСкопировать5Входные данныеСкопировать6 4Выходные данныеСкопировать39Входные данныеСкопировать2 1Выходные данныеСкопировать2",
      "description": "B. Машмох и ACM\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа через пробел n, k (1 ≤ n, k ≤ 2000).\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — количество хороших последовательностей длины k по модулю 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать3 2Выходные данныеСкопировать5Входные данныеСкопировать6 4Выходные данныеСкопировать39Входные данныеСкопировать2 1Выходные данныеСкопировать2\n\nВходные данныеСкопировать3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать39\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере хорошие последовательности такие: [1, 1], [2, 2], [3, 3], [1, 2], [1, 3].",
      "solutions": [
        {
          "title": "Codeforces Round #240 - Codeforces",
          "content": "Всем привет!Завтра в 19:30 MSK состоится Codeforces Round #240.Это наш первый раунд на Codeforces и мы надеемся, что он вам понравится. Задачи были подготовлены авторами: Amir Keivan Mohtashami (matrix), Farbod Yadegarian (FarbodY) и Gerald Agapov (Gerald).Традиционно благодарю MikeMirzayanov за системы Polygon и Codeforces, а также Maria Belova (Delinur) за перевод задач.Желаем вам хорошего и интересного раунда.Удачи!Как обычно, распределение баллов по задачам будет анонсировано перед началом контеста!Распределение баллов:div1: 500 — 1000 — 1500 — 1500 — 2500div2: 500 — 1000 — 1500 — 2000 — 2500 (стандарт)UPD: Поздравляю победителей!Div 1: fqw sankear (Единственный, кто решил задачу E во время контеста) Egor qwerty787788 hos.lyric Div 2: jzzhu SJTU_WengJian alcot LoveEvita huyifei NiuYiqiang Статистика по раунду, подготовленная DmitriyH, находится здесь. Английский разбор можно прочитать здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11458",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 908
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces",
          "content": "Hi!415A - Mashmokh and LightsFor this problem for each light j you could just iterate over all pressed buttons and find the first button bi that bi < j. Then you could output bi and move to next light.  415B - Mashmokh and TokensFor this problem you can find the number of tokens you can save if you initally have k tokens in O(1). Then you can calculate the answer for all of numbers in O(n). Suppose by p. then p * b ≤ w * a. then . Suppose initially we have k tokens. Let then we need to find such maximum k0 that .So k0 will be equal to . so we can calculate k0 in O(1).414A - Mashmokh and NumbersIn each turn Bimokh will at least get one point so the result is at lease . So if the answer is -1. Let's denote . Then you could output x and 2x as the first two integers in the sequence then output consecutive integers and also one random integer(distinct from the others) if n is odd. Based on the following fact, Bimokh's point will equal to which is equal to k.. Also you must consider some corner cases such as when n = 1.414B - Mashmokh and ACMLets define dp[i][j] as number of good sequences of length i that ends in j.Let's denote divisors of j by x1, x2, ..., xl. Then This yields O(nk sqrt(n)) solution which is not fast enough. But one could use the fact that the following loops run in O(n log(n)) in order to achieve O(nk log(n)) which is fast enough to pass the tests. for (i = 1; i <= n; i++) //loop from 1 to n\n for (int j = i; j <= n; j += i) //iterating through all multiples of i that are at most n414C - Mashmokh and Reverse OperationBuild a complete binary tree with height n. So its i-th leaf corresponds to i-th element of the initial array. For each vertex v lets define its subarray as the subarray containing the elements that have a leaf corresponding to them in subtree rooted at v.For each non-leaf vertex v, suppose its left child's subarray contains elements [a..b] of the array and its right child contains elements [b + 1..c] of the array. We'll calculate two numbers for this vertex. number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai > bj and number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai < bj. We'll call the first calculated number, normal number and the other one reverse number. Calculating these numbers can be done using merge-sort algorithm in O(n  *  2n). We'll Initially write normal number for each vertex on it. We'll define a vertex's type as type of the number that is written on them. Let's define height of a vertex v equal to its distnace to the nearest leaf. Also let's define switching a vertex as switching the number written on it with the other type number(if normal number is written on it change it to reverse number and vise-versa).Initially sum of writed numbers is equal to number of inversions in the initial array. Now when query h is given, by switching all vertices with height at most h, the sum of writed numbers will become equal to the number of inversions in the new array. The only question is how to perform such query fast? One can notice that in a height h, always all of the vertices has the same type. So we can calculate two numbers for each height h. The sum of normal numbers of vertices with height h and the sum of their reverse numbers. Then instead of switching vertices in a height one by one each time, one can just switch the number for that height. The sum of numbers of heights after each query will be the answer for that query. since there are n height each query can be performed in O(n) so the total running time will be O(nq  +  n  * 2n). 414D - Mashmokh and Water TanksLet's suppose instead of a tank there is a pile at each vertex and instead of water the game is played on tiles. Let's denote distance of each vertex q from the root by depth(q). Also Let's label each tile with number of the vertex it was initially put on. Suppose initially there was a tile at each of vertices v and u and after some move tile u and v are in the same vertex's pile. Then one can prove that there were exactly |depth(v) - depth(u)| moves at which vertex containing the tile at vertex with less depth was closed and the vertex containing the other tile wasn't. Suppose after i-th move, there was xi tiles inside the root's pile and xj is the maximum among these numbers. Suppose tiles a1, a2, ...axj were on the root after j-th move. Then the other tiles that we put inside the tree at the beginning have no effect in the final result. Then we can suppose that only these tiles were initially put on tree.So we can assume that all tiles we place at the beginning will reach to the root together. Suppose hi of these tiles were put at a vertex with depth i and d1 is the maximum depth that there is at least a tile in that depth. So as to these tiles reach to the root together we must pay . Then we want to minimize the number of needed coins so at the beginning there must not be two consecutive depth i and i + 1 that i + 1 ≤ d and there is a tile at depth i and an empty vertex at depth i + 1. In other words if we denote the minimum depth that initially there is a tile inside it as d0 then there must be a tile at each vertex with depth more than d0 and less than or equal to d1. Let's iterate over d1. Then for each d1 we can calculate d2, the minimum depth that we can pay the needed price if we put a tile at each vertex with depth at least d2 and at most d1. Let's denote this needed price as p0. Then we can also put at depth d2 - 1. So we can calculate maximum number of tiles that we can put on the tree so that they all reach to root together for a fixed d1. So the maximum of these numbers for all possible d1 will be the answer.Since by increasing d1, d2 won't decrease one can use two-pointers to update d2 while iterating over d1. Let's denote number of the vertices with depth i as cnti. Then we can save and update the following values.Then the needed price is equal to (d1 * s) - t. So as long as (d1 * s) - t > p we must increase d2. This yields an O(n) solution.414E - Mashmokh's Designed ProblemLet's define the dfs-order of a tree as the sequence created by calling function dfs(root). We'll build another sequence from a dfs-order by replacing each vertex in dfs-order by '+1' and inserting a '-1' after the last vertex of its subtree. Note that all vertices of a particular subtree are a continuous part of dfs-order of that tree. Also note that for each vertex v if the +1 corresponding to it is the i-th element of sequence, then v's distance from root(which we'll denote by height of v) is equal to sum of elements 1..i.Suppose we can perform the following operations on such sequence: For each i, find sum of the elements 1..i. For each i find the biggest j(j < i) so that sum of elements 1..j of the sequence equals p. Using these two operations we can find LCA of two vertices v and u, so since distance of u and v equals to height(u) + height(v) - 2 * height(LCA(u, v)) we can answer the second query. Also the third query can be answered using the second operation described above.As for the first query it cuts a continuous part of sequence and insert it in another place. This operation can be done using implicit treap. Also we can use the treap as a segment tree to store the following values for each vertex v. Then using these values the operations described above can be done. All of these operation can be done in O(logn). Sum of the elements in its subtree(each vertex in the treap has a value equal to +1 or -1 since it corresponds to an element of the sequence.) Let's write the values of each vertex in the subtree of v in the order they appear in the sequence. Then lets denote sum of the first i numbers we wrote as ps[i] and call elements of ps, prefix sums of the subtree of v. Then we store the maximum number amongst the prefix sums. Also we'll store the minimum number amongst prefix sums.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11470",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 414\\s*B"
          },
          "content_length": 7826
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #240 - Codeforces - Code 1",
          "code": "// cout << a/2\nint a = 6; int b = 1; \nwhile( b <= a && 2*b < a ) ++b;\ncout << b;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 2",
          "code": "// cout << a/2\nint a = 6; int b = 1; \nwhile( b <= a && 2*b < a ) ++b;\ncout << b;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 3",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 4",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 5",
          "code": "for(int i=1;i<=n;i++)\nfor(int j=1;j*i<=n;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 6",
          "code": "for(int i=1;i<=n;i++)\nfor(int j=1;j*i<=n;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 7",
          "code": "dp[i][j] = dp[i+1][j] + dp[i+1][2*j] + ... + dp[i+1][n/j*j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 8",
          "code": "dp[n][x] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 1",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 2",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 3",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 4",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 5",
          "code": "((a*x) % b) / a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 6",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 7",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 8",
          "code": "((x * A) % B)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 9",
          "code": "number of inversion after reverse = N(N-1)/2 - number of inversion before reverse - number of pair of same element",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 10",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 11",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 12",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 13",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 2000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 2000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 2000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        // Minimal case\n        n = 1;\n        k = 1;\n    } else if (type == \"max\") {\n        // Maximal case\n        n = 2000;\n        k = 2000;\n    } else if (type == \"n_equal_k\") {\n        // n equals k\n        if (n == -1 || k == -1) {\n            n = rnd.next(1, 2000);\n        }\n        n = min(n, 2000);\n        k = n;\n    } else if (type == \"n_less_k\") {\n        // n less than k\n        if (n == -1 || k == -1 || n >= k) {\n            n = rnd.next(1, 1999);\n            k = rnd.next(n + 1, 2000);\n        } else {\n            n = max(1, min(n, 2000));\n            k = max(n + 1, min(k, 2000));\n        }\n    } else if (type == \"k_equals_1\") {\n        // k equals 1\n        k = 1;\n        if (n == -1) {\n            n = rnd.next(1, 2000);\n        }\n    } else if (type == \"n_equals_1\") {\n        // n equals 1\n        n = 1;\n        if (k == -1) {\n            k = rnd.next(1, 2000);\n        }\n    } else if (type == \"random\") {\n        // Random n and k\n        if (n == -1) n = rnd.next(1, 2000);\n        if (k == -1) k = rnd.next(1, 2000);\n    }\n\n    // Ensure n and k are within constraints\n    n = max(1, min(n, 2000));\n    k = max(1, min(k, 2000));\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        // Minimal case\n        n = 1;\n        k = 1;\n    } else if (type == \"max\") {\n        // Maximal case\n        n = 2000;\n        k = 2000;\n    } else if (type == \"n_equal_k\") {\n        // n equals k\n        if (n == -1 || k == -1) {\n            n = rnd.next(1, 2000);\n        }\n        n = min(n, 2000);\n        k = n;\n    } else if (type == \"n_less_k\") {\n        // n less than k\n        if (n == -1 || k == -1 || n >= k) {\n            n = rnd.next(1, 1999);\n            k = rnd.next(n + 1, 2000);\n        } else {\n            n = max(1, min(n, 2000));\n            k = max(n + 1, min(k, 2000));\n        }\n    } else if (type == \"k_equals_1\") {\n        // k equals 1\n        k = 1;\n        if (n == -1) {\n            n = rnd.next(1, 2000);\n        }\n    } else if (type == \"n_equals_1\") {\n        // n equals 1\n        n = 1;\n        if (k == -1) {\n            k = rnd.next(1, 2000);\n        }\n    } else if (type == \"random\") {\n        // Random n and k\n        if (n == -1) n = rnd.next(1, 2000);\n        if (k == -1) k = rnd.next(1, 2000);\n    }\n\n    // Ensure n and k are within constraints\n    n = max(1, min(n, 2000));\n    k = max(1, min(k, 2000));\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal case\n./gen -type min\n\n# Maximal case\n./gen -type max\n\n# Random cases\n./gen -type random\n./gen -type random\n./gen -type random\n\n# n equals k\n./gen -type n_equal_k -n 1\n./gen -type n_equal_k -n 500\n./gen -type n_equal_k -n 2000\n\n# n less than k\n./gen -type n_less_k -n 1 -k 1000\n./gen -type n_less_k -n 500 -k 1500\n./gen -type n_less_k\n\n# k equals 1\n./gen -type k_equals_1 -n 1\n./gen -type k_equals_1 -n 1000\n./gen -type k_equals_1 -n 2000\n\n# n equals 1\n./gen -type n_equals_1 -k 1\n./gen -type n_equals_1 -k 1000\n./gen -type n_equals_1 -k 2000\n\n# Specific values\n./gen -n 1 -k 2000\n./gen -n 2000 -k 1\n./gen -n 1000 -k 1000\n./gen -n 1000 -k 1\n./gen -n 1 -k 1000\n\n# Random large values\n./gen -n 1999 -k 2000\n./gen -n 2000 -k 1999\n\n# More random cases\n./gen -type random\n./gen -type random\n\n# Edge cases\n./gen -n 2000 -k 2000\n./gen -n 1 -k 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:30.586984",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "414/C",
      "title": "C. Mashmokh and Reverse Operation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line of input contains a single integer n (0 ≤ n ≤ 20). The second line of input contains 2n space-separated integers a[1], a[2], ..., a[2n] (1 ≤ a[i] ≤ 109), the initial array.The third line of input contains a single integer m (1 ≤ m ≤ 106). The fourth line of input contains m space-separated integers q1, q2, ..., qm (0 ≤ qi ≤ n), the queries.Note: since the size of the input and output could be very large, don't use slow output techniques in your language. For example, do not use input and output streams (cin, cout) in C++.",
      "output_spec": "OutputOutput m lines. In the i-th line print the answer (the number of inversions) for the i-th query.",
      "sample_tests": "ExamplesInputCopy22 1 4 341 2 0 2OutputCopy0660InputCopy11 230 1 1OutputCopy010",
      "description": "C. Mashmokh and Reverse Operation\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains a single integer n (0 ≤ n ≤ 20). The second line of input contains 2n space-separated integers a[1], a[2], ..., a[2n] (1 ≤ a[i] ≤ 109), the initial array.The third line of input contains a single integer m (1 ≤ m ≤ 106). The fourth line of input contains m space-separated integers q1, q2, ..., qm (0 ≤ qi ≤ n), the queries.Note: since the size of the input and output could be very large, don't use slow output techniques in your language. For example, do not use input and output streams (cin, cout) in C++.\n\nOutputOutput m lines. In the i-th line print the answer (the number of inversions) for the i-th query.\n\nInputCopy22 1 4 341 2 0 2OutputCopy0660InputCopy11 230 1 1OutputCopy010\n\nInputCopy22 1 4 341 2 0 2\n\nOutputCopy0660\n\nInputCopy11 230 1 1\n\nOutputCopy010\n\nNoteIf we reverse an array x[1], x[2], ..., x[n] it becomes new array y[1], y[2], ..., y[n], where y[i] = x[n - i + 1] for each i.The number of inversions of an array x[1], x[2], ..., x[n] is the number of pairs of indices i, j such that: i < j and x[i] > x[j].",
      "solutions": [
        {
          "title": "Codeforces Round #240 - Codeforces",
          "content": "Hi everybody!Codeforces round #240 will take place tomorrow 19:30 MSKThis is our first round in Codeforces and we hope that everything will be fine. The problems were prepared by Amir Keivan Mohtashami(matrix), Farbod Yadegarian(FarbodY) and Gerald Agapov(Gerald). Also special thanks to Mohammad Amin Khashkhashi Moghaddam(alex-mercer) for testing this round.I want to also thank MikeMirzayanov for Polygon and Codeforces systems, and also Maria Belova(Delinur) for translating the statements.We wish you a good and challenging round.Have fun!Score distribution:div1: 500 — 1000 — 1500 — 1500 — 2500div2: 500 — 1000 — 1500 — 2000 — 2500 (standard)UPD: due to technical reasons the round was delayed for 10 minutes. We apologize for any inconvenience caused.  UPD2: Congratulations to the winners!Div 1: fqw sankear (The only one who solved problem E during the contest. Congratulations!) Egor qwerty787788 hos.lyric Div 2: jzzhu SJTU_WengJian alcot LoveEvita huyifei NiuYiqiang UPD3: The round analysis are prepared by DmitriyH. You can find them here. Also the tutorial is not completely ready yet. But you can find some notes about some of the problems here. I'll try to complete it as soon as possible.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11458",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1206
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces",
          "content": "Hi!415A - Mashmokh and LightsFor this problem for each light j you could just iterate over all pressed buttons and find the first button bi that bi < j. Then you could output bi and move to next light.  415B - Mashmokh and TokensFor this problem you can find the number of tokens you can save if you initally have k tokens in O(1). Then you can calculate the answer for all of numbers in O(n). Suppose by p. then p * b ≤ w * a. then . Suppose initially we have k tokens. Let then we need to find such maximum k0 that .So k0 will be equal to . so we can calculate k0 in O(1).414A - Mashmokh and NumbersIn each turn Bimokh will at least get one point so the result is at lease . So if the answer is -1. Let's denote . Then you could output x and 2x as the first two integers in the sequence then output consecutive integers and also one random integer(distinct from the others) if n is odd. Based on the following fact, Bimokh's point will equal to which is equal to k.. Also you must consider some corner cases such as when n = 1.414B - Mashmokh and ACMLets define dp[i][j] as number of good sequences of length i that ends in j.Let's denote divisors of j by x1, x2, ..., xl. Then This yields O(nk sqrt(n)) solution which is not fast enough. But one could use the fact that the following loops run in O(n log(n)) in order to achieve O(nk log(n)) which is fast enough to pass the tests. for (i = 1; i <= n; i++) //loop from 1 to n\n for (int j = i; j <= n; j += i) //iterating through all multiples of i that are at most n414C - Mashmokh and Reverse OperationBuild a complete binary tree with height n. So its i-th leaf corresponds to i-th element of the initial array. For each vertex v lets define its subarray as the subarray containing the elements that have a leaf corresponding to them in subtree rooted at v.For each non-leaf vertex v, suppose its left child's subarray contains elements [a..b] of the array and its right child contains elements [b + 1..c] of the array. We'll calculate two numbers for this vertex. number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai > bj and number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai < bj. We'll call the first calculated number, normal number and the other one reverse number. Calculating these numbers can be done using merge-sort algorithm in O(n  *  2n). We'll Initially write normal number for each vertex on it. We'll define a vertex's type as type of the number that is written on them. Let's define height of a vertex v equal to its distnace to the nearest leaf. Also let's define switching a vertex as switching the number written on it with the other type number(if normal number is written on it change it to reverse number and vise-versa).Initially sum of writed numbers is equal to number of inversions in the initial array. Now when query h is given, by switching all vertices with height at most h, the sum of writed numbers will become equal to the number of inversions in the new array. The only question is how to perform such query fast? One can notice that in a height h, always all of the vertices has the same type. So we can calculate two numbers for each height h. The sum of normal numbers of vertices with height h and the sum of their reverse numbers. Then instead of switching vertices in a height one by one each time, one can just switch the number for that height. The sum of numbers of heights after each query will be the answer for that query. since there are n height each query can be performed in O(n) so the total running time will be O(nq  +  n  * 2n). 414D - Mashmokh and Water TanksLet's suppose instead of a tank there is a pile at each vertex and instead of water the game is played on tiles. Let's denote distance of each vertex q from the root by depth(q). Also Let's label each tile with number of the vertex it was initially put on. Suppose initially there was a tile at each of vertices v and u and after some move tile u and v are in the same vertex's pile. Then one can prove that there were exactly |depth(v) - depth(u)| moves at which vertex containing the tile at vertex with less depth was closed and the vertex containing the other tile wasn't. Suppose after i-th move, there was xi tiles inside the root's pile and xj is the maximum among these numbers. Suppose tiles a1, a2, ...axj were on the root after j-th move. Then the other tiles that we put inside the tree at the beginning have no effect in the final result. Then we can suppose that only these tiles were initially put on tree.So we can assume that all tiles we place at the beginning will reach to the root together. Suppose hi of these tiles were put at a vertex with depth i and d1 is the maximum depth that there is at least a tile in that depth. So as to these tiles reach to the root together we must pay . Then we want to minimize the number of needed coins so at the beginning there must not be two consecutive depth i and i + 1 that i + 1 ≤ d and there is a tile at depth i and an empty vertex at depth i + 1. In other words if we denote the minimum depth that initially there is a tile inside it as d0 then there must be a tile at each vertex with depth more than d0 and less than or equal to d1. Let's iterate over d1. Then for each d1 we can calculate d2, the minimum depth that we can pay the needed price if we put a tile at each vertex with depth at least d2 and at most d1. Let's denote this needed price as p0. Then we can also put at depth d2 - 1. So we can calculate maximum number of tiles that we can put on the tree so that they all reach to root together for a fixed d1. So the maximum of these numbers for all possible d1 will be the answer.Since by increasing d1, d2 won't decrease one can use two-pointers to update d2 while iterating over d1. Let's denote number of the vertices with depth i as cnti. Then we can save and update the following values.Then the needed price is equal to (d1 * s) - t. So as long as (d1 * s) - t > p we must increase d2. This yields an O(n) solution.414E - Mashmokh's Designed ProblemLet's define the dfs-order of a tree as the sequence created by calling function dfs(root). We'll build another sequence from a dfs-order by replacing each vertex in dfs-order by '+1' and inserting a '-1' after the last vertex of its subtree. Note that all vertices of a particular subtree are a continuous part of dfs-order of that tree. Also note that for each vertex v if the +1 corresponding to it is the i-th element of sequence, then v's distance from root(which we'll denote by height of v) is equal to sum of elements 1..i.Suppose we can perform the following operations on such sequence: For each i, find sum of the elements 1..i. For each i find the biggest j(j < i) so that sum of elements 1..j of the sequence equals p. Using these two operations we can find LCA of two vertices v and u, so since distance of u and v equals to height(u) + height(v) - 2 * height(LCA(u, v)) we can answer the second query. Also the third query can be answered using the second operation described above.As for the first query it cuts a continuous part of sequence and insert it in another place. This operation can be done using implicit treap. Also we can use the treap as a segment tree to store the following values for each vertex v. Then using these values the operations described above can be done. All of these operation can be done in O(logn). Sum of the elements in its subtree(each vertex in the treap has a value equal to +1 or -1 since it corresponds to an element of the sequence.) Let's write the values of each vertex in the subtree of v in the order they appear in the sequence. Then lets denote sum of the first i numbers we wrote as ps[i] and call elements of ps, prefix sums of the subtree of v. Then we store the maximum number amongst the prefix sums. Also we'll store the minimum number amongst prefix sums.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11470",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 414\\s*C"
          },
          "content_length": 7826
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #240 - Codeforces - Code 1",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 2",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 3",
          "code": "dp[i][j] = dp[i+1][j] + dp[i+1][2*j] + ... + dp[i+1][n/j*j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 4",
          "code": "dp[n][x] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 1",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 2",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 3",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 4",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 5",
          "code": "((a*x) % b) / a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 6",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 7",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 8",
          "code": "((x * A) % B)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 9",
          "code": "number of inversion after reverse = N(N-1)/2 - number of inversion before reverse - number of pair of same element",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 10",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 11",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 12",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 13",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n (0 ≤ n ≤ 20)\n    int n = inf.readInt(0, 20, \"n\");\n    inf.readEoln();\n\n    // Calculate 2^n\n    int N = 1 << n;\n\n    // Read 2^n integers a[1..2^n], each in [1, 1e9]\n    vector<int> a = inf.readInts(N, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Read m (1 ≤ m ≤ 1e6)\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    // Read m integers qi, each in [0, n]\n    vector<int> q = inf.readInts(m, 0, n, \"q_i\");\n    inf.readEoln();\n\n    // Ensure that the input ends here\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n (0 ≤ n ≤ 20)\n    int n = inf.readInt(0, 20, \"n\");\n    inf.readEoln();\n\n    // Calculate 2^n\n    int N = 1 << n;\n\n    // Read 2^n integers a[1..2^n], each in [1, 1e9]\n    vector<int> a = inf.readInts(N, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Read m (1 ≤ m ≤ 1e6)\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    // Read m integers qi, each in [0, n]\n    vector<int> q = inf.readInts(m, 0, n, \"q_i\");\n    inf.readEoln();\n\n    // Ensure that the input ends here\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n (0 ≤ n ≤ 20)\n    int n = inf.readInt(0, 20, \"n\");\n    inf.readEoln();\n\n    // Calculate 2^n\n    int N = 1 << n;\n\n    // Read 2^n integers a[1..2^n], each in [1, 1e9]\n    vector<int> a = inf.readInts(N, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Read m (1 ≤ m ≤ 1e6)\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    // Read m integers qi, each in [0, n]\n    vector<int> q = inf.readInts(m, 0, n, \"q_i\");\n    inf.readEoln();\n\n    // Ensure that the input ends here\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string array_type = opt<string>(\"array_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    int N = 1 << n; // size of the array\n\n    vector<int> a(N);\n\n    if (array_type == \"random\") {\n        // Random values from [1, 1e9]\n        for (int i = 0; i < N; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (array_type == \"sorted\") {\n        // Increasing sequence\n        for (int i = 0; i < N; ++i) {\n            a[i] = i + 1;\n        }\n    } else if (array_type == \"reversed\") {\n        // Decreasing sequence\n        for (int i = 0; i < N; ++i) {\n            a[i] = N - i;\n        }\n    } else if (array_type == \"equal\") {\n        // All elements are equal to some random value\n        int val = rnd.next(1, 1000000000);\n        for (int i = 0; i < N; ++i) {\n            a[i] = val;\n        }\n    } else if (array_type == \"max_inversions\") {\n        // Decreasing sequence to maximize inversions\n        for (int i = 0; i < N; ++i) {\n            a[i] = N - i;\n        }\n    } else if (array_type == \"min_inversions\") {\n        // Increasing sequence to minimize inversions\n        for (int i = 0; i < N; ++i) {\n            a[i] = i + 1;\n        }\n    } else {\n        cerr << \"Unknown array_type: \" << array_type << endl;\n        exit(1);\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < N; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < N) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    printf(\"%d\\n\", m);\n\n    vector<int> q(m);\n\n    if (query_type == \"all_zero\") {\n        // All queries are 0\n        for (int i = 0; i < m; ++i) {\n            q[i] = 0;\n        }\n    } else if (query_type == \"all_n\") {\n        // All queries are n\n        for (int i = 0; i < m; ++i) {\n            q[i] = n;\n        }\n    } else if (query_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            q[i] = rnd.next(0, n);\n        }\n    } else if (query_type == \"alternating_0_n\") {\n        for (int i = 0; i < m; ++i) {\n            q[i] = (i % 2 == 0) ? 0 : n;\n        }\n    } else {\n        cerr << \"Unknown query_type: \" << query_type << endl;\n        exit(1);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", q[i]);\n        if (i + 1 < m) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string array_type = opt<string>(\"array_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    int N = 1 << n; // size of the array\n\n    vector<int> a(N);\n\n    if (array_type == \"random\") {\n        // Random values from [1, 1e9]\n        for (int i = 0; i < N; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (array_type == \"sorted\") {\n        // Increasing sequence\n        for (int i = 0; i < N; ++i) {\n            a[i] = i + 1;\n        }\n    } else if (array_type == \"reversed\") {\n        // Decreasing sequence\n        for (int i = 0; i < N; ++i) {\n            a[i] = N - i;\n        }\n    } else if (array_type == \"equal\") {\n        // All elements are equal to some random value\n        int val = rnd.next(1, 1000000000);\n        for (int i = 0; i < N; ++i) {\n            a[i] = val;\n        }\n    } else if (array_type == \"max_inversions\") {\n        // Decreasing sequence to maximize inversions\n        for (int i = 0; i < N; ++i) {\n            a[i] = N - i;\n        }\n    } else if (array_type == \"min_inversions\") {\n        // Increasing sequence to minimize inversions\n        for (int i = 0; i < N; ++i) {\n            a[i] = i + 1;\n        }\n    } else {\n        cerr << \"Unknown array_type: \" << array_type << endl;\n        exit(1);\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < N; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < N) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    printf(\"%d\\n\", m);\n\n    vector<int> q(m);\n\n    if (query_type == \"all_zero\") {\n        // All queries are 0\n        for (int i = 0; i < m; ++i) {\n            q[i] = 0;\n        }\n    } else if (query_type == \"all_n\") {\n        // All queries are n\n        for (int i = 0; i < m; ++i) {\n            q[i] = n;\n        }\n    } else if (query_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            q[i] = rnd.next(0, n);\n        }\n    } else if (query_type == \"alternating_0_n\") {\n        for (int i = 0; i < m; ++i) {\n            q[i] = (i % 2 == 0) ? 0 : n;\n        }\n    } else {\n        cerr << \"Unknown query_type: \" << query_type << endl;\n        exit(1);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d\", q[i]);\n        if (i + 1 < m) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 0 -m 1 -array_type random -query_type random          # Minimal size array\n./gen -n 0 -m 1 -array_type random -query_type all_zero        # Minimal size array, query q=0\n./gen -n 0 -m 1 -array_type random -query_type all_n           # Minimal size array, query q=n\n\n./gen -n 1 -m 1 -array_type random -query_type random          # Small size array\n\n./gen -n 20 -m 1000000 -array_type random -query_type random   # Max size N and m\n\n./gen -n 20 -m 1000000 -array_type sorted -query_type random   # Max N and m, sorted array\n\n./gen -n 20 -m 1000000 -array_type reversed -query_type random # Max N and m, reversed array\n\n./gen -n 20 -m 1000000 -array_type equal -query_type all_zero  # Max N and m, equal elements, q=0\n\n./gen -n 20 -m 1000000 -array_type equal -query_type all_n     # Max N and m, equal elements, q=n\n\n./gen -n 20 -m 1000000 -array_type max_inversions -query_type all_zero     # Array maximizing inversions\n\n./gen -n 20 -m 1000000 -array_type min_inversions -query_type all_n        # Array minimizing inversions\n\n./gen -n 20 -m 1000000 -array_type random -query_type all_zero             # All queries q=0\n\n./gen -n 20 -m 1000000 -array_type random -query_type all_n                # All queries q=n\n\n./gen -n 20 -m 1000000 -array_type random -query_type alternating_0_n      # Queries alternate between 0 and n\n\n./gen -n 10 -m 1000000 -array_type random -query_type random               # Medium N, large m\n\n./gen -n 15 -m 1 -array_type random -query_type random                     # Large N, small m\n\n./gen -n 20 -m 1000000 -array_type sorted -query_type all_zero             # Sorted array, q=0\n\n./gen -n 20 -m 1000000 -array_type reversed -query_type all_n              # Reversed array, q=n\n\n./gen -n 5 -m 1000 -array_type random -query_type random                   # Small N, moderate m\n\n./gen -n 5 -m 1000000 -array_type random -query_type random                # Small N, max m\n\n./gen -n 10 -m 1000000 -array_type equal -query_type random                # Equal elements, random queries\n\n./gen -n 20 -m 1000000 -array_type equal -query_type random                # Max N, equal elements\n\n./gen -n 20 -m 1000000 -array_type max_inversions -query_type random       # Max inversions, random queries\n\n./gen -n 20 -m 1 -array_type max_inversions -query_type random             # Max inversions, single query\n\n./gen -n 0 -m 1000000 -array_type random -query_type random                # Min N, max m\n\n./gen -n 20 -m 1000000 -array_type random -query_type random               # Random array and queries\n\n./gen -n 20 -m 1000000 -array_type random -query_type random               # Repeat to ensure randomness\n\n./gen -n 20 -m 1000000 -array_type random -query_type random\n\n./gen -n 20 -m 1000000 -array_type random -query_type random\n\n./gen -n 20 -m 1000000 -array_type random -query_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:32.953472",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "414/D",
      "title": "D. Mashmokh and Water Tanks",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line of the input contains three space-separated integers m, k, p (2 ≤ m ≤ 105; 0 ≤ k, p ≤ 109). Each of the following m - 1 lines contains two space-separated integers ai, bi (1 ≤ ai, bi ≤ m; ai ≠ bi) — the edges of the tree.Consider that the vertices of the tree are numbered from 1 to m. The root of the tree has number 1.",
      "output_spec": "OutputOutput a single integer, the number Mashmokh asked you to find.",
      "sample_tests": "ExamplesInputCopy10 2 11 21 33 43 52 66 86 79 88 10OutputCopy2InputCopy5 1000 10001 21 33 43 5OutputCopy4",
      "description": "D. Mashmokh and Water Tanks\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains three space-separated integers m, k, p (2 ≤ m ≤ 105; 0 ≤ k, p ≤ 109). Each of the following m - 1 lines contains two space-separated integers ai, bi (1 ≤ ai, bi ≤ m; ai ≠ bi) — the edges of the tree.Consider that the vertices of the tree are numbered from 1 to m. The root of the tree has number 1.\n\nOutputOutput a single integer, the number Mashmokh asked you to find.\n\nInputCopy10 2 11 21 33 43 52 66 86 79 88 10OutputCopy2InputCopy5 1000 10001 21 33 43 5OutputCopy4\n\nInputCopy10 2 11 21 33 43 52 66 86 79 88 10\n\nOutputCopy2\n\nInputCopy5 1000 10001 21 33 43 5\n\nOutputCopy4\n\nNoteThe tree in the first sample is shown on the picture below. The black, red, blue colors correspond to vertices with 0, 1, 2 liters of water.One way to achieve the maximum amount of money is to put 1 liter of water in each of vertices 3 and 4. The beginning state is shown on the picture below.Then in the first move Mashmokh will pay one token to close the door of the third vertex tank. The tree after the first move is shown on the picture below.After the second move there are 2 liters of water in the root as shown on the picture below.",
      "solutions": [
        {
          "title": "Codeforces Round #240 - Codeforces",
          "content": "Hi everybody!Codeforces round #240 will take place tomorrow 19:30 MSKThis is our first round in Codeforces and we hope that everything will be fine. The problems were prepared by Amir Keivan Mohtashami(matrix), Farbod Yadegarian(FarbodY) and Gerald Agapov(Gerald). Also special thanks to Mohammad Amin Khashkhashi Moghaddam(alex-mercer) for testing this round.I want to also thank MikeMirzayanov for Polygon and Codeforces systems, and also Maria Belova(Delinur) for translating the statements.We wish you a good and challenging round.Have fun!Score distribution:div1: 500 — 1000 — 1500 — 1500 — 2500div2: 500 — 1000 — 1500 — 2000 — 2500 (standard)UPD: due to technical reasons the round was delayed for 10 minutes. We apologize for any inconvenience caused.  UPD2: Congratulations to the winners!Div 1: fqw sankear (The only one who solved problem E during the contest. Congratulations!) Egor qwerty787788 hos.lyric Div 2: jzzhu SJTU_WengJian alcot LoveEvita huyifei NiuYiqiang UPD3: The round analysis are prepared by DmitriyH. You can find them here. Also the tutorial is not completely ready yet. But you can find some notes about some of the problems here. I'll try to complete it as soon as possible.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/11458",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1206
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces",
          "content": "Hi!415A - Mashmokh and LightsFor this problem for each light j you could just iterate over all pressed buttons and find the first button bi that bi < j. Then you could output bi and move to next light.  415B - Mashmokh and TokensFor this problem you can find the number of tokens you can save if you initally have k tokens in O(1). Then you can calculate the answer for all of numbers in O(n). Suppose by p. then p * b ≤ w * a. then . Suppose initially we have k tokens. Let then we need to find such maximum k0 that .So k0 will be equal to . so we can calculate k0 in O(1).414A - Mashmokh and NumbersIn each turn Bimokh will at least get one point so the result is at lease . So if the answer is -1. Let's denote . Then you could output x and 2x as the first two integers in the sequence then output consecutive integers and also one random integer(distinct from the others) if n is odd. Based on the following fact, Bimokh's point will equal to which is equal to k.. Also you must consider some corner cases such as when n = 1.414B - Mashmokh and ACMLets define dp[i][j] as number of good sequences of length i that ends in j.Let's denote divisors of j by x1, x2, ..., xl. Then This yields O(nk sqrt(n)) solution which is not fast enough. But one could use the fact that the following loops run in O(n log(n)) in order to achieve O(nk log(n)) which is fast enough to pass the tests. for (i = 1; i <= n; i++) //loop from 1 to n\n for (int j = i; j <= n; j += i) //iterating through all multiples of i that are at most n414C - Mashmokh and Reverse OperationBuild a complete binary tree with height n. So its i-th leaf corresponds to i-th element of the initial array. For each vertex v lets define its subarray as the subarray containing the elements that have a leaf corresponding to them in subtree rooted at v.For each non-leaf vertex v, suppose its left child's subarray contains elements [a..b] of the array and its right child contains elements [b + 1..c] of the array. We'll calculate two numbers for this vertex. number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai > bj and number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai < bj. We'll call the first calculated number, normal number and the other one reverse number. Calculating these numbers can be done using merge-sort algorithm in O(n  *  2n). We'll Initially write normal number for each vertex on it. We'll define a vertex's type as type of the number that is written on them. Let's define height of a vertex v equal to its distnace to the nearest leaf. Also let's define switching a vertex as switching the number written on it with the other type number(if normal number is written on it change it to reverse number and vise-versa).Initially sum of writed numbers is equal to number of inversions in the initial array. Now when query h is given, by switching all vertices with height at most h, the sum of writed numbers will become equal to the number of inversions in the new array. The only question is how to perform such query fast? One can notice that in a height h, always all of the vertices has the same type. So we can calculate two numbers for each height h. The sum of normal numbers of vertices with height h and the sum of their reverse numbers. Then instead of switching vertices in a height one by one each time, one can just switch the number for that height. The sum of numbers of heights after each query will be the answer for that query. since there are n height each query can be performed in O(n) so the total running time will be O(nq  +  n  * 2n). 414D - Mashmokh and Water TanksLet's suppose instead of a tank there is a pile at each vertex and instead of water the game is played on tiles. Let's denote distance of each vertex q from the root by depth(q). Also Let's label each tile with number of the vertex it was initially put on. Suppose initially there was a tile at each of vertices v and u and after some move tile u and v are in the same vertex's pile. Then one can prove that there were exactly |depth(v) - depth(u)| moves at which vertex containing the tile at vertex with less depth was closed and the vertex containing the other tile wasn't. Suppose after i-th move, there was xi tiles inside the root's pile and xj is the maximum among these numbers. Suppose tiles a1, a2, ...axj were on the root after j-th move. Then the other tiles that we put inside the tree at the beginning have no effect in the final result. Then we can suppose that only these tiles were initially put on tree.So we can assume that all tiles we place at the beginning will reach to the root together. Suppose hi of these tiles were put at a vertex with depth i and d1 is the maximum depth that there is at least a tile in that depth. So as to these tiles reach to the root together we must pay . Then we want to minimize the number of needed coins so at the beginning there must not be two consecutive depth i and i + 1 that i + 1 ≤ d and there is a tile at depth i and an empty vertex at depth i + 1. In other words if we denote the minimum depth that initially there is a tile inside it as d0 then there must be a tile at each vertex with depth more than d0 and less than or equal to d1. Let's iterate over d1. Then for each d1 we can calculate d2, the minimum depth that we can pay the needed price if we put a tile at each vertex with depth at least d2 and at most d1. Let's denote this needed price as p0. Then we can also put at depth d2 - 1. So we can calculate maximum number of tiles that we can put on the tree so that they all reach to root together for a fixed d1. So the maximum of these numbers for all possible d1 will be the answer.Since by increasing d1, d2 won't decrease one can use two-pointers to update d2 while iterating over d1. Let's denote number of the vertices with depth i as cnti. Then we can save and update the following values.Then the needed price is equal to (d1 * s) - t. So as long as (d1 * s) - t > p we must increase d2. This yields an O(n) solution.414E - Mashmokh's Designed ProblemLet's define the dfs-order of a tree as the sequence created by calling function dfs(root). We'll build another sequence from a dfs-order by replacing each vertex in dfs-order by '+1' and inserting a '-1' after the last vertex of its subtree. Note that all vertices of a particular subtree are a continuous part of dfs-order of that tree. Also note that for each vertex v if the +1 corresponding to it is the i-th element of sequence, then v's distance from root(which we'll denote by height of v) is equal to sum of elements 1..i.Suppose we can perform the following operations on such sequence: For each i, find sum of the elements 1..i. For each i find the biggest j(j < i) so that sum of elements 1..j of the sequence equals p. Using these two operations we can find LCA of two vertices v and u, so since distance of u and v equals to height(u) + height(v) - 2 * height(LCA(u, v)) we can answer the second query. Also the third query can be answered using the second operation described above.As for the first query it cuts a continuous part of sequence and insert it in another place. This operation can be done using implicit treap. Also we can use the treap as a segment tree to store the following values for each vertex v. Then using these values the operations described above can be done. All of these operation can be done in O(logn). Sum of the elements in its subtree(each vertex in the treap has a value equal to +1 or -1 since it corresponds to an element of the sequence.) Let's write the values of each vertex in the subtree of v in the order they appear in the sequence. Then lets denote sum of the first i numbers we wrote as ps[i] and call elements of ps, prefix sums of the subtree of v. Then we store the maximum number amongst the prefix sums. Also we'll store the minimum number amongst prefix sums.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/11470",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 414\\s*D"
          },
          "content_length": 7826
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #240 - Codeforces - Code 1",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 2",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 3",
          "code": "dp[i][j] = dp[i+1][j] + dp[i+1][2*j] + ... + dp[i+1][n/j*j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 4",
          "code": "dp[n][x] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 1",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 2",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 3",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 4",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 5",
          "code": "((a*x) % b) / a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 6",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 7",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 8",
          "code": "((x * A) % B)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 9",
          "code": "number of inversion after reverse = N(N-1)/2 - number of inversion before reverse - number of pair of same element",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 10",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 11",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 12",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 13",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\nint components;\n\nint find(int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent[u]);\n    }\n    return parent[u];\n}\n\nbool unite(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) {\n        return false;\n    }\n    parent[u] = v;\n    components--;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(2, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000000000, \"k\");\n    inf.readSpace();\n    int p = inf.readInt(0, 1000000000, \"p\");\n    inf.readEoln();\n\n    parent.resize(m + 1);\n    components = m;\n    for (int i = 1; i <= m; ++i) {\n        parent[i] = i;\n    }\n\n    for (int i = 0; i < m - 1; ++i) {\n        int a = inf.readInt(1, m, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, m, \"b_i\");\n        inf.readEoln();\n        ensuref(a != b, \"Edge cannot connect a vertex to itself (loop) at line %d\", i + 2);\n\n        ensuref(unite(a, b), \"Graph is not acyclic, cycle detected when adding edge (%d, %d) at line %d\", a, b, i + 2);\n    }\n\n    ensuref(components == 1, \"Graph is not connected, number of connected components is %d\", components);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\nint components;\n\nint find(int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent[u]);\n    }\n    return parent[u];\n}\n\nbool unite(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) {\n        return false;\n    }\n    parent[u] = v;\n    components--;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(2, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000000000, \"k\");\n    inf.readSpace();\n    int p = inf.readInt(0, 1000000000, \"p\");\n    inf.readEoln();\n\n    parent.resize(m + 1);\n    components = m;\n    for (int i = 1; i <= m; ++i) {\n        parent[i] = i;\n    }\n\n    for (int i = 0; i < m - 1; ++i) {\n        int a = inf.readInt(1, m, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, m, \"b_i\");\n        inf.readEoln();\n        ensuref(a != b, \"Edge cannot connect a vertex to itself (loop) at line %d\", i + 2);\n\n        ensuref(unite(a, b), \"Graph is not acyclic, cycle detected when adding edge (%d, %d) at line %d\", a, b, i + 2);\n    }\n\n    ensuref(components == 1, \"Graph is not connected, number of connected components is %d\", components);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\nint components;\n\nint find(int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent[u]);\n    }\n    return parent[u];\n}\n\nbool unite(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) {\n        return false;\n    }\n    parent[u] = v;\n    components--;\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(2, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000000000, \"k\");\n    inf.readSpace();\n    int p = inf.readInt(0, 1000000000, \"p\");\n    inf.readEoln();\n\n    parent.resize(m + 1);\n    components = m;\n    for (int i = 1; i <= m; ++i) {\n        parent[i] = i;\n    }\n\n    for (int i = 0; i < m - 1; ++i) {\n        int a = inf.readInt(1, m, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, m, \"b_i\");\n        inf.readEoln();\n        ensuref(a != b, \"Edge cannot connect a vertex to itself (loop) at line %d\", i + 2);\n\n        ensuref(unite(a, b), \"Graph is not acyclic, cycle detected when adding edge (%d, %d) at line %d\", a, b, i + 2);\n    }\n\n    ensuref(components == 1, \"Graph is not connected, number of connected components is %d\", components);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int m = opt<int>(\"m\"); // number of vertices\n    int k = opt<int>(\"k\", 0); // amount of water he can pour into tanks\n    int p = opt<int>(\"p\", 0); // number of coins he has\n    string type = opt<string>(\"type\", \"random\"); // tree type\n\n    // Validate parameters\n    assert(m >= 2 && m <= 100000);\n    assert(k >= 0 && k <= 1000000000);\n    assert(p >= 0 && p <= 1000000000);\n\n    // Build tree depending on type\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        /* A tree that has degenerated into a chain */\n        for (int i = 2; i <= m; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (type == \"star\") {\n        /* A star-shaped tree */\n        for (int i = 2; i <= m; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"balanced\") {\n        /* A balanced binary tree */\n        vector<int> nodes;\n        nodes.push_back(1);\n        int idx = 2;\n        for (size_t i = 0; i < nodes.size() && idx <= m; ++i) {\n            int parent = nodes[i];\n\n            if (idx <= m) {\n                edges.push_back({parent, idx});\n                nodes.push_back(idx++);\n            }\n            if (idx <= m) {\n                edges.push_back({parent, idx});\n                nodes.push_back(idx++);\n            }\n        }\n    } else if (type == \"sqrt\") {\n        /* A tree with degree approximately sqrt(n) */\n        int degree = sqrt(m) + 1;\n        int idx = 2;\n        for (int i = 1; i <= degree && idx <= m; ++i) {\n            edges.push_back({1, idx++});\n        }\n        int curr = 2;\n        while (idx <= m) {\n            edges.push_back({curr, idx++});\n            curr++;\n            if (curr > degree) curr = 2;\n        }\n    } else {\n        /* Random tree */\n        for (int i = 2; i <= m; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Output parameters\n    printf(\"%d %d %d\\n\", m, k, p);\n    for (auto& edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int m = opt<int>(\"m\"); // number of vertices\n    int k = opt<int>(\"k\", 0); // amount of water he can pour into tanks\n    int p = opt<int>(\"p\", 0); // number of coins he has\n    string type = opt<string>(\"type\", \"random\"); // tree type\n\n    // Validate parameters\n    assert(m >= 2 && m <= 100000);\n    assert(k >= 0 && k <= 1000000000);\n    assert(p >= 0 && p <= 1000000000);\n\n    // Build tree depending on type\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        /* A tree that has degenerated into a chain */\n        for (int i = 2; i <= m; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (type == \"star\") {\n        /* A star-shaped tree */\n        for (int i = 2; i <= m; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"balanced\") {\n        /* A balanced binary tree */\n        vector<int> nodes;\n        nodes.push_back(1);\n        int idx = 2;\n        for (size_t i = 0; i < nodes.size() && idx <= m; ++i) {\n            int parent = nodes[i];\n\n            if (idx <= m) {\n                edges.push_back({parent, idx});\n                nodes.push_back(idx++);\n            }\n            if (idx <= m) {\n                edges.push_back({parent, idx});\n                nodes.push_back(idx++);\n            }\n        }\n    } else if (type == \"sqrt\") {\n        /* A tree with degree approximately sqrt(n) */\n        int degree = sqrt(m) + 1;\n        int idx = 2;\n        for (int i = 1; i <= degree && idx <= m; ++i) {\n            edges.push_back({1, idx++});\n        }\n        int curr = 2;\n        while (idx <= m) {\n            edges.push_back({curr, idx++});\n            curr++;\n            if (curr > degree) curr = 2;\n        }\n    } else {\n        /* Random tree */\n        for (int i = 2; i <= m; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Output parameters\n    printf(\"%d %d %d\\n\", m, k, p);\n    for (auto& edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -m 2 -k 0 -p 0 -type chain\n./gen -m 2 -k 1 -p 1 -type star\n./gen -m 2 -k 1 -p 0 -type random\n\n./gen -m 10 -k 2 -p 1 -type chain\n./gen -m 10 -k 5 -p 0 -type star\n./gen -m 10 -k 0 -p 10 -type random\n\n./gen -m 100 -k 100 -p 1000 -type chain\n./gen -m 100 -k 50 -p 50 -type star\n./gen -m 100 -k 100 -p 0 -type random\n\n./gen -m 1000 -k 500 -p 1000000000 -type chain\n./gen -m 1000 -k 999 -p 999 -type star\n./gen -m 1000 -k 0 -p 0 -type random\n\n./gen -m 10000 -k 10000 -p 1000000000 -type chain\n./gen -m 10000 -k 0 -p 1000000000 -type star\n./gen -m 10000 -k 100 -p 100 -type balanced\n./gen -m 10000 -k 100 -p 100 -type sqrt\n./gen -m 10000 -k 10000 -p 0 -type random\n\n./gen -m 100000 -k 100000 -p 1000000000 -type chain\n./gen -m 100000 -k 0 -p 0 -type star\n./gen -m 100000 -k 50000 -p 50000 -type random\n./gen -m 100000 -k 100000 -p 500000000 -type random\n./gen -m 100000 -k 1 -p 1000000000 -type chain\n\n# Edge cases\n./gen -m 2 -k 0 -p 0 -type chain\n./gen -m 2 -k 1 -p 0 -type chain\n./gen -m 2 -k 1 -p 0 -type star\n\n# Maximal k and p\n./gen -m 100000 -k 1000000000 -p 1000000000 -type random\n\n# Random tree with varying k and p\n./gen -m 100000 -k 50000 -p 50000 -type random\n./gen -m 100000 -k 1000 -p 1000 -type random\n\n# Maximal p, minimal k\n./gen -m 100000 -k 0 -p 1000000000 -type random\n\n# Maximal k, minimal p\n./gen -m 100000 -k 100000 -p 0 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:34.680006",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "414/E",
      "title": "E. Mashmokh's Designed Problem",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line of input contains two space-separated integers n, m (2 ≤ n ≤ 105; 1 ≤ m ≤ 105), the number of vertices of T and number of queries to perform.The i-th of the following n lines contains an integer li (0 ≤ li ≤ n), number of i-th vertex's children. Then li space-separated integers follow, the j-th of them is the index of j-th child of i-th vertex. Note that the order of these vertices is important.Each of the following m lines has one of the following format: \"1 v u\", \"2 v h\", or \"3 k\". The first number in the line is the type of query to perform according to the problem statement. The next numbers are description of the query.It's guaranteed that all the queries are correct. For example, in the second-type query h is at least 2 and at most distance of v from root. Also in the third-type query there is at least one vertex with distance k from the root at the time the query is given.",
      "output_spec": "OutputFor each query of the first or third type output one line containing the result of the query.",
      "sample_tests": "ExamplesInputCopy4 91 21 31 401 1 42 4 21 3 43 13 22 3 21 1 23 13 2OutputCopy3224134InputCopy2 21 201 2 13 1OutputCopy12",
      "description": "E. Mashmokh's Designed Problem\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains two space-separated integers n, m (2 ≤ n ≤ 105; 1 ≤ m ≤ 105), the number of vertices of T and number of queries to perform.The i-th of the following n lines contains an integer li (0 ≤ li ≤ n), number of i-th vertex's children. Then li space-separated integers follow, the j-th of them is the index of j-th child of i-th vertex. Note that the order of these vertices is important.Each of the following m lines has one of the following format: \"1 v u\", \"2 v h\", or \"3 k\". The first number in the line is the type of query to perform according to the problem statement. The next numbers are description of the query.It's guaranteed that all the queries are correct. For example, in the second-type query h is at least 2 and at most distance of v from root. Also in the third-type query there is at least one vertex with distance k from the root at the time the query is given.\n\nOutputFor each query of the first or third type output one line containing the result of the query.\n\nInputCopy4 91 21 31 401 1 42 4 21 3 43 13 22 3 21 1 23 13 2OutputCopy3224134InputCopy2 21 201 2 13 1OutputCopy12\n\nInputCopy4 91 21 31 401 1 42 4 21 3 43 13 22 3 21 1 23 13 2\n\nOutputCopy3224134\n\nInputCopy2 21 201 2 13 1\n\nOutputCopy12",
      "solutions": [
        {
          "title": "Codeforces Round #240 - Codeforces",
          "content": "Hi everybody!Codeforces round #240 will take place tomorrow 19:30 MSKThis is our first round in Codeforces and we hope that everything will be fine. The problems were prepared by Amir Keivan Mohtashami(matrix), Farbod Yadegarian(FarbodY) and Gerald Agapov(Gerald). Also special thanks to Mohammad Amin Khashkhashi Moghaddam(alex-mercer) for testing this round.I want to also thank MikeMirzayanov for Polygon and Codeforces systems, and also Maria Belova(Delinur) for translating the statements.We wish you a good and challenging round.Have fun!Score distribution:div1: 500 — 1000 — 1500 — 1500 — 2500div2: 500 — 1000 — 1500 — 2000 — 2500 (standard)UPD: due to technical reasons the round was delayed for 10 minutes. We apologize for any inconvenience caused.  UPD2: Congratulations to the winners!Div 1: fqw sankear (The only one who solved problem E during the contest. Congratulations!) Egor qwerty787788 hos.lyric Div 2: jzzhu SJTU_WengJian alcot LoveEvita huyifei NiuYiqiang UPD3: The round analysis are prepared by DmitriyH. You can find them here. Also the tutorial is not completely ready yet. But you can find some notes about some of the problems here. I'll try to complete it as soon as possible.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11458",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1206
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces",
          "content": "Hi!415A - Mashmokh and LightsFor this problem for each light j you could just iterate over all pressed buttons and find the first button bi that bi < j. Then you could output bi and move to next light.  415B - Mashmokh and TokensFor this problem you can find the number of tokens you can save if you initally have k tokens in O(1). Then you can calculate the answer for all of numbers in O(n). Suppose by p. then p * b ≤ w * a. then . Suppose initially we have k tokens. Let then we need to find such maximum k0 that .So k0 will be equal to . so we can calculate k0 in O(1).414A - Mashmokh and NumbersIn each turn Bimokh will at least get one point so the result is at lease . So if the answer is -1. Let's denote . Then you could output x and 2x as the first two integers in the sequence then output consecutive integers and also one random integer(distinct from the others) if n is odd. Based on the following fact, Bimokh's point will equal to which is equal to k.. Also you must consider some corner cases such as when n = 1.414B - Mashmokh and ACMLets define dp[i][j] as number of good sequences of length i that ends in j.Let's denote divisors of j by x1, x2, ..., xl. Then This yields O(nk sqrt(n)) solution which is not fast enough. But one could use the fact that the following loops run in O(n log(n)) in order to achieve O(nk log(n)) which is fast enough to pass the tests. for (i = 1; i <= n; i++) //loop from 1 to n\n for (int j = i; j <= n; j += i) //iterating through all multiples of i that are at most n414C - Mashmokh and Reverse OperationBuild a complete binary tree with height n. So its i-th leaf corresponds to i-th element of the initial array. For each vertex v lets define its subarray as the subarray containing the elements that have a leaf corresponding to them in subtree rooted at v.For each non-leaf vertex v, suppose its left child's subarray contains elements [a..b] of the array and its right child contains elements [b + 1..c] of the array. We'll calculate two numbers for this vertex. number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai > bj and number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai < bj. We'll call the first calculated number, normal number and the other one reverse number. Calculating these numbers can be done using merge-sort algorithm in O(n  *  2n). We'll Initially write normal number for each vertex on it. We'll define a vertex's type as type of the number that is written on them. Let's define height of a vertex v equal to its distnace to the nearest leaf. Also let's define switching a vertex as switching the number written on it with the other type number(if normal number is written on it change it to reverse number and vise-versa).Initially sum of writed numbers is equal to number of inversions in the initial array. Now when query h is given, by switching all vertices with height at most h, the sum of writed numbers will become equal to the number of inversions in the new array. The only question is how to perform such query fast? One can notice that in a height h, always all of the vertices has the same type. So we can calculate two numbers for each height h. The sum of normal numbers of vertices with height h and the sum of their reverse numbers. Then instead of switching vertices in a height one by one each time, one can just switch the number for that height. The sum of numbers of heights after each query will be the answer for that query. since there are n height each query can be performed in O(n) so the total running time will be O(nq  +  n  * 2n). 414D - Mashmokh and Water TanksLet's suppose instead of a tank there is a pile at each vertex and instead of water the game is played on tiles. Let's denote distance of each vertex q from the root by depth(q). Also Let's label each tile with number of the vertex it was initially put on. Suppose initially there was a tile at each of vertices v and u and after some move tile u and v are in the same vertex's pile. Then one can prove that there were exactly |depth(v) - depth(u)| moves at which vertex containing the tile at vertex with less depth was closed and the vertex containing the other tile wasn't. Suppose after i-th move, there was xi tiles inside the root's pile and xj is the maximum among these numbers. Suppose tiles a1, a2, ...axj were on the root after j-th move. Then the other tiles that we put inside the tree at the beginning have no effect in the final result. Then we can suppose that only these tiles were initially put on tree.So we can assume that all tiles we place at the beginning will reach to the root together. Suppose hi of these tiles were put at a vertex with depth i and d1 is the maximum depth that there is at least a tile in that depth. So as to these tiles reach to the root together we must pay . Then we want to minimize the number of needed coins so at the beginning there must not be two consecutive depth i and i + 1 that i + 1 ≤ d and there is a tile at depth i and an empty vertex at depth i + 1. In other words if we denote the minimum depth that initially there is a tile inside it as d0 then there must be a tile at each vertex with depth more than d0 and less than or equal to d1. Let's iterate over d1. Then for each d1 we can calculate d2, the minimum depth that we can pay the needed price if we put a tile at each vertex with depth at least d2 and at most d1. Let's denote this needed price as p0. Then we can also put at depth d2 - 1. So we can calculate maximum number of tiles that we can put on the tree so that they all reach to root together for a fixed d1. So the maximum of these numbers for all possible d1 will be the answer.Since by increasing d1, d2 won't decrease one can use two-pointers to update d2 while iterating over d1. Let's denote number of the vertices with depth i as cnti. Then we can save and update the following values.Then the needed price is equal to (d1 * s) - t. So as long as (d1 * s) - t > p we must increase d2. This yields an O(n) solution.414E - Mashmokh's Designed ProblemLet's define the dfs-order of a tree as the sequence created by calling function dfs(root). We'll build another sequence from a dfs-order by replacing each vertex in dfs-order by '+1' and inserting a '-1' after the last vertex of its subtree. Note that all vertices of a particular subtree are a continuous part of dfs-order of that tree. Also note that for each vertex v if the +1 corresponding to it is the i-th element of sequence, then v's distance from root(which we'll denote by height of v) is equal to sum of elements 1..i.Suppose we can perform the following operations on such sequence: For each i, find sum of the elements 1..i. For each i find the biggest j(j < i) so that sum of elements 1..j of the sequence equals p. Using these two operations we can find LCA of two vertices v and u, so since distance of u and v equals to height(u) + height(v) - 2 * height(LCA(u, v)) we can answer the second query. Also the third query can be answered using the second operation described above.As for the first query it cuts a continuous part of sequence and insert it in another place. This operation can be done using implicit treap. Also we can use the treap as a segment tree to store the following values for each vertex v. Then using these values the operations described above can be done. All of these operation can be done in O(logn). Sum of the elements in its subtree(each vertex in the treap has a value equal to +1 or -1 since it corresponds to an element of the sequence.) Let's write the values of each vertex in the subtree of v in the order they appear in the sequence. Then lets denote sum of the first i numbers we wrote as ps[i] and call elements of ps, prefix sums of the subtree of v. Then we store the maximum number amongst the prefix sums. Also we'll store the minimum number amongst prefix sums.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11470",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 414\\s*E"
          },
          "content_length": 7826
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #240 - Codeforces - Code 1",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 2",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 3",
          "code": "dp[i][j] = dp[i+1][j] + dp[i+1][2*j] + ... + dp[i+1][n/j*j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 4",
          "code": "dp[n][x] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 1",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 2",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 3",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 4",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 5",
          "code": "((a*x) % b) / a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 6",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 7",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 8",
          "code": "((x * A) % B)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 9",
          "code": "number of inversion after reverse = N(N-1)/2 - number of inversion before reverse - number of pair of same element",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 10",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 11",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 12",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 13",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\n\nint n, m;\nint parent[MAXN];\nbool visited[MAXN];\nvector<int> adj[MAXN];\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    memset(parent, -1, sizeof(parent));\n\n    for (int i = 1; i <= n; ++i) {\n        int li = inf.readInt(0, n, \"li\");\n\n        if (li == 0) {\n            inf.readEoln();\n        } else {\n            inf.readSpace();\n            vector<int> children = inf.readInts(li, 1, n, \"children\");\n            inf.readEoln();\n\n            set<int> childSet;\n            for (int c : children) {\n                ensuref(c != i, \"Node %d cannot be a child of itself\", i);\n                ensuref(childSet.find(c) == childSet.end(), \"Duplicate child %d in child list of node %d\", c, i);\n                childSet.insert(c);\n\n                ensuref(parent[c] == -1, \"Node %d has more than one parent (current parent: %d, previous parent: %d)\", c, i, parent[c]);\n                parent[c] = i;\n\n                adj[i].push_back(c);\n            }\n        }\n    }\n\n    // Check that root has no parent\n    ensuref(parent[1] == -1, \"Root node 1 should have no parent\");\n\n    // Check that all nodes except root have exactly one parent\n    for (int i = 1; i <= n; ++i) {\n        if (i != 1) {\n            ensuref(parent[i] != -1, \"Node %d has no parent\", i);\n        }\n    }\n\n    // Perform DFS to check connectivity\n    memset(visited, 0, sizeof(visited));\n    dfs(1);\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Node %d is not reachable from root\", i);\n    }\n\n    for (int q = 0; q < m; ++q) {\n        int qType = inf.readInt(1, 3, \"qType\");\n        if (qType == 1) {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readSpace();\n            int u = inf.readInt(1, n, \"u\");\n            inf.readEoln();\n        } else if (qType == 2) {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readSpace();\n            int h = inf.readInt(2, n, \"h\");\n            inf.readEoln();\n        } else if (qType == 3) {\n            inf.readSpace();\n            int k = inf.readInt(0, n - 1, \"k\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\n\nint n, m;\nint parent[MAXN];\nbool visited[MAXN];\nvector<int> adj[MAXN];\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    memset(parent, -1, sizeof(parent));\n\n    for (int i = 1; i <= n; ++i) {\n        int li = inf.readInt(0, n, \"li\");\n\n        if (li == 0) {\n            inf.readEoln();\n        } else {\n            inf.readSpace();\n            vector<int> children = inf.readInts(li, 1, n, \"children\");\n            inf.readEoln();\n\n            set<int> childSet;\n            for (int c : children) {\n                ensuref(c != i, \"Node %d cannot be a child of itself\", i);\n                ensuref(childSet.find(c) == childSet.end(), \"Duplicate child %d in child list of node %d\", c, i);\n                childSet.insert(c);\n\n                ensuref(parent[c] == -1, \"Node %d has more than one parent (current parent: %d, previous parent: %d)\", c, i, parent[c]);\n                parent[c] = i;\n\n                adj[i].push_back(c);\n            }\n        }\n    }\n\n    // Check that root has no parent\n    ensuref(parent[1] == -1, \"Root node 1 should have no parent\");\n\n    // Check that all nodes except root have exactly one parent\n    for (int i = 1; i <= n; ++i) {\n        if (i != 1) {\n            ensuref(parent[i] != -1, \"Node %d has no parent\", i);\n        }\n    }\n\n    // Perform DFS to check connectivity\n    memset(visited, 0, sizeof(visited));\n    dfs(1);\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Node %d is not reachable from root\", i);\n    }\n\n    for (int q = 0; q < m; ++q) {\n        int qType = inf.readInt(1, 3, \"qType\");\n        if (qType == 1) {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readSpace();\n            int u = inf.readInt(1, n, \"u\");\n            inf.readEoln();\n        } else if (qType == 2) {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readSpace();\n            int h = inf.readInt(2, n, \"h\");\n            inf.readEoln();\n        } else if (qType == 3) {\n            inf.readSpace();\n            int k = inf.readInt(0, n - 1, \"k\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\n\nint n, m;\nint parent[MAXN];\nbool visited[MAXN];\nvector<int> adj[MAXN];\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    memset(parent, -1, sizeof(parent));\n\n    for (int i = 1; i <= n; ++i) {\n        int li = inf.readInt(0, n, \"li\");\n\n        if (li == 0) {\n            inf.readEoln();\n        } else {\n            inf.readSpace();\n            vector<int> children = inf.readInts(li, 1, n, \"children\");\n            inf.readEoln();\n\n            set<int> childSet;\n            for (int c : children) {\n                ensuref(c != i, \"Node %d cannot be a child of itself\", i);\n                ensuref(childSet.find(c) == childSet.end(), \"Duplicate child %d in child list of node %d\", c, i);\n                childSet.insert(c);\n\n                ensuref(parent[c] == -1, \"Node %d has more than one parent (current parent: %d, previous parent: %d)\", c, i, parent[c]);\n                parent[c] = i;\n\n                adj[i].push_back(c);\n            }\n        }\n    }\n\n    // Check that root has no parent\n    ensuref(parent[1] == -1, \"Root node 1 should have no parent\");\n\n    // Check that all nodes except root have exactly one parent\n    for (int i = 1; i <= n; ++i) {\n        if (i != 1) {\n            ensuref(parent[i] != -1, \"Node %d has no parent\", i);\n        }\n    }\n\n    // Perform DFS to check connectivity\n    memset(visited, 0, sizeof(visited));\n    dfs(1);\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Node %d is not reachable from root\", i);\n    }\n\n    for (int q = 0; q < m; ++q) {\n        int qType = inf.readInt(1, 3, \"qType\");\n        if (qType == 1) {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readSpace();\n            int u = inf.readInt(1, n, \"u\");\n            inf.readEoln();\n        } else if (qType == 2) {\n            inf.readSpace();\n            int v = inf.readInt(1, n, \"v\");\n            inf.readSpace();\n            int h = inf.readInt(2, n, \"h\");\n            inf.readEoln();\n        } else if (qType == 3) {\n            inf.readSpace();\n            int k = inf.readInt(0, n - 1, \"k\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint n, m;\nstring tree_type;\nint q1, q2, q3;\n\nvector<int> parent(MAXN);\nvector<vector<int>> children(MAXN);\nvector<int> depth(MAXN);\nmap<int, int> depth_counts; // depth -> count of nodes at that depth\nvector<int> nodes_with_depth_at_least_2;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    n = opt<int>(\"n\");\n    m = opt<int>(\"m\");\n    tree_type = opt<string>(\"tree_type\", \"random\");\n\n    q1 = opt<int>(\"q1\", -1);\n    q2 = opt<int>(\"q2\", -1);\n    q3 = opt<int>(\"q3\", -1);\n\n    // Handle query counts\n    if (q1 == -1 || q2 == -1 || q3 == -1) {\n        // Distribute equally\n        int per_type = m / 3;\n        q1 = per_type;\n        q2 = per_type;\n        q3 = per_type;\n        int rem = m - (q1 + q2 + q3);\n        for (int i = 0; i < rem; ++i) {\n            int t = rnd.next(1, 3);\n            if (t == 1) q1++;\n            else if (t == 2) q2++;\n            else q3++;\n        }\n    }\n    if (q1 + q2 + q3 != m) {\n        cerr << \"Error: q1 + q2 + q3 does not equal m\\n\";\n        return 1;\n    }\n\n    // Build initial tree according to tree_type\n    // Initialize parent[], children[], depth[]\n    parent.assign(n + 1, 0);\n    children.assign(n + 1, vector<int>());\n    depth.assign(n + 1, 0);\n    depth_counts.clear();\n    nodes_with_depth_at_least_2.clear();\n\n    if (tree_type == \"chain\") {\n        // Each node i > 1 is parent of i+1\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n            children[i - 1].push_back(i);\n            depth[i] = depth[i - 1] + 1;\n            depth_counts[depth[i]]++;\n            if (depth[i] >= 2) {\n                nodes_with_depth_at_least_2.push_back(i);\n            }\n        }\n    } else if (tree_type == \"star\") {\n        // Node 1 is parent of all other nodes\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n            children[1].push_back(i);\n            depth[i] = depth[1] + 1;\n            depth_counts[depth[i]]++;\n            if (depth[i] >= 2) {\n                nodes_with_depth_at_least_2.push_back(i);\n            }\n        }\n    } else if (tree_type == \"random\") {\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n            children[parent[i]].push_back(i);\n        }\n        // Compute depths\n        queue<int> q;\n        depth[1] = 0;\n        depth_counts[0]++;\n        q.push(1);\n        while (!q.empty()) {\n            int u = q.front(); q.pop();\n            for (int v : children[u]) {\n                depth[v] = depth[u] + 1;\n                depth_counts[depth[v]]++;\n                if (depth[v] >= 2) {\n                    nodes_with_depth_at_least_2.push_back(v);\n                }\n                q.push(v);\n            }\n        }\n    } else if (tree_type == \"balanced\") {\n        // Build a balanced binary tree\n        vector<int> current_level = {1};\n        int idx = 2;\n        depth[1] = 0;\n        depth_counts[0]++;\n        while (idx <= n) {\n            vector<int> next_level;\n            for (int u : current_level) {\n                if (idx <= n) {\n                    parent[idx] = u;\n                    children[u].push_back(idx);\n                    depth[idx] = depth[u] + 1;\n                    depth_counts[depth[idx]]++;\n                    if (depth[idx] >= 2) {\n                        nodes_with_depth_at_least_2.push_back(idx);\n                    }\n                    next_level.push_back(idx);\n                    idx++;\n                }\n                if (idx <= n) {\n                    parent[idx] = u;\n                    children[u].push_back(idx);\n                    depth[idx] = depth[u] + 1;\n                    depth_counts[depth[idx]]++;\n                    if (depth[idx] >= 2) {\n                        nodes_with_depth_at_least_2.push_back(idx);\n                    }\n                    next_level.push_back(idx);\n                    idx++;\n                }\n            }\n            current_level = next_level;\n        }\n    } else {\n        cerr << \"Error: unknown tree type\\n\";\n        return 1;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output tree\n    for (int i = 1; i <= n; ++i) {\n        int li = children[i].size();\n        printf(\"%d\", li);\n        for (int v : children[i]) {\n            printf(\" %d\", v);\n        }\n        printf(\"\\n\");\n    }\n\n    // Prepare query types\n    vector<int> queryTypes;\n    for (int i = 0; i < q1; ++i) queryTypes.push_back(1);\n    for (int i = 0; i < q2; ++i) queryTypes.push_back(2);\n    for (int i = 0; i < q3; ++i) queryTypes.push_back(3);\n    shuffle(queryTypes.begin(), queryTypes.end());\n\n    // Prepare to generate queries\n    for (int i = 0; i < m; ++i) {\n        int type = queryTypes[i];\n        if (type == 1) {\n            // Type 1 query: \"1 u v\"\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            printf(\"1 %d %d\\n\", u, v);\n        } else if (type == 2) {\n            // Type 2 query: \"2 v h\"\n            if (nodes_with_depth_at_least_2.empty()) {\n                // No nodes with depth >= 2, cannot generate valid type 2 query\n                // Instead, generate a type 1 query\n                int u = rnd.next(1, n);\n                int v = rnd.next(1, n);\n                printf(\"1 %d %d\\n\", u, v);\n                continue;\n            }\n            int idx = rnd.next((int)nodes_with_depth_at_least_2.size());\n            int v = nodes_with_depth_at_least_2[idx];\n            int h = rnd.next(2, depth[v]);\n            // Find h-th ancestor of v\n            int u = v;\n            for (int j = 0; j < h - 1; ++j) {\n                u = parent[u];\n            }\n            int new_parent = parent[u];\n            // Remove v from its current parent's children\n            int old_parent = parent[v];\n            auto& siblings = children[old_parent];\n            siblings.erase(remove(siblings.begin(), siblings.end(), v), siblings.end());\n            // Add v to new parent's children (at the end)\n            children[new_parent].push_back(v);\n            // Update parent[v]\n            parent[v] = new_parent;\n            // Update depths and depth_counts\n            int old_depth = depth[v];\n            int depth_delta = depth[new_parent] + 1 - depth[v];\n            queue<int> q;\n            q.push(v);\n            while (!q.empty()) {\n                int u = q.front(); q.pop();\n                depth_counts[depth[u]]--;\n                depth[u] += depth_delta;\n                depth_counts[depth[u]]++;\n                if (depth[u] >=2 && depth[u]-depth_delta <2) {\n                    nodes_with_depth_at_least_2.push_back(u);\n                } else if (depth[u] < 2 && depth[u]-depth_delta >=2) {\n                    // Remove u from nodes_with_depth_at_least_2\n                    nodes_with_depth_at_least_2.erase(remove(nodes_with_depth_at_least_2.begin(), nodes_with_depth_at_least_2.end(), u), nodes_with_depth_at_least_2.end());\n                }\n                for (int child : children[u]) {\n                    q.push(child);\n                }\n            }\n            // Output the query\n            printf(\"2 %d %d\\n\", v, h);\n        } else if (type == 3) {\n            // Type 3 query: \"3 k\"\n            if (depth_counts.empty()) {\n                // No depths available, generate type 1 query\n                int u = rnd.next(1, n);\n                int v = rnd.next(1, n);\n                printf(\"1 %d %d\\n\", u, v);\n                continue;\n            }\n            // Collect depths with non-zero counts\n            vector<int> depths_available;\n            for (auto& p : depth_counts) {\n                if (p.second > 0) {\n                    depths_available.push_back(p.first);\n                }\n            }\n            int idx = rnd.next((int)depths_available.size());\n            int k = depths_available[idx];\n            printf(\"3 %d\\n\", k);\n        } else {\n            cerr << \"Error: unknown query type\\n\";\n            return 1;\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint n, m;\nstring tree_type;\nint q1, q2, q3;\n\nvector<int> parent(MAXN);\nvector<vector<int>> children(MAXN);\nvector<int> depth(MAXN);\nmap<int, int> depth_counts; // depth -> count of nodes at that depth\nvector<int> nodes_with_depth_at_least_2;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    n = opt<int>(\"n\");\n    m = opt<int>(\"m\");\n    tree_type = opt<string>(\"tree_type\", \"random\");\n\n    q1 = opt<int>(\"q1\", -1);\n    q2 = opt<int>(\"q2\", -1);\n    q3 = opt<int>(\"q3\", -1);\n\n    // Handle query counts\n    if (q1 == -1 || q2 == -1 || q3 == -1) {\n        // Distribute equally\n        int per_type = m / 3;\n        q1 = per_type;\n        q2 = per_type;\n        q3 = per_type;\n        int rem = m - (q1 + q2 + q3);\n        for (int i = 0; i < rem; ++i) {\n            int t = rnd.next(1, 3);\n            if (t == 1) q1++;\n            else if (t == 2) q2++;\n            else q3++;\n        }\n    }\n    if (q1 + q2 + q3 != m) {\n        cerr << \"Error: q1 + q2 + q3 does not equal m\\n\";\n        return 1;\n    }\n\n    // Build initial tree according to tree_type\n    // Initialize parent[], children[], depth[]\n    parent.assign(n + 1, 0);\n    children.assign(n + 1, vector<int>());\n    depth.assign(n + 1, 0);\n    depth_counts.clear();\n    nodes_with_depth_at_least_2.clear();\n\n    if (tree_type == \"chain\") {\n        // Each node i > 1 is parent of i+1\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n            children[i - 1].push_back(i);\n            depth[i] = depth[i - 1] + 1;\n            depth_counts[depth[i]]++;\n            if (depth[i] >= 2) {\n                nodes_with_depth_at_least_2.push_back(i);\n            }\n        }\n    } else if (tree_type == \"star\") {\n        // Node 1 is parent of all other nodes\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n            children[1].push_back(i);\n            depth[i] = depth[1] + 1;\n            depth_counts[depth[i]]++;\n            if (depth[i] >= 2) {\n                nodes_with_depth_at_least_2.push_back(i);\n            }\n        }\n    } else if (tree_type == \"random\") {\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n            children[parent[i]].push_back(i);\n        }\n        // Compute depths\n        queue<int> q;\n        depth[1] = 0;\n        depth_counts[0]++;\n        q.push(1);\n        while (!q.empty()) {\n            int u = q.front(); q.pop();\n            for (int v : children[u]) {\n                depth[v] = depth[u] + 1;\n                depth_counts[depth[v]]++;\n                if (depth[v] >= 2) {\n                    nodes_with_depth_at_least_2.push_back(v);\n                }\n                q.push(v);\n            }\n        }\n    } else if (tree_type == \"balanced\") {\n        // Build a balanced binary tree\n        vector<int> current_level = {1};\n        int idx = 2;\n        depth[1] = 0;\n        depth_counts[0]++;\n        while (idx <= n) {\n            vector<int> next_level;\n            for (int u : current_level) {\n                if (idx <= n) {\n                    parent[idx] = u;\n                    children[u].push_back(idx);\n                    depth[idx] = depth[u] + 1;\n                    depth_counts[depth[idx]]++;\n                    if (depth[idx] >= 2) {\n                        nodes_with_depth_at_least_2.push_back(idx);\n                    }\n                    next_level.push_back(idx);\n                    idx++;\n                }\n                if (idx <= n) {\n                    parent[idx] = u;\n                    children[u].push_back(idx);\n                    depth[idx] = depth[u] + 1;\n                    depth_counts[depth[idx]]++;\n                    if (depth[idx] >= 2) {\n                        nodes_with_depth_at_least_2.push_back(idx);\n                    }\n                    next_level.push_back(idx);\n                    idx++;\n                }\n            }\n            current_level = next_level;\n        }\n    } else {\n        cerr << \"Error: unknown tree type\\n\";\n        return 1;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output tree\n    for (int i = 1; i <= n; ++i) {\n        int li = children[i].size();\n        printf(\"%d\", li);\n        for (int v : children[i]) {\n            printf(\" %d\", v);\n        }\n        printf(\"\\n\");\n    }\n\n    // Prepare query types\n    vector<int> queryTypes;\n    for (int i = 0; i < q1; ++i) queryTypes.push_back(1);\n    for (int i = 0; i < q2; ++i) queryTypes.push_back(2);\n    for (int i = 0; i < q3; ++i) queryTypes.push_back(3);\n    shuffle(queryTypes.begin(), queryTypes.end());\n\n    // Prepare to generate queries\n    for (int i = 0; i < m; ++i) {\n        int type = queryTypes[i];\n        if (type == 1) {\n            // Type 1 query: \"1 u v\"\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            printf(\"1 %d %d\\n\", u, v);\n        } else if (type == 2) {\n            // Type 2 query: \"2 v h\"\n            if (nodes_with_depth_at_least_2.empty()) {\n                // No nodes with depth >= 2, cannot generate valid type 2 query\n                // Instead, generate a type 1 query\n                int u = rnd.next(1, n);\n                int v = rnd.next(1, n);\n                printf(\"1 %d %d\\n\", u, v);\n                continue;\n            }\n            int idx = rnd.next((int)nodes_with_depth_at_least_2.size());\n            int v = nodes_with_depth_at_least_2[idx];\n            int h = rnd.next(2, depth[v]);\n            // Find h-th ancestor of v\n            int u = v;\n            for (int j = 0; j < h - 1; ++j) {\n                u = parent[u];\n            }\n            int new_parent = parent[u];\n            // Remove v from its current parent's children\n            int old_parent = parent[v];\n            auto& siblings = children[old_parent];\n            siblings.erase(remove(siblings.begin(), siblings.end(), v), siblings.end());\n            // Add v to new parent's children (at the end)\n            children[new_parent].push_back(v);\n            // Update parent[v]\n            parent[v] = new_parent;\n            // Update depths and depth_counts\n            int old_depth = depth[v];\n            int depth_delta = depth[new_parent] + 1 - depth[v];\n            queue<int> q;\n            q.push(v);\n            while (!q.empty()) {\n                int u = q.front(); q.pop();\n                depth_counts[depth[u]]--;\n                depth[u] += depth_delta;\n                depth_counts[depth[u]]++;\n                if (depth[u] >=2 && depth[u]-depth_delta <2) {\n                    nodes_with_depth_at_least_2.push_back(u);\n                } else if (depth[u] < 2 && depth[u]-depth_delta >=2) {\n                    // Remove u from nodes_with_depth_at_least_2\n                    nodes_with_depth_at_least_2.erase(remove(nodes_with_depth_at_least_2.begin(), nodes_with_depth_at_least_2.end(), u), nodes_with_depth_at_least_2.end());\n                }\n                for (int child : children[u]) {\n                    q.push(child);\n                }\n            }\n            // Output the query\n            printf(\"2 %d %d\\n\", v, h);\n        } else if (type == 3) {\n            // Type 3 query: \"3 k\"\n            if (depth_counts.empty()) {\n                // No depths available, generate type 1 query\n                int u = rnd.next(1, n);\n                int v = rnd.next(1, n);\n                printf(\"1 %d %d\\n\", u, v);\n                continue;\n            }\n            // Collect depths with non-zero counts\n            vector<int> depths_available;\n            for (auto& p : depth_counts) {\n                if (p.second > 0) {\n                    depths_available.push_back(p.first);\n                }\n            }\n            int idx = rnd.next((int)depths_available.size());\n            int k = depths_available[idx];\n            printf(\"3 %d\\n\", k);\n        } else {\n            cerr << \"Error: unknown query type\\n\";\n            return 1;\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and m, chain tree, equal queries\n./gen -n 10 -m 20 -tree_type chain\n\n# Small n and m, random tree, more type 2 queries\n./gen -n 10 -m 20 -tree_type random -q1 5 -q2 10 -q3 5\n\n# Small n and m, star tree, no type 2 queries\n./gen -n 10 -m 20 -tree_type star -q1 10 -q2 0 -q3 10\n\n# Medium n and m, balanced tree, equal queries\n./gen -n 1000 -m 1000 -tree_type balanced\n\n# Medium n and m, random tree, more type 3 queries\n./gen -n 1000 -m 1000 -tree_type random -q1 200 -q2 200 -q3 600\n\n# Large n and m, chain tree, mostly type 2 queries\n./gen -n 100000 -m 100000 -tree_type chain -q1 10000 -q2 80000 -q3 10000\n\n# Large n and m, random tree, equal queries\n./gen -n 100000 -m 100000 -tree_type random\n\n# Large n and m, balanced tree, more type 1 queries\n./gen -n 100000 -m 100000 -tree_type balanced -q1 70000 -q2 15000 -q3 15000\n\n# Large n and m, star tree, all type 1 queries\n./gen -n 100000 -m 100000 -tree_type star -q1 100000 -q2 0 -q3 0\n\n# Large n and m, unbalanced tree, equal queries\n./gen -n 100000 -m 100000 -tree_type chain\n\n# Small n, large m, chain tree\n./gen -n 50 -m 100000 -tree_type chain\n\n# Large n, small m, random tree\n./gen -n 100000 -m 10 -tree_type random\n\n# Medium n and m, random tree, random queries\n./gen -n 5000 -m 5000 -tree_type random\n\n# Medium n, m zero, chain tree\n./gen -n 5000 -m 0 -tree_type chain\n\n# Max n and m, random tree, equal queries\n./gen -n 100000 -m 100000 -tree_type random\n\n# Max n and m, chain tree, more type 3 queries\n./gen -n 100000 -m 100000 -tree_type chain -q1 10000 -q2 10000 -q3 80000\n\n# Medium n and m, star tree, only type 1 and 3 queries\n./gen -n 5000 -m 5000 -tree_type star -q1 2500 -q2 0 -q3 2500\n\n# Small n and m, balanced tree, only type 2 queries\n./gen -n 1000 -m 1000 -tree_type balanced -q1 0 -q2 1000 -q3 0\n\n# Max n and m, balanced tree, only type 3 queries\n./gen -n 100000 -m 100000 -tree_type balanced -q1 0 -q2 0 -q3 100000\n\n# Large n, m equals n, random tree, random queries\n./gen -n 100000 -m 100000 -tree_type random\n\n# Min n and m, chain tree\n./gen -n 2 -m 1 -tree_type chain\n\n# Small n and m, chain tree, only type 1 queries\n./gen -n 50 -m 50 -tree_type chain -q1 50 -q2 0 -q3 0\n\n# Medium n and m, random tree, only type 2 queries\n./gen -n 5000 -m 5000 -tree_type random -q1 0 -q2 5000 -q3 0\n\n# Max n and m, chain tree, only type 2 queries\n./gen -n 100000 -m 100000 -tree_type chain -q1 0 -q2 100000 -q3 0\n\n# Large n and m, chain tree, only type 3 queries\n./gen -n 100000 -m 100000 -tree_type chain -q1 0 -q2 0 -q3 100000\n\n# Edge case: n = 2, m = 2, only type 1 and 3 queries\n./gen -n 2 -m 2 -tree_type chain -q1 1 -q2 0 -q3 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:36.829546",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "415/A",
      "title": "A. Mashmokh and Lights",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two space-separated integers n and m (1 ≤ n, m ≤ 100), the number of the factory lights and the pushed buttons respectively. The next line contains m distinct space-separated integers b1, b2, ..., bm (1 ≤ bi ≤ n).It is guaranteed that all lights will be turned off after pushing all buttons.",
      "output_spec": "OutputOutput n space-separated integers where the i-th number is index of the button that turns the i-th light off.",
      "sample_tests": "ExamplesInputCopy5 44 3 1 2OutputCopy1 1 3 4 4 InputCopy5 55 4 3 2 1OutputCopy1 2 3 4 5",
      "description": "A. Mashmokh and Lights\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains two space-separated integers n and m (1 ≤ n, m ≤ 100), the number of the factory lights and the pushed buttons respectively. The next line contains m distinct space-separated integers b1, b2, ..., bm (1 ≤ bi ≤ n).It is guaranteed that all lights will be turned off after pushing all buttons.\n\nOutputOutput n space-separated integers where the i-th number is index of the button that turns the i-th light off.\n\nInputCopy5 44 3 1 2OutputCopy1 1 3 4 4 InputCopy5 55 4 3 2 1OutputCopy1 2 3 4 5\n\nInputCopy5 44 3 1 2\n\nOutputCopy1 1 3 4 4\n\nInputCopy5 55 4 3 2 1\n\nOutputCopy1 2 3 4 5\n\nNoteIn the first sample, after pressing button number 4, lights 4 and 5 are turned off and lights 1, 2 and 3 are still on. Then after pressing button number 3, light number 3 is turned off as well. Pressing button number 1 turns off lights number 1 and 2 as well so pressing button number 2 in the end has no effect. Thus button number 4 turned lights 4 and 5 off, button number 3 turned light 3 off and button number 1 turned light 1 and 2 off.",
      "solutions": [
        {
          "title": "Codeforces Round #240 - Codeforces",
          "content": "Hi everybody!Codeforces round #240 will take place tomorrow 19:30 MSKThis is our first round in Codeforces and we hope that everything will be fine. The problems were prepared by Amir Keivan Mohtashami(matrix), Farbod Yadegarian(FarbodY) and Gerald Agapov(Gerald). Also special thanks to Mohammad Amin Khashkhashi Moghaddam(alex-mercer) for testing this round.I want to also thank MikeMirzayanov for Polygon and Codeforces systems, and also Maria Belova(Delinur) for translating the statements.We wish you a good and challenging round.Have fun!Score distribution:div1: 500 — 1000 — 1500 — 1500 — 2500div2: 500 — 1000 — 1500 — 2000 — 2500 (standard)UPD: due to technical reasons the round was delayed for 10 minutes. We apologize for any inconvenience caused.  UPD2: Congratulations to the winners!Div 1: fqw sankear (The only one who solved problem E during the contest. Congratulations!) Egor qwerty787788 hos.lyric Div 2: jzzhu SJTU_WengJian alcot LoveEvita huyifei NiuYiqiang UPD3: The round analysis are prepared by DmitriyH. You can find them here. Also the tutorial is not completely ready yet. But you can find some notes about some of the problems here. I'll try to complete it as soon as possible.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11458",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1206
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces",
          "content": "Hi!415A - Mashmokh and LightsFor this problem for each light j you could just iterate over all pressed buttons and find the first button bi that bi < j. Then you could output bi and move to next light.  415B - Mashmokh and TokensFor this problem you can find the number of tokens you can save if you initally have k tokens in O(1). Then you can calculate the answer for all of numbers in O(n). Suppose by p. then p * b ≤ w * a. then . Suppose initially we have k tokens. Let then we need to find such maximum k0 that .So k0 will be equal to . so we can calculate k0 in O(1).414A - Mashmokh and NumbersIn each turn Bimokh will at least get one point so the result is at lease . So if the answer is -1. Let's denote . Then you could output x and 2x as the first two integers in the sequence then output consecutive integers and also one random integer(distinct from the others) if n is odd. Based on the following fact, Bimokh's point will equal to which is equal to k.. Also you must consider some corner cases such as when n = 1.414B - Mashmokh and ACMLets define dp[i][j] as number of good sequences of length i that ends in j.Let's denote divisors of j by x1, x2, ..., xl. Then This yields O(nk sqrt(n)) solution which is not fast enough. But one could use the fact that the following loops run in O(n log(n)) in order to achieve O(nk log(n)) which is fast enough to pass the tests. for (i = 1; i <= n; i++) //loop from 1 to n\n for (int j = i; j <= n; j += i) //iterating through all multiples of i that are at most n414C - Mashmokh and Reverse OperationBuild a complete binary tree with height n. So its i-th leaf corresponds to i-th element of the initial array. For each vertex v lets define its subarray as the subarray containing the elements that have a leaf corresponding to them in subtree rooted at v.For each non-leaf vertex v, suppose its left child's subarray contains elements [a..b] of the array and its right child contains elements [b + 1..c] of the array. We'll calculate two numbers for this vertex. number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai > bj and number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai < bj. We'll call the first calculated number, normal number and the other one reverse number. Calculating these numbers can be done using merge-sort algorithm in O(n  *  2n). We'll Initially write normal number for each vertex on it. We'll define a vertex's type as type of the number that is written on them. Let's define height of a vertex v equal to its distnace to the nearest leaf. Also let's define switching a vertex as switching the number written on it with the other type number(if normal number is written on it change it to reverse number and vise-versa).Initially sum of writed numbers is equal to number of inversions in the initial array. Now when query h is given, by switching all vertices with height at most h, the sum of writed numbers will become equal to the number of inversions in the new array. The only question is how to perform such query fast? One can notice that in a height h, always all of the vertices has the same type. So we can calculate two numbers for each height h. The sum of normal numbers of vertices with height h and the sum of their reverse numbers. Then instead of switching vertices in a height one by one each time, one can just switch the number for that height. The sum of numbers of heights after each query will be the answer for that query. since there are n height each query can be performed in O(n) so the total running time will be O(nq  +  n  * 2n). 414D - Mashmokh and Water TanksLet's suppose instead of a tank there is a pile at each vertex and instead of water the game is played on tiles. Let's denote distance of each vertex q from the root by depth(q). Also Let's label each tile with number of the vertex it was initially put on. Suppose initially there was a tile at each of vertices v and u and after some move tile u and v are in the same vertex's pile. Then one can prove that there were exactly |depth(v) - depth(u)| moves at which vertex containing the tile at vertex with less depth was closed and the vertex containing the other tile wasn't. Suppose after i-th move, there was xi tiles inside the root's pile and xj is the maximum among these numbers. Suppose tiles a1, a2, ...axj were on the root after j-th move. Then the other tiles that we put inside the tree at the beginning have no effect in the final result. Then we can suppose that only these tiles were initially put on tree.So we can assume that all tiles we place at the beginning will reach to the root together. Suppose hi of these tiles were put at a vertex with depth i and d1 is the maximum depth that there is at least a tile in that depth. So as to these tiles reach to the root together we must pay . Then we want to minimize the number of needed coins so at the beginning there must not be two consecutive depth i and i + 1 that i + 1 ≤ d and there is a tile at depth i and an empty vertex at depth i + 1. In other words if we denote the minimum depth that initially there is a tile inside it as d0 then there must be a tile at each vertex with depth more than d0 and less than or equal to d1. Let's iterate over d1. Then for each d1 we can calculate d2, the minimum depth that we can pay the needed price if we put a tile at each vertex with depth at least d2 and at most d1. Let's denote this needed price as p0. Then we can also put at depth d2 - 1. So we can calculate maximum number of tiles that we can put on the tree so that they all reach to root together for a fixed d1. So the maximum of these numbers for all possible d1 will be the answer.Since by increasing d1, d2 won't decrease one can use two-pointers to update d2 while iterating over d1. Let's denote number of the vertices with depth i as cnti. Then we can save and update the following values.Then the needed price is equal to (d1 * s) - t. So as long as (d1 * s) - t > p we must increase d2. This yields an O(n) solution.414E - Mashmokh's Designed ProblemLet's define the dfs-order of a tree as the sequence created by calling function dfs(root). We'll build another sequence from a dfs-order by replacing each vertex in dfs-order by '+1' and inserting a '-1' after the last vertex of its subtree. Note that all vertices of a particular subtree are a continuous part of dfs-order of that tree. Also note that for each vertex v if the +1 corresponding to it is the i-th element of sequence, then v's distance from root(which we'll denote by height of v) is equal to sum of elements 1..i.Suppose we can perform the following operations on such sequence: For each i, find sum of the elements 1..i. For each i find the biggest j(j < i) so that sum of elements 1..j of the sequence equals p. Using these two operations we can find LCA of two vertices v and u, so since distance of u and v equals to height(u) + height(v) - 2 * height(LCA(u, v)) we can answer the second query. Also the third query can be answered using the second operation described above.As for the first query it cuts a continuous part of sequence and insert it in another place. This operation can be done using implicit treap. Also we can use the treap as a segment tree to store the following values for each vertex v. Then using these values the operations described above can be done. All of these operation can be done in O(logn). Sum of the elements in its subtree(each vertex in the treap has a value equal to +1 or -1 since it corresponds to an element of the sequence.) Let's write the values of each vertex in the subtree of v in the order they appear in the sequence. Then lets denote sum of the first i numbers we wrote as ps[i] and call elements of ps, prefix sums of the subtree of v. Then we store the maximum number amongst the prefix sums. Also we'll store the minimum number amongst prefix sums.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11470",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 415\\s*A"
          },
          "content_length": 7826
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #240 - Codeforces - Code 1",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 2",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 3",
          "code": "dp[i][j] = dp[i+1][j] + dp[i+1][2*j] + ... + dp[i+1][n/j*j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 4",
          "code": "dp[n][x] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 1",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 2",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 3",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 4",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 5",
          "code": "((a*x) % b) / a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 6",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 7",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 8",
          "code": "((x * A) % B)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 9",
          "code": "number of inversion after reverse = N(N-1)/2 - number of inversion before reverse - number of pair of same element",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 10",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 11",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 12",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 13",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> buttons = inf.readInts(m, 1, n, \"b_i\");\n    inf.readEoln();\n\n    // Check that buttons are distinct\n    {\n        set<int> s(buttons.begin(), buttons.end());\n        ensuref((int)s.size() == m, \"Buttons must be distinct\");\n    }\n\n    // Initialize lights as on\n    vector<bool> lights(n + 1, true); // index from 1 to n\n\n    // Simulate the process\n    for (int btn : buttons) {\n        for (int i = btn; i <= n; ++i) {\n            lights[i] = false;\n        }\n    }\n\n    // Check that all lights are off\n    for (int i = 1; i <= n; ++i) {\n        ensuref(!lights[i], \"All lights must be turned off after pressing the buttons\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> buttons = inf.readInts(m, 1, n, \"b_i\");\n    inf.readEoln();\n\n    // Check that buttons are distinct\n    {\n        set<int> s(buttons.begin(), buttons.end());\n        ensuref((int)s.size() == m, \"Buttons must be distinct\");\n    }\n\n    // Initialize lights as on\n    vector<bool> lights(n + 1, true); // index from 1 to n\n\n    // Simulate the process\n    for (int btn : buttons) {\n        for (int i = btn; i <= n; ++i) {\n            lights[i] = false;\n        }\n    }\n\n    // Check that all lights are off\n    for (int i = 1; i <= n; ++i) {\n        ensuref(!lights[i], \"All lights must be turned off after pressing the buttons\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> buttons = inf.readInts(m, 1, n, \"b_i\");\n    inf.readEoln();\n\n    // Check that buttons are distinct\n    {\n        set<int> s(buttons.begin(), buttons.end());\n        ensuref((int)s.size() == m, \"Buttons must be distinct\");\n    }\n\n    // Initialize lights as on\n    vector<bool> lights(n + 1, true); // index from 1 to n\n\n    // Simulate the process\n    for (int btn : buttons) {\n        for (int i = btn; i <= n; ++i) {\n            lights[i] = false;\n        }\n    }\n\n    // Check that all lights are off\n    for (int i = 1; i <= n; ++i) {\n        ensuref(!lights[i], \"All lights must be turned off after pressing the buttons\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int m;\n\n    vector<int> buttons;\n\n    if (type == \"minimal\") {\n\n        m = 1;\n        buttons.push_back(1);\n\n    } else if (type == \"maximal\") {\n\n        m = n;\n        for (int i = 1; i <= n; ++i)\n            buttons.push_back(i);\n\n    } else if (type == \"increasing\") {\n\n        m = n;\n        for (int i = 1; i <= n; ++i)\n            buttons.push_back(i);\n\n    } else if (type == \"decreasing\") {\n\n        m = n;\n        for (int i = n; i >= 1; --i)\n            buttons.push_back(i);\n\n    } else if (type == \"random\") {\n\n        m = opt<int>(\"m\", n);\n\n        while (true) {\n\n            buttons.clear();\n\n            // Generate m distinct bi between 1 and n\n            set<int> bi_set;\n            while ((int)bi_set.size() < m)\n                bi_set.insert(rnd.next(1, n));\n\n            buttons.assign(bi_set.begin(), bi_set.end());\n\n            // Shuffle buttons to randomize order\n            shuffle(buttons.begin(), buttons.end());\n\n            // Build the union of ranges [bi, n]\n            vector<bool> lights(n + 1, false); // index from 1 to n\n\n            for (int bi : buttons)\n                for (int i = bi; i <= n; ++i)\n                    lights[i] = true;\n\n            // Check if all lights are covered\n            bool all_covered = true;\n            for (int i = 1; i <= n; ++i)\n                if (!lights[i]) {\n                    all_covered = false;\n                    break;\n                }\n\n            if (all_covered)\n                break;\n\n            // Try again\n        }\n\n    } else {\n\n        // Unknown type, error\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        return 1;\n\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)buttons.size());\n\n    // Output the buttons pressed, in order\n    for (int i = 0; i < (int)buttons.size(); ++i) {\n        if (i > 0)\n            printf(\" \");\n        printf(\"%d\", buttons[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int m;\n\n    vector<int> buttons;\n\n    if (type == \"minimal\") {\n\n        m = 1;\n        buttons.push_back(1);\n\n    } else if (type == \"maximal\") {\n\n        m = n;\n        for (int i = 1; i <= n; ++i)\n            buttons.push_back(i);\n\n    } else if (type == \"increasing\") {\n\n        m = n;\n        for (int i = 1; i <= n; ++i)\n            buttons.push_back(i);\n\n    } else if (type == \"decreasing\") {\n\n        m = n;\n        for (int i = n; i >= 1; --i)\n            buttons.push_back(i);\n\n    } else if (type == \"random\") {\n\n        m = opt<int>(\"m\", n);\n\n        while (true) {\n\n            buttons.clear();\n\n            // Generate m distinct bi between 1 and n\n            set<int> bi_set;\n            while ((int)bi_set.size() < m)\n                bi_set.insert(rnd.next(1, n));\n\n            buttons.assign(bi_set.begin(), bi_set.end());\n\n            // Shuffle buttons to randomize order\n            shuffle(buttons.begin(), buttons.end());\n\n            // Build the union of ranges [bi, n]\n            vector<bool> lights(n + 1, false); // index from 1 to n\n\n            for (int bi : buttons)\n                for (int i = bi; i <= n; ++i)\n                    lights[i] = true;\n\n            // Check if all lights are covered\n            bool all_covered = true;\n            for (int i = 1; i <= n; ++i)\n                if (!lights[i]) {\n                    all_covered = false;\n                    break;\n                }\n\n            if (all_covered)\n                break;\n\n            // Try again\n        }\n\n    } else {\n\n        // Unknown type, error\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        return 1;\n\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)buttons.size());\n\n    // Output the buttons pressed, in order\n    for (int i = 0; i < (int)buttons.size(); ++i) {\n        if (i > 0)\n            printf(\" \");\n        printf(\"%d\", buttons[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type minimal\n./gen -n 1 -type maximal\n./gen -n 1 -type random\n./gen -n 1 -type increasing\n./gen -n 1 -type decreasing\n\n./gen -n 10 -type minimal\n./gen -n 10 -type maximal\n./gen -n 10 -type random\n./gen -n 10 -m 5 -type random\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n\n./gen -n 50 -type minimal\n./gen -n 50 -type maximal\n./gen -n 50 -m 25 -type random\n./gen -n 50 -m 30 -type random\n./gen -n 50 -type increasing\n./gen -n 50 -type decreasing\n\n./gen -n 100 -type minimal\n./gen -n 100 -type maximal\n./gen -n 100 -m 50 -type random\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 20 -type random\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n\n./gen -n 100 -m 1 -type random\n./gen -n 100 -m 99 -type random\n\n./gen -n 2 -m 2 -type random\n./gen -n 2 -m 1 -type random\n\n./gen -n 3 -m 2 -type random\n./gen -n 3 -type minimal\n./gen -n 3 -type maximal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:38.549589",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "415/B",
      "title": "B. Mashmokh and Tokens",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains three space-separated integers n, a, b (1 ≤ n ≤ 105; 1 ≤ a, b ≤ 109). The second line of input contains n space-separated integers x1, x2, ..., xn (1 ≤ xi ≤ 109).",
      "output_spec": "OutputOutput n space-separated integers. The i-th of them is the number of tokens Mashmokh can save on the i-th day.",
      "sample_tests": "ExamplesInputCopy5 1 412 6 11 9 1OutputCopy0 2 3 1 1 InputCopy3 1 21 2 3OutputCopy1 0 1 InputCopy1 1 11OutputCopy0",
      "description": "B. Mashmokh and Tokens\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains three space-separated integers n, a, b (1 ≤ n ≤ 105; 1 ≤ a, b ≤ 109). The second line of input contains n space-separated integers x1, x2, ..., xn (1 ≤ xi ≤ 109).\n\nOutputOutput n space-separated integers. The i-th of them is the number of tokens Mashmokh can save on the i-th day.\n\nInputCopy5 1 412 6 11 9 1OutputCopy0 2 3 1 1 InputCopy3 1 21 2 3OutputCopy1 0 1 InputCopy1 1 11OutputCopy0\n\nInputCopy5 1 412 6 11 9 1\n\nOutputCopy0 2 3 1 1\n\nInputCopy3 1 21 2 3\n\nOutputCopy1 0 1\n\nInputCopy1 1 11\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #240 - Codeforces",
          "content": "Hi everybody!Codeforces round #240 will take place tomorrow 19:30 MSKThis is our first round in Codeforces and we hope that everything will be fine. The problems were prepared by Amir Keivan Mohtashami(matrix), Farbod Yadegarian(FarbodY) and Gerald Agapov(Gerald). Also special thanks to Mohammad Amin Khashkhashi Moghaddam(alex-mercer) for testing this round.I want to also thank MikeMirzayanov for Polygon and Codeforces systems, and also Maria Belova(Delinur) for translating the statements.We wish you a good and challenging round.Have fun!Score distribution:div1: 500 — 1000 — 1500 — 1500 — 2500div2: 500 — 1000 — 1500 — 2000 — 2500 (standard)UPD: due to technical reasons the round was delayed for 10 minutes. We apologize for any inconvenience caused.  UPD2: Congratulations to the winners!Div 1: fqw sankear (The only one who solved problem E during the contest. Congratulations!) Egor qwerty787788 hos.lyric Div 2: jzzhu SJTU_WengJian alcot LoveEvita huyifei NiuYiqiang UPD3: The round analysis are prepared by DmitriyH. You can find them here. Also the tutorial is not completely ready yet. But you can find some notes about some of the problems here. I'll try to complete it as soon as possible.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11458",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1206
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces",
          "content": "Hi!415A - Mashmokh and LightsFor this problem for each light j you could just iterate over all pressed buttons and find the first button bi that bi < j. Then you could output bi and move to next light.  415B - Mashmokh and TokensFor this problem you can find the number of tokens you can save if you initally have k tokens in O(1). Then you can calculate the answer for all of numbers in O(n). Suppose by p. then p * b ≤ w * a. then . Suppose initially we have k tokens. Let then we need to find such maximum k0 that .So k0 will be equal to . so we can calculate k0 in O(1).414A - Mashmokh and NumbersIn each turn Bimokh will at least get one point so the result is at lease . So if the answer is -1. Let's denote . Then you could output x and 2x as the first two integers in the sequence then output consecutive integers and also one random integer(distinct from the others) if n is odd. Based on the following fact, Bimokh's point will equal to which is equal to k.. Also you must consider some corner cases such as when n = 1.414B - Mashmokh and ACMLets define dp[i][j] as number of good sequences of length i that ends in j.Let's denote divisors of j by x1, x2, ..., xl. Then This yields O(nk sqrt(n)) solution which is not fast enough. But one could use the fact that the following loops run in O(n log(n)) in order to achieve O(nk log(n)) which is fast enough to pass the tests. for (i = 1; i <= n; i++) //loop from 1 to n\n for (int j = i; j <= n; j += i) //iterating through all multiples of i that are at most n414C - Mashmokh and Reverse OperationBuild a complete binary tree with height n. So its i-th leaf corresponds to i-th element of the initial array. For each vertex v lets define its subarray as the subarray containing the elements that have a leaf corresponding to them in subtree rooted at v.For each non-leaf vertex v, suppose its left child's subarray contains elements [a..b] of the array and its right child contains elements [b + 1..c] of the array. We'll calculate two numbers for this vertex. number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai > bj and number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai < bj. We'll call the first calculated number, normal number and the other one reverse number. Calculating these numbers can be done using merge-sort algorithm in O(n  *  2n). We'll Initially write normal number for each vertex on it. We'll define a vertex's type as type of the number that is written on them. Let's define height of a vertex v equal to its distnace to the nearest leaf. Also let's define switching a vertex as switching the number written on it with the other type number(if normal number is written on it change it to reverse number and vise-versa).Initially sum of writed numbers is equal to number of inversions in the initial array. Now when query h is given, by switching all vertices with height at most h, the sum of writed numbers will become equal to the number of inversions in the new array. The only question is how to perform such query fast? One can notice that in a height h, always all of the vertices has the same type. So we can calculate two numbers for each height h. The sum of normal numbers of vertices with height h and the sum of their reverse numbers. Then instead of switching vertices in a height one by one each time, one can just switch the number for that height. The sum of numbers of heights after each query will be the answer for that query. since there are n height each query can be performed in O(n) so the total running time will be O(nq  +  n  * 2n). 414D - Mashmokh and Water TanksLet's suppose instead of a tank there is a pile at each vertex and instead of water the game is played on tiles. Let's denote distance of each vertex q from the root by depth(q). Also Let's label each tile with number of the vertex it was initially put on. Suppose initially there was a tile at each of vertices v and u and after some move tile u and v are in the same vertex's pile. Then one can prove that there were exactly |depth(v) - depth(u)| moves at which vertex containing the tile at vertex with less depth was closed and the vertex containing the other tile wasn't. Suppose after i-th move, there was xi tiles inside the root's pile and xj is the maximum among these numbers. Suppose tiles a1, a2, ...axj were on the root after j-th move. Then the other tiles that we put inside the tree at the beginning have no effect in the final result. Then we can suppose that only these tiles were initially put on tree.So we can assume that all tiles we place at the beginning will reach to the root together. Suppose hi of these tiles were put at a vertex with depth i and d1 is the maximum depth that there is at least a tile in that depth. So as to these tiles reach to the root together we must pay . Then we want to minimize the number of needed coins so at the beginning there must not be two consecutive depth i and i + 1 that i + 1 ≤ d and there is a tile at depth i and an empty vertex at depth i + 1. In other words if we denote the minimum depth that initially there is a tile inside it as d0 then there must be a tile at each vertex with depth more than d0 and less than or equal to d1. Let's iterate over d1. Then for each d1 we can calculate d2, the minimum depth that we can pay the needed price if we put a tile at each vertex with depth at least d2 and at most d1. Let's denote this needed price as p0. Then we can also put at depth d2 - 1. So we can calculate maximum number of tiles that we can put on the tree so that they all reach to root together for a fixed d1. So the maximum of these numbers for all possible d1 will be the answer.Since by increasing d1, d2 won't decrease one can use two-pointers to update d2 while iterating over d1. Let's denote number of the vertices with depth i as cnti. Then we can save and update the following values.Then the needed price is equal to (d1 * s) - t. So as long as (d1 * s) - t > p we must increase d2. This yields an O(n) solution.414E - Mashmokh's Designed ProblemLet's define the dfs-order of a tree as the sequence created by calling function dfs(root). We'll build another sequence from a dfs-order by replacing each vertex in dfs-order by '+1' and inserting a '-1' after the last vertex of its subtree. Note that all vertices of a particular subtree are a continuous part of dfs-order of that tree. Also note that for each vertex v if the +1 corresponding to it is the i-th element of sequence, then v's distance from root(which we'll denote by height of v) is equal to sum of elements 1..i.Suppose we can perform the following operations on such sequence: For each i, find sum of the elements 1..i. For each i find the biggest j(j < i) so that sum of elements 1..j of the sequence equals p. Using these two operations we can find LCA of two vertices v and u, so since distance of u and v equals to height(u) + height(v) - 2 * height(LCA(u, v)) we can answer the second query. Also the third query can be answered using the second operation described above.As for the first query it cuts a continuous part of sequence and insert it in another place. This operation can be done using implicit treap. Also we can use the treap as a segment tree to store the following values for each vertex v. Then using these values the operations described above can be done. All of these operation can be done in O(logn). Sum of the elements in its subtree(each vertex in the treap has a value equal to +1 or -1 since it corresponds to an element of the sequence.) Let's write the values of each vertex in the subtree of v in the order they appear in the sequence. Then lets denote sum of the first i numbers we wrote as ps[i] and call elements of ps, prefix sums of the subtree of v. Then we store the maximum number amongst the prefix sums. Also we'll store the minimum number amongst prefix sums.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11470",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 415\\s*B"
          },
          "content_length": 7826
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #240 - Codeforces - Code 1",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 2",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 3",
          "code": "dp[i][j] = dp[i+1][j] + dp[i+1][2*j] + ... + dp[i+1][n/j*j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 4",
          "code": "dp[n][x] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 1",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 2",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 3",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 4",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 5",
          "code": "((a*x) % b) / a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 6",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 7",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 8",
          "code": "((x * A) % B)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 9",
          "code": "number of inversion after reverse = N(N-1)/2 - number of inversion before reverse - number of pair of same element",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 10",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 11",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 12",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 13",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(1, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(1, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(1, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int a = opt<int>(\"a\", rnd.next(1, int(1e9)));\n    int b = opt<int>(\"b\", rnd.next(1, int(1e9)));\n    int min_x = opt<int>(\"min_x\", 1);\n    int max_x = opt<int>(\"max_x\", int(1e9));\n\n    printf(\"%d %d %d\\n\", n, a, b);\n    vector<int> x(n);\n\n    if (type == \"max_x\") {\n        for (int i = 0; i < n; ++i)\n            x[i] = max_x;\n    } else if (type == \"min_x\") {\n        for (int i = 0; i < n; ++i)\n            x[i] = min_x;\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            x[i] = rnd.next(min_x, max_x);\n    } else if (type == \"increase\") {\n        x[0] = min_x;\n        for (int i = 1; i < n; ++i)\n            x[i] = min(x[i-1] + rnd.next(0, (max_x - min_x)/n + 1), max_x);\n    } else if (type == \"decrease\") {\n        x[0] = max_x;\n        for (int i = 1; i < n; ++i)\n            x[i] = max(x[i-1] - rnd.next(0, (max_x - min_x)/n + 1), min_x);\n    } else if (type == \"perfect_squares\") {\n        // Generate xi's as perfect squares\n        int max_sqrt = sqrt(max_x);\n        for (int i = 0; i < n; ++i) {\n            int val = rnd.next(1, max_sqrt);\n            x[i] = val * val;\n        }\n    } else if (type == \"near_square\") {\n        // xi's near perfect squares\n        int max_sqrt = sqrt(max_x);\n        for (int i = 0; i < n; ++i) {\n            int val = rnd.next(1, max_sqrt);\n            int adjust = rnd.next(-1,1); // -1,0,1\n            x[i] = val * val + adjust;\n            if (x[i] < min_x) x[i] = min_x;\n            if (x[i] > max_x) x[i] = max_x;\n        }\n    } else if (type == \"critical_cases\") {\n        // Generate xi's such that floor(a*sqrt(w)+b) changes value at xi\n        for (int i = 0; i < n; ++i) {\n            int w = rnd.next(1, min(max_x, (int)1e6));\n            x[i] = w * w;\n            if (x[i] > max_x) x[i] = max_x;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i)\n            x[i] = rnd.next(min_x, max_x);\n    }\n\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", x[i], i+1==n?'\\n':' ');\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int a = opt<int>(\"a\", rnd.next(1, int(1e9)));\n    int b = opt<int>(\"b\", rnd.next(1, int(1e9)));\n    int min_x = opt<int>(\"min_x\", 1);\n    int max_x = opt<int>(\"max_x\", int(1e9));\n\n    printf(\"%d %d %d\\n\", n, a, b);\n    vector<int> x(n);\n\n    if (type == \"max_x\") {\n        for (int i = 0; i < n; ++i)\n            x[i] = max_x;\n    } else if (type == \"min_x\") {\n        for (int i = 0; i < n; ++i)\n            x[i] = min_x;\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            x[i] = rnd.next(min_x, max_x);\n    } else if (type == \"increase\") {\n        x[0] = min_x;\n        for (int i = 1; i < n; ++i)\n            x[i] = min(x[i-1] + rnd.next(0, (max_x - min_x)/n + 1), max_x);\n    } else if (type == \"decrease\") {\n        x[0] = max_x;\n        for (int i = 1; i < n; ++i)\n            x[i] = max(x[i-1] - rnd.next(0, (max_x - min_x)/n + 1), min_x);\n    } else if (type == \"perfect_squares\") {\n        // Generate xi's as perfect squares\n        int max_sqrt = sqrt(max_x);\n        for (int i = 0; i < n; ++i) {\n            int val = rnd.next(1, max_sqrt);\n            x[i] = val * val;\n        }\n    } else if (type == \"near_square\") {\n        // xi's near perfect squares\n        int max_sqrt = sqrt(max_x);\n        for (int i = 0; i < n; ++i) {\n            int val = rnd.next(1, max_sqrt);\n            int adjust = rnd.next(-1,1); // -1,0,1\n            x[i] = val * val + adjust;\n            if (x[i] < min_x) x[i] = min_x;\n            if (x[i] > max_x) x[i] = max_x;\n        }\n    } else if (type == \"critical_cases\") {\n        // Generate xi's such that floor(a*sqrt(w)+b) changes value at xi\n        for (int i = 0; i < n; ++i) {\n            int w = rnd.next(1, min(max_x, (int)1e6));\n            x[i] = w * w;\n            if (x[i] > max_x) x[i] = max_x;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i)\n            x[i] = rnd.next(min_x, max_x);\n    }\n\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", x[i], i+1==n?'\\n':' ');\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -a 1 -b 1 -type min_x -min_x 1 -max_x 1\n./gen -n 100000 -a 1000000000 -b 1000000000 -type max_x -min_x 1000000000 -max_x 1000000000\n./gen -n 1 -a 1000000000 -b 1000000000 -type max_x -min_x 1000000000 -max_x 1000000000\n./gen -n 100000 -a 1 -b 1 -type random -min_x 1 -max_x 1000000000\n./gen -n 100000 -a 1 -b 1 -type perfect_squares -min_x 1 -max_x 1000000000\n./gen -n 100000 -a 1 -b 1 -type near_square -min_x 1 -max_x 1000000000\n./gen -n 100000 -a 1 -b 1 -type increase -min_x 1 -max_x 1000000000\n./gen -n 100000 -a 1 -b 1 -type decrease -min_x 1 -max_x 1000000000\n./gen -n 100000 -a 1 -b 1 -type critical_cases -min_x 1 -max_x 1000000000\n./gen -n 50000 -a 500000000 -b 500000000 -type random -min_x 1 -max_x 1000000000\n./gen -n 1000 -a 1000000000 -b 1000000000 -type perfect_squares -min_x 1 -max_x 1000000000\n./gen -n 1000 -a 1000000000 -b 1000000000 -type near_square -min_x 1 -max_x 1000000000\n./gen -n 100000 -a 1 -b 1 -type max_x -min_x 1 -max_x 1000000000\n./gen -n 100000 -a 1 -b 1 -type min_x -min_x 1 -max_x 1\n./gen -n 2 -a 1 -b 1 -type random -min_x 1 -max_x 1000000000\n./gen -n 3 -a 1 -b 2 -type random -min_x 1 -max_x 10\n./gen -n 5 -a 1000000000 -b 1000000000 -type random -min_x 999999999 -max_x 1000000000\n./gen -n 10000 -a 1000000 -b 1000000 -type random -min_x 1 -max_x 1000000000\n./gen -n 10000 -a 1000000000 -b 1 -type random -min_x 1 -max_x 1000000000\n./gen -n 100000 -a 1 -b 1000000000 -type random -min_x 1 -max_x 1000000000\n./gen -n 100000 -a 1000000000 -b 1 -type random -min_x 1 -max_x 1000000000\n./gen -n 100000 -a 1000000000 -b 1000000000 -type random -min_x 1 -max_x 1000000000\n./gen -n 100000 -a 1 -b 1 -type random -min_x 1 -max_x 1\n./gen -n 100000 -a 1 -b 1 -type random -min_x 1000000000 -max_x 1000000000\n./gen -n 100000 -a 1000000000 -b 1 -type decrease -min_x 1 -max_x 1000000000\n./gen -n 100000 -a 1 -b 1000000000 -type increase -min_x 1 -max_x 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:40.690252",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "415/C",
      "title": "C. Машмох и числа",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа через пробел: n, k (1 ≤ n ≤ 105; 0 ≤ k ≤ 108).",
      "output_spec": "Выходные данныеЕсли требуемая последовательность не существует, выведите -1. В противном случае, выведите n различных целых чисел через пробел a1, a2, ..., an (1 ≤ ai ≤ 109).",
      "sample_tests": "ПримерыВходные данныеСкопировать5 2Выходные данныеСкопировать1 2 3 4 5Входные данныеСкопировать5 3Выходные данныеСкопировать2 4 3 7 1Входные данныеСкопировать7 2Выходные данныеСкопировать-1",
      "description": "C. Машмох и числа\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа через пробел: n, k (1 ≤ n ≤ 105; 0 ≤ k ≤ 108).\n\nВходные данные\n\nВыходные данныеЕсли требуемая последовательность не существует, выведите -1. В противном случае, выведите n различных целых чисел через пробел a1, a2, ..., an (1 ≤ ai ≤ 109).\n\nВыходные данные\n\nВходные данныеСкопировать5 2Выходные данныеСкопировать1 2 3 4 5Входные данныеСкопировать5 3Выходные данныеСкопировать2 4 3 7 1Входные данныеСкопировать7 2Выходные данныеСкопировать-1\n\nВходные данныеСкопировать5 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 2 3 4 5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 4 3 7 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеgcd(x, y) — это наибольший общий делитель чисел x и y.",
      "solutions": [
        {
          "title": "Codeforces Round #240 - Codeforces",
          "content": "Всем привет!Завтра в 19:30 MSK состоится Codeforces Round #240.Это наш первый раунд на Codeforces и мы надеемся, что он вам понравится. Задачи были подготовлены авторами: Amir Keivan Mohtashami (matrix), Farbod Yadegarian (FarbodY) и Gerald Agapov (Gerald).Традиционно благодарю MikeMirzayanov за системы Polygon и Codeforces, а также Maria Belova (Delinur) за перевод задач.Желаем вам хорошего и интересного раунда.Удачи!Как обычно, распределение баллов по задачам будет анонсировано перед началом контеста!Распределение баллов:div1: 500 — 1000 — 1500 — 1500 — 2500div2: 500 — 1000 — 1500 — 2000 — 2500 (стандарт)UPD: Поздравляю победителей!Div 1: fqw sankear (Единственный, кто решил задачу E во время контеста) Egor qwerty787788 hos.lyric Div 2: jzzhu SJTU_WengJian alcot LoveEvita huyifei NiuYiqiang Статистика по раунду, подготовленная DmitriyH, находится здесь. Английский разбор можно прочитать здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11458",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 908
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces",
          "content": "Hi!415A - Mashmokh and LightsFor this problem for each light j you could just iterate over all pressed buttons and find the first button bi that bi < j. Then you could output bi and move to next light.  415B - Mashmokh and TokensFor this problem you can find the number of tokens you can save if you initally have k tokens in O(1). Then you can calculate the answer for all of numbers in O(n). Suppose by p. then p * b ≤ w * a. then . Suppose initially we have k tokens. Let then we need to find such maximum k0 that .So k0 will be equal to . so we can calculate k0 in O(1).414A - Mashmokh and NumbersIn each turn Bimokh will at least get one point so the result is at lease . So if the answer is -1. Let's denote . Then you could output x and 2x as the first two integers in the sequence then output consecutive integers and also one random integer(distinct from the others) if n is odd. Based on the following fact, Bimokh's point will equal to which is equal to k.. Also you must consider some corner cases such as when n = 1.414B - Mashmokh and ACMLets define dp[i][j] as number of good sequences of length i that ends in j.Let's denote divisors of j by x1, x2, ..., xl. Then This yields O(nk sqrt(n)) solution which is not fast enough. But one could use the fact that the following loops run in O(n log(n)) in order to achieve O(nk log(n)) which is fast enough to pass the tests. for (i = 1; i <= n; i++) //loop from 1 to n\n for (int j = i; j <= n; j += i) //iterating through all multiples of i that are at most n414C - Mashmokh and Reverse OperationBuild a complete binary tree with height n. So its i-th leaf corresponds to i-th element of the initial array. For each vertex v lets define its subarray as the subarray containing the elements that have a leaf corresponding to them in subtree rooted at v.For each non-leaf vertex v, suppose its left child's subarray contains elements [a..b] of the array and its right child contains elements [b + 1..c] of the array. We'll calculate two numbers for this vertex. number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai > bj and number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai < bj. We'll call the first calculated number, normal number and the other one reverse number. Calculating these numbers can be done using merge-sort algorithm in O(n  *  2n). We'll Initially write normal number for each vertex on it. We'll define a vertex's type as type of the number that is written on them. Let's define height of a vertex v equal to its distnace to the nearest leaf. Also let's define switching a vertex as switching the number written on it with the other type number(if normal number is written on it change it to reverse number and vise-versa).Initially sum of writed numbers is equal to number of inversions in the initial array. Now when query h is given, by switching all vertices with height at most h, the sum of writed numbers will become equal to the number of inversions in the new array. The only question is how to perform such query fast? One can notice that in a height h, always all of the vertices has the same type. So we can calculate two numbers for each height h. The sum of normal numbers of vertices with height h and the sum of their reverse numbers. Then instead of switching vertices in a height one by one each time, one can just switch the number for that height. The sum of numbers of heights after each query will be the answer for that query. since there are n height each query can be performed in O(n) so the total running time will be O(nq  +  n  * 2n). 414D - Mashmokh and Water TanksLet's suppose instead of a tank there is a pile at each vertex and instead of water the game is played on tiles. Let's denote distance of each vertex q from the root by depth(q). Also Let's label each tile with number of the vertex it was initially put on. Suppose initially there was a tile at each of vertices v and u and after some move tile u and v are in the same vertex's pile. Then one can prove that there were exactly |depth(v) - depth(u)| moves at which vertex containing the tile at vertex with less depth was closed and the vertex containing the other tile wasn't. Suppose after i-th move, there was xi tiles inside the root's pile and xj is the maximum among these numbers. Suppose tiles a1, a2, ...axj were on the root after j-th move. Then the other tiles that we put inside the tree at the beginning have no effect in the final result. Then we can suppose that only these tiles were initially put on tree.So we can assume that all tiles we place at the beginning will reach to the root together. Suppose hi of these tiles were put at a vertex with depth i and d1 is the maximum depth that there is at least a tile in that depth. So as to these tiles reach to the root together we must pay . Then we want to minimize the number of needed coins so at the beginning there must not be two consecutive depth i and i + 1 that i + 1 ≤ d and there is a tile at depth i and an empty vertex at depth i + 1. In other words if we denote the minimum depth that initially there is a tile inside it as d0 then there must be a tile at each vertex with depth more than d0 and less than or equal to d1. Let's iterate over d1. Then for each d1 we can calculate d2, the minimum depth that we can pay the needed price if we put a tile at each vertex with depth at least d2 and at most d1. Let's denote this needed price as p0. Then we can also put at depth d2 - 1. So we can calculate maximum number of tiles that we can put on the tree so that they all reach to root together for a fixed d1. So the maximum of these numbers for all possible d1 will be the answer.Since by increasing d1, d2 won't decrease one can use two-pointers to update d2 while iterating over d1. Let's denote number of the vertices with depth i as cnti. Then we can save and update the following values.Then the needed price is equal to (d1 * s) - t. So as long as (d1 * s) - t > p we must increase d2. This yields an O(n) solution.414E - Mashmokh's Designed ProblemLet's define the dfs-order of a tree as the sequence created by calling function dfs(root). We'll build another sequence from a dfs-order by replacing each vertex in dfs-order by '+1' and inserting a '-1' after the last vertex of its subtree. Note that all vertices of a particular subtree are a continuous part of dfs-order of that tree. Also note that for each vertex v if the +1 corresponding to it is the i-th element of sequence, then v's distance from root(which we'll denote by height of v) is equal to sum of elements 1..i.Suppose we can perform the following operations on such sequence: For each i, find sum of the elements 1..i. For each i find the biggest j(j < i) so that sum of elements 1..j of the sequence equals p. Using these two operations we can find LCA of two vertices v and u, so since distance of u and v equals to height(u) + height(v) - 2 * height(LCA(u, v)) we can answer the second query. Also the third query can be answered using the second operation described above.As for the first query it cuts a continuous part of sequence and insert it in another place. This operation can be done using implicit treap. Also we can use the treap as a segment tree to store the following values for each vertex v. Then using these values the operations described above can be done. All of these operation can be done in O(logn). Sum of the elements in its subtree(each vertex in the treap has a value equal to +1 or -1 since it corresponds to an element of the sequence.) Let's write the values of each vertex in the subtree of v in the order they appear in the sequence. Then lets denote sum of the first i numbers we wrote as ps[i] and call elements of ps, prefix sums of the subtree of v. Then we store the maximum number amongst the prefix sums. Also we'll store the minimum number amongst prefix sums.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11470",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 415 和字母"
          },
          "content_length": 7826
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #240 - Codeforces - Code 1",
          "code": "// cout << a/2\nint a = 6; int b = 1; \nwhile( b <= a && 2*b < a ) ++b;\ncout << b;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 2",
          "code": "// cout << a/2\nint a = 6; int b = 1; \nwhile( b <= a && 2*b < a ) ++b;\ncout << b;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 3",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 4",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 5",
          "code": "for(int i=1;i<=n;i++)\nfor(int j=1;j*i<=n;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 6",
          "code": "for(int i=1;i<=n;i++)\nfor(int j=1;j*i<=n;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 7",
          "code": "dp[i][j] = dp[i+1][j] + dp[i+1][2*j] + ... + dp[i+1][n/j*j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 8",
          "code": "dp[n][x] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 1",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 2",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 3",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 4",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 5",
          "code": "((a*x) % b) / a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 6",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 7",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 8",
          "code": "((x * A) % B)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 9",
          "code": "number of inversion after reverse = N(N-1)/2 - number of inversion before reverse - number of pair of same element",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 10",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 11",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 12",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 13",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000000, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000000, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100000000, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\"); // 1 ≤ n ≤ 1e5\n    int k = inf.readInt(0, 100000000, \"k\"); // 0 ≤ k ≤ 1e8\n\n    int jans = ans.readInt();\n    \n    if (jans == -1) {\n        // Jury says no solution exists\n        int pans = ouf.readInt();\n        if (pans != -1) {\n            quitf(_wa, \"Participant claimed solution exists but jury says none exists\");\n        }\n        if (!ouf.seekEof()) {\n            quitf(_wa, \"Participant output extra data after -1\");\n        }\n        quitf(_ok, \"Correct, no solution exists and participant outputs -1\");\n    } else {\n        // Jury says solution exists\n        int first_pans = ouf.readInt(1, 1000000000, \"a[1]\");\n        if (first_pans == -1) {\n            quitf(_wa, \"Participant claimed no solution but solution exists\");\n        }\n        vector<int> seq;\n        seq.push_back(first_pans);\n        for (int i = 1; i < n; ++i) {\n            if (ouf.eof()) {\n                quitf(_wa, \"Participant output less than %d numbers\", n);\n            }\n            int ai = ouf.readInt(1, 1000000000, format(\"a[%d]\", i + 1).c_str());\n            seq.push_back(ai);\n        }\n        if (!ouf.seekEof()) {\n            quitf(_wa, \"Participant output extra data after %d numbers\", n);\n        }\n        // Check that all elements are distinct\n        set<int> s(seq.begin(), seq.end());\n        if ((int)s.size() != n) {\n            quitf(_wa, \"Numbers are not distinct\");\n        }\n        // Simulate the boss's game\n        long long total_score = 0;\n        vector<int> remaining = seq;\n        while ((int)remaining.size() >= 2) {\n            int x = remaining[0];\n            int y = remaining[1];\n            total_score += __gcd(x, y);\n            remaining.erase(remaining.begin(), remaining.begin() + 2);\n        }\n        if (total_score != k) {\n            quitf(_wa, \"Total score is %lld, expected %d\", total_score, k);\n        }\n        quitf(_ok, \"Correct sequence, total score %lld\", total_score);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // 1) Always call registerGen first.\n    registerGen(argc, argv, 1);\n\n    /*\n       2) Parse parameters. \n          - n defaults to 5 if not provided.\n          - k defaults to 2 if not provided.\n          - type defaults to \"random\" if not provided, though here\n            we do not actually vary our output based on type; it is\n            just included to show how you might extend this generator\n            for special cases.\n    */\n    int n = opt<int>(\"n\", 5);\n    int k = opt<int>(\"k\", 2);\n    string type = opt<string>(\"type\", \"random\");\n\n    /*\n       3) Output exactly one test case:\n          Print \"n k\" on one line.\n          This satisfies the problem’s input format, because the problem\n          statement reads a single line containing n and k.\n    */\n    cout << n << \" \" << k << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // 1) Always call registerGen first.\n    registerGen(argc, argv, 1);\n\n    /*\n       2) Parse parameters. \n          - n defaults to 5 if not provided.\n          - k defaults to 2 if not provided.\n          - type defaults to \"random\" if not provided, though here\n            we do not actually vary our output based on type; it is\n            just included to show how you might extend this generator\n            for special cases.\n    */\n    int n = opt<int>(\"n\", 5);\n    int k = opt<int>(\"k\", 2);\n    string type = opt<string>(\"type\", \"random\");\n\n    /*\n       3) Output exactly one test case:\n          Print \"n k\" on one line.\n          This satisfies the problem’s input format, because the problem\n          statement reads a single line containing n and k.\n    */\n    cout << n << \" \" << k << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below is a list of example commands for generating 20+ different test inputs.\n# Each command prints exactly one line of the form \"n k\".\n# These cover corner cases (e.g., n=1, k=0), random mid-range, and large boundary cases.\n\n# 1) Minimum n, feasible k=0\n./gen -n 1 -k 0 -type corner\n\n# 2) Minimum n, impossible k>0\n./gen -n 1 -k 1 -type corner\n\n# 3) n=2, impossible k=0 (sum of gcds cannot be 0)\n./gen -n 2 -k 0 -type corner\n\n# 4) n=2, small feasible gcd\n./gen -n 2 -k 1 -type small\n\n# 5) n=2, bigger feasible gcd\n./gen -n 2 -k 10 -type small\n\n# 6) n=3, gcd sum = 1\n./gen -n 3 -k 1 -type small\n\n# 7) n=3, gcd sum = 2\n./gen -n 3 -k 2 -type small\n\n# 8) n=4, gcd sum = 2\n./gen -n 4 -k 2 -type small\n\n# 9) n=5, gcd sum = 0 (impossible, because n>1 and k=0)\n./gen -n 5 -k 0 -type corner\n\n# 10) n=5, gcd sum = 2\n./gen -n 5 -k 2 -type random\n\n# 11) n=5, gcd sum = 3\n./gen -n 5 -k 3 -type random\n\n# 12) n=6, gcd sum = 2\n./gen -n 6 -k 2 -type random\n\n# 13) n=10, gcd sum = 1 (likely feasible)\n./gen -n 10 -k 1 -type random\n\n# 14) n=10, gcd sum = 10\n./gen -n 10 -k 10 -type random\n\n# 15) n=11, gcd sum = 5\n./gen -n 11 -k 5 -type random\n\n# 16) n=12, gcd sum = 6\n./gen -n 12 -k 6 -type random\n\n# 17) n=50, gcd sum = 24\n./gen -n 50 -k 24 -type random\n\n# 18) n=99, gcd sum = 49\n./gen -n 99 -k 49 -type random\n\n# 19) Large n=100, smaller k=10\n./gen -n 100 -k 10 -type random\n\n# 20) Large n=100, bigger k=50\n./gen -n 100 -k 50 -type random\n\n# 21) Even larger n=1000, with k=500\n./gen -n 1000 -k 500 -type random\n\n# 22) Large borderline n=99999, k=1 (likely impossible in the official checker)\n./gen -n 99999 -k 1 -type corner\n\n# 23) Another large variant n=99999, k=49999\n./gen -n 99999 -k 49999 -type large\n\n# 24) Max n=100000, k=50000 (borderline feasible)\n./gen -n 100000 -k 50000 -type large\n\n# 25) Max n=100000, very small k=1 (impossible)\n./gen -n 100000 -k 1 -type corner\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:42.352280",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "415/D",
      "title": "D. Машмох и ACM",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа через пробел n, k (1 ≤ n, k ≤ 2000).",
      "output_spec": "Выходные данныеВыведите единственное целое число — количество хороших последовательностей длины k по модулю 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать3 2Выходные данныеСкопировать5Входные данныеСкопировать6 4Выходные данныеСкопировать39Входные данныеСкопировать2 1Выходные данныеСкопировать2",
      "description": "D. Машмох и ACM\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа через пробел n, k (1 ≤ n, k ≤ 2000).\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — количество хороших последовательностей длины k по модулю 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать3 2Выходные данныеСкопировать5Входные данныеСкопировать6 4Выходные данныеСкопировать39Входные данныеСкопировать2 1Выходные данныеСкопировать2\n\nВходные данныеСкопировать3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать39\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере хорошие последовательности такие: [1, 1], [2, 2], [3, 3], [1, 2], [1, 3].",
      "solutions": [
        {
          "title": "Codeforces Round #240 - Codeforces",
          "content": "Всем привет!Завтра в 19:30 MSK состоится Codeforces Round #240.Это наш первый раунд на Codeforces и мы надеемся, что он вам понравится. Задачи были подготовлены авторами: Amir Keivan Mohtashami (matrix), Farbod Yadegarian (FarbodY) и Gerald Agapov (Gerald).Традиционно благодарю MikeMirzayanov за системы Polygon и Codeforces, а также Maria Belova (Delinur) за перевод задач.Желаем вам хорошего и интересного раунда.Удачи!Как обычно, распределение баллов по задачам будет анонсировано перед началом контеста!Распределение баллов:div1: 500 — 1000 — 1500 — 1500 — 2500div2: 500 — 1000 — 1500 — 2000 — 2500 (стандарт)UPD: Поздравляю победителей!Div 1: fqw sankear (Единственный, кто решил задачу E во время контеста) Egor qwerty787788 hos.lyric Div 2: jzzhu SJTU_WengJian alcot LoveEvita huyifei NiuYiqiang Статистика по раунду, подготовленная DmitriyH, находится здесь. Английский разбор можно прочитать здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11458",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 908
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces",
          "content": "Hi!415A - Mashmokh and LightsFor this problem for each light j you could just iterate over all pressed buttons and find the first button bi that bi < j. Then you could output bi and move to next light.  415B - Mashmokh and TokensFor this problem you can find the number of tokens you can save if you initally have k tokens in O(1). Then you can calculate the answer for all of numbers in O(n). Suppose by p. then p * b ≤ w * a. then . Suppose initially we have k tokens. Let then we need to find such maximum k0 that .So k0 will be equal to . so we can calculate k0 in O(1).414A - Mashmokh and NumbersIn each turn Bimokh will at least get one point so the result is at lease . So if the answer is -1. Let's denote . Then you could output x and 2x as the first two integers in the sequence then output consecutive integers and also one random integer(distinct from the others) if n is odd. Based on the following fact, Bimokh's point will equal to which is equal to k.. Also you must consider some corner cases such as when n = 1.414B - Mashmokh and ACMLets define dp[i][j] as number of good sequences of length i that ends in j.Let's denote divisors of j by x1, x2, ..., xl. Then This yields O(nk sqrt(n)) solution which is not fast enough. But one could use the fact that the following loops run in O(n log(n)) in order to achieve O(nk log(n)) which is fast enough to pass the tests. for (i = 1; i <= n; i++) //loop from 1 to n\n for (int j = i; j <= n; j += i) //iterating through all multiples of i that are at most n414C - Mashmokh and Reverse OperationBuild a complete binary tree with height n. So its i-th leaf corresponds to i-th element of the initial array. For each vertex v lets define its subarray as the subarray containing the elements that have a leaf corresponding to them in subtree rooted at v.For each non-leaf vertex v, suppose its left child's subarray contains elements [a..b] of the array and its right child contains elements [b + 1..c] of the array. We'll calculate two numbers for this vertex. number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai > bj and number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai < bj. We'll call the first calculated number, normal number and the other one reverse number. Calculating these numbers can be done using merge-sort algorithm in O(n  *  2n). We'll Initially write normal number for each vertex on it. We'll define a vertex's type as type of the number that is written on them. Let's define height of a vertex v equal to its distnace to the nearest leaf. Also let's define switching a vertex as switching the number written on it with the other type number(if normal number is written on it change it to reverse number and vise-versa).Initially sum of writed numbers is equal to number of inversions in the initial array. Now when query h is given, by switching all vertices with height at most h, the sum of writed numbers will become equal to the number of inversions in the new array. The only question is how to perform such query fast? One can notice that in a height h, always all of the vertices has the same type. So we can calculate two numbers for each height h. The sum of normal numbers of vertices with height h and the sum of their reverse numbers. Then instead of switching vertices in a height one by one each time, one can just switch the number for that height. The sum of numbers of heights after each query will be the answer for that query. since there are n height each query can be performed in O(n) so the total running time will be O(nq  +  n  * 2n). 414D - Mashmokh and Water TanksLet's suppose instead of a tank there is a pile at each vertex and instead of water the game is played on tiles. Let's denote distance of each vertex q from the root by depth(q). Also Let's label each tile with number of the vertex it was initially put on. Suppose initially there was a tile at each of vertices v and u and after some move tile u and v are in the same vertex's pile. Then one can prove that there were exactly |depth(v) - depth(u)| moves at which vertex containing the tile at vertex with less depth was closed and the vertex containing the other tile wasn't. Suppose after i-th move, there was xi tiles inside the root's pile and xj is the maximum among these numbers. Suppose tiles a1, a2, ...axj were on the root after j-th move. Then the other tiles that we put inside the tree at the beginning have no effect in the final result. Then we can suppose that only these tiles were initially put on tree.So we can assume that all tiles we place at the beginning will reach to the root together. Suppose hi of these tiles were put at a vertex with depth i and d1 is the maximum depth that there is at least a tile in that depth. So as to these tiles reach to the root together we must pay . Then we want to minimize the number of needed coins so at the beginning there must not be two consecutive depth i and i + 1 that i + 1 ≤ d and there is a tile at depth i and an empty vertex at depth i + 1. In other words if we denote the minimum depth that initially there is a tile inside it as d0 then there must be a tile at each vertex with depth more than d0 and less than or equal to d1. Let's iterate over d1. Then for each d1 we can calculate d2, the minimum depth that we can pay the needed price if we put a tile at each vertex with depth at least d2 and at most d1. Let's denote this needed price as p0. Then we can also put at depth d2 - 1. So we can calculate maximum number of tiles that we can put on the tree so that they all reach to root together for a fixed d1. So the maximum of these numbers for all possible d1 will be the answer.Since by increasing d1, d2 won't decrease one can use two-pointers to update d2 while iterating over d1. Let's denote number of the vertices with depth i as cnti. Then we can save and update the following values.Then the needed price is equal to (d1 * s) - t. So as long as (d1 * s) - t > p we must increase d2. This yields an O(n) solution.414E - Mashmokh's Designed ProblemLet's define the dfs-order of a tree as the sequence created by calling function dfs(root). We'll build another sequence from a dfs-order by replacing each vertex in dfs-order by '+1' and inserting a '-1' after the last vertex of its subtree. Note that all vertices of a particular subtree are a continuous part of dfs-order of that tree. Also note that for each vertex v if the +1 corresponding to it is the i-th element of sequence, then v's distance from root(which we'll denote by height of v) is equal to sum of elements 1..i.Suppose we can perform the following operations on such sequence: For each i, find sum of the elements 1..i. For each i find the biggest j(j < i) so that sum of elements 1..j of the sequence equals p. Using these two operations we can find LCA of two vertices v and u, so since distance of u and v equals to height(u) + height(v) - 2 * height(LCA(u, v)) we can answer the second query. Also the third query can be answered using the second operation described above.As for the first query it cuts a continuous part of sequence and insert it in another place. This operation can be done using implicit treap. Also we can use the treap as a segment tree to store the following values for each vertex v. Then using these values the operations described above can be done. All of these operation can be done in O(logn). Sum of the elements in its subtree(each vertex in the treap has a value equal to +1 or -1 since it corresponds to an element of the sequence.) Let's write the values of each vertex in the subtree of v in the order they appear in the sequence. Then lets denote sum of the first i numbers we wrote as ps[i] and call elements of ps, prefix sums of the subtree of v. Then we store the maximum number amongst the prefix sums. Also we'll store the minimum number amongst prefix sums.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11470",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 415 和字母"
          },
          "content_length": 7826
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #240 - Codeforces - Code 1",
          "code": "// cout << a/2\nint a = 6; int b = 1; \nwhile( b <= a && 2*b < a ) ++b;\ncout << b;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 2",
          "code": "// cout << a/2\nint a = 6; int b = 1; \nwhile( b <= a && 2*b < a ) ++b;\ncout << b;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 3",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 4",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 5",
          "code": "for(int i=1;i<=n;i++)\nfor(int j=1;j*i<=n;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 6",
          "code": "for(int i=1;i<=n;i++)\nfor(int j=1;j*i<=n;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 7",
          "code": "dp[i][j] = dp[i+1][j] + dp[i+1][2*j] + ... + dp[i+1][n/j*j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 8",
          "code": "dp[n][x] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 1",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 2",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 3",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 4",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 5",
          "code": "((a*x) % b) / a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 6",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 7",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 8",
          "code": "((x * A) % B)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 9",
          "code": "number of inversion after reverse = N(N-1)/2 - number of inversion before reverse - number of pair of same element",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 10",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 11",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 12",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 13",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 2000, \"k\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 2000, \"k\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 2000, \"k\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int nmax = opt<int>(\"nmax\", 2000);\n    int kmax = opt<int>(\"kmax\", 2000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int n, k;\n\n    if(type == \"max\") {\n        n = nmax;\n        k = kmax;\n    } else if(type == \"min\") {\n        n = 1;\n        k = 1;\n    } else if(type == \"n_equals_k\") {\n        int limit = min(nmax, kmax);\n        n = rnd.next(1, limit);\n        k = n;\n    } else if(type == \"k_is_1\"){\n        n = rnd.next(1, nmax);\n        k = 1;\n    } else if(type == \"n_is_1\"){\n        n = 1;\n        k = rnd.next(1, kmax);\n    } else if(type == \"k_is_nmax\"){\n        n = rnd.next(1, nmax);\n        k = kmax;\n    } else {\n        // default random\n        n = rnd.next(1, nmax);\n        k = rnd.next(1, kmax);\n    }\n\n    // Ensure n and k are within 1 and 2000\n    n = min(max(n, 1), 2000);\n    k = min(max(k, 1), 2000);\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int nmax = opt<int>(\"nmax\", 2000);\n    int kmax = opt<int>(\"kmax\", 2000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int n, k;\n\n    if(type == \"max\") {\n        n = nmax;\n        k = kmax;\n    } else if(type == \"min\") {\n        n = 1;\n        k = 1;\n    } else if(type == \"n_equals_k\") {\n        int limit = min(nmax, kmax);\n        n = rnd.next(1, limit);\n        k = n;\n    } else if(type == \"k_is_1\"){\n        n = rnd.next(1, nmax);\n        k = 1;\n    } else if(type == \"n_is_1\"){\n        n = 1;\n        k = rnd.next(1, kmax);\n    } else if(type == \"k_is_nmax\"){\n        n = rnd.next(1, nmax);\n        k = kmax;\n    } else {\n        // default random\n        n = rnd.next(1, nmax);\n        k = rnd.next(1, kmax);\n    }\n\n    // Ensure n and k are within 1 and 2000\n    n = min(max(n, 1), 2000);\n    k = min(max(k, 1), 2000);\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Maximum values for n and k\n./gen -nmax 2000 -kmax 2000 -type max\n\n# Minimum values for n and k\n./gen -nmax 1 -kmax 1 -type min\n\n# Random values for n and k\n./gen -nmax 2000 -kmax 2000 -type random\n\n# n equals k\n./gen -nmax 2000 -kmax 2000 -type n_equals_k\n\n# k is 1, n varies\n./gen -nmax 2000 -kmax 1 -type k_is_1\n\n# n is 1, k varies\n./gen -nmax 1 -kmax 2000 -type n_is_1\n\n# k equals nmax, n varies\n./gen -nmax 2000 -kmax 2000 -type k_is_nmax\n\n# Some specific small values\n./gen -nmax 2 -kmax 2 -type random\n./gen -nmax 3 -kmax 3 -type random\n./gen -nmax 4 -kmax 4 -type random\n./gen -nmax 5 -kmax 5 -type random\n\n# Random small n, large k\n./gen -nmax 10 -kmax 2000 -type random\n./gen -nmax 100 -kmax 2000 -type random\n\n# Random large n, small k\n./gen -nmax 2000 -kmax 10 -type random\n./gen -nmax 2000 -kmax 100 -type random\n\n# Random moderate values\n./gen -nmax 500 -kmax 500 -type random\n./gen -nmax 1000 -kmax 1000 -type random\n\n# n equals k at maximum\n./gen -nmax 2000 -kmax 2000 -type n_equals_k\n\n# n equals k at medium values\n./gen -nmax 1000 -kmax 1000 -type n_equals_k\n\n# n equals k at small values\n./gen -nmax 10 -kmax 10 -type n_equals_k\n\n# k is maximal, n is small\n./gen -nmax 50 -kmax 2000 -type k_is_nmax\n./gen -nmax 100 -kmax 2000 -type k_is_nmax\n\n# k equals nmax, n is very small\n./gen -nmax 2 -kmax 2000 -type k_is_nmax\n./gen -nmax 3 -kmax 2000 -type k_is_nmax\n\n# Random small nmax, kmax\n./gen -nmax 4 -kmax 4 -type random\n\n# Random moderate nmax, kmax\n./gen -nmax 100 -kmax 100 -type random\n./gen -nmax 200 -kmax 200 -type random\n\n# Max n, min k\n./gen -nmax 2000 -kmax 1 -type random\n\n# Min n, max k\n./gen -nmax 1 -kmax 2000 -type random\n\n# Additional random cases\n./gen -nmax 2000 -kmax 2000 -type random\n./gen -nmax 2000 -kmax 2000 -type random\n./gen -nmax 2000 -kmax 2000 -type random\n./gen -nmax 2000 -kmax 2000 -type random\n\n# Both n and k minimal\n./gen -nmax 1 -kmax 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:44.435294",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "415/E",
      "title": "E. Машмох и операция реверс",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 секунды",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано единственное целое число n (0 ≤ n ≤ 20). Во второй строке записано 2n целых чисел через пробел a[1], a[2], ..., a[2n] (1 ≤ a[i] ≤ 109), исходный массив.В третьей строке записано единственное целое число m (1 ≤ m ≤ 106). В четвертой строке записано m целых чисел через пробел q1, q2, ..., qm (0 ≤ qi ≤ n) — запросы.Обратите внимание: входные и выходные данные имеют очень большой размер, поэтому не стоит использовать медленные методы ввода и вывода данных вашего языка программирования. Например, в языке C++ не стоит использовать потоки ввода и вывода (cin, cout).",
      "output_spec": "Выходные данныеВыведите m строк. В i-й строке выведите ответ (количество инверсий) на i-й запрос.",
      "sample_tests": "ПримерыВходные данныеСкопировать22 1 4 341 2 0 2Выходные данныеСкопировать0660Входные данныеСкопировать11 230 1 1Выходные данныеСкопировать010",
      "description": "E. Машмох и операция реверс\n\nограничение по времени на тест4 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано единственное целое число n (0 ≤ n ≤ 20). Во второй строке записано 2n целых чисел через пробел a[1], a[2], ..., a[2n] (1 ≤ a[i] ≤ 109), исходный массив.В третьей строке записано единственное целое число m (1 ≤ m ≤ 106). В четвертой строке записано m целых чисел через пробел q1, q2, ..., qm (0 ≤ qi ≤ n) — запросы.Обратите внимание: входные и выходные данные имеют очень большой размер, поэтому не стоит использовать медленные методы ввода и вывода данных вашего языка программирования. Например, в языке C++ не стоит использовать потоки ввода и вывода (cin, cout).\n\nВходные данные\n\nВыходные данныеВыведите m строк. В i-й строке выведите ответ (количество инверсий) на i-й запрос.\n\nВыходные данные\n\nВходные данныеСкопировать22 1 4 341 2 0 2Выходные данныеСкопировать0660Входные данныеСкопировать11 230 1 1Выходные данныеСкопировать010\n\nВходные данныеСкопировать22 1 4 341 2 0 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0660\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать11 230 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать010\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПри выполнении реверса массива x[1], x[2], ..., x[n] получается новый массив y[1], y[2], ..., y[n], где y[i] = x[n - i + 1] для каждого i.Количество инверсий массива x[1], x[2], ..., x[n] — это количество пар индексов i, j, таких, что: i < j и x[i] > x[j].",
      "solutions": [
        {
          "title": "Codeforces Round #240 - Codeforces",
          "content": "Всем привет!Завтра в 19:30 MSK состоится Codeforces Round #240.Это наш первый раунд на Codeforces и мы надеемся, что он вам понравится. Задачи были подготовлены авторами: Amir Keivan Mohtashami (matrix), Farbod Yadegarian (FarbodY) и Gerald Agapov (Gerald).Традиционно благодарю MikeMirzayanov за системы Polygon и Codeforces, а также Maria Belova (Delinur) за перевод задач.Желаем вам хорошего и интересного раунда.Удачи!Как обычно, распределение баллов по задачам будет анонсировано перед началом контеста!Распределение баллов:div1: 500 — 1000 — 1500 — 1500 — 2500div2: 500 — 1000 — 1500 — 2000 — 2500 (стандарт)UPD: Поздравляю победителей!Div 1: fqw sankear (Единственный, кто решил задачу E во время контеста) Egor qwerty787788 hos.lyric Div 2: jzzhu SJTU_WengJian alcot LoveEvita huyifei NiuYiqiang Статистика по раунду, подготовленная DmitriyH, находится здесь. Английский разбор можно прочитать здесь.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11458",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 908
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces",
          "content": "Hi!415A - Mashmokh and LightsFor this problem for each light j you could just iterate over all pressed buttons and find the first button bi that bi < j. Then you could output bi and move to next light.  415B - Mashmokh and TokensFor this problem you can find the number of tokens you can save if you initally have k tokens in O(1). Then you can calculate the answer for all of numbers in O(n). Suppose by p. then p * b ≤ w * a. then . Suppose initially we have k tokens. Let then we need to find such maximum k0 that .So k0 will be equal to . so we can calculate k0 in O(1).414A - Mashmokh and NumbersIn each turn Bimokh will at least get one point so the result is at lease . So if the answer is -1. Let's denote . Then you could output x and 2x as the first two integers in the sequence then output consecutive integers and also one random integer(distinct from the others) if n is odd. Based on the following fact, Bimokh's point will equal to which is equal to k.. Also you must consider some corner cases such as when n = 1.414B - Mashmokh and ACMLets define dp[i][j] as number of good sequences of length i that ends in j.Let's denote divisors of j by x1, x2, ..., xl. Then This yields O(nk sqrt(n)) solution which is not fast enough. But one could use the fact that the following loops run in O(n log(n)) in order to achieve O(nk log(n)) which is fast enough to pass the tests. for (i = 1; i <= n; i++) //loop from 1 to n\n for (int j = i; j <= n; j += i) //iterating through all multiples of i that are at most n414C - Mashmokh and Reverse OperationBuild a complete binary tree with height n. So its i-th leaf corresponds to i-th element of the initial array. For each vertex v lets define its subarray as the subarray containing the elements that have a leaf corresponding to them in subtree rooted at v.For each non-leaf vertex v, suppose its left child's subarray contains elements [a..b] of the array and its right child contains elements [b + 1..c] of the array. We'll calculate two numbers for this vertex. number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai > bj and number of pairs (i, j)(a ≤ i ≤ b ≤ j ≤ c) that ai < bj. We'll call the first calculated number, normal number and the other one reverse number. Calculating these numbers can be done using merge-sort algorithm in O(n  *  2n). We'll Initially write normal number for each vertex on it. We'll define a vertex's type as type of the number that is written on them. Let's define height of a vertex v equal to its distnace to the nearest leaf. Also let's define switching a vertex as switching the number written on it with the other type number(if normal number is written on it change it to reverse number and vise-versa).Initially sum of writed numbers is equal to number of inversions in the initial array. Now when query h is given, by switching all vertices with height at most h, the sum of writed numbers will become equal to the number of inversions in the new array. The only question is how to perform such query fast? One can notice that in a height h, always all of the vertices has the same type. So we can calculate two numbers for each height h. The sum of normal numbers of vertices with height h and the sum of their reverse numbers. Then instead of switching vertices in a height one by one each time, one can just switch the number for that height. The sum of numbers of heights after each query will be the answer for that query. since there are n height each query can be performed in O(n) so the total running time will be O(nq  +  n  * 2n). 414D - Mashmokh and Water TanksLet's suppose instead of a tank there is a pile at each vertex and instead of water the game is played on tiles. Let's denote distance of each vertex q from the root by depth(q). Also Let's label each tile with number of the vertex it was initially put on. Suppose initially there was a tile at each of vertices v and u and after some move tile u and v are in the same vertex's pile. Then one can prove that there were exactly |depth(v) - depth(u)| moves at which vertex containing the tile at vertex with less depth was closed and the vertex containing the other tile wasn't. Suppose after i-th move, there was xi tiles inside the root's pile and xj is the maximum among these numbers. Suppose tiles a1, a2, ...axj were on the root after j-th move. Then the other tiles that we put inside the tree at the beginning have no effect in the final result. Then we can suppose that only these tiles were initially put on tree.So we can assume that all tiles we place at the beginning will reach to the root together. Suppose hi of these tiles were put at a vertex with depth i and d1 is the maximum depth that there is at least a tile in that depth. So as to these tiles reach to the root together we must pay . Then we want to minimize the number of needed coins so at the beginning there must not be two consecutive depth i and i + 1 that i + 1 ≤ d and there is a tile at depth i and an empty vertex at depth i + 1. In other words if we denote the minimum depth that initially there is a tile inside it as d0 then there must be a tile at each vertex with depth more than d0 and less than or equal to d1. Let's iterate over d1. Then for each d1 we can calculate d2, the minimum depth that we can pay the needed price if we put a tile at each vertex with depth at least d2 and at most d1. Let's denote this needed price as p0. Then we can also put at depth d2 - 1. So we can calculate maximum number of tiles that we can put on the tree so that they all reach to root together for a fixed d1. So the maximum of these numbers for all possible d1 will be the answer.Since by increasing d1, d2 won't decrease one can use two-pointers to update d2 while iterating over d1. Let's denote number of the vertices with depth i as cnti. Then we can save and update the following values.Then the needed price is equal to (d1 * s) - t. So as long as (d1 * s) - t > p we must increase d2. This yields an O(n) solution.414E - Mashmokh's Designed ProblemLet's define the dfs-order of a tree as the sequence created by calling function dfs(root). We'll build another sequence from a dfs-order by replacing each vertex in dfs-order by '+1' and inserting a '-1' after the last vertex of its subtree. Note that all vertices of a particular subtree are a continuous part of dfs-order of that tree. Also note that for each vertex v if the +1 corresponding to it is the i-th element of sequence, then v's distance from root(which we'll denote by height of v) is equal to sum of elements 1..i.Suppose we can perform the following operations on such sequence: For each i, find sum of the elements 1..i. For each i find the biggest j(j < i) so that sum of elements 1..j of the sequence equals p. Using these two operations we can find LCA of two vertices v and u, so since distance of u and v equals to height(u) + height(v) - 2 * height(LCA(u, v)) we can answer the second query. Also the third query can be answered using the second operation described above.As for the first query it cuts a continuous part of sequence and insert it in another place. This operation can be done using implicit treap. Also we can use the treap as a segment tree to store the following values for each vertex v. Then using these values the operations described above can be done. All of these operation can be done in O(logn). Sum of the elements in its subtree(each vertex in the treap has a value equal to +1 or -1 since it corresponds to an element of the sequence.) Let's write the values of each vertex in the subtree of v in the order they appear in the sequence. Then lets denote sum of the first i numbers we wrote as ps[i] and call elements of ps, prefix sums of the subtree of v. Then we store the maximum number amongst the prefix sums. Also we'll store the minimum number amongst prefix sums.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11470",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 415 和字母"
          },
          "content_length": 7826
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #240 - Codeforces - Code 1",
          "code": "// cout << a/2\nint a = 6; int b = 1; \nwhile( b <= a && 2*b < a ) ++b;\ncout << b;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 2",
          "code": "// cout << a/2\nint a = 6; int b = 1; \nwhile( b <= a && 2*b < a ) ++b;\ncout << b;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 3",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 4",
          "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main()\n{\n    int   n,k;scanf(\"%ld%ld\",&n,&k);\n    int d=0;\n    if(n&1){n--;d=1;}\n    if(n>>1 > k){printf(\"-1\\n\");return 0;}\n    else\n    {\n        int  bn=n/2;\n       printf(\"%ld %ld \",(k-bn+1),2*(k-bn+1));\n        bn--;\n        int    j=2*(k-bn+1)+1;\n        while(bn--)\n        {\n            printf(\"%ld %ld \",j,j+1);j+=2\n        }\n\n    }\n    if(d==1)\n        cout<<1000000000-1<<\"\\n\";\n    return 0;\n\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 5",
          "code": "for(int i=1;i<=n;i++)\nfor(int j=1;j*i<=n;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 6",
          "code": "for(int i=1;i<=n;i++)\nfor(int j=1;j*i<=n;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 7",
          "code": "dp[i][j] = dp[i+1][j] + dp[i+1][2*j] + ... + dp[i+1][n/j*j]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 - Codeforces - Code 8",
          "code": "dp[n][x] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11458",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 1",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 2",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 3",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 4",
          "code": "for(int i=1;i<=n;i++)\nfor(int t=1;t*i<=n;t++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 5",
          "code": "((a*x) % b) / a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 6",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 7",
          "code": "((x*a)%b)/a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 8",
          "code": "((x * A) % B)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 9",
          "code": "number of inversion after reverse = N(N-1)/2 - number of inversion before reverse - number of pair of same element",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 10",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 11",
          "code": "5 1 4\n12 6 11 9 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 12",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #240 Editorial - Codeforces - Code 13",
          "code": "for (i = 1; i <= n; i++)  //loop from 1 to n\n   for (int j = i; j <= n; j += i)  //iterating through all multiples of i that are at most n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11470",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n (0 ≤ n ≤ 20)\n    int n = inf.readInt(0, 20, \"n\");\n    inf.readEoln();\n\n    // Read 2^n integers a[1], a[2], ..., a[2^n] (each between 1 and 1e9)\n    int len = 1 << n; // Compute 2^n\n    vector<int> a = inf.readInts(len, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Read m (1 ≤ m ≤ 1e6)\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    // Read m integers q1, q2, ..., qm (each between 0 and n)\n    vector<int> q = inf.readInts(m, 0, n, \"q_i\");\n    inf.readEoln();\n\n    // Ensure end of file\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n (0 ≤ n ≤ 20)\n    int n = inf.readInt(0, 20, \"n\");\n    inf.readEoln();\n\n    // Read 2^n integers a[1], a[2], ..., a[2^n] (each between 1 and 1e9)\n    int len = 1 << n; // Compute 2^n\n    vector<int> a = inf.readInts(len, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Read m (1 ≤ m ≤ 1e6)\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    // Read m integers q1, q2, ..., qm (each between 0 and n)\n    vector<int> q = inf.readInts(m, 0, n, \"q_i\");\n    inf.readEoln();\n\n    // Ensure end of file\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n (0 ≤ n ≤ 20)\n    int n = inf.readInt(0, 20, \"n\");\n    inf.readEoln();\n\n    // Read 2^n integers a[1], a[2], ..., a[2^n] (each between 1 and 1e9)\n    int len = 1 << n; // Compute 2^n\n    vector<int> a = inf.readInts(len, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Read m (1 ≤ m ≤ 1e6)\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    // Read m integers q1, q2, ..., qm (each between 0 and n)\n    vector<int> q = inf.readInts(m, 0, n, \"q_i\");\n    inf.readEoln();\n\n    // Ensure end of file\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string aType = opt<string>(\"aType\", \"random\");\n    string qType = opt<string>(\"qType\", \"random\");\n\n    int N = 1 << n; // 2^n\n\n    vector<int> a(N);\n\n    // Generate array a[]\n    if (aType == \"random\") {\n        for (int i = 0; i < N; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (aType == \"sorted\") {\n        int base = 1;\n        int step = 1000000000 / max(1, N - 1);\n        for (int i = 0; i < N; ++i) {\n            a[i] = base + i * step;\n        }\n    } else if (aType == \"reversed\") {\n        int base = 1;\n        int step = 1000000000 / max(1, N - 1);\n        for (int i = 0; i < N; ++i) {\n            a[N - i - 1] = base + i * step;\n        }\n    } else if (aType == \"same\") {\n        int val = rnd.next(1, 1000000000);\n        for (int i = 0; i < N; ++i) {\n            a[i] = val;\n        }\n    } else if (aType == \"alternating\") {\n        int val1 = rnd.next(1, 1000000000);\n        int val2 = rnd.next(1, 1000000000);\n        for (int i = 0; i < N; ++i) {\n            a[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else if (aType == \"small\") {\n        for (int i = 0; i < N; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (aType == \"worst\") {\n        for (int i = 0; i < N; ++i) {\n            a[i] = N - i;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < N; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Generate queries\n    vector<int> q(m);\n    if (qType == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            q[i] = rnd.next(0, n);\n        }\n    } else if (qType == \"max\") {\n        for (int i = 0; i < m; ++i) {\n            q[i] = n;\n        }\n    } else if (qType == \"min\") {\n        for (int i = 0; i < m; ++i) {\n            q[i] = 0;\n        }\n    } else if (qType == \"same\") {\n        int qval = opt<int>(\"qval\", n / 2);\n        for (int i = 0; i < m; ++i) {\n            q[i] = qval;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i) {\n            q[i] = rnd.next(0, n);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < N; ++i) {\n        printf(\"%d%c\", a[i], (i + 1 == N) ? '\\n' : ' ');\n    }\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", q[i], (i + 1 == m) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string aType = opt<string>(\"aType\", \"random\");\n    string qType = opt<string>(\"qType\", \"random\");\n\n    int N = 1 << n; // 2^n\n\n    vector<int> a(N);\n\n    // Generate array a[]\n    if (aType == \"random\") {\n        for (int i = 0; i < N; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (aType == \"sorted\") {\n        int base = 1;\n        int step = 1000000000 / max(1, N - 1);\n        for (int i = 0; i < N; ++i) {\n            a[i] = base + i * step;\n        }\n    } else if (aType == \"reversed\") {\n        int base = 1;\n        int step = 1000000000 / max(1, N - 1);\n        for (int i = 0; i < N; ++i) {\n            a[N - i - 1] = base + i * step;\n        }\n    } else if (aType == \"same\") {\n        int val = rnd.next(1, 1000000000);\n        for (int i = 0; i < N; ++i) {\n            a[i] = val;\n        }\n    } else if (aType == \"alternating\") {\n        int val1 = rnd.next(1, 1000000000);\n        int val2 = rnd.next(1, 1000000000);\n        for (int i = 0; i < N; ++i) {\n            a[i] = (i % 2 == 0) ? val1 : val2;\n        }\n    } else if (aType == \"small\") {\n        for (int i = 0; i < N; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (aType == \"worst\") {\n        for (int i = 0; i < N; ++i) {\n            a[i] = N - i;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < N; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Generate queries\n    vector<int> q(m);\n    if (qType == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            q[i] = rnd.next(0, n);\n        }\n    } else if (qType == \"max\") {\n        for (int i = 0; i < m; ++i) {\n            q[i] = n;\n        }\n    } else if (qType == \"min\") {\n        for (int i = 0; i < m; ++i) {\n            q[i] = 0;\n        }\n    } else if (qType == \"same\") {\n        int qval = opt<int>(\"qval\", n / 2);\n        for (int i = 0; i < m; ++i) {\n            q[i] = qval;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i) {\n            q[i] = rnd.next(0, n);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < N; ++i) {\n        printf(\"%d%c\", a[i], (i + 1 == N) ? '\\n' : ' ');\n    }\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", q[i], (i + 1 == m) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 0 -m 1 -aType random -qType random\n./gen -n 1 -m 1 -aType same -qType max\n./gen -n 1 -m 10 -aType sorted -qType min\n./gen -n 10 -m 1000000 -aType random -qType random\n./gen -n 20 -m 1000000 -aType random -qType random\n./gen -n 20 -m 1000000 -aType reversed -qType min\n./gen -n 20 -m 1000000 -aType sorted -qType max\n./gen -n 20 -m 1000000 -aType same -qType random\n./gen -n 20 -m 1000000 -aType alternating -qType same -qval 10\n./gen -n 15 -m 500000 -aType small -qType same -qval 0\n./gen -n 15 -m 500000 -aType small -qType same -qval 15\n./gen -n 20 -m 1000000 -aType worst -qType max\n./gen -n 20 -m 1000000 -aType worst -qType min\n./gen -n 0 -m 1000000 -aType small -qType random\n./gen -n 20 -m 1 -aType random -qType random\n./gen -n 20 -m 1 -aType random -qType max\n./gen -n 20 -m 1000000 -aType sorted -qType same -qval 10\n./gen -n 20 -m 1000000 -aType reversed -qType same -qval 5\n./gen -n 15 -m 700000 -aType same -qType same -qval 7\n./gen -n 20 -m 1000000 -aType random -qType random\n./gen -n 20 -m 1000000 -aType alternating -qType random\n./gen -n 15 -m 500000 -aType random -qType max\n./gen -n 15 -m 500000 -aType random -qType min\n./gen -n 20 -m 1 -aType small -qType max\n./gen -n 20 -m 1 -aType small -qType min\n./gen -n 10 -m 1000000 -aType same -qType max\n./gen -n 10 -m 1000000 -aType same -qType min\n./gen -n 0 -m 1000000 -aType random -qType max\n./gen -n 0 -m 1000000 -aType random -qType min\n./gen -n 20 -m 1000000 -aType small -qType random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:46.231977",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "416/A",
      "title": "A. Guess a number!",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains a single integer n (1 ≤ n ≤ 10000) — the number of questions (and answers). Next n lines each contain one question and one answer to it. The format of each line is like that: \"sign x answer\", where the sign is:  \">\" (for the first type queries),  \"<\" (for the second type queries),  \">=\" (for the third type queries),  \"<=\" (for the fourth type queries). All values of x are integer and meet the inequation  - 109 ≤ x ≤ 109. The answer is an English letter \"Y\" (for \"yes\") or \"N\" (for \"no\").Consequtive elements in lines are separated by a single space.",
      "output_spec": "OutputPrint any of such integers y, that the answers to all the queries are correct. The printed number y must meet the inequation  - 2·109 ≤ y ≤ 2·109. If there are many answers, print any of them. If such value doesn't exist, print word \"Impossible\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy4>= 1 Y< 3 N<= -3 N> 55 NOutputCopy17InputCopy2> 100 Y< -100 YOutputCopyImpossible",
      "description": "A. Guess a number!\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains a single integer n (1 ≤ n ≤ 10000) — the number of questions (and answers). Next n lines each contain one question and one answer to it. The format of each line is like that: \"sign x answer\", where the sign is:  \">\" (for the first type queries),  \"<\" (for the second type queries),  \">=\" (for the third type queries),  \"<=\" (for the fourth type queries). All values of x are integer and meet the inequation  - 109 ≤ x ≤ 109. The answer is an English letter \"Y\" (for \"yes\") or \"N\" (for \"no\").Consequtive elements in lines are separated by a single space.\n\nOutputPrint any of such integers y, that the answers to all the queries are correct. The printed number y must meet the inequation  - 2·109 ≤ y ≤ 2·109. If there are many answers, print any of them. If such value doesn't exist, print word \"Impossible\" (without the quotes).\n\nInputCopy4>= 1 Y< 3 N<= -3 N> 55 NOutputCopy17InputCopy2> 100 Y< -100 YOutputCopyImpossible\n\nInputCopy4>= 1 Y< 3 N<= -3 N> 55 N\n\nOutputCopy17\n\nInputCopy2> 100 Y< -100 Y\n\nOutputCopyImpossible",
      "solutions": [
        {
          "title": "Codeforces Round #241 (Div. 2) - Codeforces",
          "content": "The round will start on 08:00 (UTC) of April, 13. It will be a kind of unusual round because at first for a long time Gerald didn't work much on round. It was prepared by me (how it is interesting to write a round!), Nerevar with the help of Gerald and Fefer_Ivan-а. Maria, many thanks for translations!It will be classical points: 500 — 1000 — 1500 — 2000 — 2500.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11623",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 364
        },
        {
          "title": "Codeforces Round #241 — editorial - Codeforces",
          "content": "416A - Guess a number!Let's use the usual Div 2 problem A approach — the naive one. We will track the interval which might contain the number we're guessing. With each of the query we update this interval. If at the end the interval is non-empty then we output any number from it, otherwise the result is \"Impossible\".Submission: 6606892416B - Art UnionAll we need is to iterate over all painters and for each painter to iterate over all pictures. In the inner loop we also remember when the painter finished working on the picture to make sure that the next painter will not start working on it earlier.Submission: 6606994416C - Booking SystemLet's solve this one greedy. All we need to notice is that the optimal solution will be to place first the groups with biggest sum which they are ready to pay. For each such group it will be optimal to allocate the smallest matching table. The input limits allow to do a full search when looking for a table.Submission: 6617198416D - Population SizeOne thing to notice for this problem is that if we cover some interval with a progression then it will better (at least no worse) to include as many elements to the right of it as possible. So the solution is to greedy — find the leftmost number not covered by a progression, start a new progression with that number (the interval covered by that progression will be of size 1) and then try to extend this interval to the right as far as possible. Repeat this step until all the numbers are covered. One thing you should pay attention to is which numbers can be covered by one arithmetic progression, for example: If there are no fixed numbers in the interval then we can cover it with one progression. If there is only one non-fixed number in the interval then we can cover this interval with one progression. If there are more than one non-fixed numbers in the interval then we can calculate the parameters of the progression (start value and difference). All non-fixed numbers should match those parameters. Difference should be integer. If the progression is ascending and there are some non-fixed numbers in the beginning then those numbers should match positive numbers in the progression. Same way if the progression is descending then we can include numbers from the right side only while matching progression term is positive. Submission: 6607174416E - President's PathLet's look at the graph given to us in the example:We need to count the count of the edges on all the shortest paths between each pair of vertices. Let's do something easier first — instead of counting all the edges we will count only those which have the destination vertex on its side. For example here are the edges belonging to shortest paths from 4 to 2 which are connected to vertex 2: Let's denote this number like this: inEdgessource, v — number of edges which go into vertex v on some shortest path from source to v. In the given example inEdges4, 2 = 3. Let's also denote the set Ssource, dest — it is a set of the vertices which belong to at least one shortest path from source to dest. For example S4, 2 = {1, 2, 3, 4}. With these two variables it can be seen that the answer for vertices source and dest will be: In other words the answer for vertices s and d will be equal to the sum of inEdgess, v for all vertices v, which belong to any shortest path from s to d. So the only thing left is to calculate these S and inEdges. Both of them can be easily calculated if you have minimum distances between all pairs of vertices. And these distances can be calculated using the Floyd-Warshall. So the full solution is: Calculate minimum distances between all pairs of vertices using Floyd-Warshall algorithm. Count inEdges. Simply iterate over all source vertices and all edges. For each edge check whether any of its ends belong to any shortest path from source. Calculate the answer. Let's have three loops to iterate over the vertices — — source, destination и mid. First two vertices are those for which we're calculating the answer. Third vertex is the vertex which should belong to any shortest path (basically we're checking whether v belongs to Ssource, dest). If mid belongs to any shortest path from source to dest then we add inEdgessource, mid to the answer. Each step has a complexity O(n3).Submission: 6607257P.S.: Please feel free to let me know about any typos, errors, etc using the private messages.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12277",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 416\\s*A"
          },
          "content_length": 4397
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string sign = inf.readToken(\">|<|>=|<=\", \"sign\");\n        inf.readSpace();\n        int x = inf.readInt(-1000000000, 1000000000, \"x\");\n        inf.readSpace();\n        string answer = inf.readToken(\"Y|N\", \"answer\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string sign = inf.readToken(\">|<|>=|<=\", \"sign\");\n        inf.readSpace();\n        int x = inf.readInt(-1000000000, 1000000000, \"x\");\n        inf.readSpace();\n        string answer = inf.readToken(\"Y|N\", \"answer\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string sign = inf.readToken(\">|<|>=|<=\", \"sign\");\n        inf.readSpace();\n        int x = inf.readInt(-1000000000, 1000000000, \"x\");\n        inf.readSpace();\n        string answer = inf.readToken(\"Y|N\", \"answer\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const long long MIN_ANS = -2000000000LL;\nstatic const long long MAX_ANS =  2000000000LL;\n\nstruct Constraint {\n    string sign;  // \">\", \"<\", \">=\", \"<=\"\n    long long x;\n    char ans;     // 'Y' or 'N'\n};\n\nvector<Constraint> constraints;\nint n;\n\n// Returns true if y satisfies all constraints.\nbool checkAllConstraints(long long y) {\n    for (auto &c : constraints) {\n        bool isTrue = false;\n        \n        if (c.sign == \">\")  isTrue = (y > c.x);\n        if (c.sign == \"<\")  isTrue = (y < c.x);\n        if (c.sign == \">=\") isTrue = (y >= c.x);\n        if (c.sign == \"<=\") isTrue = (y <= c.x);\n        \n        // If the answer to the question was \"N\", then the condition is negated.\n        if (c.ans == 'N') {\n            isTrue = !isTrue;\n        }\n        \n        if (!isTrue) return false;\n    }\n    return true;\n}\n\n// Finds if there is ANY integer solution within [MIN_ANS, MAX_ANS] that satisfies all constraints.\n// If found, return true, else false.\nbool existsSolutionInRange() {\n    // We'll narrow down the feasible interval [L, R].\n    long long L = MIN_ANS, R = MAX_ANS;\n    for (auto &c : constraints) {\n        // Sign c.sign, integer c.x, answer c.ans\n        bool yes = (c.ans == 'Y');\n        \n        if (c.sign == \">\") {\n            if (yes) {\n                // y > x => L = max(L, x+1)\n                L = max(L, c.x + 1);\n            } else {\n                // y <= x => R = min(R, x)\n                R = min(R, c.x);\n            }\n        }\n        else if (c.sign == \"<\") {\n            if (yes) {\n                // y < x => R = min(R, x-1)\n                R = min(R, c.x - 1);\n            } else {\n                // y >= x => L = max(L, x)\n                L = max(L, c.x);\n            }\n        }\n        else if (c.sign == \">=\") {\n            if (yes) {\n                // y >= x => L = max(L, x)\n                L = max(L, c.x);\n            } else {\n                // y < x => R = min(R, x-1)\n                R = min(R, c.x - 1);\n            }\n        }\n        else if (c.sign == \"<=\") {\n            if (yes) {\n                // y <= x => R = min(R, x)\n                R = min(R, c.x);\n            } else {\n                // y > x => L = max(L, x + 1)\n                L = max(L, c.x + 1);\n            }\n        }\n        \n        if (L > R) {\n            // The interval became empty => no possible solution.\n            return false;\n        }\n    }\n    // If we still have L <= R, there is at least one integer in [L, R].\n    return true;\n}\n\n// Read either \"Impossible\" or one integer within checker. If it is \"Impossible\" we return an empty optional.\n// If it is an integer, we return that integer (quitf if out of range).\noptional<long long> readAnswer(InStream &stream) {\n    string token = stream.readToken();\n    if (token == \"Impossible\") {\n        return {}; // empty => \"Impossible\"\n    } else {\n        // parse as long long\n        long long val = 0;\n        // We use safeConvert from testlib or do stoll with try/catch.\n        // But let's do stoll carefully:\n        // testlib has a function to parse int or long long safely as well.\n        // We'll do readLong from the token using stringstream:\n        // But let's do a simpler approach: stream has parse solution approach, but here we want manual:\n        // We'll re-insert 'token' into format: we can do inside try/catch:\n        bool negative = false;\n        int startPos = 0;\n        if(!token.empty() && (token[0] == '-' || token[0] == '+')) {\n            negative = (token[0] == '-');\n            startPos = 1;\n        }\n        if (startPos == (int)token.size()) {\n            stream.quitf(_wa, \"Cannot parse integer (invalid token '%s')\", token.c_str());\n        }\n        // check every next char is digit\n        for (int i = startPos; i < (int)token.size(); i++) {\n            if (!isdigit((unsigned char)token[i])) {\n                stream.quitf(_wa, \"Cannot parse integer (invalid token '%s')\", token.c_str());\n            }\n        }\n        // now parse\n        // We should watch for overflow. We'll use stoll but might not be available in older compilers,\n        // testlib also has stringToLongLong, let's do that:\n        long long parsed;\n        try {\n            parsed = stoll(token);\n        } catch (...) {\n            stream.quitf(_wa, \"Cannot parse integer (overflow or invalid '%s')\", token.c_str());\n        }\n        return parsed;\n    }\n}\n\n// Checks if the solution given as \"sol\" (if present) or \"Impossible\" is correct w.r.t. constraints.\n// If \"Impossible\", it's correct only if there's no valid integer in [-2e9, 2e9] satisfying all constraints;\n// otherwise it's correct if the integer is in [-2e9, 2e9] and meets all constraints.\nbool isSolutionCorrect(optional<long long> sol) {\n    // If \"Impossible\"\n    if (!sol.has_value()) {\n        // Check if there truly is no solution in [-2e9, 2e9].\n        return !existsSolutionInRange();\n    }\n    // Otherwise, check that the integer is within bounds and satisfies constraints.\n    long long val = sol.value();\n    if (val < MIN_ANS || val > MAX_ANS) {\n        return false;\n    }\n    // Check constraints\n    return checkAllConstraints(val);\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, 10000, \"n\");\n    constraints.resize(n);\n    for (int i = 0; i < n; i++) {\n        constraints[i].sign = inf.readToken(); // one of \">\", \"<\", \">=\", \"<=\"\n        constraints[i].x    = inf.readLong(-1000000000LL, 1000000000LL, \"x\");\n        string a            = inf.readToken(); // \"Y\" or \"N\"\n        if (a != \"Y\" && a != \"N\") {\n            quitf(_fail, \"Invalid answer character found in input, expected 'Y' or 'N'\");\n        }\n        constraints[i].ans = a[0];\n    }\n\n    // Read and validate the jury's answer\n    optional<long long> jurySol = readAnswer(ans);\n    if (!isSolutionCorrect(jurySol)) {\n        ans.quitf(_fail, \"Jury's answer is incorrect\");\n    }\n\n    // Read and validate the participant's answer\n    optional<long long> partSol = readAnswer(ouf);\n    if (!isSolutionCorrect(partSol)) {\n        ouf.quitf(_wa, \"Participant's answer is incorrect\");\n    }\n\n    // If we reach here, participant's answer is correct\n    quitf(_ok, \"Participant's answer is correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"valid\");\n\n    if (type == \"valid\") {\n        // Generate a valid test case where there exists at least one valid y\n        int64_t y = rnd.next(-2000000000LL, 2000000000LL);\n        vector<string> signs = {\">\", \"<\", \">=\", \"<=\"};\n\n        cout << n << endl;\n        for(int i = 0; i < n; ++i) {\n            string sign = signs[rnd.next(0, 3)];\n            int64_t x = rnd.next(-1000000000LL, 1000000000LL);\n            char answer;\n\n            if (sign == \">\") {\n                answer = (y > x) ? 'Y' : 'N';\n            } else if (sign == \"<\") {\n                answer = (y < x) ? 'Y' : 'N';\n            } else if (sign == \">=\") {\n                answer = (y >= x) ? 'Y' : 'N';\n            } else if (sign == \"<=\") {\n                answer = (y <= x) ? 'Y' : 'N';\n            }\n            cout << sign << \" \" << x << \" \" << answer << endl;\n        }\n    } else if (type == \"impossible\") {\n        // Generate a test case where it is impossible to find a valid y\n        int64_t lower_bound = -2000000000LL;\n        int64_t upper_bound = 2000000000LL;\n        vector<string> signs = {\">\", \"<\", \">=\", \"<=\"};\n        vector<string> queries;\n\n        for(int i = 0; i < n - 1; ++i) {\n            string sign = signs[rnd.next(0, 3)];\n            int64_t x = rnd.next(-1000000000LL, 1000000000LL);\n            char answer = rnd.next(0, 1) ? 'Y' : 'N';\n\n            // Update bounds based on the answer\n            if (answer == 'Y') {\n                if (sign == \">\") {\n                    lower_bound = max(lower_bound, x + 1);\n                } else if (sign == \">=\") {\n                    lower_bound = max(lower_bound, x);\n                } else if (sign == \"<\") {\n                    upper_bound = min(upper_bound, x - 1);\n                } else if (sign == \"<=\") {\n                    upper_bound = min(upper_bound, x);\n                }\n            } else {\n                if (sign == \">\") {\n                    upper_bound = min(upper_bound, x);\n                } else if (sign == \">=\") {\n                    upper_bound = min(upper_bound, x - 1);\n                } else if (sign == \"<\") {\n                    lower_bound = max(lower_bound, x);\n                } else if (sign == \"<=\") {\n                    lower_bound = max(lower_bound, x + 1);\n                }\n            }\n            queries.push_back(sign + \" \" + to_string(x) + \" \" + answer);\n        }\n\n        // Make the last query to ensure the problem is impossible\n        string sign;\n        int64_t x;\n        char answer;\n\n        if (lower_bound <= upper_bound) {\n            // Contradict the current bounds\n            sign = \">=\";\n            x = upper_bound;\n            answer = 'N';\n            queries.push_back(sign + \" \" + to_string(x) + \" \" + answer);\n        } else {\n            // Constraints already impossible; any query\n            sign = signs[rnd.next(0, 3)];\n            x = rnd.next(-1000000000LL, 1000000000LL);\n            answer = rnd.next(0, 1) ? 'Y' : 'N';\n            queries.push_back(sign + \" \" + to_string(x) + \" \" + answer);\n        }\n\n        cout << n << endl;\n        for(const auto& q : queries) {\n            cout << q << endl;\n        }\n    } else if (type == \"narrow\") {\n        // Generate a test case where the range of possible y is narrow\n        int64_t y = rnd.next(-2000000000LL, 2000000000LL);\n        int64_t lower_bound = -2000000000LL;\n        int64_t upper_bound = 2000000000LL;\n        vector<string> queries;\n        vector<string> signs = {\">\", \"<\", \">=\", \"<=\"};\n\n        for(int i = 0; i < n; ++i) {\n            string sign;\n            int64_t x;\n            char answer = 'Y';\n\n            if (lower_bound < y && y < upper_bound) {\n                if (i % 2 == 0) {\n                    // Adjust lower_bound upwards towards y\n                    x = rnd.next(lower_bound, y - 1);\n                    sign = rnd.next(0,1) ? \">\" : \">=\";\n                    if (sign == \">\") {\n                        lower_bound = max(lower_bound, x + 1);\n                    } else {\n                        lower_bound = max(lower_bound, x);\n                    }\n                } else {\n                    // Adjust upper_bound downwards towards y\n                    x = rnd.next(y + 1, upper_bound);\n                    sign = rnd.next(0,1) ? \"<\" : \"<=\";\n                    if (sign == \"<\") {\n                        upper_bound = min(upper_bound, x - 1);\n                    } else {\n                        upper_bound = min(upper_bound, x);\n                    }\n                }\n                queries.push_back(sign + \" \" + to_string(x) + \" \" + answer);\n            } else {\n                // The range is already narrow; output any valid query\n                sign = signs[rnd.next(0, 3)];\n                x = y;\n                if (sign == \">\") {\n                    answer = 'N';\n                } else if (sign == \">=\") {\n                    answer = 'Y';\n                } else if (sign == \"<\") {\n                    answer = 'N';\n                } else if (sign == \"<=\") {\n                    answer = 'Y';\n                }\n                queries.push_back(sign + \" \" + to_string(x) + \" \" + answer);\n            }\n        }\n\n        cout << n << endl;\n        for(const auto& q : queries) {\n            cout << q << endl;\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"valid\");\n\n    if (type == \"valid\") {\n        // Generate a valid test case where there exists at least one valid y\n        int64_t y = rnd.next(-2000000000LL, 2000000000LL);\n        vector<string> signs = {\">\", \"<\", \">=\", \"<=\"};\n\n        cout << n << endl;\n        for(int i = 0; i < n; ++i) {\n            string sign = signs[rnd.next(0, 3)];\n            int64_t x = rnd.next(-1000000000LL, 1000000000LL);\n            char answer;\n\n            if (sign == \">\") {\n                answer = (y > x) ? 'Y' : 'N';\n            } else if (sign == \"<\") {\n                answer = (y < x) ? 'Y' : 'N';\n            } else if (sign == \">=\") {\n                answer = (y >= x) ? 'Y' : 'N';\n            } else if (sign == \"<=\") {\n                answer = (y <= x) ? 'Y' : 'N';\n            }\n            cout << sign << \" \" << x << \" \" << answer << endl;\n        }\n    } else if (type == \"impossible\") {\n        // Generate a test case where it is impossible to find a valid y\n        int64_t lower_bound = -2000000000LL;\n        int64_t upper_bound = 2000000000LL;\n        vector<string> signs = {\">\", \"<\", \">=\", \"<=\"};\n        vector<string> queries;\n\n        for(int i = 0; i < n - 1; ++i) {\n            string sign = signs[rnd.next(0, 3)];\n            int64_t x = rnd.next(-1000000000LL, 1000000000LL);\n            char answer = rnd.next(0, 1) ? 'Y' : 'N';\n\n            // Update bounds based on the answer\n            if (answer == 'Y') {\n                if (sign == \">\") {\n                    lower_bound = max(lower_bound, x + 1);\n                } else if (sign == \">=\") {\n                    lower_bound = max(lower_bound, x);\n                } else if (sign == \"<\") {\n                    upper_bound = min(upper_bound, x - 1);\n                } else if (sign == \"<=\") {\n                    upper_bound = min(upper_bound, x);\n                }\n            } else {\n                if (sign == \">\") {\n                    upper_bound = min(upper_bound, x);\n                } else if (sign == \">=\") {\n                    upper_bound = min(upper_bound, x - 1);\n                } else if (sign == \"<\") {\n                    lower_bound = max(lower_bound, x);\n                } else if (sign == \"<=\") {\n                    lower_bound = max(lower_bound, x + 1);\n                }\n            }\n            queries.push_back(sign + \" \" + to_string(x) + \" \" + answer);\n        }\n\n        // Make the last query to ensure the problem is impossible\n        string sign;\n        int64_t x;\n        char answer;\n\n        if (lower_bound <= upper_bound) {\n            // Contradict the current bounds\n            sign = \">=\";\n            x = upper_bound;\n            answer = 'N';\n            queries.push_back(sign + \" \" + to_string(x) + \" \" + answer);\n        } else {\n            // Constraints already impossible; any query\n            sign = signs[rnd.next(0, 3)];\n            x = rnd.next(-1000000000LL, 1000000000LL);\n            answer = rnd.next(0, 1) ? 'Y' : 'N';\n            queries.push_back(sign + \" \" + to_string(x) + \" \" + answer);\n        }\n\n        cout << n << endl;\n        for(const auto& q : queries) {\n            cout << q << endl;\n        }\n    } else if (type == \"narrow\") {\n        // Generate a test case where the range of possible y is narrow\n        int64_t y = rnd.next(-2000000000LL, 2000000000LL);\n        int64_t lower_bound = -2000000000LL;\n        int64_t upper_bound = 2000000000LL;\n        vector<string> queries;\n        vector<string> signs = {\">\", \"<\", \">=\", \"<=\"};\n\n        for(int i = 0; i < n; ++i) {\n            string sign;\n            int64_t x;\n            char answer = 'Y';\n\n            if (lower_bound < y && y < upper_bound) {\n                if (i % 2 == 0) {\n                    // Adjust lower_bound upwards towards y\n                    x = rnd.next(lower_bound, y - 1);\n                    sign = rnd.next(0,1) ? \">\" : \">=\";\n                    if (sign == \">\") {\n                        lower_bound = max(lower_bound, x + 1);\n                    } else {\n                        lower_bound = max(lower_bound, x);\n                    }\n                } else {\n                    // Adjust upper_bound downwards towards y\n                    x = rnd.next(y + 1, upper_bound);\n                    sign = rnd.next(0,1) ? \"<\" : \"<=\";\n                    if (sign == \"<\") {\n                        upper_bound = min(upper_bound, x - 1);\n                    } else {\n                        upper_bound = min(upper_bound, x);\n                    }\n                }\n                queries.push_back(sign + \" \" + to_string(x) + \" \" + answer);\n            } else {\n                // The range is already narrow; output any valid query\n                sign = signs[rnd.next(0, 3)];\n                x = y;\n                if (sign == \">\") {\n                    answer = 'N';\n                } else if (sign == \">=\") {\n                    answer = 'Y';\n                } else if (sign == \"<\") {\n                    answer = 'N';\n                } else if (sign == \"<=\") {\n                    answer = 'Y';\n                }\n                queries.push_back(sign + \" \" + to_string(x) + \" \" + answer);\n            }\n        }\n\n        cout << n << endl;\n        for(const auto& q : queries) {\n            cout << q << endl;\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type valid\n./gen -n 2 -type valid\n./gen -n 10 -type valid\n./gen -n 100 -type valid\n./gen -n 500 -type valid\n./gen -n 1000 -type valid\n./gen -n 5000 -type valid\n./gen -n 10000 -type valid\n\n./gen -n 1 -type impossible\n./gen -n 2 -type impossible\n./gen -n 10 -type impossible\n./gen -n 100 -type impossible\n./gen -n 500 -type impossible\n./gen -n 1000 -type impossible\n./gen -n 5000 -type impossible\n./gen -n 10000 -type impossible\n\n./gen -n 1 -type narrow\n./gen -n 2 -type narrow\n./gen -n 10 -type narrow\n./gen -n 100 -type narrow\n./gen -n 500 -type narrow\n./gen -n 1000 -type narrow\n./gen -n 5000 -type narrow\n./gen -n 10000 -type narrow\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:48.642114",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "416/B",
      "title": "B. Art Union",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integers m, n (1 ≤ m ≤ 50000, 1 ≤ n ≤ 5), where m is the number of pictures and n is the number of painters. Then follow the descriptions of the pictures, one per line. Each line contains n integers ti1, ti2, ..., tin (1 ≤ tij ≤ 1000), where tij is the time the j-th painter needs to work on the i-th picture.",
      "output_spec": "OutputPrint the sequence of m integers r1, r2, ..., rm, where ri is the moment when the n-th painter stopped working on the i-th picture.",
      "sample_tests": "ExamplesInputCopy5 112345OutputCopy1 3 6 10 15 InputCopy4 22 53 15 310 1OutputCopy7 8 13 21",
      "description": "B. Art Union\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integers m, n (1 ≤ m ≤ 50000, 1 ≤ n ≤ 5), where m is the number of pictures and n is the number of painters. Then follow the descriptions of the pictures, one per line. Each line contains n integers ti1, ti2, ..., tin (1 ≤ tij ≤ 1000), where tij is the time the j-th painter needs to work on the i-th picture.\n\nOutputPrint the sequence of m integers r1, r2, ..., rm, where ri is the moment when the n-th painter stopped working on the i-th picture.\n\nInputCopy5 112345OutputCopy1 3 6 10 15 InputCopy4 22 53 15 310 1OutputCopy7 8 13 21\n\nInputCopy5 112345\n\nOutputCopy1 3 6 10 15\n\nInputCopy4 22 53 15 310 1\n\nOutputCopy7 8 13 21",
      "solutions": [
        {
          "title": "Codeforces Round #241 (Div. 2) - Codeforces",
          "content": "The round will start on 08:00 (UTC) of April, 13. It will be a kind of unusual round because at first for a long time Gerald didn't work much on round. It was prepared by me (how it is interesting to write a round!), Nerevar with the help of Gerald and Fefer_Ivan-а. Maria, many thanks for translations!It will be classical points: 500 — 1000 — 1500 — 2000 — 2500.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11623",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 364
        },
        {
          "title": "Codeforces Round #241 — editorial - Codeforces",
          "content": "416A - Guess a number!Let's use the usual Div 2 problem A approach — the naive one. We will track the interval which might contain the number we're guessing. With each of the query we update this interval. If at the end the interval is non-empty then we output any number from it, otherwise the result is \"Impossible\".Submission: 6606892416B - Art UnionAll we need is to iterate over all painters and for each painter to iterate over all pictures. In the inner loop we also remember when the painter finished working on the picture to make sure that the next painter will not start working on it earlier.Submission: 6606994416C - Booking SystemLet's solve this one greedy. All we need to notice is that the optimal solution will be to place first the groups with biggest sum which they are ready to pay. For each such group it will be optimal to allocate the smallest matching table. The input limits allow to do a full search when looking for a table.Submission: 6617198416D - Population SizeOne thing to notice for this problem is that if we cover some interval with a progression then it will better (at least no worse) to include as many elements to the right of it as possible. So the solution is to greedy — find the leftmost number not covered by a progression, start a new progression with that number (the interval covered by that progression will be of size 1) and then try to extend this interval to the right as far as possible. Repeat this step until all the numbers are covered. One thing you should pay attention to is which numbers can be covered by one arithmetic progression, for example: If there are no fixed numbers in the interval then we can cover it with one progression. If there is only one non-fixed number in the interval then we can cover this interval with one progression. If there are more than one non-fixed numbers in the interval then we can calculate the parameters of the progression (start value and difference). All non-fixed numbers should match those parameters. Difference should be integer. If the progression is ascending and there are some non-fixed numbers in the beginning then those numbers should match positive numbers in the progression. Same way if the progression is descending then we can include numbers from the right side only while matching progression term is positive. Submission: 6607174416E - President's PathLet's look at the graph given to us in the example:We need to count the count of the edges on all the shortest paths between each pair of vertices. Let's do something easier first — instead of counting all the edges we will count only those which have the destination vertex on its side. For example here are the edges belonging to shortest paths from 4 to 2 which are connected to vertex 2: Let's denote this number like this: inEdgessource, v — number of edges which go into vertex v on some shortest path from source to v. In the given example inEdges4, 2 = 3. Let's also denote the set Ssource, dest — it is a set of the vertices which belong to at least one shortest path from source to dest. For example S4, 2 = {1, 2, 3, 4}. With these two variables it can be seen that the answer for vertices source and dest will be: In other words the answer for vertices s and d will be equal to the sum of inEdgess, v for all vertices v, which belong to any shortest path from s to d. So the only thing left is to calculate these S and inEdges. Both of them can be easily calculated if you have minimum distances between all pairs of vertices. And these distances can be calculated using the Floyd-Warshall. So the full solution is: Calculate minimum distances between all pairs of vertices using Floyd-Warshall algorithm. Count inEdges. Simply iterate over all source vertices and all edges. For each edge check whether any of its ends belong to any shortest path from source. Calculate the answer. Let's have three loops to iterate over the vertices — — source, destination и mid. First two vertices are those for which we're calculating the answer. Third vertex is the vertex which should belong to any shortest path (basically we're checking whether v belongs to Ssource, dest). If mid belongs to any shortest path from source to dest then we add inEdgessource, mid to the answer. Each step has a complexity O(n3).Submission: 6607257P.S.: Please feel free to let me know about any typos, errors, etc using the private messages.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12277",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 416\\s*B"
          },
          "content_length": 4397
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 50000, \"m\");\n    inf.readSpace();\n    int n = inf.readInt(1, 5, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        vector<int> tij = inf.readInts(n, 1, 1000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 50000, \"m\");\n    inf.readSpace();\n    int n = inf.readInt(1, 5, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        vector<int> tij = inf.readInts(n, 1, 1000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(1, 50000, \"m\");\n    inf.readSpace();\n    int n = inf.readInt(1, 5, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        vector<int> tij = inf.readInts(n, 1, 1000);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int m = opt<int>(\"m\");\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that n is between 1 and 5\n    ensure(n >= 1 && n <= 5);\n    // Ensure that m is between 1 and 50000\n    ensure(m >= 1 && m <= 50000);\n\n    vector<vector<int>> t(m, vector<int>(n));\n\n    if (type == \"random\") {\n        // t_{ij} random in [1, 1000]\n        for (int i = 0; i < m; ++i){\n            for (int j = 0; j < n; ++j){\n                t[i][j] = rnd.next(1, 1000);\n            }\n        }\n    } else if (type == \"max_times\") {\n        // t_{ij} = 1000\n        for (int i = 0; i < m; ++i){\n            for (int j = 0; j < n; ++j){\n                t[i][j] = 1000;\n            }\n        }\n    } else if (type == \"min_times\") {\n        // t_{ij} = 1\n        for (int i = 0; i < m; ++i){\n            for (int j = 0; j < n; ++j){\n                t[i][j] = 1;\n            }\n        }\n    } else if (type == \"increasing_times\") {\n        // t_{ij} increases over i\n        int val = 1;\n        for (int i = 0; i < m; ++i){\n            for (int j = 0; j < n; ++j){\n                t[i][j] = val;\n            }\n            val = min(val + 1, 1000);\n        }\n    } else if (type == \"decreasing_times\") {\n        // t_{ij} decreases over i\n        int val = 1000;\n        for (int i = 0; i < m; ++i){\n            for (int j = 0; j < n; ++j){\n                t[i][j] = val;\n            }\n            val = max(val - 1, 1);\n        }\n    } else if (type == \"painter_dominant\") {\n        int dominant_painter = opt<int>(\"p\", 0); // default dominant painter is 0\n        ensure(dominant_painter >= 0 && dominant_painter < n);\n        // t_{ij}\n        for (int i = 0; i < m; ++i){\n            for (int j = 0; j < n; ++j){\n                if (j == dominant_painter)\n                    t[i][j] = 1000; // dominant painter takes maximum time\n                else\n                    t[i][j] = 1; // others take minimal time\n            }\n        }\n    } else if (type == \"same_times\") {\n        int same_time = opt<int>(\"t\", 1); // default time is 1\n        ensure(same_time >= 1 && same_time <= 1000);\n        for (int i = 0; i < m; ++i){\n            for (int j = 0; j < n; ++j){\n                t[i][j] = same_time;\n            }\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < m; ++i){\n            for (int j = 0; j < n; ++j){\n                t[i][j] = rnd.next(1, 1000);\n            }\n        }\n    }\n\n    // Now output the data\n\n    printf(\"%d %d\\n\", m, n);\n    for (int i = 0; i < m; ++i){\n        for (int j = 0; j < n; ++j){\n            if (j > 0) printf(\" \");\n            printf(\"%d\", t[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int m = opt<int>(\"m\");\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure that n is between 1 and 5\n    ensure(n >= 1 && n <= 5);\n    // Ensure that m is between 1 and 50000\n    ensure(m >= 1 && m <= 50000);\n\n    vector<vector<int>> t(m, vector<int>(n));\n\n    if (type == \"random\") {\n        // t_{ij} random in [1, 1000]\n        for (int i = 0; i < m; ++i){\n            for (int j = 0; j < n; ++j){\n                t[i][j] = rnd.next(1, 1000);\n            }\n        }\n    } else if (type == \"max_times\") {\n        // t_{ij} = 1000\n        for (int i = 0; i < m; ++i){\n            for (int j = 0; j < n; ++j){\n                t[i][j] = 1000;\n            }\n        }\n    } else if (type == \"min_times\") {\n        // t_{ij} = 1\n        for (int i = 0; i < m; ++i){\n            for (int j = 0; j < n; ++j){\n                t[i][j] = 1;\n            }\n        }\n    } else if (type == \"increasing_times\") {\n        // t_{ij} increases over i\n        int val = 1;\n        for (int i = 0; i < m; ++i){\n            for (int j = 0; j < n; ++j){\n                t[i][j] = val;\n            }\n            val = min(val + 1, 1000);\n        }\n    } else if (type == \"decreasing_times\") {\n        // t_{ij} decreases over i\n        int val = 1000;\n        for (int i = 0; i < m; ++i){\n            for (int j = 0; j < n; ++j){\n                t[i][j] = val;\n            }\n            val = max(val - 1, 1);\n        }\n    } else if (type == \"painter_dominant\") {\n        int dominant_painter = opt<int>(\"p\", 0); // default dominant painter is 0\n        ensure(dominant_painter >= 0 && dominant_painter < n);\n        // t_{ij}\n        for (int i = 0; i < m; ++i){\n            for (int j = 0; j < n; ++j){\n                if (j == dominant_painter)\n                    t[i][j] = 1000; // dominant painter takes maximum time\n                else\n                    t[i][j] = 1; // others take minimal time\n            }\n        }\n    } else if (type == \"same_times\") {\n        int same_time = opt<int>(\"t\", 1); // default time is 1\n        ensure(same_time >= 1 && same_time <= 1000);\n        for (int i = 0; i < m; ++i){\n            for (int j = 0; j < n; ++j){\n                t[i][j] = same_time;\n            }\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < m; ++i){\n            for (int j = 0; j < n; ++j){\n                t[i][j] = rnd.next(1, 1000);\n            }\n        }\n    }\n\n    // Now output the data\n\n    printf(\"%d %d\\n\", m, n);\n    for (int i = 0; i < m; ++i){\n        for (int j = 0; j < n; ++j){\n            if (j > 0) printf(\" \");\n            printf(\"%d\", t[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small m and n, random times\n./gen -m 1 -n 1 -type random\n./gen -m 1 -n 5 -type random\n./gen -m 2 -n 2 -type random\n./gen -m 10 -n 3 -type random\n\n# Small m and n, minimal times\n./gen -m 1 -n 1 -type min_times\n./gen -m 10 -n 2 -type min_times\n\n# Small m and n, maximal times\n./gen -m 1 -n 1 -type max_times\n./gen -m 10 -n 2 -type max_times\n\n# Large m, random times\n./gen -m 1000 -n 2 -type random\n./gen -m 10000 -n 3 -type random\n./gen -m 50000 -n 5 -type random\n\n# Large m, minimal times\n./gen -m 10000 -n 4 -type min_times\n./gen -m 50000 -n 5 -type min_times\n\n# Large m, maximal times\n./gen -m 10000 -n 5 -type max_times\n./gen -m 50000 -n 5 -type max_times\n\n# Test cases with same_times\n./gen -m 100 -n 3 -type same_times -t 100\n./gen -m 1000 -n 4 -type same_times -t 999\n./gen -m 10000 -n 5 -type same_times -t 500\n\n# Test cases with increasing_times\n./gen -m 1000 -n 2 -type increasing_times\n./gen -m 10000 -n 3 -type increasing_times\n\n# Test cases with decreasing_times\n./gen -m 1000 -n 2 -type decreasing_times\n./gen -m 10000 -n 3 -type decreasing_times\n\n# Test cases with painter_dominant\n./gen -m 1000 -n 3 -type painter_dominant -p 0\n./gen -m 1000 -n 3 -type painter_dominant -p 1\n./gen -m 1000 -n 3 -type painter_dominant -p 2\n./gen -m 50000 -n 5 -type painter_dominant -p 4\n\n# Edge cases with m = 50000, n = 1\n./gen -m 50000 -n 1 -type random\n./gen -m 50000 -n 1 -type min_times\n./gen -m 50000 -n 1 -type max_times\n\n# Test with m = 1, n = 5\n./gen -m 1 -n 5 -type random\n./gen -m 1 -n 5 -type min_times\n./gen -m 1 -n 5 -type max_times\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:50.841834",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "416/C",
      "title": "C. Booking System",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (1 ≤ n ≤ 1000) — the number of requests from visitors. Then n lines follow. Each line contains two integers: ci, pi (1 ≤ ci, pi ≤ 1000) — the size of the group of visitors who will come by the i-th request and the total sum of money they will pay when they visit the restaurant, correspondingly.The next line contains integer k (1 ≤ k ≤ 1000) — the number of tables in the restaurant. The last line contains k space-separated integers: r1, r2, ..., rk (1 ≤ ri ≤ 1000) — the maximum number of people that can sit at each table.",
      "output_spec": "OutputIn the first line print two integers: m, s — the number of accepted requests and the total money you get from these requests, correspondingly.Then print m lines — each line must contain two space-separated integers: the number of the accepted request and the number of the table to seat people who come via this request. The requests and the tables are consecutively numbered starting from 1 in the order in which they are given in the input.If there are multiple optimal answers, print any of them.",
      "sample_tests": "ExamplesInputCopy310 502 1005 3034 6 9OutputCopy2 1302 13 2",
      "description": "C. Booking System\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n (1 ≤ n ≤ 1000) — the number of requests from visitors. Then n lines follow. Each line contains two integers: ci, pi (1 ≤ ci, pi ≤ 1000) — the size of the group of visitors who will come by the i-th request and the total sum of money they will pay when they visit the restaurant, correspondingly.The next line contains integer k (1 ≤ k ≤ 1000) — the number of tables in the restaurant. The last line contains k space-separated integers: r1, r2, ..., rk (1 ≤ ri ≤ 1000) — the maximum number of people that can sit at each table.\n\nOutputIn the first line print two integers: m, s — the number of accepted requests and the total money you get from these requests, correspondingly.Then print m lines — each line must contain two space-separated integers: the number of the accepted request and the number of the table to seat people who come via this request. The requests and the tables are consecutively numbered starting from 1 in the order in which they are given in the input.If there are multiple optimal answers, print any of them.\n\nInputCopy310 502 1005 3034 6 9OutputCopy2 1302 13 2\n\nInputCopy310 502 1005 3034 6 9\n\nOutputCopy2 1302 13 2",
      "solutions": [
        {
          "title": "Codeforces Round #241 (Div. 2) - Codeforces",
          "content": "The round will start on 08:00 (UTC) of April, 13. It will be a kind of unusual round because at first for a long time Gerald didn't work much on round. It was prepared by me (how it is interesting to write a round!), Nerevar with the help of Gerald and Fefer_Ivan-а. Maria, many thanks for translations!It will be classical points: 500 — 1000 — 1500 — 2000 — 2500.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11623",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 364
        },
        {
          "title": "Codeforces Round #241 — editorial - Codeforces",
          "content": "416A - Guess a number!Let's use the usual Div 2 problem A approach — the naive one. We will track the interval which might contain the number we're guessing. With each of the query we update this interval. If at the end the interval is non-empty then we output any number from it, otherwise the result is \"Impossible\".Submission: 6606892416B - Art UnionAll we need is to iterate over all painters and for each painter to iterate over all pictures. In the inner loop we also remember when the painter finished working on the picture to make sure that the next painter will not start working on it earlier.Submission: 6606994416C - Booking SystemLet's solve this one greedy. All we need to notice is that the optimal solution will be to place first the groups with biggest sum which they are ready to pay. For each such group it will be optimal to allocate the smallest matching table. The input limits allow to do a full search when looking for a table.Submission: 6617198416D - Population SizeOne thing to notice for this problem is that if we cover some interval with a progression then it will better (at least no worse) to include as many elements to the right of it as possible. So the solution is to greedy — find the leftmost number not covered by a progression, start a new progression with that number (the interval covered by that progression will be of size 1) and then try to extend this interval to the right as far as possible. Repeat this step until all the numbers are covered. One thing you should pay attention to is which numbers can be covered by one arithmetic progression, for example: If there are no fixed numbers in the interval then we can cover it with one progression. If there is only one non-fixed number in the interval then we can cover this interval with one progression. If there are more than one non-fixed numbers in the interval then we can calculate the parameters of the progression (start value and difference). All non-fixed numbers should match those parameters. Difference should be integer. If the progression is ascending and there are some non-fixed numbers in the beginning then those numbers should match positive numbers in the progression. Same way if the progression is descending then we can include numbers from the right side only while matching progression term is positive. Submission: 6607174416E - President's PathLet's look at the graph given to us in the example:We need to count the count of the edges on all the shortest paths between each pair of vertices. Let's do something easier first — instead of counting all the edges we will count only those which have the destination vertex on its side. For example here are the edges belonging to shortest paths from 4 to 2 which are connected to vertex 2: Let's denote this number like this: inEdgessource, v — number of edges which go into vertex v on some shortest path from source to v. In the given example inEdges4, 2 = 3. Let's also denote the set Ssource, dest — it is a set of the vertices which belong to at least one shortest path from source to dest. For example S4, 2 = {1, 2, 3, 4}. With these two variables it can be seen that the answer for vertices source and dest will be: In other words the answer for vertices s and d will be equal to the sum of inEdgess, v for all vertices v, which belong to any shortest path from s to d. So the only thing left is to calculate these S and inEdges. Both of them can be easily calculated if you have minimum distances between all pairs of vertices. And these distances can be calculated using the Floyd-Warshall. So the full solution is: Calculate minimum distances between all pairs of vertices using Floyd-Warshall algorithm. Count inEdges. Simply iterate over all source vertices and all edges. For each edge check whether any of its ends belong to any shortest path from source. Calculate the answer. Let's have three loops to iterate over the vertices — — source, destination и mid. First two vertices are those for which we're calculating the answer. Third vertex is the vertex which should belong to any shortest path (basically we're checking whether v belongs to Ssource, dest). If mid belongs to any shortest path from source to dest then we add inEdgessource, mid to the answer. Each step has a complexity O(n3).Submission: 6607257P.S.: Please feel free to let me know about any typos, errors, etc using the private messages.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12277",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 416\\s*C"
          },
          "content_length": 4397
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; ++i) {\n        int ci = inf.readInt(1, 1000, \"ci\");\n        inf.readSpace();\n        int pi = inf.readInt(1, 1000, \"pi\");\n        inf.readEoln();\n    }\n    \n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    \n    vector<int> ri = inf.readInts(k, 1, 1000, \"ri\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; ++i) {\n        int ci = inf.readInt(1, 1000, \"ci\");\n        inf.readSpace();\n        int pi = inf.readInt(1, 1000, \"pi\");\n        inf.readEoln();\n    }\n    \n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    \n    vector<int> ri = inf.readInts(k, 1, 1000, \"ri\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; ++i) {\n        int ci = inf.readInt(1, 1000, \"ci\");\n        inf.readSpace();\n        int pi = inf.readInt(1, 1000, \"pi\");\n        inf.readEoln();\n    }\n    \n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    \n    vector<int> ri = inf.readInts(k, 1, 1000, \"ri\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Request {\n    int c; // size of the group\n    int p; // total money they will pay\n};\n\nint n; // number of requests\nvector<Request> requests;\nint k; // number of tables\nvector<int> tables;\n\nint readAns(InStream& stream) {\n    int m = stream.readInt(0, min(n, k), \"number of accepted requests\");\n    int s = stream.readInt(0, accumulate(requests.begin(), requests.end(), 0, [](int sum, const Request& r){ return sum + r.p; }), \"total money\");\n    set<int> used_requests;\n    set<int> used_tables;\n    int total_money = 0;\n    for (int i = 0; i < m; i++) {\n        int req_num = stream.readInt(1, n, format(\"request number on line %d\", i + 2).c_str());\n        int table_num = stream.readInt(1, k, format(\"table number on line %d\", i + 2).c_str());\n        if (used_requests.count(req_num)) {\n            stream.quitf(_wa, \"request %d is assigned more than once\", req_num);\n        }\n        if (used_tables.count(table_num)) {\n            stream.quitf(_wa, \"table %d is assigned more than once\", table_num);\n        }\n        if (requests[req_num - 1].c > tables[table_num - 1]) {\n            stream.quitf(_wa, \"group size %d of request %d does not fit on table size %d of table %d\", requests[req_num - 1].c, req_num, tables[table_num - 1], table_num);\n        }\n        used_requests.insert(req_num);\n        used_tables.insert(table_num);\n        total_money += requests[req_num - 1].p;\n    }\n    if (total_money != s) {\n        stream.quitf(_wa, \"calculated total money %d does not match given total money %d\", total_money, s);\n    }\n    return total_money;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, 1000, \"n\");\n    requests.resize(n);\n    for (int i = 0; i < n; i++) {\n        int c = inf.readInt(1, 1000, format(\"c[%d]\", i + 1).c_str());\n        int p = inf.readInt(1, 1000, format(\"p[%d]\", i + 1).c_str());\n        requests[i] = {c, p};\n    }\n    k = inf.readInt(1, 1000, \"k\");\n    tables.resize(k);\n    for (int i = 0; i < k; i++) {\n        tables[i] = inf.readInt(1, 1000, format(\"r[%d]\", i + 1).c_str());\n    }\n\n    // Read jury's answer\n    int s_jans = readAns(ans);\n    // Read participant's answer\n    int s_pans = readAns(ouf);\n\n    if (s_pans < s_jans) {\n        quitf(_wa, \"jury has better answer: s_jury = %d, s_participant = %d\", s_jans, s_pans);\n    } else if (s_pans == s_jans) {\n        quitf(_ok, \"Accepted, total money = %d\", s_pans);\n    } else {\n        quitf(_fail, \"participant has better answer: s_jury = %d, s_participant = %d\", s_jans, s_pans);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> ci(n);\n    vector<int> pi(n);\n    vector<int> ri(k);\n    \n    if(type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 1000);\n            pi[i] = rnd.next(1, 1000);\n        }\n        for(int i = 0; i < k; ++i) {\n            ri[i] = rnd.next(1, 1000);\n        }\n    } else if(type == \"max_ci\") {\n        for(int i = 0; i < n; ++i) {\n            ci[i] = 1000;\n            pi[i] = rnd.next(1, 1000);\n        }\n        for(int i = 0; i < k; ++i) {\n            // Include some tables that can seat 1000 people\n            ri[i] = rnd.next(1000 - (i % 2), 1000);\n        }\n    } else if(type == \"exact_fit\") {\n        vector<int> capacities;\n        for(int i = 0; i < max(n, k); ++i) {\n            capacities.push_back(rnd.next(1, 1000));\n        }\n        shuffle(capacities.begin(), capacities.end());\n        for(int i = 0; i < n; ++i) {\n            ci[i] = capacities[i];\n            pi[i] = rnd.next(1, 1000);\n        }\n        shuffle(capacities.begin(), capacities.end());\n        for(int i = 0; i < k; ++i) {\n            ri[i] = capacities[i];\n        }\n    } else if(type == \"over_capacity\") {\n        for(int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(501, 1000); // ci >= 501\n            pi[i] = rnd.next(1, 1000);\n        }\n        for(int i = 0; i < k; ++i) {\n            ri[i] = rnd.next(1, 500); // ri <= 500\n        }\n    } else if(type == \"under_capacity\") {\n        for(int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 500); // ci <= 500\n            pi[i] = rnd.next(1, 1000);\n        }\n        for(int i = 0; i < k; ++i) {\n            ri[i] = rnd.next(501, 1000); // ri >= 501\n        }\n    } else if(type == \"conflict_pi\") {\n        for(int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 1000);\n            pi[i] = 1001 - ci[i]; // Higher pi for smaller ci\n        }\n        for(int i = 0; i < k; ++i) {\n            ri[i] = rnd.next(1, 1000);\n        }\n    } else {\n        // Default to random if unknown type\n        for(int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 1000);\n            pi[i] = rnd.next(1, 1000);\n        }\n        for(int i = 0; i < k; ++i) {\n            ri[i] = rnd.next(1, 1000);\n        }\n    }\n    \n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", ci[i], pi[i]);\n    }\n    printf(\"%d\\n\", k);\n    for(int i = 0; i < k; ++i) {\n        printf(\"%d%c\", ri[i], i == k - 1 ? '\\n' : ' ');\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> ci(n);\n    vector<int> pi(n);\n    vector<int> ri(k);\n    \n    if(type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 1000);\n            pi[i] = rnd.next(1, 1000);\n        }\n        for(int i = 0; i < k; ++i) {\n            ri[i] = rnd.next(1, 1000);\n        }\n    } else if(type == \"max_ci\") {\n        for(int i = 0; i < n; ++i) {\n            ci[i] = 1000;\n            pi[i] = rnd.next(1, 1000);\n        }\n        for(int i = 0; i < k; ++i) {\n            // Include some tables that can seat 1000 people\n            ri[i] = rnd.next(1000 - (i % 2), 1000);\n        }\n    } else if(type == \"exact_fit\") {\n        vector<int> capacities;\n        for(int i = 0; i < max(n, k); ++i) {\n            capacities.push_back(rnd.next(1, 1000));\n        }\n        shuffle(capacities.begin(), capacities.end());\n        for(int i = 0; i < n; ++i) {\n            ci[i] = capacities[i];\n            pi[i] = rnd.next(1, 1000);\n        }\n        shuffle(capacities.begin(), capacities.end());\n        for(int i = 0; i < k; ++i) {\n            ri[i] = capacities[i];\n        }\n    } else if(type == \"over_capacity\") {\n        for(int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(501, 1000); // ci >= 501\n            pi[i] = rnd.next(1, 1000);\n        }\n        for(int i = 0; i < k; ++i) {\n            ri[i] = rnd.next(1, 500); // ri <= 500\n        }\n    } else if(type == \"under_capacity\") {\n        for(int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 500); // ci <= 500\n            pi[i] = rnd.next(1, 1000);\n        }\n        for(int i = 0; i < k; ++i) {\n            ri[i] = rnd.next(501, 1000); // ri >= 501\n        }\n    } else if(type == \"conflict_pi\") {\n        for(int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 1000);\n            pi[i] = 1001 - ci[i]; // Higher pi for smaller ci\n        }\n        for(int i = 0; i < k; ++i) {\n            ri[i] = rnd.next(1, 1000);\n        }\n    } else {\n        // Default to random if unknown type\n        for(int i = 0; i < n; ++i) {\n            ci[i] = rnd.next(1, 1000);\n            pi[i] = rnd.next(1, 1000);\n        }\n        for(int i = 0; i < k; ++i) {\n            ri[i] = rnd.next(1, 1000);\n        }\n    }\n    \n    // Output\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", ci[i], pi[i]);\n    }\n    printf(\"%d\\n\", k);\n    for(int i = 0; i < k; ++i) {\n        printf(\"%d%c\", ri[i], i == k - 1 ? '\\n' : ' ');\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type random\n./gen -n 1 -k 1 -type exact_fit\n./gen -n 1 -k 1 -type over_capacity\n\n./gen -n 10 -k 5 -type random\n./gen -n 10 -k 5 -type max_ci\n./gen -n 10 -k 5 -type exact_fit\n./gen -n 10 -k 5 -type over_capacity\n./gen -n 10 -k 5 -type under_capacity\n./gen -n 10 -k 5 -type conflict_pi\n\n./gen -n 100 -k 100 -type random\n./gen -n 100 -k 50 -type max_ci\n./gen -n 50 -k 100 -type exact_fit\n./gen -n 100 -k 100 -type over_capacity\n./gen -n 50 -k 50 -type under_capacity\n./gen -n 100 -k 50 -type conflict_pi\n\n./gen -n 500 -k 500 -type random\n./gen -n 500 -k 250 -type exact_fit\n./gen -n 500 -k 250 -type over_capacity\n./gen -n 250 -k 500 -type under_capacity\n./gen -n 500 -k 500 -type conflict_pi\n\n./gen -n 1000 -k 1000 -type random\n./gen -n 1000 -k 500 -type max_ci\n./gen -n 1000 -k 500 -type over_capacity\n./gen -n 500 -k 1000 -type under_capacity\n./gen -n 1000 -k 1000 -type conflict_pi\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:52.696536",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "416/D",
      "title": "D. Population Size",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (1 ≤ n ≤ 2·105) — the number of elements in the sequence. The second line contains integer values a1, a2, ..., an separated by a space (1 ≤ ai ≤ 109 or ai =  - 1).",
      "output_spec": "OutputPrint the minimum number of arithmetic progressions that you need to write one after another to get sequence a. The positions marked as -1 in a can be represented by any positive integers.",
      "sample_tests": "ExamplesInputCopy98 6 4 2 1 4 7 10 2OutputCopy3InputCopy9-1 6 -1 2 -1 4 7 -1 2OutputCopy3InputCopy5-1 -1 -1 -1 -1OutputCopy1InputCopy7-1 -1 4 5 1 2 3OutputCopy2",
      "description": "D. Population Size\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n (1 ≤ n ≤ 2·105) — the number of elements in the sequence. The second line contains integer values a1, a2, ..., an separated by a space (1 ≤ ai ≤ 109 or ai =  - 1).\n\nOutputPrint the minimum number of arithmetic progressions that you need to write one after another to get sequence a. The positions marked as -1 in a can be represented by any positive integers.\n\nInputCopy98 6 4 2 1 4 7 10 2OutputCopy3InputCopy9-1 6 -1 2 -1 4 7 -1 2OutputCopy3InputCopy5-1 -1 -1 -1 -1OutputCopy1InputCopy7-1 -1 4 5 1 2 3OutputCopy2\n\nInputCopy98 6 4 2 1 4 7 10 2\n\nOutputCopy3\n\nInputCopy9-1 6 -1 2 -1 4 7 -1 2\n\nOutputCopy3\n\nInputCopy5-1 -1 -1 -1 -1\n\nOutputCopy1\n\nInputCopy7-1 -1 4 5 1 2 3\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Round #241 (Div. 2) - Codeforces",
          "content": "The round will start on 08:00 (UTC) of April, 13. It will be a kind of unusual round because at first for a long time Gerald didn't work much on round. It was prepared by me (how it is interesting to write a round!), Nerevar with the help of Gerald and Fefer_Ivan-а. Maria, many thanks for translations!It will be classical points: 500 — 1000 — 1500 — 2000 — 2500.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/11623",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 364
        },
        {
          "title": "Codeforces Round #241 — editorial - Codeforces",
          "content": "416A - Guess a number!Let's use the usual Div 2 problem A approach — the naive one. We will track the interval which might contain the number we're guessing. With each of the query we update this interval. If at the end the interval is non-empty then we output any number from it, otherwise the result is \"Impossible\".Submission: 6606892416B - Art UnionAll we need is to iterate over all painters and for each painter to iterate over all pictures. In the inner loop we also remember when the painter finished working on the picture to make sure that the next painter will not start working on it earlier.Submission: 6606994416C - Booking SystemLet's solve this one greedy. All we need to notice is that the optimal solution will be to place first the groups with biggest sum which they are ready to pay. For each such group it will be optimal to allocate the smallest matching table. The input limits allow to do a full search when looking for a table.Submission: 6617198416D - Population SizeOne thing to notice for this problem is that if we cover some interval with a progression then it will better (at least no worse) to include as many elements to the right of it as possible. So the solution is to greedy — find the leftmost number not covered by a progression, start a new progression with that number (the interval covered by that progression will be of size 1) and then try to extend this interval to the right as far as possible. Repeat this step until all the numbers are covered. One thing you should pay attention to is which numbers can be covered by one arithmetic progression, for example: If there are no fixed numbers in the interval then we can cover it with one progression. If there is only one non-fixed number in the interval then we can cover this interval with one progression. If there are more than one non-fixed numbers in the interval then we can calculate the parameters of the progression (start value and difference). All non-fixed numbers should match those parameters. Difference should be integer. If the progression is ascending and there are some non-fixed numbers in the beginning then those numbers should match positive numbers in the progression. Same way if the progression is descending then we can include numbers from the right side only while matching progression term is positive. Submission: 6607174416E - President's PathLet's look at the graph given to us in the example:We need to count the count of the edges on all the shortest paths between each pair of vertices. Let's do something easier first — instead of counting all the edges we will count only those which have the destination vertex on its side. For example here are the edges belonging to shortest paths from 4 to 2 which are connected to vertex 2: Let's denote this number like this: inEdgessource, v — number of edges which go into vertex v on some shortest path from source to v. In the given example inEdges4, 2 = 3. Let's also denote the set Ssource, dest — it is a set of the vertices which belong to at least one shortest path from source to dest. For example S4, 2 = {1, 2, 3, 4}. With these two variables it can be seen that the answer for vertices source and dest will be: In other words the answer for vertices s and d will be equal to the sum of inEdgess, v for all vertices v, which belong to any shortest path from s to d. So the only thing left is to calculate these S and inEdges. Both of them can be easily calculated if you have minimum distances between all pairs of vertices. And these distances can be calculated using the Floyd-Warshall. So the full solution is: Calculate minimum distances between all pairs of vertices using Floyd-Warshall algorithm. Count inEdges. Simply iterate over all source vertices and all edges. For each edge check whether any of its ends belong to any shortest path from source. Calculate the answer. Let's have three loops to iterate over the vertices — — source, destination и mid. First two vertices are those for which we're calculating the answer. Third vertex is the vertex which should belong to any shortest path (basically we're checking whether v belongs to Ssource, dest). If mid belongs to any shortest path from source to dest then we add inEdgessource, mid to the answer. Each step has a complexity O(n3).Submission: 6607257P.S.: Please feel free to let me know about any typos, errors, etc using the private messages.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/12277",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 416\\s*D"
          },
          "content_length": 4397
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    for (int i = 1; i <= n; ++i) {\n        int ai = inf.readInt(-1, 1000000000);\n        ensuref(ai == -1 || ai >= 1, \"a[%d] must be -1 or >= 1, but found %d\", i, ai);\n        if (i < n)\n            inf.readSpace();\n        else\n            inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    for (int i = 1; i <= n; ++i) {\n        int ai = inf.readInt(-1, 1000000000);\n        ensuref(ai == -1 || ai >= 1, \"a[%d] must be -1 or >= 1, but found %d\", i, ai);\n        if (i < n)\n            inf.readSpace();\n        else\n            inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    for (int i = 1; i <= n; ++i) {\n        int ai = inf.readInt(-1, 1000000000);\n        ensuref(ai == -1 || ai >= 1, \"a[%d] must be -1 or >= 1, but found %d\", i, ai);\n        if (i < n)\n            inf.readSpace();\n        else\n            inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_value = opt<int>(\"max_value\", (int)1e9);\n    double missing_prob = opt<double>(\"missing_prob\", 0.0);\n\n    vector<int> a(n);\n\n    if (type == \"all_missing\") {\n        for(int i = 0; i < n; ++i) a[i] = -1;\n    } else if (type == \"single_arithmetic\") {\n        // Generates a sequence that's a single arithmetic progression\n        int start = rnd.next(1, max_value);\n        int diff = rnd.next(-1000, 1000);\n        if (diff == 0) diff = 1; // ensure difference is not zero\n        for(int i = 0; i < n; ++i) {\n            long long val = 1LL*start + 1LL*i*diff;\n            while (val <= 0 || val > max_value) {\n                // Adjust diff to ensure val is within range\n                diff = rnd.next(-1000, 1000);\n                if (diff == 0) diff = 1;\n                val = 1LL*start + 1LL*i*diff;\n            }\n            a[i] = (int)val;\n            if (rnd.next(0.0, 1.0) < missing_prob) a[i] = -1;\n        }\n    } else if (type == \"multiple_arithmetics\") {\n        // Break sequence into several arithmetic progressions\n        int k = opt<int>(\"k\", 1);\n        int segment_length = n / k;\n        int rem = n % k;\n        int idx = 0;\n        for(int seg = 0; seg < k; ++seg) {\n            int len = segment_length + (seg < rem ? 1 : 0);\n            int start = rnd.next(1, max_value);\n            int diff = rnd.next(-1000, 1000);\n            if (diff == 0) diff = 1;\n            for(int i = 0; i < len; ++i) {\n                long long val = 1LL*start + 1LL*i*diff;\n                while (val <= 0 || val > max_value) {\n                    diff = rnd.next(-1000, 1000);\n                    if (diff == 0) diff = 1;\n                    val = 1LL*start + 1LL*i*diff;\n                }\n                a[idx] = (int)val;\n                if (rnd.next(0.0, 1.0) < missing_prob) a[idx] = -1;\n                idx++;\n            }\n        }\n    } else if (type == \"max_arithmetics\") {\n        // Generate sequence where minimal number of arithmetics is as big as possible\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_value);\n            if (rnd.next(0.0,1.0) < missing_prob) a[i] = -1;\n        }\n        // Ensure no three consecutive known numbers are in arithmetic progression\n        for(int i = 2; i < n; ++i) {\n            if (a[i-2] != -1 && a[i-1] != -1 && a[i] != -1) {\n                if (2LL*a[i-1] == a[i-2] + a[i]) {\n                    // Adjust a[i] to break the progression\n                    a[i] = (a[i]+1 <= max_value) ? a[i]+1 : a[i]-1;\n                    if (a[i] <= 0) a[i] = 1;\n                }\n            }\n        }\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_value);\n            if (rnd.next(0.0,1.0) < missing_prob) a[i] = -1;\n        }\n    } else if (type == \"alternating_missing\") {\n        for(int i = 0; i < n; ++i) {\n            if (i%2==0) {\n                a[i] = -1;\n            } else {\n                a[i] = rnd.next(1, max_value);\n            }\n        }\n    } else if (type == \"heavy_missing\") {\n        for(int i = 0; i < n; ++i) {\n            if (rnd.next(0.0,1.0) < 0.9) a[i]=-1;\n            else a[i]= rnd.next(1, max_value);\n        }\n    } else if (type == \"single_value\") {\n        int val = rnd.next(1, max_value);\n        for(int i = 0; i < n; ++i) {\n            a[i] = val;\n            if (rnd.next(0.0,1.0) < missing_prob) a[i] = -1;\n        }\n    } else if (type == \"large_diff_arithmetic\") {\n        // Generate arithmetic progression with large differences\n        int start = rnd.next(1, max_value);\n        int diff = rnd.next(-max_value+1, max_value-1);\n        if (diff == 0) diff = 1;\n        for(int i = 0; i < n; ++i) {\n            long long val = 1LL*start + 1LL*i*diff;\n            while (val <= 0 || val > max_value) {\n                diff = rnd.next(-max_value+1, max_value-1);\n                if (diff == 0) diff = 1;\n                val = 1LL*start + 1LL*i*diff;\n            }\n            a[i] = (int)val;\n            if (rnd.next(0.0,1.0) < missing_prob) a[i]=-1;\n        }\n    } else if (type == \"repeating_pattern\") {\n        int pattern_length = opt<int>(\"pattern_length\", 5);\n        vector<int> pattern(pattern_length);\n        for(int i = 0; i < pattern_length; ++i) {\n            pattern[i] = rnd.next(1, max_value);\n        }\n        for(int i = 0; i < n; ++i) {\n            a[i] = pattern[i % pattern_length];\n            if (rnd.next(0.0,1.0) < missing_prob) a[i]=-1;\n        }\n    } else {\n        // By default, generate random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_value);\n            if (rnd.next(0.0,1.0) < missing_prob) a[i] = -1;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the sequence\n    for(int i=0; i<n; i++) {\n        printf(\"%d%c\", a[i], (i==n-1)?'\\n':' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_value = opt<int>(\"max_value\", (int)1e9);\n    double missing_prob = opt<double>(\"missing_prob\", 0.0);\n\n    vector<int> a(n);\n\n    if (type == \"all_missing\") {\n        for(int i = 0; i < n; ++i) a[i] = -1;\n    } else if (type == \"single_arithmetic\") {\n        // Generates a sequence that's a single arithmetic progression\n        int start = rnd.next(1, max_value);\n        int diff = rnd.next(-1000, 1000);\n        if (diff == 0) diff = 1; // ensure difference is not zero\n        for(int i = 0; i < n; ++i) {\n            long long val = 1LL*start + 1LL*i*diff;\n            while (val <= 0 || val > max_value) {\n                // Adjust diff to ensure val is within range\n                diff = rnd.next(-1000, 1000);\n                if (diff == 0) diff = 1;\n                val = 1LL*start + 1LL*i*diff;\n            }\n            a[i] = (int)val;\n            if (rnd.next(0.0, 1.0) < missing_prob) a[i] = -1;\n        }\n    } else if (type == \"multiple_arithmetics\") {\n        // Break sequence into several arithmetic progressions\n        int k = opt<int>(\"k\", 1);\n        int segment_length = n / k;\n        int rem = n % k;\n        int idx = 0;\n        for(int seg = 0; seg < k; ++seg) {\n            int len = segment_length + (seg < rem ? 1 : 0);\n            int start = rnd.next(1, max_value);\n            int diff = rnd.next(-1000, 1000);\n            if (diff == 0) diff = 1;\n            for(int i = 0; i < len; ++i) {\n                long long val = 1LL*start + 1LL*i*diff;\n                while (val <= 0 || val > max_value) {\n                    diff = rnd.next(-1000, 1000);\n                    if (diff == 0) diff = 1;\n                    val = 1LL*start + 1LL*i*diff;\n                }\n                a[idx] = (int)val;\n                if (rnd.next(0.0, 1.0) < missing_prob) a[idx] = -1;\n                idx++;\n            }\n        }\n    } else if (type == \"max_arithmetics\") {\n        // Generate sequence where minimal number of arithmetics is as big as possible\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_value);\n            if (rnd.next(0.0,1.0) < missing_prob) a[i] = -1;\n        }\n        // Ensure no three consecutive known numbers are in arithmetic progression\n        for(int i = 2; i < n; ++i) {\n            if (a[i-2] != -1 && a[i-1] != -1 && a[i] != -1) {\n                if (2LL*a[i-1] == a[i-2] + a[i]) {\n                    // Adjust a[i] to break the progression\n                    a[i] = (a[i]+1 <= max_value) ? a[i]+1 : a[i]-1;\n                    if (a[i] <= 0) a[i] = 1;\n                }\n            }\n        }\n    } else if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_value);\n            if (rnd.next(0.0,1.0) < missing_prob) a[i] = -1;\n        }\n    } else if (type == \"alternating_missing\") {\n        for(int i = 0; i < n; ++i) {\n            if (i%2==0) {\n                a[i] = -1;\n            } else {\n                a[i] = rnd.next(1, max_value);\n            }\n        }\n    } else if (type == \"heavy_missing\") {\n        for(int i = 0; i < n; ++i) {\n            if (rnd.next(0.0,1.0) < 0.9) a[i]=-1;\n            else a[i]= rnd.next(1, max_value);\n        }\n    } else if (type == \"single_value\") {\n        int val = rnd.next(1, max_value);\n        for(int i = 0; i < n; ++i) {\n            a[i] = val;\n            if (rnd.next(0.0,1.0) < missing_prob) a[i] = -1;\n        }\n    } else if (type == \"large_diff_arithmetic\") {\n        // Generate arithmetic progression with large differences\n        int start = rnd.next(1, max_value);\n        int diff = rnd.next(-max_value+1, max_value-1);\n        if (diff == 0) diff = 1;\n        for(int i = 0; i < n; ++i) {\n            long long val = 1LL*start + 1LL*i*diff;\n            while (val <= 0 || val > max_value) {\n                diff = rnd.next(-max_value+1, max_value-1);\n                if (diff == 0) diff = 1;\n                val = 1LL*start + 1LL*i*diff;\n            }\n            a[i] = (int)val;\n            if (rnd.next(0.0,1.0) < missing_prob) a[i]=-1;\n        }\n    } else if (type == \"repeating_pattern\") {\n        int pattern_length = opt<int>(\"pattern_length\", 5);\n        vector<int> pattern(pattern_length);\n        for(int i = 0; i < pattern_length; ++i) {\n            pattern[i] = rnd.next(1, max_value);\n        }\n        for(int i = 0; i < n; ++i) {\n            a[i] = pattern[i % pattern_length];\n            if (rnd.next(0.0,1.0) < missing_prob) a[i]=-1;\n        }\n    } else {\n        // By default, generate random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_value);\n            if (rnd.next(0.0,1.0) < missing_prob) a[i] = -1;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the sequence\n    for(int i=0; i<n; i++) {\n        printf(\"%d%c\", a[i], (i==n-1)?'\\n':' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type all_missing\n./gen -n 1 -type single_arithmetic\n\n./gen -n 10 -type random\n./gen -n 10 -type single_arithmetic\n./gen -n 10 -type multiple_arithmetics -k 3\n./gen -n 10 -type all_missing\n./gen -n 10 -type alternating_missing\n./gen -n 10 -type heavy_missing\n./gen -n 10 -type max_arithmetics\n\n./gen -n 1000 -type random\n./gen -n 1000 -type single_arithmetic\n./gen -n 1000 -type multiple_arithmetics -k 10\n./gen -n 1000 -type all_missing\n./gen -n 1000 -type alternating_missing\n./gen -n 1000 -type heavy_missing\n./gen -n 1000 -type max_arithmetics\n\n./gen -n 100000 -type random\n./gen -n 100000 -type single_arithmetic\n./gen -n 100000 -type multiple_arithmetics -k 1000\n./gen -n 100000 -type all_missing\n./gen -n 100000 -type alternating_missing\n./gen -n 100000 -type heavy_missing -missing_prob 0.95\n./gen -n 100000 -type max_arithmetics\n\n./gen -n 200000 -type random\n./gen -n 200000 -type single_arithmetic\n./gen -n 200000 -type multiple_arithmetics -k 2000\n./gen -n 200000 -type all_missing\n./gen -n 200000 -type alternating_missing\n./gen -n 200000 -type heavy_missing -missing_prob 0.99\n./gen -n 200000 -type max_arithmetics\n\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 2 -type single_arithmetic\n./gen -n 2 -type max_arithmetics\n\n./gen -n 50000 -type repeating_pattern -pattern_length 1\n./gen -n 50000 -type repeating_pattern -pattern_length 2\n./gen -n 50000 -type repeating_pattern -pattern_length 5\n\n./gen -n 100000 -type large_diff_arithmetic\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:54.316091",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "416/E",
      "title": "E. President's Path",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integers n, m (2 ≤ n ≤ 500, 0 ≤ m ≤ n·(n - 1) / 2) — the number of cities and roads, correspondingly. Then m lines follow, containing the road descriptions, one description per line. Each description contains three integers xi, yi, li (1 ≤ xi, yi ≤ n, xi ≠ yi, 1 ≤ li ≤ 106), where xi, yi are the numbers of the cities connected by the i-th road and li is its length.",
      "output_spec": "OutputPrint the sequence of  integers c12, c13, ..., c1n, c23, c24, ..., c2n, ..., cn - 1, n, where cst is the number of roads that can lie on the shortest path from s to t. Print the elements of sequence c in the described order. If the pair of cities s and t don't have a path between them, then cst = 0.",
      "sample_tests": "ExamplesInputCopy5 61 2 12 3 13 4 14 1 12 4 24 5 4OutputCopy1 4 1 2 1 5 6 1 2 1",
      "description": "E. President's Path\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integers n, m (2 ≤ n ≤ 500, 0 ≤ m ≤ n·(n - 1) / 2) — the number of cities and roads, correspondingly. Then m lines follow, containing the road descriptions, one description per line. Each description contains three integers xi, yi, li (1 ≤ xi, yi ≤ n, xi ≠ yi, 1 ≤ li ≤ 106), where xi, yi are the numbers of the cities connected by the i-th road and li is its length.\n\nOutputPrint the sequence of  integers c12, c13, ..., c1n, c23, c24, ..., c2n, ..., cn - 1, n, where cst is the number of roads that can lie on the shortest path from s to t. Print the elements of sequence c in the described order. If the pair of cities s and t don't have a path between them, then cst = 0.\n\nInputCopy5 61 2 12 3 13 4 14 1 12 4 24 5 4OutputCopy1 4 1 2 1 5 6 1 2 1\n\nInputCopy5 61 2 12 3 13 4 14 1 12 4 24 5 4\n\nOutputCopy1 4 1 2 1 5 6 1 2 1",
      "solutions": [
        {
          "title": "Codeforces Round #241 (Div. 2) - Codeforces",
          "content": "The round will start on 08:00 (UTC) of April, 13. It will be a kind of unusual round because at first for a long time Gerald didn't work much on round. It was prepared by me (how it is interesting to write a round!), Nerevar with the help of Gerald and Fefer_Ivan-а. Maria, many thanks for translations!It will be classical points: 500 — 1000 — 1500 — 2000 — 2500.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/11623",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 364
        },
        {
          "title": "Codeforces Round #241 — editorial - Codeforces",
          "content": "416A - Guess a number!Let's use the usual Div 2 problem A approach — the naive one. We will track the interval which might contain the number we're guessing. With each of the query we update this interval. If at the end the interval is non-empty then we output any number from it, otherwise the result is \"Impossible\".Submission: 6606892416B - Art UnionAll we need is to iterate over all painters and for each painter to iterate over all pictures. In the inner loop we also remember when the painter finished working on the picture to make sure that the next painter will not start working on it earlier.Submission: 6606994416C - Booking SystemLet's solve this one greedy. All we need to notice is that the optimal solution will be to place first the groups with biggest sum which they are ready to pay. For each such group it will be optimal to allocate the smallest matching table. The input limits allow to do a full search when looking for a table.Submission: 6617198416D - Population SizeOne thing to notice for this problem is that if we cover some interval with a progression then it will better (at least no worse) to include as many elements to the right of it as possible. So the solution is to greedy — find the leftmost number not covered by a progression, start a new progression with that number (the interval covered by that progression will be of size 1) and then try to extend this interval to the right as far as possible. Repeat this step until all the numbers are covered. One thing you should pay attention to is which numbers can be covered by one arithmetic progression, for example: If there are no fixed numbers in the interval then we can cover it with one progression. If there is only one non-fixed number in the interval then we can cover this interval with one progression. If there are more than one non-fixed numbers in the interval then we can calculate the parameters of the progression (start value and difference). All non-fixed numbers should match those parameters. Difference should be integer. If the progression is ascending and there are some non-fixed numbers in the beginning then those numbers should match positive numbers in the progression. Same way if the progression is descending then we can include numbers from the right side only while matching progression term is positive. Submission: 6607174416E - President's PathLet's look at the graph given to us in the example:We need to count the count of the edges on all the shortest paths between each pair of vertices. Let's do something easier first — instead of counting all the edges we will count only those which have the destination vertex on its side. For example here are the edges belonging to shortest paths from 4 to 2 which are connected to vertex 2: Let's denote this number like this: inEdgessource, v — number of edges which go into vertex v on some shortest path from source to v. In the given example inEdges4, 2 = 3. Let's also denote the set Ssource, dest — it is a set of the vertices which belong to at least one shortest path from source to dest. For example S4, 2 = {1, 2, 3, 4}. With these two variables it can be seen that the answer for vertices source and dest will be: In other words the answer for vertices s and d will be equal to the sum of inEdgess, v for all vertices v, which belong to any shortest path from s to d. So the only thing left is to calculate these S and inEdges. Both of them can be easily calculated if you have minimum distances between all pairs of vertices. And these distances can be calculated using the Floyd-Warshall. So the full solution is: Calculate minimum distances between all pairs of vertices using Floyd-Warshall algorithm. Count inEdges. Simply iterate over all source vertices and all edges. For each edge check whether any of its ends belong to any shortest path from source. Calculate the answer. Let's have three loops to iterate over the vertices — — source, destination и mid. First two vertices are those for which we're calculating the answer. Third vertex is the vertex which should belong to any shortest path (basically we're checking whether v belongs to Ssource, dest). If mid belongs to any shortest path from source to dest then we add inEdgessource, mid to the answer. Each step has a complexity O(n3).Submission: 6607257P.S.: Please feel free to let me know about any typos, errors, etc using the private messages.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/12277",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 416\\s*E"
          },
          "content_length": 4397
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int maxm = n * (n - 1) / 2;\n    int m = inf.readInt(0, maxm, \"m\");\n    inf.readEoln();\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000000, \"li\");\n        inf.readEoln();\n        ensuref(xi != yi, \"Road %d connects a city to itself (%d)\", i + 1, xi);\n        int a = min(xi, yi);\n        int b = max(xi, yi);\n        pair<int, int> edge = make_pair(a, b);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between cities %d and %d\", a, b);\n        edges.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int maxm = n * (n - 1) / 2;\n    int m = inf.readInt(0, maxm, \"m\");\n    inf.readEoln();\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000000, \"li\");\n        inf.readEoln();\n        ensuref(xi != yi, \"Road %d connects a city to itself (%d)\", i + 1, xi);\n        int a = min(xi, yi);\n        int b = max(xi, yi);\n        pair<int, int> edge = make_pair(a, b);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between cities %d and %d\", a, b);\n        edges.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 500, \"n\");\n    inf.readSpace();\n    int maxm = n * (n - 1) / 2;\n    int m = inf.readInt(0, maxm, \"m\");\n    inf.readEoln();\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000000, \"li\");\n        inf.readEoln();\n        ensuref(xi != yi, \"Road %d connects a city to itself (%d)\", i + 1, xi);\n        int a = min(xi, yi);\n        int b = max(xi, yi);\n        pair<int, int> edge = make_pair(a, b);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between cities %d and %d\", a, b);\n        edges.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\"); // default is random\n    int m = -1; // We'll set m based on the type\n\n    int fixed_weight = opt<int>(\"fixed_weight\", -1); // Default is -1, meaning weights are random.\n\n    vector<pair<int,int>> edges;\n    vector<int> weights;\n\n    if (type == \"random\") {\n        m = opt<int>(\"m\");\n        if (m > n * (n - 1) / 2 || m < 0) {\n            fprintf(stderr, \"Invalid m: %d\\n\", m);\n            return 1;\n        }\n\n        set<pair<int,int>> edgeSet;\n        while ((int)edgeSet.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edgeSet.count(make_pair(u, v)) == 0) {\n                edgeSet.insert(make_pair(u, v));\n                edges.push_back(make_pair(u, v));\n            }\n        }\n\n    } else if (type == \"chain\") {\n        m = n - 1;\n        for (int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(i, i+1));\n        }\n    } else if (type == \"star\") {\n        m = n - 1;\n        int center = 1; // You can change to rnd.next(1, n) if you want random center\n        for (int i = 1; i <= n; ++i) {\n            if (i != center) {\n                edges.push_back(make_pair(center, i));\n            }\n        }\n    } else if (type == \"complete\") {\n        m = n * (n - 1) / 2;\n        for (int u = 1; u <= n; ++u) {\n            for (int v = u + 1; v <= n; ++v) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else if (type == \"disconnected\") {\n        // Create two separate components\n        int n1 = n / 2;\n        int n2 = n - n1;\n        // First component: nodes 1 to n1\n        for (int i = 1; i < n1; ++i) {\n            edges.push_back(make_pair(i, i+1));\n        }\n        // Second component: nodes n1+1 to n\n        for (int i = n1+1; i < n; ++i) {\n            edges.push_back(make_pair(i, i+1));\n        }\n        m = edges.size();\n    } else if (type == \"equal_weights\") {\n        m = opt<int>(\"m\");\n        if (m < n - 1 || m > n * (n - 1) / 2) {\n            fprintf(stderr, \"Invalid m: %d\\n\", m);\n            return 1;\n        }\n        // Generate a random connected graph with n nodes and m edges\n        set<pair<int,int>> edgeSet;\n        vector<int> nodes(n);\n        for (int i = 0; i < n; ++i) nodes[i] = i + 1;\n        shuffle(nodes.begin(), nodes.end());\n        for (int i = 1; i < n; ++i) {\n            int u = nodes[i - 1];\n            int v = nodes[i];\n            if (u > v) swap(u, v);\n            edgeSet.insert(make_pair(u, v));\n            edges.push_back(make_pair(u, v));\n        }\n        while ((int)edgeSet.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edgeSet.count(make_pair(u, v)) == 0) {\n                edgeSet.insert(make_pair(u, v));\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Assign weights to edges\n    for (int i = 0; i < m; ++i) {\n        int w;\n        if (fixed_weight != -1) {\n            w = fixed_weight;\n        } else {\n            w = rnd.next(1, 1000000);\n        }\n        weights.push_back(w);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output edges\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %d\\n\", edges[i].first, edges[i].second, weights[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\"); // default is random\n    int m = -1; // We'll set m based on the type\n\n    int fixed_weight = opt<int>(\"fixed_weight\", -1); // Default is -1, meaning weights are random.\n\n    vector<pair<int,int>> edges;\n    vector<int> weights;\n\n    if (type == \"random\") {\n        m = opt<int>(\"m\");\n        if (m > n * (n - 1) / 2 || m < 0) {\n            fprintf(stderr, \"Invalid m: %d\\n\", m);\n            return 1;\n        }\n\n        set<pair<int,int>> edgeSet;\n        while ((int)edgeSet.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edgeSet.count(make_pair(u, v)) == 0) {\n                edgeSet.insert(make_pair(u, v));\n                edges.push_back(make_pair(u, v));\n            }\n        }\n\n    } else if (type == \"chain\") {\n        m = n - 1;\n        for (int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(i, i+1));\n        }\n    } else if (type == \"star\") {\n        m = n - 1;\n        int center = 1; // You can change to rnd.next(1, n) if you want random center\n        for (int i = 1; i <= n; ++i) {\n            if (i != center) {\n                edges.push_back(make_pair(center, i));\n            }\n        }\n    } else if (type == \"complete\") {\n        m = n * (n - 1) / 2;\n        for (int u = 1; u <= n; ++u) {\n            for (int v = u + 1; v <= n; ++v) {\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else if (type == \"disconnected\") {\n        // Create two separate components\n        int n1 = n / 2;\n        int n2 = n - n1;\n        // First component: nodes 1 to n1\n        for (int i = 1; i < n1; ++i) {\n            edges.push_back(make_pair(i, i+1));\n        }\n        // Second component: nodes n1+1 to n\n        for (int i = n1+1; i < n; ++i) {\n            edges.push_back(make_pair(i, i+1));\n        }\n        m = edges.size();\n    } else if (type == \"equal_weights\") {\n        m = opt<int>(\"m\");\n        if (m < n - 1 || m > n * (n - 1) / 2) {\n            fprintf(stderr, \"Invalid m: %d\\n\", m);\n            return 1;\n        }\n        // Generate a random connected graph with n nodes and m edges\n        set<pair<int,int>> edgeSet;\n        vector<int> nodes(n);\n        for (int i = 0; i < n; ++i) nodes[i] = i + 1;\n        shuffle(nodes.begin(), nodes.end());\n        for (int i = 1; i < n; ++i) {\n            int u = nodes[i - 1];\n            int v = nodes[i];\n            if (u > v) swap(u, v);\n            edgeSet.insert(make_pair(u, v));\n            edges.push_back(make_pair(u, v));\n        }\n        while ((int)edgeSet.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edgeSet.count(make_pair(u, v)) == 0) {\n                edgeSet.insert(make_pair(u, v));\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Assign weights to edges\n    for (int i = 0; i < m; ++i) {\n        int w;\n        if (fixed_weight != -1) {\n            w = fixed_weight;\n        } else {\n            w = rnd.next(1, 1000000);\n        }\n        weights.push_back(w);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output edges\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d %d\\n\", edges[i].first, edges[i].second, weights[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type chain\n./gen -n 2 -type star\n./gen -n 2 -type complete\n./gen -n 2 -type disconnected\n./gen -n 2 -type random -m 1\n\n./gen -n 3 -type chain\n./gen -n 3 -type star\n./gen -n 3 -type complete\n./gen -n 3 -type disconnected\n./gen -n 3 -type random -m 2\n\n./gen -n 5 -type random -m 0\n\n./gen -n 10 -type chain\n./gen -n 10 -type chain -fixed_weight 1000000\n./gen -n 10 -type star\n./gen -n 10 -type star -fixed_weight 1\n./gen -n 10 -type complete\n./gen -n 10 -type complete -fixed_weight 1000000\n./gen -n 10 -type disconnected\n./gen -n 10 -type equal_weights -m 15\n./gen -n 10 -type random -m 15\n\n./gen -n 50 -type chain\n./gen -n 50 -type star\n./gen -n 50 -type complete\n./gen -n 50 -type disconnected\n./gen -n 50 -type equal_weights -m 100\n./gen -n 50 -type random -m 100 -fixed_weight 1000000\n\n./gen -n 100 -type chain\n./gen -n 100 -type star\n./gen -n 100 -type complete\n./gen -n 100 -type disconnected\n./gen -n 100 -type equal_weights -m 500\n./gen -n 100 -type random -m 500 -fixed_weight 1\n\n./gen -n 200 -type chain\n./gen -n 200 -type star\n./gen -n 200 -type complete\n./gen -n 200 -type disconnected\n./gen -n 200 -type equal_weights -m 1000\n./gen -n 200 -type random -m 1000\n\n./gen -n 500 -type chain\n./gen -n 500 -type star\n./gen -n 500 -type complete\n./gen -n 500 -type disconnected\n./gen -n 500 -type equal_weights -m 10000\n./gen -n 500 -type random -m 124750\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:56.083477",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "417/A",
      "title": "A. Elimination",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers c and d (1 ≤ c, d ≤ 100) — the number of problems in the main and additional rounds, correspondingly. The second line contains two integers n and m (1 ≤ n, m ≤ 100). Finally, the third line contains an integer k (1 ≤ k ≤ 100) — the number of the pre-chosen winners.",
      "output_spec": "OutputIn the first line, print a single integer — the minimum number of problems the jury needs to prepare.",
      "sample_tests": "ExamplesInputCopy1 107 21OutputCopy2InputCopy2 22 12OutputCopy0",
      "description": "A. Elimination\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers c and d (1 ≤ c, d ≤ 100) — the number of problems in the main and additional rounds, correspondingly. The second line contains two integers n and m (1 ≤ n, m ≤ 100). Finally, the third line contains an integer k (1 ≤ k ≤ 100) — the number of the pre-chosen winners.\n\nOutputIn the first line, print a single integer — the minimum number of problems the jury needs to prepare.\n\nInputCopy1 107 21OutputCopy2InputCopy2 22 12OutputCopy0\n\nInputCopy1 107 21\n\nOutputCopy2\n\nInputCopy2 22 12\n\nOutputCopy0",
      "solutions": [
        {
          "title": "RCC 2014 Warmup - Codeforces",
          "content": "Russian Code Cup is a competition organized by Mail.Ru Group for Russian-speaking programmers. This year the competition will run for the fourth time to gather top 50 to great finals in Moscow in October.Though Russian Code Cup is open only for those who speak Russian, the team that is working on problems for Russian Code Cup has decided to make a present to all CodeForces users and set up an extra round for everyone.The round will be held on April 17 at 19-30 Moscow time. The round will be open for everyone and will have both div-1 and div-2 tasks. It will use standard CodeForces rules. The writer of most problems is Aksenov239 — author of many Russian Code Cup problems.We wish all participants good luck and see you on Thursday at http://codeforces.comUPD: Score for problems: Div1: 500-1000-1500-2500-2500, Div2: 500-1000-1500-2000-2500. Good luck!",
          "author": "andrewzta",
          "url": "https://codeforces.com/blog/entry/11632",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 860
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces",
          "content": "I want to say thanks to whom can help me to make this round: for testing pashka and cerealguy, for problems chavit and enot110 and andrewzta for supervising.417A - Elimination. Author and realization Aksenov239.The first thing, that you need to mention, is that if k ≤ n·m, then the answer is equal to 0. After that you need to take at least n·m - k people. There's three possibilities to do that: To consider only main rounds: . To take additional rounds to the number, which is divisible by n: . To take only rounds of the second type: d(n·m - k). Also in this problem it is possible to write the solution, which check every possible combinations of the numbers of main and elimination rounds.Solution: 6396283417B - Crash. Author and realization Aksenov239.Let us create array a with 105 elements, which is filled with  - 1. In the cell a[k] we will contain the maximal number of the submissions of the participant with identifier k. We will process submissions in the given order. Let us process submission x k. If a[k] < x - 1, then the answer is NO, else we will update array a: a[k] = max(a[k], x).Solution: 6396297418A - Football. Author and realization Aksenov239.Let's consider this tournir as graph. Each vertex should have out-degree k. Then the graph should contain exactly nk edges. But the full-graph contains , because of that if n < 2k + 1 then the answer is  - 1, otherwise we will connect the i-th vertex with i + 1, ..., i + k, taking modulo n if needed.Solution: 6396331418B - Cunning Gena. Author and realization Aksenov239.Let us sort the friends by the number of the monitors in the increasing order. Afterwards we will calculate the dp on the masks: the minimal amount of money Gena should spend to solve some subset of problems, if we take first n friends. Then the answer we should compare with the answer for first i friends plus the number of the monitors, which the i-th friend needs. Is is not hard to see, that if we consider the friends in this order consequently, then we can recalc dp like in the knapsack problem. The running time of this algorithm is O(nlog(n) + n2m).Solution pashka: 6396347418C - Square Table. Author and realization Aksenov239.Let's build array of the length n for each n, that the sum of the squares of its elements is the square: If n = 1, then take [1]. If n = 2, then take [3, 4]. If n is even, then take . If n is odd, then take . We are given two numbers n and m. Let array a corresponds to n, and array b corresponds to m. The we will build the answer array c as follows cij = ai·bj.Solution: 6396358418D - Big Problems for Organizers. Author chavit, realization Aksenov239.This problem has two solutions.The first one. Let's hang the tree on some vertex. Afterwards, let us calculate for eah vertex it's height and 3 most distant vertices in its subtree. Also let's calculate arrays for the lowest common ancestors problem. For each vertex i and the power of two 2j we have p[i][j], up[i][j] and down[i][j]: p[i][j] is the ancestor on the distance of 2j, up[i][j] is equal to the longest path from i to the vertices, which are situated in subtrees of the vertices on the path between i and p[i][j]. down[i][j] is equal the same, but from the vertex p[i][j]. And the last part of this solution. Let us be given the query u v. Firstly, we find w = LCA(u, v). Afterwards, we need to find vertex hu, which is situated on the middle of the path between u and v. Really, we need to split the tree by this vertex, count the longest path from u in its tree and count the longest path from v in its tree. If we can imagine in the main tree, we can not delete this vertex, but with our precalculated arrays recalc this two values.First solution: 6396376The second solution. In a few words. Let's find the diameter of the tree. Precalc the answer for each vertices on the prefix. Then on the query we find two distant vertices on this diameter and the path. Obviously, diameter should contain the middle of the path, when we find it, using precalculated results on the prefixes and suffixes we can obtain the answer.Second solution cerealguy: 6396390418E - Tricky Password. Authors enot110, Aksenov239, realization Aksenov239.The key theoretical idea of this problem is that the $2$nd row is exactly the same as the $4$th row, $3$rd row is exactly the same as $5$th row and so on. Because of that we need only to answer queries on the first three rows.Let's move on to the practical part. In the first place we will compress coordinates, that any value will not exceed 2·105. Afterwards, let's split the array into parts of the length LEN. On each part we will calculate the following values: cnt[k] — the number of occurences of the number k on this prefix, also f[k] — the total number of the values, which occur exactly k times on this prefix. Array f we will store in the Fenwick data structure.It is not hard to see, that array cnt contains the answer for the queries to the 2nd row. To get the answer for the queries to the 3rd row we need to calculate f[cnt[k]... 105]. Also it's quite understandable how to recalc this dp.In summary, we will get per query. And we take , then we will get per query. Solution: 6396412",
          "author": "Aksenov239",
          "url": "https://codeforces.com/blog/entry/11730",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 417\\s*A"
          },
          "content_length": 5178
        }
      ],
      "code_examples": [
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 3",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 4",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 5",
          "code": "cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 6",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 7",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 8",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 9",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 10",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 11",
          "code": "printf(\"%d\", x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 12",
          "code": "n*i+j>=n*m-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int c = inf.readInt(1, 100, \"c\");\n    inf.readSpace();\n    int d = inf.readInt(1, 100, \"d\");\n    inf.readEoln();\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int c = inf.readInt(1, 100, \"c\");\n    inf.readSpace();\n    int d = inf.readInt(1, 100, \"d\");\n    inf.readEoln();\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int c = inf.readInt(1, 100, \"c\");\n    inf.readSpace();\n    int d = inf.readInt(1, 100, \"d\");\n    inf.readEoln();\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int c = opt<int>(\"c\", -1);\n    int d = opt<int>(\"d\", -1);\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    int k = opt<int>(\"k\", -1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate random values if not provided\n    if (c == -1)\n        c = rnd.next(1, 100);\n    if (d == -1)\n        d = rnd.next(1, 100);\n    if (n == -1)\n        n = rnd.next(1, 100);\n    if (m == -1)\n        m = rnd.next(1, 100);\n    if (k == -1)\n        k = rnd.next(1, 100);\n\n    if (type == \"minimal\") {\n        c = 1;\n        d = 1;\n        n = 1;\n        m = 1;\n        k = 1;\n    } else if (type == \"maximal\") {\n        c = 100;\n        d = 100;\n        n = 100;\n        m = 100;\n        k = 100;\n    } else if (type == \"c_equals_d\") {\n        c = rnd.next(1, 100);\n        d = c;\n    } else if (type == \"n_equals_m\") {\n        n = rnd.next(1, 100);\n        m = n;\n    } else if (type == \"k_equals_nm\") {\n        n = rnd.next(1, 100);\n        m = rnd.next(1, 100);\n        k = n * m;\n        if (k > 100) k = 100; // Since k ≤ 100\n    } else if (type == \"k_max\") {\n        k = 100;\n    } else if (type == \"k_min\") {\n        k = 1;\n    } else if (type == \"special\") {\n        // Special case\n        c = 1;\n        d = 100;\n        n = 1;\n        m = 100;\n        k = 1;\n    } else if (type == \"random\") {\n        // Values are already set randomly\n    }\n\n    // Output c and d\n    printf(\"%d %d\\n\", c, d);\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output k\n    printf(\"%d\\n\", k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int c = opt<int>(\"c\", -1);\n    int d = opt<int>(\"d\", -1);\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    int k = opt<int>(\"k\", -1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate random values if not provided\n    if (c == -1)\n        c = rnd.next(1, 100);\n    if (d == -1)\n        d = rnd.next(1, 100);\n    if (n == -1)\n        n = rnd.next(1, 100);\n    if (m == -1)\n        m = rnd.next(1, 100);\n    if (k == -1)\n        k = rnd.next(1, 100);\n\n    if (type == \"minimal\") {\n        c = 1;\n        d = 1;\n        n = 1;\n        m = 1;\n        k = 1;\n    } else if (type == \"maximal\") {\n        c = 100;\n        d = 100;\n        n = 100;\n        m = 100;\n        k = 100;\n    } else if (type == \"c_equals_d\") {\n        c = rnd.next(1, 100);\n        d = c;\n    } else if (type == \"n_equals_m\") {\n        n = rnd.next(1, 100);\n        m = n;\n    } else if (type == \"k_equals_nm\") {\n        n = rnd.next(1, 100);\n        m = rnd.next(1, 100);\n        k = n * m;\n        if (k > 100) k = 100; // Since k ≤ 100\n    } else if (type == \"k_max\") {\n        k = 100;\n    } else if (type == \"k_min\") {\n        k = 1;\n    } else if (type == \"special\") {\n        // Special case\n        c = 1;\n        d = 100;\n        n = 1;\n        m = 100;\n        k = 1;\n    } else if (type == \"random\") {\n        // Values are already set randomly\n    }\n\n    // Output c and d\n    printf(\"%d %d\\n\", c, d);\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output k\n    printf(\"%d\\n\", k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type minimal\n./gen -type maximal\n./gen -c 1 -d 1 -n 1 -m 1 -k 1\n./gen -c 100 -d 100 -n 100 -m 100 -k 100\n./gen -type random\n./gen -type c_equals_d\n./gen -type n_equals_m\n./gen -type k_equals_nm\n./gen -type k_max\n./gen -type k_min\n./gen -type special\n\n# Random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Specific test cases\n./gen -c 1 -d 100 -n 100 -m 1 -k 1\n./gen -c 100 -d 1 -n 1 -m 100 -k 1\n./gen -c 50 -d 50 -n 25 -m 4 -k 100\n./gen -c 2 -d 2 -n 2 -m 1 -k 2\n./gen -c 1 -d 10 -n 7 -m 2 -k 1\n\n# Edge cases\n./gen -c 1 -d 1 -n 100 -m 100 -k 100\n./gen -c 100 -d 100 -n 1 -m 1 -k 1\n\n# Special combinations\n./gen -c 1 -d 100 -n 1 -m 100 -k 1\n./gen -c 100 -d 1 -n 100 -m 1 -k 100\n\n# Testing when c < d\n./gen -c 10 -d 90 -n 50 -m 2 -k 10\n\n# Testing when c > d\n./gen -c 90 -d 10 -n 2 -m 50 -k 10\n\n# k equals maximum allowed\n./gen -c 10 -d 10 -n 5 -m 5 -k 100\n\n# Edge case with k = 1\n./gen -c 20 -d 15 -n 7 -m 8 -k 1\n\n# Random test cases with explicit values\n./gen -c 37 -d 84 -n 28 -m 67 -k 42\n./gen -c 65 -d 91 -n 13 -m 57 -k 98\n./gen -c 2 -d 99 -n 88 -m 16 -k 73\n\n# Another special case\n./gen -c 50 -d 50 -n 100 -m 100 -k 1\n\n# Finally\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:24:57.998679",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "417/B",
      "title": "B. Crash",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains an integer n (1 ≤ n ≤ 105) — the number of solutions. Each of the following n lines contains two integers separated by space x and k (0 ≤ x ≤ 105; 1 ≤ k ≤ 105) — the number of previous unique solutions and the identifier of the participant.",
      "output_spec": "OutputA single line of the output should contain «YES» if the data is in chronological order, and «NO» otherwise.",
      "sample_tests": "ExamplesInputCopy20 11 1OutputCopyYESInputCopy40 11 21 10 2OutputCopyNOInputCopy40 11 10 10 2OutputCopyYES",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains an integer n (1 ≤ n ≤ 105) — the number of solutions. Each of the following n lines contains two integers separated by space x and k (0 ≤ x ≤ 105; 1 ≤ k ≤ 105) — the number of previous unique solutions and the identifier of the participant.\n\nOutputA single line of the output should contain «YES» if the data is in chronological order, and «NO» otherwise.\n\nInputCopy20 11 1OutputCopyYESInputCopy40 11 21 10 2OutputCopyNOInputCopy40 11 10 10 2OutputCopyYES\n\nInputCopy20 11 1\n\nOutputCopyYES\n\nInputCopy40 11 21 10 2\n\nOutputCopyNO\n\nInputCopy40 11 10 10 2\n\nOutputCopyYES",
      "solutions": [
        {
          "title": "RCC 2014 Warmup - Codeforces",
          "content": "Russian Code Cup is a competition organized by Mail.Ru Group for Russian-speaking programmers. This year the competition will run for the fourth time to gather top 50 to great finals in Moscow in October.Though Russian Code Cup is open only for those who speak Russian, the team that is working on problems for Russian Code Cup has decided to make a present to all CodeForces users and set up an extra round for everyone.The round will be held on April 17 at 19-30 Moscow time. The round will be open for everyone and will have both div-1 and div-2 tasks. It will use standard CodeForces rules. The writer of most problems is Aksenov239 — author of many Russian Code Cup problems.We wish all participants good luck and see you on Thursday at http://codeforces.comUPD: Score for problems: Div1: 500-1000-1500-2500-2500, Div2: 500-1000-1500-2000-2500. Good luck!",
          "author": "andrewzta",
          "url": "https://codeforces.com/blog/entry/11632",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 860
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces",
          "content": "I want to say thanks to whom can help me to make this round: for testing pashka and cerealguy, for problems chavit and enot110 and andrewzta for supervising.417A - Elimination. Author and realization Aksenov239.The first thing, that you need to mention, is that if k ≤ n·m, then the answer is equal to 0. After that you need to take at least n·m - k people. There's three possibilities to do that: To consider only main rounds: . To take additional rounds to the number, which is divisible by n: . To take only rounds of the second type: d(n·m - k). Also in this problem it is possible to write the solution, which check every possible combinations of the numbers of main and elimination rounds.Solution: 6396283417B - Crash. Author and realization Aksenov239.Let us create array a with 105 elements, which is filled with  - 1. In the cell a[k] we will contain the maximal number of the submissions of the participant with identifier k. We will process submissions in the given order. Let us process submission x k. If a[k] < x - 1, then the answer is NO, else we will update array a: a[k] = max(a[k], x).Solution: 6396297418A - Football. Author and realization Aksenov239.Let's consider this tournir as graph. Each vertex should have out-degree k. Then the graph should contain exactly nk edges. But the full-graph contains , because of that if n < 2k + 1 then the answer is  - 1, otherwise we will connect the i-th vertex with i + 1, ..., i + k, taking modulo n if needed.Solution: 6396331418B - Cunning Gena. Author and realization Aksenov239.Let us sort the friends by the number of the monitors in the increasing order. Afterwards we will calculate the dp on the masks: the minimal amount of money Gena should spend to solve some subset of problems, if we take first n friends. Then the answer we should compare with the answer for first i friends plus the number of the monitors, which the i-th friend needs. Is is not hard to see, that if we consider the friends in this order consequently, then we can recalc dp like in the knapsack problem. The running time of this algorithm is O(nlog(n) + n2m).Solution pashka: 6396347418C - Square Table. Author and realization Aksenov239.Let's build array of the length n for each n, that the sum of the squares of its elements is the square: If n = 1, then take [1]. If n = 2, then take [3, 4]. If n is even, then take . If n is odd, then take . We are given two numbers n and m. Let array a corresponds to n, and array b corresponds to m. The we will build the answer array c as follows cij = ai·bj.Solution: 6396358418D - Big Problems for Organizers. Author chavit, realization Aksenov239.This problem has two solutions.The first one. Let's hang the tree on some vertex. Afterwards, let us calculate for eah vertex it's height and 3 most distant vertices in its subtree. Also let's calculate arrays for the lowest common ancestors problem. For each vertex i and the power of two 2j we have p[i][j], up[i][j] and down[i][j]: p[i][j] is the ancestor on the distance of 2j, up[i][j] is equal to the longest path from i to the vertices, which are situated in subtrees of the vertices on the path between i and p[i][j]. down[i][j] is equal the same, but from the vertex p[i][j]. And the last part of this solution. Let us be given the query u v. Firstly, we find w = LCA(u, v). Afterwards, we need to find vertex hu, which is situated on the middle of the path between u and v. Really, we need to split the tree by this vertex, count the longest path from u in its tree and count the longest path from v in its tree. If we can imagine in the main tree, we can not delete this vertex, but with our precalculated arrays recalc this two values.First solution: 6396376The second solution. In a few words. Let's find the diameter of the tree. Precalc the answer for each vertices on the prefix. Then on the query we find two distant vertices on this diameter and the path. Obviously, diameter should contain the middle of the path, when we find it, using precalculated results on the prefixes and suffixes we can obtain the answer.Second solution cerealguy: 6396390418E - Tricky Password. Authors enot110, Aksenov239, realization Aksenov239.The key theoretical idea of this problem is that the $2$nd row is exactly the same as the $4$th row, $3$rd row is exactly the same as $5$th row and so on. Because of that we need only to answer queries on the first three rows.Let's move on to the practical part. In the first place we will compress coordinates, that any value will not exceed 2·105. Afterwards, let's split the array into parts of the length LEN. On each part we will calculate the following values: cnt[k] — the number of occurences of the number k on this prefix, also f[k] — the total number of the values, which occur exactly k times on this prefix. Array f we will store in the Fenwick data structure.It is not hard to see, that array cnt contains the answer for the queries to the 2nd row. To get the answer for the queries to the 3rd row we need to calculate f[cnt[k]... 105]. Also it's quite understandable how to recalc this dp.In summary, we will get per query. And we take , then we will get per query. Solution: 6396412",
          "author": "Aksenov239",
          "url": "https://codeforces.com/blog/entry/11730",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 417\\s*B"
          },
          "content_length": 5178
        }
      ],
      "code_examples": [
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 3",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 4",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 5",
          "code": "cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 6",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 7",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 8",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 9",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 10",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 11",
          "code": "printf(\"%d\", x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 12",
          "code": "n*i+j>=n*m-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        int x = inf.readInt(0, 100000, (\"x_\" + to_string(i)).c_str());\n        inf.readSpace();\n        int k = inf.readInt(1, 100000, (\"k_\" + to_string(i)).c_str());\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        int x = inf.readInt(0, 100000, (\"x_\" + to_string(i)).c_str());\n        inf.readSpace();\n        int k = inf.readInt(1, 100000, (\"k_\" + to_string(i)).c_str());\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        int x = inf.readInt(0, 100000, (\"x_\" + to_string(i)).c_str());\n        inf.readSpace();\n        int k = inf.readInt(1, 100000, (\"k_\" + to_string(i)).c_str());\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"valid_random\");\n    int p = opt<int>(\"p\", min(n, 1000));\n\n    // Ensure the number of participants is at least 1 and at most n\n    p = max(1, min(p, n));\n\n    // Participants are numbered from 1 to p\n    int total_submissions = 0;\n    vector<int> m_k(p + 1, 0); // m_k[k] is number of submissions for participant k\n\n    // Initialize m_k[k] to 1 for all k\n    for (int k = 1; k <= p; ++k) {\n        m_k[k] = 1;\n    }\n    total_submissions = p;\n\n    // Distribute remaining submissions\n    while (total_submissions < n) {\n        int k = rnd.next(1, p);\n        m_k[k]++;\n        total_submissions++;\n    }\n\n    // Prepare submissions for each participant\n    vector< vector< pair<int, int> > > submissions(p + 1);\n    for (int k = 1; k <= p; ++k) {\n        int x = 0;\n        for (int i = 0; i < m_k[k]; ++i) {\n            submissions[k].push_back(make_pair(x, k));\n            x++;\n        }\n    }\n\n    if (type == \"invalid_missing_x\") {\n        // For one participant, swap x = 0 and x = 1 submissions to violate the chronological order\n        vector<int> candidates;\n        for (int k = 1; k <= p; ++k) {\n            if (m_k[k] >= 2) candidates.push_back(k);\n        }\n        if (!candidates.empty()) {\n            int idx = rnd.next(0, (int)candidates.size() - 1);\n            int k = candidates[idx];\n            swap(submissions[k][0], submissions[k][1]);\n        }\n    } else if (type == \"invalid_no_prev_x\") {\n        // For one participant, remove x = 0 submission to create missing prior x\n        vector<int> candidates;\n        for (int k = 1; k <= p; ++k) {\n            if (m_k[k] >= 2) candidates.push_back(k);\n        }\n        if (!candidates.empty()) {\n            int idx = rnd.next(0, (int)candidates.size() - 1);\n            int k = candidates[idx];\n            submissions[k].erase(submissions[k].begin()); // Remove x = 0 submission\n            m_k[k]--;\n            total_submissions--;\n        }\n    }\n\n    // Merge submissions preserving order within each participant\n    vector<int> current_index(p + 1, 0); // current index for each participant\n    vector<int> participants_with_submissions;\n    for (int k = 1; k <= p; ++k) {\n        if (current_index[k] < (int)submissions[k].size()) {\n            participants_with_submissions.push_back(k);\n        }\n    }\n\n    vector< pair<int, int> > output_submissions;\n    while (!participants_with_submissions.empty()) {\n        int idx = rnd.next(0, (int)participants_with_submissions.size() - 1);\n        int k = participants_with_submissions[idx];\n        // Take next submission from participant k\n        output_submissions.push_back(submissions[k][current_index[k]]);\n        current_index[k]++;\n        if (current_index[k] >= (int)submissions[k].size()) {\n            // Remove k from participants_with_submissions\n            participants_with_submissions.erase(participants_with_submissions.begin() + idx);\n        }\n    }\n\n    // Output total_submissions (might be less than n if we removed submissions)\n    printf(\"%d\\n\", (int)output_submissions.size());\n    for (size_t i = 0; i < output_submissions.size(); ++i) {\n        printf(\"%d %d\\n\", output_submissions[i].first, output_submissions[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"valid_random\");\n    int p = opt<int>(\"p\", min(n, 1000));\n\n    // Ensure the number of participants is at least 1 and at most n\n    p = max(1, min(p, n));\n\n    // Participants are numbered from 1 to p\n    int total_submissions = 0;\n    vector<int> m_k(p + 1, 0); // m_k[k] is number of submissions for participant k\n\n    // Initialize m_k[k] to 1 for all k\n    for (int k = 1; k <= p; ++k) {\n        m_k[k] = 1;\n    }\n    total_submissions = p;\n\n    // Distribute remaining submissions\n    while (total_submissions < n) {\n        int k = rnd.next(1, p);\n        m_k[k]++;\n        total_submissions++;\n    }\n\n    // Prepare submissions for each participant\n    vector< vector< pair<int, int> > > submissions(p + 1);\n    for (int k = 1; k <= p; ++k) {\n        int x = 0;\n        for (int i = 0; i < m_k[k]; ++i) {\n            submissions[k].push_back(make_pair(x, k));\n            x++;\n        }\n    }\n\n    if (type == \"invalid_missing_x\") {\n        // For one participant, swap x = 0 and x = 1 submissions to violate the chronological order\n        vector<int> candidates;\n        for (int k = 1; k <= p; ++k) {\n            if (m_k[k] >= 2) candidates.push_back(k);\n        }\n        if (!candidates.empty()) {\n            int idx = rnd.next(0, (int)candidates.size() - 1);\n            int k = candidates[idx];\n            swap(submissions[k][0], submissions[k][1]);\n        }\n    } else if (type == \"invalid_no_prev_x\") {\n        // For one participant, remove x = 0 submission to create missing prior x\n        vector<int> candidates;\n        for (int k = 1; k <= p; ++k) {\n            if (m_k[k] >= 2) candidates.push_back(k);\n        }\n        if (!candidates.empty()) {\n            int idx = rnd.next(0, (int)candidates.size() - 1);\n            int k = candidates[idx];\n            submissions[k].erase(submissions[k].begin()); // Remove x = 0 submission\n            m_k[k]--;\n            total_submissions--;\n        }\n    }\n\n    // Merge submissions preserving order within each participant\n    vector<int> current_index(p + 1, 0); // current index for each participant\n    vector<int> participants_with_submissions;\n    for (int k = 1; k <= p; ++k) {\n        if (current_index[k] < (int)submissions[k].size()) {\n            participants_with_submissions.push_back(k);\n        }\n    }\n\n    vector< pair<int, int> > output_submissions;\n    while (!participants_with_submissions.empty()) {\n        int idx = rnd.next(0, (int)participants_with_submissions.size() - 1);\n        int k = participants_with_submissions[idx];\n        // Take next submission from participant k\n        output_submissions.push_back(submissions[k][current_index[k]]);\n        current_index[k]++;\n        if (current_index[k] >= (int)submissions[k].size()) {\n            // Remove k from participants_with_submissions\n            participants_with_submissions.erase(participants_with_submissions.begin() + idx);\n        }\n    }\n\n    // Output total_submissions (might be less than n if we removed submissions)\n    printf(\"%d\\n\", (int)output_submissions.size());\n    for (size_t i = 0; i < output_submissions.size(); ++i) {\n        printf(\"%d %d\\n\", output_submissions[i].first, output_submissions[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Valid random test cases with small n\n./gen -n 1 -type valid_random -p 1\n./gen -n 5 -type valid_random -p 2\n./gen -n 10 -type valid_random -p 5\n\n# Valid random test cases with medium n\n./gen -n 100 -type valid_random -p 50\n./gen -n 1000 -type valid_random -p 100\n./gen -n 10000 -type valid_random -p 1000\n\n# Valid random test cases with large n\n./gen -n 100000 -type valid_random -p 1000\n./gen -n 100000 -type valid_random -p 10000\n./gen -n 100000 -type valid_random -p 100000\n\n# Invalid test cases where x values are misordered\n./gen -n 10 -type invalid_missing_x -p 5\n./gen -n 100 -type invalid_missing_x -p 20\n./gen -n 1000 -type invalid_missing_x -p 100\n\n# Invalid test cases where previous x values are missing\n./gen -n 10 -type invalid_no_prev_x -p 5\n./gen -n 100 -type invalid_no_prev_x -p 20\n./gen -n 1000 -type invalid_no_prev_x -p 100\n\n# Edge cases with minimal n\n./gen -n 1 -type valid_random -p 1\n./gen -n 2 -type invalid_missing_x -p 1\n\n# Edge cases with maximal n and minimal participants\n./gen -n 100000 -type valid_random -p 1\n./gen -n 100000 -type invalid_missing_x -p 1\n\n# Edge cases with maximal n and maximal participants\n./gen -n 100000 -type valid_random -p 100000\n./gen -n 100000 -type invalid_no_prev_x -p 100000\n\n# Test cases with p not specified (default value)\n./gen -n 50000 -type valid_random\n./gen -n 50000 -type invalid_missing_x\n\n# Additional test cases with various participants\n./gen -n 20000 -type valid_random -p 5000\n./gen -n 20000 -type invalid_no_prev_x -p 5000\n./gen -n 20000 -type invalid_missing_x -p 5000\n\n# Random large test cases\n./gen -n 99999 -type valid_random -p 9999\n./gen -n 99999 -type invalid_no_prev_x -p 9999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:00.079765",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}